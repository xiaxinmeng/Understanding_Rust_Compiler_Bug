{"sha": "791ccccddc18e83faa9963824112b14b3b1a93c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MWNjY2NkZGMxOGU4M2ZhYTk5NjM4MjQxMTJiMTRiM2IxYTkzYzI=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-19T16:50:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-19T16:50:00Z"}, "message": "Merge pull request #5 from rust-lang/master\n\nupdate from origin 2020-06-19", "tree": {"sha": "227579b6a22580e046493bb93b2adb946f9db021", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/227579b6a22580e046493bb93b2adb946f9db021"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/791ccccddc18e83faa9963824112b14b3b1a93c2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7Oy4CRBK7hj4Ov3rIwAAdHIIAAKkpg0Rjxevo6O2uJRCRa0Y\nyfSHVUjIl23JayaEO0zseGH8vB2GdlhYQc0nlJ3y4F3U+cQWudPKCnHuMe9m5dKS\nkVapT9ub8Dej5xHymZ1GebIaxtcLtEcjMz6dbAMd1+tTczw1RePb/e3NW4Kz1qIa\nTMeEpS5UiWECanIUgn95B6jySuH7rF9X5gCUJK03YZzhS1WR9V27+NRxJjDfQAz+\nHoibCv63MM6dapT9C9AB6uNSaLIYNpTwsxfYM+NAc1wSXoA1mZSm2B4F7MYNY5Fe\nEK4DaIbsqXuouOh/gBzrMZxcUBJ1T2SkBeI8hKCEaFHKUN0zlAyXjB/x1mWkpsY=\n=/L9y\n-----END PGP SIGNATURE-----\n", "payload": "tree 227579b6a22580e046493bb93b2adb946f9db021\nparent 7ef9eb321a0e3acf350af3866041ba75251d2884\nparent 72417d84fb51495a4f1d007fb2397a0b2609ab63\nauthor Rich Kadel <richkadel@google.com> 1592585400 -0700\ncommitter GitHub <noreply@github.com> 1592585400 -0700\n\nMerge pull request #5 from rust-lang/master\n\nupdate from origin 2020-06-19"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/791ccccddc18e83faa9963824112b14b3b1a93c2", "html_url": "https://github.com/rust-lang/rust/commit/791ccccddc18e83faa9963824112b14b3b1a93c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/791ccccddc18e83faa9963824112b14b3b1a93c2/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ef9eb321a0e3acf350af3866041ba75251d2884", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ef9eb321a0e3acf350af3866041ba75251d2884", "html_url": "https://github.com/rust-lang/rust/commit/7ef9eb321a0e3acf350af3866041ba75251d2884"}, {"sha": "72417d84fb51495a4f1d007fb2397a0b2609ab63", "url": "https://api.github.com/repos/rust-lang/rust/commits/72417d84fb51495a4f1d007fb2397a0b2609ab63", "html_url": "https://github.com/rust-lang/rust/commit/72417d84fb51495a4f1d007fb2397a0b2609ab63"}], "stats": {"total": 5797, "additions": 3915, "deletions": 1882}, "files": [{"sha": "f10d539d8296ba9cabffdf88cee33f47fecf1118", "filename": "Cargo.toml", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -42,6 +42,19 @@ debug-assertions = false\n debug = false\n debug-assertions = false\n \n+[profile.release.package.compiler_builtins]\n+# For compiler-builtins we always use a high number of codegen units.\n+# The goal here is to place every single intrinsic into its own object\n+# file to avoid symbol clashes with the system libgcc if possible. Note\n+# that this number doesn't actually produce this many object files, we\n+# just don't create more than this number of object files.\n+#\n+# It's a bit of a bummer that we have to pass this here, unfortunately.\n+# Ideally this would be specified through an env var to Cargo so Cargo\n+# knows how many CGUs are for this specific crate, but for now\n+# per-crate configuration isn't specifiable in the environment.\n+codegen-units = 10000\n+\n # We want the RLS to use the version of Cargo that we've got vendored in this\n # repository to ensure that the same exact version of Cargo is used by both the\n # RLS and the Cargo binary itself. The RLS depends on Cargo as a git repository"}, {"sha": "bc6760334170b5bd1bc63cdb1f507e2ab1acb5bb", "filename": "config.toml.example", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -209,7 +209,8 @@\n # Build the sanitizer runtimes\n #sanitizers = false\n \n-# Build the profiler runtime\n+# Build the profiler runtime (required when compiling with options that depend\n+# on this runtime, such as `-C profile-generate` or `-Z instrument-coverage`).\n #profiler = false\n \n # Indicates whether the native libraries linked into Cargo will be statically"}, {"sha": "969d16d11e81b7a578bbbcb769bf412a36da18ec", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -894,7 +894,7 @@ def bootstrap(help_triggered):\n     build.clean = args.clean\n \n     try:\n-        toml_path = args.config or 'config.toml'\n+        toml_path = os.getenv('RUST_BOOTSTRAP_CONFIG') or args.config or 'config.toml'\n         if not os.path.exists(toml_path):\n             toml_path = os.path.join(build.rust_root, toml_path)\n \n@@ -947,6 +947,7 @@ def bootstrap(help_triggered):\n     env[\"SRC\"] = build.rust_root\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     env[\"BOOTSTRAP_PYTHON\"] = sys.executable\n+    env[\"BOOTSTRAP_CONFIG\"] = toml_path\n     env[\"BUILD_DIR\"] = build.build_dir\n     env[\"RUSTC_BOOTSTRAP\"] = '1'\n     env[\"CARGO\"] = build.cargo()"}, {"sha": "58e4bef677efb56426746477c06c796606fda7b6", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -99,9 +99,21 @@ struct StepDescription {\n     name: &'static str,\n }\n \n+/// Collection of paths used to match a task rule.\n #[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq)]\n pub enum PathSet {\n+    /// A collection of individual paths.\n+    ///\n+    /// These are generally matched as a path suffix. For example, a\n+    /// command-line value of `libstd` will match if `src/libstd` is in the\n+    /// set.\n     Set(BTreeSet<PathBuf>),\n+    /// A \"suite\" of paths.\n+    ///\n+    /// These can match as a path suffix (like `Set`), or as a prefix. For\n+    /// example, a command-line value of `src/test/ui/abi/variadic-ffi.rs`\n+    /// will match `src/test/ui`. A command-line value of `ui` would also\n+    /// match `src/test/ui`.\n     Suite(PathBuf),\n }\n \n@@ -251,21 +263,33 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n-    // Unlike `krate` this will create just one pathset. As such, it probably shouldn't actually\n-    // ever be used, but as we transition to having all rules properly handle passing krate(...) by\n-    // actually doing something different for every crate passed.\n+    /// Indicates it should run if the command-line selects the given crate or\n+    /// any of its (local) dependencies.\n+    ///\n+    /// Compared to `krate`, this treats the dependencies as aliases for the\n+    /// same job. Generally it is preferred to use `krate`, and treat each\n+    /// individual path separately. For example `./x.py test src/liballoc`\n+    /// (which uses `krate`) will test just `liballoc`. However, `./x.py check\n+    /// src/liballoc` (which uses `all_krates`) will check all of `libtest`.\n+    /// `all_krates` should probably be removed at some point.\n     pub fn all_krates(mut self, name: &str) -> Self {\n         let mut set = BTreeSet::new();\n         for krate in self.builder.in_tree_crates(name) {\n-            set.insert(PathBuf::from(&krate.path));\n+            let path = krate.local_path(self.builder);\n+            set.insert(path);\n         }\n         self.paths.insert(PathSet::Set(set));\n         self\n     }\n \n+    /// Indicates it should run if the command-line selects the given crate or\n+    /// any of its (local) dependencies.\n+    ///\n+    /// `make_run` will be called separately for each matching command-line path.\n     pub fn krate(mut self, name: &str) -> Self {\n         for krate in self.builder.in_tree_crates(name) {\n-            self.paths.insert(PathSet::one(&krate.path));\n+            let path = krate.local_path(self.builder);\n+            self.paths.insert(PathSet::one(path));\n         }\n         self\n     }\n@@ -488,13 +512,19 @@ impl<'a> Builder<'a> {\n             should_run = (desc.should_run)(should_run);\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n+        let mut add_path = |path: &Path| {\n+            help.push_str(&format!(\"    ./x.py {} {}\\n\", subcommand, path.display()));\n+        };\n         for pathset in should_run.paths {\n-            if let PathSet::Set(set) = pathset {\n-                set.iter().for_each(|path| {\n-                    help.push_str(\n-                        format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str(),\n-                    )\n-                })\n+            match pathset {\n+                PathSet::Set(set) => {\n+                    for path in set {\n+                        add_path(&path);\n+                    }\n+                }\n+                PathSet::Suite(path) => {\n+                    add_path(&path.join(\"...\"));\n+                }\n             }\n         }\n         Some(help)"}, {"sha": "afcf0dcac7e55341e4764ce8a8ba513dd92a855b", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 112, "deletions": 52, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -23,7 +23,7 @@ use crate::builder::Cargo;\n use crate::dist;\n use crate::native;\n use crate::util::{exe, is_dylib, symlink_dir};\n-use crate::{Compiler, GitRepo, Mode};\n+use crate::{Compiler, DependencyType, GitRepo, Mode};\n \n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n@@ -74,6 +74,7 @@ impl Step for Std {\n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n             copy_third_party_objects(builder, &compiler, target);\n+            copy_self_contained_objects(builder, &compiler, target);\n \n             builder.ensure(StdLink {\n                 compiler: compiler_to_use,\n@@ -83,7 +84,8 @@ impl Step for Std {\n             return;\n         }\n \n-        target_deps.extend(copy_third_party_objects(builder, &compiler, target).into_iter());\n+        target_deps.extend(copy_third_party_objects(builder, &compiler, target));\n+        target_deps.extend(copy_self_contained_objects(builder, &compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n         std_cargo(builder, target, compiler.stage, &mut cargo);\n@@ -109,21 +111,76 @@ impl Step for Std {\n     }\n }\n \n+fn copy_and_stamp(\n+    builder: &Builder<'_>,\n+    libdir: &Path,\n+    sourcedir: &Path,\n+    name: &str,\n+    target_deps: &mut Vec<(PathBuf, DependencyType)>,\n+    dependency_type: DependencyType,\n+) {\n+    let target = libdir.join(name);\n+    builder.copy(&sourcedir.join(name), &target);\n+\n+    target_deps.push((target, dependency_type));\n+}\n+\n /// Copies third party objects needed by various targets.\n fn copy_third_party_objects(\n     builder: &Builder<'_>,\n     compiler: &Compiler,\n     target: Interned<String>,\n-) -> Vec<PathBuf> {\n+) -> Vec<(PathBuf, DependencyType)> {\n     let libdir = builder.sysroot_libdir(*compiler, target);\n-\n     let mut target_deps = vec![];\n \n-    let mut copy_and_stamp = |sourcedir: &Path, name: &str| {\n-        let target = libdir.join(name);\n-        builder.copy(&sourcedir.join(name), &target);\n-        target_deps.push(target);\n+    // Copies libunwind.a compiled to be linked with x86_64-fortanix-unknown-sgx.\n+    //\n+    // This target needs to be linked to Fortanix's port of llvm's libunwind.\n+    // libunwind requires support for rwlock and printing to stderr,\n+    // which is provided by std for this target.\n+    if target == \"x86_64-fortanix-unknown-sgx\" {\n+        let src_path_env = \"X86_FORTANIX_SGX_LIBS\";\n+        let src =\n+            env::var(src_path_env).unwrap_or_else(|_| panic!(\"{} not found in env\", src_path_env));\n+        copy_and_stamp(\n+            builder,\n+            &*libdir,\n+            Path::new(&src),\n+            \"libunwind.a\",\n+            &mut target_deps,\n+            DependencyType::Target,\n+        );\n+    }\n+\n+    if builder.config.sanitizers && compiler.stage != 0 {\n+        // The sanitizers are only copied in stage1 or above,\n+        // to avoid creating dependency on LLVM.\n+        target_deps.extend(\n+            copy_sanitizers(builder, &compiler, target)\n+                .into_iter()\n+                .map(|d| (d, DependencyType::Target)),\n+        );\n+    }\n+\n+    target_deps\n+}\n+\n+/// Copies third party objects needed by various targets for self-contained linkage.\n+fn copy_self_contained_objects(\n+    builder: &Builder<'_>,\n+    compiler: &Compiler,\n+    target: Interned<String>,\n+) -> Vec<(PathBuf, DependencyType)> {\n+    // cfg(bootstrap)\n+    // Remove when upgrading bootstrap compiler.\n+    let libdir_self_contained = if compiler.stage == 0 {\n+        builder.sysroot_libdir(*compiler, target).to_path_buf()\n+    } else {\n+        builder.sysroot_libdir(*compiler, target).join(\"self-contained\")\n     };\n+    t!(fs::create_dir_all(&libdir_self_contained));\n+    let mut target_deps = vec![];\n \n     // Copies the CRT objects.\n     //\n@@ -135,29 +192,32 @@ fn copy_third_party_objects(\n     if target.contains(\"musl\") {\n         let srcdir = builder.musl_root(target).unwrap().join(\"lib\");\n         for &obj in &[\"crt1.o\", \"Scrt1.o\", \"rcrt1.o\", \"crti.o\", \"crtn.o\"] {\n-            copy_and_stamp(&srcdir, obj);\n+            copy_and_stamp(\n+                builder,\n+                &libdir_self_contained,\n+                &srcdir,\n+                obj,\n+                &mut target_deps,\n+                DependencyType::TargetSelfContained,\n+            );\n         }\n     } else if target.ends_with(\"-wasi\") {\n         let srcdir = builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\");\n-        copy_and_stamp(&srcdir, \"crt1.o\");\n-    }\n-\n-    // Copies libunwind.a compiled to be linked with x86_64-fortanix-unknown-sgx.\n-    //\n-    // This target needs to be linked to Fortanix's port of llvm's libunwind.\n-    // libunwind requires support for rwlock and printing to stderr,\n-    // which is provided by std for this target.\n-    if target == \"x86_64-fortanix-unknown-sgx\" {\n-        let src_path_env = \"X86_FORTANIX_SGX_LIBS\";\n-        let src =\n-            env::var(src_path_env).unwrap_or_else(|_| panic!(\"{} not found in env\", src_path_env));\n-        copy_and_stamp(Path::new(&src), \"libunwind.a\");\n-    }\n-\n-    if builder.config.sanitizers && compiler.stage != 0 {\n-        // The sanitizers are only copied in stage1 or above,\n-        // to avoid creating dependency on LLVM.\n-        target_deps.extend(copy_sanitizers(builder, &compiler, target));\n+        copy_and_stamp(\n+            builder,\n+            &libdir_self_contained,\n+            &srcdir,\n+            \"crt1.o\",\n+            &mut target_deps,\n+            DependencyType::TargetSelfContained,\n+        );\n+    } else if target.contains(\"windows-gnu\") {\n+        for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n+            let src = compiler_file(builder, builder.cc(target), target, obj);\n+            let target = libdir_self_contained.join(obj);\n+            builder.copy(&src, &target);\n+            target_deps.push((target, DependencyType::TargetSelfContained));\n+        }\n     }\n \n     target_deps\n@@ -335,7 +395,7 @@ pub struct StartupObjects {\n }\n \n impl Step for StartupObjects {\n-    type Output = Vec<PathBuf>;\n+    type Output = Vec<(PathBuf, DependencyType)>;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/rtstartup\")\n@@ -354,7 +414,7 @@ impl Step for StartupObjects {\n     /// They don't require any library support as they're just plain old object\n     /// files, so we just use the nightly snapshot compiler to always build them (as\n     /// no other compilers are guaranteed to be available).\n-    fn run(self, builder: &Builder<'_>) -> Vec<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Vec<(PathBuf, DependencyType)> {\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"windows-gnu\") {\n@@ -388,14 +448,7 @@ impl Step for StartupObjects {\n \n             let target = sysroot_dir.join((*file).to_string() + \".o\");\n             builder.copy(dst_file, &target);\n-            target_deps.push(target);\n-        }\n-\n-        for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n-            let src = compiler_file(builder, builder.cc(target), target, obj);\n-            let target = sysroot_dir.join(obj);\n-            builder.copy(&src, &target);\n-            target_deps.push(target);\n+            target_deps.push((target, DependencyType::Target));\n         }\n \n         target_deps\n@@ -808,14 +861,17 @@ pub fn add_to_sysroot(\n     sysroot_host_dst: &Path,\n     stamp: &Path,\n ) {\n+    let self_contained_dst = &sysroot_dst.join(\"self-contained\");\n     t!(fs::create_dir_all(&sysroot_dst));\n     t!(fs::create_dir_all(&sysroot_host_dst));\n-    for (path, host) in builder.read_stamp_file(stamp) {\n-        if host {\n-            builder.copy(&path, &sysroot_host_dst.join(path.file_name().unwrap()));\n-        } else {\n-            builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n-        }\n+    t!(fs::create_dir_all(&self_contained_dst));\n+    for (path, dependency_type) in builder.read_stamp_file(stamp) {\n+        let dst = match dependency_type {\n+            DependencyType::Host => sysroot_host_dst,\n+            DependencyType::Target => sysroot_dst,\n+            DependencyType::TargetSelfContained => self_contained_dst,\n+        };\n+        builder.copy(&path, &dst.join(path.file_name().unwrap()));\n     }\n }\n \n@@ -824,7 +880,7 @@ pub fn run_cargo(\n     cargo: Cargo,\n     tail_args: Vec<String>,\n     stamp: &Path,\n-    additional_target_deps: Vec<PathBuf>,\n+    additional_target_deps: Vec<(PathBuf, DependencyType)>,\n     is_check: bool,\n ) -> Vec<PathBuf> {\n     if builder.config.dry_run {\n@@ -875,15 +931,15 @@ pub fn run_cargo(\n             if filename.starts_with(&host_root_dir) {\n                 // Unless it's a proc macro used in the compiler\n                 if crate_types.iter().any(|t| t == \"proc-macro\") {\n-                    deps.push((filename.to_path_buf(), true));\n+                    deps.push((filename.to_path_buf(), DependencyType::Host));\n                 }\n                 continue;\n             }\n \n             // If this was output in the `deps` dir then this is a precise file\n             // name (hash included) so we start tracking it.\n             if filename.starts_with(&target_deps_dir) {\n-                deps.push((filename.to_path_buf(), false));\n+                deps.push((filename.to_path_buf(), DependencyType::Target));\n                 continue;\n             }\n \n@@ -935,17 +991,21 @@ pub fn run_cargo(\n             let candidate = format!(\"{}.lib\", path_to_add);\n             let candidate = PathBuf::from(candidate);\n             if candidate.exists() {\n-                deps.push((candidate, false));\n+                deps.push((candidate, DependencyType::Target));\n             }\n         }\n-        deps.push((path_to_add.into(), false));\n+        deps.push((path_to_add.into(), DependencyType::Target));\n     }\n \n-    deps.extend(additional_target_deps.into_iter().map(|d| (d, false)));\n+    deps.extend(additional_target_deps);\n     deps.sort();\n     let mut new_contents = Vec::new();\n-    for (dep, proc_macro) in deps.iter() {\n-        new_contents.extend(if *proc_macro { b\"h\" } else { b\"t\" });\n+    for (dep, dependency_type) in deps.iter() {\n+        new_contents.extend(match *dependency_type {\n+            DependencyType::Host => b\"h\",\n+            DependencyType::Target => b\"t\",\n+            DependencyType::TargetSelfContained => b\"s\",\n+        });\n         new_contents.extend(dep.to_str().unwrap().as_bytes());\n         new_contents.extend(b\"\\0\");\n     }"}, {"sha": "8a2463d378fdb8642cea130e3bd1c10fb5bbd3ba", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -22,7 +22,7 @@ use crate::channel;\n use crate::compile;\n use crate::tool::{self, Tool};\n use crate::util::{exe, is_dylib, timeit};\n-use crate::{Compiler, Mode, LLVM_TOOLS};\n+use crate::{Compiler, DependencyType, Mode, LLVM_TOOLS};\n use time::{self, Timespec};\n \n pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n@@ -306,7 +306,12 @@ fn make_win_dist(\n     }\n \n     //Copy platform tools to platform-specific bin directory\n-    let target_bin_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"bin\");\n+    let target_bin_dir = plat_root\n+        .join(\"lib\")\n+        .join(\"rustlib\")\n+        .join(target_triple)\n+        .join(\"bin\")\n+        .join(\"self-contained\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n     for src in target_tools {\n         builder.copy_to_folder(&src, &target_bin_dir);\n@@ -321,7 +326,12 @@ fn make_win_dist(\n     );\n \n     //Copy platform libs to platform-specific lib directory\n-    let target_lib_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\");\n+    let target_lib_dir = plat_root\n+        .join(\"lib\")\n+        .join(\"rustlib\")\n+        .join(target_triple)\n+        .join(\"lib\")\n+        .join(\"self-contained\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n     for src in target_libs {\n         builder.copy_to_folder(&src, &target_lib_dir);\n@@ -652,9 +662,13 @@ fn skip_host_target_lib(builder: &Builder<'_>, compiler: Compiler) -> bool {\n /// Copy stamped files into an image's `target/lib` directory.\n fn copy_target_libs(builder: &Builder<'_>, target: &str, image: &Path, stamp: &Path) {\n     let dst = image.join(\"lib/rustlib\").join(target).join(\"lib\");\n+    let self_contained_dst = dst.join(\"self-contained\");\n     t!(fs::create_dir_all(&dst));\n-    for (path, host) in builder.read_stamp_file(stamp) {\n-        if !host || builder.config.build == target {\n+    t!(fs::create_dir_all(&self_contained_dst));\n+    for (path, dependency_type) in builder.read_stamp_file(stamp) {\n+        if dependency_type == DependencyType::TargetSelfContained {\n+            builder.copy(&path, &self_contained_dst.join(path.file_name().unwrap()));\n+        } else if dependency_type == DependencyType::Target || builder.config.build == target {\n             builder.copy(&path, &dst.join(path.file_name().unwrap()));\n         }\n     }"}, {"sha": "6d7fb7acfcb04defd4be6336b5cb44839804d29f", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -548,8 +548,8 @@ impl Step for Rustc {\n         // Find dependencies for top level crates.\n         let mut compiler_crates = HashSet::new();\n         for root_crate in &[\"rustc_driver\", \"rustc_codegen_llvm\", \"rustc_codegen_ssa\"] {\n-            let interned_root_crate = INTERNER.intern_str(root_crate);\n-            find_compiler_crates(builder, &interned_root_crate, &mut compiler_crates);\n+            compiler_crates\n+                .extend(builder.in_tree_crates(root_crate).into_iter().map(|krate| krate.name));\n         }\n \n         for krate in &compiler_crates {\n@@ -564,22 +564,6 @@ impl Step for Rustc {\n     }\n }\n \n-fn find_compiler_crates(\n-    builder: &Builder<'_>,\n-    name: &Interned<String>,\n-    crates: &mut HashSet<Interned<String>>,\n-) {\n-    // Add current crate.\n-    crates.insert(*name);\n-\n-    // Look for dependencies.\n-    for dep in builder.crates.get(name).unwrap().deps.iter() {\n-        if builder.crates.get(dep).unwrap().is_local(builder) {\n-            find_compiler_crates(builder, dep, crates);\n-        }\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustdoc {\n     stage: u32,"}, {"sha": "f477c752933856e0ffd07747f963dcf20fff026c", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -3,19 +3,17 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n-use std::fs;\n+use std::env;\n use std::path::PathBuf;\n use std::process;\n \n use getopts::Options;\n \n use crate::builder::Builder;\n+use crate::cache::{Interned, INTERNER};\n use crate::config::Config;\n-use crate::metadata;\n use crate::{Build, DocTests};\n \n-use crate::cache::{Interned, INTERNER};\n-\n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n     pub verbose: usize, // number of -v args; each extra -v after the first is passed to Cargo\n@@ -438,19 +436,12 @@ Arguments:\n         // Get any optional paths which occur after the subcommand\n         let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n-        let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n-            if fs::metadata(\"config.toml\").is_ok() {\n-                Some(PathBuf::from(\"config.toml\"))\n-            } else {\n-                None\n-            }\n-        });\n+        let cfg_file = env::var_os(\"BOOTSTRAP_CONFIG\").map(PathBuf::from);\n \n         // All subcommands except `clean` can have an optional \"Available paths\" section\n         if matches.opt_present(\"verbose\") {\n             let config = Config::parse(&[\"build\".to_string()]);\n-            let mut build = Build::new(config);\n-            metadata::build(&mut build);\n+            let build = Build::new(config);\n \n             let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n             extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());"}, {"sha": "fbdef9d8272f7686f61187dbed6330896eedbf6b", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -70,7 +70,10 @@ fn install_sh(\n     let libdir_default = PathBuf::from(\"lib\");\n     let mandir_default = datadir_default.join(\"man\");\n     let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n-        fs::canonicalize(p).unwrap_or_else(|_| panic!(\"could not canonicalize {}\", p.display()))\n+        fs::create_dir_all(p)\n+            .unwrap_or_else(|err| panic!(\"could not create {}: {}\", p.display(), err));\n+        fs::canonicalize(p)\n+            .unwrap_or_else(|err| panic!(\"could not canonicalize {}: {}\", p.display(), err))\n     });\n     let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n     let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);"}, {"sha": "e7aeb08643c297c4c89d8b6c5ed2bb6f0abe5215", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -270,16 +270,22 @@ struct Crate {\n }\n \n impl Crate {\n-    fn is_local(&self, build: &Build) -> bool {\n-        self.path.starts_with(&build.config.src) && !self.path.to_string_lossy().ends_with(\"_shim\")\n-    }\n-\n     fn local_path(&self, build: &Build) -> PathBuf {\n-        assert!(self.is_local(build));\n         self.path.strip_prefix(&build.config.src).unwrap().into()\n     }\n }\n \n+/// When building Rust various objects are handled differently.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum DependencyType {\n+    /// Libraries originating from proc-macros.\n+    Host,\n+    /// Typical Rust libraries.\n+    Target,\n+    /// Non Rust libraries and objects shipped to ease usage of certain targets.\n+    TargetSelfContained,\n+}\n+\n /// The various \"modes\" of invoking Cargo.\n ///\n /// These entries currently correspond to the various output directories of the\n@@ -1079,25 +1085,37 @@ impl Build {\n         }\n     }\n \n+    /// Returns a Vec of all the dependencies of the given root crate,\n+    /// including transitive dependencies and the root itself. Only includes\n+    /// \"local\" crates (those in the local source tree, not from a registry).\n     fn in_tree_crates(&self, root: &str) -> Vec<&Crate> {\n         let mut ret = Vec::new();\n         let mut list = vec![INTERNER.intern_str(root)];\n         let mut visited = HashSet::new();\n         while let Some(krate) = list.pop() {\n             let krate = &self.crates[&krate];\n-            if krate.is_local(self) {\n-                ret.push(krate);\n-            }\n+            ret.push(krate);\n             for dep in &krate.deps {\n-                if visited.insert(dep) && dep != \"build_helper\" {\n+                // Don't include optional deps if their features are not\n+                // enabled. Ideally this would be computed from `cargo\n+                // metadata --features \u2026`, but that is somewhat slow. Just\n+                // skip `build_helper` since there aren't any operations we\n+                // want to perform on it. In the future, we may want to\n+                // consider just filtering all build and dev dependencies in\n+                // metadata::build.\n+                if visited.insert(dep)\n+                    && dep != \"build_helper\"\n+                    && (dep != \"profiler_builtins\" || self.config.profiler)\n+                    && (dep != \"rustc_codegen_llvm\" || self.config.llvm_enabled())\n+                {\n                     list.push(*dep);\n                 }\n             }\n         }\n         ret\n     }\n \n-    fn read_stamp_file(&self, stamp: &Path) -> Vec<(PathBuf, bool)> {\n+    fn read_stamp_file(&self, stamp: &Path) -> Vec<(PathBuf, DependencyType)> {\n         if self.config.dry_run {\n             return Vec::new();\n         }\n@@ -1110,9 +1128,14 @@ impl Build {\n             if part.is_empty() {\n                 continue;\n             }\n-            let host = part[0] as char == 'h';\n+            let dependency_type = match part[0] as char {\n+                'h' => DependencyType::Host,\n+                's' => DependencyType::TargetSelfContained,\n+                't' => DependencyType::Target,\n+                _ => unreachable!(),\n+            };\n             let path = PathBuf::from(t!(str::from_utf8(&part[1..])));\n-            paths.push((path, host));\n+            paths.push((path, dependency_type));\n         }\n         paths\n     }"}, {"sha": "a38391c7b88f28f31125681682e41bc4441e1d76", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 13, "deletions": 49, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,5 +1,3 @@\n-use std::collections::HashMap;\n-use std::collections::HashSet;\n use std::path::PathBuf;\n use std::process::Command;\n \n@@ -12,7 +10,6 @@ use crate::{Build, Crate};\n #[derive(Deserialize)]\n struct Output {\n     packages: Vec<Package>,\n-    resolve: Resolve,\n }\n \n #[derive(Deserialize)]\n@@ -21,72 +18,39 @@ struct Package {\n     name: String,\n     source: Option<String>,\n     manifest_path: String,\n+    dependencies: Vec<Dependency>,\n }\n \n #[derive(Deserialize)]\n-struct Resolve {\n-    nodes: Vec<ResolveNode>,\n-}\n-\n-#[derive(Deserialize)]\n-struct ResolveNode {\n-    id: String,\n-    dependencies: Vec<String>,\n+struct Dependency {\n+    name: String,\n+    source: Option<String>,\n }\n \n pub fn build(build: &mut Build) {\n-    let mut resolves = Vec::new();\n-    build_krate(&build.std_features(), build, &mut resolves, \"src/libstd\");\n-    build_krate(\"\", build, &mut resolves, \"src/libtest\");\n-    build_krate(&build.rustc_features(), build, &mut resolves, \"src/rustc\");\n-\n-    let mut id2name = HashMap::with_capacity(build.crates.len());\n-    for (name, krate) in build.crates.iter() {\n-        id2name.insert(krate.id.clone(), name.clone());\n-    }\n-\n-    for node in resolves {\n-        let name = match id2name.get(&node.id) {\n-            Some(name) => name,\n-            None => continue,\n-        };\n-\n-        let krate = build.crates.get_mut(name).unwrap();\n-        for dep in node.dependencies.iter() {\n-            let dep = match id2name.get(dep) {\n-                Some(dep) => dep,\n-                None => continue,\n-            };\n-            krate.deps.insert(*dep);\n-        }\n-    }\n-}\n-\n-fn build_krate(features: &str, build: &mut Build, resolves: &mut Vec<ResolveNode>, krate: &str) {\n     // Run `cargo metadata` to figure out what crates we're testing.\n-    //\n-    // Down below we're going to call `cargo test`, but to test the right set\n-    // of packages we're going to have to know what `-p` arguments to pass it\n-    // to know what crates to test. Here we run `cargo metadata` to learn about\n-    // the dependency graph and what `-p` arguments there are.\n     let mut cargo = Command::new(&build.initial_cargo);\n     cargo\n         .arg(\"metadata\")\n         .arg(\"--format-version\")\n         .arg(\"1\")\n-        .arg(\"--features\")\n-        .arg(features)\n+        .arg(\"--no-deps\")\n         .arg(\"--manifest-path\")\n-        .arg(build.src.join(krate).join(\"Cargo.toml\"));\n+        .arg(build.src.join(\"Cargo.toml\"));\n     let output = output(&mut cargo);\n     let output: Output = serde_json::from_str(&output).unwrap();\n     for package in output.packages {\n         if package.source.is_none() {\n             let name = INTERNER.intern_string(package.name);\n             let mut path = PathBuf::from(package.manifest_path);\n             path.pop();\n-            build.crates.insert(name, Crate { name, id: package.id, deps: HashSet::new(), path });\n+            let deps = package\n+                .dependencies\n+                .into_iter()\n+                .filter(|dep| dep.source.is_none())\n+                .map(|dep| INTERNER.intern_string(dep.name))\n+                .collect();\n+            build.crates.insert(name, Crate { name, id: package.id, deps, path });\n         }\n     }\n-    resolves.extend(output.resolve.nodes);\n }"}, {"sha": "8a37a70d60d9a4fffa35f0a7fa3ea7261f1e7a27", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1648,14 +1648,8 @@ impl Step for Crate {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(mut run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        for krate in run.builder.in_tree_crates(\"test\") {\n-            if !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) {\n-                run = run.path(krate.local_path(&builder).to_str().unwrap());\n-            }\n-        }\n-        run\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.krate(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {"}, {"sha": "914195f015b5a83daf9325285aa6074c61c79dec", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -25,6 +25,7 @@ path = \"../liballoc/tests/lib.rs\"\n [[bench]]\n name = \"collectionsbenches\"\n path = \"../liballoc/benches/lib.rs\"\n+test = true\n \n [[bench]]\n name = \"vec_deque_append_bench\""}, {"sha": "ab0dde0ada660ecbf08ede47a4e0f58a6191e3bf", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -248,7 +248,7 @@ impl<T> Box<T> {\n     #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n     pub fn into_boxed_slice(boxed: Box<T>) -> Box<[T]> {\n         // *mut T and *mut [T; 1] have the same size and alignment\n-        unsafe { Box::from_raw(Box::into_raw(boxed) as *mut [T; 1] as *mut [T]) }\n+        unsafe { Box::from_raw(Box::into_raw(boxed) as *mut [T; 1]) }\n     }\n }\n "}, {"sha": "f16cac05ea03993f6ce314ae289a6a8caec8b69c", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1639,7 +1639,7 @@ impl<T: Default> Vec<T> {\n     }\n }\n \n-// This code generalises `extend_with_{element,default}`.\n+// This code generalizes `extend_with_{element,default}`.\n trait ExtendWith<T> {\n     fn next(&mut self) -> T;\n     fn last(self) -> T;\n@@ -1837,7 +1837,7 @@ unsafe trait IsZero {\n }\n \n macro_rules! impl_is_zero {\n-    ($t: ty, $is_zero: expr) => {\n+    ($t:ty, $is_zero:expr) => {\n         unsafe impl IsZero for $t {\n             #[inline]\n             fn is_zero(&self) -> bool {\n@@ -2362,9 +2362,9 @@ macro_rules! __impl_slice_eq1 {\n __impl_slice_eq1! { [] Vec<A>, Vec<B>, }\n __impl_slice_eq1! { [] Vec<A>, &[B], }\n __impl_slice_eq1! { [] Vec<A>, &mut [B], }\n+__impl_slice_eq1! { [] Cow<'_, [A]>, Vec<B>, A: Clone }\n __impl_slice_eq1! { [] Cow<'_, [A]>, &[B], A: Clone }\n __impl_slice_eq1! { [] Cow<'_, [A]>, &mut [B], A: Clone }\n-__impl_slice_eq1! { [] Cow<'_, [A]>, Vec<B>, A: Clone }\n __impl_slice_eq1! { [const N: usize] Vec<A>, [B; N], [B; N]: LengthAtMost32 }\n __impl_slice_eq1! { [const N: usize] Vec<A>, &[B; N], [B; N]: LengthAtMost32 }\n "}, {"sha": "42c555cafac86f187ddeb681fe62eecf85e86c9d", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -19,6 +19,7 @@ path = \"../libcore/tests/lib.rs\"\n [[bench]]\n name = \"corebenches\"\n path = \"../libcore/benches/lib.rs\"\n+test = true\n \n [dev-dependencies]\n rand = \"0.7\""}, {"sha": "de4ef7949f344a6842fe1d7c8d2a3214f59e18a1", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,3 +1,5 @@\n+// wasm32 does not support benches (no time).\n+#![cfg(not(target_arch = \"wasm32\"))]\n #![feature(flt2dec)]\n #![feature(test)]\n "}, {"sha": "8ff1ced53b071840f45edad5e3c3184804fb90c2", "filename": "src/libcore/convert/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -374,6 +374,7 @@ pub trait Into<T>: Sized {\n /// [`Into`]: trait.Into.html\n /// [`from`]: trait.From.html#tymethod.from\n /// [book]: ../../book/ch09-00-error-handling.html\n+#[rustc_diagnostic_item = \"from_trait\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(on(\n     all(_Self = \"&str\", T = \"std::string::String\"),"}, {"sha": "9061145a695f8ba1280a48ce850f7f0163380e99", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1941,6 +1941,13 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Perma-unstable: do not use.\n     pub fn miri_start_panic(payload: *mut u8) -> !;\n+\n+    /// Internal placeholder for injecting code coverage counters when the \"instrument-coverage\"\n+    /// option is enabled. The placeholder is replaced with `llvm.instrprof.increment` during code\n+    /// generation.\n+    #[cfg(not(bootstrap))]\n+    #[lang = \"count_code_region\"]\n+    pub fn count_code_region(index: u32);\n }\n \n // Some functions are defined here because they accidentally got made\n@@ -2057,9 +2064,14 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n         fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    debug_assert!(is_aligned_and_not_null(src), \"attempt to copy from unaligned or null pointer\");\n-    debug_assert!(is_aligned_and_not_null(dst), \"attempt to copy to unaligned or null pointer\");\n-    debug_assert!(is_nonoverlapping(src, dst, count), \"attempt to copy to overlapping memory\");\n+    if cfg!(debug_assertions)\n+        && !(is_aligned_and_not_null(src)\n+            && is_aligned_and_not_null(dst)\n+            && is_nonoverlapping(src, dst, count))\n+    {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     copy_nonoverlapping(src, dst, count)\n }\n \n@@ -2122,8 +2134,10 @@ pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n         fn copy<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    debug_assert!(is_aligned_and_not_null(src), \"attempt to copy from unaligned or null pointer\");\n-    debug_assert!(is_aligned_and_not_null(dst), \"attempt to copy to unaligned or null pointer\");\n+    if cfg!(debug_assertions) && !(is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     copy(src, dst, count)\n }\n "}, {"sha": "066bb8b3dc787a40ec00d36d7883dbcffb7a9ad6", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -581,11 +581,12 @@ pub const fn needs_drop<T>() -> bool {\n /// This means that, for example, the padding byte in `(u8, u16)` is not\n /// necessarily zeroed.\n ///\n-/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n-/// some type `T`. For example, the all-zero byte-pattern is not a valid value\n-/// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n-/// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n-/// that there always is a valid value in a variable it considers initialized.\n+/// There is no guarantee that an all-zero byte-pattern represents a valid value\n+/// of some type `T`. For example, the all-zero byte-pattern is not a valid value\n+/// for reference types (`&T`, `&mut T`) and functions pointers. Using `zeroed`\n+/// on such types causes immediate [undefined behavior][ub] because [the Rust\n+/// compiler assumes][inv] that there always is a valid value in a variable it\n+/// considers initialized.\n ///\n /// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n /// It is useful for FFI sometimes, but should generally be avoided.\n@@ -612,6 +613,7 @@ pub const fn needs_drop<T>() -> bool {\n /// use std::mem;\n ///\n /// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n+/// let _y: fn() = unsafe { mem::zeroed() }; // And again!\n /// ```\n #[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "ca2b0c85ec12172e72fdca0680e1d4cb1337e918", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 88, "deletions": 7, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -70,7 +70,7 @@\n use crate::cmp::Ordering;\n use crate::fmt;\n use crate::hash;\n-use crate::intrinsics::{self, is_aligned_and_not_null, is_nonoverlapping};\n+use crate::intrinsics::{self, abort, is_aligned_and_not_null, is_nonoverlapping};\n use crate::mem::{self, MaybeUninit};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -420,9 +420,14 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n #[inline]\n #[stable(feature = \"swap_nonoverlapping\", since = \"1.27.0\")]\n pub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n-    debug_assert!(is_aligned_and_not_null(x), \"attempt to swap unaligned or null pointer\");\n-    debug_assert!(is_aligned_and_not_null(y), \"attempt to swap unaligned or null pointer\");\n-    debug_assert!(is_nonoverlapping(x, y, count), \"attempt to swap overlapping memory\");\n+    if cfg!(debug_assertions)\n+        && !(is_aligned_and_not_null(x)\n+            && is_aligned_and_not_null(y)\n+            && is_nonoverlapping(x, y, count))\n+    {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n \n     let x = x as *mut u8;\n     let y = y as *mut u8;\n@@ -838,7 +843,10 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n-    debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n+    if cfg!(debug_assertions) && !is_aligned_and_not_null(dst) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n@@ -1003,7 +1011,10 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn read_volatile<T>(src: *const T) -> T {\n-    debug_assert!(is_aligned_and_not_null(src), \"attempt to read from unaligned or null pointer\");\n+    if cfg!(debug_assertions) && !is_aligned_and_not_null(src) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     intrinsics::volatile_load(src)\n }\n \n@@ -1072,7 +1083,10 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n-    debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n+    if cfg!(debug_assertions) && !is_aligned_and_not_null(dst) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     intrinsics::volatile_store(dst, src);\n }\n \n@@ -1399,3 +1413,70 @@ fnptr_impls_args! { A, B, C, D, E, F, G, H, I }\n fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J }\n fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K }\n fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n+\n+/// Create a `const` raw pointer to a place, without creating an intermediate reference.\n+///\n+/// Creating a reference with `&`/`&mut` is only allowed if the pointer is properly aligned\n+/// and points to initialized data. For cases where those requirements do not hold,\n+/// raw pointers should be used instead. However, `&expr as *const _` creates a reference\n+/// before casting it to a raw pointer, and that reference is subject to the same rules\n+/// as all other references. This macro can create a raw pointer *without* creating\n+/// a reference first.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(raw_ref_macros)]\n+/// use std::ptr;\n+///\n+/// #[repr(packed)]\n+/// struct Packed {\n+///     f1: u8,\n+///     f2: u16,\n+/// }\n+///\n+/// let packed = Packed { f1: 1, f2: 2 };\n+/// // `&packed.f2` would create an unaligned reference, and thus be Undefined Behavior!\n+/// let raw_f2 = ptr::raw_const!(packed.f2);\n+/// assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);\n+/// ```\n+#[unstable(feature = \"raw_ref_macros\", issue = \"73394\")]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+#[allow_internal_unstable(raw_ref_op)]\n+pub macro raw_const($e:expr) {\n+    &raw const $e\n+}\n+\n+/// Create a `mut` raw pointer to a place, without creating an intermediate reference.\n+///\n+/// Creating a reference with `&`/`&mut` is only allowed if the pointer is properly aligned\n+/// and points to initialized data. For cases where those requirements do not hold,\n+/// raw pointers should be used instead. However, `&mut expr as *mut _` creates a reference\n+/// before casting it to a raw pointer, and that reference is subject to the same rules\n+/// as all other references. This macro can create a raw pointer *without* creating\n+/// a reference first.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(raw_ref_macros)]\n+/// use std::ptr;\n+///\n+/// #[repr(packed)]\n+/// struct Packed {\n+///     f1: u8,\n+///     f2: u16,\n+/// }\n+///\n+/// let mut packed = Packed { f1: 1, f2: 2 };\n+/// // `&mut packed.f2` would create an unaligned reference, and thus be Undefined Behavior!\n+/// let raw_f2 = ptr::raw_mut!(packed.f2);\n+/// unsafe { raw_f2.write_unaligned(42); }\n+/// assert_eq!({packed.f2}, 42); // `{...}` forces copying the field instead of creating a reference.\n+/// ```\n+#[unstable(feature = \"raw_ref_macros\", issue = \"73394\")]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+#[allow_internal_unstable(raw_ref_op)]\n+pub macro raw_mut($e:expr) {\n+    &raw mut $e\n+}"}, {"sha": "2080ae193667e8c6945161df6102dd049c64bab5", "filename": "src/libcore/result.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1145,45 +1145,69 @@ impl<T, E: Into<!>> Result<T, E> {\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n+#[unstable(feature = \"inner_deref\", issue = \"50264\")]\n impl<T: Deref, E> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T::Target, &E>`.\n+    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&<T as Deref>::Target, &E>`.\n     ///\n-    /// Leaves the original `Result` in-place, creating a new one containing a reference to the\n-    /// `Ok` type's `Deref::Target` type.\n+    /// Coerces the [`Ok`] variant of the original [`Result`] via [`Deref`](crate::ops::Deref)\n+    /// and returns the new [`Result`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x: Result<String, u32> = Ok(\"hello\".to_string());\n+    /// let y: Result<&str, &u32> = Ok(\"hello\");\n+    /// assert_eq!(x.as_deref(), y);\n+    ///\n+    /// let x: Result<String, u32> = Err(42);\n+    /// let y: Result<&str, &u32> = Err(&42);\n+    /// assert_eq!(x.as_deref(), y);\n+    /// ```\n     pub fn as_deref(&self) -> Result<&T::Target, &E> {\n         self.as_ref().map(|t| t.deref())\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n+#[unstable(feature = \"inner_deref\", issue = \"50264\")]\n impl<T, E: Deref> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T, &E::Target>`.\n+    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T, &<E as Deref>::Target>`.\n     ///\n-    /// Leaves the original `Result` in-place, creating a new one containing a reference to the\n-    /// `Err` type's `Deref::Target` type.\n+    /// Coerces the [`Err`] variant of the original [`Result`] via [`Deref`](crate::ops::Deref)\n+    /// and returns the new [`Result`].\n     pub fn as_deref_err(&self) -> Result<&T, &E::Target> {\n         self.as_ref().map_err(|e| e.deref())\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n+#[unstable(feature = \"inner_deref\", issue = \"50264\")]\n impl<T: DerefMut, E> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut T::Target, &mut E>`.\n+    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut <T as DerefMut>::Target, &mut E>`.\n     ///\n-    /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n-    /// the `Ok` type's `Deref::Target` type.\n+    /// Coerces the [`Ok`] variant of the original [`Result`] via [`DerefMut`](crate::ops::DerefMut)\n+    /// and returns the new [`Result`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut x: Result<String, u32> = Ok(\"hello\".to_string());\n+    /// let y: Result<&mut str, &mut u32> = Ok(\"HELLO\");\n+    /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n+    ///\n+    /// let mut x: Result<String, u32> = Err(42);\n+    /// let y: Result<&mut str, &mut u32> = Err(&42);\n+    /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n+    /// ```\n     pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E> {\n         self.as_mut().map(|t| t.deref_mut())\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n+#[unstable(feature = \"inner_deref\", issue = \"50264\")]\n impl<T, E: DerefMut> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut T, &mut E::Target>`.\n+    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut T, &mut <E as DerefMut>::Target>`.\n     ///\n-    /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n-    /// the `Err` type's `Deref::Target` type.\n+    /// Coerces the [`Err`] variant of the original [`Result`] via [`DerefMut`](crate::ops::DerefMut)\n+    /// and returns the new [`Result`].\n     pub fn as_deref_mut_err(&mut self) -> Result<&mut T, &mut E::Target> {\n         self.as_mut().map_err(|e| e.deref_mut())\n     }"}, {"sha": "4bc44e98fc802a7efee5106bac8409c3b0cfa9e7", "filename": "src/libcore/tests/array.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Farray.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -241,3 +241,52 @@ fn iterator_drops() {\n     }\n     assert_eq!(i.get(), 5);\n }\n+\n+// This test does not work on targets without panic=unwind support.\n+// To work around this problem, test is marked is should_panic, so it will\n+// be automagically skipped on unsuitable targets, such as\n+// wasm32-unknown-unkown.\n+//\n+// It means that we use panic for indicating success.\n+#[test]\n+#[should_panic(expected = \"test succeeded\")]\n+fn array_default_impl_avoids_leaks_on_panic() {\n+    use core::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n+    static COUNTER: AtomicUsize = AtomicUsize::new(0);\n+    #[derive(Debug)]\n+    struct Bomb(usize);\n+\n+    impl Default for Bomb {\n+        fn default() -> Bomb {\n+            if COUNTER.load(Relaxed) == 3 {\n+                panic!(\"bomb limit exceeded\");\n+            }\n+\n+            COUNTER.fetch_add(1, Relaxed);\n+            Bomb(COUNTER.load(Relaxed))\n+        }\n+    }\n+\n+    impl Drop for Bomb {\n+        fn drop(&mut self) {\n+            COUNTER.fetch_sub(1, Relaxed);\n+        }\n+    }\n+\n+    let res = std::panic::catch_unwind(|| <[Bomb; 5]>::default());\n+    let panic_msg = match res {\n+        Ok(_) => unreachable!(),\n+        Err(p) => p.downcast::<&'static str>().unwrap(),\n+    };\n+    assert_eq!(*panic_msg, \"bomb limit exceeded\");\n+    // check that all bombs are successfully dropped\n+    assert_eq!(COUNTER.load(Relaxed), 0);\n+    panic!(\"test succeeded\")\n+}\n+\n+#[test]\n+fn empty_array_is_always_default() {\n+    struct DoesNotImplDefault;\n+\n+    let _arr = <[DoesNotImplDefault; 0]>::default();\n+}"}, {"sha": "ce186c4834d72cd60ec37a68c0780639c0015362", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -5,7 +5,7 @@\n //! additional metadata), and [`ItemKind`] (which represents a concrete type and contains\n //! information specific to the type of the item).\n //!\n-//! Other module items that worth mentioning:\n+//! Other module items worth mentioning:\n //! - [`Ty`] and [`TyKind`]: A parsed Rust type.\n //! - [`Expr`] and [`ExprKind`]: A parsed Rust expression.\n //! - [`Pat`] and [`PatKind`]: A parsed Rust pattern. Patterns are often dual to expressions."}, {"sha": "ba285b5ef38d12efa9c72d75794080ef9848fa49", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -997,6 +997,33 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.end.p0i8\", ptr, size);\n     }\n \n+    fn instrprof_increment(\n+        &mut self,\n+        fn_name: &'ll Value,\n+        hash: &'ll Value,\n+        num_counters: &'ll Value,\n+        index: &'ll Value,\n+    ) -> &'ll Value {\n+        debug!(\n+            \"instrprof_increment() with args ({:?}, {:?}, {:?}, {:?})\",\n+            fn_name, hash, num_counters, index\n+        );\n+\n+        let llfn = unsafe { llvm::LLVMRustGetInstrprofIncrementIntrinsic(self.cx().llmod) };\n+        let args = &[fn_name, hash, num_counters, index];\n+        let args = self.check_call(\"call\", llfn, args);\n+\n+        unsafe {\n+            llvm::LLVMRustBuildCall(\n+                self.llbuilder,\n+                llfn,\n+                args.as_ptr() as *const &llvm::Value,\n+                args.len() as c_uint,\n+                None,\n+            )\n+        }\n+    }\n+\n     fn call(\n         &mut self,\n         llfn: &'ll Value,"}, {"sha": "7ff5ac5cbdc10082bbdc7b54d1115784fd20addf", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -749,6 +749,8 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.lifetime.start.p0i8\", fn(t_i64, i8p) -> void);\n         ifn!(\"llvm.lifetime.end.p0i8\", fn(t_i64, i8p) -> void);\n \n+        ifn!(\"llvm.instrprof.increment\", fn(i8p, t_i64, t_i32, t_i32) -> void);\n+\n         ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n         ifn!(\"llvm.eh.typeid.for\", fn(i8p) -> t_i32);\n         ifn!(\"llvm.localescape\", fn(...) -> void);"}, {"sha": "8a957a729fb68b496a2efab490e0a7a45fca892a", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 53, "deletions": 55, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,4 +1,4 @@\n-use self::EnumDiscriminantInfo::*;\n+use self::EnumTagInfo::*;\n use self::MemberDescriptionFactory::*;\n use self::RecursiveTypeDescription::*;\n \n@@ -40,7 +40,7 @@ use rustc_middle::{bug, span_bug};\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::{Interner, Symbol};\n use rustc_span::{self, SourceFile, SourceFileHash, Span};\n-use rustc_target::abi::{Abi, Align, DiscriminantKind, HasDataLayout, Integer, LayoutOf};\n+use rustc_target::abi::{Abi, Align, HasDataLayout, Integer, LayoutOf, TagEncoding};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{Primitive, Size, VariantIdx, Variants};\n \n@@ -1335,7 +1335,7 @@ fn generator_layout_and_saved_local_names(\n struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     enum_type: Ty<'tcx>,\n     layout: TyAndLayout<'tcx>,\n-    discriminant_type_metadata: Option<&'ll DIType>,\n+    tag_type_metadata: Option<&'ll DIType>,\n     containing_scope: &'ll DIScope,\n     span: Span,\n }\n@@ -1385,7 +1385,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     cx,\n                     self.layout,\n                     variant_info,\n-                    NoDiscriminant,\n+                    NoTag,\n                     self_metadata,\n                     self.span,\n                 );\n@@ -1409,19 +1409,19 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 }]\n             }\n             Variants::Multiple {\n-                discr_kind: DiscriminantKind::Tag,\n-                discr_index,\n+                tag_encoding: TagEncoding::Direct,\n+                tag_field,\n                 ref variants,\n                 ..\n             } => {\n-                let discriminant_info = if fallback {\n-                    RegularDiscriminant {\n-                        discr_field: Field::from(discr_index),\n-                        discr_type_metadata: self.discriminant_type_metadata.unwrap(),\n+                let tag_info = if fallback {\n+                    RegularTag {\n+                        tag_field: Field::from(tag_field),\n+                        tag_type_metadata: self.tag_type_metadata.unwrap(),\n                     }\n                 } else {\n                     // This doesn't matter in this case.\n-                    NoDiscriminant\n+                    NoTag\n                 };\n                 variants\n                     .iter_enumerated()\n@@ -1432,7 +1432,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             cx,\n                             variant,\n                             variant_info,\n-                            discriminant_info,\n+                            tag_info,\n                             self_metadata,\n                             self.span,\n                         );\n@@ -1467,11 +1467,11 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     .collect()\n             }\n             Variants::Multiple {\n-                discr_kind:\n-                    DiscriminantKind::Niche { ref niche_variants, niche_start, dataful_variant },\n-                ref discr,\n+                tag_encoding:\n+                    TagEncoding::Niche { ref niche_variants, niche_start, dataful_variant },\n+                ref tag,\n                 ref variants,\n-                discr_index,\n+                tag_field,\n             } => {\n                 if fallback {\n                     let variant = self.layout.for_variant(cx, dataful_variant);\n@@ -1480,7 +1480,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         cx,\n                         variant,\n                         variant_info_for(dataful_variant),\n-                        OptimizedDiscriminant,\n+                        OptimizedTag,\n                         self.containing_scope,\n                         self.span,\n                     );\n@@ -1524,8 +1524,8 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         cx,\n                         &mut name,\n                         self.layout,\n-                        self.layout.fields.offset(discr_index),\n-                        self.layout.field(cx, discr_index).size,\n+                        self.layout.fields.offset(tag_field),\n+                        self.layout.field(cx, tag_field).size,\n                     );\n                     variant_info_for(*niche_variants.start()).map_struct_name(|variant_name| {\n                         name.push_str(variant_name);\n@@ -1552,7 +1552,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                     cx,\n                                     variant,\n                                     variant_info,\n-                                    OptimizedDiscriminant,\n+                                    OptimizedTag,\n                                     self_metadata,\n                                     self.span,\n                                 );\n@@ -1573,7 +1573,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                 let value = (i.as_u32() as u128)\n                                     .wrapping_sub(niche_variants.start().as_u32() as u128)\n                                     .wrapping_add(niche_start);\n-                                let value = truncate(value, discr.value.size(cx));\n+                                let value = truncate(value, tag.value.size(cx));\n                                 // NOTE(eddyb) do *NOT* remove this assert, until\n                                 // we pass the full 128-bit value to LLVM, otherwise\n                                 // truncation will be silent and remain undetected.\n@@ -1603,7 +1603,7 @@ struct VariantMemberDescriptionFactory<'ll, 'tcx> {\n     /// Cloned from the `layout::Struct` describing the variant.\n     offsets: Vec<Size>,\n     args: Vec<(String, Ty<'tcx>)>,\n-    discriminant_type_metadata: Option<&'ll DIType>,\n+    tag_type_metadata: Option<&'ll DIType>,\n     span: Span,\n }\n \n@@ -1617,7 +1617,7 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n                 MemberDescription {\n                     name: name.to_string(),\n                     type_metadata: if use_enum_fallback(cx) {\n-                        match self.discriminant_type_metadata {\n+                        match self.tag_type_metadata {\n                             // Discriminant is always the first field of our variant\n                             // when using the enum fallback.\n                             Some(metadata) if i == 0 => metadata,\n@@ -1637,11 +1637,14 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n     }\n }\n \n+// FIXME: terminology here should be aligned with `abi::TagEncoding`.\n+// `OptimizedTag` is `TagEncoding::Niche`, `RegularTag` is `TagEncoding::Direct`.\n+// `NoTag` should be removed; users should use `Option<EnumTagInfo>` instead.\n #[derive(Copy, Clone)]\n-enum EnumDiscriminantInfo<'ll> {\n-    RegularDiscriminant { discr_field: Field, discr_type_metadata: &'ll DIType },\n-    OptimizedDiscriminant,\n-    NoDiscriminant,\n+enum EnumTagInfo<'ll> {\n+    RegularTag { tag_field: Field, tag_type_metadata: &'ll DIType },\n+    OptimizedTag,\n+    NoTag,\n }\n \n #[derive(Copy, Clone)]\n@@ -1706,7 +1709,7 @@ fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyAndLayout<'tcx>,\n     variant: VariantInfo<'_, 'tcx>,\n-    discriminant_info: EnumDiscriminantInfo<'ll>,\n+    discriminant_info: EnumTagInfo<'ll>,\n     containing_scope: &'ll DIScope,\n     span: Span,\n ) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n@@ -1722,12 +1725,12 @@ fn describe_enum_variant(\n     let (offsets, args) = if use_enum_fallback(cx) {\n         // If this is not a univariant enum, there is also the discriminant field.\n         let (discr_offset, discr_arg) = match discriminant_info {\n-            RegularDiscriminant { discr_field, .. } => {\n+            RegularTag { tag_field, .. } => {\n                 // We have the layout of an enum variant, we need the layout of the outer enum\n                 let enum_layout = cx.layout_of(layout.ty);\n-                let offset = enum_layout.fields.offset(discr_field.as_usize());\n+                let offset = enum_layout.fields.offset(tag_field.as_usize());\n                 let args =\n-                    (\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, discr_field.as_usize()).ty);\n+                    (\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, tag_field.as_usize()).ty);\n                 (Some(offset), Some(args))\n             }\n             _ => (None, None),\n@@ -1757,8 +1760,8 @@ fn describe_enum_variant(\n     let member_description_factory = VariantMDF(VariantMemberDescriptionFactory {\n         offsets,\n         args,\n-        discriminant_type_metadata: match discriminant_info {\n-            RegularDiscriminant { discr_type_metadata, .. } => Some(discr_type_metadata),\n+        tag_type_metadata: match discriminant_info {\n+            RegularTag { tag_type_metadata, .. } => Some(tag_type_metadata),\n             _ => None,\n         },\n         span,\n@@ -1880,18 +1883,18 @@ fn prepare_enum_metadata(\n \n     if let (\n         &Abi::Scalar(_),\n-        &Variants::Multiple { discr_kind: DiscriminantKind::Tag, ref discr, .. },\n+        &Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. },\n     ) = (&layout.abi, &layout.variants)\n     {\n-        return FinalMetadata(discriminant_type_metadata(discr.value));\n+        return FinalMetadata(discriminant_type_metadata(tag.value));\n     }\n \n     if use_enum_fallback(cx) {\n         let discriminant_type_metadata = match layout.variants {\n             Variants::Single { .. }\n-            | Variants::Multiple { discr_kind: DiscriminantKind::Niche { .. }, .. } => None,\n-            Variants::Multiple { discr_kind: DiscriminantKind::Tag, ref discr, .. } => {\n-                Some(discriminant_type_metadata(discr.value))\n+            | Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, .. } => None,\n+            Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. } => {\n+                Some(discriminant_type_metadata(tag.value))\n             }\n         };\n \n@@ -1927,7 +1930,7 @@ fn prepare_enum_metadata(\n             EnumMDF(EnumMemberDescriptionFactory {\n                 enum_type,\n                 layout,\n-                discriminant_type_metadata,\n+                tag_type_metadata: discriminant_type_metadata,\n                 containing_scope,\n                 span,\n             }),\n@@ -1943,24 +1946,21 @@ fn prepare_enum_metadata(\n         Variants::Single { .. } => None,\n \n         Variants::Multiple {\n-            discr_kind: DiscriminantKind::Niche { .. },\n-            ref discr,\n-            discr_index,\n-            ..\n+            tag_encoding: TagEncoding::Niche { .. }, ref tag, tag_field, ..\n         } => {\n             // Find the integer type of the correct size.\n-            let size = discr.value.size(cx);\n-            let align = discr.value.align(cx);\n+            let size = tag.value.size(cx);\n+            let align = tag.value.align(cx);\n \n-            let discr_type = match discr.value {\n+            let tag_type = match tag.value {\n                 Int(t, _) => t,\n                 F32 => Integer::I32,\n                 F64 => Integer::I64,\n                 Pointer => cx.data_layout().ptr_sized_integer(),\n             }\n             .to_ty(cx.tcx, false);\n \n-            let discr_metadata = basic_type_metadata(cx, discr_type);\n+            let tag_metadata = basic_type_metadata(cx, tag_type);\n             unsafe {\n                 Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n@@ -1971,17 +1971,15 @@ fn prepare_enum_metadata(\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n                     align.abi.bits() as u32,\n-                    layout.fields.offset(discr_index).bits(),\n+                    layout.fields.offset(tag_field).bits(),\n                     DIFlags::FlagArtificial,\n-                    discr_metadata,\n+                    tag_metadata,\n                 ))\n             }\n         }\n \n-        Variants::Multiple {\n-            discr_kind: DiscriminantKind::Tag, ref discr, discr_index, ..\n-        } => {\n-            let discr_type = discr.value.to_ty(cx.tcx);\n+        Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, tag_field, .. } => {\n+            let discr_type = tag.value.to_ty(cx.tcx);\n             let (size, align) = cx.size_and_align_of(discr_type);\n \n             let discr_metadata = basic_type_metadata(cx, discr_type);\n@@ -1995,7 +1993,7 @@ fn prepare_enum_metadata(\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n                     align.bits() as u32,\n-                    layout.fields.offset(discr_index).bits(),\n+                    layout.fields.offset(tag_field).bits(),\n                     DIFlags::FlagArtificial,\n                     discr_metadata,\n                 ))\n@@ -2081,7 +2079,7 @@ fn prepare_enum_metadata(\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type,\n             layout,\n-            discriminant_type_metadata: None,\n+            tag_type_metadata: None,\n             containing_scope,\n             span,\n         }),"}, {"sha": "95465939070a0e62a6e8a9749df0386fa67fc890", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -7,6 +7,8 @@ use crate::type_of::LayoutLlvmExt;\n use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n \n+use log::debug;\n+\n use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n@@ -21,6 +23,7 @@ use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::Span;\n+use rustc_span::Symbol;\n use rustc_target::abi::{self, HasDataLayout, LayoutOf, Primitive};\n use rustc_target::spec::PanicStrategy;\n \n@@ -86,6 +89,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         args: &[OperandRef<'tcx, &'ll Value>],\n         llresult: &'ll Value,\n         span: Span,\n+        caller_instance: ty::Instance<'tcx>,\n     ) {\n         let tcx = self.tcx;\n         let callee_ty = instance.monomorphic_ty(tcx);\n@@ -136,6 +140,28 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let llfn = self.get_intrinsic(&(\"llvm.debugtrap\"));\n                 self.call(llfn, &[], None)\n             }\n+            \"count_code_region\" => {\n+                if let ty::InstanceDef::Item(fn_def_id) = caller_instance.def {\n+                    let caller_fn_path = tcx.def_path_str(fn_def_id);\n+                    debug!(\n+                        \"count_code_region to llvm.instrprof.increment(fn_name={})\",\n+                        caller_fn_path\n+                    );\n+\n+                    // FIXME(richkadel): (1) Replace raw function name with mangled function name;\n+                    // (2) Replace hardcoded `1234` in `hash` with a computed hash (as discussed in)\n+                    // the MCP (compiler-team/issues/278); and replace the hardcoded `1` for\n+                    // `num_counters` with the actual number of counters per function (when the\n+                    // changes are made to inject more than one counter per function).\n+                    let (fn_name, _len_val) = self.const_str(Symbol::intern(&caller_fn_path));\n+                    let index = args[0].immediate();\n+                    let hash = self.const_u64(1234);\n+                    let num_counters = self.const_u32(1);\n+                    self.instrprof_increment(fn_name, hash, num_counters, index)\n+                } else {\n+                    bug!(\"intrinsic count_code_region: no src.instance\");\n+                }\n+            }\n             \"va_start\" => self.va_start(args[0].immediate()),\n             \"va_end\" => self.va_end(args[0].immediate()),\n             \"va_copy\" => {"}, {"sha": "372fb17573a4bd8069cb6577980168226e7a5efa", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1360,6 +1360,7 @@ extern \"C\" {\n \n     // Miscellaneous instructions\n     pub fn LLVMBuildPhi(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMRustGetInstrprofIncrementIntrinsic(M: &Module) -> &'a Value;\n     pub fn LLVMRustBuildCall(\n         B: &Builder<'a>,\n         Fn: &'a Value,"}, {"sha": "1eef86f6c931c8e73daba26ac482c558456411da", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1075,6 +1075,10 @@ fn get_object_file_path(sess: &Session, name: &str) -> PathBuf {\n     if file_path.exists() {\n         return file_path;\n     }\n+    let file_path = fs.get_selfcontained_lib_path().join(name);\n+    if file_path.exists() {\n+        return file_path;\n+    }\n     for search_path in fs.search_paths() {\n         let file_path = search_path.dir.join(name);\n         if file_path.exists() {\n@@ -1470,6 +1474,9 @@ fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session) {\n     // The location of crates will be determined as needed.\n     let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+\n+    let lib_path = sess.target_filesearch(PathKind::All).get_selfcontained_lib_path();\n+    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n }\n \n /// Add options making relocation sections in the produced ELF files read-only"}, {"sha": "6011d422ca682c174549f72432a485e6e97f676a", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -721,12 +721,14 @@ impl<'a> Linker for MsvcLinker<'a> {\n     }\n \n     fn link_whole_staticlib(&mut self, lib: Symbol, _search_path: &[PathBuf]) {\n-        // not supported?\n         self.link_staticlib(lib);\n+        self.cmd.arg(format!(\"/WHOLEARCHIVE:{}.lib\", lib));\n     }\n     fn link_whole_rlib(&mut self, path: &Path) {\n-        // not supported?\n         self.link_rlib(path);\n+        let mut arg = OsString::from(\"/WHOLEARCHIVE:\");\n+        arg.push(path);\n+        self.cmd.arg(arg);\n     }\n     fn optimize(&mut self) {\n         // Needs more investigation of `/OPT` arguments"}, {"sha": "98f7da8361cc408b9041265f0e9a43dfa2bd5bf8", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -89,10 +89,12 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n                 | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n                     let def_id = tcx.hir().local_def_id(hir_id);\n                     let generics = tcx.generics_of(def_id);\n-                    if !generics.requires_monomorphization(tcx) &&\n-                        // Functions marked with #[inline] are only ever codegened\n-                        // with \"internal\" linkage and are never exported.\n-                        !Instance::mono(tcx, def_id.to_def_id()).def.generates_cgu_internal_copy(tcx)\n+                    if !generics.requires_monomorphization(tcx)\n+                        // Functions marked with #[inline] are codegened with \"internal\"\n+                        // linkage and are not exported unless marked with an extern\n+                        // inidicator\n+                        && (!Instance::mono(tcx, def_id.to_def_id()).def.generates_cgu_internal_copy(tcx)\n+                            || tcx.codegen_fn_attrs(def_id.to_def_id()).contains_extern_indicator())\n                     {\n                         Some(def_id)\n                     } else {"}, {"sha": "49054765b9dae73e92aabe78e976b50cd98f41a4", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -175,6 +175,12 @@ impl ModuleConfig {\n                     if sess.opts.debugging_opts.profile && !is_compiler_builtins {\n                         passes.push(\"insert-gcov-profiling\".to_owned());\n                     }\n+\n+                    // The rustc option `-Zinstrument_coverage` injects intrinsic calls to\n+                    // `llvm.instrprof.increment()`, which requires the LLVM `instrprof` pass.\n+                    if sess.opts.debugging_opts.instrument_coverage {\n+                        passes.push(\"instrprof\".to_owned());\n+                    }\n                     passes\n                 },\n                 vec![]"}, {"sha": "a64489c04c81dc4e07df0656f11415f4c42b2060", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -195,7 +195,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n                 tcx.def_key(def_id).disambiguated_data.disambiguator\n             ));\n         }\n-        ty::Error\n+        ty::Error(_)\n         | ty::Infer(_)\n         | ty::Placeholder(..)\n         | ty::Projection(..)"}, {"sha": "db935c2b3e2658a027ba7525da21a38e90146a44", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -234,8 +234,8 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n         self.visit_rvalue(rvalue, location);\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &mir::TerminatorKind<'tcx>, location: Location) {\n-        let check = match *kind {\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n+        let check = match terminator.kind {\n             mir::TerminatorKind::Call { func: mir::Operand::Constant(ref c), ref args, .. } => {\n                 match c.literal.ty.kind {\n                     ty::FnDef(did, _) => Some((did, args)),\n@@ -259,7 +259,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             }\n         }\n \n-        self.super_terminator_kind(kind, location);\n+        self.super_terminator(terminator, location);\n     }\n \n     fn visit_place(&mut self, place: &mir::Place<'tcx>, context: PlaceContext, location: Location) {"}, {"sha": "d56c816811b3c46d68056e7b662ddba6c08724db", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -693,6 +693,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 &args,\n                 dest,\n                 terminator.source_info.span,\n+                self.instance,\n             );\n \n             if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n@@ -998,8 +999,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx.unreachable();\n             }\n \n-            mir::TerminatorKind::Drop { location, target, unwind } => {\n-                self.codegen_drop_terminator(helper, bx, location, target, unwind);\n+            mir::TerminatorKind::Drop { place, target, unwind } => {\n+                self.codegen_drop_terminator(helper, bx, place, target, unwind);\n             }\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {"}, {"sha": "0c8638b673d4fbdab5269a40588e22b2d458ba34", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::mir;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::{self, Ty};\n-use rustc_target::abi::{Abi, Align, DiscriminantKind, FieldsShape, Int};\n+use rustc_target::abi::{Abi, Align, FieldsShape, Int, TagEncoding};\n use rustc_target::abi::{LayoutOf, VariantIdx, Variants};\n \n #[derive(Copy, Clone, Debug)]\n@@ -199,7 +199,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_undef(cast_to);\n         }\n-        let (discr_scalar, discr_kind, discr_index) = match self.layout.variants {\n+        let (tag_scalar, tag_encoding, tag_field) = match self.layout.variants {\n             Variants::Single { index } => {\n                 let discr_val = self\n                     .layout\n@@ -208,33 +208,33 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     .map_or(index.as_u32() as u128, |discr| discr.val);\n                 return bx.cx().const_uint_big(cast_to, discr_val);\n             }\n-            Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n-                (discr, discr_kind, discr_index)\n+            Variants::Multiple { ref tag, ref tag_encoding, tag_field, .. } => {\n+                (tag, tag_encoding, tag_field)\n             }\n         };\n \n         // Read the tag/niche-encoded discriminant from memory.\n-        let encoded_discr = self.project_field(bx, discr_index);\n-        let encoded_discr = bx.load_operand(encoded_discr);\n+        let tag = self.project_field(bx, tag_field);\n+        let tag = bx.load_operand(tag);\n \n         // Decode the discriminant (specifically if it's niche-encoded).\n-        match *discr_kind {\n-            DiscriminantKind::Tag => {\n-                let signed = match discr_scalar.value {\n+        match *tag_encoding {\n+            TagEncoding::Direct => {\n+                let signed = match tag_scalar.value {\n                     // We use `i1` for bytes that are always `0` or `1`,\n                     // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n                     // let LLVM interpret the `i1` as signed, because\n                     // then `i1 1` (i.e., `E::B`) is effectively `i8 -1`.\n-                    Int(_, signed) => !discr_scalar.is_bool() && signed,\n+                    Int(_, signed) => !tag_scalar.is_bool() && signed,\n                     _ => false,\n                 };\n-                bx.intcast(encoded_discr.immediate(), cast_to, signed)\n+                bx.intcast(tag.immediate(), cast_to, signed)\n             }\n-            DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+            TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n                 // Rebase from niche values to discriminants, and check\n                 // whether the result is in range for the niche variants.\n-                let niche_llty = bx.cx().immediate_backend_type(encoded_discr.layout);\n-                let encoded_discr = encoded_discr.immediate();\n+                let niche_llty = bx.cx().immediate_backend_type(tag.layout);\n+                let tag = tag.immediate();\n \n                 // We first compute the \"relative discriminant\" (wrt `niche_variants`),\n                 // that is, if `n = niche_variants.end() - niche_variants.start()`,\n@@ -248,9 +248,9 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 let relative_discr = if niche_start == 0 {\n                     // Avoid subtracting `0`, which wouldn't work for pointers.\n                     // FIXME(eddyb) check the actual primitive type here.\n-                    encoded_discr\n+                    tag\n                 } else {\n-                    bx.sub(encoded_discr, bx.cx().const_uint_big(niche_llty, niche_start))\n+                    bx.sub(tag, bx.cx().const_uint_big(niche_llty, niche_start))\n                 };\n                 let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n                 let is_niche = {\n@@ -312,8 +312,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             Variants::Single { index } => {\n                 assert_eq!(index, variant_index);\n             }\n-            Variants::Multiple { discr_kind: DiscriminantKind::Tag, discr_index, .. } => {\n-                let ptr = self.project_field(bx, discr_index);\n+            Variants::Multiple { tag_encoding: TagEncoding::Direct, tag_field, .. } => {\n+                let ptr = self.project_field(bx, tag_field);\n                 let to =\n                     self.layout.ty.discriminant_for_variant(bx.tcx(), variant_index).unwrap().val;\n                 bx.store(\n@@ -323,9 +323,9 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 );\n             }\n             Variants::Multiple {\n-                discr_kind:\n-                    DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start },\n-                discr_index,\n+                tag_encoding:\n+                    TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n+                tag_field,\n                 ..\n             } => {\n                 if variant_index != dataful_variant {\n@@ -339,7 +339,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                         bx.memset(self.llval, fill_byte, size, self.align, MemFlags::empty());\n                     }\n \n-                    let niche = self.project_field(bx, discr_index);\n+                    let niche = self.project_field(bx, tag_field);\n                     let niche_llty = bx.cx().immediate_backend_type(niche.layout);\n                     let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                     let niche_value = (niche_value as u128).wrapping_add(niche_start);"}, {"sha": "7ffc9f15bffdc59fb6d529834ab7244b1fee5c06", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -260,6 +260,14 @@ pub trait BuilderMethods<'a, 'tcx>:\n     /// Called for `StorageDead`\n     fn lifetime_end(&mut self, ptr: Self::Value, size: Size);\n \n+    fn instrprof_increment(\n+        &mut self,\n+        fn_name: Self::Value,\n+        hash: Self::Value,\n+        num_counters: Self::Value,\n+        index: Self::Value,\n+    ) -> Self::Value;\n+\n     fn call(\n         &mut self,\n         llfn: Self::Value,"}, {"sha": "f62019498511c48c166b9280c277948444965811", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -15,6 +15,7 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n         args: &[OperandRef<'tcx, Self::Value>],\n         llresult: Self::Value,\n         span: Span,\n+        caller_instance: ty::Instance<'tcx>,\n     );\n \n     fn abort(&mut self);"}, {"sha": "997762efcb3e5f3dd0314c5ece1d0ccc5b8d4178", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -439,9 +439,11 @@ E0752: include_str!(\"./error_codes/E0752.md\"),\n E0753: include_str!(\"./error_codes/E0753.md\"),\n E0754: include_str!(\"./error_codes/E0754.md\"),\n E0758: include_str!(\"./error_codes/E0758.md\"),\n+E0759: include_str!(\"./error_codes/E0759.md\"),\n E0760: include_str!(\"./error_codes/E0760.md\"),\n E0761: include_str!(\"./error_codes/E0761.md\"),\n E0762: include_str!(\"./error_codes/E0762.md\"),\n+E0763: include_str!(\"./error_codes/E0763.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "a74759bdf634b0c5deb874b8269468d5d2981507", "filename": "src/librustc_error_codes/error_codes/E0759.md", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_error_codes%2Ferror_codes%2FE0759.md", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_error_codes%2Ferror_codes%2FE0759.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0759.md?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,67 @@\n+A `'static` requirement in a return type involving a trait is not fulfilled.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0759\n+use std::fmt::Debug;\n+\n+fn foo(x: &i32) -> impl Debug {\n+    x\n+}\n+```\n+\n+```compile_fail,E0759\n+# use std::fmt::Debug;\n+fn bar(x: &i32) -> Box<dyn Debug> {\n+    Box::new(x)\n+}\n+```\n+\n+These examples have the same semantics as the following:\n+\n+```compile_fail,E0759\n+# use std::fmt::Debug;\n+fn foo(x: &i32) -> impl Debug + 'static {\n+    x\n+}\n+```\n+\n+```compile_fail,E0759\n+# use std::fmt::Debug;\n+fn bar(x: &i32) -> Box<dyn Debug + 'static> {\n+    Box::new(x)\n+}\n+```\n+\n+Both [`dyn Trait`] and [`impl Trait`] in return types have a an implicit\n+`'static` requirement, meaning that the value implementing them that is being\n+returned has to be either a `'static` borrow or an owned value.\n+\n+In order to change the requirement from `'static` to be a lifetime derived from\n+its arguments, you can add an explicit bound, either to an anonymous lifetime\n+`'_` or some appropriate named lifetime.\n+\n+```\n+# use std::fmt::Debug;\n+fn foo(x: &i32) -> impl Debug + '_ {\n+    x\n+}\n+fn bar(x: &i32) -> Box<dyn Debug + '_> {\n+    Box::new(x)\n+}\n+```\n+\n+These are equivalent to the following explicit lifetime annotations:\n+\n+```\n+# use std::fmt::Debug;\n+fn foo<'a>(x: &'a i32) -> impl Debug + 'a {\n+    x\n+}\n+fn bar<'a>(x: &'a i32) -> Box<dyn Debug + 'a> {\n+    Box::new(x)\n+}\n+```\n+\n+[`dyn Trait`]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n+[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits"}, {"sha": "095b779f3e78afdf50a425e1fa914896e76fae36", "filename": "src/librustc_error_codes/error_codes/E0763.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_error_codes%2Ferror_codes%2FE0763.md", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_error_codes%2Ferror_codes%2FE0763.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0763.md?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,13 @@\n+A byte constant wasn't correctly ended.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0763\n+let c = b'a; // error!\n+```\n+\n+To fix this error, add the missing quote:\n+\n+```\n+let c = b'a'; // ok!\n+```"}, {"sha": "0c1418d3cad279ebe8d806b3dd9d62af87d1d6fe", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -5,6 +5,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(crate_visibility_modifier)]\n #![feature(nll)]\n+#![feature(track_caller)]\n \n pub use emitter::ColorConfig;\n \n@@ -621,6 +622,7 @@ impl Handler {\n         self.inner.borrow_mut().span_bug(span, msg)\n     }\n \n+    #[track_caller]\n     pub fn delay_span_bug(&self, span: impl Into<MultiSpan>, msg: &str) {\n         self.inner.borrow_mut().delay_span_bug(span, msg)\n     }\n@@ -873,6 +875,7 @@ impl HandlerInner {\n         self.emit_diagnostic(diag.set_span(sp));\n     }\n \n+    #[track_caller]\n     fn delay_span_bug(&mut self, sp: impl Into<MultiSpan>, msg: &str) {\n         // This is technically `self.treat_err_as_bug()` but `delay_span_bug` is called before\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n@@ -883,6 +886,7 @@ impl HandlerInner {\n         }\n         let mut diagnostic = Diagnostic::new(Level::Bug, msg);\n         diagnostic.set_span(sp.into());\n+        diagnostic.note(&format!(\"delayed at {}\", std::panic::Location::caller()));\n         self.delay_as_bug(diagnostic)\n     }\n "}, {"sha": "bed2044c7085515dbef5371c87dd9e176334ae6a", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2726,6 +2726,18 @@ impl Node<'_> {\n         }\n     }\n \n+    pub fn body_id(&self) -> Option<BodyId> {\n+        match self {\n+            Node::TraitItem(TraitItem {\n+                kind: TraitItemKind::Fn(_, TraitFn::Provided(body_id)),\n+                ..\n+            })\n+            | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(_, body_id), .. })\n+            | Node::Item(Item { kind: ItemKind::Fn(.., body_id), .. }) => Some(*body_id),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn generics(&self) -> Option<&Generics<'_>> {\n         match self {\n             Node::TraitItem(TraitItem { generics, .. })"}, {"sha": "091ded6d74d0feb291a9a06bdb03f894cac21fc3", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -242,6 +242,8 @@ language_item_table! {\n \n     StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n \n+    CountCodeRegionFnLangItem,   \"count_code_region\",  count_code_region_fn,    Target::Fn;\n+\n     EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n     EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n "}, {"sha": "427cc55a428ae163846b9230c729e3383c52efa0", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -403,7 +403,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             | ty::Float(..)\n             | ty::Adt(..)\n             | ty::Str\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Array(..)\n             | ty::Slice(..)\n             | ty::RawPtr(..)"}, {"sha": "2b8c46f1de42def2944d6e2af76d3b18bd56279e", "filename": "src/librustc_infer/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -154,7 +154,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 self.tcx\n                     .mk_const(ty::Const {\n                         val: ty::ConstKind::Placeholder(placeholder_mapped),\n-                        ty: self.tcx.types.err, // FIXME(const_generics)\n+                        ty: self.tcx.ty_error(), // FIXME(const_generics)\n                     })\n                     .into()\n             }"}, {"sha": "9cfa11dd7c813ff7ffdb2aeab7847b821fbdb939", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2035,8 +2035,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             self.tcx.sess,\n             var_origin.span(),\n             E0495,\n-            \"cannot infer an appropriate lifetime{} \\\n-             due to conflicting requirements\",\n+            \"cannot infer an appropriate lifetime{} due to conflicting requirements\",\n             var_description\n         )\n     }"}, {"sha": "82feebc80292a27476089da8f8cfbc7b271fdec5", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 157, "deletions": 33, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,14 +1,15 @@\n //! Error Reporting for static impl Traits.\n \n-use crate::infer::error_reporting::msg_span_from_free_region;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use rustc_errors::{Applicability, ErrorReported};\n+use rustc_errors::{struct_span_err, Applicability, ErrorReported};\n+use rustc_hir::{GenericBound, ItemKind, Lifetime, LifetimeName, TyKind};\n use rustc_middle::ty::RegionKind;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n+        debug!(\"try_report_static_impl_trait(error={:?})\", self.error);\n         if let Some(ref error) = self.error {\n             if let RegionResolutionError::SubSupConflict(\n                 _,\n@@ -17,18 +18,36 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 sub_r,\n                 sup_origin,\n                 sup_r,\n-            ) = error.clone()\n+            ) = error\n             {\n+                debug!(\n+                    \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n+                    var_origin, sub_origin, sub_r, sup_origin, sup_r\n+                );\n                 let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n-                let (fn_return_span, is_dyn) =\n-                    self.tcx().return_type_impl_or_dyn_trait(anon_reg_sup.def_id)?;\n-                if sub_r == &RegionKind::ReStatic {\n+                debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n+                let fn_return = self.tcx().return_type_impl_or_dyn_trait(anon_reg_sup.def_id)?;\n+                debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_return);\n+                if **sub_r == RegionKind::ReStatic {\n                     let sp = var_origin.span();\n                     let return_sp = sub_origin.span();\n-                    let mut err =\n-                        self.tcx().sess.struct_span_err(sp, \"cannot infer an appropriate lifetime\");\n                     let param_info = self.find_param_with_region(sup_r, sub_r)?;\n-                    err.span_label(param_info.param_ty_span, \"data with this lifetime...\");\n+                    let (lifetime_name, lifetime) = if sup_r.has_name() {\n+                        (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n+                    } else {\n+                        (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n+                    };\n+                    let mut err = struct_span_err!(\n+                        self.tcx().sess,\n+                        sp,\n+                        E0759,\n+                        \"cannot infer an appropriate lifetime\"\n+                    );\n+                    err.span_label(\n+                        param_info.param_ty_span,\n+                        &format!(\"this data with {}...\", lifetime),\n+                    );\n+                    debug!(\"try_report_static_impl_trait: param_info={:?}\", param_info);\n \n                     // We try to make the output have fewer overlapping spans if possible.\n                     if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n@@ -38,41 +57,146 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n                         // Customize the spans and labels depending on their relative order so\n                         // that split sentences flow correctly.\n-                        if sup_origin.span().shrink_to_hi() <= return_sp.shrink_to_lo() {\n-                            err.span_label(sup_origin.span(), \"...is captured here...\");\n-                            err.span_label(return_sp, \"...and required to be `'static` by this\");\n+                        if sup_origin.span().overlaps(return_sp) && sp == sup_origin.span() {\n+                            // Avoid the following:\n+                            //\n+                            // error: cannot infer an appropriate lifetime\n+                            //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                            //    |\n+                            // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                            //    |           ----                      ---------^-\n+                            //\n+                            // and instead show:\n+                            //\n+                            // error: cannot infer an appropriate lifetime\n+                            //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                            //    |\n+                            // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                            //    |           ----                               ^\n+                            err.span_label(\n+                                sup_origin.span(),\n+                                \"...is captured here, requiring it to live as long as `'static`\",\n+                            );\n                         } else {\n-                            err.span_label(return_sp, \"...is required to be `'static` by this...\");\n-                            err.span_label(sup_origin.span(), \"...and is captured here\");\n+                            err.span_label(sup_origin.span(), \"...is captured here...\");\n+                            if return_sp < sup_origin.span() {\n+                                err.span_note(\n+                                    return_sp,\n+                                    \"...and is required to live as long as `'static` here\",\n+                                );\n+                            } else {\n+                                err.span_label(\n+                                    return_sp,\n+                                    \"...and is required to live as long as `'static` here\",\n+                                );\n+                            }\n                         }\n                     } else {\n                         err.span_label(\n                             return_sp,\n-                            \"...is captured and required to be `'static` here\",\n+                            \"...is captured and required to live as long as `'static` here\",\n                         );\n                     }\n \n-                    let (lifetime, _) = msg_span_from_free_region(self.tcx(), sup_r);\n-\n-                    let lifetime_name =\n-                        if sup_r.has_name() { sup_r.to_string() } else { \"'_\".to_owned() };\n                     // only apply this suggestion onto functions with\n                     // explicit non-desugar'able return.\n-                    if fn_return_span.desugaring_kind().is_none() {\n-                        let msg = format!(\n-                            \"to permit non-static references in {} `{} Trait` value, you can add \\\n-                             an explicit bound for {}\",\n-                            if is_dyn { \"a\" } else { \"an\" },\n-                            if is_dyn { \"dyn\" } else { \"impl\" },\n-                            lifetime,\n-                        );\n+                    if fn_return.span.desugaring_kind().is_none() {\n                         // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-                        err.span_suggestion_verbose(\n-                            fn_return_span.shrink_to_hi(),\n-                            &msg,\n-                            format!(\" + {}\", lifetime_name),\n-                            Applicability::MaybeIncorrect,\n-                        );\n+\n+                        let consider = \"consider changing the\";\n+                        let declare = \"to declare that the\";\n+                        let arg = match param_info.param.pat.simple_ident() {\n+                            Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+                            None => \"the argument\".to_string(),\n+                        };\n+                        let explicit =\n+                            format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n+                        let explicit_static =\n+                            format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n+                        let captures = format!(\"captures data from {}\", arg);\n+                        let add_static_bound =\n+                            \"alternatively, add an explicit `'static` bound to this reference\";\n+                        let plus_lt = format!(\" + {}\", lifetime_name);\n+                        match fn_return.kind {\n+                            TyKind::OpaqueDef(item_id, _) => {\n+                                let item = self.tcx().hir().item(item_id.id);\n+                                let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n+                                    opaque\n+                                } else {\n+                                    err.emit();\n+                                    return Some(ErrorReported);\n+                                };\n+\n+                                if let Some(span) = opaque\n+                                    .bounds\n+                                    .iter()\n+                                    .filter_map(|arg| match arg {\n+                                        GenericBound::Outlives(Lifetime {\n+                                            name: LifetimeName::Static,\n+                                            span,\n+                                            ..\n+                                        }) => Some(*span),\n+                                        _ => None,\n+                                    })\n+                                    .next()\n+                                {\n+                                    err.span_suggestion_verbose(\n+                                        span,\n+                                        &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n+                                        lifetime_name,\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                    err.span_suggestion_verbose(\n+                                        param_info.param_ty_span,\n+                                        add_static_bound,\n+                                        param_info.param_ty.to_string(),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                } else {\n+                                    err.span_suggestion_verbose(\n+                                        fn_return.span.shrink_to_hi(),\n+                                        &format!(\n+                                            \"{declare} `impl Trait` {captures}, {explicit}\",\n+                                            declare = declare,\n+                                            captures = captures,\n+                                            explicit = explicit,\n+                                        ),\n+                                        plus_lt,\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                };\n+                            }\n+                            TyKind::TraitObject(_, lt) => match lt.name {\n+                                LifetimeName::ImplicitObjectLifetimeDefault => {\n+                                    err.span_suggestion_verbose(\n+                                        fn_return.span.shrink_to_hi(),\n+                                        &format!(\n+                                            \"{declare} trait object {captures}, {explicit}\",\n+                                            declare = declare,\n+                                            captures = captures,\n+                                            explicit = explicit,\n+                                        ),\n+                                        plus_lt,\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n+                                _ => {\n+                                    err.span_suggestion_verbose(\n+                                        lt.span,\n+                                        &format!(\"{} trait object's {}\", consider, explicit_static),\n+                                        lifetime_name,\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                    err.span_suggestion_verbose(\n+                                        param_info.param_ty_span,\n+                                        add_static_bound,\n+                                        param_info.param_ty.to_string(),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n+                            },\n+                            _ => {}\n+                        }\n                     }\n                     err.emit();\n                     return Some(ErrorReported);"}, {"sha": "02bebe10ed04afa124c57bb82733c103d2c92b4e", "filename": "src/librustc_infer/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -192,7 +192,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::Float(..)\n             | ty::Adt(..)\n             | ty::Str\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Array(..)\n             | ty::Slice(..)\n             | ty::RawPtr(..)\n@@ -250,7 +250,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ConstKind::Param(_)\n             | ty::ConstKind::Value(_)\n             | ty::ConstKind::Unevaluated(..)\n-            | ty::ConstKind::Error => {}\n+            | ty::ConstKind::Error(_) => {}\n         }\n \n         ct.super_fold_with(self)"}, {"sha": "91f4b3323f30efc82a5e2f21e3c3b73cbc221e4d", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1751,9 +1751,10 @@ impl<'tcx> TypeTrace<'tcx> {\n     }\n \n     pub fn dummy(tcx: TyCtxt<'tcx>) -> TypeTrace<'tcx> {\n+        let err = tcx.ty_error();\n         TypeTrace {\n             cause: ObligationCause::dummy(),\n-            values: Types(ExpectedFound { expected: tcx.types.err, found: tcx.types.err }),\n+            values: Types(ExpectedFound { expected: err, found: err }),\n         }\n     }\n }"}, {"sha": "df166d21a36c3dce423913bb5beeeceb24ed9aa1", "filename": "src/librustc_infer/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fresolve.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -189,15 +189,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n             match t.kind {\n                 ty::Infer(ty::TyVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedTy(vid));\n-                    self.tcx().types.err\n+                    self.tcx().ty_error()\n                 }\n                 ty::Infer(ty::IntVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedIntTy(vid));\n-                    self.tcx().types.err\n+                    self.tcx().ty_error()\n                 }\n                 ty::Infer(ty::FloatVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedFloatTy(vid));\n-                    self.tcx().types.err\n+                    self.tcx().ty_error()\n                 }\n                 ty::Infer(_) => {\n                     bug!(\"Unexpected type in full type resolver: {:?}\", t);\n@@ -228,7 +228,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n             match c.val {\n                 ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                     self.err = Some(FixupError::UnresolvedConst(vid));\n-                    return self.tcx().mk_const(ty::Const { val: ty::ConstKind::Error, ty: c.ty });\n+                    return self.tcx().const_error(c.ty);\n                 }\n                 ty::ConstKind::Infer(InferConst::Fresh(_)) => {\n                     bug!(\"Unexpected const in full const resolver: {:?}\", c);"}, {"sha": "90962d210b5b48198f35f9e1391bda8cf16c6aeb", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -119,9 +119,9 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 Ok(a)\n             }\n \n-            (&ty::Error, _) | (_, &ty::Error) => {\n+            (&ty::Error(_), _) | (_, &ty::Error(_)) => {\n                 infcx.set_tainted_by_errors();\n-                Ok(self.tcx().types.err)\n+                Ok(self.tcx().ty_error())\n             }\n \n             _ => {"}, {"sha": "c2a7d1a4a6102739589de9e3921dc4c277df6c72", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -548,6 +548,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(human_readable_cgu_names, true);\n     tracked!(inline_in_all_cgus, Some(true));\n     tracked!(insert_sideeffect, true);\n+    tracked!(instrument_coverage, true);\n     tracked!(instrument_mcount, true);\n     tracked!(link_only, true);\n     tracked!(merge_functions, Some(MergeFunctions::Disabled));"}, {"sha": "d1445f1b2c4a3c3b642cce36e0d18653cdf64141", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use rustc_target::abi::{DiscriminantKind, Integer, LayoutOf, VariantIdx, Variants};\n+use rustc_target::abi::{Integer, LayoutOf, TagEncoding, VariantIdx, Variants};\n use rustc_target::spec::abi::Abi;\n \n use log::debug;\n@@ -889,7 +889,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::Param(..)\n             | ty::Infer(..)\n             | ty::Bound(..)\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Closure(..)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n@@ -1056,15 +1056,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n             };\n             let (variants, tag) = match layout.variants {\n                 Variants::Multiple {\n-                    discr_kind: DiscriminantKind::Tag,\n-                    ref discr,\n+                    tag_encoding: TagEncoding::Direct,\n+                    ref tag,\n                     ref variants,\n                     ..\n-                } => (variants, discr),\n+                } => (variants, tag),\n                 _ => return,\n             };\n \n-            let discr_size = tag.value.size(&cx.tcx).bytes();\n+            let tag_size = tag.value.size(&cx.tcx).bytes();\n \n             debug!(\n                 \"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n@@ -1078,8 +1078,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 .iter()\n                 .zip(variants)\n                 .map(|(variant, variant_layout)| {\n-                    // Subtract the size of the enum discriminant.\n-                    let bytes = variant_layout.size.bytes().saturating_sub(discr_size);\n+                    // Subtract the size of the enum tag.\n+                    let bytes = variant_layout.size.bytes().saturating_sub(tag_size);\n \n                     debug!(\"- variant `{}` is {} bytes large\", variant.ident, bytes);\n                     bytes"}, {"sha": "0dc007bbfd72f8db4fa5acdea855178381a6cd7d", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -452,6 +452,14 @@ impl<'a> CrateLoader<'a> {\n         if dep.is_none() {\n             self.used_extern_options.insert(name);\n         }\n+        if !name.as_str().is_ascii() {\n+            self.sess\n+                .struct_span_err(\n+                    span,\n+                    &format!(\"cannot load a crate with a non-ascii name `{}`\", name,),\n+                )\n+                .emit();\n+        }\n         self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n     }\n \n@@ -698,7 +706,9 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn inject_profiler_runtime(&mut self) {\n-        if (self.sess.opts.debugging_opts.profile || self.sess.opts.cg.profile_generate.enabled())\n+        if (self.sess.opts.debugging_opts.instrument_coverage\n+            || self.sess.opts.debugging_opts.profile\n+            || self.sess.opts.cg.profile_generate.enabled())\n             && !self.sess.opts.debugging_opts.no_profiler_runtime\n         {\n             info!(\"loading profiler\");"}, {"sha": "abbbbf7fbd6a46bc3fde0b300403334fda4983d6", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -390,8 +390,8 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     InvalidBool(u8),\n     /// Using a non-character `u32` as character.\n     InvalidChar(u32),\n-    /// An enum discriminant was set to a value which was outside the range of valid values.\n-    InvalidDiscriminant(Scalar),\n+    /// The tag of an enum does not encode an actual discriminant.\n+    InvalidTag(Scalar),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n     /// Using a string that is not valid UTF-8,\n@@ -463,7 +463,7 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             InvalidChar(c) => {\n                 write!(f, \"interpreting an invalid 32-bit value as a char: 0x{:08x}\", c)\n             }\n-            InvalidDiscriminant(val) => write!(f, \"enum value has invalid discriminant: {}\", val),\n+            InvalidTag(val) => write!(f, \"enum value has invalid tag: {}\", val),\n             InvalidFunctionPointer(p) => {\n                 write!(f, \"using {} as function pointer but it does not point to a function\", p)\n             }"}, {"sha": "3381b95c2a38e1fd9946c29d088ae2c1a6a06a5a", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -29,6 +29,7 @@ use rustc_macros::HashStable;\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_target::abi;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n@@ -1112,7 +1113,7 @@ pub enum TerminatorKind<'tcx> {\n     Unreachable,\n \n     /// Drop the `Place`.\n-    Drop { location: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n+    Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n \n     /// Drop the `Place` and assign the new value over it. This ensures\n     /// that the assignment to `P` occurs *even if* the destructor for\n@@ -1141,7 +1142,7 @@ pub enum TerminatorKind<'tcx> {\n     /// }\n     /// ```\n     DropAndReplace {\n-        location: Place<'tcx>,\n+        place: Place<'tcx>,\n         value: Operand<'tcx>,\n         target: BasicBlock,\n         unwind: Option<BasicBlock>,\n@@ -1607,9 +1608,9 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Abort => write!(fmt, \"abort\"),\n             Yield { value, resume_arg, .. } => write!(fmt, \"{:?} = yield({:?})\", resume_arg, value),\n             Unreachable => write!(fmt, \"unreachable\"),\n-            Drop { location, .. } => write!(fmt, \"drop({:?})\", location),\n-            DropAndReplace { location, value, .. } => {\n-                write!(fmt, \"replace({:?} <- {:?})\", location, value)\n+            Drop { place, .. } => write!(fmt, \"drop({:?})\", place),\n+            DropAndReplace { place, value, .. } => {\n+                write!(fmt, \"replace({:?} <- {:?})\", place, value)\n             }\n             Call { func, args, destination, .. } => {\n                 if let Some((destination, _)) = destination {\n@@ -2218,6 +2219,33 @@ impl<'tcx> Operand<'tcx> {\n         })\n     }\n \n+    /// Convenience helper to make a literal-like constant from a given scalar value.\n+    /// Since this is used to synthesize MIR, assumes `user_ty` is None.\n+    pub fn const_from_scalar(\n+        tcx: TyCtxt<'tcx>,\n+        ty: Ty<'tcx>,\n+        val: Scalar,\n+        span: Span,\n+    ) -> Operand<'tcx> {\n+        debug_assert!({\n+            let param_env_and_ty = ty::ParamEnv::empty().and(ty);\n+            let type_size = tcx\n+                .layout_of(param_env_and_ty)\n+                .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n+                .size;\n+            let scalar_size = abi::Size::from_bytes(match val {\n+                Scalar::Raw { size, .. } => size,\n+                _ => panic!(\"Invalid scalar type {:?}\", val),\n+            });\n+            scalar_size == type_size\n+        });\n+        Operand::Constant(box Constant {\n+            span,\n+            user_ty: None,\n+            literal: ty::Const::from_scalar(tcx, val, ty),\n+        })\n+    }\n+\n     pub fn to_copy(&self) -> Self {\n         match *self {\n             Operand::Copy(_) | Operand::Constant(_) => self.clone(),"}, {"sha": "f1c1b962ab997fbbd698cd6380083aa851240444", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -91,9 +91,9 @@ impl<'tcx> MonoItem<'tcx> {\n         match *self {\n             MonoItem::Fn(ref instance) => {\n                 let entry_def_id = tcx.entry_fn(LOCAL_CRATE).map(|(id, _)| id);\n-                // If this function isn't inlined or otherwise has explicit\n-                // linkage, then we'll be creating a globally shared version.\n-                if self.explicit_linkage(tcx).is_some()\n+                // If this function isn't inlined or otherwise has an extern\n+                // indicator, then we'll be creating a globally shared version.\n+                if tcx.codegen_fn_attrs(instance.def_id()).contains_extern_indicator()\n                     || !instance.def.generates_cgu_internal_copy(tcx)\n                     || Some(instance.def_id()) == entry_def_id.map(LocalDefId::to_def_id)\n                 {\n@@ -102,7 +102,7 @@ impl<'tcx> MonoItem<'tcx> {\n \n                 // At this point we don't have explicit linkage and we're an\n                 // inlined function. If we're inlining into all CGUs then we'll\n-                // be creating a local copy per CGU\n+                // be creating a local copy per CGU.\n                 if generate_cgu_internal_copies {\n                     return InstantiationMode::LocalCopy;\n                 }"}, {"sha": "89f8f10449e2de05d26190f3b3b9a56da37ded3d", "filename": "src/librustc_middle/mir/type_foldable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -27,11 +27,11 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 values: values.clone(),\n                 targets: targets.clone(),\n             },\n-            Drop { ref location, target, unwind } => {\n-                Drop { location: location.fold_with(folder), target, unwind }\n+            Drop { ref place, target, unwind } => {\n+                Drop { place: place.fold_with(folder), target, unwind }\n             }\n-            DropAndReplace { ref location, ref value, target, unwind } => DropAndReplace {\n-                location: location.fold_with(folder),\n+            DropAndReplace { ref place, ref value, target, unwind } => DropAndReplace {\n+                place: place.fold_with(folder),\n                 value: value.fold_with(folder),\n                 target,\n                 unwind,\n@@ -97,9 +97,9 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             SwitchInt { ref discr, switch_ty, .. } => {\n                 discr.visit_with(visitor) || switch_ty.visit_with(visitor)\n             }\n-            Drop { ref location, .. } => location.visit_with(visitor),\n-            DropAndReplace { ref location, ref value, .. } => {\n-                location.visit_with(visitor) || value.visit_with(visitor)\n+            Drop { ref place, .. } => place.visit_with(visitor),\n+            DropAndReplace { ref place, ref value, .. } => {\n+                place.visit_with(visitor) || value.visit_with(visitor)\n             }\n             Yield { ref value, .. } => value.visit_with(visitor),\n             Call { ref func, ref args, ref destination, .. } => {"}, {"sha": "2efc5f1dabedca48ffe6eeb95c2b02efcc8e0f8e", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -108,12 +108,6 @@ macro_rules! make_mir_visitor {\n                 self.super_terminator(terminator, location);\n             }\n \n-            fn visit_terminator_kind(&mut self,\n-                                     kind: & $($mutability)? TerminatorKind<'tcx>,\n-                                     location: Location) {\n-                self.super_terminator_kind(kind, location);\n-            }\n-\n             fn visit_assert_message(&mut self,\n                                     msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n@@ -417,12 +411,6 @@ macro_rules! make_mir_visitor {\n                 let Terminator { source_info, kind } = terminator;\n \n                 self.visit_source_info(source_info);\n-                self.visit_terminator_kind(kind, location);\n-            }\n-\n-            fn super_terminator_kind(&mut self,\n-                                     kind: & $($mutability)? TerminatorKind<'tcx>,\n-                                     source_location: Location) {\n                 match kind {\n                     TerminatorKind::Goto { .. } |\n                     TerminatorKind::Resume |\n@@ -440,7 +428,7 @@ macro_rules! make_mir_visitor {\n                         self.visit_local(\n                             & $($mutability)? local,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Move),\n-                            source_location,\n+                            location,\n                         );\n \n                         assert_eq!(\n@@ -456,34 +444,34 @@ macro_rules! make_mir_visitor {\n                         values: _,\n                         targets: _\n                     } => {\n-                        self.visit_operand(discr, source_location);\n-                        self.visit_ty(switch_ty, TyContext::Location(source_location));\n+                        self.visit_operand(discr, location);\n+                        self.visit_ty(switch_ty, TyContext::Location(location));\n                     }\n \n                     TerminatorKind::Drop {\n-                        location,\n+                        place,\n                         target: _,\n                         unwind: _,\n                     } => {\n                         self.visit_place(\n-                            location,\n+                            place,\n                             PlaceContext::MutatingUse(MutatingUseContext::Drop),\n-                            source_location\n+                            location\n                         );\n                     }\n \n                     TerminatorKind::DropAndReplace {\n-                        location,\n+                        place,\n                         value,\n                         target: _,\n                         unwind: _,\n                     } => {\n                         self.visit_place(\n-                            location,\n+                            place,\n                             PlaceContext::MutatingUse(MutatingUseContext::Drop),\n-                            source_location\n+                            location\n                         );\n-                        self.visit_operand(value, source_location);\n+                        self.visit_operand(value, location);\n                     }\n \n                     TerminatorKind::Call {\n@@ -494,15 +482,15 @@ macro_rules! make_mir_visitor {\n                         from_hir_call: _,\n                         fn_span: _\n                     } => {\n-                        self.visit_operand(func, source_location);\n+                        self.visit_operand(func, location);\n                         for arg in args {\n-                            self.visit_operand(arg, source_location);\n+                            self.visit_operand(arg, location);\n                         }\n                         if let Some((destination, _)) = destination {\n                             self.visit_place(\n                                 destination,\n                                 PlaceContext::MutatingUse(MutatingUseContext::Call),\n-                                source_location\n+                                location\n                             );\n                         }\n                     }\n@@ -514,8 +502,8 @@ macro_rules! make_mir_visitor {\n                         target: _,\n                         cleanup: _,\n                     } => {\n-                        self.visit_operand(cond, source_location);\n-                        self.visit_assert_message(msg, source_location);\n+                        self.visit_operand(cond, location);\n+                        self.visit_assert_message(msg, location);\n                     }\n \n                     TerminatorKind::Yield {\n@@ -524,11 +512,11 @@ macro_rules! make_mir_visitor {\n                         resume_arg,\n                         drop: _,\n                     } => {\n-                        self.visit_operand(value, source_location);\n+                        self.visit_operand(value, location);\n                         self.visit_place(\n                             resume_arg,\n                             PlaceContext::MutatingUse(MutatingUseContext::Yield),\n-                            source_location,\n+                            location,\n                         );\n                     }\n \n@@ -543,29 +531,29 @@ macro_rules! make_mir_visitor {\n                             match op {\n                                 InlineAsmOperand::In { value, .. }\n                                 | InlineAsmOperand::Const { value } => {\n-                                    self.visit_operand(value, source_location);\n+                                    self.visit_operand(value, location);\n                                 }\n                                 InlineAsmOperand::Out { place, .. } => {\n                                     if let Some(place) = place {\n                                         self.visit_place(\n                                             place,\n                                             PlaceContext::MutatingUse(MutatingUseContext::Store),\n-                                            source_location,\n+                                            location,\n                                         );\n                                     }\n                                 }\n                                 InlineAsmOperand::InOut { in_value, out_place, .. } => {\n-                                    self.visit_operand(in_value, source_location);\n+                                    self.visit_operand(in_value, location);\n                                     if let Some(out_place) = out_place {\n                                         self.visit_place(\n                                             out_place,\n                                             PlaceContext::MutatingUse(MutatingUseContext::Store),\n-                                            source_location,\n+                                            location,\n                                         );\n                                     }\n                                 }\n                                 InlineAsmOperand::SymFn { value } => {\n-                                    self.visit_constant(value, source_location);\n+                                    self.visit_constant(value, location);\n                                 }\n                                 InlineAsmOperand::SymStatic { def_id: _ } => {}\n                             }"}, {"sha": "69696ac9e93c062dbd36636b7394b39d149e3541", "filename": "src/librustc_middle/traits/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fquery.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -221,7 +221,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Ref(..)\n         | ty::Str\n         | ty::Foreign(..)\n-        | ty::Error => true,\n+        | ty::Error(_) => true,\n \n         // [T; N] and [T] have same properties as T.\n         ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),"}, {"sha": "db9229ae3d214b8a49b410908a22acac4e5df86a", "filename": "src/librustc_middle/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2F_match.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -79,7 +79,7 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n                 Err(TypeError::Sorts(relate::expected_found(self, &a, &b)))\n             }\n \n-            (&ty::Error, _) | (_, &ty::Error) => Ok(self.tcx().types.err),\n+            (&ty::Error(_), _) | (_, &ty::Error(_)) => Ok(self.tcx().ty_error()),\n \n             _ => relate::super_relate_tys(self, a, b),\n         }"}, {"sha": "62d6de2d71e6ddb10f6789b5a0923034bce2c795", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -46,7 +46,7 @@ use rustc_session::lint::{Level, Lint};\n use rustc_session::Session;\n use rustc_span::source_map::MultiSpan;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Layout, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n \n@@ -145,7 +145,6 @@ pub struct CommonTypes<'tcx> {\n     pub f64: Ty<'tcx>,\n     pub never: Ty<'tcx>,\n     pub self_param: Ty<'tcx>,\n-    pub err: Ty<'tcx>,\n \n     /// Dummy type used for the `Self` of a `TraitRef` created for converting\n     /// a trait object, and which gets removed in `ExistentialTraitRef`.\n@@ -803,7 +802,6 @@ impl<'tcx> CommonTypes<'tcx> {\n             bool: mk(Bool),\n             char: mk(Char),\n             never: mk(Never),\n-            err: mk(Error),\n             isize: mk(Int(ast::IntTy::Isize)),\n             i8: mk(Int(ast::IntTy::I8)),\n             i16: mk(Int(ast::IntTy::I16)),\n@@ -1142,6 +1140,31 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` to ensure it gets used.\n+    #[track_caller]\n+    pub fn ty_error(self) -> Ty<'tcx> {\n+        self.ty_error_with_message(DUMMY_SP, \"TyKind::Error constructed but no error reported\")\n+    }\n+\n+    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg to\n+    /// ensure it gets used.\n+    #[track_caller]\n+    pub fn ty_error_with_message<S: Into<MultiSpan>>(self, span: S, msg: &str) -> Ty<'tcx> {\n+        self.sess.delay_span_bug(span, msg);\n+        self.mk_ty(Error(super::sty::DelaySpanBugEmitted(())))\n+    }\n+\n+    /// Like `err` but for constants.\n+    #[track_caller]\n+    pub fn const_error(self, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n+        self.sess\n+            .delay_span_bug(DUMMY_SP, \"ty::ConstKind::Error constructed but no error reported.\");\n+        self.mk_const(ty::Const {\n+            val: ty::ConstKind::Error(super::sty::DelaySpanBugEmitted(())),\n+            ty,\n+        })\n+    }\n+\n     pub fn consider_optimizing<T: Fn() -> String>(&self, msg: T) -> bool {\n         let cname = self.crate_name(LOCAL_CRATE).as_str();\n         self.sess.consider_optimizing(&cname, msg)\n@@ -1382,7 +1405,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn return_type_impl_or_dyn_trait(&self, scope_def_id: DefId) -> Option<(Span, bool)> {\n+    pub fn return_type_impl_or_dyn_trait(\n+        &self,\n+        scope_def_id: DefId,\n+    ) -> Option<&'tcx hir::Ty<'tcx>> {\n         let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n         let hir_output = match self.hir().get(hir_id) {\n             Node::Item(hir::Item {\n@@ -1428,15 +1454,17 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let output = self.erase_late_bound_regions(&sig.output());\n                 if output.is_impl_trait() {\n                     let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n-                    Some((fn_decl.output.span(), false))\n+                    if let hir::FnRetTy::Return(ty) = fn_decl.output {\n+                        return Some(ty);\n+                    }\n                 } else {\n                     let mut v = TraitObjectVisitor(vec![]);\n                     rustc_hir::intravisit::walk_ty(&mut v, hir_output);\n                     if v.0.len() == 1 {\n-                        return Some((v.0[0], true));\n+                        return Some(v.0[0]);\n                     }\n-                    None\n                 }\n+                None\n             }\n             _ => None,\n         }\n@@ -1845,7 +1873,7 @@ macro_rules! sty_debug_print {\n                     let variant = match t.kind {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n-                        ty::Error => /* unimportant */ continue,\n+                        ty::Error(_) => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n                     let lt = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);"}, {"sha": "a2812e117ed39571f9e7e154bfdf27c4f1237143", "filename": "src/librustc_middle/ty/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -236,21 +236,24 @@ pub fn suggest_constraining_type_param(\n     }\n }\n \n-pub struct TraitObjectVisitor(pub Vec<rustc_span::Span>);\n-impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor {\n+pub struct TraitObjectVisitor<'tcx>(pub Vec<&'tcx hir::Ty<'tcx>>);\n+impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor<'v> {\n     type Map = rustc_hir::intravisit::ErasedMap<'v>;\n \n     fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n         hir::intravisit::NestedVisitorMap::None\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+    fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n         if let hir::TyKind::TraitObject(\n             _,\n-            hir::Lifetime { name: hir::LifetimeName::ImplicitObjectLifetimeDefault, .. },\n+            hir::Lifetime {\n+                name: hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Static,\n+                ..\n+            },\n         ) = ty.kind\n         {\n-            self.0.push(ty.span);\n+            self.0.push(ty);\n         }\n     }\n }"}, {"sha": "6113359ca93a72787597bd7ce95eb02757779d6c", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -286,14 +286,14 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Projection(_) => \"associated type\".into(),\n             ty::Param(p) => format!(\"type parameter `{}`\", p).into(),\n             ty::Opaque(..) => \"opaque type\".into(),\n-            ty::Error => \"type error\".into(),\n+            ty::Error(_) => \"type error\".into(),\n         }\n     }\n \n     pub fn prefix_string(&self) -> Cow<'static, str> {\n         match self.kind {\n             ty::Infer(_)\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Bool\n             | ty::Char\n             | ty::Int(_)"}, {"sha": "b0fb179b18bdfbaecc242c11802e45c46843b99f", "filename": "src/librustc_middle/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -104,7 +104,7 @@ pub fn simplify_type(\n         }\n         ty::Opaque(def_id, _) => Some(OpaqueSimplifiedType(def_id)),\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n-        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(_) | ty::Error => None,\n+        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,\n     }\n }\n "}, {"sha": "bee42be8a5388912e758d69499f9399a163b77ae", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -70,7 +70,7 @@ impl FlagComputation {\n             | &ty::Str\n             | &ty::Foreign(..) => {}\n \n-            &ty::Error => self.add_flags(TypeFlags::HAS_ERROR),\n+            &ty::Error(_) => self.add_flags(TypeFlags::HAS_ERROR),\n \n             &ty::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_TY_PARAM);\n@@ -227,7 +227,7 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n             ty::ConstKind::Value(_) => {}\n-            ty::ConstKind::Error => self.add_flags(TypeFlags::HAS_ERROR),\n+            ty::ConstKind::Error(_) => self.add_flags(TypeFlags::HAS_ERROR),\n         }\n     }\n "}, {"sha": "80f919d0c032916f608ed0323a3e70efa175b5f3", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -974,13 +974,13 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                             return Ok(tcx.intern_layout(Layout {\n                                 variants: Variants::Multiple {\n-                                    discr: niche_scalar,\n-                                    discr_kind: DiscriminantKind::Niche {\n+                                    tag: niche_scalar,\n+                                    tag_encoding: TagEncoding::Niche {\n                                         dataful_variant: i,\n                                         niche_variants,\n                                         niche_start,\n                                     },\n-                                    discr_index: 0,\n+                                    tag_field: 0,\n                                     variants: st,\n                                 },\n                                 fields: FieldsShape::Arbitrary {\n@@ -1216,9 +1216,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 tcx.intern_layout(Layout {\n                     variants: Variants::Multiple {\n-                        discr: tag,\n-                        discr_kind: DiscriminantKind::Tag,\n-                        discr_index: 0,\n+                        tag,\n+                        tag_encoding: TagEncoding::Direct,\n+                        tag_field: 0,\n                         variants: layout_variants,\n                     },\n                     fields: FieldsShape::Arbitrary {\n@@ -1245,7 +1245,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 bug!(\"Layout::compute: unexpected type `{}`\", ty)\n             }\n \n-            ty::Param(_) | ty::Error => {\n+            ty::Param(_) | ty::Error(_) => {\n                 return Err(LayoutError::Unknown(ty));\n             }\n         })\n@@ -1399,15 +1399,15 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // Build a prefix layout, including \"promoting\" all ineligible\n         // locals as part of the prefix. We compute the layout of all of\n         // these fields at once to get optimal packing.\n-        let discr_index = substs.as_generator().prefix_tys().count();\n+        let tag_index = substs.as_generator().prefix_tys().count();\n \n         // `info.variant_fields` already accounts for the reserved variants, so no need to add them.\n         let max_discr = (info.variant_fields.len() - 1) as u128;\n         let discr_int = Integer::fit_unsigned(max_discr);\n         let discr_int_ty = discr_int.to_ty(tcx, false);\n-        let discr = Scalar { value: Primitive::Int(discr_int, false), valid_range: 0..=max_discr };\n-        let discr_layout = self.tcx.intern_layout(Layout::scalar(self, discr.clone()));\n-        let discr_layout = TyAndLayout { ty: discr_int_ty, layout: discr_layout };\n+        let tag = Scalar { value: Primitive::Int(discr_int, false), valid_range: 0..=max_discr };\n+        let tag_layout = self.tcx.intern_layout(Layout::scalar(self, tag.clone()));\n+        let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout };\n \n         let promoted_layouts = ineligible_locals\n             .iter()\n@@ -1418,7 +1418,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             .as_generator()\n             .prefix_tys()\n             .map(|ty| self.layout_of(ty))\n-            .chain(iter::once(Ok(discr_layout)))\n+            .chain(iter::once(Ok(tag_layout)))\n             .chain(promoted_layouts)\n             .collect::<Result<Vec<_>, _>>()?;\n         let prefix = self.univariant_uninterned(\n@@ -1441,7 +1441,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 // \"a\" (`0..b_start`) and \"b\" (`b_start..`) correspond to\n                 // \"outer\" and \"promoted\" fields respectively.\n-                let b_start = (discr_index + 1) as u32;\n+                let b_start = (tag_index + 1) as u32;\n                 let offsets_b = offsets.split_off(b_start as usize);\n                 let offsets_a = offsets;\n \n@@ -1558,9 +1558,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         let layout = tcx.intern_layout(Layout {\n             variants: Variants::Multiple {\n-                discr,\n-                discr_kind: DiscriminantKind::Tag,\n-                discr_index,\n+                tag: tag,\n+                tag_encoding: TagEncoding::Direct,\n+                tag_field: tag_index,\n                 variants,\n             },\n             fields: outer_fields,\n@@ -1680,7 +1680,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }\n             }\n \n-            Variants::Multiple { ref discr, ref discr_kind, .. } => {\n+            Variants::Multiple { ref tag, ref tag_encoding, .. } => {\n                 debug!(\n                     \"print-type-size `{:#?}` adt general variants def {}\",\n                     layout.ty,\n@@ -1702,8 +1702,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 record(\n                     adt_kind.into(),\n                     adt_packed,\n-                    match discr_kind {\n-                        DiscriminantKind::Tag => Some(discr.value.size(self)),\n+                    match tag_encoding {\n+                        TagEncoding::Direct => Some(tag.value.size(self)),\n                         _ => None,\n                     },\n                     variant_infos,\n@@ -2028,11 +2028,11 @@ where\n \n     fn field(this: TyAndLayout<'tcx>, cx: &C, i: usize) -> C::TyAndLayout {\n         let tcx = cx.tcx();\n-        let discr_layout = |discr: &Scalar| -> C::TyAndLayout {\n-            let layout = Layout::scalar(cx, discr.clone());\n+        let tag_layout = |tag: &Scalar| -> C::TyAndLayout {\n+            let layout = Layout::scalar(cx, tag.clone());\n             MaybeResult::from(Ok(TyAndLayout {\n                 layout: tcx.intern_layout(layout),\n-                ty: discr.value.to_ty(tcx),\n+                ty: tag.value.to_ty(tcx),\n             }))\n         };\n \n@@ -2109,9 +2109,9 @@ where\n                     .unwrap()\n                     .nth(i)\n                     .unwrap(),\n-                Variants::Multiple { ref discr, discr_index, .. } => {\n-                    if i == discr_index {\n-                        return discr_layout(discr);\n+                Variants::Multiple { ref tag, tag_field, .. } => {\n+                    if i == tag_field {\n+                        return tag_layout(tag);\n                     }\n                     substs.as_generator().prefix_tys().nth(i).unwrap()\n                 }\n@@ -2128,9 +2128,9 @@ where\n                     Variants::Single { index } => def.variants[index].fields[i].ty(tcx, substs),\n \n                     // Discriminant field for enums (where applicable).\n-                    Variants::Multiple { ref discr, .. } => {\n+                    Variants::Multiple { ref tag, .. } => {\n                         assert_eq!(i, 0);\n-                        return discr_layout(discr);\n+                        return tag_layout(tag);\n                     }\n                 }\n             }\n@@ -2141,7 +2141,7 @@ where\n             | ty::Opaque(..)\n             | ty::Param(_)\n             | ty::Infer(_)\n-            | ty::Error => bug!(\"TyAndLayout::field_type: unexpected type `{}`\", this.ty),\n+            | ty::Error(_) => bug!(\"TyAndLayout::field_type: unexpected type `{}`\", this.ty),\n         })\n     }\n \n@@ -2207,10 +2207,10 @@ where\n                     // using more niches than just null (e.g., the first page of\n                     // the address space, or unaligned pointers).\n                     Variants::Multiple {\n-                        discr_kind: DiscriminantKind::Niche { dataful_variant, .. },\n-                        discr_index,\n+                        tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n+                        tag_field,\n                         ..\n-                    } if this.fields.offset(discr_index) == offset => {\n+                    } if this.fields.offset(tag_field) == offset => {\n                         Some(this.for_variant(cx, dataful_variant))\n                     }\n                     _ => Some(this),"}, {"sha": "1a8693b8df711fa0f7e69513604607813260b4ea", "filename": "src/librustc_middle/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Foutlives.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -171,7 +171,7 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n             ty::Dynamic(..) |     // OutlivesObject, OutlivesFragment (*)\n             ty::Placeholder(..) |\n             ty::Bound(..) |\n-            ty::Error => {\n+            ty::Error(_) => {\n                 // (*) Function pointers and trait objects are both binders.\n                 // In the RFC, this means we would add the bound regions to\n                 // the \"bound regions list\".  In our representation, no such"}, {"sha": "6c8f23c139f6ecf6b6ca579d06c41dceb86c18dc", "filename": "src/librustc_middle/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -298,7 +298,7 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n         | ty::Opaque(..)\n         | ty::Infer(_)\n         | ty::Bound(..)\n-        | ty::Error\n+        | ty::Error(_)\n         | ty::GeneratorWitness(..)\n         | ty::Never\n         | ty::Float(_) => None,"}, {"sha": "67b6433b6114327e31737dd164bc38d72d1253a5", "filename": "src/librustc_middle/ty/print/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -144,7 +144,7 @@ impl DefPathBasedNames<'tcx> {\n                 let substs = substs.truncate_to(self.tcx, generics);\n                 self.push_generic_params(substs, iter::empty(), output, debug);\n             }\n-            ty::Error\n+            ty::Error(_)\n             | ty::Bound(..)\n             | ty::Infer(_)\n             | ty::Placeholder(..)"}, {"sha": "17203fcce5e59e7583e6e3f329bdb55035b6e8e2", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -518,7 +518,7 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(write(\"{}\", infer_ty))\n                 }\n             }\n-            ty::Error => p!(write(\"[type error]\")),\n+            ty::Error(_) => p!(write(\"[type error]\")),\n             ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n             ty::Bound(debruijn, bound_ty) => match bound_ty.kind {\n                 ty::BoundTyKind::Anon => self.pretty_print_bound_var(debruijn, bound_ty.var)?,\n@@ -919,7 +919,7 @@ pub trait PrettyPrinter<'tcx>:\n                 self.pretty_print_bound_var(debruijn, bound_var)?\n             }\n             ty::ConstKind::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n-            ty::ConstKind::Error => p!(write(\"[const error]\")),\n+            ty::ConstKind::Error(_) => p!(write(\"[const error]\")),\n         };\n         Ok(self)\n     }"}, {"sha": "0a0ff101b52032fcf2066e08b35800b1c600aaf8", "filename": "src/librustc_middle/ty/query/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fvalues.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -17,7 +17,7 @@ impl<'tcx> Value<'tcx> for &'_ TyS<'_> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n         // SAFETY: This is never called when `Self` is not `Ty<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n-        unsafe { std::mem::transmute::<Ty<'tcx>, Ty<'_>>(tcx.types.err) }\n+        unsafe { std::mem::transmute::<Ty<'tcx>, Ty<'_>>(tcx.ty_error()) }\n     }\n }\n \n@@ -33,7 +33,7 @@ impl<'tcx> Value<'tcx> for AdtSizedConstraint<'_> {\n         // FIXME: Represent the above fact in the trait system somehow.\n         unsafe {\n             std::mem::transmute::<AdtSizedConstraint<'tcx>, AdtSizedConstraint<'_>>(\n-                AdtSizedConstraint(tcx.intern_type_list(&[tcx.types.err])),\n+                AdtSizedConstraint(tcx.intern_type_list(&[tcx.ty_error()])),\n             )\n         }\n     }"}, {"sha": "14cddd11c438d813d7ca81dda150f71ef5fc5e0a", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -354,7 +354,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n             bug!(\"bound types encountered in super_relate_tys\")\n         }\n \n-        (&ty::Error, _) | (_, &ty::Error) => Ok(tcx.types.err),\n+        (&ty::Error(_), _) | (_, &ty::Error(_)) => Ok(tcx.ty_error()),\n \n         (&ty::Never, _)\n         | (&ty::Char, _)\n@@ -524,7 +524,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n             bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n         }\n \n-        (ty::ConstKind::Error, _) | (_, ty::ConstKind::Error) => Ok(ty::ConstKind::Error),\n+        (ty::ConstKind::Error(d), _) | (_, ty::ConstKind::Error(d)) => Ok(ty::ConstKind::Error(d)),\n \n         (ty::ConstKind::Param(a_p), ty::ConstKind::Param(b_p)) if a_p.index == b_p.index => {\n             return Ok(a);"}, {"sha": "f04d31601ea5b5a8e0310d77ccdb1590a282dfed", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -911,7 +911,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             | ty::Int(_)\n             | ty::Uint(_)\n             | ty::Float(_)\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Infer(_)\n             | ty::Param(..)\n             | ty::Bound(..)\n@@ -952,7 +952,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             | ty::Int(_)\n             | ty::Uint(_)\n             | ty::Float(_)\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Infer(_)\n             | ty::Bound(..)\n             | ty::Placeholder(..)\n@@ -1051,7 +1051,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n             ty::ConstKind::Value(_)\n             | ty::ConstKind::Bound(..)\n             | ty::ConstKind::Placeholder(..)\n-            | ty::ConstKind::Error => *self,\n+            | ty::ConstKind::Error(_) => *self,\n         }\n     }\n \n@@ -1063,7 +1063,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n             ty::ConstKind::Value(_)\n             | ty::ConstKind::Bound(..)\n             | ty::ConstKind::Placeholder(_)\n-            | ty::ConstKind::Error => false,\n+            | ty::ConstKind::Error(_) => false,\n         }\n     }\n }"}, {"sha": "cf11adb0285ac3ad38837dd373426e4f5b4a8127", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -203,9 +203,15 @@ pub enum TyKind<'tcx> {\n \n     /// A placeholder for a type which could not be computed; this is\n     /// propagated to avoid useless error messages.\n-    Error,\n+    Error(DelaySpanBugEmitted),\n }\n \n+/// A type that is not publicly constructable. This prevents people from making `TyKind::Error`\n+/// except through `tcx.err*()`.\n+#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+pub struct DelaySpanBugEmitted(pub(super) ());\n+\n // `TyKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(TyKind<'_>, 24);\n@@ -1984,7 +1990,7 @@ impl<'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn has_concrete_skeleton(&self) -> bool {\n         match self.kind {\n-            Param(_) | Infer(_) | Error => false,\n+            Param(_) | Infer(_) | Error(_) => false,\n             _ => true,\n         }\n     }\n@@ -2016,7 +2022,7 @@ impl<'tcx> TyS<'tcx> {\n         match self.kind {\n             FnDef(def_id, substs) => tcx.fn_sig(def_id).subst(tcx, substs),\n             FnPtr(f) => f,\n-            Error => {\n+            Error(_) => {\n                 // ignore errors (#54954)\n                 ty::Binder::dummy(FnSig::fake())\n             }\n@@ -2140,7 +2146,7 @@ impl<'tcx> TyS<'tcx> {\n             // closure type is not yet known\n             Bound(..) | Infer(_) => None,\n \n-            Error => Some(ty::ClosureKind::Fn),\n+            Error(_) => Some(ty::ClosureKind::Fn),\n \n             _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n         }\n@@ -2167,7 +2173,7 @@ impl<'tcx> TyS<'tcx> {\n             | ty::Array(..)\n             | ty::Closure(..)\n             | ty::Never\n-            | ty::Error => true,\n+            | ty::Error(_) => true,\n \n             ty::Str | ty::Slice(_) | ty::Dynamic(..) | ty::Foreign(..) => false,\n \n@@ -2372,9 +2378,7 @@ impl<'tcx> Const<'tcx> {\n                 // can leak through `val` into the const we return.\n                 Ok(val) => Const::from_value(tcx, val, self.ty),\n                 Err(ErrorHandled::TooGeneric | ErrorHandled::Linted) => self,\n-                Err(ErrorHandled::Reported(ErrorReported)) => {\n-                    tcx.mk_const(ty::Const { val: ty::ConstKind::Error, ty: self.ty })\n-                }\n+                Err(ErrorHandled::Reported(ErrorReported)) => tcx.const_error(self.ty),\n             }\n         } else {\n             self\n@@ -2434,7 +2438,7 @@ pub enum ConstKind<'tcx> {\n \n     /// A placeholder for a const which could not be computed; this is\n     /// propagated to avoid useless error messages.\n-    Error,\n+    Error(DelaySpanBugEmitted),\n }\n \n #[cfg(target_arch = \"x86_64\")]"}, {"sha": "47110be53b2521ad09b296e7ecf5793122054996", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -176,7 +176,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let ty::Adt(def, substs) = ty.kind {\n             for field in def.all_fields() {\n                 let field_ty = field.ty(self, substs);\n-                if let Error = field_ty.kind {\n+                if let Error(_) = field_ty.kind {\n                     return true;\n                 }\n             }\n@@ -731,7 +731,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             | ty::Ref(..)\n             | ty::RawPtr(_)\n             | ty::FnDef(..)\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::FnPtr(_) => true,\n             ty::Tuple(_) => self.tuple_fields().all(Self::is_trivially_freeze),\n             ty::Slice(elem_ty) | ty::Array(elem_ty, _) => elem_ty.is_trivially_freeze(),\n@@ -826,7 +826,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             // called for known, fully-monomorphized types.\n             Projection(_) | Opaque(..) | Param(_) | Bound(..) | Placeholder(_) | Infer(_) => false,\n \n-            Foreign(_) | GeneratorWitness(..) | Error => false,\n+            Foreign(_) | GeneratorWitness(..) | Error(_) => false,\n         }\n     }\n \n@@ -1109,7 +1109,7 @@ pub fn needs_drop_components(\n         // Foreign types can never have destructors.\n         ty::Foreign(..) => Ok(SmallVec::new()),\n \n-        ty::Dynamic(..) | ty::Error => Err(AlwaysRequiresDrop),\n+        ty::Dynamic(..) | ty::Error(_) => Err(AlwaysRequiresDrop),\n \n         ty::Slice(ty) => needs_drop_components(ty, target_layout),\n         ty::Array(elem_ty, size) => {"}, {"sha": "d6f504fdb338bff1e68880aa7d2e48b2b2569eab", "filename": "src/librustc_middle/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fwalk.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -108,7 +108,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n             | ty::Infer(_)\n             | ty::Param(_)\n             | ty::Never\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Placeholder(..)\n             | ty::Bound(..)\n             | ty::Foreign(..) => {}\n@@ -171,7 +171,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 | ty::ConstKind::Placeholder(_)\n                 | ty::ConstKind::Bound(..)\n                 | ty::ConstKind::Value(_)\n-                | ty::ConstKind::Error => {}\n+                | ty::ConstKind::Error(_) => {}\n \n                 ty::ConstKind::Unevaluated(_, substs, _) => {\n                     stack.extend(substs.iter().rev());"}, {"sha": "fd8f17718e795b48f5bacc0e569eb8e8932bf9e2", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{BasicBlock, Body, Location, Place, Rvalue};\n use rustc_middle::mir::{BorrowKind, Mutability, Operand};\n-use rustc_middle::mir::{InlineAsmOperand, TerminatorKind};\n+use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::mir::{Statement, StatementKind};\n use rustc_middle::ty::TyCtxt;\n \n@@ -112,14 +112,14 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n         self.super_statement(statement, location);\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &TerminatorKind<'tcx>, location: Location) {\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         self.check_activations(location);\n \n-        match kind {\n+        match &terminator.kind {\n             TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n-            TerminatorKind::Drop { location: drop_place, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { place: drop_place, target: _, unwind: _ } => {\n                 self.access_place(\n                     location,\n                     *drop_place,\n@@ -128,7 +128,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 );\n             }\n             TerminatorKind::DropAndReplace {\n-                location: drop_place,\n+                place: drop_place,\n                 value: ref new_value,\n                 target: _,\n                 unwind: _,\n@@ -222,7 +222,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n         }\n \n-        self.super_terminator_kind(kind, location);\n+        self.super_terminator(terminator, location);\n     }\n }\n "}, {"sha": "83691d439eb81c983dc1af5da94f01eb310ce4c2", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -663,7 +663,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n             TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n                 self.consume_operand(loc, (discr, span), flow_state);\n             }\n-            TerminatorKind::Drop { location: ref drop_place, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { place: ref drop_place, target: _, unwind: _ } => {\n                 let tcx = self.infcx.tcx;\n \n                 // Compute the type with accurate region information.\n@@ -692,7 +692,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 );\n             }\n             TerminatorKind::DropAndReplace {\n-                location: drop_place,\n+                place: drop_place,\n                 value: ref new_value,\n                 target: _,\n                 unwind: _,"}, {"sha": "beee31812563ed4d536ea5abd4b58fb81222a767", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -264,7 +264,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                             .tcx\n                             .sess\n                             .delay_span_bug(DUMMY_SP, &format!(\"failed to normalize {:?}\", ty));\n-                        (self.infcx.tcx.types.err, None)\n+                        (self.infcx.tcx.ty_error(), None)\n                     });\n                 let constraints2 = self.add_implied_bounds(ty);\n                 normalized_inputs_and_output.push(ty);"}, {"sha": "0e35cafb9f3e928a7a29dd39a2c76161a24345cc", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             if place_ty.variant_index.is_none() {\n                 if place_ty.ty.references_error() {\n                     assert!(self.errors_reported);\n-                    return PlaceTy::from_ty(self.tcx().types.err);\n+                    return PlaceTy::from_ty(self.tcx().ty_error());\n                 }\n             }\n             place_ty = self.sanitize_projection(place_ty, elem, place, location)\n@@ -725,7 +725,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n     fn error(&mut self) -> Ty<'tcx> {\n         self.errors_reported = true;\n-        self.tcx().types.err\n+        self.tcx().ty_error()\n     }\n \n     fn field_ty(\n@@ -1558,8 +1558,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // no checks needed for these\n             }\n \n-            TerminatorKind::DropAndReplace { ref location, ref value, target: _, unwind: _ } => {\n-                let place_ty = location.ty(body, tcx).ty;\n+            TerminatorKind::DropAndReplace { ref place, ref value, target: _, unwind: _ } => {\n+                let place_ty = place.ty(body, tcx).ty;\n                 let rv_ty = value.ty(body, tcx);\n \n                 let locations = term_location.to_locations();"}, {"sha": "e027056842db97d20cf69c0109df7def59377a78", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,5 +1,7 @@\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n-use rustc_middle::mir::{Local, Location, Place, Statement, StatementKind, TerminatorKind};\n+use rustc_middle::mir::{\n+    Local, Location, Place, Statement, StatementKind, Terminator, TerminatorKind,\n+};\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -62,20 +64,22 @@ impl GatherUsedMutsVisitor<'_, '_, '_> {\n }\n \n impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tcx> {\n-    fn visit_terminator_kind(&mut self, kind: &TerminatorKind<'tcx>, _location: Location) {\n-        debug!(\"visit_terminator_kind: kind={:?}\", kind);\n-        match &kind {\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        debug!(\"visit_terminator: terminator={:?}\", terminator);\n+        match &terminator.kind {\n             TerminatorKind::Call { destination: Some((into, _)), .. } => {\n                 self.remove_never_initialized_mut_locals(*into);\n             }\n-            TerminatorKind::DropAndReplace { location, .. } => {\n-                self.remove_never_initialized_mut_locals(*location);\n+            TerminatorKind::DropAndReplace { place, .. } => {\n+                self.remove_never_initialized_mut_locals(*place);\n             }\n             _ => {}\n         }\n+\n+        self.super_terminator(terminator, location);\n     }\n \n-    fn visit_statement(&mut self, statement: &Statement<'tcx>, _location: Location) {\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         if let StatementKind::Assign(box (into, _)) = &statement.kind {\n             debug!(\n                 \"visit_statement: statement={:?} local={:?} \\\n@@ -84,6 +88,8 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n             );\n             self.remove_never_initialized_mut_locals(*into);\n         }\n+\n+        self.super_statement(statement, location);\n     }\n \n     fn visit_local(&mut self, local: &Local, place_context: PlaceContext, location: Location) {"}, {"sha": "4512ae96c0833f24d7af72180987e40b10d58fe0", "filename": "src/librustc_mir/dataflow/framework/direction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -441,8 +441,8 @@ impl Direction for Forward {\n             Goto { target } => propagate(target, exit_state),\n \n             Assert { target, cleanup: unwind, expected: _, msg: _, cond: _ }\n-            | Drop { target, unwind, location: _ }\n-            | DropAndReplace { target, unwind, value: _, location: _ }\n+            | Drop { target, unwind, place: _ }\n+            | DropAndReplace { target, unwind, value: _, place: _ }\n             | FalseUnwind { real_target: target, unwind } => {\n                 if let Some(unwind) = unwind {\n                     if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {"}, {"sha": "70c916a089270dd108cbddfb72dfad01e478a591", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -189,8 +189,8 @@ where\n         self.super_terminator(terminator, location);\n \n         match terminator.kind {\n-            mir::TerminatorKind::Drop { location: dropped_place, .. }\n-            | mir::TerminatorKind::DropAndReplace { location: dropped_place, .. } => {\n+            mir::TerminatorKind::Drop { place: dropped_place, .. }\n+            | mir::TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n                 // See documentation for `unsound_ignore_borrow_on_drop` for an explanation.\n                 if !self.ignore_borrow_on_drop {\n                     self.trans.gen(dropped_place.local);"}, {"sha": "7c8aa1db71ff873f56ff15d916a1ff14e138b87b", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -387,13 +387,13 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 self.gather_init(place.as_ref(), InitKind::Deep);\n             }\n \n-            TerminatorKind::Drop { location, target: _, unwind: _ } => {\n-                self.gather_move(location);\n+            TerminatorKind::Drop { place, target: _, unwind: _ } => {\n+                self.gather_move(place);\n             }\n-            TerminatorKind::DropAndReplace { location, ref value, .. } => {\n-                self.create_move_path(location);\n+            TerminatorKind::DropAndReplace { place, ref value, .. } => {\n+                self.create_move_path(place);\n                 self.gather_operand(value);\n-                self.gather_init(location.as_ref(), InitKind::Deep);\n+                self.gather_init(place.as_ref(), InitKind::Deep);\n             }\n             TerminatorKind::Call {\n                 ref func,"}, {"sha": "cab13d379a2ccead0845ab7735d5ae4aaedf30e9", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -293,7 +293,6 @@ pub enum InternKind {\n     Static(hir::Mutability),\n     Constant,\n     Promoted,\n-    ConstProp,\n }\n \n /// Intern `ret` and everything it references.\n@@ -314,9 +313,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     let base_intern_mode = match intern_kind {\n         InternKind::Static(mutbl) => InternMode::Static(mutbl),\n         // FIXME: what about array lengths, array initializers?\n-        InternKind::Constant | InternKind::ConstProp | InternKind::Promoted => {\n-            InternMode::ConstBase\n-        }\n+        InternKind::Constant | InternKind::Promoted => InternMode::ConstBase,\n     };\n \n     // Type based interning.\n@@ -358,7 +355,10 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             Err(error) => {\n                 ecx.tcx.sess.delay_span_bug(\n                     ecx.tcx.span,\n-                    \"error during interning should later cause validation failure\",\n+                    &format!(\n+                        \"error during interning should later cause validation failure: {}\",\n+                        error\n+                    ),\n                 );\n                 // Some errors shouldn't come up because creating them causes\n                 // an allocation, which we should avoid. When that happens,\n@@ -399,7 +399,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n                     // immutability is so important.\n                     alloc.mutability = Mutability::Not;\n                 }\n-                InternKind::Constant | InternKind::ConstProp => {\n+                InternKind::Constant => {\n                     // If it's a constant, we should not have any \"leftovers\" as everything\n                     // is tracked by const-checking.\n                     // FIXME: downgrade this to a warning? It rejects some legitimate consts,"}, {"sha": "ac28ccd181520f7092cb546e3fb83b014ef5f39e", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -389,6 +389,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 );\n                 self.copy_op(self.operand_index(args[0], index)?, dest)?;\n             }\n+            // FIXME(#73156): Handle source code coverage in const eval\n+            sym::count_code_region => (),\n             _ => return Ok(false),\n         }\n "}, {"sha": "379117f3b846a26135307518fd57b5e90267f7f8", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             | ty::Dynamic(_, _) => self.pretty_print_type(ty),\n \n             // Placeholders (all printed as `_` to uniformize them).\n-            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error => {\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error(_) => {\n                 write!(self, \"_\")?;\n                 Ok(self)\n             }"}, {"sha": "35e433c4bd5cd28a3b20844619fce6db1f27297e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::layout::{PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n use rustc_middle::ty::Ty;\n use rustc_middle::{mir, ty};\n-use rustc_target::abi::{Abi, DiscriminantKind, HasDataLayout, LayoutOf, Size};\n+use rustc_target::abi::{Abi, HasDataLayout, LayoutOf, Size, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n@@ -527,7 +527,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Early-return cases.\n         let val_val = match val.val {\n             ty::ConstKind::Param(_) => throw_inval!(TooGeneric),\n-            ty::ConstKind::Error => throw_inval!(TypeckError(ErrorReported)),\n+            ty::ConstKind::Error(_) => throw_inval!(TypeckError(ErrorReported)),\n             ty::ConstKind::Unevaluated(def_id, substs, promoted) => {\n                 let instance = self.resolve(def_id, substs)?;\n                 // We use `const_eval` here and `const_eval_raw` elsewhere in mir interpretation.\n@@ -587,7 +587,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         op: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", op.layout);\n-\n         // Get type and layout of the discriminant.\n         let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n         trace!(\"discriminant type: {:?}\", discr_layout.ty);\n@@ -596,10 +595,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // This is not to be confused with its \"variant index\", which is just determining its position in the\n         // declared list of variants -- they can differ with explicitly assigned discriminants.\n         // We use \"tag\" to refer to how the discriminant is encoded in memory, which can be either\n-        // straight-forward (`DiscriminantKind::Tag`) or with a niche (`DiscriminantKind::Niche`).\n-        // Unfortunately, the rest of the compiler calls the latter \"discriminant\", too, which makes things\n-        // rather confusing.\n-        let (tag_scalar_layout, tag_kind, tag_index) = match op.layout.variants {\n+        // straight-forward (`TagEncoding::Direct`) or with a niche (`TagEncoding::Niche`).\n+        let (tag_scalar_layout, tag_encoding, tag_field) = match op.layout.variants {\n             Variants::Single { index } => {\n                 let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     Some(discr) => {\n@@ -615,8 +612,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 return Ok((discr, index));\n             }\n-            Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n-                (discr, discr_kind, discr_index)\n+            Variants::Multiple { ref tag, ref tag_encoding, tag_field, .. } => {\n+                (tag, tag_encoding, tag_field)\n             }\n         };\n \n@@ -633,21 +630,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(*self.tcx))?;\n \n         // Read tag and sanity-check `tag_layout`.\n-        let tag_val = self.read_immediate(self.operand_field(op, tag_index)?)?;\n+        let tag_val = self.read_immediate(self.operand_field(op, tag_field)?)?;\n         assert_eq!(tag_layout.size, tag_val.layout.size);\n         assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n         let tag_val = tag_val.to_scalar()?;\n         trace!(\"tag value: {:?}\", tag_val);\n \n         // Figure out which discriminant and variant this corresponds to.\n-        Ok(match *tag_kind {\n-            DiscriminantKind::Tag => {\n+        Ok(match *tag_encoding {\n+            TagEncoding::Direct => {\n                 let tag_bits = self\n                     .force_bits(tag_val, tag_layout.size)\n-                    .map_err(|_| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n+                    .map_err(|_| err_ub!(InvalidTag(tag_val.erase_tag())))?;\n                 // Cast bits from tag layout to discriminant layout.\n-                let discr_val_cast = self.cast_from_scalar(tag_bits, tag_layout, discr_layout.ty);\n-                let discr_bits = discr_val_cast.assert_bits(discr_layout.size);\n+                let discr_val = self.cast_from_scalar(tag_bits, tag_layout, discr_layout.ty);\n+                let discr_bits = discr_val.assert_bits(discr_layout.size);\n                 // Convert discriminant to variant index, and catch invalid discriminants.\n                 let index = match op.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n@@ -661,11 +658,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),\n                 }\n-                .ok_or_else(|| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n+                .ok_or_else(|| err_ub!(InvalidTag(tag_val.erase_tag())))?;\n                 // Return the cast value, and the index.\n-                (discr_val_cast, index.0)\n+                (discr_val, index.0)\n             }\n-            DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+            TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n                 // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n                 // discriminant (encoded in niche/tag) and variant index are the same.\n                 let variants_start = niche_variants.start().as_u32();\n@@ -677,7 +674,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             && variants_start == variants_end\n                             && !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            throw_ub!(InvalidDiscriminant(tag_val.erase_tag()))\n+                            throw_ub!(InvalidTag(tag_val.erase_tag()))\n                         }\n                         dataful_variant\n                     }"}, {"sha": "396aec0a8f89f79a49d549ab07c0f5ac525c0519", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -9,7 +9,7 @@ use rustc_macros::HashStable;\n use rustc_middle::mir;\n use rustc_middle::ty::layout::{PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::{self, Ty};\n-use rustc_target::abi::{Abi, Align, DiscriminantKind, FieldsShape};\n+use rustc_target::abi::{Abi, Align, FieldsShape, TagEncoding};\n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, VariantIdx, Variants};\n \n use super::{\n@@ -1045,7 +1045,8 @@ where\n         MPlaceTy { mplace, layout }\n     }\n \n-    pub fn write_discriminant_index(\n+    /// Writes the discriminant of the given variant.\n+    pub fn write_discriminant(\n         &mut self,\n         variant_index: VariantIdx,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n@@ -1061,9 +1062,9 @@ where\n                 assert_eq!(index, variant_index);\n             }\n             Variants::Multiple {\n-                discr_kind: DiscriminantKind::Tag,\n-                discr: ref discr_layout,\n-                discr_index,\n+                tag_encoding: TagEncoding::Direct,\n+                tag: ref tag_layout,\n+                tag_field,\n                 ..\n             } => {\n                 // No need to validate that the discriminant here because the\n@@ -1075,17 +1076,17 @@ where\n                 // raw discriminants for enums are isize or bigger during\n                 // their computation, but the in-memory tag is the smallest possible\n                 // representation\n-                let size = discr_layout.value.size(self);\n-                let discr_val = truncate(discr_val, size);\n+                let size = tag_layout.value.size(self);\n+                let tag_val = truncate(discr_val, size);\n \n-                let discr_dest = self.place_field(dest, discr_index)?;\n-                self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;\n+                let tag_dest = self.place_field(dest, tag_field)?;\n+                self.write_scalar(Scalar::from_uint(tag_val, size), tag_dest)?;\n             }\n             Variants::Multiple {\n-                discr_kind:\n-                    DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start },\n-                discr: ref discr_layout,\n-                discr_index,\n+                tag_encoding:\n+                    TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n+                tag: ref tag_layout,\n+                tag_field,\n                 ..\n             } => {\n                 // No need to validate that the discriminant here because the\n@@ -1098,19 +1099,19 @@ where\n                         .checked_sub(variants_start)\n                         .expect(\"overflow computing relative variant idx\");\n                     // We need to use machine arithmetic when taking into account `niche_start`:\n-                    // discr_val = variant_index_relative + niche_start_val\n-                    let discr_layout = self.layout_of(discr_layout.value.to_int_ty(*self.tcx))?;\n-                    let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n+                    // tag_val = variant_index_relative + niche_start_val\n+                    let tag_layout = self.layout_of(tag_layout.value.to_int_ty(*self.tcx))?;\n+                    let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n                     let variant_index_relative_val =\n-                        ImmTy::from_uint(variant_index_relative, discr_layout);\n-                    let discr_val = self.binary_op(\n+                        ImmTy::from_uint(variant_index_relative, tag_layout);\n+                    let tag_val = self.binary_op(\n                         mir::BinOp::Add,\n                         variant_index_relative_val,\n                         niche_start_val,\n                     )?;\n                     // Write result.\n-                    let niche_dest = self.place_field(dest, discr_index)?;\n-                    self.write_immediate(*discr_val, niche_dest)?;\n+                    let niche_dest = self.place_field(dest, tag_field)?;\n+                    self.write_immediate(*tag_val, niche_dest)?;\n                 }\n             }\n         }"}, {"sha": "18f9bbd2e315086bdb978d3eb11da7811a47e537", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -88,7 +88,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             SetDiscriminant { place, variant_index } => {\n                 let dest = self.eval_place(**place)?;\n-                self.write_discriminant_index(*variant_index, dest)?;\n+                self.write_discriminant(*variant_index, dest)?;\n             }\n \n             // Mark locals as alive\n@@ -179,7 +179,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n-                        self.write_discriminant_index(variant_index, dest)?;\n+                        self.write_discriminant(variant_index, dest)?;\n                         if adt_def.is_enum() {\n                             (self.place_downcast(dest, variant_index)?, active_field_index)\n                         } else {"}, {"sha": "1d57fce39734e9119c93f8cf8a21030a00fca6d7", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -91,10 +91,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n-            Drop { location, target, unwind } => {\n-                let place = self.eval_place(location)?;\n+            Drop { place, target, unwind } => {\n+                let place = self.eval_place(place)?;\n                 let ty = place.layout.ty;\n-                trace!(\"TerminatorKind::drop: {:?}, type {}\", location, ty);\n+                trace!(\"TerminatorKind::drop: {:?}, type {}\", place, ty);\n \n                 let instance = Instance::resolve_drop_in_place(*self.tcx, ty);\n                 self.drop_in_place(place, instance, target, unwind)?;"}, {"sha": "3bb9ba37120582fda0f770298e2daa4ba3c84c98", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -208,8 +208,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     fn aggregate_field_path_elem(&mut self, layout: TyAndLayout<'tcx>, field: usize) -> PathElem {\n         // First, check if we are projecting to a variant.\n         match layout.variants {\n-            Variants::Multiple { discr_index, .. } => {\n-                if discr_index == field {\n+            Variants::Multiple { tag_field, .. } => {\n+                if tag_field == field {\n                     return match layout.ty.kind {\n                         ty::Adt(def, ..) if def.is_enum() => PathElem::EnumTag,\n                         ty::Generator(..) => PathElem::GeneratorTag,\n@@ -561,7 +561,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             | ty::Generator(..) => Ok(false),\n             // Some types only occur during typechecking, they have no layout.\n             // We should not see them here and we could not check them anyway.\n-            ty::Error\n+            ty::Error(_)\n             | ty::Infer(..)\n             | ty::Placeholder(..)\n             | ty::Bound(..)\n@@ -697,8 +697,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         try_validation!(\n             self.walk_value(op),\n             self.path,\n-            err_ub!(InvalidDiscriminant(val)) =>\n-                { \"{}\", val } expected { \"a valid enum discriminant\" },\n+            err_ub!(InvalidTag(val)) =>\n+                { \"{}\", val } expected { \"a valid enum tag\" },\n             err_unsup!(ReadPointerAsBytes) =>\n                 { \"a pointer\" } expected { \"plain (non-pointer) bytes\" },\n         );"}, {"sha": "36f3947d8301711dabb4f7b99223193c9e474735", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -624,19 +624,19 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_const(constant);\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &mir::TerminatorKind<'tcx>, location: Location) {\n-        debug!(\"visiting terminator {:?} @ {:?}\", kind, location);\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n+        debug!(\"visiting terminator {:?} @ {:?}\", terminator, location);\n \n         let tcx = self.tcx;\n-        match *kind {\n+        match terminator.kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.body, tcx);\n                 let callee_ty = self.monomorphize(callee_ty);\n                 visit_fn_use(self.tcx, callee_ty, true, &mut self.output);\n             }\n-            mir::TerminatorKind::Drop { ref location, .. }\n-            | mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                let ty = location.ty(self.body, self.tcx).ty;\n+            mir::TerminatorKind::Drop { ref place, .. }\n+            | mir::TerminatorKind::DropAndReplace { ref place, .. } => {\n+                let ty = place.ty(self.body, self.tcx).ty;\n                 let ty = self.monomorphize(ty);\n                 visit_drop_use(self.tcx, ty, true, self.output);\n             }\n@@ -671,7 +671,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             | mir::TerminatorKind::FalseUnwind { .. } => bug!(),\n         }\n \n-        self.super_terminator_kind(kind, location);\n+        self.super_terminator(terminator, location);\n     }\n \n     fn visit_local("}, {"sha": "a945c1d626a9a63849c17386ac2c1dd656781e59", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -454,18 +454,11 @@ fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibilit\n fn merge_codegen_units<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-    mut target_cgu_count: usize,\n+    target_cgu_count: usize,\n ) {\n     assert!(target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n-    if tcx.is_compiler_builtins(LOCAL_CRATE) {\n-        // Compiler builtins require some degree of control over how mono items\n-        // are partitioned into compilation units. Provide it by keeping the\n-        // original partitioning when compiling the compiler builtins crate.\n-        target_cgu_count = codegen_units.len();\n-    }\n-\n     // Note that at this point in time the `codegen_units` here may not be in a\n     // deterministic order (but we know they're deterministically the same set).\n     // We want this merging to produce a deterministic ordering of codegen units"}, {"sha": "71fff851531414be7586b3e03cd2fea759685203", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -582,7 +582,7 @@ impl CloneShimBuilder<'tcx> {\n         self.block(\n             vec![],\n             TerminatorKind::Drop {\n-                location: self.tcx.mk_place_index(dest, beg),\n+                place: self.tcx.mk_place_index(dest, beg),\n                 target: BasicBlock::new(8),\n                 unwind: None,\n             },\n@@ -634,7 +634,7 @@ impl CloneShimBuilder<'tcx> {\n                 self.block(\n                     vec![],\n                     TerminatorKind::Drop {\n-                        location: previous_field,\n+                        place: previous_field,\n                         target: previous_cleanup,\n                         unwind: None,\n                     },\n@@ -799,11 +799,7 @@ fn build_call_shim<'tcx>(\n         block(\n             &mut blocks,\n             vec![],\n-            TerminatorKind::Drop {\n-                location: rcvr_place(),\n-                target: BasicBlock::new(2),\n-                unwind: None,\n-            },\n+            TerminatorKind::Drop { place: rcvr_place(), target: BasicBlock::new(2), unwind: None },\n             false,\n         );\n     }\n@@ -814,11 +810,7 @@ fn build_call_shim<'tcx>(\n         block(\n             &mut blocks,\n             vec![],\n-            TerminatorKind::Drop {\n-                location: rcvr_place(),\n-                target: BasicBlock::new(4),\n-                unwind: None,\n-            },\n+            TerminatorKind::Drop { place: rcvr_place(), target: BasicBlock::new(4), unwind: None },\n             true,\n         );\n "}, {"sha": "a02d0f655600d9db337171f54348b88e702083dd", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -64,8 +64,8 @@ fn add_moves_for_packed_drops_patch<'tcx>(\n         let terminator = data.terminator();\n \n         match terminator.kind {\n-            TerminatorKind::Drop { location, .. }\n-                if util::is_disaligned(tcx, body, param_env, location) =>\n+            TerminatorKind::Drop { place, .. }\n+                if util::is_disaligned(tcx, body, param_env, place) =>\n             {\n                 add_move_for_packed_drop(tcx, body, &mut patch, terminator, loc, data.is_cleanup);\n             }\n@@ -88,13 +88,13 @@ fn add_move_for_packed_drop<'tcx>(\n     is_cleanup: bool,\n ) {\n     debug!(\"add_move_for_packed_drop({:?} @ {:?})\", terminator, loc);\n-    let (location, target, unwind) = match terminator.kind {\n-        TerminatorKind::Drop { ref location, target, unwind } => (location, target, unwind),\n+    let (place, target, unwind) = match terminator.kind {\n+        TerminatorKind::Drop { ref place, target, unwind } => (place, target, unwind),\n         _ => unreachable!(),\n     };\n \n     let source_info = terminator.source_info;\n-    let ty = location.ty(body, tcx).ty;\n+    let ty = place.ty(body, tcx).ty;\n     let temp = patch.new_temp(ty, terminator.source_info.span);\n \n     let storage_dead_block = patch.new_block(BasicBlockData {\n@@ -104,9 +104,9 @@ fn add_move_for_packed_drop<'tcx>(\n     });\n \n     patch.add_statement(loc, StatementKind::StorageLive(temp));\n-    patch.add_assign(loc, Place::from(temp), Rvalue::Use(Operand::Move(*location)));\n+    patch.add_assign(loc, Place::from(temp), Rvalue::Use(Operand::Move(*place)));\n     patch.patch_terminator(\n         loc.block,\n-        TerminatorKind::Drop { location: Place::from(temp), target: storage_dead_block, unwind },\n+        TerminatorKind::Drop { place: Place::from(temp), target: storage_dead_block, unwind },\n     );\n }"}, {"sha": "124606fb423e61c164aee58662215ad4128a2fee", "filename": "src/librustc_mir/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -78,7 +78,7 @@ impl Visitor<'tcx> for CheckLiveDrops<'mir, 'tcx> {\n         trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n \n         match &terminator.kind {\n-            mir::TerminatorKind::Drop { location: dropped_place, .. } => {\n+            mir::TerminatorKind::Drop { place: dropped_place, .. } => {\n                 let dropped_ty = dropped_place.ty(self.body, self.tcx).ty;\n                 if !NeedsDrop::in_any_value_of_ty(self.ccx, dropped_ty) {\n                     return;"}, {"sha": "b8104292aab23cf47c8d76181b352ce8abb08c29", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -121,25 +121,25 @@ where\n         self.super_assign(place, rvalue, location);\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &mir::TerminatorKind<'tcx>, location: Location) {\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n         // The effect of assignment to the return place in `TerminatorKind::Call` is not applied\n         // here; that occurs in `apply_call_return_effect`.\n \n-        if let mir::TerminatorKind::DropAndReplace { value, location: dest, .. } = kind {\n+        if let mir::TerminatorKind::DropAndReplace { value, place, .. } = &terminator.kind {\n             let qualif = qualifs::in_operand::<Q, _>(\n                 self.ccx,\n                 &mut |l| self.qualifs_per_local.contains(l),\n                 value,\n             );\n \n-            if !dest.is_indirect() {\n-                self.assign_qualif_direct(dest, qualif);\n+            if !place.is_indirect() {\n+                self.assign_qualif_direct(place, qualif);\n             }\n         }\n \n         // We need to assign qualifs to the dropped location before visiting the operand that\n         // replaces it since qualifs can be cleared on move.\n-        self.super_terminator_kind(kind, location);\n+        self.super_terminator(terminator, location);\n     }\n }\n "}, {"sha": "35a8df62cb83a967620c92d4fa1482dfddfd9bcb", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -560,8 +560,8 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n             // Forbid all `Drop` terminators unless the place being dropped is a local with no\n             // projections that cannot be `NeedsDrop`.\n-            TerminatorKind::Drop { location: dropped_place, .. }\n-            | TerminatorKind::DropAndReplace { location: dropped_place, .. } => {\n+            TerminatorKind::Drop { place: dropped_place, .. }\n+            | TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n                 // If we are checking live drops after drop-elaboration, don't emit duplicate\n                 // errors here.\n                 if super::post_drop_elaboration::checking_enabled(self.tcx) {"}, {"sha": "17ca918d32c9f6e3438a43bef0c0b545d04aec9b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -27,9 +27,9 @@ use rustc_trait_selection::traits;\n \n use crate::const_eval::error_to_const_error;\n use crate::interpret::{\n-    self, compile_time_machine, intern_const_alloc_recursive, AllocId, Allocation, Frame, ImmTy,\n-    Immediate, InternKind, InterpCx, LocalState, LocalValue, Memory, MemoryKind, OpTy,\n-    Operand as InterpOperand, PlaceTy, Pointer, ScalarMaybeUninit, StackPopCleanup,\n+    self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx, LocalState,\n+    LocalValue, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n+    ScalarMaybeUninit, StackPopCleanup,\n };\n use crate::transform::{MirPass, MirSource};\n \n@@ -702,11 +702,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 ScalarMaybeUninit::Scalar(l),\n                 ScalarMaybeUninit::Scalar(r),\n             )) => l.is_bits() && r.is_bits(),\n-            interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n-                let mplace = op.assert_mem_place(&self.ecx);\n-                intern_const_alloc_recursive(&mut self.ecx, InternKind::ConstProp, mplace, false);\n-                true\n-            }\n             _ => false,\n         }\n     }"}, {"sha": "1704d8baabdc8c24a617498e5e7c938be844fbca", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -85,15 +85,15 @@ fn find_dead_unwinds<'tcx>(\n         .iterate_to_fixpoint()\n         .into_results_cursor(body);\n     for (bb, bb_data) in body.basic_blocks().iter_enumerated() {\n-        let location = match bb_data.terminator().kind {\n-            TerminatorKind::Drop { ref location, unwind: Some(_), .. }\n-            | TerminatorKind::DropAndReplace { ref location, unwind: Some(_), .. } => location,\n+        let place = match bb_data.terminator().kind {\n+            TerminatorKind::Drop { ref place, unwind: Some(_), .. }\n+            | TerminatorKind::DropAndReplace { ref place, unwind: Some(_), .. } => place,\n             _ => continue,\n         };\n \n         debug!(\"find_dead_unwinds @ {:?}: {:?}\", bb, bb_data);\n \n-        let path = match env.move_data.rev_lookup.find(location.as_ref()) {\n+        let path = match env.move_data.rev_lookup.find(place.as_ref()) {\n             LookupResult::Exact(e) => e,\n             LookupResult::Parent(..) => {\n                 debug!(\"find_dead_unwinds: has parent; skipping\");\n@@ -105,7 +105,7 @@ fn find_dead_unwinds<'tcx>(\n         debug!(\n             \"find_dead_unwinds @ {:?}: path({:?})={:?}; init_data={:?}\",\n             bb,\n-            location,\n+            place,\n             path,\n             flow_inits.get()\n         );\n@@ -294,16 +294,16 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn collect_drop_flags(&mut self) {\n         for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n             let terminator = data.terminator();\n-            let location = match terminator.kind {\n-                TerminatorKind::Drop { ref location, .. }\n-                | TerminatorKind::DropAndReplace { ref location, .. } => location,\n+            let place = match terminator.kind {\n+                TerminatorKind::Drop { ref place, .. }\n+                | TerminatorKind::DropAndReplace { ref place, .. } => place,\n                 _ => continue,\n             };\n \n             self.init_data.seek_before(self.body.terminator_loc(bb));\n \n-            let path = self.move_data().rev_lookup.find(location.as_ref());\n-            debug!(\"collect_drop_flags: {:?}, place {:?} ({:?})\", bb, location, path);\n+            let path = self.move_data().rev_lookup.find(place.as_ref());\n+            debug!(\"collect_drop_flags: {:?}, place {:?} ({:?})\", bb, place, path);\n \n             let path = match path {\n                 LookupResult::Exact(e) => e,\n@@ -315,7 +315,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                             terminator.source_info.span,\n                             \"drop of untracked, uninitialized value {:?}, place {:?} ({:?})\",\n                             bb,\n-                            location,\n+                            place,\n                             path\n                         );\n                     }\n@@ -328,7 +328,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 debug!(\n                     \"collect_drop_flags: collecting {:?} from {:?}@{:?} - {:?}\",\n                     child,\n-                    location,\n+                    place,\n                     path,\n                     (maybe_live, maybe_dead)\n                 );\n@@ -346,13 +346,13 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n             let resume_block = self.patch.resume_block();\n             match terminator.kind {\n-                TerminatorKind::Drop { location, target, unwind } => {\n+                TerminatorKind::Drop { place, target, unwind } => {\n                     self.init_data.seek_before(loc);\n-                    match self.move_data().rev_lookup.find(location.as_ref()) {\n+                    match self.move_data().rev_lookup.find(place.as_ref()) {\n                         LookupResult::Exact(path) => elaborate_drop(\n                             &mut Elaborator { ctxt: self },\n                             terminator.source_info,\n-                            location,\n+                            place,\n                             path,\n                             target,\n                             if data.is_cleanup {\n@@ -371,10 +371,10 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                         }\n                     }\n                 }\n-                TerminatorKind::DropAndReplace { location, ref value, target, unwind } => {\n+                TerminatorKind::DropAndReplace { place, ref value, target, unwind } => {\n                     assert!(!data.is_cleanup);\n \n-                    self.elaborate_replace(loc, location, value, target, unwind);\n+                    self.elaborate_replace(loc, place, value, target, unwind);\n                 }\n                 _ => continue,\n             }\n@@ -396,7 +396,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn elaborate_replace(\n         &mut self,\n         loc: Location,\n-        location: Place<'tcx>,\n+        place: Place<'tcx>,\n         value: &Operand<'tcx>,\n         target: BasicBlock,\n         unwind: Option<BasicBlock>,\n@@ -407,7 +407,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         assert!(!data.is_cleanup, \"DropAndReplace in unwind path not supported\");\n \n         let assign = Statement {\n-            kind: StatementKind::Assign(box (location, Rvalue::Use(value.clone()))),\n+            kind: StatementKind::Assign(box (place, Rvalue::Use(value.clone()))),\n             source_info: terminator.source_info,\n         };\n \n@@ -427,14 +427,14 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             is_cleanup: false,\n         });\n \n-        match self.move_data().rev_lookup.find(location.as_ref()) {\n+        match self.move_data().rev_lookup.find(place.as_ref()) {\n             LookupResult::Exact(path) => {\n                 debug!(\"elaborate_drop_and_replace({:?}) - tracked {:?}\", terminator, path);\n                 self.init_data.seek_before(loc);\n                 elaborate_drop(\n                     &mut Elaborator { ctxt: self },\n                     terminator.source_info,\n-                    location,\n+                    place,\n                     path,\n                     target,\n                     Unwind::To(unwind),\n@@ -459,7 +459,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 debug!(\"elaborate_drop_and_replace({:?}) - untracked {:?}\", terminator, parent);\n                 self.patch.patch_terminator(\n                     bb,\n-                    TerminatorKind::Drop { location, target, unwind: Some(unwind) },\n+                    TerminatorKind::Drop { place, target, unwind: Some(unwind) },\n                 );\n             }\n         }"}, {"sha": "c8702eeae1d5b15ebb1bcfc632cd2d2f36d7aa88", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -93,13 +93,13 @@ impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor<'tcx> {\n         }\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &mut TerminatorKind<'tcx>, location: Location) {\n-        match kind {\n+    fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n+        match terminator.kind {\n             TerminatorKind::Return => {\n                 // Do not replace the implicit `_0` access here, as that's not possible. The\n                 // transform already handles `return` correctly.\n             }\n-            _ => self.super_terminator_kind(kind, location),\n+            _ => self.super_terminator(terminator, location),\n         }\n     }\n }\n@@ -835,8 +835,8 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n \n     for (block, block_data) in body.basic_blocks().iter_enumerated() {\n         let (target, unwind, source_info) = match block_data.terminator() {\n-            Terminator { source_info, kind: TerminatorKind::Drop { location, target, unwind } } => {\n-                if let Some(local) = location.as_local() {\n+            Terminator { source_info, kind: TerminatorKind::Drop { place, target, unwind } } => {\n+                if let Some(local) = place.as_local() {\n                     if local == SELF_ARG {\n                         (target, unwind, source_info)\n                     } else {\n@@ -1102,11 +1102,8 @@ fn create_generator_resume_function<'tcx>(\n fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n     let return_block = insert_term_block(body, TerminatorKind::Return);\n \n-    let term = TerminatorKind::Drop {\n-        location: Place::from(SELF_ARG),\n-        target: return_block,\n-        unwind: None,\n-    };\n+    let term =\n+        TerminatorKind::Drop { place: Place::from(SELF_ARG), target: return_block, unwind: None };\n     let source_info = SourceInfo::outermost(body.span);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars."}, {"sha": "db909494aed6b53f6c103158cb20c1ef24f37c0a", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -319,13 +319,13 @@ impl Inliner<'tcx> {\n             let term = blk.terminator();\n             let mut is_drop = false;\n             match term.kind {\n-                TerminatorKind::Drop { ref location, target, unwind }\n-                | TerminatorKind::DropAndReplace { ref location, target, unwind, .. } => {\n+                TerminatorKind::Drop { ref place, target, unwind }\n+                | TerminatorKind::DropAndReplace { ref place, target, unwind, .. } => {\n                     is_drop = true;\n                     work_list.push(target);\n-                    // If the location doesn't actually need dropping, treat it like\n+                    // If the place doesn't actually need dropping, treat it like\n                     // a regular goto.\n-                    let ty = location.ty(callee_body, tcx).subst(tcx, callsite.substs).ty;\n+                    let ty = place.ty(callee_body, tcx).subst(tcx, callsite.substs).ty;\n                     if ty.needs_drop(tcx, param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n@@ -731,14 +731,14 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &mut TerminatorKind<'tcx>, loc: Location) {\n+    fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, loc: Location) {\n         // Don't try to modify the implicit `_0` access on return (`return` terminators are\n         // replaced down below anyways).\n-        if !matches!(kind, TerminatorKind::Return) {\n-            self.super_terminator_kind(kind, loc);\n+        if !matches!(terminator.kind, TerminatorKind::Return) {\n+            self.super_terminator(terminator, loc);\n         }\n \n-        match *kind {\n+        match terminator.kind {\n             TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => bug!(),\n             TerminatorKind::Goto { ref mut target } => {\n                 *target = self.update_target(*target);\n@@ -782,11 +782,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::Return => {\n-                *kind = TerminatorKind::Goto { target: self.return_block };\n+                terminator.kind = TerminatorKind::Goto { target: self.return_block };\n             }\n             TerminatorKind::Resume => {\n                 if let Some(tgt) = self.cleanup_block {\n-                    *kind = TerminatorKind::Goto { target: tgt }\n+                    terminator.kind = TerminatorKind::Goto { target: tgt }\n                 }\n             }\n             TerminatorKind::Abort => {}"}, {"sha": "c36614938e10f9ab8b9a006faae3becece49105b", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,92 @@\n+use crate::transform::{MirPass, MirSource};\n+use crate::util::patch::MirPatch;\n+use rustc_hir::lang_items;\n+use rustc_middle::mir::interpret::Scalar;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::def_id::DefId;\n+use rustc_span::Span;\n+\n+/// Inserts call to count_code_region() as a placeholder to be replaced during code generation with\n+/// the intrinsic llvm.instrprof.increment.\n+pub struct InstrumentCoverage;\n+\n+impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        if tcx.sess.opts.debugging_opts.instrument_coverage {\n+            debug!(\"instrumenting {:?}\", src.def_id());\n+            instrument_coverage(tcx, body);\n+        }\n+    }\n+}\n+\n+// The first counter (start of the function) is index zero.\n+const INIT_FUNCTION_COUNTER: u32 = 0;\n+\n+/// Injects calls to placeholder function `count_code_region()`.\n+// FIXME(richkadel): As a first step, counters are only injected at the top of each function.\n+// The complete solution will inject counters at each conditional code branch.\n+pub fn instrument_coverage<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let span = body.span.shrink_to_lo();\n+\n+    let count_code_region_fn = function_handle(\n+        tcx,\n+        tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n+        span,\n+    );\n+    let counter_index = Operand::const_from_scalar(\n+        tcx,\n+        tcx.types.u32,\n+        Scalar::from_u32(INIT_FUNCTION_COUNTER),\n+        span,\n+    );\n+\n+    let mut patch = MirPatch::new(body);\n+\n+    let new_block = patch.new_block(placeholder_block(SourceInfo::outermost(body.span)));\n+    let next_block = START_BLOCK;\n+\n+    let temp = patch.new_temp(tcx.mk_unit(), body.span);\n+    patch.patch_terminator(\n+        new_block,\n+        TerminatorKind::Call {\n+            func: count_code_region_fn,\n+            args: vec![counter_index],\n+            // new_block will swapped with the next_block, after applying patch\n+            destination: Some((Place::from(temp), new_block)),\n+            cleanup: None,\n+            from_hir_call: false,\n+            fn_span: span,\n+        },\n+    );\n+\n+    patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n+    patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n+\n+    patch.apply(body);\n+\n+    // To insert the `new_block` in front of the first block in the counted branch (for example,\n+    // the START_BLOCK, at the top of the function), just swap the indexes, leaving the rest of the\n+    // graph unchanged.\n+    body.basic_blocks_mut().swap(next_block, new_block);\n+}\n+\n+fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Operand<'tcx> {\n+    let ret_ty = tcx.fn_sig(fn_def_id).output();\n+    let ret_ty = ret_ty.no_bound_vars().unwrap();\n+    let substs = tcx.mk_substs(::std::iter::once(ty::subst::GenericArg::from(ret_ty)));\n+    Operand::function_handle(tcx, fn_def_id, substs, span)\n+}\n+\n+fn placeholder_block<'tcx>(source_info: SourceInfo) -> BasicBlockData<'tcx> {\n+    BasicBlockData {\n+        statements: vec![],\n+        terminator: Some(Terminator {\n+            source_info,\n+            // this gets overwritten by the counter Call\n+            kind: TerminatorKind::Unreachable,\n+        }),\n+        is_cleanup: false,\n+    }\n+}"}, {"sha": "846ed1f86d8d6ab996bd664edc191aaa460331f9", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -28,6 +28,7 @@ pub mod elaborate_drops;\n pub mod generator;\n pub mod inline;\n pub mod instcombine;\n+pub mod instrument_coverage;\n pub mod no_landing_pads;\n pub mod nrvo;\n pub mod promote_consts;\n@@ -288,6 +289,10 @@ fn mir_validated(\n             // What we need to run borrowck etc.\n             &promote_pass,\n             &simplify::SimplifyCfg::new(\"qualify-consts\"),\n+            // If the `instrument-coverage` option is enabled, analyze the CFG, identify each\n+            // conditional branch, construct a coverage map to be passed to LLVM, and inject counters\n+            // where needed.\n+            &instrument_coverage::InstrumentCoverage,\n         ]],\n     );\n "}, {"sha": "1d83733e4cd306bc88868a32f6195286df53327d", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -34,10 +34,10 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads<'tcx> {\n         self.tcx\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &mut TerminatorKind<'tcx>, location: Location) {\n-        if let Some(unwind) = kind.unwind_mut() {\n+    fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n+        if let Some(unwind) = terminator.kind.unwind_mut() {\n             unwind.take();\n         }\n-        self.super_terminator_kind(kind, location);\n+        self.super_terminator(terminator, location);\n     }\n }"}, {"sha": "330f6c1640ff493ecd0b9ce443982a6ae22943f7", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -147,7 +147,6 @@ struct Collector<'a, 'tcx> {\n     ccx: &'a ConstCx<'a, 'tcx>,\n     temps: IndexVec<Local, TempState>,\n     candidates: Vec<Candidate>,\n-    span: Span,\n }\n \n impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n@@ -216,10 +215,10 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n         }\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &TerminatorKind<'tcx>, location: Location) {\n-        self.super_terminator_kind(kind, location);\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        self.super_terminator(terminator, location);\n \n-        match *kind {\n+        match terminator.kind {\n             TerminatorKind::Call { ref func, .. } => {\n                 if let ty::FnDef(def_id, _) = func.ty(self.ccx.body, self.ccx.tcx).kind {\n                     let fn_sig = self.ccx.tcx.fn_sig(def_id);\n@@ -254,10 +253,6 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n             _ => {}\n         }\n     }\n-\n-    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n-        self.span = source_info.span;\n-    }\n }\n \n pub fn collect_temps_and_candidates(\n@@ -267,7 +262,6 @@ pub fn collect_temps_and_candidates(\n     let mut collector = Collector {\n         temps: IndexVec::from_elem(TempState::Undefined, &ccx.body.local_decls),\n         candidates: vec![],\n-        span: ccx.body.span,\n         ccx,\n     };\n     for (bb, data) in rpo {\n@@ -1192,7 +1186,7 @@ pub fn promote_candidates<'tcx>(\n             _ => true,\n         });\n         let terminator = block.terminator_mut();\n-        if let TerminatorKind::Drop { location: place, target, .. } = &terminator.kind {\n+        if let TerminatorKind::Drop { place, target, .. } = &terminator.kind {\n             if let Some(index) = place.as_local() {\n                 if promoted(index) {\n                     terminator.kind = TerminatorKind::Goto { target: *target };"}, {"sha": "caf6c7715a9e1caa3cc717c266e1a1a670cc5b87", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -349,9 +349,9 @@ fn check_terminator(\n         | TerminatorKind::Resume\n         | TerminatorKind::Unreachable => Ok(()),\n \n-        TerminatorKind::Drop { location, .. } => check_place(tcx, *location, span, def_id, body),\n-        TerminatorKind::DropAndReplace { location, value, .. } => {\n-            check_place(tcx, *location, span, def_id, body)?;\n+        TerminatorKind::Drop { place, .. } => check_place(tcx, *place, span, def_id, body),\n+        TerminatorKind::DropAndReplace { place, value, .. } => {\n+            check_place(tcx, *place, span, def_id, body)?;\n             check_operand(tcx, value, span, def_id, body)\n         }\n "}, {"sha": "5f55a812a4e0dc2cdfbc63c0022b17ff1627dd17", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -238,7 +238,7 @@ where\n                 self.elaborator.patch().patch_terminator(\n                     bb,\n                     TerminatorKind::Drop {\n-                        location: self.place,\n+                        place: self.place,\n                         target: self.succ,\n                         unwind: self.unwind.into_option(),\n                     },\n@@ -723,7 +723,7 @@ where\n         self.elaborator.patch().patch_terminator(\n             drop_block,\n             TerminatorKind::Drop {\n-                location: tcx.mk_place_deref(ptr),\n+                place: tcx.mk_place_deref(ptr),\n                 target: loop_block,\n                 unwind: unwind.into_option(),\n             },\n@@ -1000,7 +1000,7 @@ where\n \n     fn drop_block(&mut self, target: BasicBlock, unwind: Unwind) -> BasicBlock {\n         let block =\n-            TerminatorKind::Drop { location: self.place, target, unwind: unwind.into_option() };\n+            TerminatorKind::Drop { place: self.place, target, unwind: unwind.into_option() };\n         self.new_block(unwind, block)\n     }\n "}, {"sha": "e2cf1bce733d6b2c70959c507cdb39a9b357c86e", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -687,7 +687,7 @@ fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'t\n     let tcx = hir.tcx();\n     let owner_id = tcx.hir().body_owner(body_id);\n     let span = tcx.hir().span(owner_id);\n-    let ty = tcx.types.err;\n+    let ty = tcx.ty_error();\n     let num_params = match hir.body_owner_kind {\n         hir::BodyOwnerKind::Fn => tcx.hir().fn_decl_by_hir_id(owner_id).unwrap().inputs.len(),\n         hir::BodyOwnerKind::Closure => {\n@@ -909,7 +909,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         self.local_decls[local].mutability = mutability;\n                         self.local_decls[local].source_info.scope = self.source_scope;\n                         self.local_decls[local].local_info = if let Some(kind) = self_binding {\n-                            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(*kind))))\n+                            Some(box LocalInfo::User(ClearCrossCrate::Set(\n+                                BindingForm::ImplicitSelf(*kind),\n+                            )))\n                         } else {\n                             let binding_mode = ty::BindingMode::BindByValue(mutability);\n                             Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var("}, {"sha": "b8df27094471ffcc87b4aa02cc39c026d8e5e400", "filename": "src/librustc_mir_build/build/scope.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1037,7 +1037,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         block: BasicBlock,\n         span: Span,\n-        location: Place<'tcx>,\n+        place: Place<'tcx>,\n         value: Operand<'tcx>,\n     ) -> BlockAnd<()> {\n         let source_info = self.source_info(span);\n@@ -1047,7 +1047,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             block,\n             source_info,\n             TerminatorKind::DropAndReplace {\n-                location,\n+                place,\n                 value,\n                 target: next_target,\n                 unwind: Some(diverge_target),\n@@ -1158,7 +1158,7 @@ fn build_scope_drops<'tcx>(\n                     block,\n                     source_info,\n                     TerminatorKind::Drop {\n-                        location: local.into(),\n+                        place: local.into(),\n                         target: next,\n                         unwind: Some(unwind_to),\n                     },\n@@ -1272,7 +1272,7 @@ fn build_diverge_scope<'tcx>(\n                         block,\n                         source_info(drop_data.span),\n                         TerminatorKind::Drop {\n-                            location: drop_data.local.into(),\n+                            place: drop_data.local.into(),\n                             target,\n                             unwind: None,\n                         },"}, {"sha": "a1796c9433eac0329d92b86558bf7c66303f5cbc", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -478,7 +478,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                                     );\n \n                                     // Not a real fn, but we're not reaching codegen anyways...\n-                                    ty = cx.tcx.types.err;\n+                                    ty = cx.tcx.ty_error();\n                                     InlineAsmOperand::SymFn {\n                                         expr: Expr {\n                                             ty,"}, {"sha": "1aed8e844b60b02f261b2b3e27fddbe7be608ae2", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -107,8 +107,15 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 cv.ty, structural\n             );\n \n+            // This can occur because const qualification treats all associated constants as\n+            // opaque, whereas `search_for_structural_match_violation` tries to monomorphize them\n+            // before it runs.\n+            //\n+            // FIXME(#73448): Find a way to bring const qualification into parity with\n+            // `search_for_structural_match_violation`.\n             if structural.is_none() && mir_structural_match_violation {\n-                bug!(\"MIR const-checker found novel structural match violation\");\n+                warn!(\"MIR const-checker found novel structural match violation. See #73448.\");\n+                return inlined_const_as_pat;\n             }\n \n             if let Some(non_sm_ty) = structural {"}, {"sha": "5c30b2a448c6d3a6b6d86f6c161df8870355f1ef", "filename": "src/librustc_mir_build/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -509,7 +509,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         let mut ty = self.tables.node_type(pat.hir_id);\n \n-        if let ty::Error = ty.kind {\n+        if let ty::Error(_) = ty.kind {\n             // Avoid ICEs (e.g., #50577 and #50585).\n             return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n         }\n@@ -708,7 +708,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 if adt_def.is_enum() {\n                     let substs = match ty.kind {\n                         ty::Adt(_, substs) | ty::FnDef(_, substs) => substs,\n-                        ty::Error => {\n+                        ty::Error(_) => {\n                             // Avoid ICE (#50585)\n                             return PatKind::Wild;\n                         }\n@@ -1051,7 +1051,7 @@ crate fn compare_const_vals<'tcx>(\n     let b_bits = b.try_eval_bits(tcx, param_env, ty);\n \n     if let (Some(a), Some(b)) = (a_bits, b_bits) {\n-        use ::rustc_apfloat::Float;\n+        use rustc_apfloat::Float;\n         return match ty.kind {\n             ty::Float(ast::FloatTy::F32) => {\n                 let l = ::rustc_apfloat::ieee::Single::from_bits(a);"}, {"sha": "2e3cf4e746ae959778a5a2df14b1794288814a7f", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -339,8 +339,15 @@ impl<'a> StringReader<'a> {\n             }\n             rustc_lexer::LiteralKind::Byte { terminated } => {\n                 if !terminated {\n-                    self.fatal_span_(start + BytePos(1), suffix_start, \"unterminated byte constant\")\n-                        .raise()\n+                    self.sess\n+                        .span_diagnostic\n+                        .struct_span_fatal_with_code(\n+                            self.mk_sp(start + BytePos(1), suffix_start),\n+                            \"unterminated byte constant\",\n+                            error_code!(E0763),\n+                        )\n+                        .emit();\n+                    FatalError.raise();\n                 }\n                 (token::Byte, Mode::Byte, 2, 1) // b' '\n             }"}, {"sha": "fc9ffc3092447e7941668e671f6f6702ffd2abc3", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -961,7 +961,7 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let sp = self.prev_token.span;\n             self.struct_span_err(sp, &msg)\n-                .span_suggestion(sp, \"change this to `;`\", \";\".to_string(), appl)\n+                .span_suggestion_short(sp, \"change this to `;`\", \";\".to_string(), appl)\n                 .emit();\n             return Ok(());\n         } else if self.look_ahead(0, |t| {"}, {"sha": "53f32b7c800bdaf74af35dfcba588571e1be4f16", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -216,8 +216,28 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses the RHS of a local variable declaration (e.g., '= 14;').\n-    fn parse_initializer(&mut self, skip_eq: bool) -> PResult<'a, Option<P<Expr>>> {\n-        if self.eat(&token::Eq) || skip_eq { Ok(Some(self.parse_expr()?)) } else { Ok(None) }\n+    fn parse_initializer(&mut self, eq_optional: bool) -> PResult<'a, Option<P<Expr>>> {\n+        let eq_consumed = match self.token.kind {\n+            token::BinOpEq(..) => {\n+                // Recover `let x <op>= 1` as `let x = 1`\n+                self.struct_span_err(\n+                    self.token.span,\n+                    \"can't reassign to an uninitialized variable\",\n+                )\n+                .span_suggestion_short(\n+                    self.token.span,\n+                    \"initialize the variable\",\n+                    \"=\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .emit();\n+                self.bump();\n+                true\n+            }\n+            _ => self.eat(&token::Eq),\n+        };\n+\n+        Ok(if eq_consumed || eq_optional { Some(self.parse_expr()?) } else { None })\n     }\n \n     /// Parses a block. No inner attributes are allowed."}, {"sha": "88fb78f85e423add2e3303342314fcd09f6485f5", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -150,7 +150,7 @@ impl ExprVisitor<'tcx> {\n             _ => unreachable!(),\n         };\n         let asm_ty = match ty.kind {\n-            ty::Never | ty::Error => return None,\n+            ty::Never | ty::Error(_) => return None,\n             ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => Some(InlineAsmType::I8),\n             ty::Int(IntTy::I16) | ty::Uint(UintTy::U16) => Some(InlineAsmType::I16),\n             ty::Int(IntTy::I32) | ty::Uint(UintTy::U32) => Some(InlineAsmType::I32),\n@@ -167,7 +167,7 @@ impl ExprVisitor<'tcx> {\n                 let fields = &adt.non_enum_variant().fields;\n                 let elem_ty = fields[0].ty(self.tcx, substs);\n                 match elem_ty.kind {\n-                    ty::Never | ty::Error => return None,\n+                    ty::Never | ty::Error(_) => return None,\n                     ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => {\n                         Some(InlineAsmType::VecI8(fields.len() as u64))\n                     }"}, {"sha": "f2f07b5d4fb26fba2d7a8acf877d2136f734b2ff", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -5,10 +5,12 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::lang_items;\n+use rustc_hir::lang_items::ITEM_REFS;\n use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n use rustc_middle::middle::lang_items::whitelisted;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n+use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n@@ -70,11 +72,21 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n }\n \n impl<'a, 'tcx> Context<'a, 'tcx> {\n-    fn register(&mut self, name: Symbol, span: Span) {\n+    fn register(&mut self, name: Symbol, span: Span, hir_id: hir::HirId) {\n         if let Some(&item) = WEAK_ITEMS_REFS.get(&name) {\n             if self.items.require(item).is_err() {\n                 self.items.missing.push(item);\n             }\n+        } else if name == sym::count_code_region {\n+            // `core::intrinsics::code_count_region()` is (currently) the only `extern` lang item\n+            // that is never actually linked. It is not a `weak_lang_item` that can be registered\n+            // when used, and should be registered here instead.\n+            if let Some((item_index, _)) = ITEM_REFS.get(&*name.as_str()).cloned() {\n+                if self.items.items[item_index].is_none() {\n+                    let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n+                    self.items.items[item_index] = Some(item_def_id);\n+                }\n+            }\n         } else {\n             struct_span_err!(self.tcx.sess, span, E0264, \"unknown external lang item: `{}`\", name)\n                 .emit();\n@@ -91,7 +103,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n         if let Some((lang_item, _)) = hir::lang_items::extract(&i.attrs) {\n-            self.register(lang_item, i.span);\n+            self.register(lang_item, i.span, i.hir_id);\n         }\n         intravisit::walk_foreign_item(self, i)\n     }"}, {"sha": "9e6e7ea962bc378f21f3dc34aab3a50e22cdb68b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -220,7 +220,7 @@ where\n             | ty::Ref(..)\n             | ty::FnPtr(..)\n             | ty::Param(..)\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::GeneratorWitness(..) => {}\n             ty::Bound(..) | ty::Placeholder(..) | ty::Infer(..) => {\n                 bug!(\"unexpected type: {:?}\", ty)"}, {"sha": "8432e34a5271ceef7ddc9eed6de8b256f671f5cb", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -485,6 +485,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                             module_path.push(Segment {\n                                 ident: Ident { name: kw::PathRoot, span: source.ident.span },\n                                 id: Some(self.r.next_node_id()),\n+                                has_generic_args: false,\n                             });\n                             source.ident.name = crate_name;\n                         }"}, {"sha": "05ef0aa0bb689f5e6f2c85c3778baa3d1fa90fca", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -920,20 +920,47 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n         &self,\n         path: &[Segment],\n     ) -> Option<(Span, &'static str, String, Applicability)> {\n-        let ident = match path {\n-            [segment] => segment.ident,\n+        let (ident, span) = match path {\n+            [segment] if !segment.has_generic_args => {\n+                (segment.ident.to_string(), segment.ident.span)\n+            }\n             _ => return None,\n         };\n-        match (\n-            self.diagnostic_metadata.current_item,\n-            self.diagnostic_metadata.currently_processing_generics,\n-        ) {\n-            (Some(Item { kind: ItemKind::Fn(..), ident, .. }), true) if ident.name == sym::main => {\n+        let mut iter = ident.chars().map(|c| c.is_uppercase());\n+        let single_uppercase_char =\n+            matches!(iter.next(), Some(true)) && matches!(iter.next(), None);\n+        if !self.diagnostic_metadata.currently_processing_generics && !single_uppercase_char {\n+            return None;\n+        }\n+        match (self.diagnostic_metadata.current_item, single_uppercase_char) {\n+            (Some(Item { kind: ItemKind::Fn(..), ident, .. }), _) if ident.name == sym::main => {\n                 // Ignore `fn main()` as we don't want to suggest `fn main<T>()`\n             }\n-            (Some(Item { kind, .. }), true) => {\n+            (\n+                Some(Item {\n+                    kind:\n+                        kind @ ItemKind::Fn(..)\n+                        | kind @ ItemKind::Enum(..)\n+                        | kind @ ItemKind::Struct(..)\n+                        | kind @ ItemKind::Union(..),\n+                    ..\n+                }),\n+                true,\n+            )\n+            | (Some(Item { kind, .. }), false) => {\n                 // Likely missing type parameter.\n                 if let Some(generics) = kind.generics() {\n+                    if span.overlaps(generics.span) {\n+                        // Avoid the following:\n+                        // error[E0405]: cannot find trait `A` in this scope\n+                        //  --> $DIR/typo-suggestion-named-underscore.rs:CC:LL\n+                        //   |\n+                        // L | fn foo<T: A>(x: T) {} // Shouldn't suggest underscore\n+                        //   |           ^- help: you might be missing a type parameter: `, A`\n+                        //   |           |\n+                        //   |           not found in this scope\n+                        return None;\n+                    }\n                     let msg = \"you might be missing a type parameter\";\n                     let (span, sugg) = if let [.., param] = &generics.params[..] {\n                         let span = if let [.., bound] = &param.bounds[..] {"}, {"sha": "cca9eabe7bcf898d82945497a49d3c26cecb9b49", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -225,13 +225,15 @@ enum VisResolutionError<'a> {\n     ModuleOnly(Span),\n }\n \n-// A minimal representation of a path segment. We use this in resolve because\n-// we synthesize 'path segments' which don't have the rest of an AST or HIR\n-// `PathSegment`.\n+/// A minimal representation of a path segment. We use this in resolve because we synthesize 'path\n+/// segments' which don't have the rest of an AST or HIR `PathSegment`.\n #[derive(Clone, Copy, Debug)]\n pub struct Segment {\n     ident: Ident,\n     id: Option<NodeId>,\n+    /// Signals whether this `PathSegment` has generic arguments. Used to avoid providing\n+    /// nonsensical suggestions.\n+    has_generic_args: bool,\n }\n \n impl Segment {\n@@ -240,7 +242,7 @@ impl Segment {\n     }\n \n     fn from_ident(ident: Ident) -> Segment {\n-        Segment { ident, id: None }\n+        Segment { ident, id: None, has_generic_args: false }\n     }\n \n     fn names_to_string(segments: &[Segment]) -> String {\n@@ -250,7 +252,7 @@ impl Segment {\n \n impl<'a> From<&'a ast::PathSegment> for Segment {\n     fn from(seg: &'a ast::PathSegment) -> Segment {\n-        Segment { ident: seg.ident, id: Some(seg.id) }\n+        Segment { ident: seg.ident, id: Some(seg.id), has_generic_args: seg.args.is_some() }\n     }\n }\n \n@@ -2017,7 +2019,7 @@ impl<'a> Resolver<'a> {\n             path, opt_ns, record_used, path_span, crate_lint,\n         );\n \n-        for (i, &Segment { ident, id }) in path.iter().enumerate() {\n+        for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n             let record_segment_res = |this: &mut Self, res| {\n                 if record_used {"}, {"sha": "cae501e942b6552eca0e156cc1b403db4a83fddf", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -520,7 +520,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     pub fn get_expr_data(&self, expr: &hir::Expr<'_>) -> Option<Data> {\n         let hir_node = self.tcx.hir().expect_expr(expr.hir_id);\n         let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n-        if ty.is_none() || ty.unwrap().kind == ty::Error {\n+        if ty.is_none() || matches!(ty.unwrap().kind, ty::Error(_)) {\n             return None;\n         }\n         match expr.kind {"}, {"sha": "5586b82b0edc082f8c5001b0516ee001b5963a52", "filename": "src/librustc_session/filesearch.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_session%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_session%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Ffilesearch.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -41,6 +41,10 @@ impl<'a> FileSearch<'a> {\n         make_target_lib_path(self.sysroot, self.triple)\n     }\n \n+    pub fn get_selfcontained_lib_path(&self) -> PathBuf {\n+        self.get_lib_path().join(\"self-contained\")\n+    }\n+\n     pub fn search<F>(&self, mut pick: F)\n     where\n         F: FnMut(&SearchPathFile, PathKind) -> FileMatch,\n@@ -94,7 +98,7 @@ impl<'a> FileSearch<'a> {\n         p.push(RUST_LIB_DIR);\n         p.push(&self.triple);\n         p.push(\"bin\");\n-        vec![p]\n+        vec![p.clone(), p.join(\"self-contained\")]\n     }\n }\n "}, {"sha": "5a8f5c1b9fbca8685a1caf87f5c12624ab1fcdcc", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -534,6 +534,16 @@ declare_lint! {\n     @feature_gate = sym::unsafe_block_in_unsafe_fn;\n }\n \n+declare_lint! {\n+    pub CENUM_IMPL_DROP_CAST,\n+    Warn,\n+    \"a C-like enum implementing Drop is cast\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #73333 <https://github.com/rust-lang/rust/issues/73333>\",\n+        edition: None,\n+    };\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -607,6 +617,7 @@ declare_lint_pass! {\n         ASM_SUB_REGISTER,\n         UNSAFE_OP_IN_UNSAFE_FN,\n         INCOMPLETE_INCLUDE,\n+        CENUM_IMPL_DROP_CAST,\n     ]\n }\n "}, {"sha": "2d231359057fd1669603e11f5337f6c21e74ba84", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -876,6 +876,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"fix undefined behavior when a thread doesn't eventually make progress \\\n         (such as entering an empty infinite loop) by inserting llvm.sideeffect \\\n         (default: no)\"),\n+    instrument_coverage: bool = (false, parse_bool, [TRACKED],\n+        \"instrument the generated code with LLVM code region counters to \\\n+        (in the future) generate coverage reports (experimental; default: no)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "970a26325926cc13a5cdd391ada1b5fa1d3882c6", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -240,6 +240,7 @@ symbols! {\n         copy_closures,\n         core,\n         core_intrinsics,\n+        count_code_region,\n         crate_id,\n         crate_in_paths,\n         crate_local,\n@@ -345,6 +346,7 @@ symbols! {\n         from_method,\n         from_ok,\n         from_usize,\n+        from_trait,\n         fundamental,\n         future,\n         Future,"}, {"sha": "7d117b77cf5e5ab95484cf54b8cdb8fdd5812fb9", "filename": "src/librustc_symbol_mangling/v0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_symbol_mangling%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_symbol_mangling%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Fv0.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -345,7 +345,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             ty::Never => \"z\",\n \n             // Placeholders (should be demangled as `_`).\n-            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error => \"p\",\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error(_) => \"p\",\n \n             _ => \"\",\n         };\n@@ -367,7 +367,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             ty::Tuple(_) if ty.is_unit() => unreachable!(),\n \n             // Placeholders, also handled as part of basic types.\n-            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error => {\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error(_) => {\n                 unreachable!()\n             }\n "}, {"sha": "c79e9bb28900882ed0a41860f628a477d56b16a8", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -809,25 +809,30 @@ pub enum Variants {\n     /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n     Single { index: VariantIdx },\n \n-    /// Enum-likes with more than one inhabited variant: for each case there is\n-    /// a struct, and they all have space reserved for the discriminant.\n-    /// For enums this is the sole field of the layout.\n+    /// Enum-likes with more than one inhabited variant: each variant comes with\n+    /// a *discriminant* (usually the same as the variant index but the user can\n+    /// assign explicit discriminant values).  That discriminant is encoded\n+    /// as a *tag* on the machine.  The layout of each variant is\n+    /// a struct, and they all have space reserved for the tag.\n+    /// For enums, the tag is the sole field of the layout.\n     Multiple {\n-        discr: Scalar,\n-        discr_kind: DiscriminantKind,\n-        discr_index: usize,\n+        tag: Scalar,\n+        tag_encoding: TagEncoding,\n+        tag_field: usize,\n         variants: IndexVec<VariantIdx, Layout>,\n     },\n }\n \n #[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n-pub enum DiscriminantKind {\n-    /// Integer tag holding the discriminant value itself.\n-    Tag,\n+pub enum TagEncoding {\n+    /// The tag directly stores the discriminant, but possibly with a smaller layout\n+    /// (so converting the tag to the discriminant can require sign extension).\n+    Direct,\n \n     /// Niche (values invalid for a type) encoding the discriminant:\n-    /// the variant `dataful_variant` contains a niche at an arbitrary\n-    /// offset (field `discr_index` of the enum), which for a variant with\n+    /// Discriminant and variant index coincide.\n+    /// The variant `dataful_variant` contains a niche at an arbitrary\n+    /// offset (field `tag_field` of the enum), which for a variant with\n     /// discriminant `d` is set to\n     /// `(d - niche_variants.start).wrapping_add(niche_start)`.\n     ///"}, {"sha": "3a22290da68583ceef070dcdfa1898d6237b42b5", "filename": "src/librustc_target/spec/x86_64_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_linux_musl.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -6,6 +6,7 @@ pub fn target() -> TargetResult {\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.stack_probes = true;\n+    base.static_position_independent_executables = true;\n \n     Ok(Target {\n         llvm_target: \"x86_64-unknown-linux-musl\".to_string(),"}, {"sha": "adccdd0b2617a4760602c13c8569fe0fd6c13492", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -941,7 +941,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                             )\n                             .emit();\n \n-                        self.tcx().types.err\n+                        self.tcx().ty_error()\n                     }\n                 }\n             }\n@@ -974,7 +974,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                             )\n                             .emit();\n \n-                        self.tcx().mk_const(ty::Const { val: ty::ConstKind::Error, ty: ct.ty })\n+                        self.tcx().const_error(ct.ty)\n                     }\n                 }\n             }\n@@ -1002,7 +1002,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             tcx,\n             ty_op: |ty| {\n                 if ty.references_error() {\n-                    return tcx.types.err;\n+                    return tcx.ty_error();\n                 } else if let ty::Opaque(def_id, substs) = ty.kind {\n                     // Check that this is `impl Trait` type is\n                     // declared by `parent_def_id` -- i.e., one whose"}, {"sha": "706cbf058b713b354ce7d985d4bba9772790c044", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -565,7 +565,7 @@ fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>>\n             }\n         }\n \n-        ty::Error => None,\n+        ty::Error(_) => None,\n \n         ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)"}, {"sha": "e5a6c9a2e391a2a548ce895628124e121d676be7", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1246,7 +1246,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 ty::Generator(..) => Some(18),\n                 ty::Foreign(..) => Some(19),\n                 ty::GeneratorWitness(..) => Some(20),\n-                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n+                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => None,\n             }\n         }\n "}, {"sha": "dfd7dac72d8e1702996d1cec1954a39415d038d7", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -948,7 +948,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n              ty| {\n                 let ty = self.resolve_vars_if_possible(&ty);\n                 same &=\n-                    ty.kind != ty::Error\n+                    !matches!(ty.kind, ty::Error(_))\n                         && last_ty.map_or(true, |last_ty| {\n                             // FIXME: ideally we would use `can_coerce` here instead, but `typeck` comes\n                             // *after* in the dependency graph.\n@@ -1992,8 +1992,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n /// Collect all the returned expressions within the input expression.\n /// Used to point at the return spans when we want to suggest some change to them.\n #[derive(Default)]\n-struct ReturnsVisitor<'v> {\n-    returns: Vec<&'v hir::Expr<'v>>,\n+pub struct ReturnsVisitor<'v> {\n+    pub returns: Vec<&'v hir::Expr<'v>>,\n     in_block_tail: bool,\n }\n "}, {"sha": "ed108613bfa233735952dcd4dc35c60c5e22be2d", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -784,7 +784,7 @@ struct Progress<'tcx> {\n \n impl<'tcx> Progress<'tcx> {\n     fn error(tcx: TyCtxt<'tcx>) -> Self {\n-        Progress { ty: tcx.types.err, obligations: vec![] }\n+        Progress { ty: tcx.ty_error(), obligations: vec![] }\n     }\n \n     fn with_addl_obligations(mut self, mut obligations: Vec<PredicateObligation<'tcx>>) -> Self {\n@@ -1085,7 +1085,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     | ty::Bound(..)\n                     | ty::Placeholder(..)\n                     | ty::Infer(..)\n-                    | ty::Error => false,\n+                    | ty::Error(_) => false,\n                 }\n             }\n             super::ImplSourceParam(..) => {\n@@ -1440,8 +1440,8 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n                 obligation, poly_cache_entry, e,\n             );\n             debug!(\"confirm_param_env_candidate: {}\", msg);\n-            infcx.tcx.sess.delay_span_bug(obligation.cause.span, &msg);\n-            Progress { ty: infcx.tcx.types.err, obligations: vec![] }\n+            let err = infcx.tcx.ty_error_with_message(obligation.cause.span, &msg);\n+            Progress { ty: err, obligations: vec![] }\n         }\n     }\n }\n@@ -1460,7 +1460,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let param_env = obligation.param_env;\n     let assoc_ty = match assoc_ty_def(selcx, impl_def_id, assoc_item_id) {\n         Ok(assoc_ty) => assoc_ty,\n-        Err(ErrorReported) => return Progress { ty: tcx.types.err, obligations: nested },\n+        Err(ErrorReported) => return Progress { ty: tcx.ty_error(), obligations: nested },\n     };\n \n     if !assoc_ty.item.defaultness.has_value() {\n@@ -1472,16 +1472,18 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n             \"confirm_impl_candidate: no associated type {:?} for {:?}\",\n             assoc_ty.item.ident, obligation.predicate\n         );\n-        return Progress { ty: tcx.types.err, obligations: nested };\n+        return Progress { ty: tcx.ty_error(), obligations: nested };\n     }\n     let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n     let substs =\n         translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);\n     let ty = tcx.type_of(assoc_ty.item.def_id);\n     if substs.len() != tcx.generics_of(assoc_ty.item.def_id).count() {\n-        tcx.sess\n-            .delay_span_bug(DUMMY_SP, \"impl item and trait item have different parameter counts\");\n-        Progress { ty: tcx.types.err, obligations: nested }\n+        let err = tcx.ty_error_with_message(\n+            DUMMY_SP,\n+            \"impl item and trait item have different parameter counts\",\n+        );\n+        Progress { ty: err, obligations: nested }\n     } else {\n         Progress { ty: ty.subst(tcx, substs), obligations: nested }\n     }"}, {"sha": "d07c95270e0040411e00fe825053eb5c15cd85cc", "filename": "src/librustc_trait_selection/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -101,7 +101,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Ref(..)\n         | ty::Str\n         | ty::Foreign(..)\n-        | ty::Error => true,\n+        | ty::Error(_) => true,\n \n         // [T; N] and [T] have same properties as T.\n         ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),"}, {"sha": "3fd566eab437e8899c4f2e7b7cdf7ae57dc27eb0", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1569,7 +1569,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Array(..)\n             | ty::Closure(..)\n             | ty::Never\n-            | ty::Error => {\n+            | ty::Error(_) => {\n                 // safe for everything\n                 Where(ty::Binder::dummy(Vec::new()))\n             }\n@@ -1613,7 +1613,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Infer(ty::FloatVar(_))\n             | ty::FnDef(..)\n             | ty::FnPtr(_)\n-            | ty::Error => Where(ty::Binder::dummy(Vec::new())),\n+            | ty::Error(_) => Where(ty::Binder::dummy(Vec::new())),\n \n             ty::Uint(_)\n             | ty::Int(_)\n@@ -1690,7 +1690,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::FnDef(..)\n             | ty::FnPtr(_)\n             | ty::Str\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n             | ty::Never\n             | ty::Char => Vec::new(),"}, {"sha": "201edf27a655cbba3d77ea2eb6e96492c8c8f26c", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -219,7 +219,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n             ty::Infer(_) | ty::Placeholder(_) | ty::Bound(..) => {\n                 bug!(\"unexpected type during structural-match checking: {:?}\", ty);\n             }\n-            ty::Error => {\n+            ty::Error(_) => {\n                 self.tcx().sess.delay_span_bug(self.span, \"ty::Error in structural-match check\");\n                 // We still want to check other types after encountering an error,\n                 // as this may still emit relevant errors."}, {"sha": "1825c159ff3fba47bedffdf47e277c2becd5b95f", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -392,7 +392,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                 ));\n                             }\n                         }\n-                        ty::ConstKind::Error\n+                        ty::ConstKind::Error(_)\n                         | ty::ConstKind::Param(_)\n                         | ty::ConstKind::Bound(..)\n                         | ty::ConstKind::Placeholder(..) => {\n@@ -412,7 +412,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 | ty::Int(..)\n                 | ty::Uint(..)\n                 | ty::Float(..)\n-                | ty::Error\n+                | ty::Error(_)\n                 | ty::Str\n                 | ty::GeneratorWitness(..)\n                 | ty::Never"}, {"sha": "c9dd06e9f1ba2ade7d14e1c19bc517a7acb6fbe9", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -168,7 +168,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n                 GenericArgKind::Type(ty) => match ty.kind {\n                     // These types are always WF.\n-                    ty::Str | ty::Placeholder(..) | ty::Error | ty::Never => {\n+                    ty::Str | ty::Placeholder(..) | ty::Error(_) | ty::Never => {\n                         chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n                     }\n \n@@ -376,7 +376,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n             })\n             .intern(interner),\n             Infer(_infer) => unimplemented!(),\n-            Error => unimplemented!(),\n+            Error(_) => unimplemented!(),\n         }\n     }\n }"}, {"sha": "6339f8288d54e7f3c370b574099aeffc4e9451fd", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -271,7 +271,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n             constraints.dtorck_types.push(ty);\n         }\n \n-        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => {\n+        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => {\n             // By the time this code runs, all type variables ought to\n             // be fully resolved.\n             return Err(NoSolution);"}, {"sha": "cf70a845af0aa54c3c83795e3b810d6d96eb7844", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -20,7 +20,7 @@ fn sized_constraint_for_ty<'tcx>(\n         Bool | Char | Int(..) | Uint(..) | Float(..) | RawPtr(..) | Ref(..) | FnDef(..)\n         | FnPtr(_) | Array(..) | Closure(..) | Generator(..) | Never => vec![],\n \n-        Str | Dynamic(..) | Slice(_) | Foreign(..) | Error | GeneratorWitness(..) => {\n+        Str | Dynamic(..) | Slice(_) | Foreign(..) | Error(_) | GeneratorWitness(..) => {\n             // these are never sized - return the target type\n             vec![ty]\n         }"}, {"sha": "7cdcb2face8232f97a4ba43dc3caed1d084b128d", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -819,7 +819,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n                     if let (hir::TyKind::Infer, false) = (&ty.kind, self.allow_ty_infer()) {\n                         inferred_params.push(ty.span);\n-                        tcx.types.err.into()\n+                        tcx.ty_error().into()\n                     } else {\n                         self.ast_ty_to_ty(&ty).into()\n                     }\n@@ -845,7 +845,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             // careful!\n                             if default_needs_object_self(param) {\n                                 missing_type_params.push(param.name.to_string());\n-                                tcx.types.err.into()\n+                                tcx.ty_error().into()\n                             } else {\n                                 // This is a default type parameter.\n                                 self.normalize_ty(\n@@ -865,7 +865,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             self.ty_infer(param, span).into()\n                         } else {\n                             // We've already errored above about the mismatch.\n-                            tcx.types.err.into()\n+                            tcx.ty_error().into()\n                         }\n                     }\n                     GenericParamDefKind::Const => {\n@@ -876,7 +876,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             self.ct_infer(ty, Some(param), span).into()\n                         } else {\n                             // We've already errored above about the mismatch.\n-                            tcx.mk_const(ty::Const { val: ty::ConstKind::Error, ty }).into()\n+                            tcx.const_error(ty).into()\n                         }\n                     }\n                 }\n@@ -1607,7 +1607,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 \"at least one trait is required for an object type\"\n             )\n             .emit();\n-            return tcx.types.err;\n+            return tcx.ty_error();\n         }\n \n         // Check that there are no gross object safety violations;\n@@ -1624,7 +1624,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     &object_safety_violations[..],\n                 )\n                 .emit();\n-                return tcx.types.err;\n+                return tcx.ty_error();\n             }\n         }\n \n@@ -2434,7 +2434,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 &path_str,\n                 item_segment.ident.name,\n             );\n-            return tcx.types.err;\n+            return tcx.ty_error();\n         };\n \n         debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n@@ -2792,7 +2792,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::Err => {\n                 self.set_tainted_by_errors();\n-                self.tcx().types.err\n+                self.tcx().ty_error()\n             }\n             _ => span_bug!(span, \"unexpected resolution: {:?}\", path.res),\n         }\n@@ -2860,7 +2860,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 };\n                 self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, res, segment, false)\n                     .map(|(ty, _, _)| ty)\n-                    .unwrap_or(tcx.types.err)\n+                    .unwrap_or_else(|_| tcx.ty_error())\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length_def_id = tcx.hir().local_def_id(length.hir_id);\n@@ -2878,7 +2878,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .span_label(ast_ty.span, \"reserved keyword\")\n                 .emit();\n \n-                tcx.types.err\n+                tcx.ty_error()\n             }\n             hir::TyKind::Infer => {\n                 // Infer also appears as the type of arguments or return\n@@ -2887,7 +2887,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(None, ast_ty.span)\n             }\n-            hir::TyKind::Err => tcx.types.err,\n+            hir::TyKind::Err => tcx.ty_error(),\n         };\n \n         debug!(\"ast_ty_to_ty: result_ty={:?}\", result_ty);"}, {"sha": "9e23f5df3c6a8a367d9fc5821979f40ec464be49", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 && i != 0\n                 && self.if_fallback_coercion(expr.span, &arms[0].body, &mut coercion)\n             {\n-                tcx.types.err\n+                tcx.ty_error()\n             } else {\n                 // Only call this if this is not an `if` expr with an expected type and no `else`\n                 // clause to avoid duplicated type errors. (#60254)"}, {"sha": "2570025959cb4f7320010f63837a7444209bd402", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,5 +1,5 @@\n use super::method::MethodCallee;\n-use super::{FnCtxt, Needs, PlaceOp};\n+use super::{FnCtxt, PlaceOp};\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -170,14 +170,13 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>, needs: Needs) -> Vec<Adjustment<'tcx>> {\n-        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx, needs))\n+    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>) -> Vec<Adjustment<'tcx>> {\n+        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx))\n     }\n \n     pub fn adjust_steps_as_infer_ok(\n         &self,\n         fcx: &FnCtxt<'a, 'tcx>,\n-        needs: Needs,\n     ) -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n         let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty).chain(iter::once(self.cur_ty));\n@@ -186,7 +185,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n             .iter()\n             .map(|&(source, kind)| {\n                 if let AutoderefKind::Overloaded = kind {\n-                    fcx.try_overloaded_deref(self.span, source, needs).and_then(\n+                    fcx.try_overloaded_deref(self.span, source).and_then(\n                         |InferOk { value: method, obligations: o }| {\n                             obligations.extend(o);\n                             if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n@@ -266,8 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         base_ty: Ty<'tcx>,\n-        needs: Needs,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        self.try_overloaded_place_op(span, base_ty, &[], needs, PlaceOp::Deref)\n+        self.try_overloaded_place_op(span, base_ty, &[], PlaceOp::Deref)\n     }\n }"}, {"sha": "fe200a0ad2a1c09423999f77a1daa5a7a7aabe24", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,6 +1,6 @@\n use super::autoderef::Autoderef;\n use super::method::MethodCallee;\n-use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n+use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n use crate::type_error_struct;\n \n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.kind {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n-                let adjustments = autoderef.adjust_steps(self, Needs::None);\n+                let adjustments = autoderef.adjust_steps(self);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             &closure_sig,\n                         )\n                         .0;\n-                    let adjustments = autoderef.adjust_steps(self, Needs::None);\n+                    let adjustments = autoderef.adjust_steps(self);\n                     self.record_deferred_call_resolution(\n                         def_id,\n                         DeferredCallResolution {\n@@ -176,7 +176,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.try_overloaded_call_traits(call_expr, adjusted_ty, Some(arg_exprs))\n             .or_else(|| self.try_overloaded_call_traits(call_expr, adjusted_ty, None))\n             .map(|(autoref, method)| {\n-                let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n+                let mut adjustments = autoderef.adjust_steps(self);\n                 adjustments.extend(autoref);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 CallStep::Overloaded(method)\n@@ -220,21 +220,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let method = self.register_infer_ok_obligations(ok);\n                 let mut autoref = None;\n                 if borrow {\n-                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n-                        let mutbl = match mutbl {\n-                            hir::Mutability::Not => AutoBorrowMutability::Not,\n-                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                // For initial two-phase borrow\n-                                // deployment, conservatively omit\n-                                // overloaded function call ops.\n-                                allow_two_phase_borrow: AllowTwoPhase::No,\n-                            },\n-                        };\n-                        autoref = Some(Adjustment {\n-                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                            target: method.sig.inputs()[0],\n-                        });\n-                    }\n+                    // Check for &self vs &mut self in the method signature. Since this is either\n+                    // the Fn or FnMut trait, it should be one of those.\n+                    let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].kind\n+                    {\n+                        (r, mutbl)\n+                    } else {\n+                        span_bug!(call_expr.span, \"input to call/call_mut is not a ref?\");\n+                    };\n+\n+                    let mutbl = match mutbl {\n+                        hir::Mutability::Not => AutoBorrowMutability::Not,\n+                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n+                            // For initial two-phase borrow\n+                            // deployment, conservatively omit\n+                            // overloaded function call ops.\n+                            allow_two_phase_borrow: AllowTwoPhase::No,\n+                        },\n+                    };\n+                    autoref = Some(Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                        target: method.sig.inputs()[0],\n+                    });\n                 }\n                 return Some((autoref, method));\n             }\n@@ -383,7 +390,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (\n                     ty::Binder::bind(self.tcx.mk_fn_sig(\n                         self.err_args(arg_exprs.len()).into_iter(),\n-                        self.tcx.types.err,\n+                        self.tcx.ty_error(),\n                         false,\n                         hir::Unsafety::Normal,\n                         abi::Abi::Rust,"}, {"sha": "1ea7bf25ef2ed67436f99a84f428ef3c200efe8a", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 116, "deletions": 23, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -43,6 +43,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc_session::lint;\n use rustc_session::Session;\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::report_object_safety_error;\n@@ -135,7 +136,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             | ty::Generator(..)\n             | ty::Adt(..)\n             | ty::Never\n-            | ty::Error => {\n+            | ty::Error(_) => {\n                 self.tcx\n                     .sess\n                     .delay_span_bug(span, &format!(\"`{:?}` should be sized but is not?\", t));\n@@ -333,23 +334,87 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     \"only `u8` can be cast as `char`, not `{}`\",\n                     self.expr_ty\n                 )\n+                .span_label(self.span, \"invalid cast\")\n                 .emit();\n             }\n             CastError::NonScalar => {\n-                type_error_struct!(\n+                let mut err = type_error_struct!(\n                     fcx.tcx.sess,\n                     self.span,\n                     self.expr_ty,\n                     E0605,\n                     \"non-primitive cast: `{}` as `{}`\",\n                     self.expr_ty,\n                     fcx.ty_to_string(self.cast_ty)\n-                )\n-                .note(\n-                    \"an `as` expression can only be used to convert between \\\n-                                         primitive types. Consider using the `From` trait\",\n-                )\n-                .emit();\n+                );\n+                let mut sugg = None;\n+                if let ty::Ref(reg, _, mutbl) = self.cast_ty.kind {\n+                    if fcx\n+                        .try_coerce(\n+                            self.expr,\n+                            fcx.tcx.mk_ref(reg, TypeAndMut { ty: self.expr_ty, mutbl }),\n+                            self.cast_ty,\n+                            AllowTwoPhase::No,\n+                        )\n+                        .is_ok()\n+                    {\n+                        sugg = Some(format!(\"&{}\", mutbl.prefix_str()));\n+                    }\n+                }\n+                if let Some(sugg) = sugg {\n+                    err.span_label(self.span, \"invalid cast\");\n+                    err.span_suggestion_verbose(\n+                        self.expr.span.shrink_to_lo(),\n+                        \"borrow the value for the cast to be valid\",\n+                        sugg,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if !matches!(\n+                    self.cast_ty.kind,\n+                    ty::FnDef(..) | ty::FnPtr(..) | ty::Closure(..)\n+                ) {\n+                    let mut label = true;\n+                    // Check `impl From<self.expr_ty> for self.cast_ty {}` for accurate suggestion:\n+                    if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr.span) {\n+                        if let Some(from_trait) = fcx.tcx.get_diagnostic_item(sym::from_trait) {\n+                            let ty = fcx.resolve_vars_if_possible(&self.cast_ty);\n+                            // Erase regions to avoid panic in `prove_value` when calling\n+                            // `type_implements_trait`.\n+                            let ty = fcx.tcx.erase_regions(&ty);\n+                            let expr_ty = fcx.resolve_vars_if_possible(&self.expr_ty);\n+                            let expr_ty = fcx.tcx.erase_regions(&expr_ty);\n+                            let ty_params = fcx.tcx.mk_substs_trait(expr_ty, &[]);\n+                            // Check for infer types because cases like `Option<{integer}>` would\n+                            // panic otherwise.\n+                            if !expr_ty.has_infer_types()\n+                                && fcx.tcx.type_implements_trait((\n+                                    from_trait,\n+                                    ty,\n+                                    ty_params,\n+                                    fcx.param_env,\n+                                ))\n+                            {\n+                                label = false;\n+                                err.span_suggestion(\n+                                    self.span,\n+                                    \"consider using the `From` trait instead\",\n+                                    format!(\"{}::from({})\", self.cast_ty, snippet),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                        }\n+                    }\n+                    let msg = \"an `as` expression can only be used to convert between primitive \\\n+                               types or to coerce to a specific trait object\";\n+                    if label {\n+                        err.span_label(self.span, msg);\n+                    } else {\n+                        err.note(msg);\n+                    }\n+                } else {\n+                    err.span_label(self.span, \"invalid cast\");\n+                }\n+                err.emit();\n             }\n             CastError::SizedUnsizedCast => {\n                 use crate::structured_errors::{SizedUnsizedCastError, StructuredDiagnostic};\n@@ -370,21 +435,22 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 };\n                 let mut err = struct_span_err!(\n                     fcx.tcx.sess,\n-                    self.span,\n+                    if unknown_cast_to { self.cast_span } else { self.span },\n                     E0641,\n                     \"cannot cast {} a pointer of an unknown kind\",\n                     if unknown_cast_to { \"to\" } else { \"from\" }\n                 );\n-                err.note(\n-                    \"the type information given here is insufficient to check whether \\\n-                          the pointer cast is valid\",\n-                );\n                 if unknown_cast_to {\n-                    err.span_suggestion_short(\n-                        self.cast_span,\n-                        \"consider giving more type information\",\n-                        String::new(),\n-                        Applicability::Unspecified,\n+                    err.span_label(self.cast_span, \"needs more type information\");\n+                    err.note(\n+                        \"the type information given here is insufficient to check whether \\\n+                        the pointer cast is valid\",\n+                    );\n+                } else {\n+                    err.span_label(\n+                        self.span,\n+                        \"the type information given here is insufficient to check whether \\\n+                        the pointer cast is valid\",\n                     );\n                 }\n                 err.emit();\n@@ -438,13 +504,16 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     Ok(s) => {\n                         err.span_suggestion(\n                             self.cast_span,\n-                            \"try casting to a `Box` instead\",\n+                            \"you can cast to a `Box` instead\",\n                             format!(\"Box<{}>\", s),\n                             Applicability::MachineApplicable,\n                         );\n                     }\n                     Err(_) => {\n-                        err.span_help(self.cast_span, &format!(\"did you mean `Box<{}>`?\", tstr));\n+                        err.span_help(\n+                            self.cast_span,\n+                            &format!(\"you might have meant `Box<{}>`\", tstr),\n+                        );\n                     }\n                 }\n             }\n@@ -609,7 +678,10 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             (FnPtr, Ptr(mt)) => self.check_fptr_ptr_cast(fcx, mt),\n \n             // prim -> prim\n-            (Int(CEnum), Int(_)) => Ok(CastKind::EnumCast),\n+            (Int(CEnum), Int(_)) => {\n+                self.cenum_impl_drop_lint(fcx);\n+                Ok(CastKind::EnumCast)\n+            }\n             (Int(Char) | Int(Bool), Int(_)) => Ok(CastKind::PrimIntCast),\n \n             (Int(_) | Float, Int(_) | Float) => Ok(CastKind::NumericCast),\n@@ -706,11 +778,13 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 // Coerce to a raw pointer so that we generate AddressOf in MIR.\n                 let array_ptr_type = fcx.tcx.mk_ptr(m_expr);\n                 fcx.try_coerce(self.expr, self.expr_ty, array_ptr_type, AllowTwoPhase::No)\n-                    .unwrap_or_else(|_| bug!(\n+                    .unwrap_or_else(|_| {\n+                        bug!(\n                         \"could not cast from reference to array to pointer to array ({:?} to {:?})\",\n                         self.expr_ty,\n                         array_ptr_type,\n-                    ));\n+                    )\n+                    });\n \n                 // this will report a type mismatch if needed\n                 fcx.demand_eqtype(self.span, ety, m_cast.ty);\n@@ -740,6 +814,25 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             Err(err) => Err(err),\n         }\n     }\n+\n+    fn cenum_impl_drop_lint(&self, fcx: &FnCtxt<'a, 'tcx>) {\n+        if let ty::Adt(d, _) = self.expr_ty.kind {\n+            if d.has_dtor(fcx.tcx) {\n+                fcx.tcx.struct_span_lint_hir(\n+                    lint::builtin::CENUM_IMPL_DROP_CAST,\n+                    self.expr.hir_id,\n+                    self.span,\n+                    |err| {\n+                        err.build(&format!(\n+                            \"cannot cast enum `{}` into integer `{}` because it implements `Drop`\",\n+                            self.expr_ty, self.cast_ty\n+                        ))\n+                        .emit();\n+                    },\n+                );\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {"}, {"sha": "6d09ddc925ffe1f22ec44e5cf5f10326a4899cee", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -700,7 +700,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let supplied_arguments = decl.inputs.iter().map(|a| {\n             // Convert the types that the user supplied (if any), but ignore them.\n             astconv.ast_ty_to_ty(a);\n-            self.tcx.types.err\n+            self.tcx.ty_error()\n         });\n \n         if let hir::FnRetTy::Return(ref output) = decl.output {\n@@ -709,7 +709,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let result = ty::Binder::bind(self.tcx.mk_fn_sig(\n             supplied_arguments,\n-            self.tcx.types.err,\n+            self.tcx.ty_error(),\n             decl.c_variadic,\n             hir::Unsafety::Normal,\n             Abi::RustCall,"}, {"sha": "1c34d71ee31847dcdb7cff52e53c319aac472ce4", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -51,7 +51,7 @@\n //! we may want to adjust precisely when coercions occur.\n \n use crate::astconv::AstConv;\n-use crate::check::{FnCtxt, Needs};\n+use crate::check::FnCtxt;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -162,7 +162,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n-            return success(vec![], self.fcx.tcx.types.err, vec![]);\n+            return success(vec![], self.fcx.tcx.ty_error(), vec![]);\n         }\n \n         if a.is_never() {\n@@ -421,9 +421,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             return success(vec![], ty, obligations);\n         }\n \n-        let needs = Needs::maybe_mut_place(mutbl_b);\n         let InferOk { value: mut adjustments, obligations: o } =\n-            autoderef.adjust_steps_as_infer_ok(self, needs);\n+            autoderef.adjust_steps_as_infer_ok(self);\n         obligations.extend(o);\n         obligations.extend(autoderef.into_obligations());\n \n@@ -864,7 +863,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (adjustments, _) = self.register_infer_ok_obligations(ok);\n         self.apply_adjustments(expr, adjustments);\n-        Ok(if expr_ty.references_error() { self.tcx.types.err } else { target })\n+        Ok(if expr_ty.references_error() { self.tcx.ty_error() } else { target })\n     }\n \n     /// Same as `try_coerce()`, but without side-effects.\n@@ -1239,7 +1238,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         // If we see any error types, just propagate that error\n         // upwards.\n         if expression_ty.references_error() || self.merged_ty().references_error() {\n-            self.final_ty = Some(fcx.tcx.types.err);\n+            self.final_ty = Some(fcx.tcx.ty_error());\n             return;\n         }\n \n@@ -1396,7 +1395,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n                 err.emit_unless(assign_to_bool || unsized_return);\n \n-                self.final_ty = Some(fcx.tcx.types.err);\n+                self.final_ty = Some(fcx.tcx.ty_error());\n             }\n         }\n     }"}, {"sha": "188f4a9401422fe65dff2048295808f09219a2f4", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 56, "deletions": 83, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -29,9 +29,7 @@ use rustc_hir::{ExprKind, QPath};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty;\n-use rustc_middle::ty::adjustment::{\n-    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n-};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{AdtKind, Visibility};\n@@ -113,12 +111,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.check_expr_with_expectation(expr, ExpectHasType(expected))\n     }\n \n-    pub(super) fn check_expr_with_expectation(\n+    fn check_expr_with_expectation_and_needs(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n+        needs: Needs,\n     ) -> Ty<'tcx> {\n-        self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n+        let ty = self.check_expr_with_expectation(expr, expected);\n+\n+        // If the expression is used in a place whether mutable place is required\n+        // e.g. LHS of assignment, perform the conversion.\n+        if let Needs::MutPlace = needs {\n+            self.convert_place_derefs_to_mutable(expr);\n+        }\n+\n+        ty\n     }\n \n     pub(super) fn check_expr(&self, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n@@ -143,11 +150,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Note that inspecting a type's structure *directly* may expose the fact\n     /// that there are actually multiple representations for `Error`, so avoid\n     /// that when err needs to be handled differently.\n-    fn check_expr_with_expectation_and_needs(\n+    pub(super) fn check_expr_with_expectation(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n     ) -> Ty<'tcx> {\n         debug!(\">> type-checking: expr={:?} expected={:?}\", expr, expected);\n \n@@ -171,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let old_diverges = self.diverges.replace(Diverges::Maybe);\n         let old_has_errors = self.has_errors.replace(false);\n \n-        let ty = self.check_expr_kind(expr, expected, needs);\n+        let ty = self.check_expr_kind(expr, expected);\n \n         // Warn for non-block expressions with diverging children.\n         match expr.kind {\n@@ -213,9 +219,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n     ) -> Ty<'tcx> {\n-        debug!(\"check_expr_kind(expr={:?}, expected={:?}, needs={:?})\", expr, expected, needs,);\n+        debug!(\"check_expr_kind(expr={:?}, expected={:?})\", expr, expected);\n \n         let tcx = self.tcx;\n         match expr.kind {\n@@ -226,9 +231,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_assign(expr, expected, lhs, rhs, span)\n             }\n             ExprKind::AssignOp(op, ref lhs, ref rhs) => self.check_binop_assign(expr, op, lhs, rhs),\n-            ExprKind::Unary(unop, ref oprnd) => {\n-                self.check_expr_unary(unop, oprnd, expected, needs, expr)\n-            }\n+            ExprKind::Unary(unop, ref oprnd) => self.check_expr_unary(unop, oprnd, expected, expr),\n             ExprKind::AddrOf(kind, mutbl, ref oprnd) => {\n                 self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n@@ -248,7 +251,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     tcx.types.never\n                 } else {\n                     // There was an error; make type-check fail.\n-                    tcx.types.err\n+                    tcx.ty_error()\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n@@ -264,7 +267,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Block(ref body, _) => self.check_block_with_expected(&body, expected),\n             ExprKind::Call(ref callee, ref args) => self.check_call(expr, &callee, args, expected),\n             ExprKind::MethodCall(ref segment, span, ref args, _) => {\n-                self.check_method_call(expr, segment, span, args, expected, needs)\n+                self.check_method_call(expr, segment, span, args, expected)\n             }\n             ExprKind::Cast(ref e, ref t) => self.check_expr_cast(e, t, expr),\n             ExprKind::Type(ref e, ref t) => {\n@@ -281,10 +284,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Struct(ref qpath, fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            ExprKind::Field(ref base, field) => self.check_field(expr, needs, &base, field),\n-            ExprKind::Index(ref base, ref idx) => self.check_expr_index(base, idx, needs, expr),\n+            ExprKind::Field(ref base, field) => self.check_field(expr, &base, field),\n+            ExprKind::Index(ref base, ref idx) => self.check_expr_index(base, idx, expr),\n             ExprKind::Yield(ref value, ref src) => self.check_expr_yield(value, expr, src),\n-            hir::ExprKind::Err => tcx.types.err,\n+            hir::ExprKind::Err => tcx.ty_error(),\n         }\n     }\n \n@@ -302,48 +305,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         unop: hir::UnOp,\n         oprnd: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected_inner = match unop {\n             hir::UnOp::UnNot | hir::UnOp::UnNeg => expected,\n             hir::UnOp::UnDeref => NoExpectation,\n         };\n-        let needs = match unop {\n-            hir::UnOp::UnDeref => needs,\n-            _ => Needs::None,\n-        };\n-        let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd, expected_inner, needs);\n+        let mut oprnd_t = self.check_expr_with_expectation(&oprnd, expected_inner);\n \n         if !oprnd_t.references_error() {\n             oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n             match unop {\n                 hir::UnOp::UnDeref => {\n-                    if let Some(mt) = oprnd_t.builtin_deref(true) {\n-                        oprnd_t = mt.ty;\n-                    } else if let Some(ok) = self.try_overloaded_deref(expr.span, oprnd_t, needs) {\n-                        let method = self.register_infer_ok_obligations(ok);\n-                        if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n-                            let mutbl = match mutbl {\n-                                hir::Mutability::Not => AutoBorrowMutability::Not,\n-                                hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                    // (It shouldn't actually matter for unary ops whether\n-                                    // we enable two-phase borrows or not, since a unary\n-                                    // op has no additional operands.)\n-                                    allow_two_phase_borrow: AllowTwoPhase::No,\n-                                },\n-                            };\n-                            self.apply_adjustments(\n-                                oprnd,\n-                                vec![Adjustment {\n-                                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                                    target: method.sig.inputs()[0],\n-                                }],\n-                            );\n-                        }\n-                        oprnd_t = self.make_overloaded_place_return_type(method).ty;\n-                        self.write_method_call(expr.hir_id, method);\n+                    if let Some(ty) = self.lookup_derefing(expr, oprnd, oprnd_t) {\n+                        oprnd_t = ty;\n                     } else {\n                         let mut err = type_error_struct!(\n                             tcx.sess,\n@@ -360,7 +336,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             tcx.sess.parse_sess.expr_parentheses_needed(&mut err, *sp, None);\n                         }\n                         err.emit();\n-                        oprnd_t = tcx.types.err;\n+                        oprnd_t = tcx.ty_error();\n                     }\n                 }\n                 hir::UnOp::UnNot => {\n@@ -405,12 +381,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => NoExpectation,\n             }\n         });\n-        let needs = Needs::maybe_mut_place(mutbl);\n-        let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n+        let ty =\n+            self.check_expr_with_expectation_and_needs(&oprnd, hint, Needs::maybe_mut_place(mutbl));\n \n         let tm = ty::TypeAndMut { ty, mutbl };\n         match kind {\n-            _ if tm.ty.references_error() => self.tcx.types.err,\n+            _ if tm.ty.references_error() => self.tcx.ty_error(),\n             hir::BorrowKind::Raw => {\n                 self.check_named_place_expr(oprnd);\n                 self.tcx.mk_ptr(tm)\n@@ -476,11 +452,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = match res {\n             Res::Err => {\n                 self.set_tainted_by_errors();\n-                tcx.types.err\n+                tcx.ty_error()\n             }\n             Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n                 report_unexpected_variant_res(tcx, res, expr.span);\n-                tcx.types.err\n+                tcx.ty_error()\n             }\n             _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n         };\n@@ -560,19 +536,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Some(ctxt) => ctxt.coerce.as_ref().map(|coerce| coerce.expected_ty()),\n                         None => {\n                             // Avoid ICE when `break` is inside a closure (#65383).\n-                            self.tcx.sess.delay_span_bug(\n+                            return tcx.ty_error_with_message(\n                                 expr.span,\n                                 \"break was outside loop, but no error was emitted\",\n                             );\n-                            return tcx.types.err;\n                         }\n                     }\n                 };\n \n                 // If the loop context is not a `loop { }`, then break with\n                 // a value is illegal, and `opt_coerce_to` will be `None`.\n                 // Just set expectation to error in that case.\n-                let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n+                let coerce_to = opt_coerce_to.unwrap_or_else(|| tcx.ty_error());\n \n                 // Recurse without `enclosing_breakables` borrowed.\n                 e_ty = self.check_expr_with_hint(e, coerce_to);\n@@ -592,11 +567,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(ctxt) => ctxt,\n                 None => {\n                     // Avoid ICE when `break` is inside a closure (#65383).\n-                    self.tcx.sess.delay_span_bug(\n+                    return tcx.ty_error_with_message(\n                         expr.span,\n                         \"break was outside loop, but no error was emitted\",\n                     );\n-                    return tcx.types.err;\n                 }\n             };\n \n@@ -649,14 +623,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // this can only happen if the `break` was not\n             // inside a loop at all, which is caught by the\n             // loop-checking pass.\n-            self.tcx\n-                .sess\n-                .delay_span_bug(expr.span, \"break was outside loop, but no error was emitted\");\n+            let err = self.tcx.ty_error_with_message(\n+                expr.span,\n+                \"break was outside loop, but no error was emitted\",\n+            );\n \n             // We still need to assign a type to the inner expression to\n             // prevent the ICE in #43162.\n             if let Some(ref e) = expr_opt {\n-                self.check_expr_with_hint(e, tcx.types.err);\n+                self.check_expr_with_hint(e, err);\n \n                 // ... except when we try to 'break rust;'.\n                 // ICE this expression in particular (see #43162).\n@@ -666,8 +641,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n+\n             // There was an error; make type-check fail.\n-            tcx.types.err\n+            err\n         }\n     }\n \n@@ -803,7 +779,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n \n         if lhs_ty.references_error() || rhs_ty.references_error() {\n-            self.tcx.types.err\n+            self.tcx.ty_error()\n         } else {\n             self.tcx.mk_unit()\n         }\n@@ -861,10 +837,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n     ) -> Ty<'tcx> {\n         let rcvr = &args[0];\n-        let rcvr_t = self.check_expr_with_needs(&rcvr, needs);\n+        let rcvr_t = self.check_expr(&rcvr);\n         // no need to check for bot/err -- callee does that\n         let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n \n@@ -957,7 +932,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Eagerly check for some obvious errors.\n         if t_expr.references_error() || t_cast.references_error() {\n-            self.tcx.types.err\n+            self.tcx.ty_error()\n         } else {\n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n@@ -966,7 +941,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     deferred_cast_checks.push(cast_check);\n                     t_cast\n                 }\n-                Err(ErrorReported) => self.tcx.types.err,\n+                Err(ErrorReported) => self.tcx.ty_error(),\n             }\n         }\n     }\n@@ -1041,7 +1016,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         if element_ty.references_error() {\n-            return tcx.types.err;\n+            return tcx.ty_error();\n         }\n \n         tcx.mk_ty(ty::Array(t, count))\n@@ -1071,7 +1046,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         });\n         let tuple = self.tcx.mk_tup(elt_ts_iter);\n         if tuple.references_error() {\n-            self.tcx.types.err\n+            self.tcx.ty_error()\n         } else {\n             self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n             tuple\n@@ -1092,7 +1067,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             variant_ty\n         } else {\n             self.check_struct_fields_on_error(fields, base_expr);\n-            return self.tcx.types.err;\n+            return self.tcx.ty_error();\n         };\n \n         let path_span = match *qpath {\n@@ -1233,7 +1208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name, span);\n                 }\n \n-                tcx.types.err\n+                tcx.ty_error()\n             };\n \n             // Make sure to give a type to the field even if there's\n@@ -1443,11 +1418,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_field(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n-        needs: Needs,\n         base: &'tcx hir::Expr<'tcx>,\n         field: Ident,\n     ) -> Ty<'tcx> {\n-        let expr_t = self.check_expr_with_needs(base, needs);\n+        let expr_t = self.check_expr(base);\n         let expr_t = self.structurally_resolved_type(base.span, expr_t);\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n@@ -1467,7 +1441,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // of error recovery.\n                         self.write_field_index(expr.hir_id, index);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(self, needs);\n+                            let adjustments = autoderef.adjust_steps(self);\n                             self.apply_adjustments(base, adjustments);\n                             autoderef.finalize(self);\n \n@@ -1482,7 +1456,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n                             if let Some(field_ty) = tys.get(index) {\n-                                let adjustments = autoderef.adjust_steps(self, needs);\n+                                let adjustments = autoderef.adjust_steps(self);\n                                 self.apply_adjustments(base, adjustments);\n                                 autoderef.finalize(self);\n \n@@ -1519,7 +1493,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .emit();\n         }\n \n-        self.tcx().types.err\n+        self.tcx().ty_error()\n     }\n \n     fn ban_nonexisting_field(\n@@ -1721,10 +1695,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         base: &'tcx hir::Expr<'tcx>,\n         idx: &'tcx hir::Expr<'tcx>,\n-        needs: Needs,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n-        let base_t = self.check_expr_with_needs(&base, needs);\n+        let base_t = self.check_expr(&base);\n         let idx_t = self.check_expr(&idx);\n \n         if base_t.references_error() {\n@@ -1733,7 +1706,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             idx_t\n         } else {\n             let base_t = self.structurally_resolved_type(base.span, base_t);\n-            match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n+            match self.lookup_indexing(expr, base, base_t, idx_t) {\n                 Some((index_ty, element_ty)) => {\n                     // two-phase not needed because index_ty is never mutable\n                     self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);\n@@ -1775,7 +1748,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     err.emit();\n-                    self.tcx.types.err\n+                    self.tcx.ty_error()\n                 }\n             }\n         }\n@@ -1887,7 +1860,7 @@ pub(super) fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n         ty::Char => \"'a'\",\n         ty::Int(_) | ty::Uint(_) => \"42\",\n         ty::Float(_) => \"3.14159\",\n-        ty::Error | ty::Never => return None,\n+        ty::Error(_) | ty::Never => return None,\n         _ => \"value\",\n     })\n }"}, {"sha": "3ec6973a17d567fb704eb158d5605ce28d682c00", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -347,6 +347,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 return;\n             }\n \n+            \"count_code_region\" => (0, vec![tcx.types.u32], tcx.mk_unit()),\n+\n             ref other => {\n                 struct_span_err!(\n                     tcx.sess,"}, {"sha": "6844c9416af8a7a1a6a9c5b37a14afe11cb1ef4a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 155, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,12 +1,12 @@\n use super::{probe, MethodCallee};\n \n use crate::astconv::AstConv;\n-use crate::check::{callee, FnCtxt, Needs, PlaceOp};\n+use crate::check::{callee, FnCtxt};\n use crate::hir::def_id::DefId;\n use crate::hir::GenericArg;\n use rustc_hir as hir;\n use rustc_infer::infer::{self, InferOk};\n-use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n@@ -119,11 +119,6 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n         // Create the final `MethodCallee`.\n         let callee = MethodCallee { def_id: pick.item.def_id, substs: all_substs, sig: method_sig };\n-\n-        if let Some(hir::Mutability::Mut) = pick.autoref {\n-            self.convert_place_derefs_to_mutable();\n-        }\n-\n         ConfirmResult { callee, illegal_sized_bound }\n     }\n \n@@ -141,16 +136,15 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         let (_, n) = match autoderef.nth(pick.autoderefs) {\n             Some(n) => n,\n             None => {\n-                self.tcx.sess.delay_span_bug(\n+                return self.tcx.ty_error_with_message(\n                     rustc_span::DUMMY_SP,\n                     &format!(\"failed autoderef {}\", pick.autoderefs),\n                 );\n-                return self.tcx.types.err;\n             }\n         };\n         assert_eq!(n, pick.autoderefs);\n \n-        let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n+        let mut adjustments = autoderef.adjust_steps(self);\n \n         let mut target = autoderef.unambiguous_final_ty(self);\n \n@@ -416,151 +410,6 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         self.register_wf_obligation(fty.into(), self.span, traits::MiscObligation);\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // RECONCILIATION\n-\n-    /// When we select a method with a mutable autoref, we have to go convert any\n-    /// auto-derefs, indices, etc from `Deref` and `Index` into `DerefMut` and `IndexMut`\n-    /// respectively.\n-    fn convert_place_derefs_to_mutable(&self) {\n-        // Gather up expressions we want to munge.\n-        let mut exprs = vec![self.self_expr];\n-\n-        loop {\n-            match exprs.last().unwrap().kind {\n-                hir::ExprKind::Field(ref expr, _)\n-                | hir::ExprKind::Index(ref expr, _)\n-                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) => exprs.push(&expr),\n-                _ => break,\n-            }\n-        }\n-\n-        debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n-\n-        // Fix up autoderefs and derefs.\n-        for (i, &expr) in exprs.iter().rev().enumerate() {\n-            debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n-\n-            // Fix up the autoderefs. Autorefs can only occur immediately preceding\n-            // overloaded place ops, and will be fixed by them in order to get\n-            // the correct region.\n-            let mut source = self.node_ty(expr.hir_id);\n-            // Do not mutate adjustments in place, but rather take them,\n-            // and replace them after mutating them, to avoid having the\n-            // tables borrowed during (`deref_mut`) method resolution.\n-            let previous_adjustments =\n-                self.tables.borrow_mut().adjustments_mut().remove(expr.hir_id);\n-            if let Some(mut adjustments) = previous_adjustments {\n-                let needs = Needs::MutPlace;\n-                for adjustment in &mut adjustments {\n-                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n-                        if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n-                            let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n-                                *deref = OverloadedDeref { region, mutbl };\n-                            }\n-                        }\n-                    }\n-                    source = adjustment.target;\n-                }\n-                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n-            }\n-\n-            match expr.kind {\n-                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n-                    // We need to get the final type in case dereferences were needed for the trait\n-                    // to apply (#72002).\n-                    let index_expr_ty = self.tables.borrow().expr_ty_adjusted(index_expr);\n-                    self.convert_place_op_to_mutable(\n-                        PlaceOp::Index,\n-                        expr,\n-                        base_expr,\n-                        &[index_expr_ty],\n-                    );\n-                }\n-                hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base_expr) => {\n-                    self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr, &[]);\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    fn convert_place_op_to_mutable(\n-        &self,\n-        op: PlaceOp,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &hir::Expr<'_>,\n-        arg_tys: &[Ty<'tcx>],\n-    ) {\n-        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);\n-        if !self.tables.borrow().is_method_call(expr) {\n-            debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n-            return;\n-        }\n-\n-        let base_ty = self\n-            .tables\n-            .borrow()\n-            .expr_adjustments(base_expr)\n-            .last()\n-            .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n-        let base_ty = self.resolve_vars_if_possible(&base_ty);\n-\n-        // Need to deref because overloaded place ops take self by-reference.\n-        let base_ty =\n-            base_ty.builtin_deref(false).expect(\"place op takes something that is not a ref\").ty;\n-\n-        let method = self.try_overloaded_place_op(expr.span, base_ty, arg_tys, Needs::MutPlace, op);\n-        let method = match method {\n-            Some(ok) => self.register_infer_ok_obligations(ok),\n-            None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\"),\n-        };\n-        debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n-        self.write_method_call(expr.hir_id, method);\n-\n-        let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].kind {\n-            (r, mutbl)\n-        } else {\n-            span_bug!(expr.span, \"input to place op is not a ref?\");\n-        };\n-\n-        // Convert the autoref in the base expr to mutable with the correct\n-        // region and mutability.\n-        let base_expr_ty = self.node_ty(base_expr.hir_id);\n-        if let Some(adjustments) =\n-            self.tables.borrow_mut().adjustments_mut().get_mut(base_expr.hir_id)\n-        {\n-            let mut source = base_expr_ty;\n-            for adjustment in &mut adjustments[..] {\n-                if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n-                    debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n-                    let mutbl = match mutbl {\n-                        hir::Mutability::Not => AutoBorrowMutability::Not,\n-                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                            // For initial two-phase borrow\n-                            // deployment, conservatively omit\n-                            // overloaded operators.\n-                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                        },\n-                    };\n-                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n-                    adjustment.target =\n-                        self.tcx.mk_ref(region, ty::TypeAndMut { ty: source, mutbl: mutbl.into() });\n-                }\n-                source = adjustment.target;\n-            }\n-\n-            // If we have an autoref followed by unsizing at the end, fix the unsize target.\n-\n-            if let [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. }, Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), ref mut target }] =\n-                adjustments[..]\n-            {\n-                *target = method.sig.inputs()[0];\n-            }\n-        }\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n "}, {"sha": "93bcd5cf29149d0138259f2b924fbb7365b90d33", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -400,7 +400,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .probe_instantiate_query_response(span, &orig_values, ty)\n                     .unwrap_or_else(|_| span_bug!(span, \"instantiating {:?} failed?\", ty));\n                 let ty = self.structurally_resolved_type(span, ty.value);\n-                assert_eq!(ty, self.tcx.types.err);\n+                assert!(matches!(ty.kind, ty::Error(_)));\n                 return Err(MethodError::NoMatch(NoMatchData::new(\n                     Vec::new(),\n                     Vec::new(),\n@@ -478,7 +478,7 @@ fn method_autoderef_steps<'tcx>(\n \n         let final_ty = autoderef.maybe_ambiguous_final_ty();\n         let opt_bad_ty = match final_ty.kind {\n-            ty::Infer(ty::TyVar(_)) | ty::Error => Some(MethodAutoderefBadTy {\n+            ty::Infer(ty::TyVar(_)) | ty::Error(_) => Some(MethodAutoderefBadTy {\n                 reached_raw_pointer,\n                 ty: infcx\n                     .make_query_response_ignoring_pending_obligations(inference_vars, final_ty),"}, {"sha": "2ece8e8c2842369a8c7fe0ea88413700eab89560", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 203, "deletions": 178, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -79,6 +79,7 @@ pub mod intrinsic;\n pub mod method;\n mod op;\n mod pat;\n+mod place_op;\n mod regionck;\n mod upvar;\n mod wfcheck;\n@@ -114,7 +115,7 @@ use rustc_infer::infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin,\n use rustc_middle::hir::map::blocks::FnLikeNode;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::adjustment::{\n-    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n+    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::query::Providers;\n@@ -138,6 +139,7 @@ use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::opaque_types::{InferCtxtExt as _, OpaqueTypeDecl};\n use rustc_trait_selection::traits::error_reporting::recursive_type_with_infinite_size_error;\n+use rustc_trait_selection::traits::error_reporting::suggestions::ReturnsVisitor;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n@@ -155,7 +157,6 @@ use std::slice;\n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n \n-use self::autoderef::Autoderef;\n use self::callee::DeferredCallResolution;\n use self::coercion::{CoerceMany, DynamicCoerceMany};\n use self::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n@@ -967,8 +968,7 @@ fn diagnostic_only_typeck_tables_of<'tcx>(\n ) -> &ty::TypeckTables<'tcx> {\n     let fallback = move || {\n         let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id));\n-        tcx.sess.delay_span_bug(span, \"diagnostic only typeck table used\");\n-        tcx.types.err\n+        tcx.ty_error_with_message(span, \"diagnostic only typeck table used\")\n     };\n     typeck_tables_of_with_fallback(tcx, def_id, fallback)\n }\n@@ -1711,6 +1711,173 @@ fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: LocalDefId,\n     }\n }\n \n+/// Given a `DefId` for an opaque type in return position, find its parent item's return\n+/// expressions.\n+fn get_owner_return_paths(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+) -> Option<(hir::HirId, ReturnsVisitor<'tcx>)> {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let id = tcx.hir().get_parent_item(hir_id);\n+    tcx.hir()\n+        .find(id)\n+        .map(|n| (id, n))\n+        .and_then(|(hir_id, node)| node.body_id().map(|b| (hir_id, b)))\n+        .map(|(hir_id, body_id)| {\n+            let body = tcx.hir().body(body_id);\n+            let mut visitor = ReturnsVisitor::default();\n+            visitor.visit_body(body);\n+            (hir_id, visitor)\n+        })\n+}\n+\n+/// Emit an error for recursive opaque types.\n+///\n+/// If this is a return `impl Trait`, find the item's return expressions and point at them. For\n+/// direct recursion this is enough, but for indirect recursion also point at the last intermediary\n+/// `impl Trait`.\n+///\n+/// If all the return expressions evaluate to `!`, then we explain that the error will go away\n+/// after changing it. This can happen when a user uses `panic!()` or similar as a placeholder.\n+fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n+    let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n+\n+    let mut label = false;\n+    if let Some((hir_id, visitor)) = get_owner_return_paths(tcx, def_id) {\n+        let tables = tcx.typeck_tables_of(tcx.hir().local_def_id(hir_id));\n+        if visitor\n+            .returns\n+            .iter()\n+            .filter_map(|expr| tables.node_type_opt(expr.hir_id))\n+            .all(|ty| matches!(ty.kind, ty::Never))\n+        {\n+            let spans = visitor\n+                .returns\n+                .iter()\n+                .filter(|expr| tables.node_type_opt(expr.hir_id).is_some())\n+                .map(|expr| expr.span)\n+                .collect::<Vec<Span>>();\n+            let span_len = spans.len();\n+            if span_len == 1 {\n+                err.span_label(spans[0], \"this returned value is of `!` type\");\n+            } else {\n+                let mut multispan: MultiSpan = spans.clone().into();\n+                for span in spans {\n+                    multispan\n+                        .push_span_label(span, \"this returned value is of `!` type\".to_string());\n+                }\n+                err.span_note(multispan, \"these returned values have a concrete \\\"never\\\" type\");\n+            }\n+            err.help(\"this error will resolve once the item's body returns a concrete type\");\n+        } else {\n+            let mut seen = FxHashSet::default();\n+            seen.insert(span);\n+            err.span_label(span, \"recursive opaque type\");\n+            label = true;\n+            for (sp, ty) in visitor\n+                .returns\n+                .iter()\n+                .filter_map(|e| tables.node_type_opt(e.hir_id).map(|t| (e.span, t)))\n+                .filter(|(_, ty)| !matches!(ty.kind, ty::Never))\n+            {\n+                struct VisitTypes(Vec<DefId>);\n+                impl<'tcx> ty::fold::TypeVisitor<'tcx> for VisitTypes {\n+                    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                        match t.kind {\n+                            ty::Opaque(def, _) => {\n+                                self.0.push(def);\n+                                false\n+                            }\n+                            _ => t.super_visit_with(self),\n+                        }\n+                    }\n+                }\n+                let mut visitor = VisitTypes(vec![]);\n+                ty.visit_with(&mut visitor);\n+                for def_id in visitor.0 {\n+                    let ty_span = tcx.def_span(def_id);\n+                    if !seen.contains(&ty_span) {\n+                        err.span_label(ty_span, &format!(\"returning this opaque type `{}`\", ty));\n+                        seen.insert(ty_span);\n+                    }\n+                    err.span_label(sp, &format!(\"returning here with type `{}`\", ty));\n+                }\n+            }\n+        }\n+    }\n+    if !label {\n+        err.span_label(span, \"cannot resolve opaque type\");\n+    }\n+    err.emit();\n+}\n+\n+/// Emit an error for recursive opaque types in a `let` binding.\n+fn binding_opaque_type_cycle_error(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+    span: Span,\n+    partially_expanded_type: Ty<'tcx>,\n+) {\n+    let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n+    err.span_label(span, \"cannot resolve opaque type\");\n+    // Find the the owner that declared this `impl Trait` type.\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let mut prev_hir_id = hir_id;\n+    let mut hir_id = tcx.hir().get_parent_node(hir_id);\n+    while let Some(node) = tcx.hir().find(hir_id) {\n+        match node {\n+            hir::Node::Local(hir::Local {\n+                pat,\n+                init: None,\n+                ty: Some(ty),\n+                source: hir::LocalSource::Normal,\n+                ..\n+            }) => {\n+                err.span_label(pat.span, \"this binding might not have a concrete type\");\n+                err.span_suggestion_verbose(\n+                    ty.span.shrink_to_hi(),\n+                    \"set the binding to a value for a concrete type to be resolved\",\n+                    \" = /* value */\".to_string(),\n+                    Applicability::HasPlaceholders,\n+                );\n+            }\n+            hir::Node::Local(hir::Local {\n+                init: Some(expr),\n+                source: hir::LocalSource::Normal,\n+                ..\n+            }) => {\n+                let hir_id = tcx.hir().as_local_hir_id(def_id);\n+                let tables =\n+                    tcx.typeck_tables_of(tcx.hir().local_def_id(tcx.hir().get_parent_item(hir_id)));\n+                if let Some(ty) = tables.node_type_opt(expr.hir_id) {\n+                    err.span_label(\n+                        expr.span,\n+                        &format!(\n+                            \"this is of type `{}`, which doesn't constrain \\\n+                             `{}` enough to arrive to a concrete type\",\n+                            ty, partially_expanded_type\n+                        ),\n+                    );\n+                }\n+            }\n+            _ => {}\n+        }\n+        if prev_hir_id == hir_id {\n+            break;\n+        }\n+        prev_hir_id = hir_id;\n+        hir_id = tcx.hir().get_parent_node(hir_id);\n+    }\n+    err.emit();\n+}\n+\n+fn async_opaque_type_cycle_error(tcx: TyCtxt<'tcx>, span: Span) {\n+    struct_span_err!(tcx.sess, span, E0733, \"recursion in an `async fn` requires boxing\")\n+        .span_label(span, \"recursive `async fn`\")\n+        .note(\"a recursive `async fn` must be rewritten to return a boxed `dyn Future`\")\n+        .emit();\n+}\n+\n /// Checks that an opaque type does not contain cycles.\n fn check_opaque_for_cycles<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -1721,21 +1888,12 @@ fn check_opaque_for_cycles<'tcx>(\n ) {\n     if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id.to_def_id(), substs)\n     {\n-        if let hir::OpaqueTyOrigin::AsyncFn = origin {\n-            struct_span_err!(tcx.sess, span, E0733, \"recursion in an `async fn` requires boxing\",)\n-                .span_label(span, \"recursive `async fn`\")\n-                .note(\"a recursive `async fn` must be rewritten to return a boxed `dyn Future`\")\n-                .emit();\n-        } else {\n-            let mut err =\n-                struct_span_err!(tcx.sess, span, E0720, \"opaque type expands to a recursive type\",);\n-            err.span_label(span, \"expands to a recursive type\");\n-            if let ty::Opaque(..) = partially_expanded_type.kind {\n-                err.note(\"type resolves to itself\");\n-            } else {\n-                err.note(&format!(\"expanded type is `{}`\", partially_expanded_type));\n+        match origin {\n+            hir::OpaqueTyOrigin::AsyncFn => async_opaque_type_cycle_error(tcx, span),\n+            hir::OpaqueTyOrigin::Binding => {\n+                binding_opaque_type_cycle_error(tcx, def_id, span, partially_expanded_type)\n             }\n-            err.emit();\n+            _ => opaque_type_cycle_error(tcx, def_id, span),\n         }\n     }\n }\n@@ -3175,6 +3333,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n+        let autoborrow_mut = adj.iter().any(|adj| {\n+            matches!(adj, &Adjustment {\n+                kind: Adjust::Borrow(AutoBorrow::Ref(_, AutoBorrowMutability::Mut { .. })),\n+                ..\n+            })\n+        });\n+\n         match self.tables.borrow_mut().adjustments_mut().entry(expr.hir_id) {\n             Entry::Vacant(entry) => {\n                 entry.insert(adj);\n@@ -3204,6 +3369,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 *entry.get_mut() = adj;\n             }\n         }\n+\n+        // If there is an mutable auto-borrow, it is equivalent to `&mut <expr>`.\n+        // In this case implicit use of `Deref` and `Index` within `<expr>` should\n+        // instead be `DerefMut` and `IndexMut`, so fix those up.\n+        if autoborrow_mut {\n+            self.convert_place_derefs_to_mutable(expr);\n+        }\n     }\n \n     /// Basically whenever we are converting from a type scheme into\n@@ -3387,7 +3559,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.tables.borrow().node_types().get(id) {\n             Some(&t) => t,\n-            None if self.is_tainted_by_errors() => self.tcx.types.err,\n+            None if self.is_tainted_by_errors() => self.tcx.ty_error(),\n             None => {\n                 bug!(\n                     \"no type for node {}: {} in fcx {}\",\n@@ -3501,7 +3673,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         assert!(ty.is_ty_infer());\n         let fallback = match self.type_is_unconstrained_numeric(ty) {\n-            _ if self.is_tainted_by_errors() => self.tcx().types.err,\n+            _ if self.is_tainted_by_errors() => self.tcx().ty_error(),\n             UnconstrainedInt => self.tcx.types.i32,\n             UnconstrainedFloat => self.tcx.types.f64,\n             Neither if self.type_var_diverges(ty) => self.tcx.mk_diverging_default(),\n@@ -3595,154 +3767,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ret_ty.builtin_deref(true).unwrap()\n     }\n \n-    fn lookup_indexing(\n-        &self,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &'tcx hir::Expr<'tcx>,\n-        base_ty: Ty<'tcx>,\n-        idx_ty: Ty<'tcx>,\n-        needs: Needs,\n-    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n-        // FIXME(#18741) -- this is almost but not quite the same as the\n-        // autoderef that normal method probing does. They could likely be\n-        // consolidated.\n-\n-        let mut autoderef = self.autoderef(base_expr.span, base_ty);\n-        let mut result = None;\n-        while result.is_none() && autoderef.next().is_some() {\n-            result = self.try_index_step(expr, base_expr, &autoderef, needs, idx_ty);\n-        }\n-        autoderef.finalize(self);\n-        result\n-    }\n-\n-    /// To type-check `base_expr[index_expr]`, we progressively autoderef\n-    /// (and otherwise adjust) `base_expr`, looking for a type which either\n-    /// supports builtin indexing or overloaded indexing.\n-    /// This loop implements one step in that search; the autoderef loop\n-    /// is implemented by `lookup_indexing`.\n-    fn try_index_step(\n-        &self,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &hir::Expr<'_>,\n-        autoderef: &Autoderef<'a, 'tcx>,\n-        needs: Needs,\n-        index_ty: Ty<'tcx>,\n-    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n-        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n-        debug!(\n-            \"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n-             index_ty={:?})\",\n-            expr, base_expr, adjusted_ty, index_ty\n-        );\n-\n-        for &unsize in &[false, true] {\n-            let mut self_ty = adjusted_ty;\n-            if unsize {\n-                // We only unsize arrays here.\n-                if let ty::Array(element_ty, _) = adjusted_ty.kind {\n-                    self_ty = self.tcx.mk_slice(element_ty);\n-                } else {\n-                    continue;\n-                }\n-            }\n-\n-            // If some lookup succeeds, write callee into table and extract index/element\n-            // type from the method signature.\n-            // If some lookup succeeded, install method in table\n-            let input_ty = self.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::AutoDeref,\n-                span: base_expr.span,\n-            });\n-            let method = self.try_overloaded_place_op(\n-                expr.span,\n-                self_ty,\n-                &[input_ty],\n-                needs,\n-                PlaceOp::Index,\n-            );\n-\n-            let result = method.map(|ok| {\n-                debug!(\"try_index_step: success, using overloaded indexing\");\n-                let method = self.register_infer_ok_obligations(ok);\n-\n-                let mut adjustments = autoderef.adjust_steps(self, needs);\n-                if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].kind {\n-                    let mutbl = match r_mutbl {\n-                        hir::Mutability::Not => AutoBorrowMutability::Not,\n-                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                            // Indexing can be desugared to a method call,\n-                            // so maybe we could use two-phase here.\n-                            // See the documentation of AllowTwoPhase for why that's\n-                            // not the case today.\n-                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                        },\n-                    };\n-                    adjustments.push(Adjustment {\n-                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                        target: self\n-                            .tcx\n-                            .mk_ref(region, ty::TypeAndMut { mutbl: r_mutbl, ty: adjusted_ty }),\n-                    });\n-                }\n-                if unsize {\n-                    adjustments.push(Adjustment {\n-                        kind: Adjust::Pointer(PointerCast::Unsize),\n-                        target: method.sig.inputs()[0],\n-                    });\n-                }\n-                self.apply_adjustments(base_expr, adjustments);\n-\n-                self.write_method_call(expr.hir_id, method);\n-                (input_ty, self.make_overloaded_place_return_type(method).ty)\n-            });\n-            if result.is_some() {\n-                return result;\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, Ident) {\n-        let (tr, name) = match (op, is_mut) {\n-            (PlaceOp::Deref, false) => (self.tcx.lang_items().deref_trait(), sym::deref),\n-            (PlaceOp::Deref, true) => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n-            (PlaceOp::Index, false) => (self.tcx.lang_items().index_trait(), sym::index),\n-            (PlaceOp::Index, true) => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n-        };\n-        (tr, Ident::with_dummy_span(name))\n-    }\n-\n-    fn try_overloaded_place_op(\n-        &self,\n-        span: Span,\n-        base_ty: Ty<'tcx>,\n-        arg_tys: &[Ty<'tcx>],\n-        needs: Needs,\n-        op: PlaceOp,\n-    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        debug!(\"try_overloaded_place_op({:?},{:?},{:?},{:?})\", span, base_ty, needs, op);\n-\n-        // Try Mut first, if needed.\n-        let (mut_tr, mut_op) = self.resolve_place_op(op, true);\n-        let method = match (needs, mut_tr) {\n-            (Needs::MutPlace, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, mut_op, trait_did, base_ty, Some(arg_tys))\n-            }\n-            _ => None,\n-        };\n-\n-        // Otherwise, fall back to the immutable version.\n-        let (imm_tr, imm_op) = self.resolve_place_op(op, false);\n-        match (method, imm_tr) {\n-            (None, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, imm_op, trait_did, base_ty, Some(arg_tys))\n-            }\n-            (method, _) => method,\n-        }\n-    }\n-\n     fn check_method_argument_types(\n         &self,\n         sp: Span,\n@@ -3774,7 +3798,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tuple_arguments,\n                 None,\n             );\n-            return self.tcx.types.err;\n+            return self.tcx.ty_error();\n         }\n \n         let method = method.unwrap();\n@@ -4161,7 +4185,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n-        vec![self.tcx.types.err; len]\n+        vec![self.tcx.ty_error(); len]\n     }\n \n     /// Given a vec of evaluated `FulfillmentError`s and an `fn` call argument expressions, we walk\n@@ -4305,7 +4329,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 opt_ty.unwrap_or_else(|| self.next_float_var())\n             }\n             ast::LitKind::Bool(_) => tcx.types.bool,\n-            ast::LitKind::Err(_) => tcx.types.err,\n+            ast::LitKind::Err(_) => tcx.ty_error(),\n         }\n     }\n \n@@ -4442,7 +4466,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 let result =\n                     AstConv::associated_path_to_ty(self, hir_id, path_span, ty, res, segment, true);\n-                let ty = result.map(|(ty, _, _)| ty).unwrap_or(self.tcx().types.err);\n+                let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));\n \n                 // Write back the new resolution.\n@@ -4570,7 +4594,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) {\n         if ty.references_error() {\n-            // Override the types everywhere with `types.err` to avoid knock on errors.\n+            // Override the types everywhere with `err()` to avoid knock on errors.\n             self.write_ty(local.hir_id, ty);\n             self.write_ty(local.pat.hir_id, ty);\n             let local_ty = LocalTy { decl_ty, revealed_ty: ty };\n@@ -4790,7 +4814,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut ty = ctxt.coerce.unwrap().complete(self);\n \n         if self.has_errors.get() || ty.references_error() {\n-            ty = self.tcx.types.err\n+            ty = self.tcx.ty_error()\n         }\n \n         self.write_ty(blk.hir_id, ty);\n@@ -5378,7 +5402,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => return None,\n         };\n         let last_expr_ty = self.node_ty(last_expr.hir_id);\n-        if matches!(last_expr_ty.kind, ty::Error)\n+        if matches!(last_expr_ty.kind, ty::Error(_))\n             || self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err()\n         {\n             return None;\n@@ -5538,7 +5562,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     err.emit();\n \n-                    return (tcx.types.err, res);\n+                    return (tcx.ty_error(), res);\n                 }\n             }\n         } else {\n@@ -5731,8 +5755,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .note(\"type must be known at this point\")\n                     .emit();\n             }\n-            self.demand_suptype(sp, self.tcx.types.err, ty);\n-            self.tcx.types.err\n+            let err = self.tcx.ty_error();\n+            self.demand_suptype(sp, err, ty);\n+            err\n         }\n     }\n "}, {"sha": "56804792b19442a04481e078866ac341fb5f2a69", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,7 +1,7 @@\n //! Code related to processing overloaded binary and unary operators.\n \n use super::method::MethodCallee;\n-use super::{FnCtxt, Needs};\n+use super::FnCtxt;\n use rustc_errors::{self, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // trait matching creating lifetime constraints that are too strict.\n                 // e.g., adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n                 // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n-                let lhs_ty = self.check_expr_with_needs(lhs_expr, Needs::None);\n+                let lhs_ty = self.check_expr(lhs_expr);\n                 let fresh_var = self.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: lhs_expr.span,\n@@ -177,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // equivalence on the LHS of an assign-op like `+=`;\n                 // overwritten or mutably-borrowed places cannot be\n                 // coerced to a supertype.\n-                self.check_expr_with_needs(lhs_expr, Needs::MutPlace)\n+                self.check_expr(lhs_expr)\n             }\n         };\n         let lhs_ty = self.resolve_vars_with_obligations(lhs_ty);\n@@ -497,7 +497,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                 }\n-                self.tcx.types.err\n+                self.tcx.ty_error()\n             }\n         };\n \n@@ -709,7 +709,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     err.emit();\n                 }\n-                self.tcx.types.err\n+                self.tcx.ty_error()\n             }\n         }\n     }"}, {"sha": "7965c9c9ce12aed4d391d9359a26eac35abf46c0", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -442,7 +442,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // There exists a side that didn't meet our criteria that the end-point\n             // be of a numeric or char type, as checked in `calc_side` above.\n             self.emit_err_pat_range(span, lhs, rhs);\n-            return self.tcx.types.err;\n+            return self.tcx.ty_error();\n         }\n \n         // Now that we know the types can be unified we find the unified type\n@@ -673,11 +673,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         {\n             variant_ty\n         } else {\n+            let err = self.tcx.ty_error();\n             for field in fields {\n                 let ti = TopInfo { parent_pat: Some(&pat), ..ti };\n-                self.check_pat(&field.pat, self.tcx.types.err, def_bm, ti);\n+                self.check_pat(&field.pat, err, def_bm, ti);\n             }\n-            return self.tcx.types.err;\n+            return err;\n         };\n \n         // Type-check the path.\n@@ -687,7 +688,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if self.check_struct_pat_fields(pat_ty, &pat, variant, fields, etc, def_bm, ti) {\n             pat_ty\n         } else {\n-            self.tcx.types.err\n+            self.tcx.ty_error()\n         }\n     }\n \n@@ -705,11 +706,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match res {\n             Res::Err => {\n                 self.set_tainted_by_errors();\n-                return tcx.types.err;\n+                return tcx.ty_error();\n             }\n             Res::Def(DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fictive | CtorKind::Fn), _) => {\n                 report_unexpected_variant_res(tcx, res, pat.span);\n-                return tcx.types.err;\n+                return tcx.ty_error();\n             }\n             Res::SelfCtor(..)\n             | Res::Def(\n@@ -788,7 +789,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let on_error = || {\n             let parent_pat = Some(pat);\n             for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err, def_bm, TopInfo { parent_pat, ..ti });\n+                self.check_pat(&pat, tcx.ty_error(), def_bm, TopInfo { parent_pat, ..ti });\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -824,26 +825,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if res == Res::Err {\n             self.set_tainted_by_errors();\n             on_error();\n-            return self.tcx.types.err;\n+            return self.tcx.ty_error();\n         }\n \n         // Type-check the path.\n         let (pat_ty, res) =\n             self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id);\n         if !pat_ty.is_fn() {\n             report_unexpected_res(res);\n-            return tcx.types.err;\n+            return tcx.ty_error();\n         }\n \n         let variant = match res {\n             Res::Err => {\n                 self.set_tainted_by_errors();\n                 on_error();\n-                return tcx.types.err;\n+                return tcx.ty_error();\n             }\n             Res::Def(DefKind::AssocConst | DefKind::AssocFn, _) => {\n                 report_unexpected_res(res);\n-                return tcx.types.err;\n+                return tcx.ty_error();\n             }\n             Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => tcx.expect_variant_res(res),\n             _ => bug!(\"unexpected pattern resolution: {:?}\", res),\n@@ -880,7 +881,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Pattern has wrong number of fields.\n             self.e0023(pat.span, res, qpath, subpats, &variant.fields, expected, had_err);\n             on_error();\n-            return tcx.types.err;\n+            return tcx.ty_error();\n         }\n         pat_ty\n     }\n@@ -1001,9 +1002,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.emit();\n             // Walk subpatterns with an expected type of `err` in this case to silence\n             // further errors being emitted when using the bindings. #50333\n-            let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n+            let element_tys_iter = (0..max_len).map(|_| tcx.ty_error());\n             for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, &tcx.types.err, def_bm, ti);\n+                self.check_pat(elem, &tcx.ty_error(), def_bm, ti);\n             }\n             tcx.mk_tup(element_tys_iter)\n         } else {\n@@ -1052,7 +1053,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Occupied(occupied) => {\n                     self.error_field_already_bound(span, field.ident, *occupied.get());\n                     no_field_errors = false;\n-                    tcx.types.err\n+                    tcx.ty_error()\n                 }\n                 Vacant(vacant) => {\n                     vacant.insert(span);\n@@ -1066,7 +1067,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .unwrap_or_else(|| {\n                             inexistent_fields.push(field.ident);\n                             no_field_errors = false;\n-                            tcx.types.err\n+                            tcx.ty_error()\n                         })\n                 }\n             };\n@@ -1281,7 +1282,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.demand_eqtype_pat(span, expected, box_ty, ti);\n             (box_ty, inner_ty)\n         } else {\n-            (tcx.types.err, tcx.types.err)\n+            let err = tcx.ty_error();\n+            (err, err)\n         };\n         self.check_pat(&inner, inner_ty, def_bm, ti);\n         box_ty\n@@ -1327,7 +1329,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n         } else {\n-            (tcx.types.err, tcx.types.err)\n+            let err = tcx.ty_error();\n+            (err, err)\n         };\n         self.check_pat(&inner, inner_ty, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n         rptr_ty\n@@ -1378,7 +1381,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if !expected.references_error() {\n                     self.error_expected_array_or_slice(span, expected);\n                 }\n-                let err = self.tcx.types.err;\n+                let err = self.tcx.ty_error();\n                 (err, Some(err), err)\n             }\n         };\n@@ -1445,7 +1448,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         // If we get here, we must have emitted an error.\n-        (Some(self.tcx.types.err), arr_ty)\n+        (Some(self.tcx.ty_error()), arr_ty)\n     }\n \n     fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {"}, {"sha": "d1c22cd1ac03ebe0d18747d73f5a0b6e38198517", "filename": "src/librustc_typeck/check/place_op.rs", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,336 @@\n+use crate::check::autoderef::Autoderef;\n+use crate::check::method::MethodCallee;\n+use crate::check::{FnCtxt, PlaceOp};\n+use rustc_hir as hir;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::InferOk;\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n+use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::Span;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /// Type-check `*oprnd_expr` with `oprnd_expr` type-checked already.\n+    pub(super) fn lookup_derefing(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        oprnd_expr: &'tcx hir::Expr<'tcx>,\n+        oprnd_ty: Ty<'tcx>,\n+    ) -> Option<Ty<'tcx>> {\n+        if let Some(mt) = oprnd_ty.builtin_deref(true) {\n+            return Some(mt.ty);\n+        }\n+\n+        let ok = self.try_overloaded_deref(expr.span, oprnd_ty)?;\n+        let method = self.register_infer_ok_obligations(ok);\n+        if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n+            self.apply_adjustments(\n+                oprnd_expr,\n+                vec![Adjustment {\n+                    kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),\n+                    target: method.sig.inputs()[0],\n+                }],\n+            );\n+        } else {\n+            span_bug!(expr.span, \"input to deref is not a ref?\");\n+        }\n+        let ty = self.make_overloaded_place_return_type(method).ty;\n+        self.write_method_call(expr.hir_id, method);\n+        Some(ty)\n+    }\n+\n+    /// Type-check `*base_expr[index_expr]` with `base_expr` and `index_expr` type-checked already.\n+    pub(super) fn lookup_indexing(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &'tcx hir::Expr<'tcx>,\n+        base_ty: Ty<'tcx>,\n+        idx_ty: Ty<'tcx>,\n+    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n+        // FIXME(#18741) -- this is almost but not quite the same as the\n+        // autoderef that normal method probing does. They could likely be\n+        // consolidated.\n+\n+        let mut autoderef = self.autoderef(base_expr.span, base_ty);\n+        let mut result = None;\n+        while result.is_none() && autoderef.next().is_some() {\n+            result = self.try_index_step(expr, base_expr, &autoderef, idx_ty);\n+        }\n+        autoderef.finalize(self);\n+        result\n+    }\n+\n+    /// To type-check `base_expr[index_expr]`, we progressively autoderef\n+    /// (and otherwise adjust) `base_expr`, looking for a type which either\n+    /// supports builtin indexing or overloaded indexing.\n+    /// This loop implements one step in that search; the autoderef loop\n+    /// is implemented by `lookup_indexing`.\n+    fn try_index_step(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n+        autoderef: &Autoderef<'a, 'tcx>,\n+        index_ty: Ty<'tcx>,\n+    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n+        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n+        debug!(\n+            \"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n+             index_ty={:?})\",\n+            expr, base_expr, adjusted_ty, index_ty\n+        );\n+\n+        for &unsize in &[false, true] {\n+            let mut self_ty = adjusted_ty;\n+            if unsize {\n+                // We only unsize arrays here.\n+                if let ty::Array(element_ty, _) = adjusted_ty.kind {\n+                    self_ty = self.tcx.mk_slice(element_ty);\n+                } else {\n+                    continue;\n+                }\n+            }\n+\n+            // If some lookup succeeds, write callee into table and extract index/element\n+            // type from the method signature.\n+            // If some lookup succeeded, install method in table\n+            let input_ty = self.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::AutoDeref,\n+                span: base_expr.span,\n+            });\n+            let method =\n+                self.try_overloaded_place_op(expr.span, self_ty, &[input_ty], PlaceOp::Index);\n+\n+            let result = method.map(|ok| {\n+                debug!(\"try_index_step: success, using overloaded indexing\");\n+                let method = self.register_infer_ok_obligations(ok);\n+\n+                let mut adjustments = autoderef.adjust_steps(self);\n+                if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n+                    adjustments.push(Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),\n+                        target: self.tcx.mk_ref(\n+                            region,\n+                            ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: adjusted_ty },\n+                        ),\n+                    });\n+                } else {\n+                    span_bug!(expr.span, \"input to index is not a ref?\");\n+                }\n+                if unsize {\n+                    adjustments.push(Adjustment {\n+                        kind: Adjust::Pointer(PointerCast::Unsize),\n+                        target: method.sig.inputs()[0],\n+                    });\n+                }\n+                self.apply_adjustments(base_expr, adjustments);\n+\n+                self.write_method_call(expr.hir_id, method);\n+                (input_ty, self.make_overloaded_place_return_type(method).ty)\n+            });\n+            if result.is_some() {\n+                return result;\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Try to resolve an overloaded place op. We only deal with the immutable\n+    /// variant here (Deref/Index). In some contexts we would need the mutable\n+    /// variant (DerefMut/IndexMut); those would be later converted by\n+    /// `convert_place_derefs_to_mutable`.\n+    pub(super) fn try_overloaded_place_op(\n+        &self,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+        arg_tys: &[Ty<'tcx>],\n+        op: PlaceOp,\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        debug!(\"try_overloaded_place_op({:?},{:?},{:?})\", span, base_ty, op);\n+\n+        let (imm_tr, imm_op) = match op {\n+            PlaceOp::Deref => (self.tcx.lang_items().deref_trait(), sym::deref),\n+            PlaceOp::Index => (self.tcx.lang_items().index_trait(), sym::index),\n+        };\n+        imm_tr.and_then(|trait_did| {\n+            self.lookup_method_in_trait(\n+                span,\n+                Ident::with_dummy_span(imm_op),\n+                trait_did,\n+                base_ty,\n+                Some(arg_tys),\n+            )\n+        })\n+    }\n+\n+    fn try_mutable_overloaded_place_op(\n+        &self,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+        arg_tys: &[Ty<'tcx>],\n+        op: PlaceOp,\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        debug!(\"try_mutable_overloaded_place_op({:?},{:?},{:?})\", span, base_ty, op);\n+\n+        let (mut_tr, mut_op) = match op {\n+            PlaceOp::Deref => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n+            PlaceOp::Index => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n+        };\n+        mut_tr.and_then(|trait_did| {\n+            self.lookup_method_in_trait(\n+                span,\n+                Ident::with_dummy_span(mut_op),\n+                trait_did,\n+                base_ty,\n+                Some(arg_tys),\n+            )\n+        })\n+    }\n+\n+    /// Convert auto-derefs, indices, etc of an expression from `Deref` and `Index`\n+    /// into `DerefMut` and `IndexMut` respectively.\n+    ///\n+    /// This is a second pass of typechecking derefs/indices. We need this we do not\n+    /// always know whether a place needs to be mutable or not in the first pass.\n+    /// This happens whether there is an implicit mutable reborrow, e.g. when the type\n+    /// is used as the receiver of a method call.\n+    pub fn convert_place_derefs_to_mutable(&self, expr: &hir::Expr<'_>) {\n+        // Gather up expressions we want to munge.\n+        let mut exprs = vec![expr];\n+\n+        loop {\n+            match exprs.last().unwrap().kind {\n+                hir::ExprKind::Field(ref expr, _)\n+                | hir::ExprKind::Index(ref expr, _)\n+                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) => exprs.push(&expr),\n+                _ => break,\n+            }\n+        }\n+\n+        debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n+\n+        // Fix up autoderefs and derefs.\n+        for (i, &expr) in exprs.iter().rev().enumerate() {\n+            debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n+\n+            // Fix up the autoderefs. Autorefs can only occur immediately preceding\n+            // overloaded place ops, and will be fixed by them in order to get\n+            // the correct region.\n+            let mut source = self.node_ty(expr.hir_id);\n+            // Do not mutate adjustments in place, but rather take them,\n+            // and replace them after mutating them, to avoid having the\n+            // tables borrowed during (`deref_mut`) method resolution.\n+            let previous_adjustments =\n+                self.tables.borrow_mut().adjustments_mut().remove(expr.hir_id);\n+            if let Some(mut adjustments) = previous_adjustments {\n+                for adjustment in &mut adjustments {\n+                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n+                        if let Some(ok) = self.try_mutable_overloaded_place_op(\n+                            expr.span,\n+                            source,\n+                            &[],\n+                            PlaceOp::Deref,\n+                        ) {\n+                            let method = self.register_infer_ok_obligations(ok);\n+                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n+                                *deref = OverloadedDeref { region, mutbl };\n+                            }\n+                        }\n+                    }\n+                    source = adjustment.target;\n+                }\n+                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n+            }\n+\n+            match expr.kind {\n+                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n+                    // We need to get the final type in case dereferences were needed for the trait\n+                    // to apply (#72002).\n+                    let index_expr_ty = self.tables.borrow().expr_ty_adjusted(index_expr);\n+                    self.convert_place_op_to_mutable(\n+                        PlaceOp::Index,\n+                        expr,\n+                        base_expr,\n+                        &[index_expr_ty],\n+                    );\n+                }\n+                hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base_expr) => {\n+                    self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr, &[]);\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    fn convert_place_op_to_mutable(\n+        &self,\n+        op: PlaceOp,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n+        arg_tys: &[Ty<'tcx>],\n+    ) {\n+        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);\n+        if !self.tables.borrow().is_method_call(expr) {\n+            debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n+            return;\n+        }\n+\n+        // Need to deref because overloaded place ops take self by-reference.\n+        let base_ty = self\n+            .tables\n+            .borrow()\n+            .expr_ty_adjusted(base_expr)\n+            .builtin_deref(false)\n+            .expect(\"place op takes something that is not a ref\")\n+            .ty;\n+\n+        let method = self.try_mutable_overloaded_place_op(expr.span, base_ty, arg_tys, op);\n+        let method = match method {\n+            Some(ok) => self.register_infer_ok_obligations(ok),\n+            // Couldn't find the mutable variant of the place op, keep the\n+            // current, immutable version.\n+            None => return,\n+        };\n+        debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n+        self.write_method_call(expr.hir_id, method);\n+\n+        let region = if let ty::Ref(r, _, hir::Mutability::Mut) = method.sig.inputs()[0].kind {\n+            r\n+        } else {\n+            span_bug!(expr.span, \"input to mutable place op is not a mut ref?\");\n+        };\n+\n+        // Convert the autoref in the base expr to mutable with the correct\n+        // region and mutability.\n+        let base_expr_ty = self.node_ty(base_expr.hir_id);\n+        if let Some(adjustments) =\n+            self.tables.borrow_mut().adjustments_mut().get_mut(base_expr.hir_id)\n+        {\n+            let mut source = base_expr_ty;\n+            for adjustment in &mut adjustments[..] {\n+                if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n+                    debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n+                    let mutbl = AutoBorrowMutability::Mut {\n+                        // Deref/indexing can be desugared to a method call,\n+                        // so maybe we could use two-phase here.\n+                        // See the documentation of AllowTwoPhase for why that's\n+                        // not the case today.\n+                        allow_two_phase_borrow: AllowTwoPhase::No,\n+                    };\n+                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n+                    adjustment.target =\n+                        self.tcx.mk_ref(region, ty::TypeAndMut { ty: source, mutbl: mutbl.into() });\n+                }\n+                source = adjustment.target;\n+            }\n+\n+            // If we have an autoref followed by unsizing at the end, fix the unsize target.\n+            if let [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. }, Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), ref mut target }] =\n+                adjustments[..]\n+            {\n+                *target = method.sig.inputs()[0];\n+            }\n+        }\n+    }\n+}"}, {"sha": "8403c99f01bb57d549fe104e9a9ceedd7af29efb", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let (closure_def_id, substs) = match ty.kind {\n             ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n             ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n-            ty::Error => {\n+            ty::Error(_) => {\n                 // #51714: skip analysis when we have already encountered type errors\n                 return;\n             }"}, {"sha": "ba806430f17fda879afc75f85fcdadd7f87d7ad1", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -208,11 +208,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     // to access an unexistend index. We assume that more relevant errors will\n                     // already have been emitted, so we only gate on this with an ICE if no\n                     // error has been emitted. (#64638)\n-                    self.tcx().sess.delay_span_bug(\n+                    self.fcx.tcx.ty_error_with_message(\n                         e.span,\n                         &format!(\"bad index {:?} for base: `{:?}`\", index, base),\n-                    );\n-                    self.fcx.tcx.types.err\n+                    )\n                 });\n                 let index_ty = self.fcx.resolve_vars_if_possible(&index_ty);\n \n@@ -681,7 +680,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n                 self.report_type_error(t);\n                 self.replaced_with_error = true;\n-                self.tcx().types.err\n+                self.tcx().ty_error()\n             }\n         }\n     }\n@@ -698,7 +697,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n                 self.report_const_error(ct);\n                 self.replaced_with_error = true;\n-                self.tcx().mk_const(ty::Const { val: ty::ConstKind::Error, ty: ct.ty })\n+                self.tcx().const_error(ct.ty)\n             }\n         }\n     }"}, {"sha": "8c6161a62647346b780450776524de5e5228a51d", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> Checker<'tcx> {\n \n fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     // Destructors only work on nominal types.\n-    if let ty::Adt(..) | ty::Error = tcx.type_of(impl_did).kind {\n+    if let ty::Adt(..) | ty::Error(_) = tcx.type_of(impl_did).kind {\n         return;\n     }\n "}, {"sha": "93ee87f6c572ee5bd164247dcb11fefcabfe8789", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -296,7 +296,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     item.span,\n                 );\n             }\n-            ty::Error => {}\n+            ty::Error(_) => {}\n             _ => {\n                 struct_span_err!(\n                     self.tcx.sess,"}, {"sha": "3bd75095bb6021db986c5bd682a2dec7d93dd3eb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -307,8 +307,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n     }\n \n     fn ty_infer(&self, _: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx> {\n-        self.tcx().sess.delay_span_bug(span, \"bad placeholder type\");\n-        self.tcx().types.err\n+        self.tcx().ty_error_with_message(span, \"bad_placeholder_type\")\n     }\n \n     fn ct_infer(\n@@ -318,8 +317,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n         span: Span,\n     ) -> &'tcx Const<'tcx> {\n         bad_placeholder_type(self.tcx(), vec![span]).emit();\n-\n-        self.tcx().mk_const(ty::Const { val: ty::ConstKind::Error, ty })\n+        self.tcx().const_error(ty)\n     }\n \n     fn projected_ty_from_poly_trait_ref(\n@@ -419,7 +417,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n                 _ => {}\n             }\n             err.emit();\n-            self.tcx().types.err\n+            self.tcx().ty_error()\n         }\n     }\n \n@@ -1465,7 +1463,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     visitor.visit_ty(ty);\n                     let mut diag = bad_placeholder_type(tcx, visitor.0);\n                     let ret_ty = fn_sig.output();\n-                    if ret_ty != tcx.types.err {\n+                    if ret_ty != tcx.ty_error() {\n                         diag.span_suggestion(\n                             ty.span,\n                             \"replace with the correct return type\",\n@@ -2004,12 +2002,11 @@ fn associated_item_predicates(\n             // once they are handled by the trait system.\n             ty::GenericParamDefKind::Type { .. } => {\n                 unimplemented_error(\"type\");\n-                tcx.types.err.into()\n+                tcx.ty_error().into()\n             }\n             ty::GenericParamDefKind::Const => {\n                 unimplemented_error(\"const\");\n-                tcx.mk_const(ty::Const { val: ty::ConstKind::Error, ty: tcx.type_of(param.def_id) })\n-                    .into()\n+                tcx.const_error(tcx.type_of(param.def_id)).into()\n             }\n         }\n     };"}, {"sha": "cf5f2ec69d8d85ee3e0b93d5545d6595338d60b0", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -127,7 +127,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                 // Some error in the\n                                 // owner fn prevented us from populating\n                                 // the `concrete_opaque_types` table.\n-                                tcx.types.err\n+                                tcx.ty_error()\n                             } else {\n                                 // We failed to resolve the opaque type or it\n                                 // resolves to itself. Return the non-revealed\n@@ -217,11 +217,10 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         })\n                         | Node::TraitRef(&TraitRef { path, .. }) => &*path,\n                         _ => {\n-                            tcx.sess.delay_span_bug(\n+                            return tcx.ty_error_with_message(\n                                 DUMMY_SP,\n                                 &format!(\"unexpected const parent path {:?}\", parent_node),\n                             );\n-                            return tcx.types.err;\n                         }\n                     };\n \n@@ -254,14 +253,13 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         }\n                         Res::Def(_, def_id) => tcx.generics_of(def_id),\n                         res => {\n-                            tcx.sess.delay_span_bug(\n+                            return tcx.ty_error_with_message(\n                                 DUMMY_SP,\n                                 &format!(\n                                     \"unexpected anon const res {:?} in path: {:?}\",\n                                     res, path,\n                                 ),\n-                            );\n-                            return tcx.types.err;\n+                                );\n                         }\n                     };\n \n@@ -283,24 +281,21 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     } else {\n                         // This is no generic parameter associated with the arg. This is\n                         // probably from an extra arg where one is not needed.\n-                        tcx.sess.delay_span_bug(\n+                        tcx.ty_error_with_message(\n                             DUMMY_SP,\n                             &format!(\n-                                \"missing generic parameter for `AnonConst`, parent: {:?}, res: {:?}\",\n+                                \"missing generic parameter for `AnonConst`, \\\n+                                 parent: {:?}, res: {:?}\",\n                                 parent_node, res\n                             ),\n-                        );\n-                        tcx.types.err\n+                        )\n                     }\n                 }\n \n-                x => {\n-                    tcx.sess.delay_span_bug(\n-                        DUMMY_SP,\n-                        &format!(\"unexpected const parent in type_of_def_id(): {:?}\", x),\n-                    );\n-                    tcx.types.err\n-                }\n+                x => tcx.ty_error_with_message(\n+                    DUMMY_SP,\n+                    &format!(\"unexpected const parent in type_of_def_id(): {:?}\", x),\n+                ),\n             }\n         }\n \n@@ -568,7 +563,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n         None => {\n             let span = tcx.def_span(def_id);\n             tcx.sess.span_err(span, \"could not find defining uses\");\n-            tcx.types.err\n+            tcx.ty_error()\n         }\n     }\n }\n@@ -605,7 +600,7 @@ fn let_position_impl_trait_type(tcx: TyCtxt<'_>, opaque_ty_id: LocalDefId) -> Ty\n             if let Some(ErrorReported) = owner_tables.tainted_by_errors {\n                 // Some error in the owner fn prevented us from populating the\n                 // `concrete_opaque_types` table.\n-                tcx.types.err\n+                tcx.ty_error()\n             } else {\n                 // We failed to resolve the opaque type or it resolves to\n                 // itself. Return the non-revealed type, which should result in\n@@ -655,7 +650,7 @@ fn infer_placeholder_type(\n         }\n         None => {\n             let mut diag = bad_placeholder_type(tcx, vec![span]);\n-            if ty != tcx.types.err {\n+            if !matches!(ty.kind, ty::Error(_)) {\n                 diag.span_suggestion(\n                     span,\n                     \"replace `_` with the correct type\","}, {"sha": "cae09267994e3fe94af54dc80e41d95cedb4c0a1", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -339,7 +339,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_sig(current, sig, variance);\n             }\n \n-            ty::Error => {\n+            ty::Error(_) => {\n                 // we encounter this when walking the trait references for object\n                 // types, where we use Error as the Self type\n             }"}, {"sha": "73fe87b05d477e6f3d25ed64e24c7252b03a976e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1717,7 +1717,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::Placeholder(..) => panic!(\"Placeholder\"),\n             ty::GeneratorWitness(..) => panic!(\"GeneratorWitness\"),\n             ty::Infer(..) => panic!(\"Infer\"),\n-            ty::Error => panic!(\"Error\"),\n+            ty::Error(_) => panic!(\"Error\"),\n         }\n     }\n }"}, {"sha": "7a6626766d38830c27283ad336f69ee03aae2435", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -192,6 +192,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n     fn next(&mut self) -> Option<Self::Item> {\n         let event = self.inner.next();\n         let compile_fail;\n+        let should_panic;\n         let ignore;\n         let edition;\n         if let Some(Event::Start(Tag::CodeBlock(kind))) = event {\n@@ -205,6 +206,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                 return Some(Event::Start(Tag::CodeBlock(kind)));\n             }\n             compile_fail = parse_result.compile_fail;\n+            should_panic = parse_result.should_panic;\n             ignore = parse_result.ignore;\n             edition = parse_result.edition;\n         } else {\n@@ -280,6 +282,8 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n             Some((\"This example is not tested\".to_owned(), \"ignore\"))\n         } else if compile_fail {\n             Some((\"This example deliberately fails to compile\".to_owned(), \"compile_fail\"))\n+        } else if should_panic {\n+            Some((\"This example panics\".to_owned(), \"should_panic\"))\n         } else if explicit_edition {\n             Some((format!(\"This code runs with edition {}\", edition), \"edition\"))\n         } else {\n@@ -295,6 +299,8 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                         \" ignore\"\n                     } else if compile_fail {\n                         \" compile_fail\"\n+                    } else if should_panic {\n+                        \" should_panic\"\n                     } else if explicit_edition {\n                         \" edition \"\n                     } else {\n@@ -314,6 +320,8 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                         \" ignore\"\n                     } else if compile_fail {\n                         \" compile_fail\"\n+                    } else if should_panic {\n+                        \" should_panic\"\n                     } else if explicit_edition {\n                         \" edition \"\n                     } else {"}, {"sha": "8d53b0579537407c8abbf5c66c2566baacb58b71", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -100,6 +100,8 @@ function defocusSearchBar() {\n     // 2 for \"In Return Types\"\n     var currentTab = 0;\n \n+    var mouseMovedAfterSearch = true;\n+\n     var titleBeforeSearch = document.title;\n \n     function clearInputTimeout() {\n@@ -162,6 +164,7 @@ function defocusSearchBar() {\n         }\n         addClass(main, \"hidden\");\n         removeClass(search, \"hidden\");\n+        mouseMovedAfterSearch = false;\n     }\n \n     function hideSearchResults(search) {\n@@ -424,6 +427,12 @@ function defocusSearchBar() {\n     document.addEventListener(\"keypress\", handleShortcut);\n     document.addEventListener(\"keydown\", handleShortcut);\n \n+    function resetMouseMoved(ev) {\n+        mouseMovedAfterSearch = true;\n+    }\n+\n+    document.addEventListener(\"mousemove\", resetMouseMoved);\n+\n     var handleSourceHighlight = (function() {\n         var prev_line_id = 0;\n \n@@ -1353,20 +1362,22 @@ function defocusSearchBar() {\n                 }\n             };\n             var mouseover_func = function(e) {\n-                var el = e.target;\n-                // to retrieve the real \"owner\" of the event.\n-                while (el.tagName !== \"TR\") {\n-                    el = el.parentNode;\n-                }\n-                clearTimeout(hoverTimeout);\n-                hoverTimeout = setTimeout(function() {\n-                    onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n-                        onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {\n-                            removeClass(i_e, \"highlighted\");\n+                if (mouseMovedAfterSearch) {\n+                    var el = e.target;\n+                    // to retrieve the real \"owner\" of the event.\n+                    while (el.tagName !== \"TR\") {\n+                        el = el.parentNode;\n+                    }\n+                    clearTimeout(hoverTimeout);\n+                    hoverTimeout = setTimeout(function() {\n+                        onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n+                            onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {\n+                                removeClass(i_e, \"highlighted\");\n+                            });\n                         });\n-                    });\n-                    addClass(el, \"highlighted\");\n-                }, 20);\n+                        addClass(el, \"highlighted\");\n+                    }, 20);\n+                }\n             };\n             onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n                 onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {"}, {"sha": "9c6dd25394db0e8ed4d1c1c0beffbf9cd36eaa3e", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1089,7 +1089,7 @@ h3 > .collapse-toggle, h4 > .collapse-toggle {\n \tborder-style: solid;\n }\n \n-.tooltip.compile_fail, .tooltip.ignore {\n+.tooltip.compile_fail, .tooltip.should_panic, .tooltip.ignore {\n \tfont-weight: bold;\n \tfont-size: 20px;\n }"}, {"sha": "41dcb5c24507c6c38dfe99a66bd3f84ac20cde81", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -283,6 +283,14 @@ pre.compile_fail:hover, .information:hover + pre.compile_fail {\n \tborder-left: 2px solid #f00;\n }\n \n+pre.should_panic {\n+\tborder-left: 2px solid rgba(255,0,0,.8);\n+}\n+\n+pre.should_panic:hover, .information:hover + pre.should_panic {\n+\tborder-left: 2px solid #f00;\n+}\n+\n pre.ignore {\n \tborder-left: 2px solid rgba(255,142,0,.6);\n }\n@@ -299,6 +307,14 @@ pre.ignore:hover, .information:hover + pre.ignore {\n \tcolor: #f00;\n }\n \n+.tooltip.should_panic {\n+\tcolor: rgba(255,0,0,.8);\n+}\n+\n+.information > .should_panic:hover {\n+\tcolor: #f00;\n+}\n+\n .tooltip.ignore {\n \tcolor: rgba(255,142,0,.6);\n }"}, {"sha": "386fe2398e63aec931bb665ea82dea7db5c0f0ef", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -278,6 +278,14 @@ pre.compile_fail:hover, .information:hover + pre.compile_fail {\n \tborder-left: 2px solid #f00;\n }\n \n+pre.should_panic {\n+\tborder-left: 2px solid rgba(255,0,0,.5);\n+}\n+\n+pre.should_panic:hover, .information:hover + pre.should_panic {\n+\tborder-left: 2px solid #f00;\n+}\n+\n pre.ignore {\n \tborder-left: 2px solid rgba(255,142,0,.6);\n }\n@@ -294,6 +302,14 @@ pre.ignore:hover, .information:hover + pre.ignore {\n \tcolor: #f00;\n }\n \n+.tooltip.should_panic {\n+\tcolor: rgba(255,0,0,.5);\n+}\n+\n+.information > .should_panic:hover {\n+\tcolor: #f00;\n+}\n+\n .tooltip.ignore {\n \tcolor: rgba(255,142,0,.6);\n }"}, {"sha": "95d113166e00119edb3ef19d6917a81053524c98", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -165,9 +165,8 @@ fn opts() -> Vec<RustcOptGroup> {\n             o.optmulti(\n                 \"\",\n                 \"passes\",\n-                \"list of passes to also run, you might want \\\n-                        to pass it multiple times; a value of `list` \\\n-                        will print available passes\",\n+                \"list of passes to also run, you might want to pass it multiple times; a value of \\\n+                        `list` will print available passes\",\n                 \"PASSES\",\n             )\n         }),\n@@ -248,8 +247,8 @@ fn opts() -> Vec<RustcOptGroup> {\n                 \"e\",\n                 \"extend-css\",\n                 \"To add some CSS rules with a given file to generate doc with your \\\n-                      own theme. However, your theme might break if the rustdoc's generated HTML \\\n-                      changes, so be careful!\",\n+                        own theme. However, your theme might break if the rustdoc's generated HTML \\\n+                        changes, so be careful!\",\n                 \"PATH\",\n             )\n         }),\n@@ -262,7 +261,7 @@ fn opts() -> Vec<RustcOptGroup> {\n                 \"\",\n                 \"playground-url\",\n                 \"URL to send code snippets to, may be reset by --markdown-playground-url \\\n-                      or `#![doc(html_playground_url=...)]`\",\n+                        or `#![doc(html_playground_url=...)]`\",\n                 \"URL\",\n             )\n         }),\n@@ -276,8 +275,7 @@ fn opts() -> Vec<RustcOptGroup> {\n             o.optflag(\n                 \"\",\n                 \"sort-modules-by-appearance\",\n-                \"sort modules by where they appear in the \\\n-                                                         program, rather than alphabetically\",\n+                \"sort modules by where they appear in the program, rather than alphabetically\",\n             )\n         }),\n         stable(\"theme\", |o| {\n@@ -358,7 +356,7 @@ fn opts() -> Vec<RustcOptGroup> {\n                 \"\",\n                 \"static-root-path\",\n                 \"Path string to force loading static files from in output pages. \\\n-                      If not set, uses combinations of '../' to reach the documentation root.\",\n+                        If not set, uses combinations of '../' to reach the documentation root.\",\n                 \"PATH\",\n             )\n         }),"}, {"sha": "490afb5a0438f9088c545d4ede084e4b3797d927", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -74,3 +74,8 @@ std_detect_dlsym_getauxval = []\n threads = 125\n # Maximum heap size\n heap_size = 0x8000000\n+\n+[[bench]]\n+name = \"stdbenches\"\n+path = \"benches/lib.rs\"\n+test = true"}, {"sha": "b392d6e7226d2d7bba2080ebefae53cd89626c45", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -832,11 +832,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn asinh(self) -> f32 {\n-        if self == Self::NEG_INFINITY {\n-            Self::NEG_INFINITY\n-        } else {\n-            (self + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n-        }\n+        (self.abs() + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n     }\n \n     /// Inverse hyperbolic cosine function.\n@@ -1413,6 +1409,8 @@ mod tests {\n         assert!((-0.0f32).asinh().is_sign_negative()); // issue 63271\n         assert_approx_eq!(2.0f32.asinh(), 1.443635475178810342493276740273105f32);\n         assert_approx_eq!((-2.0f32).asinh(), -1.443635475178810342493276740273105f32);\n+        // regression test for the catastrophic cancellation fixed in 72486\n+        assert_approx_eq!((-3000.0f32).asinh(), -8.699514775987968673236893537700647f32);\n     }\n \n     #[test]"}, {"sha": "72268d2cc2f984be863501d2e4df84197d3fbb61", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -834,11 +834,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn asinh(self) -> f64 {\n-        if self == Self::NEG_INFINITY {\n-            Self::NEG_INFINITY\n-        } else {\n-            (self + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n-        }\n+        (self.abs() + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n     }\n \n     /// Inverse hyperbolic cosine function.\n@@ -1442,6 +1438,8 @@ mod tests {\n         // issue 63271\n         assert_approx_eq!(2.0f64.asinh(), 1.443635475178810342493276740273105f64);\n         assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n+        // regression test for the catastrophic cancellation fixed in 72486\n+        assert_approx_eq!((-67452098.07139316f64).asinh(), -18.72007542627454439398548429400083);\n     }\n \n     #[test]"}, {"sha": "ef699ede2a140bc50a85d8a0d0aac2e73c39c571", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -298,6 +298,7 @@\n #![feature(prelude_import)]\n #![feature(ptr_internals)]\n #![feature(raw)]\n+#![feature(raw_ref_macros)]\n #![feature(renamed_spin_loop)]\n #![feature(rustc_attrs)]\n #![feature(rustc_private)]"}, {"sha": "e4d714936047e71b03807c2afc5e24deb6eb87a7", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -242,7 +242,8 @@ pub trait PermissionsExt {\n     ///     let permissions = metadata.permissions();\n     ///\n     ///     println!(\"permissions: {:o}\", permissions.mode());\n-    ///     Ok(()) }\n+    ///     Ok(())\n+    /// }\n     /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&self) -> u32;\n@@ -262,7 +263,8 @@ pub trait PermissionsExt {\n     ///\n     ///     permissions.set_mode(0o644); // Read/write for owner and read for others.\n     ///     assert_eq!(permissions.mode(), 0o644);\n-    ///     Ok(()) }\n+    ///     Ok(())\n+    /// }\n     /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn set_mode(&mut self, mode: u32);"}, {"sha": "295ebcbb7293970ecea26835a407a13a64eeb217", "filename": "src/libstd/time.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -60,6 +60,21 @@ pub use core::time::Duration;\n /// }\n /// ```\n ///\n+/// # OS-specific behaviors\n+///\n+/// An `Instant` is a wrapper around system-specific types and it may behave\n+/// differently depending on the underlying operating system. For example,\n+/// the following snippet is fine on Linux but panics on macOS:\n+///\n+/// ```no_run\n+/// use std::time::{Instant, Duration};\n+///\n+/// let now = Instant::now();\n+/// let max_nanoseconds = u64::MAX / 1_000_000_000;\n+/// let duration = Duration::new(max_nanoseconds, 0);\n+/// println!(\"{:?}\", now + duration);\n+/// ```\n+///\n /// # Underlying System calls\n /// Currently, the following system calls are being used to get the current time using `now()`:\n ///"}, {"sha": "323bd26c698a33e2cb72815d5ab444d44893035d", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -424,6 +424,12 @@ extern \"C\" void LLVMRustPrintTargetFeatures(LLVMTargetMachineRef TM) {\n   printf(\"Available features for this target:\\n\");\n   for (auto &Feature : FeatTable)\n     printf(\"    %-*s - %s.\\n\", MaxFeatLen, Feature.Key, Feature.Desc);\n+  printf(\"\\nRust-specific features:\\n\");\n+  printf(\"    %-*s - %s.\\n\",\n+    MaxFeatLen,\n+    \"crt-static\",\n+    \"Enables libraries with C Run-time Libraries(CRT) to be statically linked\"\n+  );\n   printf(\"\\n\");\n \n   printf(\"Use +feature to enable a feature, or -feature to disable it.\\n\""}, {"sha": "cdb3a157eab97bc408dceb86f44d79d923025db1", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -5,6 +5,7 @@\n #include \"llvm/IR/DiagnosticPrinter.h\"\n #include \"llvm/IR/GlobalVariable.h\"\n #include \"llvm/IR/Instructions.h\"\n+#include \"llvm/IR/Intrinsics.h\"\n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/Bitcode/BitcodeWriterPass.h\"\n@@ -1364,6 +1365,11 @@ extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n       unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles));\n }\n \n+extern \"C\" LLVMValueRef LLVMRustGetInstrprofIncrementIntrinsic(LLVMModuleRef M) {\n+  return wrap(llvm::Intrinsic::getDeclaration(unwrap(M),\n+              (llvm::Intrinsic::ID)llvm::Intrinsic::instrprof_increment));\n+}\n+\n extern \"C\" LLVMValueRef LLVMRustBuildMemCpy(LLVMBuilderRef B,\n                                             LLVMValueRef Dst, unsigned DstAlign,\n                                             LLVMValueRef Src, unsigned SrcAlign,"}, {"sha": "25195743b04007360ab92f5e8cf6d337ee021333", "filename": "src/test/codegen-units/partitioning/compiler-builtins.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7ef9eb321a0e3acf350af3866041ba75251d2884/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fcompiler-builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef9eb321a0e3acf350af3866041ba75251d2884/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fcompiler-builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fcompiler-builtins.rs?ref=7ef9eb321a0e3acf350af3866041ba75251d2884", "patch": "@@ -1,40 +0,0 @@\n-// Verifies that during compiler_builtins compilation the codegen units are kept\n-// unmerged. Even when only a single codegen unit is requested with -Ccodegen-units=1.\n-//\n-// compile-flags: -Zprint-mono-items=eager -Ccodegen-units=1\n-\n-#![compiler_builtins]\n-#![crate_type=\"lib\"]\n-#![feature(compiler_builtins)]\n-\n-mod atomics {\n-    //~ MONO_ITEM fn compiler_builtins::atomics[0]::sync_1[0] @@ compiler_builtins-cgu.0[External]\n-    #[no_mangle]\n-    pub extern \"C\" fn sync_1() {}\n-\n-    //~ MONO_ITEM fn compiler_builtins::atomics[0]::sync_2[0] @@ compiler_builtins-cgu.0[External]\n-    #[no_mangle]\n-    pub extern \"C\" fn sync_2() {}\n-\n-    //~ MONO_ITEM fn compiler_builtins::atomics[0]::sync_3[0] @@ compiler_builtins-cgu.0[External]\n-    #[no_mangle]\n-    pub extern \"C\" fn sync_3() {}\n-}\n-\n-mod x {\n-    //~ MONO_ITEM fn compiler_builtins::x[0]::x[0] @@ compiler_builtins-cgu.1[External]\n-    #[no_mangle]\n-    pub extern \"C\" fn x() {}\n-}\n-\n-mod y {\n-    //~ MONO_ITEM fn compiler_builtins::y[0]::y[0] @@ compiler_builtins-cgu.2[External]\n-    #[no_mangle]\n-    pub extern \"C\" fn y() {}\n-}\n-\n-mod z {\n-    //~ MONO_ITEM fn compiler_builtins::z[0]::z[0] @@ compiler_builtins-cgu.3[External]\n-    #[no_mangle]\n-    pub extern \"C\" fn z() {}\n-}"}, {"sha": "519be6b6a99a43d2d870ee6dfcad1117f264a753", "filename": "src/test/codegen/cdylib-external-inline-fns.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fcdylib-external-inline-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fcdylib-external-inline-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcdylib-external-inline-fns.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,43 @@\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"cdylib\"]\n+\n+// CHECK: define void @a()\n+#[no_mangle]\n+#[inline]\n+pub extern \"C\" fn a() {}\n+\n+// CHECK: define void @b()\n+#[export_name = \"b\"]\n+#[inline]\n+pub extern \"C\" fn b() {}\n+\n+// CHECK: define void @c()\n+#[no_mangle]\n+#[inline]\n+extern \"C\" fn c() {}\n+\n+// CHECK: define void @d()\n+#[export_name = \"d\"]\n+#[inline]\n+extern \"C\" fn d() {}\n+\n+// CHECK: define void @e()\n+#[no_mangle]\n+#[inline(always)]\n+pub extern \"C\" fn e() {}\n+\n+// CHECK: define void @f()\n+#[export_name = \"f\"]\n+#[inline(always)]\n+pub extern \"C\" fn f() {}\n+\n+// CHECK: define void @g()\n+#[no_mangle]\n+#[inline(always)]\n+extern \"C\" fn g() {}\n+\n+// CHECK: define void @h()\n+#[export_name = \"h\"]\n+#[inline(always)]\n+extern \"C\" fn h() {}"}, {"sha": "59e97601c838d6427d6e741e1a91aa97aa64b8cc", "filename": "src/test/codegen/export-no-mangle.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fexport-no-mangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fexport-no-mangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fexport-no-mangle.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -11,11 +11,21 @@ mod private {\n     #[export_name = \"BAR\"]\n     static BAR: u32 = 3;\n \n-    // CHECK: void @foo()\n+    // CHECK: void @a()\n     #[no_mangle]\n-    pub extern fn foo() {}\n+    pub extern fn a() {}\n \n-    // CHECK: void @bar()\n-    #[export_name = \"bar\"]\n-    extern fn bar() {}\n+    // CHECK: void @b()\n+    #[export_name = \"b\"]\n+    extern fn b() {}\n+\n+    // CHECK: void @c()\n+    #[export_name = \"c\"]\n+    #[inline]\n+    extern fn c() {}\n+\n+    // CHECK: void @d()\n+    #[export_name = \"d\"]\n+    #[inline(always)]\n+    extern fn d() {}\n }"}, {"sha": "41820b057f1ef27710bf098403d3829daee3dac8", "filename": "src/test/codegen/external-no-mangle-fns.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fexternal-no-mangle-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fexternal-no-mangle-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fexternal-no-mangle-fns.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -53,3 +53,23 @@ fn x() {\n         core::ptr::read_volatile(&42);\n     }\n }\n+\n+// CHECK: define void @i()\n+#[no_mangle]\n+#[inline]\n+fn i() {}\n+\n+// CHECK: define void @j()\n+#[no_mangle]\n+#[inline]\n+pub fn j() {}\n+\n+// CHECK: define void @k()\n+#[no_mangle]\n+#[inline(always)]\n+fn k() {}\n+\n+// CHECK: define void @l()\n+#[no_mangle]\n+#[inline(always)]\n+pub fn l() {}"}, {"sha": "8ade583b5712732466153f2161f43fa49d0d7141", "filename": "src/test/codegen/issue-69101-bounds-check.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fissue-69101-bounds-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fissue-69101-bounds-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-69101-bounds-check.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,44 @@\n+// no-system-llvm\n+// compile-flags: -O\n+// ignore-debug: the debug assertions get in the way\n+#![crate_type = \"lib\"]\n+\n+// Make sure no bounds checks are emitted in the loop when upfront slicing\n+// ensures that the slices are big enough.\n+// In particular, bounds checks were not always optimized out if the upfront\n+// check was for a greater len than the loop requires.\n+// (i.e. `already_sliced_no_bounds_check` was not always optimized even when\n+// `already_sliced_no_bounds_check_exact` was)\n+// CHECK-LABEL: @already_sliced_no_bounds_check\n+#[no_mangle]\n+pub fn already_sliced_no_bounds_check(a: &[u8], b: &[u8], c: &mut [u8]) {\n+    // CHECK: slice_index_len_fail\n+    // CHECK-NOT: panic_bounds_check\n+    let _ = (&a[..2048], &b[..2048], &mut c[..2048]);\n+    for i in 0..1024 {\n+        c[i] = a[i] ^ b[i];\n+    }\n+}\n+\n+// CHECK-LABEL: @already_sliced_no_bounds_check_exact\n+#[no_mangle]\n+pub fn already_sliced_no_bounds_check_exact(a: &[u8], b: &[u8], c: &mut [u8]) {\n+    // CHECK: slice_index_len_fail\n+    // CHECK-NOT: panic_bounds_check\n+    let _ = (&a[..1024], &b[..1024], &mut c[..1024]);\n+    for i in 0..1024 {\n+        c[i] = a[i] ^ b[i];\n+    }\n+}\n+\n+// Make sure we're checking for the right thing: there can be a panic if the slice is too small.\n+// CHECK-LABEL: @already_sliced_bounds_check\n+#[no_mangle]\n+pub fn already_sliced_bounds_check(a: &[u8], b: &[u8], c: &mut [u8]) {\n+    // CHECK: slice_index_len_fail\n+    // CHECK: panic_bounds_check\n+    let _ = (&a[..1023], &b[..2048], &mut c[..2048]);\n+    for i in 0..1024 {\n+        c[i] = a[i] ^ b[i];\n+    }\n+}"}, {"sha": "4bd50508d152056e13f7ecc21d80055ab00a6a45", "filename": "src/test/codegen/sanitizer-memory-track-orgins.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,9 +1,7 @@\n // Verifies that MemorySanitizer track-origins level can be controlled\n // with -Zsanitizer-memory-track-origins option.\n //\n-// needs-sanitizer-support\n-// only-linux\n-// only-x86_64\n+// needs-sanitizer-memory\n // revisions:MSAN-0 MSAN-1 MSAN-2 MSAN-1-LTO MSAN-2-LTO\n //\n //[MSAN-0] compile-flags: -Zsanitizer=memory"}, {"sha": "be0547afa4cd5059432123f54ab40db0549d9e94", "filename": "src/test/codegen/sanitizer-no-sanitize-inlining.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,19 +1,17 @@\n // Verifies that no_sanitize attribute prevents inlining when\n // given sanitizer is enabled, but has no effect on inlining otherwise.\n //\n-// needs-sanitizer-support\n-// only-x86_64\n-//\n+// needs-sanitizer-address\n+// needs-sanitizer-leak\n // revisions: ASAN LSAN\n-//\n //[ASAN] compile-flags: -Zsanitizer=address -C opt-level=3 -Z mir-opt-level=3\n //[LSAN] compile-flags: -Zsanitizer=leak    -C opt-level=3 -Z mir-opt-level=3\n \n #![crate_type=\"lib\"]\n #![feature(no_sanitize)]\n \n // ASAN-LABEL: define void @test\n-// ASAN:         tail call fastcc void @random_inline\n+// ASAN:         call {{.*}} @random_inline\n // ASAN:       }\n //\n // LSAN-LABEL: define void @test"}, {"sha": "1b2b18822e63e8a8c673166bcb92bd0fdb99ac2f", "filename": "src/test/codegen/sanitizer-no-sanitize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,7 +1,7 @@\n // Verifies that no_sanitze attribute can be used to\n // selectively disable sanitizer instrumentation.\n //\n-// needs-sanitizer-support\n+// needs-sanitizer-address\n // compile-flags: -Zsanitizer=address\n \n #![crate_type=\"lib\"]"}, {"sha": "719f219ce4ef1b9fe8cc0c1830309d352b9f142b", "filename": "src/test/codegen/sanitizer-recover.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,9 +1,8 @@\n // Verifies that AddressSanitizer and MemorySanitizer\n // recovery mode can be enabled with -Zsanitizer-recover.\n //\n-// needs-sanitizer-support\n-// only-linux\n-// only-x86_64\n+// needs-sanitizer-address\n+// needs-sanitizer-memory\n // revisions:ASAN ASAN-RECOVER MSAN MSAN-RECOVER MSAN-RECOVER-LTO\n // no-prefer-dynamic\n //"}, {"sha": "8876ab7376afe3ce5ca7b7c400c86251efae375e", "filename": "src/test/codegen/staticlib-external-inline-fns.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fstaticlib-external-inline-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fstaticlib-external-inline-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstaticlib-external-inline-fns.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,43 @@\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"staticlib\"]\n+\n+// CHECK: define void @a()\n+#[no_mangle]\n+#[inline]\n+pub extern \"C\" fn a() {}\n+\n+// CHECK: define void @b()\n+#[export_name = \"b\"]\n+#[inline]\n+pub extern \"C\" fn b() {}\n+\n+// CHECK: define void @c()\n+#[no_mangle]\n+#[inline]\n+extern \"C\" fn c() {}\n+\n+// CHECK: define void @d()\n+#[export_name = \"d\"]\n+#[inline]\n+extern \"C\" fn d() {}\n+\n+// CHECK: define void @e()\n+#[no_mangle]\n+#[inline(always)]\n+pub extern \"C\" fn e() {}\n+\n+// CHECK: define void @f()\n+#[export_name = \"f\"]\n+#[inline(always)]\n+pub extern \"C\" fn f() {}\n+\n+// CHECK: define void @g()\n+#[no_mangle]\n+#[inline(always)]\n+extern \"C\" fn g() {}\n+\n+// CHECK: define void @h()\n+#[export_name = \"h\"]\n+#[inline(always)]\n+extern \"C\" fn h() {}"}, {"sha": "15bfe421e9d35911d8e1f4ad05e3187e4fb644bd", "filename": "src/test/codegen/vec-clear.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fvec-clear.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fvec-clear.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-clear.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,4 +1,3 @@\n-// ignore-debug: the debug assertions get in the way\n // compile-flags: -O\n \n #![crate_type = \"lib\"]"}, {"sha": "9143fad23408749b278aef4eb428397195a4db1d", "filename": "src/test/codegen/vec-optimizes-away.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fvec-optimizes-away.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fcodegen%2Fvec-optimizes-away.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-optimizes-away.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,4 +1,3 @@\n-//\n // ignore-debug: the debug assertions get in the way\n // no-system-llvm\n // compile-flags: -O"}, {"sha": "13e8eb3e44e1aeb03471c8e2506a38b054bd7601", "filename": "src/test/mir-opt/const_prop/discriminant.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,5 +1,10 @@\n // compile-flags: -O\n \n+// FIXME(wesleywiser): Ideally, we could const-prop away all of this and just be left with\n+// `let x = 42` but that doesn't work because const-prop doesn't support `Operand::Indirect`\n+// and `InterpCx::eval_place()` always forces an allocation which creates the `Indirect`.\n+// Fixing either of those will allow us to const-prop this away.\n+\n // EMIT_MIR_FOR_EACH_BIT_WIDTH\n // EMIT_MIR rustc.main.ConstProp.diff\n fn main() {"}, {"sha": "1c873f53f378a1fa4962928eac7be68df58490c8", "filename": "src/test/mir-opt/const_prop/discriminant/32bit/rustc.main.ConstProp.diff", "status": "modified", "additions": 34, "deletions": 41, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant%2F32bit%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant%2F32bit%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant%2F32bit%2Frustc.main.ConstProp.diff?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,100 +2,93 @@\n + // MIR for `main` after ConstProp\n   \n   fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/discriminant.rs:5:11: 5:11\n-      let _1: i32;                         // in scope 0 at $DIR/discriminant.rs:6:9: 6:10\n-      let mut _2: i32;                     // in scope 0 at $DIR/discriminant.rs:6:13: 6:64\n-      let mut _3: std::option::Option<bool>; // in scope 0 at $DIR/discriminant.rs:6:34: 6:44\n-      let mut _4: isize;                   // in scope 0 at $DIR/discriminant.rs:6:21: 6:31\n+      let mut _0: ();                      // return place in scope 0 at $DIR/discriminant.rs:10:11: 10:11\n+      let _1: i32;                         // in scope 0 at $DIR/discriminant.rs:11:9: 11:10\n+      let mut _2: i32;                     // in scope 0 at $DIR/discriminant.rs:11:13: 11:64\n+      let mut _3: std::option::Option<bool>; // in scope 0 at $DIR/discriminant.rs:11:34: 11:44\n+      let mut _4: isize;                   // in scope 0 at $DIR/discriminant.rs:11:21: 11:31\n       scope 1 {\n-          debug x => _1;                   // in scope 1 at $DIR/discriminant.rs:6:9: 6:10\n+          debug x => _1;                   // in scope 1 at $DIR/discriminant.rs:11:9: 11:10\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/discriminant.rs:6:9: 6:10\n-          StorageLive(_2);                 // scope 0 at $DIR/discriminant.rs:6:13: 6:64\n-          StorageLive(_3);                 // scope 0 at $DIR/discriminant.rs:6:34: 6:44\n--         _3 = std::option::Option::<bool>::Some(const true); // scope 0 at $DIR/discriminant.rs:6:34: 6:44\n-+         _3 = const std::option::Option::<bool>::Some(true); // scope 0 at $DIR/discriminant.rs:6:34: 6:44\n+          StorageLive(_1);                 // scope 0 at $DIR/discriminant.rs:11:9: 11:10\n+          StorageLive(_2);                 // scope 0 at $DIR/discriminant.rs:11:13: 11:64\n+          StorageLive(_3);                 // scope 0 at $DIR/discriminant.rs:11:34: 11:44\n+-         _3 = std::option::Option::<bool>::Some(const true); // scope 0 at $DIR/discriminant.rs:11:34: 11:44\n++         _3 = const std::option::Option::<bool>::Some(true); // scope 0 at $DIR/discriminant.rs:11:34: 11:44\n                                            // ty::Const\n -                                          // + ty: bool\n +                                          // + ty: std::option::Option<bool>\n                                            // + val: Value(Scalar(0x01))\n                                            // mir::Constant\n--                                          // + span: $DIR/discriminant.rs:6:39: 6:43\n+-                                          // + span: $DIR/discriminant.rs:11:39: 11:43\n -                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n--         _4 = discriminant(_3);           // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n--         switchInt(move _4) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n-+                                          // + span: $DIR/discriminant.rs:6:34: 6:44\n+-         _4 = discriminant(_3);           // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n+-         switchInt(move _4) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n++                                          // + span: $DIR/discriminant.rs:11:34: 11:44\n +                                          // + literal: Const { ty: std::option::Option<bool>, val: Value(Scalar(0x01)) }\n-+         _4 = const 1isize;               // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n++         _4 = const 1isize;               // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n +                                          // ty::Const\n +                                          // + ty: isize\n +                                          // + val: Value(Scalar(0x00000001))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:6:21: 6:31\n++                                          // + span: $DIR/discriminant.rs:11:21: 11:31\n +                                          // + literal: Const { ty: isize, val: Value(Scalar(0x00000001)) }\n-+         switchInt(const 1isize) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n++         switchInt(const 1isize) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n +                                          // ty::Const\n +                                          // + ty: isize\n +                                          // + val: Value(Scalar(0x00000001))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:6:21: 6:31\n++                                          // + span: $DIR/discriminant.rs:11:21: 11:31\n +                                          // + literal: Const { ty: isize, val: Value(Scalar(0x00000001)) }\n       }\n   \n       bb1: {\n-          _2 = const 10i32;                // scope 0 at $DIR/discriminant.rs:6:59: 6:61\n+          _2 = const 10i32;                // scope 0 at $DIR/discriminant.rs:11:59: 11:61\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000000a))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:6:59: 6:61\n+                                           // + span: $DIR/discriminant.rs:11:59: 11:61\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000000a)) }\n-          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:6:13: 6:64\n+          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:11:13: 11:64\n       }\n   \n       bb2: {\n--         switchInt(((_3 as Some).0: bool)) -> [false: bb1, otherwise: bb3]; // scope 0 at $DIR/discriminant.rs:6:26: 6:30\n-+         switchInt(const true) -> [false: bb1, otherwise: bb3]; // scope 0 at $DIR/discriminant.rs:6:26: 6:30\n-+                                          // ty::Const\n-+                                          // + ty: bool\n-+                                          // + val: Value(Scalar(0x01))\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:6:26: 6:30\n-+                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          switchInt(((_3 as Some).0: bool)) -> [false: bb1, otherwise: bb3]; // scope 0 at $DIR/discriminant.rs:11:26: 11:30\n       }\n   \n       bb3: {\n-          _2 = const 42i32;                // scope 0 at $DIR/discriminant.rs:6:47: 6:49\n+          _2 = const 42i32;                // scope 0 at $DIR/discriminant.rs:11:47: 11:49\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000002a))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:6:47: 6:49\n+                                           // + span: $DIR/discriminant.rs:11:47: 11:49\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000002a)) }\n-          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:6:13: 6:64\n+          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:11:13: 11:64\n       }\n   \n       bb4: {\n-          _1 = Add(move _2, const 0i32);   // scope 0 at $DIR/discriminant.rs:6:13: 6:68\n+          _1 = Add(move _2, const 0i32);   // scope 0 at $DIR/discriminant.rs:11:13: 11:68\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x00000000))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:6:67: 6:68\n+                                           // + span: $DIR/discriminant.rs:11:67: 11:68\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x00000000)) }\n-          StorageDead(_2);                 // scope 0 at $DIR/discriminant.rs:6:67: 6:68\n-          StorageDead(_3);                 // scope 0 at $DIR/discriminant.rs:6:68: 6:69\n-          _0 = const ();                   // scope 0 at $DIR/discriminant.rs:5:11: 7:2\n+          StorageDead(_2);                 // scope 0 at $DIR/discriminant.rs:11:67: 11:68\n+          StorageDead(_3);                 // scope 0 at $DIR/discriminant.rs:11:68: 11:69\n+          _0 = const ();                   // scope 0 at $DIR/discriminant.rs:10:11: 12:2\n                                            // ty::Const\n                                            // + ty: ()\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:5:11: 7:2\n+                                           // + span: $DIR/discriminant.rs:10:11: 12:2\n                                            // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-          StorageDead(_1);                 // scope 0 at $DIR/discriminant.rs:7:1: 7:2\n-          return;                          // scope 0 at $DIR/discriminant.rs:7:2: 7:2\n+          StorageDead(_1);                 // scope 0 at $DIR/discriminant.rs:12:1: 12:2\n+          return;                          // scope 0 at $DIR/discriminant.rs:12:2: 12:2\n       }\n   }\n   "}, {"sha": "75b4b7e5a62bab836ca891969e06599a1278a3fd", "filename": "src/test/mir-opt/const_prop/discriminant/64bit/rustc.main.ConstProp.diff", "status": "modified", "additions": 34, "deletions": 41, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant%2F64bit%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant%2F64bit%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant%2F64bit%2Frustc.main.ConstProp.diff?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,100 +2,93 @@\n + // MIR for `main` after ConstProp\n   \n   fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/discriminant.rs:5:11: 5:11\n-      let _1: i32;                         // in scope 0 at $DIR/discriminant.rs:6:9: 6:10\n-      let mut _2: i32;                     // in scope 0 at $DIR/discriminant.rs:6:13: 6:64\n-      let mut _3: std::option::Option<bool>; // in scope 0 at $DIR/discriminant.rs:6:34: 6:44\n-      let mut _4: isize;                   // in scope 0 at $DIR/discriminant.rs:6:21: 6:31\n+      let mut _0: ();                      // return place in scope 0 at $DIR/discriminant.rs:10:11: 10:11\n+      let _1: i32;                         // in scope 0 at $DIR/discriminant.rs:11:9: 11:10\n+      let mut _2: i32;                     // in scope 0 at $DIR/discriminant.rs:11:13: 11:64\n+      let mut _3: std::option::Option<bool>; // in scope 0 at $DIR/discriminant.rs:11:34: 11:44\n+      let mut _4: isize;                   // in scope 0 at $DIR/discriminant.rs:11:21: 11:31\n       scope 1 {\n-          debug x => _1;                   // in scope 1 at $DIR/discriminant.rs:6:9: 6:10\n+          debug x => _1;                   // in scope 1 at $DIR/discriminant.rs:11:9: 11:10\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/discriminant.rs:6:9: 6:10\n-          StorageLive(_2);                 // scope 0 at $DIR/discriminant.rs:6:13: 6:64\n-          StorageLive(_3);                 // scope 0 at $DIR/discriminant.rs:6:34: 6:44\n--         _3 = std::option::Option::<bool>::Some(const true); // scope 0 at $DIR/discriminant.rs:6:34: 6:44\n-+         _3 = const std::option::Option::<bool>::Some(true); // scope 0 at $DIR/discriminant.rs:6:34: 6:44\n+          StorageLive(_1);                 // scope 0 at $DIR/discriminant.rs:11:9: 11:10\n+          StorageLive(_2);                 // scope 0 at $DIR/discriminant.rs:11:13: 11:64\n+          StorageLive(_3);                 // scope 0 at $DIR/discriminant.rs:11:34: 11:44\n+-         _3 = std::option::Option::<bool>::Some(const true); // scope 0 at $DIR/discriminant.rs:11:34: 11:44\n++         _3 = const std::option::Option::<bool>::Some(true); // scope 0 at $DIR/discriminant.rs:11:34: 11:44\n                                            // ty::Const\n -                                          // + ty: bool\n +                                          // + ty: std::option::Option<bool>\n                                            // + val: Value(Scalar(0x01))\n                                            // mir::Constant\n--                                          // + span: $DIR/discriminant.rs:6:39: 6:43\n+-                                          // + span: $DIR/discriminant.rs:11:39: 11:43\n -                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n--         _4 = discriminant(_3);           // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n--         switchInt(move _4) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n-+                                          // + span: $DIR/discriminant.rs:6:34: 6:44\n+-         _4 = discriminant(_3);           // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n+-         switchInt(move _4) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n++                                          // + span: $DIR/discriminant.rs:11:34: 11:44\n +                                          // + literal: Const { ty: std::option::Option<bool>, val: Value(Scalar(0x01)) }\n-+         _4 = const 1isize;               // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n++         _4 = const 1isize;               // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n +                                          // ty::Const\n +                                          // + ty: isize\n +                                          // + val: Value(Scalar(0x0000000000000001))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:6:21: 6:31\n++                                          // + span: $DIR/discriminant.rs:11:21: 11:31\n +                                          // + literal: Const { ty: isize, val: Value(Scalar(0x0000000000000001)) }\n-+         switchInt(const 1isize) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n++         switchInt(const 1isize) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n +                                          // ty::Const\n +                                          // + ty: isize\n +                                          // + val: Value(Scalar(0x0000000000000001))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:6:21: 6:31\n++                                          // + span: $DIR/discriminant.rs:11:21: 11:31\n +                                          // + literal: Const { ty: isize, val: Value(Scalar(0x0000000000000001)) }\n       }\n   \n       bb1: {\n-          _2 = const 10i32;                // scope 0 at $DIR/discriminant.rs:6:59: 6:61\n+          _2 = const 10i32;                // scope 0 at $DIR/discriminant.rs:11:59: 11:61\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000000a))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:6:59: 6:61\n+                                           // + span: $DIR/discriminant.rs:11:59: 11:61\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000000a)) }\n-          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:6:13: 6:64\n+          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:11:13: 11:64\n       }\n   \n       bb2: {\n--         switchInt(((_3 as Some).0: bool)) -> [false: bb1, otherwise: bb3]; // scope 0 at $DIR/discriminant.rs:6:26: 6:30\n-+         switchInt(const true) -> [false: bb1, otherwise: bb3]; // scope 0 at $DIR/discriminant.rs:6:26: 6:30\n-+                                          // ty::Const\n-+                                          // + ty: bool\n-+                                          // + val: Value(Scalar(0x01))\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:6:26: 6:30\n-+                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          switchInt(((_3 as Some).0: bool)) -> [false: bb1, otherwise: bb3]; // scope 0 at $DIR/discriminant.rs:11:26: 11:30\n       }\n   \n       bb3: {\n-          _2 = const 42i32;                // scope 0 at $DIR/discriminant.rs:6:47: 6:49\n+          _2 = const 42i32;                // scope 0 at $DIR/discriminant.rs:11:47: 11:49\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000002a))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:6:47: 6:49\n+                                           // + span: $DIR/discriminant.rs:11:47: 11:49\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000002a)) }\n-          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:6:13: 6:64\n+          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:11:13: 11:64\n       }\n   \n       bb4: {\n-          _1 = Add(move _2, const 0i32);   // scope 0 at $DIR/discriminant.rs:6:13: 6:68\n+          _1 = Add(move _2, const 0i32);   // scope 0 at $DIR/discriminant.rs:11:13: 11:68\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x00000000))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:6:67: 6:68\n+                                           // + span: $DIR/discriminant.rs:11:67: 11:68\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x00000000)) }\n-          StorageDead(_2);                 // scope 0 at $DIR/discriminant.rs:6:67: 6:68\n-          StorageDead(_3);                 // scope 0 at $DIR/discriminant.rs:6:68: 6:69\n-          _0 = const ();                   // scope 0 at $DIR/discriminant.rs:5:11: 7:2\n+          StorageDead(_2);                 // scope 0 at $DIR/discriminant.rs:11:67: 11:68\n+          StorageDead(_3);                 // scope 0 at $DIR/discriminant.rs:11:68: 11:69\n+          _0 = const ();                   // scope 0 at $DIR/discriminant.rs:10:11: 12:2\n                                            // ty::Const\n                                            // + ty: ()\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:5:11: 7:2\n+                                           // + span: $DIR/discriminant.rs:10:11: 12:2\n                                            // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-          StorageDead(_1);                 // scope 0 at $DIR/discriminant.rs:7:1: 7:2\n-          return;                          // scope 0 at $DIR/discriminant.rs:7:2: 7:2\n+          StorageDead(_1);                 // scope 0 at $DIR/discriminant.rs:12:1: 12:2\n+          return;                          // scope 0 at $DIR/discriminant.rs:12:2: 12:2\n       }\n   }\n   "}, {"sha": "3fe010ef68fc351abe2709c2560fdcb5ddf5e3c3", "filename": "src/test/mir-opt/instrument_coverage.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,20 @@\n+// Test that the initial version of Rust coverage injects count_code_region() placeholder calls,\n+// at the top of each function. The placeholders are later converted into LLVM instrprof.increment\n+// intrinsics, during codegen.\n+\n+// needs-profiler-support\n+// compile-flags: -Zinstrument-coverage\n+// EMIT_MIR rustc.main.InstrumentCoverage.diff\n+// EMIT_MIR rustc.bar.InstrumentCoverage.diff\n+fn main() {\n+    loop {\n+        if bar() {\n+            break;\n+        }\n+    }\n+}\n+\n+#[inline(never)]\n+fn bar() -> bool {\n+    true\n+}"}, {"sha": "1e64379aa0e4b6a311e2a3aed3bd63de11cacde0", "filename": "src/test/mir-opt/instrument_coverage/rustc.bar.InstrumentCoverage.diff", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,41 @@\n+- // MIR for `bar` before InstrumentCoverage\n++ // MIR for `bar` after InstrumentCoverage\n+  \n+  fn bar() -> bool {\n+      let mut _0: bool;                    // return place in scope 0 at $DIR/instrument_coverage.rs:18:13: 18:17\n++     let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n+  \n+      bb0: {\n++         StorageLive(_1);                 // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++         _1 = const std::intrinsics::count_code_region(const 0u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++                                          // ty::Const\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}\n++                                          // + val: Value(Scalar(<ZST>))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000000))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n++     }\n++ \n++     bb1 (cleanup): {\n++         resume;                          // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++     }\n++ \n++     bb2: {\n++         StorageDead(_1);                 // scope 0 at $DIR/instrument_coverage.rs:19:5: 19:9\n+          _0 = const true;                 // scope 0 at $DIR/instrument_coverage.rs:19:5: 19:9\n+                                           // ty::Const\n+                                           // + ty: bool\n+                                           // + val: Value(Scalar(0x01))\n+                                           // mir::Constant\n+                                           // + span: $DIR/instrument_coverage.rs:19:5: 19:9\n+                                           // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          return;                          // scope 0 at $DIR/instrument_coverage.rs:20:2: 20:2\n+      }\n+  }\n+  "}, {"sha": "82d21467827ebbcb1f35adbf7a2e57b11b3caf39", "filename": "src/test/mir-opt/instrument_coverage/rustc.main.InstrumentCoverage.diff", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,82 @@\n+- // MIR for `main` before InstrumentCoverage\n++ // MIR for `main` after InstrumentCoverage\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n+      let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n+      let mut _2: bool;                    // in scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+      let mut _3: !;                       // in scope 0 at $DIR/instrument_coverage.rs:11:18: 13:10\n++     let mut _4: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n+  \n+      bb0: {\n+-         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n++         StorageLive(_4);                 // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n++         _4 = const std::intrinsics::count_code_region(const 0u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n++                                          // ty::Const\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}\n++                                          // + val: Value(Scalar(<ZST>))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000000))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n+      }\n+  \n+      bb1: {\n+          StorageLive(_2);                 // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+          _2 = const bar() -> [return: bb3, unwind: bb2]; // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+                                           // ty::Const\n+                                           // + ty: fn() -> bool {bar}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/instrument_coverage.rs:11:12: 11:15\n+                                           // + literal: Const { ty: fn() -> bool {bar}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb2 (cleanup): {\n+          resume;                          // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n+      }\n+  \n+      bb3: {\n+          FakeRead(ForMatchedPlace, _2);   // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+          switchInt(_2) -> [false: bb5, otherwise: bb4]; // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+      }\n+  \n+      bb4: {\n+          falseEdge -> [real: bb6, imaginary: bb5]; // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+      }\n+  \n+      bb5: {\n+          _1 = const ();                   // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/instrument_coverage.rs:11:9: 13:10\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 0 at $DIR/instrument_coverage.rs:14:5: 14:6\n+          goto -> bb0;                     // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n+      }\n+  \n+      bb6: {\n+          _0 = const ();                   // scope 0 at $DIR/instrument_coverage.rs:12:13: 12:18\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/instrument_coverage.rs:12:13: 12:18\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 0 at $DIR/instrument_coverage.rs:14:5: 14:6\n+          return;                          // scope 0 at $DIR/instrument_coverage.rs:15:2: 15:2\n++     }\n++ \n++     bb7: {\n++         StorageDead(_4);                 // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n++         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n+      }\n+  }\n+  "}, {"sha": "b11d4c4cab7cf54c5f1f5de18a50cf3b15372149", "filename": "src/test/run-make-fulldeps/sanitizer-cdylib-link/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-cdylib-link%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-cdylib-link%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-cdylib-link%2FMakefile?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,5 +1,5 @@\n # needs-sanitizer-support\n-# only-x86_64\n+# needs-sanitizer-address\n # only-linux\n \n -include ../tools.mk"}, {"sha": "c2ebd2a6d8cacbf49ad9c02f92ec1f3e8252b448", "filename": "src/test/run-make-fulldeps/sanitizer-dylib-link/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-dylib-link%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-dylib-link%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-dylib-link%2FMakefile?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,5 +1,5 @@\n # needs-sanitizer-support\n-# only-x86_64\n+# needs-sanitizer-address\n # only-linux\n \n -include ../tools.mk"}, {"sha": "5ceff16471cee99fde034adabf0d53e8fadd9eeb", "filename": "src/test/run-make-fulldeps/sanitizer-staticlib-link/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-staticlib-link%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-staticlib-link%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-staticlib-link%2FMakefile?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,5 +1,5 @@\n # needs-sanitizer-support\n-# only-x86_64\n+# needs-sanitizer-address\n # only-linux\n \n -include ../tools.mk"}, {"sha": "1d3cc82138927a1018c97a10d2814b05814a6602", "filename": "src/test/run-make/static-pie/Makefile", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frun-make%2Fstatic-pie%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frun-make%2Fstatic-pie%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstatic-pie%2FMakefile?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,15 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+# only-x86_64-unknown-linux-musl\n+\n+# How to manually run this\n+# $ ./x.py test --target x86_64-unknown-linux-musl src/test/run-make/static-pie\n+\n+all:\n+\t$(RUSTC) --target $(TARGET) -C target-feature=+crt-static test-aslr.rs\n+\t# Check that no dynamic interpreter is set\n+\t! readelf -l $(call RUN_BINFILE,test-aslr) | $(CGREP) INTERP\n+\t# Check that we have a dynamic executable\n+\treadelf -l $(call RUN_BINFILE,test-aslr) | $(CGREP) DYNAMIC\n+\t# Check for address space layout randomization\n+\t$(call RUN,test-aslr) --test-aslr"}, {"sha": "f28e00f7f4cf93825df45defa08944b1fee17251", "filename": "src/test/run-make/static-pie/test-aslr.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frun-make%2Fstatic-pie%2Ftest-aslr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frun-make%2Fstatic-pie%2Ftest-aslr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstatic-pie%2Ftest-aslr.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,43 @@\n+const NUM_RUNS: usize = 10;\n+\n+fn run_self(exe: &str) -> usize {\n+    use std::process::Command;\n+    let mut set = std::collections::HashSet::new();\n+\n+    let mut cmd = Command::new(exe);\n+    cmd.arg(\"--report\");\n+    (0..NUM_RUNS).for_each(|_| {\n+        set.insert(cmd.output().expect(\"failed to execute process\").stdout);\n+    });\n+    set.len()\n+}\n+\n+fn main() {\n+    let mut args = std::env::args();\n+    let arg0 = args.next().unwrap();\n+    match args.next() {\n+        Some(s) if s.eq(\"--report\") => {\n+            println!(\"main = {:#?}\", &main as *const _);\n+        }\n+        Some(s) if s.eq(\"--test-no-aslr\") => {\n+            let cnt = run_self(&arg0);\n+            if cnt != 1 {\n+                eprintln!(\"FAIL: {} most likely ASLR\", arg0);\n+                std::process::exit(1);\n+            }\n+            println!(\"PASS: {} does no ASLR\", arg0);\n+        }\n+        Some(s) if s.eq(\"--test-aslr\") => {\n+            let cnt = run_self(&arg0);\n+            if cnt != NUM_RUNS {\n+                eprintln!(\"FAIL: {} most likely no ASLR\", arg0);\n+                std::process::exit(1);\n+            }\n+            println!(\"PASS: {} does ASLR\", arg0);\n+        }\n+        Some(_) | None => {\n+            println!(\"Usage: {} --test-no-aslr | --test-aslr\", arg0);\n+            std::process::exit(1);\n+        }\n+    }\n+}"}, {"sha": "b59b21111b009740350b5f5db4a6a1d941a3a231", "filename": "src/test/rustdoc/codeblock-title.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frustdoc%2Fcodeblock-title.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frustdoc%2Fcodeblock-title.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcodeblock-title.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -4,6 +4,7 @@\n \n // @has foo/fn.bar.html '//*[@class=\"tooltip compile_fail\"]/span' \"This example deliberately fails to compile\"\n // @has foo/fn.bar.html '//*[@class=\"tooltip ignore\"]/span' \"This example is not tested\"\n+// @has foo/fn.bar.html '//*[@class=\"tooltip should_panic\"]/span' \"This example panics\"\n \n /// foo\n ///\n@@ -15,6 +16,10 @@\n /// goo();\n /// ```\n ///\n+/// ```should_panic\n+/// hoo();\n+/// ```\n+///\n /// ```\n /// let x = 0;\n /// ```"}, {"sha": "a79b37ee08210717c27c9f278f7aac0402992e09", "filename": "src/test/rustdoc/sanitizer-option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frustdoc%2Fsanitizer-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Frustdoc%2Fsanitizer-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsanitizer-option.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,4 +1,5 @@\n // needs-sanitizer-support\n+// needs-sanitizer-address\n // compile-flags: --test -Z sanitizer=address\n //\n // #43031: Verify that rustdoc passes `-Z` options to rustc. Use an extern"}, {"sha": "973294e985f7a45a65e4c99e946bf31df508dd52", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -37,7 +37,7 @@ fn main() {\n         TyKind::Bound(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Placeholder(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Infer(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Error => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Error(_) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n     }\n \n     if let ty::Int(int_ty) = kind {}"}, {"sha": "d6e4c85c190d5af36da784f4a5ddcb52b7a87394", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -169,7 +169,7 @@ LL |         TyKind::Infer(..) => (),\n error: usage of `ty::TyKind::<kind>`\n   --> $DIR/ty_tykind_usage.rs:40:9\n    |\n-LL |         TyKind::Error => (),\n+LL |         TyKind::Error(_) => (),\n    |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`"}, {"sha": "53a45cf4e4f4db2763635182c1f60372cdfa9bab", "filename": "src/test/ui/associated-types/associated-types-eq-1.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-1.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -4,7 +4,16 @@ error[E0412]: cannot find type `A` in this scope\n LL | fn foo2<I: Foo>(x: I) {\n    |         - similarly named type parameter `I` defined here\n LL |     let _: A = x.boo();\n-   |            ^ help: a type parameter with a similar name exists: `I`\n+   |            ^\n+   |\n+help: a type parameter with a similar name exists\n+   |\n+LL |     let _: I = x.boo();\n+   |            ^\n+help: you might be missing a type parameter\n+   |\n+LL | fn foo2<I: Foo, A>(x: I) {\n+   |               ^^^\n \n error: aborting due to previous error\n "}, {"sha": "0f58b158904db0a2fb3aa8fdb2e5c935c07e2707", "filename": "src/test/ui/async-await/issues/issue-62097.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,13 +1,14 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/issue-62097.rs:12:31\n    |\n LL |     pub async fn run_dummy_fn(&self) {\n    |                               ^^^^^\n    |                               |\n-   |                               data with this lifetime...\n+   |                               this data with an anonymous lifetime `'_`...\n    |                               ...is captured here...\n LL |         foo(|| self.bar()).await;\n-   |         --- ...and required to be `'static` by this\n+   |         --- ...and is required to live as long as `'static` here\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "dab133cfb4b673f06c91352c9dc5cfdba9f72992", "filename": "src/test/ui/cast/cast-from-nil.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcast%2Fcast-from-nil.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcast%2Fcast-from-nil.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcast-from-nil.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,9 +2,7 @@ error[E0605]: non-primitive cast: `()` as `u32`\n   --> $DIR/cast-from-nil.rs:2:21\n    |\n LL | fn main() { let u = (assert!(true) as u32); }\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "d97b0c5f8aadc736c3fdc1c114e1c3c98b34f814", "filename": "src/test/ui/cast/cast-to-bare-fn.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcast%2Fcast-to-bare-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcast%2Fcast-to-bare-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcast-to-bare-fn.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,17 +2,13 @@ error[E0605]: non-primitive cast: `fn(isize) {foo}` as `extern \"C\" fn() -> isize\n   --> $DIR/cast-to-bare-fn.rs:5:13\n    |\n LL |     let x = foo as extern \"C\" fn() -> isize;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n \n error[E0605]: non-primitive cast: `u64` as `fn(isize) -> (isize, isize)`\n   --> $DIR/cast-to-bare-fn.rs:7:13\n    |\n LL |     let y = v as extern \"Rust\" fn(isize) -> (isize, isize);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n \n error: aborting due to 2 previous errors\n "}, {"sha": "29a9baffd71d7592268a801d2fcfd26d730aa78b", "filename": "src/test/ui/cast/cast-to-nil.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcast%2Fcast-to-nil.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcast%2Fcast-to-nil.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcast-to-nil.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,9 +2,7 @@ error[E0605]: non-primitive cast: `u32` as `()`\n   --> $DIR/cast-to-nil.rs:2:21\n    |\n LL | fn main() { let u = 0u32 as (); }\n-   |                     ^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |                     ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "9b86f8d4def86bd04fcb118e7fcfaeac652f21cf", "filename": "src/test/ui/cast/cast-to-unsized-trait-object-suggestion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcast%2Fcast-to-unsized-trait-object-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcast%2Fcast-to-unsized-trait-object-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcast-to-unsized-trait-object-suggestion.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -12,7 +12,7 @@ error[E0620]: cast to unsized type: `std::boxed::Box<{integer}>` as `dyn std::ma\n LL |     Box::new(1) as dyn Send;\n    |     ^^^^^^^^^^^^^^^--------\n    |                    |\n-   |                    help: try casting to a `Box` instead: `Box<dyn Send>`\n+   |                    help: you can cast to a `Box` instead: `Box<dyn Send>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "96e3d967e2c61cf8bbdabc2311d469524288ebe0", "filename": "src/test/ui/cenum_impl_drop_cast.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcenum_impl_drop_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcenum_impl_drop_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcenum_impl_drop_cast.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,18 @@\n+#![deny(cenum_impl_drop_cast)]\n+\n+enum E {\n+    A = 0,\n+}\n+\n+impl Drop for E {\n+    fn drop(&mut self) {\n+        println!(\"Drop\");\n+    }\n+}\n+\n+fn main() {\n+    let e = E::A;\n+    let i = e as u32;\n+    //~^ ERROR cannot cast enum `E` into integer `u32` because it implements `Drop`\n+    //~| WARN this was previously accepted\n+}"}, {"sha": "8d847a0c80b16fbf308f87d89886c684c024e374", "filename": "src/test/ui/cenum_impl_drop_cast.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcenum_impl_drop_cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcenum_impl_drop_cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcenum_impl_drop_cast.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,16 @@\n+error: cannot cast enum `E` into integer `u32` because it implements `Drop`\n+  --> $DIR/cenum_impl_drop_cast.rs:15:13\n+   |\n+LL |     let i = e as u32;\n+   |             ^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/cenum_impl_drop_cast.rs:1:9\n+   |\n+LL | #![deny(cenum_impl_drop_cast)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #73333 <https://github.com/rust-lang/rust/issues/73333>\n+\n+error: aborting due to previous error\n+"}, {"sha": "4b3b4be798fc1e541a2f7b98df22ef6c737b8db3", "filename": "src/test/ui/closures/closure-no-fn-3.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fclosures%2Fclosure-no-fn-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fclosures%2Fclosure-no-fn-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-no-fn-3.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,9 +2,7 @@ error[E0605]: non-primitive cast: `[closure@$DIR/closure-no-fn-3.rs:6:27: 6:37 b\n   --> $DIR/closure-no-fn-3.rs:6:27\n    |\n LL |     let baz: fn() -> u8 = (|| { b }) as fn() -> u8;\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n \n error: aborting due to previous error\n "}, {"sha": "d3adbd5158dbbbffc6f0a72484039f9c5819c9c0", "filename": "src/test/ui/coercion/coerce-to-bang-cast.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-to-bang-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-to-bang-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-to-bang-cast.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,17 +2,13 @@ error[E0605]: non-primitive cast: `i32` as `!`\n   --> $DIR/coerce-to-bang-cast.rs:6:13\n    |\n LL |     let y = {return; 22} as !;\n-   |             ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0605]: non-primitive cast: `i32` as `!`\n   --> $DIR/coerce-to-bang-cast.rs:11:13\n    |\n LL |     let y = 22 as !;\n-   |             ^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e4d256c0ad19201b93438af57daec0badf1fb1d3", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-4b.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -16,7 +16,7 @@ error[E0604]: only `u8` can be cast as `char`, not `i8`\n   --> $DIR/const-eval-overflow-4b.rs:25:13\n    |\n LL |     : [u32; 5i8 as char as usize]\n-   |             ^^^^^^^^^^^\n+   |             ^^^^^^^^^^^ invalid cast\n \n error: aborting due to 3 previous errors\n "}, {"sha": "93dd9a53ec99f95c3595d875e208dc49bf181652", "filename": "src/test/ui/consts/const-eval/double_check2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -5,7 +5,7 @@ LL | / static FOO: (&Foo, &Bar) = unsafe {(\n LL | |     Union { u8: &BAR }.foo,\n LL | |     Union { u8: &BAR }.bar,\n LL | | )};\n-   | |___^ type validation failed: encountered 0x05 at .1.<deref>, but expected a valid enum discriminant\n+   | |___^ type validation failed: encountered 0x05 at .1.<deref>, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "1f7593c6db9b6b25f66bd958265cf92a7ff1ff12", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:24:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x00000001, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x00000001, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -26,7 +26,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:42:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x00000000, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x00000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "fa18a3af1b09f2b98fda88fc0ca803df0daffe0a", "filename": "src/test/ui/consts/const_in_pattern/issue-73431.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-73431.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-73431.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-73431.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,29 @@\n+// run-pass\n+\n+// Regression test for https://github.com/rust-lang/rust/issues/73431.\n+\n+pub trait Zero {\n+    const ZERO: Self;\n+}\n+\n+impl Zero for usize {\n+    const ZERO: Self = 0;\n+}\n+\n+impl<T: Zero> Zero for Wrapper<T> {\n+    const ZERO: Self = Wrapper(T::ZERO);\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct Wrapper<T>(T);\n+\n+fn is_zero(x: Wrapper<usize>) -> bool {\n+    match x {\n+        Zero::ZERO => true,\n+        _ => false,\n+    }\n+}\n+\n+fn main() {\n+    let _ = is_zero(Wrapper(42));\n+}"}, {"sha": "18835310bd5e87ec6541fa49df36540a60be1c64", "filename": "src/test/ui/error-codes/E0604.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ferror-codes%2FE0604.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ferror-codes%2FE0604.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0604.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,7 +2,7 @@ error[E0604]: only `u8` can be cast as `char`, not `u32`\n   --> $DIR/E0604.rs:2:5\n    |\n LL |     1u32 as char;\n-   |     ^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^ invalid cast\n \n error: aborting due to previous error\n "}, {"sha": "f23d2008e0b5f2c4cd38904b074ac9c48bc5747c", "filename": "src/test/ui/error-codes/E0605.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ferror-codes%2FE0605.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ferror-codes%2FE0605.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0605.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,17 +2,13 @@ error[E0605]: non-primitive cast: `u8` as `std::vec::Vec<u8>`\n   --> $DIR/E0605.rs:3:5\n    |\n LL |     x as Vec<u8>;\n-   |     ^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |     ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0605]: non-primitive cast: `*const u8` as `&u8`\n   --> $DIR/E0605.rs:6:5\n    |\n LL |     v as &u8;\n-   |     ^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |     ^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to 2 previous errors\n "}, {"sha": "905195d4ad963fe4b963a1dc31e03a1b9a115a27", "filename": "src/test/ui/error-festival.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ferror-festival.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ferror-festival.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-festival.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -42,15 +42,13 @@ error[E0604]: only `u8` can be cast as `char`, not `u32`\n   --> $DIR/error-festival.rs:25:5\n    |\n LL |     0u32 as char;\n-   |     ^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^ invalid cast\n \n error[E0605]: non-primitive cast: `u8` as `std::vec::Vec<u8>`\n   --> $DIR/error-festival.rs:29:5\n    |\n LL |     x as Vec<u8>;\n-   |     ^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |     ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0054]: cannot cast as `bool`\n   --> $DIR/error-festival.rs:33:24"}, {"sha": "56d5a26beb04ee0d37e823799155373569c068a4", "filename": "src/test/ui/fat-ptr-cast.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ffat-ptr-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ffat-ptr-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffat-ptr-cast.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -34,9 +34,7 @@ error[E0605]: non-primitive cast: `std::boxed::Box<[i32]>` as `usize`\n   --> $DIR/fat-ptr-cast.rs:14:5\n    |\n LL |     b as usize;\n-   |     ^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |     ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0606]: casting `*const [i32]` as `usize` is invalid\n   --> $DIR/fat-ptr-cast.rs:15:5"}, {"sha": "6a97f28ff552b3a76c5f4743b8d980dcddaf97b1", "filename": "src/test/ui/impl-trait/binding-without-value.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,9 @@\n+#![allow(incomplete_features)]\n+#![feature(impl_trait_in_bindings)]\n+\n+fn foo() {\n+    let _ : impl Copy;\n+    //~^ ERROR cannot resolve opaque type\n+}\n+\n+fn main() {}"}, {"sha": "0d2faeaf85d10be60785746009a2de1eed8ac1ce", "filename": "src/test/ui/impl-trait/binding-without-value.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,16 @@\n+error[E0720]: cannot resolve opaque type\n+  --> $DIR/binding-without-value.rs:5:13\n+   |\n+LL |     let _ : impl Copy;\n+   |         -   ^^^^^^^^^ cannot resolve opaque type\n+   |         |\n+   |         this binding might not have a concrete type\n+   |\n+help: set the binding to a value for a concrete type to be resolved\n+   |\n+LL |     let _ : impl Copy = /* value */;\n+   |                       ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "451ddb3cce0e01c1bd9bc6d6034f055c5901f2d1", "filename": "src/test/ui/impl-trait/issues/infinite-impl-trait-issue-38064.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -5,13 +5,13 @@\n \n trait Quux {}\n \n-fn foo() -> impl Quux { //~ opaque type expands to a recursive type\n+fn foo() -> impl Quux { //~ ERROR cannot resolve opaque type\n     struct Foo<T>(T);\n     impl<T> Quux for Foo<T> {}\n     Foo(bar())\n }\n \n-fn bar() -> impl Quux { //~ opaque type expands to a recursive type\n+fn bar() -> impl Quux { //~ ERROR cannot resolve opaque type\n     struct Bar<T>(T);\n     impl<T> Quux for Bar<T> {}\n     Bar(foo())"}, {"sha": "c538b77098a2d23a133667a96d30897926a1c4f5", "filename": "src/test/ui/impl-trait/issues/infinite-impl-trait-issue-38064.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,18 +1,26 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/infinite-impl-trait-issue-38064.rs:8:13\n    |\n LL | fn foo() -> impl Quux {\n-   |             ^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `foo::Foo<bar::Bar<impl Quux>>`\n+   |             ^^^^^^^^^ recursive opaque type\n+...\n+LL |     Foo(bar())\n+   |     ---------- returning here with type `foo::Foo<impl Quux>`\n+...\n+LL | fn bar() -> impl Quux {\n+   |             --------- returning this opaque type `foo::Foo<impl Quux>`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/infinite-impl-trait-issue-38064.rs:14:13\n    |\n+LL | fn foo() -> impl Quux {\n+   |             --------- returning this opaque type `bar::Bar<impl Quux>`\n+...\n LL | fn bar() -> impl Quux {\n-   |             ^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `bar::Bar<foo::Foo<impl Quux>>`\n+   |             ^^^^^^^^^ recursive opaque type\n+...\n+LL |     Bar(foo())\n+   |     ---------- returning here with type `bar::Bar<impl Quux>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ca9ca8a9debe2a62dfee8a8b31a77f81506bb096", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -26,7 +26,34 @@ LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                ^^^^^^^^^^^^^^\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:12:69\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n+   |               -                              ^ returning this value requires that `'1` must outlive `'static`\n+   |               |\n+   |               let's call the lifetime of this reference `'1`\n+   |\n+   = help: consider replacing `'1` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/must_outlive_least_region_or_bound.rs:12:55\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n+   |              -- lifetime `'a` defined here            ^ returning this value requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+   = help: consider replacing `'a` with `'static`\n+\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/must_outlive_least_region_or_bound.rs:15:41\n+   |\n+LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n+   |               ----                      ^ lifetime `'a` required\n+   |               |\n+   |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/must_outlive_least_region_or_bound.rs:33:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |               -- lifetime `'a` defined here                         ^ returning this value requires that `'a` must outlive `'static`\n@@ -35,7 +62,7 @@ LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    = help: consider replacing `'a` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:17:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:38:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n    |                          --  -- lifetime `'b` defined here  ^^^^^^^^^^^^^^^^ opaque type requires that `'b` must outlive `'a`\n@@ -45,13 +72,14 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n    = help: consider adding the following bound: `'b: 'a`\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:22:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:43:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                                   ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 8 previous errors\n \n-For more information about this error, try `rustc --explain E0310`.\n+Some errors have detailed explanations: E0310, E0621.\n+For more information about an error, try `rustc --explain E0310`."}, {"sha": "837244b022721c266bd9353b960e2e2b961daf7e", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -6,6 +6,27 @@ fn elided(x: &i32) -> impl Copy { x }\n fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n //~^ ERROR cannot infer an appropriate lifetime\n \n+fn elided2(x: &i32) -> impl Copy + 'static { x }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n+//~^ ERROR explicit lifetime required in the type of `x`\n+\n+fn elided3(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug> { Box::new(x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n trait LifetimeTrait<'a> {}\n impl<'a> LifetimeTrait<'a> for &'a i32 {}\n "}, {"sha": "e1fa4f02b6fcf770f2585118eae9c58c507983f4", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 149, "deletions": 25, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,47 +1,113 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              ----     ---------   ^ ...and is captured here\n-   |              |        |\n-   |              |        ...is required to be `'static` by this...\n-   |              data with this lifetime...\n+   |              ----                 ^ ...is captured here...\n+   |              |\n+   |              this data with an anonymous lifetime `'_`...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 3:1\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n+   |\n+LL | fn elided(x: &i32) -> impl Copy { x }\n+   |                       ^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ^^^^\n \n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |                    -------     ---------   ^ ...and is captured here\n-   |                    |           |\n-   |                    |           ...is required to be `'static` by this...\n-   |                    data with this lifetime...\n+   |                    -------                 ^ ...is captured here...\n+   |                    |\n+   |                    this data with lifetime `'a`...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the function body at 6:13\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n+   |\n+LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n+   |                                ^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'a` lifetime bound\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                          ^^^^\n \n-error: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:12:69\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n+   |               ----                           ^ ...is captured here...\n+   |               |\n+   |               this data with an anonymous lifetime `'_`...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:24\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n+   |                        ^^^^^^^^^^^^^^^^^^^\n+help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + '_ { x }\n+   |                                    ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn elided2(x: &'static i32) -> impl Copy + 'static { x }\n+   |               ^^^^^^^^^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:12:55\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n+   |                     -------                           ^ ...is captured here...\n+   |                     |\n+   |                     this data with lifetime `'a`...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:12:33\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n+   |                                 ^^^^^^^^^^^^^^^^^^^\n+help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'a { x }\n+   |                                             ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn explicit2<'a>(x: &'static i32) -> impl Copy + 'static { x }\n+   |                     ^^^^^^^^^^^^\n+\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/must_outlive_least_region_or_bound.rs:15:24\n+   |\n+LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n+   |               ----     ^^^^^^^^^^^^^^ lifetime `'a` required\n+   |               |\n+   |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:33:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n-   |                      -------     --------------------------------   ^ ...and is captured here\n-   |                      |           |\n-   |                      |           ...is required to be `'static` by this...\n-   |                      data with this lifetime...\n+   |                      ------- this data with lifetime `'a`...        ^ ...is captured here...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the function body at 12:15\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:33:34\n+   |\n+LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n-LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static + 'a { x }\n-   |                                                                   ^^^^\n+LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'a { x }\n+   |                                                           ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x }\n+   |                      ^^^^^^^^^^^^\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/must_outlive_least_region_or_bound.rs:17:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:38:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n    |                                                 -------     ^^^^^^^^^^^^^^^^\n@@ -50,14 +116,72 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n    |                                                 this parameter and the return type are declared with different lifetimes...\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:22:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:43:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |                                 |\n    |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n \n-error: aborting due to 5 previous errors\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+   |\n+LL | fn elided3(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+   |               ----                               ^ ...is captured here, requiring it to live as long as `'static`\n+   |               |\n+   |               this data with an anonymous lifetime `'_`...\n+   |\n+help: to declare that the trait object captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided3(x: &i32) -> Box<dyn Debug + '_> { Box::new(x) }\n+   |                                      ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:21:59\n+   |\n+LL | fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug> { Box::new(x) }\n+   |                     -------                               ^ ...is captured here, requiring it to live as long as `'static`\n+   |                     |\n+   |                     this data with lifetime `'a`...\n+   |\n+help: to declare that the trait object captures data from argument `x`, you can add an explicit `'a` lifetime bound\n+   |\n+LL | fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug + 'a> { Box::new(x) }\n+   |                                               ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:24:60\n+   |\n+LL | fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |               ----                                         ^ ...is captured here, requiring it to live as long as `'static`\n+   |               |\n+   |               this data with an anonymous lifetime `'_`...\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn elided4(x: &i32) -> Box<dyn Debug + '_> { Box::new(x) }\n+   |                                        ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn elided4(x: &'static i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |               ^^^^^^^^^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:27:69\n+   |\n+LL | fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |                     ------- this data with lifetime `'a`...         ^ ...is captured here, requiring it to live as long as `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'a> { Box::new(x) }\n+   |                                                 ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn explicit4<'a>(x: &'static i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |                     ^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n \n-Some errors have detailed explanations: E0310, E0623.\n+Some errors have detailed explanations: E0310, E0621, E0623, E0759.\n For more information about an error, try `rustc --explain E0310`."}, {"sha": "5a3027ec751a91126268ddd7bc3eb8691c248246", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,10 +1,11 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-direct.rs:5:14\n    |\n LL | fn test() -> impl Sized {\n-   |              ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |              ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     test()\n+   |     ------ returning here with type `impl Sized`\n \n error: aborting due to previous error\n "}, {"sha": "75ff9e078cc2ca7fe96b51e61d66bb1c25d8ad22", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-indirect.stderr", "status": "modified", "additions": 93, "deletions": 60, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,114 +1,147 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:7:22\n    |\n LL | fn option(i: i32) -> impl Sized {\n-   |                      ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `std::option::Option<(impl Sized, i32)>`\n+   |                      ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     if i < 0 { None } else { Some((option(i - 1), i)) }\n+   |                ----          ------------------------ returning here with type `std::option::Option<(impl Sized, i32)>`\n+   |                |\n+   |                returning here with type `std::option::Option<(impl Sized, i32)>`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:12:15\n    |\n LL | fn tuple() -> impl Sized {\n-   |               ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `(impl Sized,)`\n+   |               ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     (tuple(),)\n+   |     ---------- returning here with type `(impl Sized,)`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:17:15\n    |\n LL | fn array() -> impl Sized {\n-   |               ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[impl Sized; 1]`\n+   |               ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     [array()]\n+   |     --------- returning here with type `[impl Sized; 1]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:22:13\n    |\n LL | fn ptr() -> impl Sized {\n-   |             ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `*const impl Sized`\n+   |             ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     &ptr() as *const _\n+   |     ------------------ returning here with type `*const impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:27:16\n    |\n LL | fn fn_ptr() -> impl Sized {\n-   |                ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `fn() -> impl Sized`\n+   |                ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     fn_ptr as fn() -> _\n+   |     ------------------- returning here with type `fn() -> impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:32:25\n    |\n-LL | fn closure_capture() -> impl Sized {\n-   |                         ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:35:5: 37:6 x:impl Sized]`\n+LL |   fn closure_capture() -> impl Sized {\n+   |                           ^^^^^^^^^^ recursive opaque type\n+...\n+LL | /     move || {\n+LL | |         x;\n+LL | |     }\n+   | |_____- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:35:5: 37:6 x:impl Sized]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:40:29\n    |\n-LL | fn closure_ref_capture() -> impl Sized {\n-   |                             ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:43:5: 45:6 x:impl Sized]`\n+LL |   fn closure_ref_capture() -> impl Sized {\n+   |                               ^^^^^^^^^^ recursive opaque type\n+...\n+LL | /     move || {\n+LL | |         &x;\n+LL | |     }\n+   | |_____- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:43:5: 45:6 x:impl Sized]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:48:21\n    |\n LL | fn closure_sig() -> impl Sized {\n-   |                     ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:50:5: 50:21]`\n+   |                     ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     || closure_sig()\n+   |     ---------------- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:50:5: 50:21]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:53:23\n    |\n LL | fn generator_sig() -> impl Sized {\n-   |                       ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:55:5: 55:23]`\n+   |                       ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     || generator_sig()\n+   |     ------------------ returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:55:5: 55:23]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:58:27\n    |\n-LL | fn generator_capture() -> impl Sized {\n-   |                           ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type-indirect.rs:61:5: 64:6 x:impl Sized {()}]`\n+LL |   fn generator_capture() -> impl Sized {\n+   |                             ^^^^^^^^^^ recursive opaque type\n+...\n+LL | /     move || {\n+LL | |         yield;\n+LL | |         x;\n+LL | |     }\n+   | |_____- returning here with type `[generator@$DIR/recursive-impl-trait-type-indirect.rs:61:5: 64:6 x:impl Sized {()}]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:67:35\n    |\n LL | fn substs_change<T: 'static>() -> impl Sized {\n-   |                                   ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `(impl Sized,)`\n+   |                                   ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     (substs_change::<&T>(),)\n+   |     ------------------------ returning here with type `(impl Sized,)`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:72:24\n    |\n-LL | fn generator_hold() -> impl Sized {\n-   |                        ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type-indirect.rs:74:5: 78:6 {impl Sized, ()}]`\n+LL |   fn generator_hold() -> impl Sized {\n+   |                          ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL | /     move || {\n+LL | |         let x = generator_hold();\n+LL | |         yield;\n+LL | |         x;\n+LL | |     }\n+   | |_____- returning here with type `[generator@$DIR/recursive-impl-trait-type-indirect.rs:74:5: 78:6 {impl Sized, ()}]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:86:26\n    |\n LL | fn mutual_recursion() -> impl Sync {\n-   |                          ^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |                          ^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     mutual_recursion_b()\n+   |     -------------------- returning here with type `impl Sized`\n+...\n+LL | fn mutual_recursion_b() -> impl Sized {\n+   |                            ---------- returning this opaque type `impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:91:28\n    |\n+LL | fn mutual_recursion() -> impl Sync {\n+   |                          --------- returning this opaque type `impl std::marker::Sync`\n+...\n LL | fn mutual_recursion_b() -> impl Sized {\n-   |                            ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |                            ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     mutual_recursion()\n+   |     ------------------ returning here with type `impl std::marker::Sync`\n \n error: aborting due to 14 previous errors\n "}, {"sha": "818e40365394dea65b44fe652d41be64aae4071e", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-through-non-recursive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -4,21 +4,21 @@\n \n fn id<T>(t: T) -> impl Sized { t }\n \n-fn recursive_id() -> impl Sized { //~ ERROR opaque type expands to a recursive type\n+fn recursive_id() -> impl Sized { //~ ERROR cannot resolve opaque type\n     id(recursive_id2())\n }\n \n-fn recursive_id2() -> impl Sized { //~ ERROR opaque type expands to a recursive type\n+fn recursive_id2() -> impl Sized { //~ ERROR cannot resolve opaque type\n     id(recursive_id())\n }\n \n fn wrap<T>(t: T) -> impl Sized { (t,) }\n \n-fn recursive_wrap() -> impl Sized { //~ ERROR opaque type expands to a recursive type\n+fn recursive_wrap() -> impl Sized { //~ ERROR cannot resolve opaque type\n     wrap(recursive_wrap2())\n }\n \n-fn recursive_wrap2() -> impl Sized { //~ ERROR opaque type expands to a recursive type\n+fn recursive_wrap2() -> impl Sized { //~ ERROR cannot resolve opaque type\n     wrap(recursive_wrap())\n }\n "}, {"sha": "fbc58837a8e946dc45cd62490a2dc6442c83f4ae", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-through-non-recursive.stderr", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,34 +1,46 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:7:22\n    |\n+LL | fn id<T>(t: T) -> impl Sized { t }\n+   |                   ---------- returning this opaque type `impl Sized`\n+LL | \n LL | fn recursive_id() -> impl Sized {\n-   |                      ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |                      ^^^^^^^^^^ recursive opaque type\n+LL |     id(recursive_id2())\n+   |     ------------------- returning here with type `impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:11:23\n    |\n+LL | fn id<T>(t: T) -> impl Sized { t }\n+   |                   ---------- returning this opaque type `impl Sized`\n+...\n LL | fn recursive_id2() -> impl Sized {\n-   |                       ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |                       ^^^^^^^^^^ recursive opaque type\n+LL |     id(recursive_id())\n+   |     ------------------ returning here with type `impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:17:24\n    |\n+LL | fn wrap<T>(t: T) -> impl Sized { (t,) }\n+   |                     ---------- returning this opaque type `impl Sized`\n+LL | \n LL | fn recursive_wrap() -> impl Sized {\n-   |                        ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `((impl Sized,),)`\n+   |                        ^^^^^^^^^^ recursive opaque type\n+LL |     wrap(recursive_wrap2())\n+   |     ----------------------- returning here with type `impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:21:25\n    |\n+LL | fn wrap<T>(t: T) -> impl Sized { (t,) }\n+   |                     ---------- returning this opaque type `impl Sized`\n+...\n LL | fn recursive_wrap2() -> impl Sized {\n-   |                         ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `((impl Sized,),)`\n+   |                         ^^^^^^^^^^ recursive opaque type\n+LL |     wrap(recursive_wrap())\n+   |     ---------------------- returning here with type `impl Sized`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "df0db6e4fc6df927297d9793d271390de5bc21dd", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,36 +1,43 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/static-return-lifetime-infered.rs:7:16\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         -----     ----------------------- ...is required to be `'static` by this...\n-   |                         |\n-   |                         data with this lifetime...\n+   |                         ----- this data with an anonymous lifetime `'_`...\n LL |         self.x.iter().map(|a| a.0)\n    |         ------ ^^^^\n    |         |\n-   |         ...and is captured here\n+   |         ...is captured here...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the method body at 6:5\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/static-return-lifetime-infered.rs:6:35\n+   |\n+LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ^^^^\n \n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/static-return-lifetime-infered.rs:11:16\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                        --------     ----------------------- ...is required to be `'static` by this...\n-   |                        |\n-   |                        data with this lifetime...\n+   |                        -------- this data with lifetime `'a`...\n LL |         self.x.iter().map(|a| a.0)\n    |         ------ ^^^^\n    |         |\n-   |         ...and is captured here\n+   |         ...is captured here...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the method body at 10:20\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/static-return-lifetime-infered.rs:10:37\n+   |\n+LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n    |                                                             ^^^^\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "462508f306ef34f4b1f3de692f996a79a3d894e8", "filename": "src/test/ui/impl-trait/where-allowed-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -3,7 +3,6 @@\n use std::fmt::Debug;\n \n // Disallowed\n-fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n-//~^ ERROR opaque type expands to a recursive type\n+fn in_adt_in_return() -> Vec<impl Debug> { panic!() } //~ ERROR cannot resolve opaque type\n \n fn main() {}"}, {"sha": "b8e06725cbcdd6493683dc2ca34fd4d775d5cc27", "filename": "src/test/ui/impl-trait/where-allowed-2.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,10 +1,12 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/where-allowed-2.rs:6:30\n    |\n LL | fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n-   |                              ^^^^^^^^^^ expands to a recursive type\n+   |                              ^^^^^^^^^^    -------- this returned value is of `!` type\n+   |                              |\n+   |                              cannot resolve opaque type\n    |\n-   = note: type resolves to itself\n+   = help: this error will resolve once the item's body returns a concrete type\n \n error: aborting due to previous error\n "}, {"sha": "5b8a1823386936929c5200ea19a420515be3608e", "filename": "src/test/ui/issues/issue-10991.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-10991.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-10991.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10991.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,9 +2,7 @@ error[E0605]: non-primitive cast: `()` as `usize`\n   --> $DIR/issue-10991.rs:3:14\n    |\n LL |     let _t = nil as usize;\n-   |              ^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |              ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "eaf6acff26bf35cf92b704ebca96c4c0bdaaebb0", "filename": "src/test/ui/issues/issue-16048.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-16048.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-16048.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16048.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -18,12 +18,12 @@ impl<'a> Test<'a> for Foo<'a> {\n }\n \n impl<'a> NoLifetime for Foo<'a> {\n-    fn get<'p, T : Test<'a>>(&self) -> T {\n+    fn get<'p, T: Test<'a> + From<Foo<'a>>>(&self) -> T {\n     //~^ ERROR E0195\n     //~| NOTE lifetimes do not match method in trait\n         return *self as T;\n         //~^ ERROR non-primitive cast: `Foo<'a>` as `T`\n-        //~| NOTE an `as` expression can only be used to convert between primitive types.\n+        //~| NOTE an `as` expression can only be used to convert between primitive types\n     }\n }\n "}, {"sha": "73610942d7a7ed358ded73169f73004ff5bfac24", "filename": "src/test/ui/issues/issue-16048.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-16048.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-16048.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16048.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -4,16 +4,16 @@ error[E0195]: lifetime parameters or bounds on method `get` do not match the tra\n LL |     fn get<'p, T : Test<'p>>(&self) -> T;\n    |           ------------------ lifetimes in impl do not match this method in trait\n ...\n-LL |     fn get<'p, T : Test<'a>>(&self) -> T {\n-   |           ^^^^^^^^^^^^^^^^^^ lifetimes do not match method in trait\n+LL |     fn get<'p, T: Test<'a> + From<Foo<'a>>>(&self) -> T {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetimes do not match method in trait\n \n error[E0605]: non-primitive cast: `Foo<'a>` as `T`\n   --> $DIR/issue-16048.rs:24:16\n    |\n LL |         return *self as T;\n-   |                ^^^^^^^^^^\n+   |                ^^^^^^^^^^ help: consider using the `From` trait instead: `T::from(*self)`\n    |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   = note: an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to 2 previous errors\n "}, {"sha": "919594fc9af4b434967d1975e1a23b41346c5f6e", "filename": "src/test/ui/issues/issue-16922.stderr", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,18 +1,16 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/issue-16922.rs:4:14\n    |\n LL | fn foo<T: Any>(value: &T) -> Box<dyn Any> {\n-   |                       -- data with this lifetime...\n+   |                       -- this data with an anonymous lifetime `'_`...\n LL |     Box::new(value) as Box<dyn Any>\n-   |     ---------^^^^^-\n-   |     |        |\n-   |     |        ...and is captured here\n-   |     ...is required to be `'static` by this...\n+   |              ^^^^^ ...is captured here, requiring it to live as long as `'static`\n    |\n-help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 3:1\n+help: to declare that the trait object captures data from argument `value`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn foo<T: Any>(value: &T) -> Box<dyn Any + '_> {\n    |                                          ^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "b63a3995d255dd523a3518f7e891845f57bd5069", "filename": "src/test/ui/issues/issue-17441.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-17441.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-17441.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17441.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -16,7 +16,7 @@ error[E0620]: cast to unsized type: `std::boxed::Box<usize>` as `dyn std::fmt::D\n LL |     let _bar = Box::new(1_usize) as dyn std::fmt::Debug;\n    |                ^^^^^^^^^^^^^^^^^^^^^-------------------\n    |                                     |\n-   |                                     help: try casting to a `Box` instead: `Box<dyn std::fmt::Debug>`\n+   |                                     help: you can cast to a `Box` instead: `Box<dyn std::fmt::Debug>`\n \n error[E0620]: cast to unsized type: `usize` as `dyn std::fmt::Debug`\n   --> $DIR/issue-17441.rs:8:16"}, {"sha": "4c35deb1fbe4e0b566c14fc9026d09f5883cfff3", "filename": "src/test/ui/issues/issue-22289.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-22289.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-22289.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22289.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,9 +2,12 @@ error[E0605]: non-primitive cast: `i32` as `&(dyn std::any::Any + 'static)`\n   --> $DIR/issue-22289.rs:2:5\n    |\n LL |     0 as &dyn std::any::Any;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n    |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+help: borrow the value for the cast to be valid\n+   |\n+LL |     &0 as &dyn std::any::Any;\n+   |     ^\n \n error: aborting due to previous error\n "}, {"sha": "4e359b3412a71e8400aca880fea2c4cadf9f93f6", "filename": "src/test/ui/issues/issue-22312.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-22312.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-22312.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22312.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,6 +1,6 @@\n use std::ops::Index;\n \n-pub trait Array2D: Index<usize> {\n+pub trait Array2D: Index<usize> + Sized {\n     fn rows(&self) -> usize;\n     fn columns(&self) -> usize;\n     fn get<'a>(&'a self, y: usize, x: usize) -> Option<&'a <Self as Index<usize>>::Output> {"}, {"sha": "28564b074633bf2fd402729008e8f39644b90f7d", "filename": "src/test/ui/issues/issue-22312.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-22312.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-22312.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22312.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,9 +2,12 @@ error[E0605]: non-primitive cast: `Self` as `&dyn std::ops::Index<usize, Output\n   --> $DIR/issue-22312.rs:11:24\n    |\n LL |         let indexer = &(*self as &dyn Index<usize, Output = <Self as Index<usize>>::Output>);\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n    |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+help: borrow the value for the cast to be valid\n+   |\n+LL |         let indexer = &(&*self as &dyn Index<usize, Output = <Self as Index<usize>>::Output>);\n+   |                         ^\n \n error: aborting due to previous error\n "}, {"sha": "9f5968399a37d8a730bced19a959071fba7e0bf9", "filename": "src/test/ui/issues/issue-2995.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-2995.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-2995.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2995.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,9 +2,7 @@ error[E0605]: non-primitive cast: `*const isize` as `&isize`\n   --> $DIR/issue-2995.rs:2:22\n    |\n LL |     let _q: &isize = p as &isize;\n-   |                      ^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |                      ^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "d00f3d91b49da640f3a063a9c071155fc7e663ae", "filename": "src/test/ui/issues/issue-45730.stderr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-45730.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fissues%2Fissue-45730.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45730.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,30 +1,24 @@\n error[E0641]: cannot cast to a pointer of an unknown kind\n-  --> $DIR/issue-45730.rs:3:23\n+  --> $DIR/issue-45730.rs:3:28\n    |\n LL |     let x: *const _ = 0 as _;\n-   |                       ^^^^^-\n-   |                            |\n-   |                            help: consider giving more type information\n+   |                            ^ needs more type information\n    |\n    = note: the type information given here is insufficient to check whether the pointer cast is valid\n \n error[E0641]: cannot cast to a pointer of an unknown kind\n-  --> $DIR/issue-45730.rs:5:23\n+  --> $DIR/issue-45730.rs:5:28\n    |\n LL |     let x: *const _ = 0 as *const _;\n-   |                       ^^^^^--------\n-   |                            |\n-   |                            help: consider giving more type information\n+   |                            ^^^^^^^^ needs more type information\n    |\n    = note: the type information given here is insufficient to check whether the pointer cast is valid\n \n error[E0641]: cannot cast to a pointer of an unknown kind\n-  --> $DIR/issue-45730.rs:8:13\n+  --> $DIR/issue-45730.rs:8:44\n    |\n LL |     let x = 0 as *const i32 as *const _ as *mut _;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^------\n-   |                                            |\n-   |                                            help: consider giving more type information\n+   |                                            ^^^^^^ needs more type information\n    |\n    = note: the type information given here is insufficient to check whether the pointer cast is valid\n "}, {"sha": "1a371c6b17000b6c93d2a491f88321ba4ee95230", "filename": "src/test/ui/layout/debug.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -10,15 +10,15 @@ error: layout_of(E) = Layout {\n         ],\n     },\n     variants: Multiple {\n-        discr: Scalar {\n+        tag: Scalar {\n             value: Int(\n                 I32,\n                 false,\n             ),\n             valid_range: 0..=0,\n         },\n-        discr_kind: Tag,\n-        discr_index: 0,\n+        tag_encoding: Direct,\n+        tag_field: 0,\n         variants: [\n             Layout {\n                 fields: Arbitrary {\n@@ -202,15 +202,15 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n         ],\n     },\n     variants: Multiple {\n-        discr: Scalar {\n+        tag: Scalar {\n             value: Int(\n                 I32,\n                 false,\n             ),\n             valid_range: 0..=1,\n         },\n-        discr_kind: Tag,\n-        discr_index: 0,\n+        tag_encoding: Direct,\n+        tag_field: 0,\n         variants: [\n             Layout {\n                 fields: Arbitrary {"}, {"sha": "95936de218b8fe5d25de453501655ddde3c5ba76", "filename": "src/test/ui/mismatched_types/cast-rfc0401.stderr", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -24,41 +24,31 @@ error[E0605]: non-primitive cast: `*const u8` as `&u8`\n   --> $DIR/cast-rfc0401.rs:29:13\n    |\n LL |     let _ = v as &u8;\n-   |             ^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0605]: non-primitive cast: `*const u8` as `E`\n   --> $DIR/cast-rfc0401.rs:30:13\n    |\n LL |     let _ = v as E;\n-   |             ^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0605]: non-primitive cast: `*const u8` as `fn()`\n   --> $DIR/cast-rfc0401.rs:31:13\n    |\n LL |     let _ = v as fn();\n-   |             ^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^ invalid cast\n \n error[E0605]: non-primitive cast: `*const u8` as `(u32,)`\n   --> $DIR/cast-rfc0401.rs:32:13\n    |\n LL |     let _ = v as (u32,);\n-   |             ^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0605]: non-primitive cast: `std::option::Option<&*const u8>` as `*const u8`\n   --> $DIR/cast-rfc0401.rs:33:13\n    |\n LL |     let _ = Some(&v) as *const u8;\n-   |             ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0606]: casting `*const u8` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:35:13\n@@ -102,7 +92,7 @@ error[E0604]: only `u8` can be cast as `char`, not `u32`\n   --> $DIR/cast-rfc0401.rs:41:13\n    |\n LL |     let _ = 0x61u32 as char;\n-   |             ^^^^^^^^^^^^^^^\n+   |             ^^^^^^^^^^^^^^^ invalid cast\n \n error[E0606]: casting `bool` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:43:13"}, {"sha": "d39b0a3207763a37eb1f89165afd06be0bd5dcca", "filename": "src/test/ui/mismatched_types/issue-26480.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -17,12 +17,11 @@ error[E0605]: non-primitive cast: `{integer}` as `()`\n   --> $DIR/issue-26480.rs:22:19\n    |\n LL |     ($x:expr) => ($x as ())\n-   |                   ^^^^^^^^\n+   |                   ^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n ...\n LL |     cast!(2);\n    |     --------- in this macro invocation\n    |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors"}, {"sha": "0a4b98469b2b6c356b60af5f9aac6dc47a03f464", "filename": "src/test/ui/nonscalar-cast.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fnonscalar-cast.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fnonscalar-cast.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnonscalar-cast.fixed?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+\n+#[derive(Debug)]\n+struct Foo {\n+    x: isize\n+}\n+\n+impl From<Foo> for isize {\n+    fn from(val: Foo) -> isize {\n+        val.x\n+    }\n+}\n+\n+fn main() {\n+    println!(\"{}\", isize::from(Foo { x: 1 })); //~ non-primitive cast: `Foo` as `isize` [E0605]\n+}"}, {"sha": "59fcf09666b24f32aa36a63b8029b8acd1064dba", "filename": "src/test/ui/nonscalar-cast.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fnonscalar-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fnonscalar-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnonscalar-cast.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,8 +1,16 @@\n+// run-rustfix\n+\n #[derive(Debug)]\n struct Foo {\n     x: isize\n }\n \n+impl From<Foo> for isize {\n+    fn from(val: Foo) -> isize {\n+        val.x\n+    }\n+}\n+\n fn main() {\n     println!(\"{}\", Foo { x: 1 } as isize); //~ non-primitive cast: `Foo` as `isize` [E0605]\n }"}, {"sha": "2a7037121876d8725202c24c4131c23e8b811df4", "filename": "src/test/ui/nonscalar-cast.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fnonscalar-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fnonscalar-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnonscalar-cast.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,10 +1,10 @@\n error[E0605]: non-primitive cast: `Foo` as `isize`\n-  --> $DIR/nonscalar-cast.rs:7:20\n+  --> $DIR/nonscalar-cast.rs:15:20\n    |\n LL |     println!(\"{}\", Foo { x: 1 } as isize);\n-   |                    ^^^^^^^^^^^^^^^^^^^^^\n+   |                    ^^^^^^^^^^^^^^^^^^^^^ help: consider using the `From` trait instead: `isize::from(Foo { x: 1 })`\n    |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   = note: an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "1b1e0d9610724b6e83c1a48c19e2a0ff427fb158", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-box-error.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,13 +1,13 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/object-lifetime-default-from-box-error.rs:18:5\n    |\n LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait> {\n-   |             --------------- data with this lifetime...\n+   |             --------------- this data with an anonymous lifetime `'_`...\n ...\n LL |     ss.r\n-   |     ^^^^ ...is captured and required to be `'static` here\n+   |     ^^^^ ...is captured and required to live as long as `'static` here\n    |\n-help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #2 defined on the function body at 14:1\n+help: to declare that the trait object captures data from argument `ss`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait + '_> {\n    |                                                   ^^^^\n@@ -23,4 +23,5 @@ LL |     ss.r = b;\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0621`.\n+Some errors have detailed explanations: E0621, E0759.\n+For more information about an error, try `rustc --explain E0621`."}, {"sha": "9f4ac0fea36ef03ba41bb048a197ad87627bb0af", "filename": "src/test/ui/order-dependent-cast-inference.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Forder-dependent-cast-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Forder-dependent-cast-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Forder-dependent-cast-inference.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,10 +1,8 @@\n error[E0641]: cannot cast to a pointer of an unknown kind\n-  --> $DIR/order-dependent-cast-inference.rs:5:17\n+  --> $DIR/order-dependent-cast-inference.rs:5:22\n    |\n LL |     let mut y = 0 as *const _;\n-   |                 ^^^^^--------\n-   |                      |\n-   |                      help: consider giving more type information\n+   |                      ^^^^^^^^ needs more type information\n    |\n    = note: the type information given here is insufficient to check whether the pointer cast is valid\n "}, {"sha": "9683a83e72095b09ecdc07abad6385811d48ccde", "filename": "src/test/ui/parser/byte-literals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -8,5 +8,5 @@ pub fn main() {\n     b'\t';  //~ ERROR byte constant must be escaped\n     b''';  //~ ERROR byte constant must be escaped\n     b'\u00e9';  //~ ERROR byte constant must be ASCII\n-    b'a  //~ ERROR unterminated byte constant\n+    b'a  //~ ERROR unterminated byte constant [E0763]\n }"}, {"sha": "7bbdc07cd835fa02c70a119c299e5a0a53056128", "filename": "src/test/ui/parser/byte-literals.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -34,11 +34,12 @@ error: byte constant must be ASCII. Use a \\xHH escape for a non-ASCII byte\n LL |     b'\u00e9';\n    |       ^\n \n-error: unterminated byte constant\n+error[E0763]: unterminated byte constant\n   --> $DIR/byte-literals.rs:11:6\n    |\n LL |     b'a\n    |      ^^^^\n \n error: aborting due to 7 previous errors\n \n+For more information about this error, try `rustc --explain E0763`."}, {"sha": "7f58f5df2d4125786ff200cc557cd910d1338554", "filename": "src/test/ui/parser/let-binop.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fparser%2Flet-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fparser%2Flet-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flet-binop.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let a: i8 *= 1; //~ ERROR can't reassign to an uninitialized variable\n+    let _ = a;\n+    let b += 1; //~ ERROR can't reassign to an uninitialized variable\n+    let _ = b;\n+    let c *= 1; //~ ERROR can't reassign to an uninitialized variable\n+    let _ = c;\n+}"}, {"sha": "71431499ac70b8c0ea43c7e8db333fac646da5e4", "filename": "src/test/ui/parser/let-binop.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fparser%2Flet-binop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fparser%2Flet-binop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flet-binop.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,20 @@\n+error: can't reassign to an uninitialized variable\n+  --> $DIR/let-binop.rs:2:15\n+   |\n+LL |     let a: i8 *= 1;\n+   |               ^^ help: initialize the variable\n+\n+error: can't reassign to an uninitialized variable\n+  --> $DIR/let-binop.rs:4:11\n+   |\n+LL |     let b += 1;\n+   |           ^^ help: initialize the variable\n+\n+error: can't reassign to an uninitialized variable\n+  --> $DIR/let-binop.rs:6:11\n+   |\n+LL |     let c *= 1;\n+   |           ^^ help: initialize the variable\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "7e8f78067e08af9d8d699016cb12f2e4026488e3", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.nll.stderr", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,21 +1,21 @@\n-error[E0621]: explicit lifetime required in the type of `v`\n+error: lifetime may not live long enough\n   --> $DIR/region-object-lifetime-in-coercion.rs:8:12\n    |\n LL | fn a(v: &[u8]) -> Box<dyn Foo + 'static> {\n-   |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n+   |         - let's call the lifetime of this reference `'1`\n LL |     let x: Box<dyn Foo + 'static> = Box::new(v);\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ lifetime `'static` required\n+   |            ^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'1` must outlive `'static`\n \n-error[E0621]: explicit lifetime required in the type of `v`\n-  --> $DIR/region-object-lifetime-in-coercion.rs:14:5\n+error: lifetime may not live long enough\n+  --> $DIR/region-object-lifetime-in-coercion.rs:13:5\n    |\n LL | fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n-   |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n+   |         - let's call the lifetime of this reference `'1`\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^ lifetime `'static` required\n+   |     ^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/region-object-lifetime-in-coercion.rs:20:5\n+  --> $DIR/region-object-lifetime-in-coercion.rs:19:5\n    |\n LL | fn c(v: &[u8]) -> Box<dyn Foo> {\n    |         - let's call the lifetime of this reference `'1`\n@@ -24,7 +24,7 @@ LL |     Box::new(v)\n    |     ^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/region-object-lifetime-in-coercion.rs:24:5\n+  --> $DIR/region-object-lifetime-in-coercion.rs:23:5\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |      -- -- lifetime `'b` defined here\n@@ -37,4 +37,3 @@ LL |     Box::new(v)\n \n error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0621`."}, {"sha": "5d199149c39b860d029bc80728988afe33c76b25", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -5,13 +5,12 @@ trait Foo {}\n impl<'a> Foo for &'a [u8] {}\n \n fn a(v: &[u8]) -> Box<dyn Foo + 'static> {\n-    let x: Box<dyn Foo + 'static> = Box::new(v);\n-    //~^ ERROR explicit lifetime required in the type of `v` [E0621]\n+    let x: Box<dyn Foo + 'static> = Box::new(v); //~ ERROR cannot infer an appropriate lifetime\n     x\n }\n \n fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n-    Box::new(v) //~ ERROR explicit lifetime required in the type of `v` [E0621]\n+    Box::new(v) //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn c(v: &[u8]) -> Box<dyn Foo> {"}, {"sha": "7f5a3a47976c7d38f812fa9fb9a1232657dd2a1c", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.stderr", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,61 +1,76 @@\n-error[E0621]: explicit lifetime required in the type of `v`\n-  --> $DIR/region-object-lifetime-in-coercion.rs:8:37\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/region-object-lifetime-in-coercion.rs:8:46\n    |\n LL | fn a(v: &[u8]) -> Box<dyn Foo + 'static> {\n-   |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n+   |         ----- this data with an anonymous lifetime `'_`...\n LL |     let x: Box<dyn Foo + 'static> = Box::new(v);\n-   |                                     ^^^^^^^^^^^ lifetime `'static` required\n+   |                                              ^ ...is captured here, requiring it to live as long as `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n+   |\n+LL | fn a(v: &[u8]) -> Box<dyn Foo + '_> {\n+   |                                 ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn a(v: &'static [u8]) -> Box<dyn Foo + 'static> {\n+   |         ^^^^^^^^^^^^^\n \n-error[E0621]: explicit lifetime required in the type of `v`\n-  --> $DIR/region-object-lifetime-in-coercion.rs:14:5\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/region-object-lifetime-in-coercion.rs:13:14\n    |\n LL | fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n-   |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n+   |         ----- this data with an anonymous lifetime `'_`...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^ lifetime `'static` required\n+   |              ^ ...is captured here, requiring it to live as long as `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n+   |\n+LL | fn b(v: &[u8]) -> Box<dyn Foo + '_> {\n+   |                                 ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn b(v: &'static [u8]) -> Box<dyn Foo + 'static> {\n+   |         ^^^^^^^^^^^^^\n \n-error: cannot infer an appropriate lifetime\n-  --> $DIR/region-object-lifetime-in-coercion.rs:20:14\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/region-object-lifetime-in-coercion.rs:19:14\n    |\n LL | fn c(v: &[u8]) -> Box<dyn Foo> {\n-   |         ----- data with this lifetime...\n+   |         ----- this data with an anonymous lifetime `'_`...\n ...\n LL |     Box::new(v)\n-   |     ---------^-\n-   |     |        |\n-   |     |        ...and is captured here\n-   |     ...is required to be `'static` by this...\n+   |              ^ ...is captured here, requiring it to live as long as `'static`\n    |\n-help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 17:1\n+help: to declare that the trait object captures data from argument `v`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn c(v: &[u8]) -> Box<dyn Foo + '_> {\n    |                               ^^^^\n \n error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n-  --> $DIR/region-object-lifetime-in-coercion.rs:24:14\n+  --> $DIR/region-object-lifetime-in-coercion.rs:23:14\n    |\n LL |     Box::new(v)\n    |              ^\n    |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 23:6...\n-  --> $DIR/region-object-lifetime-in-coercion.rs:23:6\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 22:6...\n+  --> $DIR/region-object-lifetime-in-coercion.rs:22:6\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |      ^^\n note: ...so that the expression is assignable\n-  --> $DIR/region-object-lifetime-in-coercion.rs:24:14\n+  --> $DIR/region-object-lifetime-in-coercion.rs:23:14\n    |\n LL |     Box::new(v)\n    |              ^\n    = note: expected `&[u8]`\n               found `&'a [u8]`\n-note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 23:9...\n-  --> $DIR/region-object-lifetime-in-coercion.rs:23:9\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 22:9...\n+  --> $DIR/region-object-lifetime-in-coercion.rs:22:9\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |         ^^\n note: ...so that the expression is assignable\n-  --> $DIR/region-object-lifetime-in-coercion.rs:24:5\n+  --> $DIR/region-object-lifetime-in-coercion.rs:23:5\n    |\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^\n@@ -64,5 +79,5 @@ LL |     Box::new(v)\n \n error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0495, E0621.\n+Some errors have detailed explanations: E0495, E0759.\n For more information about an error, try `rustc --explain E0495`."}, {"sha": "114e4052aae09b63159cc61e3899af7c0e982403", "filename": "src/test/ui/regions/regions-close-object-into-object-2.stderr", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,28 +1,20 @@\n-error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/regions-close-object-into-object-2.rs:10:11\n    |\n+LL | fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'static> {\n+   |                         ------------------ this data with lifetime `'a`...\n LL |     box B(&*v) as Box<dyn X>\n-   |           ^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 9:6...\n-  --> $DIR/regions-close-object-into-object-2.rs:9:6\n+   |           ^^^ ...is captured here, requiring it to live as long as `'static`\n    |\n-LL | fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'static> {\n-   |      ^^\n-note: ...so that the type `(dyn A<T> + 'a)` is not borrowed for too long\n-  --> $DIR/regions-close-object-into-object-2.rs:10:11\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n    |\n-LL |     box B(&*v) as Box<dyn X>\n-   |           ^^^\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the expression is assignable\n-  --> $DIR/regions-close-object-into-object-2.rs:10:5\n+LL | fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'a> {\n+   |                                                            ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n    |\n-LL |     box B(&*v) as Box<dyn X>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected `std::boxed::Box<(dyn X + 'static)>`\n-              found `std::boxed::Box<dyn X>`\n+LL | fn g<'a, T: 'static>(v: std::boxed::Box<(dyn A<T> + 'static)>) -> Box<dyn X + 'static> {\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "850d81940791fd168afbe9224765cf642bbaaf61", "filename": "src/test/ui/regions/regions-close-object-into-object-4.stderr", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,28 +1,20 @@\n-error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/regions-close-object-into-object-4.rs:10:11\n    |\n+LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n+   |                   ---------------- this data with lifetime `'a`...\n LL |     box B(&*v) as Box<dyn X>\n-   |           ^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 9:6...\n-  --> $DIR/regions-close-object-into-object-4.rs:9:6\n+   |           ^^^ ...is captured here, requiring it to live as long as `'static`\n    |\n-LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n-   |      ^^\n-note: ...so that the type `(dyn A<U> + 'a)` is not borrowed for too long\n-  --> $DIR/regions-close-object-into-object-4.rs:10:11\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n    |\n-LL |     box B(&*v) as Box<dyn X>\n-   |           ^^^\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the expression is assignable\n-  --> $DIR/regions-close-object-into-object-4.rs:10:5\n+LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'a> {\n+   |                                                    ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n    |\n-LL |     box B(&*v) as Box<dyn X>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected `std::boxed::Box<(dyn X + 'static)>`\n-              found `std::boxed::Box<dyn X>`\n+LL | fn i<'a, T, U>(v: std::boxed::Box<(dyn A<U> + 'static)>) -> Box<dyn X + 'static> {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "75890b8581537fc7b6ef6d36a42c00cdc94a232f", "filename": "src/test/ui/regions/regions-proc-bound-capture.nll.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.nll.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,11 @@\n+error: lifetime may not live long enough\n+  --> $DIR/regions-proc-bound-capture.rs:9:5\n+   |\n+LL | fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n+   |                   - let's call the lifetime of this reference `'1`\n+LL |     // This is illegal, because the region bound on `proc` is 'static.\n+LL |     Box::new(move || { *x })\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "8617c0e9da8f76f51a6319847965b265e8aff148", "filename": "src/test/ui/regions/regions-proc-bound-capture.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -4,9 +4,9 @@ fn borrowed_proc<'a>(x: &'a isize) -> Box<dyn FnMut()->(isize) + 'a> {\n     Box::new(move|| { *x })\n }\n \n-fn static_proc(x: &isize) -> Box<dyn FnMut()->(isize) + 'static> {\n+fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n     // This is illegal, because the region bound on `proc` is 'static.\n-    Box::new(move|| { *x }) //~ ERROR explicit lifetime required in the type of `x` [E0621]\n+    Box::new(move || { *x }) //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() { }"}, {"sha": "67eee3bb6e28127bbd8db3417d40386340b6a38f", "filename": "src/test/ui/regions/regions-proc-bound-capture.stderr", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,12 +1,21 @@\n-error[E0621]: explicit lifetime required in the type of `x`\n-  --> $DIR/regions-proc-bound-capture.rs:9:5\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/regions-proc-bound-capture.rs:9:14\n    |\n-LL | fn static_proc(x: &isize) -> Box<dyn FnMut()->(isize) + 'static> {\n-   |                   ------ help: add explicit lifetime `'static` to the type of `x`: `&'static isize`\n+LL | fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n+   |                   ------ this data with an anonymous lifetime `'_`...\n LL |     // This is illegal, because the region bound on `proc` is 'static.\n-LL |     Box::new(move|| { *x })\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^ lifetime `'static` required\n+LL |     Box::new(move || { *x })\n+   |              ^^^^^^^^^^^^^^ ...is captured here, requiring it to live as long as `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + '_> {\n+   |                                                           ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn static_proc(x: &'static isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n+   |                   ^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0621`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "3fb1cf9f557b2c86d71de72e61fa2c51c0895381", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-1.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,6 @@\n+#![feature(non_ascii_idents)]\n+\n+extern crate \u044c\u0430\u0433; //~ ERROR cannot load a crate with a non-ascii name `\u044c\u0430\u0433`\n+//~| ERROR can't find crate for `\u044c\u0430\u0433`\n+\n+fn main() {}"}, {"sha": "1e424237fd238480f5a37082015ed1f34df0f8f0", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,15 @@\n+error: cannot load a crate with a non-ascii name `\u044c\u0430\u0433`\n+  --> $DIR/crate_name_nonascii_forbidden-1.rs:3:1\n+   |\n+LL | extern crate \u044c\u0430\u0433;\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error[E0463]: can't find crate for `\u044c\u0430\u0433`\n+  --> $DIR/crate_name_nonascii_forbidden-1.rs:3:1\n+   |\n+LL | extern crate \u044c\u0430\u0433;\n+   | ^^^^^^^^^^^^^^^^^ can't find crate\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0463`."}, {"sha": "e1acdbff06189efd8b07c8f493e927ec98596900", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags:--extern \u043c\u0443_\u0441\u0433\u0430\u0442\u0435\n+// edition:2018\n+#![feature(non_ascii_idents)]\n+\n+use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz; //~  ERROR cannot load a crate with a non-ascii name `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n+                   //~| can't find crate for `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n+\n+\n+fn main() {}"}, {"sha": "c06405ebb37ec6a15e736c607e7387babfb0606d", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,15 @@\n+error: cannot load a crate with a non-ascii name `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n+  --> $DIR/crate_name_nonascii_forbidden-2.rs:5:5\n+   |\n+LL | use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz;\n+   |     ^^^^^^^^\n+\n+error[E0463]: can't find crate for `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n+  --> $DIR/crate_name_nonascii_forbidden-2.rs:5:5\n+   |\n+LL | use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz;\n+   |     ^^^^^^^^ can't find crate\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0463`."}, {"sha": "cee73b0425ad52210f7032b7e6b9262babad2b51", "filename": "src/test/ui/sanitize/address.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Faddress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Faddress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Faddress.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,5 +1,5 @@\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-address\n //\n // compile-flags: -Z sanitizer=address -O -g\n //"}, {"sha": "095a6f4697b1c15a35a1e5139531b3ec5b4bfa46", "filename": "src/test/ui/sanitize/badfree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fbadfree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fbadfree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fbadfree.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,5 +1,5 @@\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-address\n //\n // compile-flags: -Z sanitizer=address -O\n //"}, {"sha": "79dfe58f04d0b48274bac1512000aec19a327098", "filename": "src/test/ui/sanitize/cfg.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fcfg.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,8 +2,10 @@\n // the `#[cfg(sanitize = \"option\")]` attribute is configured.\n \n // needs-sanitizer-support\n-// only-linux\n-// only-x86_64\n+// needs-sanitizer-address\n+// needs-sanitizer-leak\n+// needs-sanitizer-memory\n+// needs-sanitizer-thread\n // check-pass\n // revisions: address leak memory thread\n //[address]compile-flags: -Zsanitizer=address --cfg address"}, {"sha": "b2e182238ce288803b0cd9116c8be6d8fb939d01", "filename": "src/test/ui/sanitize/issue-72154-lifetime-markers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fissue-72154-lifetime-markers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fissue-72154-lifetime-markers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fissue-72154-lifetime-markers.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -4,7 +4,7 @@\n // miscompilation which was subsequently detected by AddressSanitizer as UB.\n //\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-address\n //\n // compile-flags: -Copt-level=0 -Zsanitizer=address\n // run-pass"}, {"sha": "c9f10fe4f467ed73c8bdc7a4a92944bcf49c788e", "filename": "src/test/ui/sanitize/leak.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fleak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fleak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fleak.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,5 +1,5 @@\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-leak\n //\n // compile-flags: -Z sanitizer=leak -O\n //"}, {"sha": "a26649a5800131e20a6820ec72a123263552a84a", "filename": "src/test/ui/sanitize/memory.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fmemory.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,6 +1,5 @@\n // needs-sanitizer-support\n-// only-linux\n-// only-x86_64\n+// needs-sanitizer-memory\n //\n // compile-flags: -Z sanitizer=memory -Zsanitizer-memory-track-origins -O\n //"}, {"sha": "64d6ccf34091681d386c7c3f746c7e529e2d15fb", "filename": "src/test/ui/sanitize/new-llvm-pass-manager-thin-lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -4,7 +4,7 @@\n //\n // min-llvm-version 9.0\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-address\n //\n // no-prefer-dynamic\n // revisions: opt0 opt1"}, {"sha": "c70cf5accc0776611cf557a43178b708e002708e", "filename": "src/test/ui/sanitize/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fthread.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -11,7 +11,7 @@\n // would occasionally fail, making test flaky.\n //\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-thread\n //\n // compile-flags: -Z sanitizer=thread -O\n //"}, {"sha": "30be2ae6f090641e4bdacb7374f0940b521370fd", "filename": "src/test/ui/sanitize/use-after-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fuse-after-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsanitize%2Fuse-after-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fuse-after-scope.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,5 +1,5 @@\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-address\n //\n // compile-flags: -Zsanitizer=address\n // run-fail"}, {"sha": "88bd990b1e81b095e1c01ce8da9f0802b787ff90", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,11 +1,12 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:16\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                ^^^^  ----------     ---------- ...and required to be `'static` by this\n+   |                ^^^^  ----------     ---------- ...and is required to live as long as `'static` here\n    |                |     |\n-   |                |     data with this lifetime...\n+   |                |     this data with an anonymous lifetime `'_`...\n    |                ...is captured here...\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "2e10ab3d3f9b84a8c1802524008ab8020e311bd2", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,16 +1,21 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:44\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                ----------     ----------   ^^^^ ...and is captured here\n-   |                |              |\n-   |                |              ...is required to be `'static` by this...\n-   |                data with this lifetime...\n+   |                ----------                  ^^^^ ...is captured here...\n+   |                |\n+   |                this data with an anonymous lifetime `'_`...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the method body at 6:5\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:31\n+   |\n+LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n+   |                               ^^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n    |                                          ^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "9ab060328537b56b08f0f3dcf6b023edfcd3fea5", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -6,20 +6,23 @@ LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n    |        |\n    |        help: consider introducing lifetime `'a` here: `'a,`\n \n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/missing-lifetimes-in-signature.rs:19:5\n    |\n LL |   fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n-   |                            ------     ------------- ...is required to be `'static` by this...\n-   |                            |\n-   |                            data with this lifetime...\n+   |                            ------ this data with an anonymous lifetime `'_`...\n ...\n LL | /     move || {\n LL | |         *dest = g.get();\n LL | |     }\n-   | |_____^ ...and is captured here\n+   | |_____^ ...is captured here...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 15:1\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/missing-lifetimes-in-signature.rs:15:37\n+   |\n+LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+   |                                     ^^^^^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `dest`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n    |                                                   ^^^^\n@@ -122,5 +125,5 @@ LL | fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n \n error: aborting due to 7 previous errors\n \n-Some errors have detailed explanations: E0261, E0309, E0621.\n+Some errors have detailed explanations: E0261, E0309, E0621, E0759.\n For more information about an error, try `rustc --explain E0261`."}, {"sha": "4cbfe58d357038ac3e4d6157ea6d60c1cb41df2b", "filename": "src/test/ui/suggestions/type-not-found-in-adt-field.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsuggestions%2Ftype-not-found-in-adt-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsuggestions%2Ftype-not-found-in-adt-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-not-found-in-adt-field.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,9 @@\n+struct Struct {\n+    m: Vec<Someunknownname<String, ()>>, //~ ERROR cannot find type `Someunknownname` in this scope\n+    //~^ NOTE not found in this scope\n+}\n+struct OtherStruct { //~ HELP you might be missing a type parameter\n+    m: K, //~ ERROR cannot find type `K` in this scope\n+    //~^ NOTE not found in this scope\n+}\n+fn main() {}"}, {"sha": "e990fb5ba12107c67dbe22e3abdc2259a99cddb5", "filename": "src/test/ui/suggestions/type-not-found-in-adt-field.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsuggestions%2Ftype-not-found-in-adt-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Fsuggestions%2Ftype-not-found-in-adt-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-not-found-in-adt-field.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,17 @@\n+error[E0412]: cannot find type `Someunknownname` in this scope\n+  --> $DIR/type-not-found-in-adt-field.rs:2:12\n+   |\n+LL |     m: Vec<Someunknownname<String, ()>>,\n+   |            ^^^^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `K` in this scope\n+  --> $DIR/type-not-found-in-adt-field.rs:6:8\n+   |\n+LL | struct OtherStruct {\n+   |                   - help: you might be missing a type parameter: `<K>`\n+LL |     m: K,\n+   |        ^ not found in this scope\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "53e68c2ac6af64dc9ec6f6c1c7c59c10fe9726c7", "filename": "src/test/ui/tag-variant-cast-non-nullary.fixed", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.fixed?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,20 @@\n+// run-rustfix\n+#![allow(dead_code, unused_variables)]\n+enum NonNullary {\n+    Nullary,\n+    Other(isize),\n+}\n+\n+impl From<NonNullary> for isize {\n+    fn from(val: NonNullary) -> isize {\n+        match val {\n+            NonNullary::Nullary => 0,\n+            NonNullary::Other(i) => i,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let v = NonNullary::Nullary;\n+    let val = isize::from(v); //~ ERROR non-primitive cast: `NonNullary` as `isize` [E0605]\n+}"}, {"sha": "0d0c6188ad114f2d3cb5c8efd121092f228ab320", "filename": "src/test/ui/tag-variant-cast-non-nullary.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,8 +1,19 @@\n+// run-rustfix\n+#![allow(dead_code, unused_variables)]\n enum NonNullary {\n     Nullary,\n     Other(isize),\n }\n \n+impl From<NonNullary> for isize {\n+    fn from(val: NonNullary) -> isize {\n+        match val {\n+            NonNullary::Nullary => 0,\n+            NonNullary::Other(i) => i,\n+        }\n+    }\n+}\n+\n fn main() {\n     let v = NonNullary::Nullary;\n     let val = v as isize; //~ ERROR non-primitive cast: `NonNullary` as `isize` [E0605]"}, {"sha": "ae2f5a7aead552f9346eb0a231865d2d2690ce62", "filename": "src/test/ui/tag-variant-cast-non-nullary.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,10 +1,10 @@\n error[E0605]: non-primitive cast: `NonNullary` as `isize`\n-  --> $DIR/tag-variant-cast-non-nullary.rs:8:15\n+  --> $DIR/tag-variant-cast-non-nullary.rs:19:15\n    |\n LL |     let val = v as isize;\n-   |               ^^^^^^^^^^\n+   |               ^^^^^^^^^^ help: consider using the `From` trait instead: `isize::from(v)`\n    |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   = note: an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "a6b7e35b488b17388d9fc2502c64001a8d0c9aa6", "filename": "src/test/ui/type-alias-impl-trait/never_reveal_concrete_type.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -16,9 +16,7 @@ error[E0605]: non-primitive cast: `impl std::fmt::Debug` as `&'static str`\n   --> $DIR/never_reveal_concrete_type.rs:14:13\n    |\n LL |     let _ = x as &'static str;\n-   |             ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e4436260e70a07ac26d90c715b3995087ec58379", "filename": "src/test/ui/typeck/issue-68590-reborrow-through-derefmut.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ftypeck%2Fissue-68590-reborrow-through-derefmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ftypeck%2Fissue-68590-reborrow-through-derefmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-68590-reborrow-through-derefmut.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+\n+// rust-lang/rust#68590: confusing diagnostics when reborrowing through DerefMut.\n+\n+use std::cell::RefCell;\n+\n+struct A;\n+\n+struct S<'a> {\n+    a: &'a mut A,\n+}\n+\n+fn take_a(_: &mut A) {}\n+\n+fn test<'a>(s: &RefCell<S<'a>>) {\n+    let mut guard = s.borrow_mut();\n+    take_a(guard.a);\n+    let _s2 = S { a: guard.a };\n+}\n+\n+fn main() {\n+    let a = &mut A;\n+    let s = RefCell::new(S { a });\n+    test(&s);\n+}"}, {"sha": "3ea05389f04a0b7ae8c2fdd3c8f31f34e37b1178", "filename": "src/test/ui/typeck/issue-72225-call-fnmut-through-derefmut.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ftypeck%2Fissue-72225-call-fnmut-through-derefmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Ftypeck%2Fissue-72225-call-fnmut-through-derefmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-72225-call-fnmut-through-derefmut.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+\n+// rust-lang/rust#72225: confusing diagnostics when calling FnMut through DerefMut.\n+\n+use std::cell::RefCell;\n+\n+struct S {\n+    f: Box<dyn FnMut()>\n+}\n+\n+fn test(s: &RefCell<S>) {\n+    let mut guard = s.borrow_mut();\n+    (guard.f)();\n+}\n+\n+fn main() {\n+    let s = RefCell::new(S {\n+        f: Box::new(|| ())\n+    });\n+    test(&s);\n+}"}, {"sha": "dda5de431d30944e4e0f9a1f4f6c5c221773c609", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -1,16 +1,17 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/dyn-trait-underscore.rs:8:20\n    |\n LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n-   |                ---- data with this lifetime...\n+   |                ---- this data with an anonymous lifetime `'_`...\n LL |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n LL |     Box::new(items.iter())\n-   |     ---------------^^^^--- ...is captured and required to be `'static` here\n+   |     ---------------^^^^--- ...is captured and required to live as long as `'static` here\n    |\n-help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 6:1\n+help: to declare that the trait object captures data from argument `items`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T> + '_> {\n    |                                                   ^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "a9f10dfec994a9e4c7a71ca776e2fca44abb058f", "filename": "src/test/ui/uninhabited/uninhabited-enum-cast.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-enum-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-enum-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-enum-cast.stderr?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -2,9 +2,7 @@ error[E0605]: non-primitive cast: `E` as `isize`\n   --> $DIR/uninhabited-enum-cast.rs:4:20\n    |\n LL |     println!(\"{}\", (e as isize).to_string());\n-   |                    ^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |                    ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "9614707433e13af4a0111db8a271c7aa8f9547c7", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -43,6 +43,10 @@ impl EarlyProps {\n         let mut props = EarlyProps::default();\n         let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();\n         let rustc_has_sanitizer_support = env::var_os(\"RUSTC_SANITIZER_SUPPORT\").is_some();\n+        let has_asan = util::ASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n+        let has_lsan = util::LSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n+        let has_msan = util::MSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n+        let has_tsan = util::TSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n \n         iter_header(testfile, None, rdr, &mut |ln| {\n             // we should check if any only-<platform> exists and if it exists\n@@ -74,7 +78,25 @@ impl EarlyProps {\n                     props.ignore = true;\n                 }\n \n-                if !rustc_has_sanitizer_support && config.parse_needs_sanitizer_support(ln) {\n+                if !rustc_has_sanitizer_support\n+                    && config.parse_name_directive(ln, \"needs-sanitizer-support\")\n+                {\n+                    props.ignore = true;\n+                }\n+\n+                if !has_asan && config.parse_name_directive(ln, \"needs-sanitizer-address\") {\n+                    props.ignore = true;\n+                }\n+\n+                if !has_lsan && config.parse_name_directive(ln, \"needs-sanitizer-leak\") {\n+                    props.ignore = true;\n+                }\n+\n+                if !has_msan && config.parse_name_directive(ln, \"needs-sanitizer-memory\") {\n+                    props.ignore = true;\n+                }\n+\n+                if !has_tsan && config.parse_name_directive(ln, \"needs-sanitizer-thread\") {\n                     props.ignore = true;\n                 }\n \n@@ -829,10 +851,6 @@ impl Config {\n         self.parse_name_directive(line, \"needs-profiler-support\")\n     }\n \n-    fn parse_needs_sanitizer_support(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"needs-sanitizer-support\")\n-    }\n-\n     /// Parses a name-value directive which contains config-specific information, e.g., `ignore-x86`\n     /// or `normalize-stderr-32bit`.\n     fn parse_cfg_name_directive(&self, line: &str, prefix: &str) -> ParsedNameDirective {"}, {"sha": "72af34d78260ba6007a385300ba0c8be2aeb8622", "filename": "src/tools/compiletest/src/header/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ccccddc18e83faa9963824112b14b3b1a93c2/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs?ref=791ccccddc18e83faa9963824112b14b3b1a93c2", "patch": "@@ -201,3 +201,22 @@ fn debugger() {\n     config.debugger = Some(Debugger::Lldb);\n     assert!(parse_rs(&config, \"// ignore-lldb\").ignore);\n }\n+\n+#[test]\n+fn sanitizers() {\n+    let mut config = config();\n+\n+    // Target that supports all sanitizers:\n+    config.target = \"x86_64-unknown-linux-gnu\".to_owned();\n+    assert!(!parse_rs(&config, \"// needs-sanitizer-address\").ignore);\n+    assert!(!parse_rs(&config, \"// needs-sanitizer-leak\").ignore);\n+    assert!(!parse_rs(&config, \"// needs-sanitizer-memory\").ignore);\n+    assert!(!parse_rs(&config, \"// needs-sanitizer-thread\").ignore);\n+\n+    // Target that doesn't support sanitizers:\n+    config.target = \"wasm32-unknown-emscripten\".to_owned();\n+    assert!(parse_rs(&config, \"// needs-sanitizer-address\").ignore);\n+    assert!(parse_rs(&config, \"// needs-sanitizer-leak\").ignore);\n+    assert!(parse_rs(&config, \"// needs-sanitizer-memory\").ignore);\n+    assert!(parse_rs(&config, \"// needs-sanitizer-thread\").ignore);\n+}"}]}