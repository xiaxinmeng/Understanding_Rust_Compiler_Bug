{"sha": "a91f3794be69cf8626cfb1ce3b443f24902929fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MWYzNzk0YmU2OWNmODYyNmNmYjFjZTNiNDQzZjI0OTAyOTI5ZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-09T11:43:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-09T11:43:26Z"}, "message": "Auto merge of #1127 - rust-lang:stacked_borrow_tracing, r=RalfJung\n\nAdd a scheme for emitting errors without halting interpretation\n\ncc #797", "tree": {"sha": "974374b1949ae9edecbd01535f4db74179c87f17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/974374b1949ae9edecbd01535f4db74179c87f17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a91f3794be69cf8626cfb1ce3b443f24902929fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a91f3794be69cf8626cfb1ce3b443f24902929fb", "html_url": "https://github.com/rust-lang/rust/commit/a91f3794be69cf8626cfb1ce3b443f24902929fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a91f3794be69cf8626cfb1ce3b443f24902929fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85ab34826a606308451bf8b47143b64f224bfaf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/85ab34826a606308451bf8b47143b64f224bfaf9", "html_url": "https://github.com/rust-lang/rust/commit/85ab34826a606308451bf8b47143b64f224bfaf9"}, {"sha": "dbffbe52148ec0ef6cf5522b4171de40c93d4d65", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbffbe52148ec0ef6cf5522b4171de40c93d4d65", "html_url": "https://github.com/rust-lang/rust/commit/dbffbe52148ec0ef6cf5522b4171de40c93d4d65"}], "stats": {"total": 208, "additions": 128, "deletions": 80}, "files": [{"sha": "e68dfad1b9fae5e40a40cd9d3c1b87921f1b6637", "filename": "src/diagnostics.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a91f3794be69cf8626cfb1ce3b443f24902929fb/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a91f3794be69cf8626cfb1ce3b443f24902929fb/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=a91f3794be69cf8626cfb1ce3b443f24902929fb", "patch": "@@ -0,0 +1,108 @@\n+use rustc_mir::interpret::InterpErrorInfo;\n+use std::cell::RefCell;\n+\n+use crate::*;\n+\n+/// Miri specific diagnostics\n+pub enum NonHaltingDiagnostic {\n+    PoppedTrackedPointerTag(Item),\n+}\n+\n+/// Emit a custom diagnostic without going through the miri-engine machinery\n+pub fn report_diagnostic<'tcx, 'mir>(\n+    ecx: &InterpCx<'mir, 'tcx, Evaluator<'tcx>>,\n+    mut e: InterpErrorInfo<'tcx>,\n+) -> Option<i64> {\n+    // Special treatment for some error kinds\n+    let msg = match e.kind {\n+        InterpError::MachineStop(ref info) => {\n+            let info = info.downcast_ref::<TerminationInfo>().expect(\"invalid MachineStop payload\");\n+            match info {\n+                TerminationInfo::Exit(code) => return Some(*code),\n+                TerminationInfo::Abort => format!(\"the evaluated program aborted execution\"),\n+            }\n+        }\n+        err_unsup!(NoMirFor(..)) => format!(\n+            \"{}. Did you set `MIRI_SYSROOT` to a Miri-enabled sysroot? You can prepare one with `cargo miri setup`.\",\n+            e\n+        ),\n+        InterpError::InvalidProgram(_) => bug!(\"This error should be impossible in Miri: {}\", e),\n+        _ => e.to_string(),\n+    };\n+    e.print_backtrace();\n+    report_msg(ecx, msg, true)\n+}\n+\n+/// Report an error or note (depending on the `error` argument) at the current frame's current statement.\n+/// Also emits a full stacktrace of the interpreter stack.\n+pub fn report_msg<'tcx, 'mir>(\n+    ecx: &InterpCx<'mir, 'tcx, Evaluator<'tcx>>,\n+    msg: String,\n+    error: bool,\n+) -> Option<i64> {\n+    if let Some(frame) = ecx.stack().last() {\n+        let span = frame.current_source_info().unwrap().span;\n+\n+        let mut err = if error {\n+            let msg = format!(\"Miri evaluation error: {}\", msg);\n+            ecx.tcx.sess.struct_span_err(span, msg.as_str())\n+        } else {\n+            ecx.tcx.sess.diagnostic().span_note_diag(span, msg.as_str())\n+        };\n+        let frames = ecx.generate_stacktrace(None);\n+        err.span_label(span, msg);\n+        // We iterate with indices because we need to look at the next frame (the caller).\n+        for idx in 0..frames.len() {\n+            let frame_info = &frames[idx];\n+            let call_site_is_local = frames\n+                .get(idx + 1)\n+                .map_or(false, |caller_info| caller_info.instance.def_id().is_local());\n+            if call_site_is_local {\n+                err.span_note(frame_info.call_site, &frame_info.to_string());\n+            } else {\n+                err.note(&frame_info.to_string());\n+            }\n+        }\n+        err.emit();\n+    } else {\n+        ecx.tcx.sess.err(&msg);\n+    }\n+\n+    for (i, frame) in ecx.stack().iter().enumerate() {\n+        trace!(\"-------------------\");\n+        trace!(\"Frame {}\", i);\n+        trace!(\"    return: {:?}\", frame.return_place.map(|p| *p));\n+        for (i, local) in frame.locals.iter().enumerate() {\n+            trace!(\"    local {}: {:?}\", i, local.value);\n+        }\n+    }\n+    // Let the reported error determine the return code.\n+    return None;\n+}\n+\n+thread_local! {\n+    static DIAGNOSTICS: RefCell<Vec<NonHaltingDiagnostic>> = RefCell::new(Vec::new());\n+}\n+\n+/// Schedule a diagnostic for emitting. This function works even if you have no `InterpCx` available.\n+/// The diagnostic will be emitted after the current interpreter step is finished.\n+pub fn register_diagnostic(e: NonHaltingDiagnostic) {\n+    DIAGNOSTICS.with(|diagnostics| diagnostics.borrow_mut().push(e));\n+}\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    /// Emit all diagnostics that were registed with `register_diagnostics`\n+    fn process_diagnostics(&self) {\n+        let this = self.eval_context_ref();\n+        DIAGNOSTICS.with(|diagnostics| {\n+            for e in diagnostics.borrow_mut().drain(..) {\n+                let msg = match e {\n+                    NonHaltingDiagnostic::PoppedTrackedPointerTag(item) =>\n+                        format!(\"popped tracked tag for item {:?}\", item),\n+                };\n+                report_msg(this, msg, false);\n+            }\n+        });\n+    }\n+}"}, {"sha": "7a3945220f7725808277ce6b3651f005165a3fb2", "filename": "src/eval.rs", "status": "modified", "additions": 5, "deletions": 62, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a91f3794be69cf8626cfb1ce3b443f24902929fb/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a91f3794be69cf8626cfb1ce3b443f24902929fb/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=a91f3794be69cf8626cfb1ce3b443f24902929fb", "patch": "@@ -33,7 +33,6 @@ pub struct MiriConfig {\n /// Details of premature program termination.\n pub enum TerminationInfo {\n     Exit(i64),\n-    PoppedTrackedPointerTag(Item),\n     Abort,\n }\n \n@@ -183,7 +182,9 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n \n     // Perform the main execution.\n     let res: InterpResult<'_, i64> = (|| {\n-        ecx.run()?;\n+        while ecx.step()? {\n+            ecx.process_diagnostics();\n+        }\n         // Read the return code pointer *before* we run TLS destructors, to assert\n         // that it was written to by the time that `start` lang item returned.\n         let return_code = ecx.read_scalar(ret_place.into())?.not_undef()?.to_machine_isize(&ecx)?;\n@@ -203,66 +204,8 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n                     return None;\n                 }\n             }\n-            return Some(return_code);\n-        }\n-        Err(mut e) => {\n-            // Special treatment for some error kinds\n-            let msg = match e.kind {\n-                InterpError::MachineStop(ref info) => {\n-                    let info = info\n-                        .downcast_ref::<TerminationInfo>()\n-                        .expect(\"invalid MachineStop payload\");\n-                    match info {\n-                        TerminationInfo::Exit(code) => return Some(*code),\n-                        TerminationInfo::PoppedTrackedPointerTag(item) =>\n-                            format!(\"popped tracked tag for item {:?}\", item),\n-                        TerminationInfo::Abort =>\n-                            format!(\"the evaluated program aborted execution\"),\n-                    }\n-                }\n-                err_unsup!(NoMirFor(..)) => format!(\n-                    \"{}. Did you set `MIRI_SYSROOT` to a Miri-enabled sysroot? You can prepare one with `cargo miri setup`.\",\n-                    e\n-                ),\n-                InterpError::InvalidProgram(_) =>\n-                    bug!(\"This error should be impossible in Miri: {}\", e),\n-                _ => e.to_string(),\n-            };\n-            e.print_backtrace();\n-            if let Some(frame) = ecx.stack().last() {\n-                let span = frame.current_source_info().unwrap().span;\n-\n-                let msg = format!(\"Miri evaluation error: {}\", msg);\n-                let mut err = ecx.tcx.sess.struct_span_err(span, msg.as_str());\n-                let frames = ecx.generate_stacktrace(None);\n-                err.span_label(span, msg);\n-                // We iterate with indices because we need to look at the next frame (the caller).\n-                for idx in 0..frames.len() {\n-                    let frame_info = &frames[idx];\n-                    let call_site_is_local = frames\n-                        .get(idx + 1)\n-                        .map_or(false, |caller_info| caller_info.instance.def_id().is_local());\n-                    if call_site_is_local {\n-                        err.span_note(frame_info.call_site, &frame_info.to_string());\n-                    } else {\n-                        err.note(&frame_info.to_string());\n-                    }\n-                }\n-                err.emit();\n-            } else {\n-                ecx.tcx.sess.err(&msg);\n-            }\n-\n-            for (i, frame) in ecx.stack().iter().enumerate() {\n-                trace!(\"-------------------\");\n-                trace!(\"Frame {}\", i);\n-                trace!(\"    return: {:?}\", frame.return_place.map(|p| *p));\n-                for (i, local) in frame.locals.iter().enumerate() {\n-                    trace!(\"    local {}: {:?}\", i, local.value);\n-                }\n-            }\n-            // Let the reported error determine the return code.\n-            return None;\n+            Some(return_code)\n         }\n+        Err(e) => report_diagnostic(&ecx, e),\n     }\n }"}, {"sha": "880a14b98c80ee707588f3b238f6308c5a9cce8b", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a91f3794be69cf8626cfb1ce3b443f24902929fb/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a91f3794be69cf8626cfb1ce3b443f24902929fb/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a91f3794be69cf8626cfb1ce3b443f24902929fb", "patch": "@@ -16,6 +16,7 @@ extern crate rustc_data_structures;\n extern crate rustc_mir;\n extern crate rustc_target;\n \n+mod diagnostics;\n mod eval;\n mod helpers;\n mod intptrcast;\n@@ -41,6 +42,9 @@ pub use crate::shims::time::EvalContextExt as TimeEvalContextExt;\n pub use crate::shims::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n pub use crate::shims::EvalContextExt as ShimsEvalContextExt;\n \n+pub use crate::diagnostics::{\n+    register_diagnostic, report_diagnostic, EvalContextExt as DiagnosticsEvalContextExt, NonHaltingDiagnostic,\n+};\n pub use crate::eval::{create_ecx, eval_main, MiriConfig, TerminationInfo};\n pub use crate::helpers::EvalContextExt as HelpersEvalContextExt;\n pub use crate::machine::{"}, {"sha": "1b7a118e637d6f1986af96e31994936d92c67383", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a91f3794be69cf8626cfb1ce3b443f24902929fb/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a91f3794be69cf8626cfb1ce3b443f24902929fb/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=a91f3794be69cf8626cfb1ce3b443f24902929fb", "patch": "@@ -11,10 +11,7 @@ use rustc_hir::Mutability;\n use rustc::mir::RetagKind;\n use rustc::ty::{self, layout::Size};\n \n-use crate::{\n-    AllocId, HelpersEvalContextExt, ImmTy, Immediate, InterpResult, MPlaceTy, MemoryKind,\n-    MiriMemoryKind, PlaceTy, Pointer, RangeMap, TerminationInfo,\n-};\n+use crate::*;\n \n pub type PtrId = NonZeroU64;\n pub type CallId = NonZeroU64;\n@@ -269,7 +266,7 @@ impl<'tcx> Stack {\n     fn check_protector(item: &Item, tag: Option<Tag>, global: &GlobalState) -> InterpResult<'tcx> {\n         if let Tag::Tagged(id) = item.tag {\n             if Some(id) == global.tracked_pointer_tag {\n-                throw_machine_stop!(TerminationInfo::PoppedTrackedPointerTag(item.clone()));\n+                register_diagnostic(NonHaltingDiagnostic::PoppedTrackedPointerTag(item.clone()));\n             }\n         }\n         if let Some(call) = item.protector {\n@@ -296,12 +293,9 @@ impl<'tcx> Stack {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n-            err_ub!(UbExperimental(format!(\n-                \"no item granting {} to tag {:?} found in borrow stack\",\n-                access, tag,\n-            )))\n-        })?;\n+        let granting_idx = self.find_granting(access, tag).ok_or_else(|| err_ub!(UbExperimental(\n+            format!(\"no item granting {} to tag {:?} found in borrow stack.\", access, tag),\n+        )))?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -340,12 +334,10 @@ impl<'tcx> Stack {\n     /// active protectors at all because we will remove all items.\n     fn dealloc(&mut self, tag: Tag, global: &GlobalState) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n-        self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n-            err_ub!(UbExperimental(format!(\n-                \"no item granting write access for deallocation to tag {:?} found in borrow stack\",\n-                tag,\n-            )))\n-        })?;\n+        self.find_granting(AccessKind::Write, tag).ok_or_else(|| err_ub!(UbExperimental(format!(\n+            \"no item granting write access for deallocation to tag {:?} found in borrow stack\",\n+            tag,\n+        ))))?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n         for item in self.borrows.drain(..).rev() {\n@@ -367,7 +359,8 @@ impl<'tcx> Stack {\n         // We use that to determine where to put the new item.\n         let granting_idx = self.find_granting(access, derived_from)\n             .ok_or_else(|| err_ub!(UbExperimental(format!(\n-                \"trying to reborrow for {:?}, but parent tag {:?} does not have an appropriate item in the borrow stack\", new.perm, derived_from,\n+                \"trying to reborrow for {:?}, but parent tag {:?} does not have an appropriate item in the borrow stack\",\n+                new.perm, derived_from,\n             ))))?;\n \n         // Compute where to put the new item."}]}