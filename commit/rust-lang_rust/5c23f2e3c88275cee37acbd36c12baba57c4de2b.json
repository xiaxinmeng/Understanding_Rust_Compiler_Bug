{"sha": "5c23f2e3c88275cee37acbd36c12baba57c4de2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMjNmMmUzYzg4Mjc1Y2VlMzdhY2JkMzZjMTJiYWJhNTdjNGRlMmI=", "commit": {"author": {"name": "Theodore DeRego", "email": "tedsta@google.com", "date": "2016-11-12T02:21:03Z"}, "committer": {"name": "Theodore DeRego", "email": "tedsta@google.com", "date": "2016-11-22T20:12:46Z"}, "message": "Fuchsia support for std::process via liblaunchpad.", "tree": {"sha": "f77bcfe12ed23ef51d5be7765c38ad9712e94f38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f77bcfe12ed23ef51d5be7765c38ad9712e94f38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c23f2e3c88275cee37acbd36c12baba57c4de2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c23f2e3c88275cee37acbd36c12baba57c4de2b", "html_url": "https://github.com/rust-lang/rust/commit/5c23f2e3c88275cee37acbd36c12baba57c4de2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c23f2e3c88275cee37acbd36c12baba57c4de2b/comments", "author": {"login": "tedsta", "id": 1218723, "node_id": "MDQ6VXNlcjEyMTg3MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1218723?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tedsta", "html_url": "https://github.com/tedsta", "followers_url": "https://api.github.com/users/tedsta/followers", "following_url": "https://api.github.com/users/tedsta/following{/other_user}", "gists_url": "https://api.github.com/users/tedsta/gists{/gist_id}", "starred_url": "https://api.github.com/users/tedsta/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tedsta/subscriptions", "organizations_url": "https://api.github.com/users/tedsta/orgs", "repos_url": "https://api.github.com/users/tedsta/repos", "events_url": "https://api.github.com/users/tedsta/events{/privacy}", "received_events_url": "https://api.github.com/users/tedsta/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tedsta", "id": 1218723, "node_id": "MDQ6VXNlcjEyMTg3MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1218723?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tedsta", "html_url": "https://github.com/tedsta", "followers_url": "https://api.github.com/users/tedsta/followers", "following_url": "https://api.github.com/users/tedsta/following{/other_user}", "gists_url": "https://api.github.com/users/tedsta/gists{/gist_id}", "starred_url": "https://api.github.com/users/tedsta/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tedsta/subscriptions", "organizations_url": "https://api.github.com/users/tedsta/orgs", "repos_url": "https://api.github.com/users/tedsta/repos", "events_url": "https://api.github.com/users/tedsta/events{/privacy}", "received_events_url": "https://api.github.com/users/tedsta/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0491a231777735ba050c208ce621df93f863bf7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0491a231777735ba050c208ce621df93f863bf7c", "html_url": "https://github.com/rust-lang/rust/commit/0491a231777735ba050c208ce621df93f863bf7c"}], "stats": {"total": 431, "additions": 426, "deletions": 5}, "files": [{"sha": "1087d1f24471b75e1a641ddd453fc79d6e2c5da7", "filename": "src/libstd/build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=5c23f2e3c88275cee37acbd36c12baba57c4de2b", "patch": "@@ -60,6 +60,8 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=shell32\");\n     } else if target.contains(\"fuchsia\") {\n         println!(\"cargo:rustc-link-lib=magenta\");\n+        println!(\"cargo:rustc-link-lib=mxio\");\n+        println!(\"cargo:rustc-link-lib=launchpad\"); // for std::process\n     }\n }\n "}, {"sha": "a9c68e82175b04e3edf1946f30d850a9211707c1", "filename": "src/libstd/process.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=5c23f2e3c88275cee37acbd36c12baba57c4de2b", "patch": "@@ -780,6 +780,8 @@ impl Child {\n     ///\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn wait_with_output(mut self) -> io::Result<Output> {\n+        //use io::ErrorKind;\n+\n         drop(self.stdin.take());\n \n         let (mut stdout, mut stderr) = (Vec::new(), Vec::new());\n@@ -794,8 +796,15 @@ impl Child {\n                 res.unwrap();\n             }\n             (Some(out), Some(err)) => {\n-                let res = read2(out.inner, &mut stdout, err.inner, &mut stderr);\n-                res.unwrap();\n+                match read2(out.inner, &mut stdout, err.inner, &mut stderr) {\n+                    Ok(()) => { },\n+                    #[cfg(not(target_os = \"fuchsia\"))]\n+                    Err(ref e) => { panic!(\"Failed to read child's stdout and stderr: {:?}\", e); },\n+                    #[cfg(target_os = \"fuchsia\")]\n+                    Err(_) => {\n+                        // FIXME: Right now there's a bug in magenta's pipes implementation\n+                    },\n+                }\n             }\n         }\n "}, {"sha": "61eb60da486c95e07af92462ef15fd515c0c0534", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=5c23f2e3c88275cee37acbd36c12baba57c4de2b", "patch": "@@ -110,6 +110,7 @@ impl FileDesc {\n     #[cfg(not(any(target_env = \"newlib\",\n                   target_os = \"solaris\",\n                   target_os = \"emscripten\",\n+                  target_os = \"fuchsia\",\n                   target_os = \"haiku\")))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n@@ -120,6 +121,7 @@ impl FileDesc {\n     #[cfg(any(target_env = \"newlib\",\n               target_os = \"solaris\",\n               target_os = \"emscripten\",\n+              target_os = \"fuchsia\",\n               target_os = \"haiku\"))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {"}, {"sha": "ae3b7789b1061bca01a3c4e39fd814dadc5f3e95", "filename": "src/libstd/sys/unix/magenta.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fsys%2Funix%2Fmagenta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fsys%2Funix%2Fmagenta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmagenta.rs?ref=5c23f2e3c88275cee37acbd36c12baba57c4de2b", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_camel_case_types)]\n+\n+use os::raw::c_char;\n+use u64;\n+\n+use libc::{c_int, c_void};\n+\n+pub type mx_handle_t = i32;\n+pub type mx_vaddr_t = usize;\n+pub type mx_rights_t = u32;\n+pub type mx_status_t = i32;\n+\n+pub type mx_size_t = usize;\n+pub type mx_ssize_t = isize;\n+\n+pub const MX_HANDLE_INVALID: mx_handle_t = 0;\n+\n+pub type mx_time_t = u64;\n+pub const MX_TIME_INFINITE : mx_time_t = u64::MAX;\n+\n+pub const NO_ERROR              : mx_status_t = 0;\n+\n+pub type mx_signals_t = u32;\n+\n+pub const MX_OBJECT_SIGNAL_3         : mx_signals_t = 1 << 3;\n+\n+pub const MX_TASK_TERMINATED        : mx_signals_t = MX_OBJECT_SIGNAL_3;\n+\n+pub const MX_RIGHT_SAME_RIGHTS  : mx_rights_t = 1 << 31;\n+\n+pub type mx_object_info_topic_t = u32;\n+\n+pub const MX_INFO_PROCESS         : mx_object_info_topic_t = 3;\n+\n+pub const MX_HND_TYPE_JOB: u32 = 6;\n+\n+// Common MX_INFO header\n+#[derive(Default)]\n+#[repr(C)]\n+pub struct mx_info_header_t {\n+    pub topic: u32,              // identifies the info struct\n+    pub avail_topic_size: u16,   // \u201cnative\u201d size of the struct\n+    pub topic_size: u16,         // size of the returned struct (<=topic_size)\n+    pub avail_count: u32,        // number of records the kernel has\n+    pub count: u32,              // number of records returned (limited by buffer size)\n+}\n+\n+#[derive(Default)]\n+#[repr(C)]\n+pub struct mx_record_process_t {\n+    pub return_code: c_int,\n+}\n+\n+// Returned for topic MX_INFO_PROCESS\n+#[derive(Default)]\n+#[repr(C)]\n+pub struct mx_info_process_t {\n+    pub hdr: mx_info_header_t,\n+    pub rec: mx_record_process_t,\n+}\n+\n+#[link(name = \"magenta\")]\n+extern {\n+    pub fn mx_handle_close(handle: mx_handle_t) -> mx_status_t;\n+\n+    pub fn mx_handle_duplicate(handle: mx_handle_t, rights: mx_rights_t,\n+                               out: *const mx_handle_t) -> mx_handle_t;\n+\n+    pub fn mx_handle_wait_one(handle: mx_handle_t, signals: mx_signals_t, timeout: mx_time_t,\n+                              pending: *mut mx_signals_t) -> mx_status_t;\n+\n+    pub fn mx_object_get_info(handle: mx_handle_t, topic: u32, buffer: *mut c_void,\n+                              buffer_size: mx_size_t, actual_size: *mut mx_size_t,\n+                              avail: *mut mx_size_t) -> mx_status_t;\n+}\n+\n+// Handle Info entries associate a type and optional\n+// argument with each handle included in the process\n+// arguments message.\n+pub fn mx_hnd_info(hnd_type: u32, arg: u32) -> u32 {\n+    (hnd_type & 0xFFFF) | ((arg & 0xFFFF) << 16)\n+}\n+\n+#[link(name=\"mxio\")]\n+extern {\n+    pub fn mxio_get_startup_handle(id: u32) -> mx_handle_t;\n+}\n+\n+// From `enum special_handles` in system/ulib/launchpad/launchpad.c\n+#[allow(unused)] pub const HND_LOADER_SVC: usize = 0;\n+// HND_EXEC_VMO = 1\n+#[allow(unused)] pub const HND_SPECIAL_COUNT: usize = 2;\n+\n+#[repr(C)]\n+pub struct launchpad_t {\n+    argc: u32,\n+    envc: u32,\n+    args: *const c_char,\n+    args_len: usize,\n+    env: *const c_char,\n+    env_len: usize,\n+\n+    handles: *mut mx_handle_t,\n+    handles_info: *mut u32,\n+    handle_count: usize,\n+    handle_alloc: usize,\n+\n+    entry: mx_vaddr_t,\n+    base: mx_vaddr_t,\n+    vdso_base: mx_vaddr_t,\n+\n+    stack_size: usize,\n+\n+    special_handles: [mx_handle_t; HND_SPECIAL_COUNT],\n+    loader_message: bool,\n+}\n+\n+#[link(name=\"launchpad\")]\n+extern {\n+    pub fn launchpad_create(job: mx_handle_t, name: *const c_char,\n+                            lp: *mut *mut launchpad_t) -> mx_status_t;\n+\n+    pub fn launchpad_start(lp: *mut launchpad_t) -> mx_status_t;\n+\n+    pub fn launchpad_destroy(lp: *mut launchpad_t);\n+\n+    pub fn launchpad_arguments(lp: *mut launchpad_t, argc: c_int,\n+                               argv: *const *const c_char) -> mx_status_t;\n+\n+    pub fn launchpad_environ(lp: *mut launchpad_t, envp: *const *const c_char) -> mx_status_t;\n+\n+    pub fn launchpad_clone_mxio_root(lp: *mut launchpad_t) -> mx_status_t;\n+\n+    pub fn launchpad_clone_mxio_cwd(lp: *mut launchpad_t) -> mx_status_t;\n+\n+    pub fn launchpad_clone_fd(lp: *mut launchpad_t, fd: c_int, target_fd: c_int) -> mx_status_t;\n+\n+    pub fn launchpad_transfer_fd(lp: *mut launchpad_t, fd: c_int, target_fd: c_int) -> mx_status_t;\n+\n+    pub fn launchpad_elf_load(lp: *mut launchpad_t, vmo: mx_handle_t) -> mx_status_t;\n+\n+    pub fn launchpad_add_vdso_vmo(lp: *mut launchpad_t) -> mx_status_t;\n+\n+    pub fn launchpad_load_vdso(lp: *mut launchpad_t, vmo: mx_handle_t) -> mx_status_t;\n+\n+    pub fn launchpad_vmo_from_file(filename: *const c_char) -> mx_handle_t;\n+}"}, {"sha": "8fe55af51d54fbce86ceb2bcb77bc8878f535145", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=5c23f2e3c88275cee37acbd36c12baba57c4de2b", "patch": "@@ -13,6 +13,11 @@\n use io::{self, ErrorKind};\n use libc;\n \n+#[cfg(target_os = \"fuchsia\")]\n+use convert::TryInto;\n+#[cfg(target_os = \"fuchsia\")]\n+pub use self::magenta::mx_status_t;\n+\n #[cfg(target_os = \"android\")]   pub use os::android as platform;\n #[cfg(target_os = \"bitrig\")]    pub use os::bitrig as platform;\n #[cfg(target_os = \"dragonfly\")] pub use os::dragonfly as platform;\n@@ -41,6 +46,8 @@ pub mod ext;\n pub mod fast_thread_local;\n pub mod fd;\n pub mod fs;\n+#[cfg(target_os = \"fuchsia\")]\n+pub mod magenta;\n pub mod memchr;\n pub mod mutex;\n pub mod net;\n@@ -164,6 +171,19 @@ pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n     }\n }\n \n+#[cfg(target_os = \"fuchsia\")]\n+pub fn mx_cvt<T>(t: T) -> io::Result<T> where T: TryInto<mx_status_t>+Copy {\n+    if let Ok(status) = TryInto::try_into(t) {\n+        if status < 0 {\n+            Err(io::Error::from_raw_os_error(status))\n+        } else {\n+            Ok(t)\n+        }\n+    } else {\n+        Err(io::Error::last_os_error())\n+    }\n+}\n+\n // On Unix-like platforms, libc::abort will unregister signal handlers\n // including the SIGABRT handler, preventing the abort from being blocked, and\n // fclose streams, with the side effect of flushing them so libc bufferred"}, {"sha": "a8ed415b7f47f89216c5e5a83543e1203c7e7252", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=5c23f2e3c88275cee37acbd36c12baba57c4de2b", "patch": "@@ -77,6 +77,7 @@ pub fn read2(p1: AnonPipe,\n              v1: &mut Vec<u8>,\n              p2: AnonPipe,\n              v2: &mut Vec<u8>) -> io::Result<()> {\n+\n     // Set both pipes into nonblocking mode as we're gonna be reading from both\n     // in the `select` loop below, and we wouldn't want one to block the other!\n     let p1 = p1.into_fd();"}, {"sha": "aa203dc62153537d78891f5e54f78004df7b91f5", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 233, "deletions": 3, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c23f2e3c88275cee37acbd36c12baba57c4de2b/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=5c23f2e3c88275cee37acbd36c12baba57c4de2b", "patch": "@@ -15,13 +15,23 @@ use env;\n use ffi::{OsString, OsStr, CString, CStr};\n use fmt;\n use io::{self, Error, ErrorKind};\n-use libc::{self, pid_t, c_int, gid_t, uid_t, c_char};\n+use libc::{self, c_int, gid_t, uid_t, c_char};\n use mem;\n use ptr;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n use sys::pipe::{self, AnonPipe};\n-use sys::{self, cvt, cvt_r};\n+\n+#[cfg(not(target_os = \"fuchsia\"))]\n+use sys::cvt;\n+#[cfg(target_os = \"fuchsia\")]\n+use sys::mx_cvt;\n+\n+#[cfg(target_os = \"fuchsia\")]\n+use sys::magenta::{launchpad_t, mx_handle_t};\n+\n+#[cfg(not(target_os = \"fuchsia\"))]\n+use libc::pid_t;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -210,8 +220,11 @@ impl Command {\n         self.stderr = Some(stderr);\n     }\n \n+    #[cfg(not(target_os = \"fuchsia\"))]\n     pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n                  -> io::Result<(Process, StdioPipes)> {\n+        use sys;\n+\n         const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n \n         if self.saw_nul {\n@@ -286,6 +299,31 @@ impl Command {\n         }\n     }\n \n+    #[cfg(target_os = \"fuchsia\")]\n+    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n+                 -> io::Result<(Process, StdioPipes)> {\n+        if self.saw_nul {\n+            return Err(io::Error::new(ErrorKind::InvalidInput,\n+                                      \"nul byte found in provided data\"));\n+        }\n+\n+        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n+\n+        let (maybe_process, err) = unsafe { self.do_exec(&theirs) };\n+        // We don't want FileDesc::drop to be called on any stdio. It would close their handles.\n+        let ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr } = theirs;\n+        their_stdin.fd();\n+        their_stdout.fd();\n+        their_stderr.fd();\n+\n+        if let Some((launchpad, process_handle)) = maybe_process {\n+            Ok((Process { launchpad: launchpad, handle: process_handle, status: None }, ours))\n+        } else {\n+            Err(err)\n+        }\n+    }\n+\n+    #[cfg(not(target_os = \"fuchsia\"))]\n     pub fn exec(&mut self, default: Stdio) -> io::Error {\n         if self.saw_nul {\n             return io::Error::new(ErrorKind::InvalidInput,\n@@ -298,6 +336,22 @@ impl Command {\n         }\n     }\n \n+    #[cfg(target_os = \"fuchsia\")]\n+    pub fn exec(&mut self, default: Stdio) -> io::Error {\n+        if self.saw_nul {\n+            return io::Error::new(ErrorKind::InvalidInput,\n+                                  \"nul byte found in provided data\")\n+        }\n+\n+        match self.setup_io(default, true) {\n+            Ok((_, _)) => {\n+                // FIXME: This is tough because we don't support the exec syscalls\n+                unimplemented!();\n+            },\n+            Err(e) => e,\n+        }\n+    }\n+\n     // And at this point we've reached a special time in the life of the\n     // child. The child must now be considered hamstrung and unable to\n     // do anything other than syscalls really. Consider the following\n@@ -328,7 +382,10 @@ impl Command {\n     // allocation). Instead we just close it manually. This will never\n     // have the drop glue anyway because this code never returns (the\n     // child will either exec() or invoke libc::exit)\n+    #[cfg(not(target_os = \"fuchsia\"))]\n     unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n+        use sys::{self, cvt_r};\n+\n         macro_rules! t {\n             ($e:expr) => (match $e {\n                 Ok(e) => e,\n@@ -395,6 +452,108 @@ impl Command {\n         io::Error::last_os_error()\n     }\n \n+    #[cfg(target_os = \"fuchsia\")]\n+    unsafe fn do_exec(&mut self, stdio: &ChildPipes)\n+                      -> (Option<(*mut launchpad_t, mx_handle_t)>, io::Error) {\n+        use sys::magenta::*;\n+\n+        macro_rules! t {\n+            ($e:expr) => (match $e {\n+                Ok(e) => e,\n+                Err(e) => return (None, e),\n+            })\n+        }\n+\n+        macro_rules! tlp {\n+            ($lp:expr, $e:expr) => (match $e {\n+                Ok(e) => e,\n+                Err(e) => {\n+                    launchpad_destroy($lp);\n+                    return (None, e);\n+                },\n+            })\n+        }\n+\n+        let job_handle = mxio_get_startup_handle(mx_hnd_info(MX_HND_TYPE_JOB, 0));\n+        let envp = match self.envp {\n+            Some(ref envp) => envp.as_ptr(),\n+            None => ptr::null(),\n+        };\n+\n+        let mut launchpad: *mut launchpad_t = ptr::null_mut();\n+        let mut job_copy: mx_handle_t = MX_HANDLE_INVALID;\n+\n+        // Duplicate the job handle\n+        t!(mx_cvt(mx_handle_duplicate(job_handle, MX_RIGHT_SAME_RIGHTS,\n+                                   &mut job_copy as *mut mx_handle_t)));\n+        // Create a launchpad\n+        t!(mx_cvt(launchpad_create(job_copy, self.argv[0],\n+                                &mut launchpad as *mut *mut launchpad_t)));\n+        // Set the process argv\n+        tlp!(launchpad, mx_cvt(launchpad_arguments(launchpad, self.argv.len() as i32 - 1,\n+                                                self.argv.as_ptr())));\n+        // Setup the environment vars\n+        let status = launchpad_environ(launchpad, envp);\n+        if status != NO_ERROR {\n+            launchpad_destroy(launchpad);\n+            return (None, io::Error::last_os_error());\n+        }\n+        let status = launchpad_add_vdso_vmo(launchpad);\n+        if status != NO_ERROR {\n+            launchpad_destroy(launchpad);\n+            return (None, io::Error::last_os_error());\n+        }\n+        let status = launchpad_clone_mxio_root(launchpad);\n+        if status != NO_ERROR {\n+            launchpad_destroy(launchpad);\n+            return (None, io::Error::last_os_error());\n+        }\n+        // Load the executable\n+        let status = launchpad_elf_load(launchpad, launchpad_vmo_from_file(self.argv[0]));\n+        if status != NO_ERROR {\n+            launchpad_destroy(launchpad);\n+            return (None, io::Error::last_os_error());\n+        }\n+        let status = launchpad_load_vdso(launchpad, MX_HANDLE_INVALID);\n+        if status != NO_ERROR {\n+            launchpad_destroy(launchpad);\n+            return (None, io::Error::last_os_error());\n+        }\n+        let status = launchpad_clone_mxio_cwd(launchpad);\n+        if status != NO_ERROR {\n+            launchpad_destroy(launchpad);\n+            return (None, io::Error::last_os_error());\n+        }\n+\n+        // Clone stdin, stdout, and stderr\n+        if let Some(fd) = stdio.stdin.fd() {\n+            launchpad_transfer_fd(launchpad, fd, 0);\n+        } else {\n+            launchpad_clone_fd(launchpad, 0, 0);\n+        }\n+        if let Some(fd) = stdio.stdout.fd() {\n+            launchpad_transfer_fd(launchpad, fd, 1);\n+        } else {\n+            launchpad_clone_fd(launchpad, 1, 1);\n+        }\n+        if let Some(fd) = stdio.stderr.fd() {\n+            launchpad_transfer_fd(launchpad, fd, 2);\n+        } else {\n+            launchpad_clone_fd(launchpad, 2, 2);\n+        }\n+\n+        for callback in self.closures.iter_mut() {\n+            t!(callback());\n+        }\n+\n+        let process_handle = launchpad_start(launchpad);\n+        if process_handle < 0 {\n+            launchpad_destroy(launchpad);\n+            return (None, io::Error::last_os_error());\n+        }\n+\n+        (Some((launchpad, process_handle)), io::Error::last_os_error())\n+    }\n \n     fn setup_io(&self, default: Stdio, needs_stdin: bool)\n                 -> io::Result<(StdioPipes, ChildPipes)> {\n@@ -431,7 +590,9 @@ impl Stdio {\n     fn to_child_stdio(&self, readable: bool)\n                       -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n         match *self {\n-            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n+            Stdio::Inherit => {\n+                Ok((ChildStdio::Inherit, None))\n+            },\n \n             // Make sure that the source descriptors are not an stdio\n             // descriptor, otherwise the order which we set the child's\n@@ -556,16 +717,31 @@ impl fmt::Display for ExitStatus {\n }\n \n /// The unique id of the process (this should never be negative).\n+#[cfg(not(target_os = \"fuchsia\"))]\n pub struct Process {\n     pid: pid_t,\n     status: Option<ExitStatus>,\n }\n \n+#[cfg(target_os = \"fuchsia\")]\n+pub struct Process {\n+    launchpad: *mut launchpad_t,\n+    handle: mx_handle_t,\n+    status: Option<ExitStatus>,\n+}\n+\n impl Process {\n+    #[cfg(not(target_os = \"fuchsia\"))]\n     pub fn id(&self) -> u32 {\n         self.pid as u32\n     }\n \n+    #[cfg(target_os = \"fuchsia\")]\n+    pub fn id(&self) -> u32 {\n+        0\n+    }\n+\n+    #[cfg(not(target_os = \"fuchsia\"))]\n     pub fn kill(&mut self) -> io::Result<()> {\n         // If we've already waited on this process then the pid can be recycled\n         // and used for another process, and we probably shouldn't be killing\n@@ -578,7 +754,28 @@ impl Process {\n         }\n     }\n \n+    #[cfg(target_os = \"fuchsia\")]\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        use sys::magenta::*;\n+\n+        // If we've already waited on this process then the pid can be recycled\n+        // and used for another process, and we probably shouldn't be killing\n+        // random processes, so just return an error.\n+        if self.status.is_some() {\n+            Err(Error::new(ErrorKind::InvalidInput,\n+                           \"invalid argument: can't kill an exited process\"))\n+        } else {\n+            unsafe {\n+                mx_cvt(mx_handle_close(self.handle))?;\n+                launchpad_destroy(self.launchpad);\n+            }\n+            Ok(())\n+        }\n+    }\n+\n+    #[cfg(not(target_os = \"fuchsia\"))]\n     pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        use sys::cvt_r;\n         if let Some(status) = self.status {\n             return Ok(status)\n         }\n@@ -587,6 +784,39 @@ impl Process {\n         self.status = Some(ExitStatus(status));\n         Ok(ExitStatus(status))\n     }\n+\n+    #[cfg(target_os = \"fuchsia\")]\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        use default::Default;\n+        use sys::magenta::*;\n+\n+        if let Some(status) = self.status {\n+            return Ok(status)\n+        }\n+\n+        let mut proc_info: mx_info_process_t = Default::default();\n+        let mut actual: mx_size_t = 0;\n+        let mut avail: mx_size_t = 0;\n+\n+        unsafe {\n+            mx_cvt(mx_handle_wait_one(self.handle, MX_TASK_TERMINATED,\n+                                      MX_TIME_INFINITE, ptr::null_mut()))?;\n+            mx_cvt(mx_object_get_info(self.handle, MX_INFO_PROCESS,\n+                                      &mut proc_info as *mut _ as *mut libc::c_void,\n+                                      mem::size_of::<mx_info_process_t>(), &mut actual,\n+                                      &mut avail))?;\n+        }\n+        if actual != 1 {\n+            return Err(Error::new(ErrorKind::InvalidInput,\n+                                  \"Failed to get exit status of process\"));\n+        }\n+        self.status = Some(ExitStatus(proc_info.rec.return_code));\n+        unsafe {\n+            mx_cvt(mx_handle_close(self.handle))?;\n+            launchpad_destroy(self.launchpad);\n+        }\n+        Ok(ExitStatus(proc_info.rec.return_code))\n+    }\n }\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]"}]}