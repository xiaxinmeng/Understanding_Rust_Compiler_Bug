{"sha": "b17ec43637276773cd331844896fe7071de2475c", "node_id": "C_kwDOAAsO6NoAKGIxN2VjNDM2MzcyNzY3NzNjZDMzMTg0NDg5NmZlNzA3MWRlMjQ3NWM", "commit": {"author": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-09-28T20:02:03Z"}, "committer": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-10-07T19:19:27Z"}, "message": "migrate entry.rs to translateable diagnostics", "tree": {"sha": "37b7fd0e1d4d1f34fef841a3e476c133e57a1f50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37b7fd0e1d4d1f34fef841a3e476c133e57a1f50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b17ec43637276773cd331844896fe7071de2475c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b17ec43637276773cd331844896fe7071de2475c", "html_url": "https://github.com/rust-lang/rust/commit/b17ec43637276773cd331844896fe7071de2475c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b17ec43637276773cd331844896fe7071de2475c/comments", "author": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "committer": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "parents": [{"sha": "96f92eab683497a14079fd4da67642f1a4fc07e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/96f92eab683497a14079fd4da67642f1a4fc07e0", "html_url": "https://github.com/rust-lang/rust/commit/96f92eab683497a14079fd4da67642f1a4fc07e0"}], "stats": {"total": 316, "additions": 224, "deletions": 92}, "files": [{"sha": "b075568ae13efec25fe80e876eb204e41741a793", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b17ec43637276773cd331844896fe7071de2475c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/b17ec43637276773cd331844896fe7071de2475c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=b17ec43637276773cd331844896fe7071de2475c", "patch": "@@ -495,3 +495,42 @@ passes_naked_functions_asm_options =\n passes_naked_functions_must_use_noreturn =\n     asm in naked functions must use `noreturn` option\n     .suggestion = consider specifying that the asm block is responsible for returning from the function\n+\n+passes_attr_only_on_main =\n+    `{$attr}` attribute can only be used on `fn main()`\n+\n+passes_attr_only_on_root_main =\n+    `{$attr}` attribute can only be used on root `fn main()`\n+\n+passes_attr_only_in_functions =\n+    `{$attr}` attribute can only be used on functions\n+\n+passes_multiple_rustc_main =\n+    multiple functions with a `#[rustc_main]` attribute\n+    .first = first `#[rustc_main]` function\n+    .additional = additional `#[rustc_main]` function\n+\n+passes_multiple_start_functions =\n+    multiple `start` functions\n+    .label = multiple `start` functions\n+    .previous = previous `#[start]` function here\n+\n+passes_extern_main =\n+    the `main` function cannot be declared in an `extern` block\n+\n+passes_unix_sigpipe_values =\n+    valid values for `#[unix_sigpipe = \"...\"]` are `inherit`, `sig_ign`, or `sig_dfl`\n+\n+passes_no_main_function =\n+    `main` function not found in crate `{$crate_name}`\n+    .here_is_main = here is a function named `main`\n+    .one_or_more_possible_main = you have one or more functions named `main` not defined at the crate level\n+    .consider_moving_main = consider moving the `main` function definitions\n+    .main_must_be_defined_at_crate = the main function must be defined at the crate level{$has_filename ->\n+        [true] {\" \"}(in `{$filename}`)\n+        *[false] {\"\"}\n+        }\n+    .consider_adding_main_to_file = consider adding a `main` function to `{$filename}`\n+    .consider_adding_main_at_crate = consider adding a `main` function at the crate level\n+    .teach_note = If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/\n+    .non_function_main = non-function item at `crate::main` is found"}, {"sha": "38a259ca8846f14834a0eb982f73dffd439c8025", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 55, "deletions": 90, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/b17ec43637276773cd331844896fe7071de2475c/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b17ec43637276773cd331844896fe7071de2475c/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=b17ec43637276773cd331844896fe7071de2475c", "patch": "@@ -1,5 +1,5 @@\n use rustc_ast::entry::EntryPointType;\n-use rustc_errors::struct_span_err;\n+use rustc_errors::error_code;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::{ItemId, Node, CRATE_HIR_ID};\n@@ -8,7 +8,12 @@ use rustc_middle::ty::{DefIdTree, TyCtxt};\n use rustc_session::config::{sigpipe, CrateType, EntryFnType};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n-use rustc_span::{Span, Symbol, DUMMY_SP};\n+use rustc_span::{Span, Symbol};\n+\n+use crate::errors::{\n+    AttrOnlyInFunctions, AttrOnlyOnMain, AttrOnlyOnRootMain, ExternMain, MultipleRustcMain,\n+    MultipleStartFunctions, NoMainErr, UnixSigpipeValues,\n+};\n \n struct EntryContext<'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -71,64 +76,57 @@ fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> Entry\n     }\n }\n \n-fn err_if_attr_found(ctxt: &EntryContext<'_>, id: ItemId, sym: Symbol, details: &str) {\n+fn attr_span_by_symbol(ctxt: &EntryContext<'_>, id: ItemId, sym: Symbol) -> Option<Span> {\n     let attrs = ctxt.tcx.hir().attrs(id.hir_id());\n-    if let Some(attr) = ctxt.tcx.sess.find_by_name(attrs, sym) {\n-        ctxt.tcx\n-            .sess\n-            .struct_span_err(attr.span, &format!(\"`{}` attribute {}\", sym, details))\n-            .emit();\n-    }\n+    ctxt.tcx.sess.find_by_name(attrs, sym).map(|attr| attr.span)\n }\n \n fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n     let at_root = ctxt.tcx.opt_local_parent(id.def_id.def_id) == Some(CRATE_DEF_ID);\n \n     match entry_point_type(ctxt, id, at_root) {\n         EntryPointType::None => {\n-            err_if_attr_found(ctxt, id, sym::unix_sigpipe, \"can only be used on `fn main()`\");\n+            if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n+                ctxt.tcx.sess.emit_err(AttrOnlyOnMain { span, attr: sym::unix_sigpipe });\n+            }\n         }\n         _ if !matches!(ctxt.tcx.def_kind(id.def_id), DefKind::Fn) => {\n-            err_if_attr_found(ctxt, id, sym::start, \"can only be used on functions\");\n-            err_if_attr_found(ctxt, id, sym::rustc_main, \"can only be used on functions\");\n+            for attr in [sym::start, sym::rustc_main] {\n+                if let Some(span) = attr_span_by_symbol(ctxt, id, attr) {\n+                    ctxt.tcx.sess.emit_err(AttrOnlyInFunctions { span, attr });\n+                }\n+            }\n         }\n         EntryPointType::MainNamed => (),\n         EntryPointType::OtherMain => {\n-            err_if_attr_found(ctxt, id, sym::unix_sigpipe, \"can only be used on root `fn main()`\");\n+            if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n+                ctxt.tcx.sess.emit_err(AttrOnlyOnRootMain { span, attr: sym::unix_sigpipe });\n+            }\n             ctxt.non_main_fns.push(ctxt.tcx.def_span(id.def_id));\n         }\n         EntryPointType::RustcMainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n                 ctxt.attr_main_fn = Some((id.def_id.def_id, ctxt.tcx.def_span(id.def_id)));\n             } else {\n-                struct_span_err!(\n-                    ctxt.tcx.sess,\n-                    ctxt.tcx.def_span(id.def_id.to_def_id()),\n-                    E0137,\n-                    \"multiple functions with a `#[rustc_main]` attribute\"\n-                )\n-                .span_label(\n-                    ctxt.tcx.def_span(id.def_id.to_def_id()),\n-                    \"additional `#[rustc_main]` function\",\n-                )\n-                .span_label(ctxt.attr_main_fn.unwrap().1, \"first `#[rustc_main]` function\")\n-                .emit();\n+                ctxt.tcx.sess.emit_err(MultipleRustcMain {\n+                    span: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    first: ctxt.attr_main_fn.unwrap().1,\n+                    additional: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                });\n             }\n         }\n         EntryPointType::Start => {\n-            err_if_attr_found(ctxt, id, sym::unix_sigpipe, \"can only be used on `fn main()`\");\n+            if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n+                ctxt.tcx.sess.emit_err(AttrOnlyOnMain { span, attr: sym::unix_sigpipe });\n+            }\n             if ctxt.start_fn.is_none() {\n                 ctxt.start_fn = Some((id.def_id.def_id, ctxt.tcx.def_span(id.def_id)));\n             } else {\n-                struct_span_err!(\n-                    ctxt.tcx.sess,\n-                    ctxt.tcx.def_span(id.def_id),\n-                    E0138,\n-                    \"multiple `start` functions\"\n-                )\n-                .span_label(ctxt.start_fn.unwrap().1, \"previous `#[start]` function here\")\n-                .span_label(ctxt.tcx.def_span(id.def_id.to_def_id()), \"multiple `start` functions\")\n-                .emit();\n+                ctxt.tcx.sess.emit_err(MultipleStartFunctions {\n+                    span: ctxt.tcx.def_span(id.def_id),\n+                    labeled: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    previous: ctxt.start_fn.unwrap().1,\n+                });\n             }\n         }\n     }\n@@ -144,12 +142,7 @@ fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_>) -> Option<(DefId,\n         if let Some(main_def) = tcx.resolutions(()).main_def && let Some(def_id) = main_def.opt_fn_def_id() {\n             // non-local main imports are handled below\n             if let Some(def_id) = def_id.as_local() && matches!(tcx.hir().find_by_def_id(def_id), Some(Node::ForeignItem(_))) {\n-                tcx.sess\n-                    .struct_span_err(\n-                        tcx.def_span(def_id),\n-                        \"the `main` function cannot be declared in an `extern` block\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(ExternMain { span: tcx.def_span(def_id) });\n                 return None;\n             }\n \n@@ -182,12 +175,7 @@ fn sigpipe(tcx: TyCtxt<'_>, def_id: DefId) -> u8 {\n                 sigpipe::DEFAULT\n             }\n             _ => {\n-                tcx.sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"valid values for `#[unix_sigpipe = \\\"...\\\"]` are `inherit`, `sig_ign`, or `sig_dfl`\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(UnixSigpipeValues { span: attr.span });\n                 sigpipe::DEFAULT\n             }\n         }\n@@ -206,52 +194,29 @@ fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_>) {\n     }\n \n     // There is no main function.\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        DUMMY_SP,\n-        E0601,\n-        \"`main` function not found in crate `{}`\",\n-        tcx.crate_name(LOCAL_CRATE)\n-    );\n-    let filename = &tcx.sess.local_crate_source_file;\n-    let note = if !visitor.non_main_fns.is_empty() {\n-        for &span in &visitor.non_main_fns {\n-            err.span_note(span, \"here is a function named `main`\");\n-        }\n-        err.note(\"you have one or more functions named `main` not defined at the crate level\");\n-        err.help(\"consider moving the `main` function definitions\");\n-        // There were some functions named `main` though. Try to give the user a hint.\n-        format!(\n-            \"the main function must be defined at the crate level{}\",\n-            filename.as_ref().map(|f| format!(\" (in `{}`)\", f.display())).unwrap_or_default()\n-        )\n-    } else if let Some(filename) = filename {\n-        format!(\"consider adding a `main` function to `{}`\", filename.display())\n-    } else {\n-        String::from(\"consider adding a `main` function at the crate level\")\n-    };\n+    let mut has_filename = true;\n+    let filename = tcx.sess.local_crate_source_file.clone().unwrap_or_else(|| {\n+        has_filename = false;\n+        Default::default()\n+    });\n+    let main_def_opt = tcx.resolutions(()).main_def;\n+    let diagnostic_id = error_code!(E0601);\n+    let add_teach_note = tcx.sess.teach(&diagnostic_id);\n     // The file may be empty, which leads to the diagnostic machinery not emitting this\n     // note. This is a relatively simple way to detect that case and emit a span-less\n     // note instead.\n-    if tcx.sess.source_map().lookup_line(sp.hi()).is_ok() {\n-        err.set_span(sp.shrink_to_hi());\n-        err.span_label(sp.shrink_to_hi(), &note);\n-    } else {\n-        err.note(&note);\n-    }\n-\n-    if let Some(main_def) = tcx.resolutions(()).main_def && main_def.opt_fn_def_id().is_none(){\n-        // There is something at `crate::main`, but it is not a function definition.\n-        err.span_label(main_def.span, \"non-function item at `crate::main` is found\");\n-    }\n-\n-    if tcx.sess.teach(&err.get_code().unwrap()) {\n-        err.note(\n-            \"If you don't know the basics of Rust, you can go look to the Rust Book \\\n-                  to get started: https://doc.rust-lang.org/book/\",\n-        );\n-    }\n-    err.emit();\n+    let file_empty = !tcx.sess.source_map().lookup_line(sp.hi()).is_ok();\n+\n+    tcx.sess.emit_err(NoMainErr {\n+        sp,\n+        crate_name: tcx.crate_name(LOCAL_CRATE),\n+        has_filename,\n+        filename,\n+        file_empty,\n+        non_main_fns: visitor.non_main_fns.clone(),\n+        main_def_opt,\n+        add_teach_note,\n+    });\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "56e184ab25ee07343296577fe04a34b3900494ec", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 130, "deletions": 2, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b17ec43637276773cd331844896fe7071de2475c/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b17ec43637276773cd331844896fe7071de2475c/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=b17ec43637276773cd331844896fe7071de2475c", "patch": "@@ -1,10 +1,14 @@\n-use std::{io::Error, path::Path};\n+use std::{\n+    io::Error,\n+    path::{Path, PathBuf},\n+};\n \n use rustc_ast::Label;\n use rustc_errors::{error_code, Applicability, ErrorGuaranteed, IntoDiagnostic, MultiSpan};\n use rustc_hir::{self as hir, ExprKind, Target};\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n-use rustc_span::{Span, Symbol};\n+use rustc_middle::ty::MainDefinition;\n+use rustc_span::{Span, Symbol, DUMMY_SP};\n \n #[derive(LintDiagnostic)]\n #[diag(passes::outer_crate_level_attr)]\n@@ -1063,3 +1067,127 @@ pub struct NakedFunctionsMustUseNoreturn {\n     #[suggestion(code = \", options(noreturn)\", applicability = \"machine-applicable\")]\n     pub last_span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::attr_only_on_main)]\n+pub struct AttrOnlyOnMain {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::attr_only_on_root_main)]\n+pub struct AttrOnlyOnRootMain {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::attr_only_in_functions)]\n+pub struct AttrOnlyInFunctions {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::multiple_rustc_main, code = \"E0137\")]\n+pub struct MultipleRustcMain {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(passes::first)]\n+    pub first: Span,\n+    #[label(passes::additional)]\n+    pub additional: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::multiple_start_functions, code = \"E0138\")]\n+pub struct MultipleStartFunctions {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub labeled: Span,\n+    #[label(passes::previous)]\n+    pub previous: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::extern_main)]\n+pub struct ExternMain {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unix_sigpipe_values)]\n+pub struct UnixSigpipeValues {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::no_main_function, code = \"E0601\")]\n+pub struct NoMainFunction {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+}\n+\n+pub struct NoMainErr {\n+    pub sp: Span,\n+    pub crate_name: Symbol,\n+    pub has_filename: bool,\n+    pub filename: PathBuf,\n+    pub file_empty: bool,\n+    pub non_main_fns: Vec<Span>,\n+    pub main_def_opt: Option<MainDefinition>,\n+    pub add_teach_note: bool,\n+}\n+\n+impl<'a> IntoDiagnostic<'a> for NoMainErr {\n+    fn into_diagnostic(\n+        self,\n+        handler: &'a rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n+            DUMMY_SP,\n+            rustc_errors::fluent::passes::no_main_function,\n+            error_code!(E0601),\n+        );\n+        diag.set_arg(\"crate_name\", self.crate_name);\n+        diag.set_arg(\"filename\", self.filename);\n+        diag.set_arg(\"has_filename\", self.has_filename);\n+        let note = if !self.non_main_fns.is_empty() {\n+            for &span in &self.non_main_fns {\n+                diag.span_note(span, rustc_errors::fluent::passes::here_is_main);\n+            }\n+            diag.note(rustc_errors::fluent::passes::one_or_more_possible_main);\n+            diag.help(rustc_errors::fluent::passes::consider_moving_main);\n+            // There were some functions named `main` though. Try to give the user a hint.\n+            rustc_errors::fluent::passes::main_must_be_defined_at_crate\n+        } else if self.has_filename {\n+            rustc_errors::fluent::passes::consider_adding_main_to_file\n+        } else {\n+            rustc_errors::fluent::passes::consider_adding_main_at_crate\n+        };\n+        if self.file_empty {\n+            diag.note(note);\n+        } else {\n+            diag.set_span(self.sp.shrink_to_hi());\n+            diag.span_label(self.sp.shrink_to_hi(), note);\n+        }\n+\n+        if let Some(main_def) = self.main_def_opt && main_def.opt_fn_def_id().is_none(){\n+            // There is something at `crate::main`, but it is not a function definition.\n+            diag.span_label(main_def.span, rustc_errors::fluent::passes::non_function_main);\n+        }\n+\n+        if self.add_teach_note {\n+            diag.note(rustc_errors::fluent::passes::teach_note);\n+        }\n+        diag\n+    }\n+}"}]}