{"sha": "71f5cfb21f3fd2f1740bced061c66ff112fec259", "node_id": "C_kwDOAAsO6NoAKDcxZjVjZmIyMWYzZmQyZjE3NDBiY2VkMDYxYzY2ZmYxMTJmZWMyNTk", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-11-12T04:32:18Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-11-12T04:32:18Z"}, "message": "MIRI says `reverse` is UB, so replace it with an implementation that LLVM can vectorize\n\nFor small types with padding, the current implementation is UB because it does integer operations on uninit values.  But LLVM has gotten smarter since I wrote the previous implementation in 2017, so remove all the manual magic and just write it in such a way that LLVM will vectorize.  This code is much simpler (albeit nuanced) and has very little `unsafe`, and is actually faster to boot!", "tree": {"sha": "38e7d3c08601da65ab64a796fc895d7f35d48166", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38e7d3c08601da65ab64a796fc895d7f35d48166"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71f5cfb21f3fd2f1740bced061c66ff112fec259", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71f5cfb21f3fd2f1740bced061c66ff112fec259", "html_url": "https://github.com/rust-lang/rust/commit/71f5cfb21f3fd2f1740bced061c66ff112fec259", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71f5cfb21f3fd2f1740bced061c66ff112fec259/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14a2fd640e0df9ee8cc1e04280b0c3aff93c42da", "url": "https://api.github.com/repos/rust-lang/rust/commits/14a2fd640e0df9ee8cc1e04280b0c3aff93c42da", "html_url": "https://github.com/rust-lang/rust/commit/14a2fd640e0df9ee8cc1e04280b0c3aff93c42da"}], "stats": {"total": 149, "additions": 58, "deletions": 91}, "files": [{"sha": "e9ec06f55a294c3efe7e6c9044346ec91c2b9d8f", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 32, "deletions": 91, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/71f5cfb21f3fd2f1740bced061c66ff112fec259/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f5cfb21f3fd2f1740bced061c66ff112fec259/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=71f5cfb21f3fd2f1740bced061c66ff112fec259", "patch": "@@ -621,100 +621,41 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn reverse(&mut self) {\n-        let mut i: usize = 0;\n-        let ln = self.len();\n-\n-        // For very small types, all the individual reads in the normal\n-        // path perform poorly.  We can do better, given efficient unaligned\n-        // load/store, by loading a larger chunk and reversing a register.\n-\n-        // Ideally LLVM would do this for us, as it knows better than we do\n-        // whether unaligned reads are efficient (since that changes between\n-        // different ARM versions, for example) and what the best chunk size\n-        // would be.  Unfortunately, as of LLVM 4.0 (2017-05) it only unrolls\n-        // the loop, so we need to do this ourselves.  (Hypothesis: reverse\n-        // is troublesome because the sides can be aligned differently --\n-        // will be, when the length is odd -- so there's no way of emitting\n-        // pre- and postludes to use fully-aligned SIMD in the middle.)\n-\n-        let fast_unaligned = cfg!(any(target_arch = \"x86\", target_arch = \"x86_64\"));\n-\n-        if fast_unaligned && mem::size_of::<T>() == 1 {\n-            // Use the llvm.bswap intrinsic to reverse u8s in a usize\n-            let chunk = mem::size_of::<usize>();\n-            while i + chunk - 1 < ln / 2 {\n-                // SAFETY: There are several things to check here:\n-                //\n-                // - Note that `chunk` is either 4 or 8 due to the cfg check\n-                //   above. So `chunk - 1` is positive.\n-                // - Indexing with index `i` is fine as the loop check guarantees\n-                //   `i + chunk - 1 < ln / 2`\n-                //   <=> `i < ln / 2 - (chunk - 1) < ln / 2 < ln`.\n-                // - Indexing with index `ln - i - chunk = ln - (i + chunk)` is fine:\n-                //   - `i + chunk > 0` is trivially true.\n-                //   - The loop check guarantees:\n-                //     `i + chunk - 1 < ln / 2`\n-                //     <=> `i + chunk \u2264 ln / 2 \u2264 ln`, thus subtraction does not underflow.\n-                // - The `read_unaligned` and `write_unaligned` calls are fine:\n-                //   - `pa` points to index `i` where `i < ln / 2 - (chunk - 1)`\n-                //     (see above) and `pb` points to index `ln - i - chunk`, so\n-                //     both are at least `chunk`\n-                //     many bytes away from the end of `self`.\n-                //   - Any initialized memory is valid `usize`.\n-                unsafe {\n-                    let ptr = self.as_mut_ptr();\n-                    let pa = ptr.add(i);\n-                    let pb = ptr.add(ln - i - chunk);\n-                    let va = ptr::read_unaligned(pa as *mut usize);\n-                    let vb = ptr::read_unaligned(pb as *mut usize);\n-                    ptr::write_unaligned(pa as *mut usize, vb.swap_bytes());\n-                    ptr::write_unaligned(pb as *mut usize, va.swap_bytes());\n-                }\n-                i += chunk;\n-            }\n-        }\n+        let half_len = self.len() / 2;\n+        let Range { start, end } = self.as_mut_ptr_range();\n+\n+        // These slices will skip the middle item for an odd length,\n+        // since that one doesn't need to move.\n+        let (front_half, back_half) =\n+            // SAFETY: Both are subparts of the original slice, so the memory\n+            // range is valid, and they don't overlap because they're each only\n+            // half (or less) of the original slice.\n+            unsafe {\n+                (\n+                    slice::from_raw_parts_mut(start, half_len),\n+                    slice::from_raw_parts_mut(end.sub(half_len), half_len),\n+                )\n+            };\n \n-        if fast_unaligned && mem::size_of::<T>() == 2 {\n-            // Use rotate-by-16 to reverse u16s in a u32\n-            let chunk = mem::size_of::<u32>() / 2;\n-            while i + chunk - 1 < ln / 2 {\n-                // SAFETY: An unaligned u32 can be read from `i` if `i + 1 < ln`\n-                // (and obviously `i < ln`), because each element is 2 bytes and\n-                // we're reading 4.\n-                //\n-                // `i + chunk - 1 < ln / 2` # while condition\n-                // `i + 2 - 1 < ln / 2`\n-                // `i + 1 < ln / 2`\n-                //\n-                // Since it's less than the length divided by 2, then it must be\n-                // in bounds.\n-                //\n-                // This also means that the condition `0 < i + chunk <= ln` is\n-                // always respected, ensuring the `pb` pointer can be used\n-                // safely.\n-                unsafe {\n-                    let ptr = self.as_mut_ptr();\n-                    let pa = ptr.add(i);\n-                    let pb = ptr.add(ln - i - chunk);\n-                    let va = ptr::read_unaligned(pa as *mut u32);\n-                    let vb = ptr::read_unaligned(pb as *mut u32);\n-                    ptr::write_unaligned(pa as *mut u32, vb.rotate_left(16));\n-                    ptr::write_unaligned(pb as *mut u32, va.rotate_left(16));\n-                }\n-                i += chunk;\n-            }\n-        }\n+        // Introducing a function boundary here means that the two halves\n+        // get `noalias` markers, allowing better optimization as LLVM\n+        // knows that they're disjoint, unlike in the original slice.\n+        revswap(front_half, back_half, half_len);\n \n-        while i < ln / 2 {\n-            // SAFETY: `i` is inferior to half the length of the slice so\n-            // accessing `i` and `ln - i - 1` is safe (`i` starts at 0 and\n-            // will not go further than `ln / 2 - 1`).\n-            // The resulting pointers `pa` and `pb` are therefore valid and\n-            // aligned, and can be read from and written to.\n-            unsafe {\n-                self.swap_unchecked(i, ln - i - 1);\n+        #[inline]\n+        fn revswap<T>(a: &mut [T], b: &mut [T], n: usize) {\n+            debug_assert_eq!(a.len(), n);\n+            debug_assert_eq!(b.len(), n);\n+\n+            // Because this function is first compiled in isolation,\n+            // this check tells LLVM that the indexing below is\n+            // in-bounds.  Then after inlining -- once the actual\n+            // lengths of the slices are known -- it's removed.\n+            let (a, b) = (&mut a[..n], &mut b[..n]);\n+\n+            for i in 0..n {\n+                mem::swap(&mut a[i], &mut b[n - 1 - i]);\n             }\n-            i += 1;\n         }\n     }\n "}, {"sha": "5b29b2646fdb048894fa89e51ae543a8c58a0339", "filename": "src/test/codegen/slice-reverse.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/71f5cfb21f3fd2f1740bced061c66ff112fec259/src%2Ftest%2Fcodegen%2Fslice-reverse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f5cfb21f3fd2f1740bced061c66ff112fec259/src%2Ftest%2Fcodegen%2Fslice-reverse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-reverse.rs?ref=71f5cfb21f3fd2f1740bced061c66ff112fec259", "patch": "@@ -0,0 +1,26 @@\n+// compile-flags: -O\n+// only-x86_64\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @slice_reverse_u8\n+#[no_mangle]\n+pub fn slice_reverse_u8(slice: &mut [u8]) {\n+    // CHECK-NOT: panic_bounds_check\n+    // CHECK-NOT: slice_end_index_len_fail\n+    // CHECK: shufflevector <{{[0-9]+}} x i8>\n+    // CHECK-NOT: panic_bounds_check\n+    // CHECK-NOT: slice_end_index_len_fail\n+    slice.reverse();\n+}\n+\n+// CHECK-LABEL: @slice_reverse_i32\n+#[no_mangle]\n+pub fn slice_reverse_i32(slice: &mut [i32]) {\n+    // CHECK-NOT: panic_bounds_check\n+    // CHECK-NOT: slice_end_index_len_fail\n+    // CHECK: shufflevector <{{[0-9]+}} x i32>\n+    // CHECK-NOT: panic_bounds_check\n+    // CHECK-NOT: slice_end_index_len_fail\n+    slice.reverse();\n+}"}]}