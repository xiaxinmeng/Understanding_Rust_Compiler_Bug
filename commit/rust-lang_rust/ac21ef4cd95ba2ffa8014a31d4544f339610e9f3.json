{"sha": "ac21ef4cd95ba2ffa8014a31d4544f339610e9f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMjFlZjRjZDk1YmEyZmZhODAxNGEzMWQ0NTQ0ZjMzOTYxMGU5ZjM=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-07T09:12:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-07T09:12:04Z"}, "message": "Merge pull request #91 from oli-obk/master\n\nrustup and small fixes", "tree": {"sha": "bc57e2b4c223f1b84cdb2f600cb66b5d768d2f4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc57e2b4c223f1b84cdb2f600cb66b5d768d2f4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3", "html_url": "https://github.com/rust-lang/rust/commit/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c076321a94e626968606610f491439fb8b409a25", "url": "https://api.github.com/repos/rust-lang/rust/commits/c076321a94e626968606610f491439fb8b409a25", "html_url": "https://github.com/rust-lang/rust/commit/c076321a94e626968606610f491439fb8b409a25"}, {"sha": "5dd01c309fbe730d378c4a55f8d6aadfe9eabeea", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd01c309fbe730d378c4a55f8d6aadfe9eabeea", "html_url": "https://github.com/rust-lang/rust/commit/5dd01c309fbe730d378c4a55f8d6aadfe9eabeea"}], "stats": {"total": 95, "additions": 54, "deletions": 41}, "files": [{"sha": "1b8072190ba6ceeaff2ef7395fb8e142d3d9adfe", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=ac21ef4cd95ba2ffa8014a31d4544f339610e9f3", "patch": "@@ -82,6 +82,12 @@ pub struct Frame<'tcx> {\n     /// Before being initialized, a local is simply marked as None.\n     pub locals: Vec<Option<Value>>,\n \n+    /// Temporary allocations introduced to save stackframes\n+    /// This is pure interpreter magic and has nothing to do with how rustc does it\n+    /// An example is calling an FnMut closure that has been converted to a FnOnce closure\n+    /// The memory will be freed when the stackframe finishes\n+    pub interpreter_temporaries: Vec<Pointer>,\n+\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -327,6 +333,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         substs: &'tcx Substs<'tcx>,\n         return_lvalue: Lvalue<'tcx>,\n         return_to_block: StackPopCleanup,\n+        temporaries: Vec<Pointer>,\n     ) -> EvalResult<'tcx, ()> {\n         ::log_settings::settings().indentation += 1;\n \n@@ -341,6 +348,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             return_to_block: return_to_block,\n             return_lvalue: return_lvalue,\n             locals: locals,\n+            interpreter_temporaries: temporaries,\n             span: span,\n             def_id: def_id,\n             substs: substs,\n@@ -385,9 +393,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             StackPopCleanup::None => {},\n         }\n         // deallocate all locals that are backed by an allocation\n-        for (i, local) in frame.locals.into_iter().enumerate() {\n+        for local in frame.locals.into_iter() {\n             if let Some(Value::ByRef(ptr)) = local {\n-                trace!(\"deallocating local {}: {:?}\", i + 1, ptr);\n+                trace!(\"deallocating local\");\n                 self.memory.dump(ptr.alloc_id);\n                 match self.memory.deallocate(ptr) {\n                     // Any frozen memory means that it belongs to a constant or something referenced\n@@ -399,6 +407,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n             }\n         }\n+        // deallocate all temporary allocations\n+        for ptr in frame.interpreter_temporaries {\n+            trace!(\"deallocating temporary allocation\");\n+            self.memory.dump(ptr.alloc_id);\n+            self.memory.deallocate(ptr)?;\n+        }\n         Ok(())\n     }\n \n@@ -1131,27 +1145,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(new_lvalue)\n     }\n \n-    // FIXME(solson): This method unnecessarily allocates and should not be necessary. We can\n-    // remove it as soon as PrimVal can represent fat pointers.\n-    fn value_to_ptr_dont_use(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n-        match value {\n-            Value::ByRef(ptr) => Ok(ptr),\n-\n-            Value::ByVal(primval) => {\n-                let ptr = self.alloc_ptr(ty)?;\n-                let kind = self.ty_to_primval_kind(ty)?;\n-                self.memory.write_primval(ptr, primval, kind)?;\n-                Ok(ptr)\n-            }\n-\n-            Value::ByValPair(a, b) => {\n-                let ptr = self.alloc_ptr(ty)?;\n-                self.write_pair_to_ptr(a, b, ptr, ty)?;\n-                Ok(ptr)\n-            }\n-        }\n-    }\n-\n     /// ensures this Value is not a ByRef\n     fn follow_by_ref_value(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         match value {\n@@ -1719,6 +1712,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n         tcx.intern_substs(&[]),\n         Lvalue::from_ptr(Pointer::zst_ptr()),\n         StackPopCleanup::None,\n+        Vec::new(),\n     ).expect(\"could not allocate first stack frame\");\n \n     loop {"}, {"sha": "ff4f3b3aa7003d038b87a74efb05642234d99276", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=ac21ef4cd95ba2ffa8014a31d4544f339610e9f3", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n             } else {\n                 StackPopCleanup::None\n             };\n-            this.ecx.push_stack_frame(def_id, span, mir, substs, Lvalue::Global(cid), cleanup)\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, Lvalue::Global(cid), cleanup, Vec::new())\n         });\n     }\n     fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n@@ -194,7 +194,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                                               mir,\n                                               this.substs,\n                                               Lvalue::Global(cid),\n-                                              StackPopCleanup::Freeze)\n+                                              StackPopCleanup::Freeze,\n+                                              Vec::new())\n                 });\n             }\n         }"}, {"sha": "9c7b13adf76b6ba9a72f7fe07d41384c56b56ba7", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=ac21ef4cd95ba2ffa8014a31d4544f339610e9f3", "patch": "@@ -190,11 +190,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 let mut drops = Vec::new();\n                 self.drop(lvalue, ty, &mut drops)?;\n+                let span = {\n+                    let frame = self.frame();\n+                    frame.mir[frame.block].terminator().source_info.span\n+                };\n                 // need to change the block before pushing the drop impl stack frames\n                 // we could do this for all intrinsics before evaluating the intrinsics, but if\n                 // the evaluation fails, we should not have moved forward\n                 self.goto_block(target);\n-                return self.eval_drop_impls(drops);\n+                return self.eval_drop_impls(drops, span);\n             }\n \n             \"fabsf32\" => {"}, {"sha": "837c7011125274f6a17105bcb8d45491b5bf45b6", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=ac21ef4cd95ba2ffa8014a31d4544f339610e9f3", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let mut drops = Vec::new();\n                 self.drop(lval, ty, &mut drops)?;\n                 self.goto_block(target);\n-                self.eval_drop_impls(drops)?;\n+                self.eval_drop_impls(drops, terminator.source_info.span)?;\n             }\n \n             Assert { ref cond, expected, ref msg, target, .. } => {\n@@ -151,12 +151,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>) -> EvalResult<'tcx, ()> {\n-        let span = self.frame().span;\n+    pub fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>, span: Span) -> EvalResult<'tcx, ()> {\n         // add them to the stack in reverse order, because the impl that needs to run the last\n         // is the one that needs to be at the bottom of the stack\n         for (drop_def_id, self_arg, substs) in drops.into_iter().rev() {\n-            // FIXME: supply a real span\n             let mir = self.load_mir(drop_def_id)?;\n             trace!(\"substs for drop glue: {:?}\", substs);\n             self.push_stack_frame(\n@@ -166,6 +164,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 substs,\n                 Lvalue::from_ptr(Pointer::zst_ptr()),\n                 StackPopCleanup::None,\n+                Vec::new(),\n             )?;\n             let mut arg_locals = self.frame().mir.args_iter();\n             let first = arg_locals.next().expect(\"drop impl has self arg\");\n@@ -213,11 +212,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n \n                 // Only trait methods can have a Self parameter.\n-                let (resolved_def_id, resolved_substs) =\n+                let (resolved_def_id, resolved_substs, temporaries) =\n                     if let Some(trait_id) = self.tcx.trait_of_item(def_id) {\n                         self.trait_method(trait_id, def_id, substs, &mut args)?\n                     } else {\n-                        (def_id, substs)\n+                        (def_id, substs, Vec::new())\n                     };\n \n                 let mir = self.load_mir(resolved_def_id)?;\n@@ -237,6 +236,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     resolved_substs,\n                     return_lvalue,\n                     return_to_block,\n+                    temporaries,\n                 )?;\n \n                 let arg_locals = self.frame().mir.args_iter();\n@@ -432,7 +432,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         args: &mut Vec<(Value, Ty<'tcx>)>,\n-    ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>)> {\n+    ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>, Vec<Pointer>)> {\n         let trait_ref = ty::TraitRef::from_method(self.tcx, trait_id, substs);\n         let trait_ref = self.tcx.normalize_associated_type(&ty::Binder(trait_ref));\n \n@@ -444,7 +444,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // and those from the method:\n                 let (did, substs) = find_method(self.tcx, substs, impl_did, vtable_impl.substs, mname);\n \n-                Ok((did, substs))\n+                Ok((did, substs, Vec::new()))\n             }\n \n             traits::VtableClosure(vtable_closure) => {\n@@ -455,6 +455,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let closure_kind = self.tcx.closure_kind(vtable_closure.closure_def_id);\n                 trace!(\"closures {:?}, {:?}\", closure_kind, trait_closure_kind);\n                 self.unpack_fn_args(args)?;\n+                let mut temporaries = Vec::new();\n                 match (closure_kind, trait_closure_kind) {\n                     (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n                     (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n@@ -474,23 +475,36 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                         // Interpreter magic: insert an intermediate pointer, so we can skip the\n                         // intermediate function call.\n-                        // FIXME: this is a memory leak, should probably add the pointer to the\n-                        // current stack.\n-                        let first = self.value_to_ptr_dont_use(args[0].0, args[0].1)?;\n-                        args[0].0 = Value::ByVal(PrimVal::from_ptr(first));\n+                        let ptr = match args[0].0 {\n+                            Value::ByRef(ptr) => ptr,\n+                            Value::ByVal(primval) => {\n+                                let ptr = self.alloc_ptr(args[0].1)?;\n+                                let kind = self.ty_to_primval_kind(args[0].1)?;\n+                                self.memory.write_primval(ptr, primval, kind)?;\n+                                temporaries.push(ptr);\n+                                ptr\n+                            },\n+                            Value::ByValPair(a, b) => {\n+                                let ptr = self.alloc_ptr(args[0].1)?;\n+                                self.write_pair_to_ptr(a, b, ptr, args[0].1)?;\n+                                temporaries.push(ptr);\n+                                ptr\n+                            },\n+                        };\n+                        args[0].0 = Value::ByVal(PrimVal::from_ptr(ptr));\n                         args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n                     }\n \n                     _ => bug!(\"cannot convert {:?} to {:?}\", closure_kind, trait_closure_kind),\n                 }\n-                Ok((vtable_closure.closure_def_id, vtable_closure.substs.substs))\n+                Ok((vtable_closure.closure_def_id, vtable_closure.substs.substs, temporaries))\n             }\n \n             traits::VtableFnPointer(vtable_fn_ptr) => {\n                 if let ty::TyFnDef(did, ref substs, _) = vtable_fn_ptr.fn_ty.sty {\n                     args.remove(0);\n                     self.unpack_fn_args(args)?;\n-                    Ok((did, substs))\n+                    Ok((did, substs, Vec::new()))\n                 } else {\n                     bug!(\"VtableFnPointer did not contain a concrete function: {:?}\", vtable_fn_ptr)\n                 }\n@@ -506,7 +520,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let fn_ptr = self.memory.read_ptr(vtable.offset(offset))?;\n                     let (def_id, substs, _abi, sig) = self.memory.get_fn(fn_ptr.alloc_id)?;\n                     *first_ty = sig.inputs[0];\n-                    Ok((def_id, substs))\n+                    Ok((def_id, substs, Vec::new()))\n                 } else {\n                     Err(EvalError::VtableForArgumentlessMethod)\n                 }"}]}