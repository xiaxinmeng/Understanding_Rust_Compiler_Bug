{"sha": "2f6226518bd5085896a0f27cfd3ea396367ecd50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNjIyNjUxOGJkNTA4NTg5NmEwZjI3Y2ZkM2VhMzk2MzY3ZWNkNTA=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2018-11-16T21:22:06Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2018-12-07T17:54:11Z"}, "message": "use top level `fs` functions where appropriate\n\nThis commit replaces many usages of `File::open` and reading or writing\nwith `fs::read_to_string`, `fs::read` and `fs::write`. This reduces code\ncomplexity, and will improve performance for most reads, since the\nfunctions allocate the buffer to be the size of the file.\n\nI believe that this commit will not impact behavior in any way, so some\nmatches will check the error kind in case the file was not valid UTF-8.\nSome of these cases may not actually care about the error.", "tree": {"sha": "713f018b5a2028f682ac9fcf84688022e5f6acfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/713f018b5a2028f682ac9fcf84688022e5f6acfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f6226518bd5085896a0f27cfd3ea396367ecd50", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEELriChyEaiMu0yCg7viIhAz7bw3QFAlwKs8QWHGFydXNzZWxs\nMTIzQGdtYWlsLmNvbQAKCRC+IiEDPtvDdKoBCACaXtZj0JcimWgKMORRvlqy0oNx\npTLrWQRg0+IB/vFoaHB63N1y87SrLf1PFZsTgAfvPb+8tdWDjKa1TqAoutdwC+Lk\nVvAOt5kctOxf8tKo1/+3aMfpQBuAAV2pntzefyW2tFcqE7BcwoYz/MwxfMTfPElY\njXutt6V9Lzk2FapyJC15kT8b57oqIXDJ3QI07SKopk/zCI8JZOGheBq2Fev8sBH/\nn38E2fg8ma7sSvhvoLEzKoVKkPvuHC2g1jfKjuJbeRfcuKW8SeviBH5bP4HTHQob\nQX4YUlOhnEPEAsizRtQ0vZUigXhqYYxTuQzoQq26ikesQPygUmUuO2KGeNQ4\n=1904\n-----END PGP SIGNATURE-----", "payload": "tree 713f018b5a2028f682ac9fcf84688022e5f6acfe\nparent 1c3236afc3560b5781acf942a4746aeb11e5374e\nauthor Andy Russell <arussell123@gmail.com> 1542403326 -0500\ncommitter Andy Russell <arussell123@gmail.com> 1544205251 -0500\n\nuse top level `fs` functions where appropriate\n\nThis commit replaces many usages of `File::open` and reading or writing\nwith `fs::read_to_string`, `fs::read` and `fs::write`. This reduces code\ncomplexity, and will improve performance for most reads, since the\nfunctions allocate the buffer to be the size of the file.\n\nI believe that this commit will not impact behavior in any way, so some\nmatches will check the error kind in case the file was not valid UTF-8.\nSome of these cases may not actually care about the error.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f6226518bd5085896a0f27cfd3ea396367ecd50", "html_url": "https://github.com/rust-lang/rust/commit/2f6226518bd5085896a0f27cfd3ea396367ecd50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f6226518bd5085896a0f27cfd3ea396367ecd50/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c3236afc3560b5781acf942a4746aeb11e5374e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c3236afc3560b5781acf942a4746aeb11e5374e", "html_url": "https://github.com/rust-lang/rust/commit/1c3236afc3560b5781acf942a4746aeb11e5374e"}], "stats": {"total": 372, "additions": 137, "deletions": 235}, "files": [{"sha": "2e792b6053ea354016e4f99855e4d9d0a0c18c4d", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -18,7 +18,7 @@\n \n use std::borrow::Cow;\n use std::env;\n-use std::fs::{self, File};\n+use std::fs;\n use std::io::BufReader;\n use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n@@ -707,7 +707,7 @@ impl Step for CodegenBackend {\n         }\n         let stamp = codegen_backend_stamp(builder, compiler, target, backend);\n         let codegen_backend = codegen_backend.to_str().unwrap();\n-        t!(t!(File::create(&stamp)).write_all(codegen_backend.as_bytes()));\n+        t!(fs::write(&stamp, &codegen_backend));\n     }\n }\n \n@@ -796,8 +796,7 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n \n     for backend in builder.config.rust_codegen_backends.iter() {\n         let stamp = codegen_backend_stamp(builder, compiler, target, *backend);\n-        let mut dylib = String::new();\n-        t!(t!(File::open(&stamp)).read_to_string(&mut dylib));\n+        let dylib = t!(fs::read_to_string(&stamp));\n         let file = Path::new(&dylib);\n         let filename = file.file_name().unwrap().to_str().unwrap();\n         // change `librustc_codegen_llvm-xxxxxx.so` to `librustc_codegen_llvm-llvm.so`\n@@ -1137,10 +1136,7 @@ pub fn run_cargo(builder: &Builder,\n     // contents (the list of files to copy) is different or if any dep's mtime\n     // is newer then we rewrite the stamp file.\n     deps.sort();\n-    let mut stamp_contents = Vec::new();\n-    if let Ok(mut f) = File::open(stamp) {\n-        t!(f.read_to_end(&mut stamp_contents));\n-    }\n+    let stamp_contents = fs::read(stamp);\n     let stamp_mtime = mtime(&stamp);\n     let mut new_contents = Vec::new();\n     let mut max = None;\n@@ -1156,7 +1152,10 @@ pub fn run_cargo(builder: &Builder,\n     }\n     let max = max.unwrap();\n     let max_path = max_path.unwrap();\n-    if stamp_contents == new_contents && max <= stamp_mtime {\n+    let contents_equal = stamp_contents\n+        .map(|contents| contents == new_contents)\n+        .unwrap_or_default();\n+    if contents_equal && max <= stamp_mtime {\n         builder.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n                 stamp, max, stamp_mtime));\n         return deps\n@@ -1166,7 +1165,7 @@ pub fn run_cargo(builder: &Builder,\n     } else {\n         builder.verbose(&format!(\"updating {:?} as deps changed\", stamp));\n     }\n-    t!(t!(File::create(stamp)).write_all(&new_contents));\n+    t!(fs::write(&stamp, &new_contents));\n     deps\n }\n "}, {"sha": "1dafbe148afdafd503f1f640e36c4749d1e69b6d", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -15,8 +15,7 @@\n \n use std::collections::{HashMap, HashSet};\n use std::env;\n-use std::fs::{self, File};\n-use std::io::prelude::*;\n+use std::fs;\n use std::path::{Path, PathBuf};\n use std::process;\n use std::cmp;\n@@ -416,9 +415,7 @@ impl Config {\n         config.run_host_only = !(flags.host.is_empty() && !flags.target.is_empty());\n \n         let toml = file.map(|file| {\n-            let mut f = t!(File::open(&file));\n-            let mut contents = String::new();\n-            t!(f.read_to_string(&mut contents));\n+            let contents = t!(fs::read_to_string(&file));\n             match toml::from_str(&contents) {\n                 Ok(table) => table,\n                 Err(err) => {"}, {"sha": "d9ff6276d52601c97e97c5ea6861a8a89f03c932", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -19,8 +19,8 @@\n //! pieces of `rustup.rs`!\n \n use std::env;\n-use std::fs::{self, File};\n-use std::io::{Read, Write};\n+use std::fs;\n+use std::io::Write;\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n \n@@ -1511,8 +1511,7 @@ impl Step for Extended {\n         }\n \n         let xform = |p: &Path| {\n-            let mut contents = String::new();\n-            t!(t!(File::open(p)).read_to_string(&mut contents));\n+            let mut contents = t!(fs::read_to_string(p));\n             if rls_installer.is_none() {\n                 contents = filter(&contents, \"rls\");\n             }\n@@ -1523,8 +1522,8 @@ impl Step for Extended {\n                 contents = filter(&contents, \"rustfmt\");\n             }\n             let ret = tmp.join(p.file_name().unwrap());\n-            t!(t!(File::create(&ret)).write_all(contents.as_bytes()));\n-            return ret\n+            t!(fs::write(&ret, &contents));\n+            ret\n         };\n \n         if target.contains(\"apple-darwin\") {\n@@ -1869,8 +1868,7 @@ impl Step for HashSign {\n         let file = builder.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n         });\n-        let mut pass = String::new();\n-        t!(t!(File::open(&file)).read_to_string(&mut pass));\n+        let pass = t!(fs::read_to_string(&file));\n \n         let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n "}, {"sha": "2d0625b26dbe3cf19de5a655fcafad2d0669f40a", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -18,8 +18,7 @@\n //! `rustdoc`.\n \n use std::collections::HashSet;\n-use std::fs::{self, File};\n-use std::io::prelude::*;\n+use std::fs;\n use std::io;\n use std::path::{PathBuf, Path};\n \n@@ -379,12 +378,11 @@ impl Step for Standalone {\n         let version_info = out.join(\"version_info.html\");\n \n         if !builder.config.dry_run && !up_to_date(&version_input, &version_info) {\n-            let mut info = String::new();\n-            t!(t!(File::open(&version_input)).read_to_string(&mut info));\n-            let info = info.replace(\"VERSION\", &builder.rust_release())\n-                           .replace(\"SHORT_HASH\", builder.rust_info.sha_short().unwrap_or(\"\"))\n-                           .replace(\"STAMP\", builder.rust_info.sha().unwrap_or(\"\"));\n-            t!(t!(File::create(&version_info)).write_all(info.as_bytes()));\n+            let info = t!(fs::read_to_string(&version_input))\n+                .replace(\"VERSION\", &builder.rust_release())\n+                .replace(\"SHORT_HASH\", builder.rust_info.sha_short().unwrap_or(\"\"))\n+                .replace(\"STAMP\", builder.rust_info.sha().unwrap_or(\"\"));\n+            t!(fs::write(&version_info, &info));\n         }\n \n         for file in t!(fs::read_dir(builder.src.join(\"src/doc\"))) {"}, {"sha": "a62830da4bb61974b01e463e0dcce3b48ff3412d", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -1067,9 +1067,8 @@ impl Build {\n \n     /// Returns the `a.b.c` version that the given package is at.\n     fn release_num(&self, package: &str) -> String {\n-        let mut toml = String::new();\n         let toml_file_name = self.src.join(&format!(\"src/tools/{}/Cargo.toml\", package));\n-        t!(t!(File::open(toml_file_name)).read_to_string(&mut toml));\n+        let toml = t!(fs::read_to_string(&toml_file_name));\n         for line in toml.lines() {\n             let prefix = \"version = \\\"\";\n             let suffix = \"\\\"\";\n@@ -1151,8 +1150,7 @@ impl Build {\n         }\n \n         let mut paths = Vec::new();\n-        let mut contents = Vec::new();\n-        t!(t!(File::open(stamp)).read_to_end(&mut contents));\n+        let contents = t!(fs::read(stamp));\n         // This is the method we use for extracting paths from the stamp file passed to us. See\n         // run_cargo for more information (in compile.rs).\n         for part in contents.split(|b| *b == 0) {"}, {"sha": "150b6bea18064d51a5a2ac78321ebb3c80433ecc", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -21,7 +21,6 @@\n use std::env;\n use std::ffi::OsString;\n use std::fs::{self, File};\n-use std::io::{Read, Write};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n@@ -75,8 +74,7 @@ impl Step for Llvm {\n         }\n \n         let rebuild_trigger = builder.src.join(\"src/rustllvm/llvm-rebuild-trigger\");\n-        let mut rebuild_trigger_contents = String::new();\n-        t!(t!(File::open(&rebuild_trigger)).read_to_string(&mut rebuild_trigger_contents));\n+        let rebuild_trigger_contents = t!(fs::read_to_string(&rebuild_trigger));\n \n         let (out_dir, llvm_config_ret_dir) = if emscripten {\n             let dir = builder.emscripten_llvm_out(target);\n@@ -93,8 +91,7 @@ impl Step for Llvm {\n         let build_llvm_config = llvm_config_ret_dir\n             .join(exe(\"llvm-config\", &*builder.config.build));\n         if done_stamp.exists() {\n-            let mut done_contents = String::new();\n-            t!(t!(File::open(&done_stamp)).read_to_string(&mut done_contents));\n+            let done_contents = t!(fs::read_to_string(&done_stamp));\n \n             // If LLVM was already built previously and contents of the rebuild-trigger file\n             // didn't change from the previous build, then no action is required.\n@@ -261,7 +258,7 @@ impl Step for Llvm {\n \n         cfg.build();\n \n-        t!(t!(File::create(&done_stamp)).write_all(rebuild_trigger_contents.as_bytes()));\n+        t!(fs::write(&done_stamp, &rebuild_trigger_contents));\n \n         build_llvm_config\n     }"}, {"sha": "7a9e6d4fd387b8a7fa3b0a6b7954c457b0191fda", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -21,8 +21,7 @@\n use std::collections::HashMap;\n use std::env;\n use std::ffi::{OsString, OsStr};\n-use std::fs::{self, File};\n-use std::io::Read;\n+use std::fs;\n use std::path::PathBuf;\n use std::process::Command;\n \n@@ -235,9 +234,7 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n     }\n \n     if build.config.channel == \"stable\" {\n-        let mut stage0 = String::new();\n-        t!(t!(File::open(build.src.join(\"src/stage0.txt\")))\n-            .read_to_string(&mut stage0));\n+        let stage0 = t!(fs::read_to_string(build.src.join(\"src/stage0.txt\")));\n         if stage0.contains(\"\\ndev:\") {\n             panic!(\"bootstrapping from a dev compiler in a stable release, but \\\n                     should only be bootstrapping from a released compiler!\");"}, {"sha": "4ece3435e929abaf2e49a75fec9446162ac1c358", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -16,8 +16,7 @@\n use std::env;\n use std::ffi::OsString;\n use std::fmt;\n-use std::fs::{self, File};\n-use std::io::Read;\n+use std::fs;\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n@@ -1427,10 +1426,8 @@ impl Step for ErrorIndex {\n }\n \n fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool {\n-    match File::open(markdown) {\n-        Ok(mut file) => {\n-            let mut contents = String::new();\n-            t!(file.read_to_string(&mut contents));\n+    match fs::read_to_string(markdown) {\n+        Ok(contents) => {\n             if !contents.contains(\"```\") {\n                 return true;\n             }"}, {"sha": "2d4813718f41a0f92d97eb57cc538e4131186fba", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -327,7 +327,8 @@ pub trait Into<T>: Sized {\n /// An example usage for error handling:\n ///\n /// ```\n-/// use std::io::{self, Read};\n+/// use std::fs;\n+/// use std::io;\n /// use std::num;\n ///\n /// enum CliError {\n@@ -348,9 +349,7 @@ pub trait Into<T>: Sized {\n /// }\n ///\n /// fn open_and_parse_file(file_name: &str) -> Result<i32, CliError> {\n-///     let mut file = std::fs::File::open(\"test\")?;\n-///     let mut contents = String::new();\n-///     file.read_to_string(&mut contents)?;\n+///     let mut contents = fs::read_to_string(&file_name)?;\n ///     let num: i32 = contents.trim().parse()?;\n ///     Ok(num)\n /// }"}, {"sha": "512e57d810aa43b783e896fe6c0818b519be5da4", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -31,9 +31,8 @@ use std::borrow::Cow;\n use std::collections::hash_map::Entry::Vacant;\n use std::collections::btree_map::BTreeMap;\n use std::env;\n-use std::fs::File;\n+use std::fs;\n use std::io;\n-use std::io::prelude::*;\n use std::sync::atomic::{AtomicBool, Ordering};\n \n fn print_help_message() {\n@@ -268,5 +267,5 @@ fn dump_region_data_to<'a, 'gcx, 'tcx>(region_rels: &RegionRelations<'a, 'gcx, '\n     debug!(\"dump_region_data calling render\");\n     let mut v = Vec::new();\n     dot::render(&g, &mut v).unwrap();\n-    File::create(path).and_then(|mut f| f.write_all(&v))\n+    fs::write(path, &v)\n }"}, {"sha": "74718460f562fbe0e0f165b2c882cff4dea531e3", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -22,8 +22,8 @@\n #![feature(box_syntax)]\n \n use std::any::Any;\n-use std::io::{self, Write};\n-use std::fs::File;\n+use std::io::Write;\n+use std::fs;\n use std::path::Path;\n use std::sync::{mpsc, Arc};\n \n@@ -81,11 +81,7 @@ pub struct NoLlvmMetadataLoader;\n \n impl MetadataLoader for NoLlvmMetadataLoader {\n     fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<MetadataRef, String> {\n-        let mut file = File::open(filename)\n-            .map_err(|e| format!(\"metadata file open err: {:?}\", e))?;\n-\n-        let mut buf = Vec::new();\n-        io::copy(&mut file, &mut buf).unwrap();\n+        let buf = fs::read(filename).map_err(|e| format!(\"metadata file open err: {:?}\", e))?;\n         let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf);\n         Ok(rustc_erase_owner!(buf.map_owner_box()))\n     }\n@@ -209,8 +205,7 @@ impl CodegenBackend for MetadataOnlyCodegenBackend {\n             } else {\n                 &ongoing_codegen.metadata.raw_data\n             };\n-            let mut file = File::create(&output_name).unwrap();\n-            file.write_all(metadata).unwrap();\n+            fs::write(&output_name, metadata).unwrap();\n         }\n \n         sess.abort_if_errors();"}, {"sha": "b316cddf0c8ecfb8e53287cd86966a5b9a7feba6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -778,10 +778,7 @@ fn write_shared(\n     let mut themes: FxHashSet<String> = FxHashSet::default();\n \n     for entry in &cx.shared.themes {\n-        let mut content = Vec::with_capacity(100000);\n-\n-        let mut f = try_err!(File::open(&entry), &entry);\n-        try_err!(f.read_to_end(&mut content), &entry);\n+        let content = try_err!(fs::read(&entry), &entry);\n         let theme = try_none!(try_none!(entry.file_stem(), &entry).to_str(), &entry);\n         let extension = try_none!(try_none!(entry.extension(), &entry).to_str(), &entry);\n         write(cx.dst.join(format!(\"{}{}.{}\", theme, cx.shared.resource_suffix, extension)),\n@@ -881,10 +878,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         if !options.enable_minification {\n             try_err!(fs::copy(css, out), css);\n         } else {\n-            let mut f = try_err!(File::open(css), css);\n-            let mut buffer = String::with_capacity(1000);\n-\n-            try_err!(f.read_to_string(&mut buffer), css);\n+            let buffer = try_err!(fs::read_to_string(css), css);\n             write_minify(out, &buffer, options.enable_minification)?;\n         }\n     }\n@@ -2102,8 +2096,7 @@ impl Context {\n                 if !buf.is_empty() {\n                     try_err!(this.shared.ensure_dir(&this.dst), &this.dst);\n                     let joint_dst = this.dst.join(\"index.html\");\n-                    let mut dst = try_err!(File::create(&joint_dst), &joint_dst);\n-                    try_err!(dst.write_all(&buf), &joint_dst);\n+                    try_err!(fs::write(&joint_dst, buf), &joint_dst);\n                 }\n \n                 let m = match item.inner {\n@@ -2137,8 +2130,7 @@ impl Context {\n                 let file_name = &item_path(item_type, name);\n                 try_err!(self.shared.ensure_dir(&self.dst), &self.dst);\n                 let joint_dst = self.dst.join(file_name);\n-                let mut dst = try_err!(File::create(&joint_dst), &joint_dst);\n-                try_err!(dst.write_all(&buf), &joint_dst);\n+                try_err!(fs::write(&joint_dst, buf), &joint_dst);\n \n                 if !self.render_redirect_pages {\n                     all.append(full_path(self, &item), &item_type);"}, {"sha": "206a72cebfef8f0b1165586d8b6623bc4967df89", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n use rustc_data_structures::fx::FxHashSet;\n-use std::fs::File;\n+use std::fs;\n use std::hash::{Hash, Hasher};\n-use std::io::Read;\n use std::path::Path;\n \n use errors::Handler;\n@@ -278,12 +277,9 @@ pub fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>)\n pub fn test_theme_against<P: AsRef<Path>>(f: &P, against: &CssPath, diag: &Handler)\n     -> (bool, Vec<String>)\n {\n-    let mut file = try_something!(File::open(f), diag, (false, Vec::new()));\n-    let mut data = Vec::with_capacity(1000);\n-\n-    try_something!(file.read_to_end(&mut data), diag, (false, Vec::new()));\n+    let data = try_something!(fs::read(f), diag, (false, vec![]));\n     let paths = load_css_paths(&data);\n-    let mut ret = Vec::new();\n+    let mut ret = vec![];\n     get_differences(against, &paths, &mut ret);\n     (true, ret)\n }"}, {"sha": "bb5be7f5394bf32d8318192cb4f67c837055d3a4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -34,8 +34,8 @@ use tokenstream::{TokenStream, TokenTree};\n use visit::{self, Visitor};\n \n use rustc_data_structures::fx::FxHashMap;\n-use std::fs::File;\n-use std::io::Read;\n+use std::fs;\n+use std::io::ErrorKind;\n use std::{iter, mem};\n use std::rc::Rc;\n use std::path::PathBuf;\n@@ -1507,20 +1507,8 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                         return noop_fold_attribute(at, self);\n                     }\n \n-                    let mut buf = vec![];\n                     let filename = self.cx.root_path.join(file.to_string());\n-\n-                    match File::open(&filename).and_then(|mut f| f.read_to_end(&mut buf)) {\n-                        Ok(..) => {}\n-                        Err(e) => {\n-                            self.cx.span_err(at.span,\n-                                             &format!(\"couldn't read {}: {}\",\n-                                                      filename.display(),\n-                                                      e));\n-                        }\n-                    }\n-\n-                    match String::from_utf8(buf) {\n+                    match fs::read_to_string(&filename) {\n                         Ok(src) => {\n                             let src_interned = Symbol::intern(&src);\n \n@@ -1530,21 +1518,34 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                             let include_info = vec![\n                                 dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n-                                        attr::mk_name_value_item_str(Ident::from_str(\"file\"),\n-                                                                     dummy_spanned(file)))),\n+                                    attr::mk_name_value_item_str(\n+                                        Ident::from_str(\"file\"),\n+                                        dummy_spanned(file),\n+                                    ),\n+                                )),\n                                 dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n-                                        attr::mk_name_value_item_str(Ident::from_str(\"contents\"),\n-                                                            dummy_spanned(src_interned)))),\n+                                    attr::mk_name_value_item_str(\n+                                        Ident::from_str(\"contents\"),\n+                                        dummy_spanned(src_interned),\n+                                    ),\n+                                )),\n                             ];\n \n                             let include_ident = Ident::from_str(\"include\");\n                             let item = attr::mk_list_item(DUMMY_SP, include_ident, include_info);\n                             items.push(dummy_spanned(ast::NestedMetaItemKind::MetaItem(item)));\n                         }\n-                        Err(_) => {\n-                            self.cx.span_err(at.span,\n-                                             &format!(\"{} wasn't a utf-8 file\",\n-                                                      filename.display()));\n+                        Err(ref e) if e.kind() == ErrorKind::InvalidData => {\n+                            self.cx.span_err(\n+                                at.span,\n+                                &format!(\"{} wasn't a utf-8 file\", filename.display()),\n+                            );\n+                        }\n+                        Err(e) => {\n+                            self.cx.span_err(\n+                                at.span,\n+                                &format!(\"couldn't read {}: {}\", filename.display(), e),\n+                            );\n                         }\n                     }\n                 } else {"}, {"sha": "ec27ceeb74c22ae3191353e7daece91c7ba0242c", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -21,8 +21,8 @@ use smallvec::SmallVec;\n use symbol::Symbol;\n use tokenstream;\n \n-use std::fs::File;\n-use std::io::prelude::*;\n+use std::fs;\n+use std::io::ErrorKind;\n use std::path::PathBuf;\n use rustc_data_structures::sync::Lrc;\n \n@@ -137,18 +137,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n         None => return DummyResult::expr(sp)\n     };\n     let file = res_rel_file(cx, sp, file);\n-    let mut bytes = Vec::new();\n-    match File::open(&file).and_then(|mut f| f.read_to_end(&mut bytes)) {\n-        Ok(..) => {}\n-        Err(e) => {\n-            cx.span_err(sp,\n-                        &format!(\"couldn't read {}: {}\",\n-                                file.display(),\n-                                e));\n-            return DummyResult::expr(sp);\n-        }\n-    };\n-    match String::from_utf8(bytes) {\n+    match fs::read_to_string(&file) {\n         Ok(src) => {\n             let interned_src = Symbol::intern(&src);\n \n@@ -157,11 +146,13 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n             cx.source_map().new_source_file(file.into(), src);\n \n             base::MacEager::expr(cx.expr_str(sp, interned_src))\n+        },\n+        Err(ref e) if e.kind() == ErrorKind::InvalidData => {\n+            cx.span_err(sp, &format!(\"{} wasn't a utf-8 file\", file.display()));\n+            DummyResult::expr(sp)\n         }\n-        Err(_) => {\n-            cx.span_err(sp,\n-                        &format!(\"{} wasn't a utf-8 file\",\n-                                file.display()));\n+        Err(e) => {\n+            cx.span_err(sp, &format!(\"couldn't read {}: {}\", file.display(), e));\n             DummyResult::expr(sp)\n         }\n     }\n@@ -174,22 +165,23 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n         None => return DummyResult::expr(sp)\n     };\n     let file = res_rel_file(cx, sp, file);\n-    let mut bytes = Vec::new();\n-    match File::open(&file).and_then(|mut f| f.read_to_end(&mut bytes)) {\n-        Err(e) => {\n-            cx.span_err(sp,\n-                        &format!(\"couldn't read {}: {}\", file.display(), e));\n-            DummyResult::expr(sp)\n-        }\n-        Ok(..) => {\n-            let src = match String::from_utf8(bytes.clone()) {\n-                Ok(contents) => contents,\n-                Err(..) => \"\".to_string()\n+    match fs::read(&file) {\n+        Ok(bytes) => {\n+            // Add the contents to the source map if it contains UTF-8.\n+            let (contents, bytes) = match String::from_utf8(bytes) {\n+                Ok(s) => {\n+                    let bytes = s.as_bytes().to_owned();\n+                    (s, bytes)\n+                },\n+                Err(e) => (String::new(), e.into_bytes()),\n             };\n-\n-            cx.source_map().new_source_file(file.into(), src);\n+            cx.source_map().new_source_file(file.into(), contents);\n \n             base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Lrc::new(bytes))))\n+        },\n+        Err(e) => {\n+            cx.span_err(sp, &format!(\"couldn't read {}: {}\", file.display(), e));\n+            DummyResult::expr(sp)\n         }\n     }\n }"}, {"sha": "45008129e83b649966f38dba000a29156df75621", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -31,7 +31,7 @@ use std::path::{Path, PathBuf};\n \n use std::env;\n use std::fs;\n-use std::io::{self, Read};\n+use std::io;\n use errors::SourceMapper;\n \n /// Return the span itself if it doesn't come from a macro expansion,\n@@ -96,9 +96,7 @@ impl FileLoader for RealFileLoader {\n     }\n \n     fn read_file(&self, path: &Path) -> io::Result<String> {\n-        let mut src = String::new();\n-        fs::File::open(path)?.read_to_string(&mut src)?;\n-        Ok(src)\n+        fs::read_to_string(path)\n     }\n }\n "}, {"sha": "d9834f9f0a0045588d45fdb46780175288edfd47", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -606,7 +606,7 @@ impl Builder {\n \n         let filename = path.file_name().unwrap().to_str().unwrap();\n         let sha256 = self.output.join(format!(\"{}.sha256\", filename));\n-        t!(t!(File::create(&sha256)).write_all(&sha.stdout));\n+        t!(fs::write(&sha256, &sha.stdout));\n \n         let stdout = String::from_utf8_lossy(&sha.stdout);\n         stdout.split_whitespace().next().unwrap().to_string()\n@@ -643,7 +643,7 @@ impl Builder {\n \n     fn write(&self, contents: &str, channel_name: &str, suffix: &str) {\n         let dst = self.output.join(format!(\"channel-rust-{}{}\", channel_name, suffix));\n-        t!(t!(File::create(&dst)).write_all(contents.as_bytes()));\n+        t!(fs::write(&dst, contents));\n         self.hash(&dst);\n         self.sign(&dst);\n     }"}, {"sha": "ab74e7b7a7fd8498c06032fad7dcc1f1931c328d", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -11,8 +11,7 @@\n use std::env;\n use std::process::Command;\n use std::path::{Path, PathBuf};\n-use std::fs::File;\n-use std::io::Write;\n+use std::fs;\n \n struct Test {\n     repo: &'static str,\n@@ -91,10 +90,7 @@ fn test_repo(cargo: &Path, out_dir: &Path, test: &Test) {\n     println!(\"testing {}\", test.repo);\n     let dir = clone_repo(test, out_dir);\n     if let Some(lockfile) = test.lock {\n-        File::create(&dir.join(\"Cargo.lock\"))\n-            .expect(\"\")\n-            .write_all(lockfile.as_bytes())\n-            .expect(\"\");\n+        fs::write(&dir.join(\"Cargo.lock\"), lockfile).unwrap();\n     }\n     if !run_cargo_test(cargo, &dir, test.packages) {\n         panic!(\"tests failed for {}\", test.repo);"}, {"sha": "65f6bff7eaf55804249a795872f73026edc2a90c", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -38,7 +38,7 @@ use getopts::Options;\n use std::env;\n use std::ffi::OsString;\n use std::fs;\n-use std::io::{self, Read};\n+use std::io::{self, ErrorKind};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use test::ColorConfig;\n@@ -686,13 +686,11 @@ fn up_to_date(\n ) -> bool {\n     let stamp_name = stamp(config, testpaths, revision);\n     // Check hash.\n-    let mut f = match fs::File::open(&stamp_name) {\n+    let contents = match fs::read_to_string(&stamp_name) {\n         Ok(f) => f,\n+        Err(ref e) if e.kind() == ErrorKind::InvalidData => panic!(\"Can't read stamp contents\"),\n         Err(_) => return true,\n     };\n-    let mut contents = String::new();\n-    f.read_to_string(&mut contents)\n-        .expect(\"Can't read stamp contents\");\n     let expected_hash = runtest::compute_stamp_hash(config);\n     if contents != expected_hash {\n         return true;"}, {"sha": "45527a7cce535bf833b290b70117e0253fff8f73", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 19, "deletions": 51, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -458,11 +458,7 @@ impl<'test> TestCx<'test> {\n             None => 2,\n         };\n \n-        let mut src = String::new();\n-        File::open(&self.testpaths.file)\n-            .unwrap()\n-            .read_to_string(&mut src)\n-            .unwrap();\n+        let src = fs::read_to_string(&self.testpaths.file).unwrap();\n         let mut srcs = vec![src];\n \n         let mut round = 0;\n@@ -500,12 +496,7 @@ impl<'test> TestCx<'test> {\n         let mut expected = match self.props.pp_exact {\n             Some(ref file) => {\n                 let filepath = self.testpaths.file.parent().unwrap().join(file);\n-                let mut s = String::new();\n-                File::open(&filepath)\n-                    .unwrap()\n-                    .read_to_string(&mut s)\n-                    .unwrap();\n-                s\n+                fs::read_to_string(&filepath).unwrap()\n             }\n             None => srcs[srcs.len() - 2].clone(),\n         };\n@@ -1949,10 +1940,7 @@ impl<'test> TestCx<'test> {\n \n     fn dump_output_file(&self, out: &str, extension: &str) {\n         let outfile = self.make_out_name(extension);\n-        File::create(&outfile)\n-            .unwrap()\n-            .write_all(out.as_bytes())\n-            .unwrap();\n+        fs::write(&outfile, out).unwrap();\n     }\n \n     /// Create a filename for output with the given extension.  Example:\n@@ -2149,11 +2137,7 @@ impl<'test> TestCx<'test> {\n         path: &P,\n         mut other_files: Option<&mut Vec<String>>,\n     ) -> Vec<usize> {\n-        let mut file =\n-            fs::File::open(path).expect(\"markdown_test_output_check_entry File::open failed\");\n-        let mut content = String::new();\n-        file.read_to_string(&mut content)\n-            .expect(\"markdown_test_output_check_entry read_to_string failed\");\n+        let content = fs::read_to_string(&path).unwrap();\n         let mut ignore = false;\n         content\n             .lines()\n@@ -2826,11 +2810,7 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn check_mir_dump(&self) {\n-        let mut test_file_contents = String::new();\n-        fs::File::open(self.testpaths.file.clone())\n-            .unwrap()\n-            .read_to_string(&mut test_file_contents)\n-            .unwrap();\n+        let test_file_contents = fs::read_to_string(&self.testpaths.file).unwrap();\n         if let Some(idx) = test_file_contents.find(\"// END RUST SOURCE\") {\n             let (_, tests_text) = test_file_contents.split_at(idx + \"// END_RUST SOURCE\".len());\n             let tests_text_str = String::from(tests_text);\n@@ -2894,9 +2874,7 @@ impl<'test> TestCx<'test> {\n         }\n         self.check_mir_test_timestamp(test_name, &output_file);\n \n-        let mut dumped_file = fs::File::open(output_file.clone()).unwrap();\n-        let mut dumped_string = String::new();\n-        dumped_file.read_to_string(&mut dumped_string).unwrap();\n+        let dumped_string = fs::read_to_string(&output_file).unwrap();\n         let mut dumped_lines = dumped_string\n             .lines()\n             .map(|l| nocomment_mir_line(l))\n@@ -3108,19 +3086,13 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn load_expected_output_from_path(&self, path: &Path) -> Result<String, String> {\n-        let mut result = String::new();\n-        match File::open(path).and_then(|mut f| f.read_to_string(&mut result)) {\n-            Ok(_) => Ok(result),\n-            Err(e) => Err(format!(\n-                \"failed to load expected output from `{}`: {}\",\n-                path.display(),\n-                e\n-            )),\n-        }\n+        fs::read_to_string(path).map_err(|err| {\n+            format!(\"failed to load expected output from `{}`: {}\", path.display(), err)\n+        })\n     }\n \n     fn delete_file(&self, file: &PathBuf) {\n-        if let Err(e) = ::std::fs::remove_file(file) {\n+        if let Err(e) = fs::remove_file(file) {\n             self.fatal(&format!(\n                 \"failed to delete `{}`: {}\",\n                 file.display(),\n@@ -3182,16 +3154,13 @@ impl<'test> TestCx<'test> {\n         for output_file in &files {\n             if actual.is_empty() {\n                 self.delete_file(output_file);\n-            } else {\n-                match File::create(&output_file).and_then(|mut f| f.write_all(actual.as_bytes())) {\n-                    Ok(()) => {}\n-                    Err(e) => self.fatal(&format!(\n-                        \"failed to write {} to `{}`: {}\",\n-                        kind,\n-                        output_file.display(),\n-                        e\n-                    )),\n-                }\n+            } else if let Err(err) = fs::write(&output_file, &actual) {\n+                self.fatal(&format!(\n+                    \"failed to write {} to `{}`: {}\",\n+                    kind,\n+                    output_file.display(),\n+                    err,\n+                ));\n             }\n         }\n \n@@ -3243,9 +3212,8 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn create_stamp(&self) {\n-        let mut f = File::create(::stamp(&self.config, self.testpaths, self.revision)).unwrap();\n-        f.write_all(compute_stamp_hash(&self.config).as_bytes())\n-            .unwrap();\n+        let stamp = ::stamp(&self.config, self.testpaths, self.revision);\n+        fs::write(&stamp, compute_stamp_hash(&self.config)).unwrap();\n     }\n }\n "}, {"sha": "03add412b645144ab11029808f6f2885e9ff7576", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -18,8 +18,8 @@ extern crate serialize as rustc_serialize;\n use std::collections::BTreeMap;\n use std::env;\n use std::error::Error;\n-use std::fs::{read_dir, File};\n-use std::io::{Read, Write};\n+use std::fs::{self, read_dir, File};\n+use std::io::Write;\n use std::path::Path;\n use std::path::PathBuf;\n use std::cell::RefCell;\n@@ -210,8 +210,7 @@ fn load_all_errors(metadata_dir: &Path) -> Result<ErrorMetadataMap, Box<dyn Erro\n     for entry in read_dir(metadata_dir)? {\n         let path = entry?.path();\n \n-        let mut metadata_str = String::new();\n-        File::open(&path).and_then(|mut f| f.read_to_string(&mut metadata_str))?;\n+        let metadata_str = fs::read_to_string(&path)?;\n \n         let some_errors: ErrorMetadataMap = json::decode(&metadata_str)?;\n "}, {"sha": "ae930555d0912b63ee98c8b405a135fc7ce46553", "filename": "src/tools/tidy/src/bins.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -24,13 +24,10 @@ pub fn check(_path: &Path, _bad: &mut bool) {}\n #[cfg(unix)]\n pub fn check(path: &Path, bad: &mut bool) {\n     use std::fs;\n-    use std::io::Read;\n     use std::process::{Command, Stdio};\n     use std::os::unix::prelude::*;\n \n-    if let Ok(mut file) = fs::File::open(\"/proc/version\") {\n-        let mut contents = String::new();\n-        file.read_to_string(&mut contents).unwrap();\n+    if let Ok(contents) = fs::read_to_string(\"/proc/version\") {\n         // Probably on Windows Linux Subsystem or Docker via VirtualBox,\n         // all files will be marked as executable, so skip checking.\n         if contents.contains(\"Microsoft\") || contents.contains(\"boot2docker\") {"}, {"sha": "ac7e968dff76ce5b8a48bd7d07fda8e2e8f58cd2", "filename": "src/tools/tidy/src/cargo.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -15,8 +15,7 @@\n //! `extern crate` declarations. This should help us keep the DAG correctly\n //! structured through various refactorings to prune out unnecessary edges.\n \n-use std::io::prelude::*;\n-use std::fs::File;\n+use std::fs;\n use std::path::Path;\n \n pub fn check(path: &Path, bad: &mut bool) {\n@@ -41,10 +40,8 @@ pub fn check(path: &Path, bad: &mut bool) {\n // Verify that the dependencies in Cargo.toml at `tomlfile` are sync'd with the\n // `extern crate` annotations in the lib.rs at `libfile`.\n fn verify(tomlfile: &Path, libfile: &Path, bad: &mut bool) {\n-    let mut toml = String::new();\n-    let mut librs = String::new();\n-    t!(t!(File::open(tomlfile)).read_to_string(&mut toml));\n-    t!(t!(File::open(libfile)).read_to_string(&mut librs));\n+    let toml = t!(fs::read_to_string(&tomlfile));\n+    let librs = t!(fs::read_to_string(&libfile));\n \n     if toml.contains(\"name = \\\"bootstrap\\\"\") {\n         return"}, {"sha": "05c974569a3c532654eb415d153baafe3b7c3951", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -11,8 +11,7 @@\n //! Check license of third-party deps by inspecting vendor\n \n use std::collections::{BTreeSet, HashSet, HashMap};\n-use std::fs::File;\n-use std::io::Read;\n+use std::fs;\n use std::path::Path;\n use std::process::Command;\n \n@@ -262,8 +261,7 @@ fn check_license(path: &Path) -> bool {\n     if !path.exists() {\n         panic!(\"{} does not exist\", path.display());\n     }\n-    let mut contents = String::new();\n-    t!(t!(File::open(path)).read_to_string(&mut contents));\n+    let contents = t!(fs::read_to_string(&path));\n \n     let mut found_license = false;\n     for line in contents.lines() {"}, {"sha": "377a7c33d75ae81760bdcfffadf35f509e4600b0", "filename": "src/tools/tidy/src/extdeps.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -10,8 +10,7 @@\n \n // ! Check for external package sources. Allow only vendorable packages.\n \n-use std::fs::File;\n-use std::io::Read;\n+use std::fs;\n use std::path::Path;\n \n /// List of whitelisted sources for packages\n@@ -25,8 +24,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n     let path = path.join(\"../Cargo.lock\");\n \n     // open and read the whole file\n-    let mut cargo_lock = String::new();\n-    t!(t!(File::open(path)).read_to_string(&mut cargo_lock));\n+    let cargo_lock = t!(fs::read_to_string(&path));\n \n     // process each line\n     for line in cargo_lock.lines() {"}, {"sha": "b0bd5ba8dbdbdabef25f2f7faa9426eac2377a5d", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6226518bd5085896a0f27cfd3ea396367ecd50/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=2f6226518bd5085896a0f27cfd3ea396367ecd50", "patch": "@@ -20,7 +20,7 @@\n \n use std::collections::HashMap;\n use std::fmt;\n-use std::fs::File;\n+use std::fs::{self, File};\n use std::io::prelude::*;\n use std::path::Path;\n \n@@ -183,9 +183,7 @@ fn test_filen_gate(filen_underscore: &str, features: &mut Features) -> bool {\n }\n \n pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n-    let mut contents = String::new();\n-    let path = base_src_path.join(\"libsyntax/feature_gate.rs\");\n-    t!(t!(File::open(path)).read_to_string(&mut contents));\n+    let contents = t!(fs::read_to_string(base_src_path.join(\"libsyntax/feature_gate.rs\")));\n \n     // we allow rustc-internal features to omit a tracking issue.\n     // these features must be marked with `// rustc internal` in its own group."}]}