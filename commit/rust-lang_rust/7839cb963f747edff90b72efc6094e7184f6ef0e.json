{"sha": "7839cb963f747edff90b72efc6094e7184f6ef0e", "node_id": "C_kwDOAAsO6NoAKDc4MzljYjk2M2Y3NDdlZGZmOTBiNzJlZmM2MDk0ZTcxODRmNmVmMGU", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-06-29T14:18:55Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-06-30T07:47:07Z"}, "message": "Change enum->int casts to not go through MIR casts.\n\nInstead we generate a discriminant rvalue and cast the result of that.", "tree": {"sha": "5bf0f8fa756c9bfd3867445cd5a97c91066a5d04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bf0f8fa756c9bfd3867445cd5a97c91066a5d04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7839cb963f747edff90b72efc6094e7184f6ef0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7839cb963f747edff90b72efc6094e7184f6ef0e", "html_url": "https://github.com/rust-lang/rust/commit/7839cb963f747edff90b72efc6094e7184f6ef0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7839cb963f747edff90b72efc6094e7184f6ef0e/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e674b3ec5e2c238e6756d512fa39efc1ceeb74a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e674b3ec5e2c238e6756d512fa39efc1ceeb74a", "html_url": "https://github.com/rust-lang/rust/commit/0e674b3ec5e2c238e6756d512fa39efc1ceeb74a"}], "stats": {"total": 353, "additions": 221, "deletions": 132}, "files": [{"sha": "a07ed405aa4c6b7ae299a6cca7bbb920ecb9b3db", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -635,29 +635,6 @@ fn codegen_stmt<'tcx>(\n                             let (ptr, _extra) = operand.load_scalar_pair(fx);\n                             lval.write_cvalue(fx, CValue::by_val(ptr, dest_layout))\n                         }\n-                    } else if let ty::Adt(adt_def, _substs) = from_ty.kind() {\n-                        // enum -> discriminant value\n-                        assert!(adt_def.is_enum());\n-                        match to_ty.kind() {\n-                            ty::Uint(_) | ty::Int(_) => {}\n-                            _ => unreachable!(\"cast adt {} -> {}\", from_ty, to_ty),\n-                        }\n-                        let to_clif_ty = fx.clif_type(to_ty).unwrap();\n-\n-                        let discriminant = crate::discriminant::codegen_get_discriminant(\n-                            fx,\n-                            operand,\n-                            fx.layout_of(operand.layout().ty.discriminant_ty(fx.tcx)),\n-                        )\n-                        .load_scalar(fx);\n-\n-                        let res = crate::cast::clif_intcast(\n-                            fx,\n-                            discriminant,\n-                            to_clif_ty,\n-                            to_ty.is_signed(),\n-                        );\n-                        lval.write_cvalue(fx, CValue::by_val(res, dest_layout));\n                     } else {\n                         let to_clif_ty = fx.clif_type(to_ty).unwrap();\n                         let from = operand.load_scalar(fx);"}, {"sha": "e3a055b619a3b6f4393d47e31c2f9a874ba810b5", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 8, "deletions": 70, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -12,7 +12,6 @@ use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n-use rustc_target::abi::{Abi, Int, Variants};\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     #[instrument(level = \"debug\", skip(self, bx))]\n@@ -283,74 +282,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             CastTy::from_ty(operand.layout.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast.ty).expect(\"bad output type for cast\");\n                         let ll_t_in = bx.cx().immediate_backend_type(operand.layout);\n-                        match operand.layout.variants {\n-                            Variants::Single { index } => {\n-                                if let Some(discr) =\n-                                    operand.layout.ty.discriminant_for_variant(bx.tcx(), index)\n-                                {\n-                                    let discr_layout = bx.cx().layout_of(discr.ty);\n-                                    let discr_t = bx.cx().immediate_backend_type(discr_layout);\n-                                    let discr_val = bx.cx().const_uint_big(discr_t, discr.val);\n-                                    let discr_val =\n-                                        bx.intcast(discr_val, ll_t_out, discr.ty.is_signed());\n-\n-                                    return (\n-                                        bx,\n-                                        OperandRef {\n-                                            val: OperandValue::Immediate(discr_val),\n-                                            layout: cast,\n-                                        },\n-                                    );\n-                                }\n-                            }\n-                            Variants::Multiple { .. } => {}\n-                        }\n                         let llval = operand.immediate();\n \n-                        let mut signed = false;\n-                        if let Abi::Scalar(scalar) = operand.layout.abi {\n-                            if let Int(_, s) = scalar.primitive() {\n-                                // We use `i1` for bytes that are always `0` or `1`,\n-                                // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n-                                // let LLVM interpret the `i1` as signed, because\n-                                // then `i1 1` (i.e., E::B) is effectively `i8 -1`.\n-                                signed = !scalar.is_bool() && s;\n-\n-                                if !scalar.is_always_valid(bx.cx())\n-                                    && scalar.valid_range(bx.cx()).end\n-                                        >= scalar.valid_range(bx.cx()).start\n-                                {\n-                                    // We want `table[e as usize \u00b1 k]` to not\n-                                    // have bound checks, and this is the most\n-                                    // convenient place to put the `assume`s.\n-                                    if scalar.valid_range(bx.cx()).start > 0 {\n-                                        let enum_value_lower_bound = bx.cx().const_uint_big(\n-                                            ll_t_in,\n-                                            scalar.valid_range(bx.cx()).start,\n-                                        );\n-                                        let cmp_start = bx.icmp(\n-                                            IntPredicate::IntUGE,\n-                                            llval,\n-                                            enum_value_lower_bound,\n-                                        );\n-                                        bx.assume(cmp_start);\n-                                    }\n-\n-                                    let enum_value_upper_bound = bx\n-                                        .cx()\n-                                        .const_uint_big(ll_t_in, scalar.valid_range(bx.cx()).end);\n-                                    let cmp_end = bx.icmp(\n-                                        IntPredicate::IntULE,\n-                                        llval,\n-                                        enum_value_upper_bound,\n-                                    );\n-                                    bx.assume(cmp_end);\n-                                }\n-                            }\n-                        }\n-\n                         let newval = match (r_t_in, r_t_out) {\n-                            (CastTy::Int(_), CastTy::Int(_)) => bx.intcast(llval, ll_t_out, signed),\n+                            (CastTy::Int(i), CastTy::Int(_)) => {\n+                                bx.intcast(llval, ll_t_out, matches!(i, IntTy::I))\n+                            }\n                             (CastTy::Float, CastTy::Float) => {\n                                 let srcsz = bx.cx().float_width(ll_t_in);\n                                 let dstsz = bx.cx().float_width(ll_t_out);\n@@ -362,8 +299,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     llval\n                                 }\n                             }\n-                            (CastTy::Int(_), CastTy::Float) => {\n-                                if signed {\n+                            (CastTy::Int(i), CastTy::Float) => {\n+                                if matches!(i, IntTy::I) {\n                                     bx.sitofp(llval, ll_t_out)\n                                 } else {\n                                     bx.uitofp(llval, ll_t_out)\n@@ -372,8 +309,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Ptr(_)) => {\n                                 bx.pointercast(llval, ll_t_out)\n                             }\n-                            (CastTy::Int(_), CastTy::Ptr(_)) => {\n-                                let usize_llval = bx.intcast(llval, bx.cx().type_isize(), signed);\n+                            (CastTy::Int(i), CastTy::Ptr(_)) => {\n+                                let usize_llval =\n+                                    bx.intcast(llval, bx.cx().type_isize(), matches!(i, IntTy::I));\n                                 bx.inttoptr(usize_llval, ll_t_out)\n                             }\n                             (CastTy::Float, CastTy::Int(IntTy::I)) => {"}, {"sha": "4835b7969b2047a2eb33040560a54c06071c0f2d", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::mir::CastKind;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::{self, FloatTy, Ty, TypeAndMut};\n-use rustc_target::abi::{Integer, Variants};\n+use rustc_target::abi::Integer;\n use rustc_type_ir::sty::TyKind::*;\n \n use super::{\n@@ -127,12 +127,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Float(FloatTy::F64) => {\n                 return Ok(self.cast_from_float(src.to_scalar()?.to_f64()?, cast_ty).into());\n             }\n-            // The rest is integer/pointer-\"like\", including fn ptr casts and casts from enums that\n-            // are represented as integers.\n+            // The rest is integer/pointer-\"like\", including fn ptr casts\n             _ => assert!(\n                 src.layout.ty.is_bool()\n                     || src.layout.ty.is_char()\n-                    || src.layout.ty.is_enum()\n                     || src.layout.ty.is_integral()\n                     || src.layout.ty.is_any_ptr(),\n                 \"Unexpected cast from type {:?}\",\n@@ -142,25 +140,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         // # First handle non-scalar source values.\n \n-        // Handle cast from a ZST enum (0 or 1 variants).\n-        match src.layout.variants {\n-            Variants::Single { index } => {\n-                if src.layout.abi.is_uninhabited() {\n-                    // This is dead code, because an uninhabited enum is UB to\n-                    // instantiate.\n-                    throw_ub!(Unreachable);\n-                }\n-                if let Some(discr) = src.layout.ty.discriminant_for_variant(*self.tcx, index) {\n-                    assert!(src.layout.is_zst());\n-                    let discr_layout = self.layout_of(discr.ty)?;\n-\n-                    let scalar = Scalar::from_uint(discr.val, discr_layout.layout.size());\n-                    return Ok(self.cast_from_int_like(scalar, discr_layout, cast_ty)?.into());\n-                }\n-            }\n-            Variants::Multiple { .. } => {}\n-        }\n-\n         // Handle casting any ptr to raw ptr (might be a fat ptr).\n         if src.layout.ty.is_any_ptr() && cast_ty.is_unsafe_ptr() {\n             let dest_layout = self.layout_of(cast_ty)?;"}, {"sha": "dce4a68e811b09cfb693e693a3836db632f5fd1b", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -7,9 +7,9 @@ use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n-    traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, Local, Location, MirPass,\n-    MirPhase, Operand, Place, PlaceElem, PlaceRef, ProjectionElem, Rvalue, SourceScope, Statement,\n-    StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n+    traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, CastKind, Local, Location,\n+    MirPass, MirPhase, Operand, Place, PlaceElem, PlaceRef, ProjectionElem, Rvalue, SourceScope,\n+    Statement, StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n };\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable};\n@@ -361,6 +361,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n+            Rvalue::Ref(..) => {}\n             Rvalue::Len(p) => {\n                 let pty = p.ty(&self.body.local_decls, self.tcx).ty;\n                 check_kinds!(\n@@ -503,7 +504,30 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 let a = operand.ty(&self.body.local_decls, self.tcx);\n                 check_kinds!(a, \"Cannot shallow init type {:?}\", ty::RawPtr(..));\n             }\n-            _ => {}\n+            Rvalue::Cast(kind, operand, target_type) => {\n+                match kind {\n+                    CastKind::Misc => {\n+                        let op_ty = operand.ty(self.body, self.tcx);\n+                        if op_ty.is_enum() {\n+                            self.fail(\n+                                location,\n+                                format!(\n+                                    \"enum -> int casts should go through `Rvalue::Discriminant`: {operand:?}:{op_ty} as {target_type}\",\n+                                ),\n+                            );\n+                        }\n+                    }\n+                    // Nothing to check here\n+                    CastKind::PointerFromExposedAddress\n+                    | CastKind::PointerExposeAddress\n+                    | CastKind::Pointer(_) => {}\n+                }\n+            }\n+            Rvalue::Repeat(_, _)\n+            | Rvalue::ThreadLocalRef(_)\n+            | Rvalue::AddressOf(_, _)\n+            | Rvalue::NullaryOp(_, _)\n+            | Rvalue::Discriminant(_) => {}\n         }\n         self.super_rvalue(rvalue, location);\n     }"}, {"sha": "e3a383f86a76ad7f792fa69d0d9f237dc85a87cc", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -1,6 +1,7 @@\n //! See docs in `build/expr/mod.rs`.\n \n use rustc_index::vec::Idx;\n+use rustc_middle::ty::util::IntTypeExt;\n \n use crate::build::expr::as_place::PlaceBase;\n use crate::build::expr::category::{Category, RvalueFunc};\n@@ -190,7 +191,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             ExprKind::Cast { source } => {\n                 let source = &this.thir[source];\n-                let from_ty = CastTy::from_ty(source.ty);\n+\n+                // Casting an enum to an integer is equivalent to computing the discriminant and casting the\n+                // discriminant. Previously every backend had to repeat the logic for this operation. Now we\n+                // create all the steps directly in MIR with operations all backends need to support anyway.\n+                let (source, ty) = if let ty::Adt(adt_def, ..) = source.ty.kind() && adt_def.is_enum() {\n+                    let discr_ty = adt_def.repr().discr_type().to_ty(this.tcx);\n+                    let place = unpack!(block = this.as_place(block, source));\n+                    let discr = this.temp(discr_ty, source.span);\n+                    this.cfg.push_assign(\n+                        block,\n+                        source_info,\n+                        discr,\n+                        Rvalue::Discriminant(place),\n+                    );\n+\n+                    (Operand::Move(discr), discr_ty)\n+                } else {\n+                    let ty = source.ty;\n+                    let source = unpack!(\n+                        block = this.as_operand(block, scope, source, None, NeedsTemporary::No)\n+                    );\n+                    (source, ty)\n+                };\n+                let from_ty = CastTy::from_ty(ty);\n                 let cast_ty = CastTy::from_ty(expr.ty);\n                 let cast_kind = match (from_ty, cast_ty) {\n                     (Some(CastTy::Ptr(_) | CastTy::FnPtr), Some(CastTy::Int(_))) => {\n@@ -201,9 +225,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                     (_, _) => CastKind::Misc,\n                 };\n-                let source = unpack!(\n-                    block = this.as_operand(block, scope, source, None, NeedsTemporary::No)\n-                );\n                 block.and(Rvalue::Cast(cast_kind, source, expr.ty))\n             }\n             ExprKind::Pointer { cast, source } => {"}, {"sha": "fe02aeb5f6252924ce56820ea011e3b39287eb2d", "filename": "src/test/codegen/enum-bounds-check-derived-idx.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fcodegen%2Fenum-bounds-check-derived-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fcodegen%2Fenum-bounds-check-derived-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check-derived-idx.rs?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -12,13 +12,15 @@ pub enum Bar {\n // CHECK-LABEL: @lookup_inc\n #[no_mangle]\n pub fn lookup_inc(buf: &[u8; 5], f: Bar) -> u8 {\n-    // CHECK-NOT: panic_bounds_check\n+    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n+    // CHECK: panic_bounds_check\n     buf[f as usize + 1]\n }\n \n // CHECK-LABEL: @lookup_dec\n #[no_mangle]\n pub fn lookup_dec(buf: &[u8; 5], f: Bar) -> u8 {\n-    // CHECK-NOT: panic_bounds_check\n+    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n+    // CHECK: panic_bounds_check\n     buf[f as usize - 1]\n }"}, {"sha": "1aec41d54411b267f82847754d25419e64a77de9", "filename": "src/test/codegen/enum-bounds-check-issue-13926.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-13926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-13926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-13926.rs?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -13,6 +13,7 @@ pub enum Exception {\n // CHECK-LABEL: @access\n #[no_mangle]\n pub fn access(array: &[usize; 12], exc: Exception) -> usize {\n-    // CHECK-NOT: panic_bounds_check\n+    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n+    // CHECK: panic_bounds_check\n     array[(exc as u8 - 4) as usize]\n }"}, {"sha": "32fdc4a5f4fab96d020626640c495e6871abe95e", "filename": "src/test/codegen/enum-bounds-check-issue-82871.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-82871.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-82871.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-82871.rs?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -O\n+// compile-flags: -C opt-level=0\n \n #![crate_type = \"lib\"]\n \n@@ -9,7 +9,10 @@ pub enum E {\n \n // CHECK-LABEL: @index\n #[no_mangle]\n-pub fn index(x: &[u32; 3], ind: E) -> u32{\n-    // CHECK-NOT: panic_bounds_check\n+pub fn index(x: &[u32; 3], ind: E) -> u32 {\n+    // Canary: we should be able to optimize out the bounds check, but we need\n+    // to track the range of the discriminant result in order to be able to do that.\n+    // oli-obk tried to add that, but that caused miscompilations all over the place.\n+    // CHECK: panic_bounds_check\n     x[ind as usize]\n }"}, {"sha": "f85c6817deda3417ec7295137dca12e71d2fed43", "filename": "src/test/codegen/enum-bounds-check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -21,6 +21,7 @@ pub enum Bar {\n // CHECK-LABEL: @lookup_unmodified\n #[no_mangle]\n pub fn lookup_unmodified(buf: &[u8; 5], f: Bar) -> u8 {\n-    // CHECK-NOT: panic_bounds_check\n+    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n+    // CHECK: panic_bounds_check\n     buf[f as usize]\n }"}, {"sha": "1b4a469135cb6d5fa7945006b97a13226a77f305", "filename": "src/test/mir-opt/enum_cast.bar.mir_map.0.mir", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fmir-opt%2Fenum_cast.bar.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fmir-opt%2Fenum_cast.bar.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fenum_cast.bar.mir_map.0.mir?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -0,0 +1,13 @@\n+// MIR for `bar` 0 mir_map\n+\n+fn bar(_1: Bar) -> usize {\n+    debug bar => _1;                     // in scope 0 at $DIR/enum_cast.rs:22:8: 22:11\n+    let mut _0: usize;                   // return place in scope 0 at $DIR/enum_cast.rs:22:21: 22:26\n+    let mut _2: isize;                   // in scope 0 at $DIR/enum_cast.rs:23:5: 23:8\n+\n+    bb0: {\n+        _2 = discriminant(_1);           // scope 0 at $DIR/enum_cast.rs:23:5: 23:17\n+        _0 = move _2 as usize (Misc);    // scope 0 at $DIR/enum_cast.rs:23:5: 23:17\n+        return;                          // scope 0 at $DIR/enum_cast.rs:24:2: 24:2\n+    }\n+}"}, {"sha": "7724e89a22854965ab1ad2b4ca30d1e09ad5ecf6", "filename": "src/test/mir-opt/enum_cast.boo.mir_map.0.mir", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fmir-opt%2Fenum_cast.boo.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fmir-opt%2Fenum_cast.boo.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fenum_cast.boo.mir_map.0.mir?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -0,0 +1,13 @@\n+// MIR for `boo` 0 mir_map\n+\n+fn boo(_1: Boo) -> usize {\n+    debug boo => _1;                     // in scope 0 at $DIR/enum_cast.rs:26:8: 26:11\n+    let mut _0: usize;                   // return place in scope 0 at $DIR/enum_cast.rs:26:21: 26:26\n+    let mut _2: u8;                      // in scope 0 at $DIR/enum_cast.rs:27:5: 27:8\n+\n+    bb0: {\n+        _2 = discriminant(_1);           // scope 0 at $DIR/enum_cast.rs:27:5: 27:17\n+        _0 = move _2 as usize (Misc);    // scope 0 at $DIR/enum_cast.rs:27:5: 27:17\n+        return;                          // scope 0 at $DIR/enum_cast.rs:28:2: 28:2\n+    }\n+}"}, {"sha": "a9dcfadae75c716c37ebc749d1f4d83d66958ffd", "filename": "src/test/mir-opt/enum_cast.droppy.mir_map.0.mir", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fmir-opt%2Fenum_cast.droppy.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fmir-opt%2Fenum_cast.droppy.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fenum_cast.droppy.mir_map.0.mir?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -0,0 +1,54 @@\n+// MIR for `droppy` 0 mir_map\n+\n+fn droppy() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/enum_cast.rs:39:13: 39:13\n+    let _1: ();                          // in scope 0 at $DIR/enum_cast.rs:40:5: 45:6\n+    let _2: Droppy;                      // in scope 0 at $DIR/enum_cast.rs:41:13: 41:14\n+    let mut _4: isize;                   // in scope 0 at $DIR/enum_cast.rs:44:17: 44:18\n+    let _5: Droppy;                      // in scope 0 at $DIR/enum_cast.rs:46:9: 46:10\n+    scope 1 {\n+        debug x => _2;                   // in scope 1 at $DIR/enum_cast.rs:41:13: 41:14\n+        scope 2 {\n+            debug y => _3;               // in scope 2 at $DIR/enum_cast.rs:44:13: 44:14\n+        }\n+        scope 3 {\n+            let _3: usize;               // in scope 3 at $DIR/enum_cast.rs:44:13: 44:14\n+        }\n+    }\n+    scope 4 {\n+        debug z => _5;                   // in scope 4 at $DIR/enum_cast.rs:46:9: 46:10\n+    }\n+\n+    bb0: {\n+        StorageLive(_1);                 // scope 0 at $DIR/enum_cast.rs:40:5: 45:6\n+        StorageLive(_2);                 // scope 0 at $DIR/enum_cast.rs:41:13: 41:14\n+        _2 = Droppy::C;                  // scope 0 at $DIR/enum_cast.rs:41:17: 41:26\n+        FakeRead(ForLet(None), _2);      // scope 0 at $DIR/enum_cast.rs:41:13: 41:14\n+        StorageLive(_3);                 // scope 3 at $DIR/enum_cast.rs:44:13: 44:14\n+        _4 = discriminant(_2);           // scope 3 at $DIR/enum_cast.rs:44:17: 44:27\n+        _3 = move _4 as usize (Misc);    // scope 3 at $DIR/enum_cast.rs:44:17: 44:27\n+        FakeRead(ForLet(None), _3);      // scope 3 at $DIR/enum_cast.rs:44:13: 44:14\n+        _1 = const ();                   // scope 0 at $DIR/enum_cast.rs:40:5: 45:6\n+        StorageDead(_3);                 // scope 1 at $DIR/enum_cast.rs:45:5: 45:6\n+        drop(_2) -> [return: bb1, unwind: bb3]; // scope 0 at $DIR/enum_cast.rs:45:5: 45:6\n+    }\n+\n+    bb1: {\n+        StorageDead(_2);                 // scope 0 at $DIR/enum_cast.rs:45:5: 45:6\n+        StorageDead(_1);                 // scope 0 at $DIR/enum_cast.rs:45:5: 45:6\n+        StorageLive(_5);                 // scope 0 at $DIR/enum_cast.rs:46:9: 46:10\n+        _5 = Droppy::B;                  // scope 0 at $DIR/enum_cast.rs:46:13: 46:22\n+        FakeRead(ForLet(None), _5);      // scope 0 at $DIR/enum_cast.rs:46:9: 46:10\n+        _0 = const ();                   // scope 0 at $DIR/enum_cast.rs:39:13: 47:2\n+        drop(_5) -> [return: bb2, unwind: bb3]; // scope 0 at $DIR/enum_cast.rs:47:1: 47:2\n+    }\n+\n+    bb2: {\n+        StorageDead(_5);                 // scope 0 at $DIR/enum_cast.rs:47:1: 47:2\n+        return;                          // scope 0 at $DIR/enum_cast.rs:47:2: 47:2\n+    }\n+\n+    bb3 (cleanup): {\n+        resume;                          // scope 0 at $DIR/enum_cast.rs:39:1: 47:2\n+    }\n+}"}, {"sha": "d89dc9519239bc90fcee553c1715eb58e7cf3274", "filename": "src/test/mir-opt/enum_cast.foo.mir_map.0.mir", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fmir-opt%2Fenum_cast.foo.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fmir-opt%2Fenum_cast.foo.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fenum_cast.foo.mir_map.0.mir?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -0,0 +1,13 @@\n+// MIR for `foo` 0 mir_map\n+\n+fn foo(_1: Foo) -> usize {\n+    debug foo => _1;                     // in scope 0 at $DIR/enum_cast.rs:18:8: 18:11\n+    let mut _0: usize;                   // return place in scope 0 at $DIR/enum_cast.rs:18:21: 18:26\n+    let mut _2: isize;                   // in scope 0 at $DIR/enum_cast.rs:19:5: 19:8\n+\n+    bb0: {\n+        _2 = discriminant(_1);           // scope 0 at $DIR/enum_cast.rs:19:5: 19:17\n+        _0 = move _2 as usize (Misc);    // scope 0 at $DIR/enum_cast.rs:19:5: 19:17\n+        return;                          // scope 0 at $DIR/enum_cast.rs:20:2: 20:2\n+    }\n+}"}, {"sha": "090142aaf3559ae4c0b111992c0b98f44dc0ffb2", "filename": "src/test/mir-opt/enum_cast.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fmir-opt%2Fenum_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Fmir-opt%2Fenum_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fenum_cast.rs?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -0,0 +1,50 @@\n+// EMIT_MIR enum_cast.foo.mir_map.0.mir\n+// EMIT_MIR enum_cast.bar.mir_map.0.mir\n+// EMIT_MIR enum_cast.boo.mir_map.0.mir\n+\n+enum Foo {\n+    A\n+}\n+\n+enum Bar {\n+    A, B\n+}\n+\n+#[repr(u8)]\n+enum Boo {\n+    A, B\n+}\n+\n+fn foo(foo: Foo) -> usize {\n+    foo as usize\n+}\n+\n+fn bar(bar: Bar) -> usize {\n+    bar as usize\n+}\n+\n+fn boo(boo: Boo) -> usize {\n+    boo as usize\n+}\n+\n+// EMIT_MIR enum_cast.droppy.mir_map.0.mir\n+enum Droppy {\n+    A, B, C\n+}\n+\n+impl Drop for Droppy {\n+    fn drop(&mut self) {}\n+}\n+\n+fn droppy() {\n+    {\n+        let x = Droppy::C;\n+        // remove this entire test once `cenum_impl_drop_cast` becomes a hard error\n+        #[allow(cenum_impl_drop_cast)]\n+        let y = x as usize;\n+    }\n+    let z = Droppy::B;\n+}\n+\n+fn main() {\n+}"}, {"sha": "f29bc50e84c4ea36322de62068f6d88dac3424e5", "filename": "src/test/run-pass-valgrind/cast-enum-with-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7839cb963f747edff90b72efc6094e7184f6ef0e/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs?ref=7839cb963f747edff90b72efc6094e7184f6ef0e", "patch": "@@ -30,5 +30,5 @@ fn main() {\n         assert_eq!(e as u32, 2);\n         assert_eq!(FLAG.load(Ordering::SeqCst), 0);\n     }\n-    assert_eq!(FLAG.load(Ordering::SeqCst), 0);\n+    assert_eq!(FLAG.load(Ordering::SeqCst), 1);\n }"}]}