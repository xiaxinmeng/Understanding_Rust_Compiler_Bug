{"sha": "a18b34d9793a88142c122f83fe53683f58f26ecc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExOGIzNGQ5NzkzYTg4MTQyYzEyMmY4M2ZlNTM2ODNmNThmMjZlY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-10T08:07:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-10T08:07:48Z"}, "message": "Auto merge of #76291 - matklad:spacing, r=petrochenkov\n\nRename IsJoint -> Spacing\n\nBuilds on #76286 and might conflict with #76285\n\nr? `@petrochenkov`", "tree": {"sha": "439016049345e2ac5cb2cf79064161fff6e8e0db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/439016049345e2ac5cb2cf79064161fff6e8e0db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a18b34d9793a88142c122f83fe53683f58f26ecc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a18b34d9793a88142c122f83fe53683f58f26ecc", "html_url": "https://github.com/rust-lang/rust/commit/a18b34d9793a88142c122f83fe53683f58f26ecc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a18b34d9793a88142c122f83fe53683f58f26ecc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88197214b8a9099bb3da559a3bd7bf4867c10c5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/88197214b8a9099bb3da559a3bd7bf4867c10c5f", "html_url": "https://github.com/rust-lang/rust/commit/88197214b8a9099bb3da559a3bd7bf4867c10c5f"}, {"sha": "ccf41dd5eb42730b1de6a4bc9d95c03dca0a8143", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccf41dd5eb42730b1de6a4bc9d95c03dca0a8143", "html_url": "https://github.com/rust-lang/rust/commit/ccf41dd5eb42730b1de6a4bc9d95c03dca0a8143"}], "stats": {"total": 183, "additions": 86, "deletions": 97}, "files": [{"sha": "d819e3cb8152e9862d3706ac2f2fca88b836771f", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=a18b34d9793a88142c122f83fe53683f58f26ecc", "patch": "@@ -8,7 +8,7 @@ use crate::ast::{Path, PathSegment};\n use crate::mut_visit::visit_clobber;\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Token};\n-use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n+use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndSpacing};\n \n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::source_map::{BytePos, Spanned};\n@@ -361,7 +361,7 @@ pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n }\n \n impl MetaItem {\n-    fn token_trees_and_joints(&self) -> Vec<TreeAndJoint> {\n+    fn token_trees_and_spacings(&self) -> Vec<TreeAndSpacing> {\n         let mut idents = vec![];\n         let mut last_pos = BytePos(0 as u32);\n         for (i, segment) in self.path.segments.iter().enumerate() {\n@@ -374,7 +374,7 @@ impl MetaItem {\n             idents.push(TokenTree::Token(Token::from_ast_ident(segment.ident)).into());\n             last_pos = segment.ident.span.hi();\n         }\n-        idents.extend(self.kind.token_trees_and_joints(self.span));\n+        idents.extend(self.kind.token_trees_and_spacings(self.span));\n         idents\n     }\n \n@@ -447,7 +447,7 @@ impl MetaItemKind {\n                     if i > 0 {\n                         tts.push(TokenTree::token(token::Comma, span).into());\n                     }\n-                    tts.extend(item.token_trees_and_joints())\n+                    tts.extend(item.token_trees_and_spacings())\n                 }\n                 MacArgs::Delimited(\n                     DelimSpan::from_single(span),\n@@ -458,7 +458,7 @@ impl MetaItemKind {\n         }\n     }\n \n-    fn token_trees_and_joints(&self, span: Span) -> Vec<TreeAndJoint> {\n+    fn token_trees_and_spacings(&self, span: Span) -> Vec<TreeAndSpacing> {\n         match *self {\n             MetaItemKind::Word => vec![],\n             MetaItemKind::NameValue(ref lit) => {\n@@ -470,7 +470,7 @@ impl MetaItemKind {\n                     if i > 0 {\n                         tokens.push(TokenTree::token(token::Comma, span).into());\n                     }\n-                    tokens.extend(item.token_trees_and_joints())\n+                    tokens.extend(item.token_trees_and_spacings())\n                 }\n                 vec![\n                     TokenTree::Delimited(\n@@ -553,9 +553,9 @@ impl NestedMetaItem {\n         }\n     }\n \n-    fn token_trees_and_joints(&self) -> Vec<TreeAndJoint> {\n+    fn token_trees_and_spacings(&self) -> Vec<TreeAndSpacing> {\n         match *self {\n-            NestedMetaItem::MetaItem(ref item) => item.token_trees_and_joints(),\n+            NestedMetaItem::MetaItem(ref item) => item.token_trees_and_spacings(),\n             NestedMetaItem::Literal(ref lit) => vec![lit.token_tree().into()],\n         }\n     }"}, {"sha": "f201f0b5c66430ebe4d6b89c50d943e804600377", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=a18b34d9793a88142c122f83fe53683f58f26ecc", "patch": "@@ -83,7 +83,7 @@ impl TokenTree {\n     }\n \n     pub fn joint(self) -> TokenStream {\n-        TokenStream::new(vec![(self, Joint)])\n+        TokenStream::new(vec![(self, Spacing::Joint)])\n     }\n \n     pub fn token(kind: TokenKind, span: Span) -> TokenTree {\n@@ -125,22 +125,20 @@ where\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `token::Interpolated` for back-compat.\n #[derive(Clone, Debug, Default, Encodable, Decodable)]\n-pub struct TokenStream(pub Lrc<Vec<TreeAndJoint>>);\n+pub struct TokenStream(pub Lrc<Vec<TreeAndSpacing>>);\n \n-pub type TreeAndJoint = (TokenTree, IsJoint);\n+pub type TreeAndSpacing = (TokenTree, Spacing);\n \n // `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(TokenStream, 8);\n \n #[derive(Clone, Copy, Debug, PartialEq, Encodable, Decodable)]\n-pub enum IsJoint {\n+pub enum Spacing {\n+    Alone,\n     Joint,\n-    NonJoint,\n }\n \n-use IsJoint::*;\n-\n impl TokenStream {\n     /// Given a `TokenStream` with a `Stream` of only two arguments, return a new `TokenStream`\n     /// separating the two arguments with a comma for diagnostic suggestions.\n@@ -153,7 +151,7 @@ impl TokenStream {\n                 let sp = match (&ts, &next) {\n                     (_, (TokenTree::Token(Token { kind: token::Comma, .. }), _)) => continue,\n                     (\n-                        (TokenTree::Token(token_left), NonJoint),\n+                        (TokenTree::Token(token_left), Spacing::Alone),\n                         (TokenTree::Token(token_right), _),\n                     ) if ((token_left.is_ident() && !token_left.is_reserved_ident())\n                         || token_left.is_lit())\n@@ -162,11 +160,11 @@ impl TokenStream {\n                     {\n                         token_left.span\n                     }\n-                    ((TokenTree::Delimited(sp, ..), NonJoint), _) => sp.entire(),\n+                    ((TokenTree::Delimited(sp, ..), Spacing::Alone), _) => sp.entire(),\n                     _ => continue,\n                 };\n                 let sp = sp.shrink_to_hi();\n-                let comma = (TokenTree::token(token::Comma, sp), NonJoint);\n+                let comma = (TokenTree::token(token::Comma, sp), Spacing::Alone);\n                 suggestion = Some((pos, comma, sp));\n             }\n         }\n@@ -184,19 +182,19 @@ impl TokenStream {\n \n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream::new(vec![(tree, NonJoint)])\n+        TokenStream::new(vec![(tree, Spacing::Alone)])\n     }\n }\n \n-impl From<TokenTree> for TreeAndJoint {\n-    fn from(tree: TokenTree) -> TreeAndJoint {\n-        (tree, NonJoint)\n+impl From<TokenTree> for TreeAndSpacing {\n+    fn from(tree: TokenTree) -> TreeAndSpacing {\n+        (tree, Spacing::Alone)\n     }\n }\n \n impl iter::FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(iter: I) -> Self {\n-        TokenStream::new(iter.into_iter().map(Into::into).collect::<Vec<TreeAndJoint>>())\n+        TokenStream::new(iter.into_iter().map(Into::into).collect::<Vec<TreeAndSpacing>>())\n     }\n }\n \n@@ -209,7 +207,7 @@ impl PartialEq<TokenStream> for TokenStream {\n }\n \n impl TokenStream {\n-    pub fn new(streams: Vec<TreeAndJoint>) -> TokenStream {\n+    pub fn new(streams: Vec<TreeAndSpacing>) -> TokenStream {\n         TokenStream(Lrc::new(streams))\n     }\n \n@@ -320,11 +318,11 @@ impl TokenStreamBuilder {\n         // If `self` is not empty and the last tree within the last stream is a\n         // token tree marked with `Joint`...\n         if let Some(TokenStream(ref mut last_stream_lrc)) = self.0.last_mut() {\n-            if let Some((TokenTree::Token(last_token), Joint)) = last_stream_lrc.last() {\n+            if let Some((TokenTree::Token(last_token), Spacing::Joint)) = last_stream_lrc.last() {\n                 // ...and `stream` is not empty and the first tree within it is\n                 // a token tree...\n                 let TokenStream(ref mut stream_lrc) = stream;\n-                if let Some((TokenTree::Token(token), is_joint)) = stream_lrc.first() {\n+                if let Some((TokenTree::Token(token), spacing)) = stream_lrc.first() {\n                     // ...and the two tokens can be glued together...\n                     if let Some(glued_tok) = last_token.glue(&token) {\n                         // ...then do so, by overwriting the last token\n@@ -337,8 +335,7 @@ impl TokenStreamBuilder {\n                         // Overwrite the last token tree with the merged\n                         // token.\n                         let last_vec_mut = Lrc::make_mut(last_stream_lrc);\n-                        *last_vec_mut.last_mut().unwrap() =\n-                            (TokenTree::Token(glued_tok), *is_joint);\n+                        *last_vec_mut.last_mut().unwrap() = (TokenTree::Token(glued_tok), *spacing);\n \n                         // Remove the first token tree from `stream`. (This\n                         // is almost always the only tree in `stream`.)\n@@ -375,7 +372,7 @@ impl Iterator for Cursor {\n     type Item = TokenTree;\n \n     fn next(&mut self) -> Option<TokenTree> {\n-        self.next_with_joint().map(|(tree, _)| tree)\n+        self.next_with_spacing().map(|(tree, _)| tree)\n     }\n }\n \n@@ -384,7 +381,7 @@ impl Cursor {\n         Cursor { stream, index: 0 }\n     }\n \n-    pub fn next_with_joint(&mut self) -> Option<TreeAndJoint> {\n+    pub fn next_with_spacing(&mut self) -> Option<TreeAndSpacing> {\n         if self.index < self.stream.len() {\n             self.index += 1;\n             Some(self.stream.0[self.index - 1].clone())"}, {"sha": "0e5c5fe4d447394f4708f566edc2853dfdbbbc1a", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=a18b34d9793a88142c122f83fe53683f58f26ecc", "patch": "@@ -4,7 +4,7 @@ use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n \n use rustc_ast::mut_visit::{self, MutVisitor};\n use rustc_ast::token::{self, NtTT, Token};\n-use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n+use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndSpacing};\n use rustc_ast::MacCall;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -111,7 +111,7 @@ pub(super) fn transcribe<'a>(\n     //\n     // Thus, if we try to pop the `result_stack` and it is empty, we have reached the top-level\n     // again, and we are done transcribing.\n-    let mut result: Vec<TreeAndJoint> = Vec::new();\n+    let mut result: Vec<TreeAndSpacing> = Vec::new();\n     let mut result_stack = Vec::new();\n     let mut marker = Marker(cx.current_expansion.id, transparency);\n "}, {"sha": "ec41fd7a3eebe90132d9982db5b8c74f34b21b38", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=a18b34d9793a88142c122f83fe53683f58f26ecc", "patch": "@@ -2,7 +2,7 @@ use crate::base::ExtCtxt;\n \n use rustc_ast as ast;\n use rustc_ast::token;\n-use rustc_ast::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n+use rustc_ast::tokenstream::{self, DelimSpan, Spacing::*, TokenStream, TreeAndSpacing};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::Diagnostic;\n@@ -47,15 +47,15 @@ impl ToInternal<token::DelimToken> for Delimiter {\n     }\n }\n \n-impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n+impl FromInternal<(TreeAndSpacing, &'_ ParseSess, &'_ mut Vec<Self>)>\n     for TokenTree<Group, Punct, Ident, Literal>\n {\n     fn from_internal(\n-        ((tree, is_joint), sess, stack): (TreeAndJoint, &ParseSess, &mut Vec<Self>),\n+        ((tree, spacing), sess, stack): (TreeAndSpacing, &ParseSess, &mut Vec<Self>),\n     ) -> Self {\n         use rustc_ast::token::*;\n \n-        let joint = is_joint == Joint;\n+        let joint = spacing == Joint;\n         let Token { kind, span } = match tree {\n             tokenstream::TokenTree::Delimited(span, delim, tts) => {\n                 let delimiter = Delimiter::from_internal(delim);\n@@ -261,7 +261,7 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n         };\n \n         let tree = tokenstream::TokenTree::token(kind, span);\n-        TokenStream::new(vec![(tree, if joint { Joint } else { NonJoint })])\n+        TokenStream::new(vec![(tree, if joint { Joint } else { Alone })])\n     }\n }\n \n@@ -444,7 +444,7 @@ impl server::TokenStreamIter for Rustc<'_> {\n     ) -> Option<TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n         loop {\n             let tree = iter.stack.pop().or_else(|| {\n-                let next = iter.cursor.next_with_joint()?;\n+                let next = iter.cursor.next_with_spacing()?;\n                 Some(TokenTree::from_internal((next, self.sess, &mut iter.stack)))\n             })?;\n             // A hack used to pass AST fragments to attribute and derive macros"}, {"sha": "32b124970cf7c72e0fe30841c053192cb9946928", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=a18b34d9793a88142c122f83fe53683f58f26ecc", "patch": "@@ -1,22 +1,19 @@\n use rustc_ast::ast::AttrStyle;\n use rustc_ast::token::{self, CommentKind, Token, TokenKind};\n-use rustc_ast::tokenstream::IsJoint;\n-use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{error_code, Applicability, DiagnosticBuilder, FatalError};\n-use rustc_lexer::Base;\n-use rustc_lexer::{unescape, RawStrError};\n+use rustc_ast::tokenstream::{Spacing, TokenStream};\n+use rustc_errors::{error_code, Applicability, DiagnosticBuilder, FatalError, PResult};\n+use rustc_lexer::unescape::{self, Mode};\n+use rustc_lexer::{Base, DocStyle, RawStrError};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Pos, Span};\n \n-use std::char;\n use tracing::debug;\n \n mod tokentrees;\n mod unescape_error_reporting;\n mod unicode_chars;\n \n-use rustc_lexer::{unescape::Mode, DocStyle};\n use unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n #[derive(Clone, Debug)]\n@@ -28,7 +25,17 @@ pub struct UnmatchedBrace {\n     pub candidate_span: Option<Span>,\n }\n \n-crate struct StringReader<'a> {\n+crate fn parse_token_trees<'a>(\n+    sess: &'a ParseSess,\n+    src: &'a str,\n+    start_pos: BytePos,\n+    override_span: Option<Span>,\n+) -> (PResult<'a, TokenStream>, Vec<UnmatchedBrace>) {\n+    StringReader { sess, start_pos, pos: start_pos, end_src_index: src.len(), src, override_span }\n+        .into_token_trees()\n+}\n+\n+struct StringReader<'a> {\n     sess: &'a ParseSess,\n     /// Initial position, read-only.\n     start_pos: BytePos,\n@@ -37,38 +44,18 @@ crate struct StringReader<'a> {\n     /// Stop reading src at this index.\n     end_src_index: usize,\n     /// Source text to tokenize.\n-    src: Lrc<String>,\n+    src: &'a str,\n     override_span: Option<Span>,\n }\n \n impl<'a> StringReader<'a> {\n-    crate fn new(\n-        sess: &'a ParseSess,\n-        source_file: Lrc<rustc_span::SourceFile>,\n-        override_span: Option<Span>,\n-    ) -> Self {\n-        let src = source_file.src.clone().unwrap_or_else(|| {\n-            sess.span_diagnostic\n-                .bug(&format!(\"cannot lex `source_file` without source: {}\", source_file.name));\n-        });\n-\n-        StringReader {\n-            sess,\n-            start_pos: source_file.start_pos,\n-            pos: source_file.start_pos,\n-            end_src_index: src.len(),\n-            src,\n-            override_span,\n-        }\n-    }\n-\n     fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {\n         self.override_span.unwrap_or_else(|| Span::with_root_ctxt(lo, hi))\n     }\n \n     /// Returns the next token, and info about preceding whitespace, if any.\n-    fn next_token(&mut self) -> (IsJoint, Token) {\n-        let mut is_joint = IsJoint::Joint;\n+    fn next_token(&mut self) -> (Spacing, Token) {\n+        let mut spacing = Spacing::Joint;\n \n         // Skip `#!` at the start of the file\n         let start_src_index = self.src_index(self.pos);\n@@ -77,7 +64,7 @@ impl<'a> StringReader<'a> {\n         if is_beginning_of_file {\n             if let Some(shebang_len) = rustc_lexer::strip_shebang(text) {\n                 self.pos = self.pos + BytePos::from_usize(shebang_len);\n-                is_joint = IsJoint::NonJoint;\n+                spacing = Spacing::Alone;\n             }\n         }\n \n@@ -88,7 +75,7 @@ impl<'a> StringReader<'a> {\n \n             if text.is_empty() {\n                 let span = self.mk_sp(self.pos, self.pos);\n-                return (is_joint, Token::new(token::Eof, span));\n+                return (spacing, Token::new(token::Eof, span));\n             }\n \n             let token = rustc_lexer::first_token(text);\n@@ -101,9 +88,9 @@ impl<'a> StringReader<'a> {\n             match self.cook_lexer_token(token.kind, start) {\n                 Some(kind) => {\n                     let span = self.mk_sp(start, self.pos);\n-                    return (is_joint, Token::new(kind, span));\n+                    return (spacing, Token::new(kind, span));\n                 }\n-                None => is_joint = IsJoint::NonJoint,\n+                None => spacing = Spacing::Alone,\n             }\n         }\n     }"}, {"sha": "0f364bffb134ec31d83031398a7dd5bb1687ffd0", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=a18b34d9793a88142c122f83fe53683f58f26ecc", "patch": "@@ -3,16 +3,16 @@ use super::{StringReader, UnmatchedBrace};\n use rustc_ast::token::{self, DelimToken, Token};\n use rustc_ast::tokenstream::{\n     DelimSpan,\n-    IsJoint::{self, *},\n-    TokenStream, TokenTree, TreeAndJoint,\n+    Spacing::{self, *},\n+    TokenStream, TokenTree, TreeAndSpacing,\n };\n use rustc_ast_pretty::pprust::token_to_string;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::PResult;\n use rustc_span::Span;\n \n impl<'a> StringReader<'a> {\n-    crate fn into_token_trees(self) -> (PResult<'a, TokenStream>, Vec<UnmatchedBrace>) {\n+    pub(super) fn into_token_trees(self) -> (PResult<'a, TokenStream>, Vec<UnmatchedBrace>) {\n         let mut tt_reader = TokenTreesReader {\n             string_reader: self,\n             token: Token::dummy(),\n@@ -77,7 +77,7 @@ impl<'a> TokenTreesReader<'a> {\n         }\n     }\n \n-    fn parse_token_tree(&mut self) -> PResult<'a, TreeAndJoint> {\n+    fn parse_token_tree(&mut self) -> PResult<'a, TreeAndSpacing> {\n         let sm = self.string_reader.sess.source_map();\n \n         match self.token.kind {\n@@ -262,29 +262,29 @@ impl<'a> TokenTreesReader<'a> {\n             }\n             _ => {\n                 let tt = TokenTree::Token(self.token.take());\n-                let mut is_joint = self.bump();\n+                let mut spacing = self.bump();\n                 if !self.token.is_op() {\n-                    is_joint = NonJoint;\n+                    spacing = Alone;\n                 }\n-                Ok((tt, is_joint))\n+                Ok((tt, spacing))\n             }\n         }\n     }\n \n-    fn bump(&mut self) -> IsJoint {\n-        let (joint_to_prev, token) = self.string_reader.next_token();\n+    fn bump(&mut self) -> Spacing {\n+        let (spacing, token) = self.string_reader.next_token();\n         self.token = token;\n-        joint_to_prev\n+        spacing\n     }\n }\n \n #[derive(Default)]\n struct TokenStreamBuilder {\n-    buf: Vec<TreeAndJoint>,\n+    buf: Vec<TreeAndSpacing>,\n }\n \n impl TokenStreamBuilder {\n-    fn push(&mut self, (tree, joint): TreeAndJoint) {\n+    fn push(&mut self, (tree, joint): TreeAndSpacing) {\n         if let Some((TokenTree::Token(prev_token), Joint)) = self.buf.last() {\n             if let TokenTree::Token(token) = &tree {\n                 if let Some(glued) = prev_token.glue(token) {"}, {"sha": "40e2e34aa05892980a1ccec354932da9bb295119", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=a18b34d9793a88142c122f83fe53683f58f26ecc", "patch": "@@ -332,7 +332,7 @@ const ASCII_ARRAY: &[(char, &str, Option<token::TokenKind>)] = &[\n     ('\"', \"Quotation Mark\", None),\n ];\n \n-crate fn check_for_substitution<'a>(\n+pub(super) fn check_for_substitution<'a>(\n     reader: &StringReader<'a>,\n     pos: BytePos,\n     ch: char,"}, {"sha": "e7fd74f551aaaa484e8b26bbae38745091e69e66", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=a18b34d9793a88142c122f83fe53683f58f26ecc", "patch": "@@ -8,7 +8,7 @@\n \n use rustc_ast as ast;\n use rustc_ast::token::{self, DelimToken, Nonterminal, Token, TokenKind};\n-use rustc_ast::tokenstream::{self, IsJoint, TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{self, Spacing, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n@@ -200,8 +200,13 @@ pub fn maybe_file_to_stream(\n     source_file: Lrc<SourceFile>,\n     override_span: Option<Span>,\n ) -> Result<(TokenStream, Vec<lexer::UnmatchedBrace>), Vec<Diagnostic>> {\n-    let srdr = lexer::StringReader::new(sess, source_file, override_span);\n-    let (token_trees, unmatched_braces) = srdr.into_token_trees();\n+    let src = source_file.src.as_ref().unwrap_or_else(|| {\n+        sess.span_diagnostic\n+            .bug(&format!(\"cannot lex `source_file` without source: {}\", source_file.name));\n+    });\n+\n+    let (token_trees, unmatched_braces) =\n+        lexer::parse_token_trees(sess, src.as_str(), source_file.start_pos, override_span);\n \n     match token_trees {\n         Ok(stream) => Ok((stream, unmatched_braces)),\n@@ -432,7 +437,7 @@ pub fn tokenstream_probably_equal_for_proc_macro(\n             // issue #75734 tracks resolving this.\n             nt_to_tokenstream(nt, sess, *span).into_trees()\n         } else {\n-            TokenStream::new(vec![(tree, IsJoint::NonJoint)]).into_trees()\n+            TokenStream::new(vec![(tree, Spacing::Alone)]).into_trees()\n         }\n     };\n "}, {"sha": "d22d08cd14438225b015a52c9808688d6a6614c5", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a18b34d9793a88142c122f83fe53683f58f26ecc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=a18b34d9793a88142c122f83fe53683f58f26ecc", "patch": "@@ -15,7 +15,7 @@ pub use path::PathStyle;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, DelimToken, Token, TokenKind};\n-use rustc_ast::tokenstream::{self, DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n+use rustc_ast::tokenstream::{self, DelimSpan, TokenStream, TokenTree, TreeAndSpacing};\n use rustc_ast::DUMMY_NODE_ID;\n use rustc_ast::{self as ast, AttrStyle, AttrVec, Const, CrateSugar, Extern, Unsafe};\n use rustc_ast::{Async, MacArgs, MacDelimiter, Mutability, StrLit, Visibility, VisibilityKind};\n@@ -118,7 +118,7 @@ impl<'a> Drop for Parser<'a> {\n struct TokenCursor {\n     frame: TokenCursorFrame,\n     stack: Vec<TokenCursorFrame>,\n-    cur_token: Option<TreeAndJoint>,\n+    cur_token: Option<TreeAndSpacing>,\n     collecting: Option<Collecting>,\n }\n \n@@ -136,7 +136,7 @@ struct TokenCursorFrame {\n struct Collecting {\n     /// Holds the current tokens captured during the most\n     /// recent call to `collect_tokens`\n-    buf: Vec<TreeAndJoint>,\n+    buf: Vec<TreeAndSpacing>,\n     /// The depth of the `TokenCursor` stack at the time\n     /// collection was started. When we encounter a `TokenTree::Delimited`,\n     /// we want to record the `TokenTree::Delimited` itself,\n@@ -167,7 +167,7 @@ impl TokenCursor {\n             let tree = if !self.frame.open_delim {\n                 self.frame.open_delim = true;\n                 TokenTree::open_tt(self.frame.span, self.frame.delim).into()\n-            } else if let Some(tree) = self.frame.tree_cursor.next_with_joint() {\n+            } else if let Some(tree) = self.frame.tree_cursor.next_with_spacing() {\n                 tree\n             } else if !self.frame.close_delim {\n                 self.frame.close_delim = true;\n@@ -1154,7 +1154,7 @@ impl<'a> Parser<'a> {\n         f: impl FnOnce(&mut Self) -> PResult<'a, R>,\n     ) -> PResult<'a, (R, TokenStream)> {\n         // Record all tokens we parse when parsing this item.\n-        let tokens: Vec<TreeAndJoint> = self.token_cursor.cur_token.clone().into_iter().collect();\n+        let tokens: Vec<TreeAndSpacing> = self.token_cursor.cur_token.clone().into_iter().collect();\n         debug!(\"collect_tokens: starting with {:?}\", tokens);\n \n         // We need special handling for the case where `collect_tokens` is called"}, {"sha": "031c0d0cae51c86bbd74d9b1bf66ee6da45b83cb", "filename": "src/test/ui/ast-json/ast-json-noexpand-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a18b34d9793a88142c122f83fe53683f58f26ecc/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/a18b34d9793a88142c122f83fe53683f58f26ecc/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout?ref=a18b34d9793a88142c122f83fe53683f58f26ecc", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}, {"sha": "9b3b6870cbe7ef361f401e243f1aeced91b81850", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a18b34d9793a88142c122f83fe53683f58f26ecc/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/a18b34d9793a88142c122f83fe53683f58f26ecc/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=a18b34d9793a88142c122f83fe53683f58f26ecc", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}]}