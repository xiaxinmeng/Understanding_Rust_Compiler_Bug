{"sha": "fdfe819580062a441024d713b49340cd3f7d7efc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZmU4MTk1ODAwNjJhNDQxMDI0ZDcxM2I0OTM0MGNkM2Y3ZDdlZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-09T01:13:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-09T01:13:49Z"}, "message": "Auto merge of #86701 - sexxi-goose:optimization, r=nikomatsakis\n\n2229: Reduce the size of closures with `capture_disjoint_fields`\n\nOne key observation while going over the closure size profile of rustc\nwas that we are disjointly capturing one or more fields starting at an\nimmutable reference.\n\nDisjoint capture over immutable reference doesn't add too much value\nbecause the fields can either be borrowed immutably or copied.\n\nOne possible edge case of the optimization is when a fields of a struct\nhave a longer lifetime than the structure, therefore we can't completely\nget rid of all the accesses on top of sharef refs, only the rightmost\none. Here is a possible example:\n\n```rust\nstruct MyStruct<'a> {\n   a: &'static A,\n   b: B,\n   c: C<'a>,\n}\n\nfn foo<'a, 'b>(m: &'a MyStruct<'b>) -> impl FnMut() + 'static {\n    let c = || drop(&*m.a.field_of_a);\n    // Here we really do want to capture `*m.a` because that outlives `'static`\n\n    // If we capture `m`, then the closure no longer outlives `'static'\n    // it is constrained to `'a`\n}\n```\n\nr? `@nikomatsakis`", "tree": {"sha": "f4ad5b6bb8942d60b9ab296bbf4c2ce98cf03e94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4ad5b6bb8942d60b9ab296bbf4c2ce98cf03e94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdfe819580062a441024d713b49340cd3f7d7efc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdfe819580062a441024d713b49340cd3f7d7efc", "html_url": "https://github.com/rust-lang/rust/commit/fdfe819580062a441024d713b49340cd3f7d7efc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdfe819580062a441024d713b49340cd3f7d7efc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b87e85394aa583b01e53aef06343dd0749a3324", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b87e85394aa583b01e53aef06343dd0749a3324", "html_url": "https://github.com/rust-lang/rust/commit/8b87e85394aa583b01e53aef06343dd0749a3324"}, {"sha": "38dcae2cda85916d91d727ffe08a944e69ee3162", "url": "https://api.github.com/repos/rust-lang/rust/commits/38dcae2cda85916d91d727ffe08a944e69ee3162", "html_url": "https://github.com/rust-lang/rust/commit/38dcae2cda85916d91d727ffe08a944e69ee3162"}], "stats": {"total": 171, "additions": 159, "deletions": 12}, "files": [{"sha": "8aca64fe4745b2ae9d1c82827d5e7af2e52d28f3", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fdfe819580062a441024d713b49340cd3f7d7efc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfe819580062a441024d713b49340cd3f7d7efc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=fdfe819580062a441024d713b49340cd3f7d7efc", "patch": "@@ -1618,11 +1618,17 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             \"consume(place_with_id={:?}, diag_expr_id={:?}, mode={:?})\",\n             place_with_id, diag_expr_id, mode\n         );\n+\n+        let place_with_id = PlaceWithHirId {\n+            place: truncate_capture_for_optimization(&place_with_id.place),\n+            ..*place_with_id\n+        };\n+\n         if !self.capture_information.contains_key(&place_with_id.place) {\n-            self.init_capture_info_for_place(place_with_id, diag_expr_id);\n+            self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n         }\n \n-        self.adjust_upvar_borrow_kind_for_consume(place_with_id, diag_expr_id, mode);\n+        self.adjust_upvar_borrow_kind_for_consume(&place_with_id, diag_expr_id, mode);\n     }\n \n     fn borrow(\n@@ -1645,6 +1651,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             &place_with_id.place,\n         );\n \n+        let place = truncate_capture_for_optimization(&place);\n+\n         let place_with_id = PlaceWithHirId { place, ..*place_with_id };\n \n         if !self.capture_information.contains_key(&place_with_id.place) {\n@@ -1980,6 +1988,48 @@ fn determine_place_ancestry_relation(\n     }\n }\n \n+/// Reduces the precision of the captured place when the precision doesn't yeild any benefit from\n+/// borrow checking prespective, allowing us to save us on the size of the capture.\n+///\n+///\n+/// Fields that are read through a shared reference will always be read via a shared ref or a copy,\n+/// and therefore capturing precise paths yields no benefit. This optimization truncates the\n+/// rightmost deref of the capture if the deref is applied to a shared ref.\n+///\n+/// Reason we only drop the last deref is because of the following edge case:\n+///\n+/// ```rust\n+/// struct MyStruct<'a> {\n+///    a: &'static A,\n+///    b: B,\n+///    c: C<'a>,\n+/// }\n+///\n+/// fn foo<'a, 'b>(m: &'a MyStruct<'b>) -> impl FnMut() + 'static {\n+///     let c = || drop(&*m.a.field_of_a);\n+///     // Here we really do want to capture `*m.a` because that outlives `'static`\n+///\n+///     // If we capture `m`, then the closure no longer outlives `'static'\n+///     // it is constrained to `'a`\n+/// }\n+/// ```\n+fn truncate_capture_for_optimization<'tcx>(place: &Place<'tcx>) -> Place<'tcx> {\n+    let is_shared_ref = |ty: Ty<'_>| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Not));\n+\n+    // Find the right-most deref (if any). All the projections that come after this\n+    // are fields or other \"in-place pointer adjustments\"; these refer therefore to\n+    // data owned by whatever pointer is being dereferenced here.\n+    let idx = place.projections.iter().rposition(|proj| ProjectionKind::Deref == proj.kind);\n+\n+    match idx {\n+        // If that pointer is a shared reference, then we don't need those fields.\n+        Some(idx) if is_shared_ref(place.ty_before_projection(idx)) => {\n+            Place { projections: place.projections[0..=idx].to_vec(), ..place.clone() }\n+        }\n+        None | Some(_) => place.clone(),\n+    }\n+}\n+\n /// Precise capture is enabled if the feature gate `capture_disjoint_fields` is enabled or if\n /// user is using Rust Edition 2021 or higher.\n ///"}, {"sha": "77effcb006588f263df2c996d3763c3c2bb73ab5", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/cant-mutate-imm-borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.rs?ref=fdfe819580062a441024d713b49340cd3f7d7efc", "patch": "@@ -8,10 +8,10 @@ fn main() {\n     let mut y = (&x, \"Y\");\n     let z = (&mut y, \"Z\");\n \n-    // `x.0` is mutable but we access `x` via `z.0.0`, which is an immutable reference and\n+    // `x.0` is mutable but we access `x` via `*z.0.0`, which is an immutable reference and\n     // therefore can't be mutated.\n     let mut c = || {\n-    //~^ ERROR: cannot borrow `z.0.0.0` as mutable, as it is behind a `&` reference\n+    //~^ ERROR: cannot borrow `*z.0.0` as mutable, as it is behind a `&` reference\n         z.0.0.0 = format!(\"X1\");\n     };\n "}, {"sha": "38c530b809a624680626c6b52c608c2113777974", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/cant-mutate-imm-borrow.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.stderr?ref=fdfe819580062a441024d713b49340cd3f7d7efc", "patch": "@@ -1,11 +1,11 @@\n-error[E0596]: cannot borrow `z.0.0.0` as mutable, as it is behind a `&` reference\n+error[E0596]: cannot borrow `*z.0.0` as mutable, as it is behind a `&` reference\n   --> $DIR/cant-mutate-imm-borrow.rs:13:17\n    |\n LL |     let mut c = || {\n    |                 ^^ cannot borrow as mutable\n LL |\n LL |         z.0.0.0 = format!(\"X1\");\n-   |         ------- mutable borrow occurs due to use of `z.0.0.0` in closure\n+   |         ------- mutable borrow occurs due to use of `*z.0.0` in closure\n \n error: aborting due to previous error\n "}, {"sha": "76874e03dc02a128128636cff2e7d9ce89d8e6d9", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs?ref=fdfe819580062a441024d713b49340cd3f7d7efc", "patch": "@@ -78,8 +78,8 @@ fn struct_contains_ref_to_another_struct_2() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         let _t = t.0.0;\n-        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n-        //~| NOTE: Min Capture t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+        //~^ NOTE: Capturing t[(0, 0),Deref] -> ImmBorrow\n+        //~| NOTE: Min Capture t[(0, 0),Deref] -> ImmBorrow\n     };\n \n     c();\n@@ -100,7 +100,7 @@ fn struct_contains_ref_to_another_struct_3() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         let _t = t.0.0;\n-        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+        //~^ NOTE: Capturing t[(0, 0),Deref] -> ImmBorrow\n         //~| NOTE: Capturing t[(0, 0)] -> ByValue\n         //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n     };"}, {"sha": "b35aadfcbd41948b200812453362ea0c7012a824", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr?ref=fdfe819580062a441024d713b49340cd3f7d7efc", "patch": "@@ -190,7 +190,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+note: Capturing t[(0, 0),Deref] -> ImmBorrow\n   --> $DIR/move_closure.rs:80:18\n    |\n LL |         let _t = t.0.0;\n@@ -208,7 +208,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Min Capture t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+note: Min Capture t[(0, 0),Deref] -> ImmBorrow\n   --> $DIR/move_closure.rs:80:18\n    |\n LL |         let _t = t.0.0;\n@@ -226,7 +226,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+note: Capturing t[(0, 0),Deref] -> ImmBorrow\n   --> $DIR/move_closure.rs:102:18\n    |\n LL |         let _t = t.0.0;"}, {"sha": "37a2a97d44279d7746a36e7730172c4796953159", "filename": "src/test/ui/closures/2229_closure_analysis/optimization/edge_case.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case.rs?ref=fdfe819580062a441024d713b49340cd3f7d7efc", "patch": "@@ -0,0 +1,34 @@\n+// edition:2021\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+#![allow(dead_code)]\n+\n+struct Int(i32);\n+struct B<'a>(&'a i32);\n+\n+const I : Int = Int(0);\n+const REF_I : &'static Int = &I;\n+\n+\n+struct MyStruct<'a> {\n+   a: &'static Int,\n+   b: B<'a>,\n+}\n+\n+fn foo<'a, 'b>(m: &'a MyStruct<'b>) -> impl FnMut() + 'static {\n+    let c = #[rustc_capture_analysis] || drop(&m.a.0);\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    //~| ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+    //~| NOTE: Capturing m[Deref,(0, 0),Deref] -> ImmBorrow\n+    //~| NOTE: Min Capture m[Deref,(0, 0),Deref] -> ImmBorrow\n+    c\n+}\n+\n+fn main() {\n+    let t = 0;\n+    let s = MyStruct { a: REF_I, b: B(&t) };\n+    let _ = foo(&s);\n+}"}, {"sha": "b727c06d9528f0ded2176718e413576b1a15e321", "filename": "src/test/ui/closures/2229_closure_analysis/optimization/edge_case.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case.stderr?ref=fdfe819580062a441024d713b49340cd3f7d7efc", "patch": "@@ -0,0 +1,36 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/edge_case.rs:20:13\n+   |\n+LL |     let c = #[rustc_capture_analysis] || drop(&m.a.0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error: First Pass analysis includes:\n+  --> $DIR/edge_case.rs:20:39\n+   |\n+LL |     let c = #[rustc_capture_analysis] || drop(&m.a.0);\n+   |                                       ^^^^^^^^^^^^^^^\n+   |\n+note: Capturing m[Deref,(0, 0),Deref] -> ImmBorrow\n+  --> $DIR/edge_case.rs:20:48\n+   |\n+LL |     let c = #[rustc_capture_analysis] || drop(&m.a.0);\n+   |                                                ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/edge_case.rs:20:39\n+   |\n+LL |     let c = #[rustc_capture_analysis] || drop(&m.a.0);\n+   |                                       ^^^^^^^^^^^^^^^\n+   |\n+note: Min Capture m[Deref,(0, 0),Deref] -> ImmBorrow\n+  --> $DIR/edge_case.rs:20:48\n+   |\n+LL |     let c = #[rustc_capture_analysis] || drop(&m.a.0);\n+   |                                                ^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "033fd6f17753af47dd23d3cea03a9fe8cb740201", "filename": "src/test/ui/closures/2229_closure_analysis/optimization/edge_case_run_pass.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case_run_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfe819580062a441024d713b49340cd3f7d7efc/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case_run_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case_run_pass.rs?ref=fdfe819580062a441024d713b49340cd3f7d7efc", "patch": "@@ -0,0 +1,27 @@\n+// edition:2021\n+// run-pass\n+\n+#![allow(unused)]\n+#![allow(dead_code)]\n+\n+struct Int(i32);\n+struct B<'a>(&'a i32);\n+\n+const I : Int = Int(0);\n+const REF_I : &'static Int = &I;\n+\n+struct MyStruct<'a> {\n+   a: &'static Int,\n+   b: B<'a>,\n+}\n+\n+fn foo<'a, 'b>(m: &'a MyStruct<'b>) -> impl FnMut() + 'static {\n+    let c = || drop(&m.a.0);\n+    c\n+}\n+\n+fn main() {\n+    let t = 0;\n+    let s = MyStruct { a: REF_I, b: B(&t) };\n+    let _ = foo(&s);\n+}"}]}