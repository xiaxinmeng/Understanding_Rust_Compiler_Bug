{"sha": "10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwODU1YTM2YjUzZDMzYWEyZTRmOGI5ODEwN2VlNTRhMGNjYTVlOWM=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-04-03T00:43:49Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-04-15T05:23:01Z"}, "message": "Use a proc macro to declare preallocated symbols", "tree": {"sha": "eb06422719e2b2f7098d8b658f2ebd835eb04bb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb06422719e2b2f7098d8b658f2ebd835eb04bb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "html_url": "https://github.com/rust-lang/rust/commit/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a55f6be4286991437659acb8506466e8d637ac51", "url": "https://api.github.com/repos/rust-lang/rust/commits/a55f6be4286991437659acb8506466e8d637ac51", "html_url": "https://github.com/rust-lang/rust/commit/a55f6be4286991437659acb8506466e8d637ac51"}], "stats": {"total": 451, "additions": 312, "deletions": 139}, "files": [{"sha": "80a4029e1aa095b916c8b3b129cf817ed5466f9e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "patch": "@@ -3387,6 +3387,7 @@ dependencies = [\n  \"arena 0.0.0\",\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_macros 0.1.0\",\n  \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "98fba55218f9b10283b2b43998bc9876f269fa27", "filename": "src/librustc_macros/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "patch": "@@ -9,10 +9,16 @@ use proc_macro::TokenStream;\n \n mod hash_stable;\n mod query;\n+mod symbols;\n \n #[proc_macro]\n pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     query::rustc_queries(input)\n }\n \n+#[proc_macro]\n+pub fn symbols(input: TokenStream) -> TokenStream {\n+    symbols::symbols(input)\n+}\n+\n decl_derive!([HashStable, attributes(stable_hasher)] => hash_stable::hash_stable_derive);"}, {"sha": "e72ab7f84e92af4a1248f06743f85eb78652fa2a", "filename": "src/librustc_macros/src/symbols.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs?ref=10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "patch": "@@ -0,0 +1,173 @@\n+use proc_macro::TokenStream;\n+use syn::{\n+    Token, Ident, LitStr,\n+    braced, parse_macro_input,\n+};\n+use syn::parse::{Result, Parse, ParseStream};\n+use syn;\n+use std::collections::HashSet;\n+use quote::quote;\n+\n+#[allow(non_camel_case_types)]\n+mod kw {\n+    syn::custom_keyword!(Keywords);\n+    syn::custom_keyword!(Other);\n+}\n+\n+struct Keyword {\n+    name: Ident,\n+    value: LitStr,\n+}\n+\n+impl Parse for Keyword {\n+    fn parse(input: ParseStream<'_>) -> Result<Self> {\n+        let name = input.parse()?;\n+        input.parse::<Token![,]>()?;\n+        let value = input.parse()?;\n+        input.parse::<Token![,]>()?;\n+\n+        Ok(Keyword {\n+            name,\n+            value,\n+        })\n+    }\n+}\n+\n+struct Symbol(Ident);\n+\n+impl Parse for Symbol {\n+    fn parse(input: ParseStream<'_>) -> Result<Self> {\n+        let ident: Ident = input.parse()?;\n+        input.parse::<Token![,]>()?;\n+\n+        Ok(Symbol(ident))\n+    }\n+}\n+\n+/// A type used to greedily parse another type until the input is empty.\n+struct List<T>(Vec<T>);\n+\n+impl<T: Parse> Parse for List<T> {\n+    fn parse(input: ParseStream<'_>) -> Result<Self> {\n+        let mut list = Vec::new();\n+        while !input.is_empty() {\n+            list.push(input.parse()?);\n+        }\n+        Ok(List(list))\n+    }\n+}\n+\n+struct Input {\n+    keywords: List<Keyword>,\n+    symbols: List<Symbol>,\n+}\n+\n+impl Parse for Input {\n+    fn parse(input: ParseStream<'_>) -> Result<Self> {\n+        input.parse::<kw::Keywords>()?;\n+        let content;\n+        braced!(content in input);\n+        let keywords = content.parse()?;\n+\n+        input.parse::<kw::Other>()?;\n+        let content;\n+        braced!(content in input);\n+        let symbols = content.parse()?;\n+\n+        Ok(Input {\n+            keywords,\n+            symbols,\n+        })\n+    }\n+}\n+\n+pub fn symbols(input: TokenStream) -> TokenStream {\n+    let input = parse_macro_input!(input as Input);\n+\n+    let mut keyword_stream = quote! {};\n+    let mut symbols_stream = quote! {};\n+    let mut prefill_stream = quote! {};\n+    let mut from_str_stream = quote! {};\n+    let mut counter = 0u32;\n+    let mut keys = HashSet::<String>::new();\n+\n+    let mut check_dup = |str: &str| {\n+        if !keys.insert(str.to_string()) {\n+            panic!(\"Symbol `{}` is duplicated\", str);\n+        }\n+    };\n+\n+    for keyword in &input.keywords.0 {\n+        let name = &keyword.name;\n+        let value = &keyword.value;\n+        check_dup(&value.value());\n+        prefill_stream.extend(quote! {\n+            #value,\n+        });\n+        keyword_stream.extend(quote! {\n+            pub const #name: Keyword = Keyword {\n+                ident: Ident::with_empty_ctxt(super::Symbol::new(#counter))\n+            };\n+        });\n+        from_str_stream.extend(quote! {\n+            #value => Ok(#name),\n+        });\n+        counter += 1;\n+    }\n+\n+    for symbol in &input.symbols.0 {\n+        let value = &symbol.0;\n+        let value_str = value.to_string();\n+        check_dup(&value_str);\n+        prefill_stream.extend(quote! {\n+            #value_str,\n+        });\n+        symbols_stream.extend(quote! {\n+            pub const #value: Symbol = Symbol::new(#counter);\n+        });\n+        counter += 1;\n+    }\n+\n+    TokenStream::from(quote! {\n+        #[allow(non_upper_case_globals)]\n+        pub mod keywords {\n+            use super::{Symbol, Ident};\n+            #[derive(Clone, Copy, PartialEq, Eq)]\n+            pub struct Keyword {\n+                ident: Ident,\n+            }\n+            impl Keyword {\n+                #[inline] pub fn ident(self) -> Ident { self.ident }\n+                #[inline] pub fn name(self) -> Symbol { self.ident.name }\n+            }\n+\n+            #keyword_stream\n+\n+            impl std::str::FromStr for Keyword {\n+                type Err = ();\n+\n+                fn from_str(s: &str) -> Result<Self, ()> {\n+                    match s {\n+                        #from_str_stream\n+                        _ => Err(()),\n+                    }\n+                }\n+            }\n+        }\n+\n+        #[allow(non_upper_case_globals)]\n+        pub mod symbols {\n+            use super::Symbol;\n+\n+            #symbols_stream\n+        }\n+\n+        impl Interner {\n+            pub fn fresh() -> Self {\n+                Interner::prefill(&[\n+                    #prefill_stream\n+                ])\n+            }\n+        }\n+    })\n+}"}, {"sha": "c015e9b06acdb81bc7ef41f1121197b2e7468bc3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "patch": "@@ -68,6 +68,12 @@ pub struct Path {\n     pub segments: Vec<PathSegment>,\n }\n \n+impl PartialEq<Symbol> for Path {\n+    fn eq(&self, symbol: &Symbol) -> bool {\n+        self.segments.len() == 1 && self.segments[0].ident.name.interned() == *symbol\n+    }\n+}\n+\n impl<'a> PartialEq<&'a str> for Path {\n     fn eq(&self, string: &&'a str) -> bool {\n         self.segments.len() == 1 && self.segments[0].ident.name == *string"}, {"sha": "f34bbc9f35dad6dc0eddc0e7ec9d415db88af1c0", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "patch": "@@ -85,6 +85,11 @@ impl NestedMetaItem {\n         self.meta_item().map_or(false, |meta_item| meta_item.check_name(name))\n     }\n \n+    /// Returns `true` if this list item is a MetaItem with a name of `name`.\n+    pub fn check_name_symbol(&self, name: Symbol) -> bool {\n+        self.meta_item().map_or(false, |meta_item| meta_item.check_name_symbol(name))\n+    }\n+\n     /// For a single-segment meta-item returns its name, otherwise returns `None`.\n     pub fn ident(&self) -> Option<Ident> {\n         self.meta_item().and_then(|meta_item| meta_item.ident())\n@@ -159,6 +164,18 @@ impl Attribute {\n         matches\n     }\n \n+    /// Returns `true` if the attribute's path matches the argument. If it matches, then the\n+    /// attribute is marked as used.\n+    ///\n+    /// To check the attribute name without marking it used, use the `path` field directly.\n+    pub fn check_name_symbol(&self, name: Symbol) -> bool {\n+        let matches = self.path == name;\n+        if matches {\n+            mark_used(self);\n+        }\n+        matches\n+    }\n+\n     /// For a single-segment attribute returns its name, otherwise returns `None`.\n     pub fn ident(&self) -> Option<Ident> {\n         if self.path.segments.len() == 1 {\n@@ -248,6 +265,10 @@ impl MetaItem {\n         self.path == name\n     }\n \n+    pub fn check_name_symbol(&self, name: Symbol) -> bool {\n+        self.path == name\n+    }\n+\n     pub fn is_value_str(&self) -> bool {\n         self.value_str().is_some()\n     }"}, {"sha": "b3e5d808a476d4000701d52be41e7c8efec88041", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "patch": "@@ -28,7 +28,7 @@ use crate::tokenstream::TokenTree;\n use errors::{DiagnosticBuilder, Handler};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::abi::Abi;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP, symbols};\n use log::debug;\n \n use std::env;\n@@ -1366,7 +1366,7 @@ impl<'a> Context<'a> {\n                     }\n                 } else if n == \"doc\" {\n                     if let Some(content) = attr.meta_item_list() {\n-                        if content.iter().any(|c| c.check_name(\"include\")) {\n+                        if content.iter().any(|c| c.check_name_symbol(symbols::include)) {\n                             gate_feature!(self, external_doc, attr.span,\n                                 \"#[doc(include = \\\"...\\\")] is experimental\"\n                             );\n@@ -1667,33 +1667,33 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         // check for gated attributes\n         self.context.check_attribute(attr, false);\n \n-        if attr.check_name(\"doc\") {\n+        if attr.check_name_symbol(symbols::doc) {\n             if let Some(content) = attr.meta_item_list() {\n-                if content.len() == 1 && content[0].check_name(\"cfg\") {\n+                if content.len() == 1 && content[0].check_name_symbol(symbols::cfg) {\n                     gate_feature_post!(&self, doc_cfg, attr.span,\n                         \"#[doc(cfg(...))] is experimental\"\n                     );\n-                } else if content.iter().any(|c| c.check_name(\"masked\")) {\n+                } else if content.iter().any(|c| c.check_name_symbol(symbols::masked)) {\n                     gate_feature_post!(&self, doc_masked, attr.span,\n                         \"#[doc(masked)] is experimental\"\n                     );\n-                } else if content.iter().any(|c| c.check_name(\"spotlight\")) {\n+                } else if content.iter().any(|c| c.check_name_symbol(symbols::spotlight)) {\n                     gate_feature_post!(&self, doc_spotlight, attr.span,\n                         \"#[doc(spotlight)] is experimental\"\n                     );\n-                } else if content.iter().any(|c| c.check_name(\"alias\")) {\n+                } else if content.iter().any(|c| c.check_name_symbol(symbols::alias)) {\n                     gate_feature_post!(&self, doc_alias, attr.span,\n                         \"#[doc(alias = \\\"...\\\")] is experimental\"\n                     );\n-                } else if content.iter().any(|c| c.check_name(\"keyword\")) {\n+                } else if content.iter().any(|c| c.check_name_symbol(symbols::keyword)) {\n                     gate_feature_post!(&self, doc_keyword, attr.span,\n                         \"#[doc(keyword = \\\"...\\\")] is experimental\"\n                     );\n                 }\n             }\n         }\n \n-        match BUILTIN_ATTRIBUTES.iter().find(|(name, ..)| attr.path == name) {\n+        match BUILTIN_ATTRIBUTES.iter().find(|(name, ..)| attr.path == *name) {\n             Some(&(name, _, template, _)) => self.check_builtin_attribute(attr, name, template),\n             None => if let Some(TokenTree::Token(_, token::Eq)) = attr.tokens.trees().next() {\n                 // All key-value attributes are restricted to meta-item syntax.\n@@ -1748,7 +1748,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ItemKind::Struct(..) => {\n                 for attr in attr::filter_by_name(&i.attrs[..], \"repr\") {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-                        if item.check_name(\"simd\") {\n+                        if item.check_name_symbol(symbols::simd) {\n                             gate_feature_post!(&self, repr_simd, attr.span,\n                                                \"SIMD types are experimental and possibly buggy\");\n                         }\n@@ -1759,7 +1759,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ItemKind::Enum(..) => {\n                 for attr in attr::filter_by_name(&i.attrs[..], \"repr\") {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-                        if item.check_name(\"align\") {\n+                        if item.check_name_symbol(symbols::align) {\n                             gate_feature_post!(&self, repr_align_enum, attr.span,\n                                                \"`#[repr(align(x))]` on enums is experimental\");\n                         }\n@@ -2083,7 +2083,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n     // Process the edition umbrella feature-gates first, to ensure\n     // `edition_enabled_features` is completed before it's queried.\n     for attr in krate_attrs {\n-        if !attr.check_name(\"feature\") {\n+        if !attr.check_name_symbol(symbols::feature) {\n             continue\n         }\n \n@@ -2128,7 +2128,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n     }\n \n     for attr in krate_attrs {\n-        if !attr.check_name(\"feature\") {\n+        if !attr.check_name_symbol(symbols::feature) {\n             continue\n         }\n \n@@ -2258,7 +2258,7 @@ fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate,\n     };\n     if !allow_features {\n         for attr in &krate.attrs {\n-            if attr.check_name(\"feature\") {\n+            if attr.check_name_symbol(symbols::feature) {\n                 let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n                 span_err!(span_handler, attr.span, E0554,\n                           \"#![feature] may not be used on the {} release channel\","}, {"sha": "af7edc0a6bd3eb08a98ec476533f8c48e672054e", "filename": "src/libsyntax_pos/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibsyntax_pos%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibsyntax_pos%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2FCargo.toml?ref=10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "patch": "@@ -11,6 +11,7 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n serialize = { path = \"../libserialize\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n arena = { path = \"../libarena\" }\n scoped-tls = \"1.0\""}, {"sha": "1ad556bbcfa5637fe9cab41c574169a36eeb3d6e", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "patch": "@@ -16,6 +16,7 @@\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n #![feature(rustc_attrs)]\n+#![feature(proc_macro_hygiene)]\n #![feature(specialization)]\n #![feature(step_trait)]\n \n@@ -32,6 +33,7 @@ mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n \n pub mod symbol;\n+pub use symbol::symbols;\n \n mod analyze_source_file;\n "}, {"sha": "8c195fb45ef7b751fccbe12e936857874c260d6d", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 88, "deletions": 125, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10855a36b53d33aa2e4f8b98107ee54a0cca5e9c/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=10855a36b53d33aa2e4f8b98107ee54a0cca5e9c", "patch": "@@ -6,6 +6,7 @@ use arena::DroplessArena;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::newtype_index;\n+use rustc_macros::symbols;\n use serialize::{Decodable, Decoder, Encodable, Encoder};\n \n use std::fmt;\n@@ -16,6 +17,93 @@ use std::hash::{Hash, Hasher};\n use crate::hygiene::SyntaxContext;\n use crate::{Span, DUMMY_SP, GLOBALS};\n \n+symbols! {\n+    // After modifying this list adjust `is_special`, `is_used_keyword`/`is_unused_keyword`,\n+    // this should be rarely necessary though if the keywords are kept in alphabetic order.\n+    Keywords {\n+        // Special reserved identifiers used internally for elided lifetimes,\n+        // unnamed method parameters, crate root module, error recovery etc.\n+        Invalid,            \"\",\n+        PathRoot,           \"{{root}}\",\n+        DollarCrate,        \"$crate\",\n+        Underscore,         \"_\",\n+\n+        // Keywords that are used in stable Rust.\n+        As,                 \"as\",\n+        Box,                \"box\",\n+        Break,              \"break\",\n+        Const,              \"const\",\n+        Continue,           \"continue\",\n+        Crate,              \"crate\",\n+        Else,               \"else\",\n+        Enum,               \"enum\",\n+        Extern,             \"extern\",\n+        False,              \"false\",\n+        Fn,                 \"fn\",\n+        For,                \"for\",\n+        If,                 \"if\",\n+        Impl,               \"impl\",\n+        In,                 \"in\",\n+        Let,                \"let\",\n+        Loop,               \"loop\",\n+        Match,              \"match\",\n+        Mod,                \"mod\",\n+        Move,               \"move\",\n+        Mut,                \"mut\",\n+        Pub,                \"pub\",\n+        Ref,                \"ref\",\n+        Return,             \"return\",\n+        SelfLower,          \"self\",\n+        SelfUpper,          \"Self\",\n+        Static,             \"static\",\n+        Struct,             \"struct\",\n+        Super,              \"super\",\n+        Trait,              \"trait\",\n+        True,               \"true\",\n+        Type,               \"type\",\n+        Unsafe,             \"unsafe\",\n+        Use,                \"use\",\n+        Where,              \"where\",\n+        While,              \"while\",\n+\n+        // Keywords that are used in unstable Rust or reserved for future use.\n+        Abstract,           \"abstract\",\n+        Become,             \"become\",\n+        Do,                 \"do\",\n+        Final,              \"final\",\n+        Macro,              \"macro\",\n+        Override,           \"override\",\n+        Priv,               \"priv\",\n+        Typeof,             \"typeof\",\n+        Unsized,            \"unsized\",\n+        Virtual,            \"virtual\",\n+        Yield,              \"yield\",\n+\n+        // Edition-specific keywords that are used in stable Rust.\n+        Dyn,                \"dyn\", // >= 2018 Edition only\n+\n+        // Edition-specific keywords that are used in unstable Rust or reserved for future use.\n+        Async,              \"async\", // >= 2018 Edition only\n+        Try,                \"try\", // >= 2018 Edition only\n+\n+        // Special lifetime names\n+        UnderscoreLifetime, \"'_\",\n+        StaticLifetime,     \"'static\",\n+\n+        // Weak keywords, have special meaning only in specific contexts.\n+        Auto,               \"auto\",\n+        Catch,              \"catch\",\n+        Default,            \"default\",\n+        Existential,        \"existential\",\n+        Union,              \"union\",\n+    }\n+\n+    // Other symbols that can be referred to with syntax_pos::symbols::*\n+    Other {\n+        doc, cfg, masked, spotlight, alias, keyword, feature, include, simd, align,\n+    }\n+}\n+\n #[derive(Copy, Clone, Eq)]\n pub struct Ident {\n     pub name: Symbol,\n@@ -317,131 +405,6 @@ impl Interner {\n     }\n }\n \n-// In this macro, there is the requirement that the name (the number) must be monotonically\n-// increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n-// except starting from the next number instead of zero.\n-macro_rules! declare_keywords {(\n-    $( ($index: expr, $konst: ident, $string: expr) )*\n-) => {\n-    pub mod keywords {\n-        use super::{Symbol, Ident};\n-        #[derive(Clone, Copy, PartialEq, Eq)]\n-        pub struct Keyword {\n-            ident: Ident,\n-        }\n-        impl Keyword {\n-            #[inline] pub fn ident(self) -> Ident { self.ident }\n-            #[inline] pub fn name(self) -> Symbol { self.ident.name }\n-        }\n-        $(\n-            #[allow(non_upper_case_globals)]\n-            pub const $konst: Keyword = Keyword {\n-                ident: Ident::with_empty_ctxt(super::Symbol::new($index))\n-            };\n-        )*\n-\n-        impl std::str::FromStr for Keyword {\n-            type Err = ();\n-\n-            fn from_str(s: &str) -> Result<Self, ()> {\n-                match s {\n-                    $($string => Ok($konst),)*\n-                    _ => Err(()),\n-                }\n-            }\n-        }\n-    }\n-\n-    impl Interner {\n-        pub fn fresh() -> Self {\n-            Interner::prefill(&[$($string,)*])\n-        }\n-    }\n-}}\n-\n-// N.B., leaving holes in the ident table is bad! a different ident will get\n-// interned with the id from the hole, but it will be between the min and max\n-// of the reserved words, and thus tagged as \"reserved\".\n-// After modifying this list adjust `is_special`, `is_used_keyword`/`is_unused_keyword`,\n-// this should be rarely necessary though if the keywords are kept in alphabetic order.\n-declare_keywords! {\n-    // Special reserved identifiers used internally for elided lifetimes,\n-    // unnamed method parameters, crate root module, error recovery etc.\n-    (0,  Invalid,            \"\")\n-    (1,  PathRoot,           \"{{root}}\")\n-    (2,  DollarCrate,        \"$crate\")\n-    (3,  Underscore,         \"_\")\n-\n-    // Keywords that are used in stable Rust.\n-    (4,  As,                 \"as\")\n-    (5,  Box,                \"box\")\n-    (6,  Break,              \"break\")\n-    (7,  Const,              \"const\")\n-    (8,  Continue,           \"continue\")\n-    (9,  Crate,              \"crate\")\n-    (10, Else,               \"else\")\n-    (11, Enum,               \"enum\")\n-    (12, Extern,             \"extern\")\n-    (13, False,              \"false\")\n-    (14, Fn,                 \"fn\")\n-    (15, For,                \"for\")\n-    (16, If,                 \"if\")\n-    (17, Impl,               \"impl\")\n-    (18, In,                 \"in\")\n-    (19, Let,                \"let\")\n-    (20, Loop,               \"loop\")\n-    (21, Match,              \"match\")\n-    (22, Mod,                \"mod\")\n-    (23, Move,               \"move\")\n-    (24, Mut,                \"mut\")\n-    (25, Pub,                \"pub\")\n-    (26, Ref,                \"ref\")\n-    (27, Return,             \"return\")\n-    (28, SelfLower,          \"self\")\n-    (29, SelfUpper,          \"Self\")\n-    (30, Static,             \"static\")\n-    (31, Struct,             \"struct\")\n-    (32, Super,              \"super\")\n-    (33, Trait,              \"trait\")\n-    (34, True,               \"true\")\n-    (35, Type,               \"type\")\n-    (36, Unsafe,             \"unsafe\")\n-    (37, Use,                \"use\")\n-    (38, Where,              \"where\")\n-    (39, While,              \"while\")\n-\n-    // Keywords that are used in unstable Rust or reserved for future use.\n-    (40, Abstract,           \"abstract\")\n-    (41, Become,             \"become\")\n-    (42, Do,                 \"do\")\n-    (43, Final,              \"final\")\n-    (44, Macro,              \"macro\")\n-    (45, Override,           \"override\")\n-    (46, Priv,               \"priv\")\n-    (47, Typeof,             \"typeof\")\n-    (48, Unsized,            \"unsized\")\n-    (49, Virtual,            \"virtual\")\n-    (50, Yield,              \"yield\")\n-\n-    // Edition-specific keywords that are used in stable Rust.\n-    (51, Dyn,                \"dyn\") // >= 2018 Edition only\n-\n-    // Edition-specific keywords that are used in unstable Rust or reserved for future use.\n-    (52, Async,              \"async\") // >= 2018 Edition only\n-    (53, Try,                \"try\") // >= 2018 Edition only\n-\n-    // Special lifetime names\n-    (54, UnderscoreLifetime, \"'_\")\n-    (55, StaticLifetime,     \"'static\")\n-\n-    // Weak keywords, have special meaning only in specific contexts.\n-    (56, Auto,               \"auto\")\n-    (57, Catch,              \"catch\")\n-    (58, Default,            \"default\")\n-    (59, Existential,        \"existential\")\n-    (60, Union,              \"union\")\n-}\n-\n impl Symbol {\n     fn is_used_keyword_2018(self) -> bool {\n         self == keywords::Dyn.name()"}]}