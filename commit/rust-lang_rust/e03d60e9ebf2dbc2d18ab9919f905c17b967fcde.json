{"sha": "e03d60e9ebf2dbc2d18ab9919f905c17b967fcde", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwM2Q2MGU5ZWJmMmRiYzJkMThhYjk5MTlmOTA1YzE3Yjk2N2ZjZGU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-11T16:33:45Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-13T01:54:12Z"}, "message": "std: Add ToEither/IntoEither/AsEither", "tree": {"sha": "d80ca6146eb66e930b1063c6929bb1b09e90b1e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d80ca6146eb66e930b1063c6929bb1b09e90b1e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e03d60e9ebf2dbc2d18ab9919f905c17b967fcde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e03d60e9ebf2dbc2d18ab9919f905c17b967fcde", "html_url": "https://github.com/rust-lang/rust/commit/e03d60e9ebf2dbc2d18ab9919f905c17b967fcde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e03d60e9ebf2dbc2d18ab9919f905c17b967fcde/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12e0d7ecf061313d02a4647db8c1b30aad2ae53d", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e0d7ecf061313d02a4647db8c1b30aad2ae53d", "html_url": "https://github.com/rust-lang/rust/commit/12e0d7ecf061313d02a4647db8c1b30aad2ae53d"}], "stats": {"total": 183, "additions": 162, "deletions": 21}, "files": [{"sha": "27381f64ad4a6b05a996e9e932ca35b9d9ff45a0", "filename": "src/libstd/either.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e03d60e9ebf2dbc2d18ab9919f905c17b967fcde/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e03d60e9ebf2dbc2d18ab9919f905c17b967fcde/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=e03d60e9ebf2dbc2d18ab9919f905c17b967fcde", "patch": "@@ -105,6 +105,24 @@ impl<L, R> Either<L, R> {\n     }\n }\n \n+/// A generic trait for converting a value to a `Either`\n+pub trait ToEither<L, R> {\n+    /// Convert to the `either` type\n+    fn to_either(&self) -> Either<L, R>;\n+}\n+\n+/// A generic trait for converting a value to a `Either`\n+pub trait IntoEither<L, R> {\n+    /// Convert to the `either` type\n+    fn into_either(self) -> Either<L, R>;\n+}\n+\n+/// A generic trait for converting a value to a `Either`\n+pub trait AsEither<L, R> {\n+    /// Convert to the `either` type\n+    fn as_either<'a>(&'a self) -> Either<&'a L, &'a R>;\n+}\n+\n impl<L, R: Clone> option::ToOption<R> for Either<L, R> {\n     #[inline]\n     fn to_option(&self)-> option::Option<R> {\n@@ -165,6 +183,23 @@ impl<L, R> result::AsResult<R, L> for Either<L, R> {\n     }\n }\n \n+impl<L: Clone, R: Clone> ToEither<L, R> for Either<L, R> {\n+    fn to_either(&self) -> Either<L, R> { self.clone() }\n+}\n+\n+impl<L, R> IntoEither<L, R> for Either<L, R> {\n+    fn into_either(self) -> Either<L, R> { self }\n+}\n+\n+impl<L, R> AsEither<L, R> for Either<L, R> {\n+    fn as_either<'a>(&'a self) -> Either<&'a L, &'a R> {\n+        match *self {\n+            Left(ref l) => Left(l),\n+            Right(ref r) => Right(r),\n+        }\n+    }\n+}\n+\n /// An iterator yielding the `Left` values of its source\n pub type Lefts<L, R, Iter> = FilterMap<'static, Either<L, R>, L, Iter>;\n \n@@ -370,4 +405,31 @@ mod tests {\n         let x = 404;\n         assert_eq!(left.as_result(), result::Err(&x));\n     }\n+\n+    #[test]\n+    pub fn test_to_either() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.to_either(), Right(100));\n+        assert_eq!(left.to_either(), Left(404));\n+    }\n+\n+    #[test]\n+    pub fn test_into_either() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.into_either(), Right(100));\n+        assert_eq!(left.into_either(), Left(404));\n+    }\n+\n+    #[test]\n+    pub fn test_as_either() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.as_either().unwrap_right(), &100);\n+        assert_eq!(left.as_either().unwrap_left(), &404);\n+    }\n }"}, {"sha": "cd9e39807160f5c7bd3dcc50b980c235932dc93c", "filename": "src/libstd/option.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e03d60e9ebf2dbc2d18ab9919f905c17b967fcde/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e03d60e9ebf2dbc2d18ab9919f905c17b967fcde/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=e03d60e9ebf2dbc2d18ab9919f905c17b967fcde", "patch": "@@ -44,6 +44,7 @@ let unwrapped_msg = match msg {\n use clone::Clone;\n use cmp::{Eq,Ord};\n use default::Default;\n+use either;\n use util;\n use num::Zero;\n use iter;\n@@ -447,6 +448,26 @@ impl<T> result::IntoResult<T, ()> for Option<T> {\n     }\n }\n \n+impl<T: Clone> either::ToEither<(), T> for Option<T> {\n+    #[inline]\n+    fn to_either(&self) -> either::Either<(), T> {\n+        match *self {\n+            Some(ref x) => either::Right(x.clone()),\n+            None => either::Left(()),\n+        }\n+    }\n+}\n+\n+impl<T> either::IntoEither<(), T> for Option<T> {\n+    #[inline]\n+    fn into_either(self) -> either::Either<(), T> {\n+        match self {\n+            Some(x) => either::Right(x),\n+            None => either::Left(()),\n+        }\n+    }\n+}\n+\n impl<T: Default> Option<T> {\n     /// Returns the contained value or default (for this type)\n     #[inline]\n@@ -529,6 +550,9 @@ impl<A> ExactSize<A> for OptionIterator<A> {}\n #[cfg(test)]\n mod tests {\n     use super::*;\n+\n+    use either::{IntoEither, ToEither};\n+    use either;\n     use result::{IntoResult, ToResult};\n     use result;\n     use util;\n@@ -817,4 +841,22 @@ mod tests {\n         assert_eq!(some.into_result(), result::Ok(100));\n         assert_eq!(none.into_result(), result::Err(()));\n     }\n+\n+    #[test]\n+    pub fn test_to_either() {\n+        let some: Option<int> = Some(100);\n+        let none: Option<int> = None;\n+\n+        assert_eq!(some.to_either(), either::Right(100));\n+        assert_eq!(none.to_either(), either::Left(()));\n+    }\n+\n+    #[test]\n+    pub fn test_into_either() {\n+        let some: Option<int> = Some(100);\n+        let none: Option<int> = None;\n+\n+        assert_eq!(some.into_either(), either::Right(100));\n+        assert_eq!(none.into_either(), either::Left(()));\n+    }\n }"}, {"sha": "20b65f1576d78b36c2747a355f5ed22249b2e3e5", "filename": "src/libstd/result.rs", "status": "modified", "additions": 58, "deletions": 21, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e03d60e9ebf2dbc2d18ab9919f905c17b967fcde/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e03d60e9ebf2dbc2d18ab9919f905c17b967fcde/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=e03d60e9ebf2dbc2d18ab9919f905c17b967fcde", "patch": "@@ -37,18 +37,6 @@ pub enum Result<T, E> {\n }\n \n impl<T, E: ToStr> Result<T, E> {\n-    /// Convert to the `either` type\n-    ///\n-    /// `Ok` result variants are converted to `either::Right` variants, `Err`\n-    /// result variants are converted to `either::Left`.\n-    #[inline]\n-    pub fn to_either(self)-> either::Either<E, T>{\n-        match self {\n-            Ok(t) => either::Right(t),\n-            Err(e) => either::Left(e),\n-        }\n-    }\n-\n     /// Get a reference to the value out of a successful result\n     ///\n     /// # Failure\n@@ -324,6 +312,36 @@ impl<T, E> AsResult<T, E> for Result<T, E> {\n     }\n }\n \n+impl<T: Clone, E: Clone> either::ToEither<E, T> for Result<T, E> {\n+    #[inline]\n+    fn to_either(&self)-> either::Either<E, T> {\n+        match *self {\n+            Ok(ref t) => either::Right(t.clone()),\n+            Err(ref e) => either::Left(e.clone()),\n+        }\n+    }\n+}\n+\n+impl<T, E> either::IntoEither<E, T> for Result<T, E> {\n+    #[inline]\n+    fn into_either(self)-> either::Either<E, T> {\n+        match self {\n+            Ok(t) => either::Right(t),\n+            Err(e) => either::Left(e),\n+        }\n+    }\n+}\n+\n+impl<T, E> either::AsEither<E, T> for Result<T, E> {\n+    #[inline]\n+    fn as_either<'a>(&'a self)-> either::Either<&'a E, &'a T> {\n+        match *self {\n+            Ok(ref t) => either::Right(t),\n+            Err(ref e) => either::Left(e),\n+        }\n+    }\n+}\n+\n #[inline]\n #[allow(missing_doc)]\n pub fn map_opt<T, U: ToStr, V>(o_t: &Option<T>,\n@@ -403,6 +421,7 @@ pub fn fold_<T, E, Iter: Iterator<Result<T, E>>>(\n mod tests {\n     use super::*;\n \n+    use either::{IntoEither, ToEither, AsEither};\n     use either;\n     use iter::range;\n     use option::{IntoOption, ToOption, AsOption};\n@@ -483,15 +502,6 @@ mod tests {\n         assert_eq!(*foo.get_ref(), 100);\n     }\n \n-    #[test]\n-    pub fn test_to_either() {\n-        let r: Result<int, ()> = Ok(100);\n-        let err: Result<(), int> = Err(404);\n-\n-        assert_eq!(r.to_either(), either::Right(100));\n-        assert_eq!(err.to_either(), either::Left(404));\n-    }\n-\n     #[test]\n     fn test_collect() {\n         assert_eq!(collect(range(0, 0)\n@@ -588,4 +598,31 @@ mod tests {\n         let x = 404;\n         assert_eq!(err.as_result(), Err(&x));\n     }\n+\n+    #[test]\n+    pub fn test_to_either() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.to_either(), either::Right(100));\n+        assert_eq!(err.to_either(), either::Left(404));\n+    }\n+\n+    #[test]\n+    pub fn test_into_either() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.into_either(), either::Right(100));\n+        assert_eq!(err.into_either(), either::Left(404));\n+    }\n+\n+    #[test]\n+    pub fn test_as_either() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.as_either().unwrap_right(), &100);\n+        assert_eq!(err.as_either().unwrap_left(), &404);\n+    }\n }"}]}