{"sha": "36b6630771cb371ffc6aa737ae26c6c8806c7060", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2YjY2MzA3NzFjYjM3MWZmYzZhYTczN2FlMjZjNmM4ODA2YzcwNjA=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-29T10:20:20Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-01T13:15:02Z"}, "message": "Move stability queries to librustc_passes.\n\nContains:\n- check_mod_unstable_api_usage query;\n- stability_index query;\n- check_unused_or_stable features pass.", "tree": {"sha": "de6d040a74b92004bd13571570c89f312c07e2c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de6d040a74b92004bd13571570c89f312c07e2c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36b6630771cb371ffc6aa737ae26c6c8806c7060", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36b6630771cb371ffc6aa737ae26c6c8806c7060", "html_url": "https://github.com/rust-lang/rust/commit/36b6630771cb371ffc6aa737ae26c6c8806c7060", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36b6630771cb371ffc6aa737ae26c6c8806c7060/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eca7797d6b96b67039017b64129bd2bc1898ccd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/eca7797d6b96b67039017b64129bd2bc1898ccd8", "html_url": "https://github.com/rust-lang/rust/commit/eca7797d6b96b67039017b64129bd2bc1898ccd8"}], "stats": {"total": 963, "additions": 491, "deletions": 472}, "files": [{"sha": "5ef4942ac3ba9d70ff8c1ddb1e58c5b85d93a447", "filename": "src/librustc/middle/stability.rs", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/36b6630771cb371ffc6aa737ae26c6c8806c7060/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b6630771cb371ffc6aa737ae26c6c8806c7060/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=36b6630771cb371ffc6aa737ae26c6c8806c7060", "patch": "@@ -0,0 +1,410 @@\n+//! A pass that annotates every item and method with its stability level,\n+//! propagating default levels lexically from parent to children ast nodes.\n+\n+pub use self::StabilityLevel::*;\n+\n+use crate::hir::def::DefKind;\n+use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n+use crate::hir::{self, HirId};\n+use crate::lint::builtin::BuiltinLintDiagnostics;\n+use crate::lint::{self, in_derive_expansion, Lint};\n+use crate::session::{DiagnosticMessageId, Session};\n+use crate::ty::{self, TyCtxt};\n+use crate::util::nodemap::{FxHashMap, FxHashSet};\n+use errors::DiagnosticBuilder;\n+use rustc_feature::GateIssue;\n+use rustc_span::{MultiSpan, Span};\n+use syntax::ast::CRATE_NODE_ID;\n+use syntax::attr::{self, ConstStability, Deprecation, RustcDeprecation, Stability};\n+use syntax::errors::Applicability;\n+use syntax::feature_gate::feature_err_issue;\n+use syntax::symbol::{sym, Symbol};\n+\n+use std::num::NonZeroU32;\n+\n+#[derive(PartialEq, Clone, Copy, Debug)]\n+pub enum StabilityLevel {\n+    Unstable,\n+    Stable,\n+}\n+\n+impl StabilityLevel {\n+    pub fn from_attr_level(level: &attr::StabilityLevel) -> Self {\n+        if level.is_stable() { Stable } else { Unstable }\n+    }\n+}\n+\n+/// An entry in the `depr_map`.\n+#[derive(Clone, HashStable)]\n+pub struct DeprecationEntry {\n+    /// The metadata of the attribute associated with this entry.\n+    pub attr: Deprecation,\n+    /// The `DefId` where the attr was originally attached. `None` for non-local\n+    /// `DefId`'s.\n+    origin: Option<HirId>,\n+}\n+\n+impl DeprecationEntry {\n+    pub fn local(attr: Deprecation, id: HirId) -> DeprecationEntry {\n+        DeprecationEntry { attr, origin: Some(id) }\n+    }\n+\n+    pub fn external(attr: Deprecation) -> DeprecationEntry {\n+        DeprecationEntry { attr, origin: None }\n+    }\n+\n+    pub fn same_origin(&self, other: &DeprecationEntry) -> bool {\n+        match (self.origin, other.origin) {\n+            (Some(o1), Some(o2)) => o1 == o2,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+/// A stability index, giving the stability level for items and methods.\n+#[derive(HashStable)]\n+pub struct Index<'tcx> {\n+    /// This is mostly a cache, except the stabilities of local items\n+    /// are filled by the annotator.\n+    pub stab_map: FxHashMap<HirId, &'tcx Stability>,\n+    pub const_stab_map: FxHashMap<HirId, &'tcx ConstStability>,\n+    pub depr_map: FxHashMap<HirId, DeprecationEntry>,\n+\n+    /// Maps for each crate whether it is part of the staged API.\n+    pub staged_api: FxHashMap<CrateNum, bool>,\n+\n+    /// Features enabled for this crate.\n+    pub active_features: FxHashSet<Symbol>,\n+}\n+\n+impl<'tcx> Index<'tcx> {\n+    pub fn local_stability(&self, id: HirId) -> Option<&'tcx Stability> {\n+        self.stab_map.get(&id).cloned()\n+    }\n+\n+    pub fn local_const_stability(&self, id: HirId) -> Option<&'tcx ConstStability> {\n+        self.const_stab_map.get(&id).cloned()\n+    }\n+\n+    pub fn local_deprecation_entry(&self, id: HirId) -> Option<DeprecationEntry> {\n+        self.depr_map.get(&id).cloned()\n+    }\n+}\n+\n+pub fn report_unstable(\n+    sess: &Session,\n+    feature: Symbol,\n+    reason: Option<Symbol>,\n+    issue: Option<NonZeroU32>,\n+    is_soft: bool,\n+    span: Span,\n+    soft_handler: impl FnOnce(&'static lint::Lint, Span, &str),\n+) {\n+    let msg = match reason {\n+        Some(r) => format!(\"use of unstable library feature '{}': {}\", feature, r),\n+        None => format!(\"use of unstable library feature '{}'\", &feature),\n+    };\n+\n+    let msp: MultiSpan = span.into();\n+    let cm = &sess.parse_sess.source_map();\n+    let span_key = msp.primary_span().and_then(|sp: Span| {\n+        if !sp.is_dummy() {\n+            let file = cm.lookup_char_pos(sp.lo()).file;\n+            if file.name.is_macros() { None } else { Some(span) }\n+        } else {\n+            None\n+        }\n+    });\n+\n+    let error_id = (DiagnosticMessageId::StabilityId(issue), span_key, msg.clone());\n+    let fresh = sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+    if fresh {\n+        if is_soft {\n+            soft_handler(lint::builtin::SOFT_UNSTABLE, span, &msg)\n+        } else {\n+            feature_err_issue(&sess.parse_sess, feature, span, GateIssue::Library(issue), &msg)\n+                .emit();\n+        }\n+    }\n+}\n+\n+/// Checks whether an item marked with `deprecated(since=\"X\")` is currently\n+/// deprecated (i.e., whether X is not greater than the current rustc version).\n+pub fn deprecation_in_effect(since: &str) -> bool {\n+    fn parse_version(ver: &str) -> Vec<u32> {\n+        // We ignore non-integer components of the version (e.g., \"nightly\").\n+        ver.split(|c| c == '.' || c == '-').flat_map(|s| s.parse()).collect()\n+    }\n+\n+    if let Some(rustc) = option_env!(\"CFG_RELEASE\") {\n+        let since: Vec<u32> = parse_version(since);\n+        let rustc: Vec<u32> = parse_version(rustc);\n+        // We simply treat invalid `since` attributes as relating to a previous\n+        // Rust version, thus always displaying the warning.\n+        if since.len() != 3 {\n+            return true;\n+        }\n+        since <= rustc\n+    } else {\n+        // By default, a deprecation warning applies to\n+        // the current version of the compiler.\n+        true\n+    }\n+}\n+\n+pub fn deprecation_suggestion(\n+    diag: &mut DiagnosticBuilder<'_>,\n+    suggestion: Option<Symbol>,\n+    span: Span,\n+) {\n+    if let Some(suggestion) = suggestion {\n+        diag.span_suggestion(\n+            span,\n+            \"replace the use of the deprecated item\",\n+            suggestion.to_string(),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+fn deprecation_message_common(message: String, reason: Option<Symbol>) -> String {\n+    match reason {\n+        Some(reason) => format!(\"{}: {}\", message, reason),\n+        None => message,\n+    }\n+}\n+\n+pub fn deprecation_message(depr: &Deprecation, path: &str) -> (String, &'static Lint) {\n+    let message = format!(\"use of deprecated item '{}'\", path);\n+    (deprecation_message_common(message, depr.note), lint::builtin::DEPRECATED)\n+}\n+\n+pub fn rustc_deprecation_message(depr: &RustcDeprecation, path: &str) -> (String, &'static Lint) {\n+    let (message, lint) = if deprecation_in_effect(&depr.since.as_str()) {\n+        (format!(\"use of deprecated item '{}'\", path), lint::builtin::DEPRECATED)\n+    } else {\n+        (\n+            format!(\n+                \"use of item '{}' that will be deprecated in future version {}\",\n+                path, depr.since\n+            ),\n+            lint::builtin::DEPRECATED_IN_FUTURE,\n+        )\n+    };\n+    (deprecation_message_common(message, Some(depr.reason)), lint)\n+}\n+\n+pub fn early_report_deprecation(\n+    lint_buffer: &'a mut lint::LintBuffer,\n+    message: &str,\n+    suggestion: Option<Symbol>,\n+    lint: &'static Lint,\n+    span: Span,\n+) {\n+    if in_derive_expansion(span) {\n+        return;\n+    }\n+\n+    let diag = BuiltinLintDiagnostics::DeprecatedMacro(suggestion, span);\n+    lint_buffer.buffer_lint_with_diagnostic(lint, CRATE_NODE_ID, span, message, diag);\n+}\n+\n+fn late_report_deprecation(\n+    tcx: TyCtxt<'_>,\n+    message: &str,\n+    suggestion: Option<Symbol>,\n+    lint: &'static Lint,\n+    span: Span,\n+    def_id: DefId,\n+    hir_id: HirId,\n+) {\n+    if in_derive_expansion(span) {\n+        return;\n+    }\n+\n+    let mut diag = tcx.struct_span_lint_hir(lint, hir_id, span, message);\n+    if let hir::Node::Expr(_) = tcx.hir().get(hir_id) {\n+        deprecation_suggestion(&mut diag, suggestion, span);\n+    }\n+    diag.emit();\n+    if hir_id == hir::DUMMY_HIR_ID {\n+        span_bug!(span, \"emitted a {} lint with dummy HIR id: {:?}\", lint.name, def_id);\n+    }\n+}\n+\n+/// Result of `TyCtxt::eval_stability`.\n+pub enum EvalResult {\n+    /// We can use the item because it is stable or we provided the\n+    /// corresponding feature gate.\n+    Allow,\n+    /// We cannot use the item because it is unstable and we did not provide the\n+    /// corresponding feature gate.\n+    Deny { feature: Symbol, reason: Option<Symbol>, issue: Option<NonZeroU32>, is_soft: bool },\n+    /// The item does not have the `#[stable]` or `#[unstable]` marker assigned.\n+    Unmarked,\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    // See issue #38412.\n+    fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n+        // Check if `def_id` is a trait method.\n+        match self.def_kind(def_id) {\n+            Some(DefKind::Method) | Some(DefKind::AssocTy) | Some(DefKind::AssocConst) => {\n+                if let ty::TraitContainer(trait_def_id) = self.associated_item(def_id).container {\n+                    // Trait methods do not declare visibility (even\n+                    // for visibility info in cstore). Use containing\n+                    // trait instead, so methods of `pub` traits are\n+                    // themselves considered `pub`.\n+                    def_id = trait_def_id;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        let visibility = self.visibility(def_id);\n+\n+        match visibility {\n+            // Must check stability for `pub` items.\n+            ty::Visibility::Public => false,\n+\n+            // These are not visible outside crate; therefore\n+            // stability markers are irrelevant, if even present.\n+            ty::Visibility::Restricted(..) | ty::Visibility::Invisible => true,\n+        }\n+    }\n+\n+    /// Evaluates the stability of an item.\n+    ///\n+    /// Returns `EvalResult::Allow` if the item is stable, or unstable but the corresponding\n+    /// `#![feature]` has been provided. Returns `EvalResult::Deny` which describes the offending\n+    /// unstable feature otherwise.\n+    ///\n+    /// If `id` is `Some(_)`, this function will also check if the item at `def_id` has been\n+    /// deprecated. If the item is indeed deprecated, we will emit a deprecation lint attached to\n+    /// `id`.\n+    pub fn eval_stability(self, def_id: DefId, id: Option<HirId>, span: Span) -> EvalResult {\n+        // Deprecated attributes apply in-crate and cross-crate.\n+        if let Some(id) = id {\n+            if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n+                let parent_def_id = self.hir().local_def_id(self.hir().get_parent_item(id));\n+                let skip = self\n+                    .lookup_deprecation_entry(parent_def_id)\n+                    .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n+\n+                if !skip {\n+                    let (message, lint) =\n+                        deprecation_message(&depr_entry.attr, &self.def_path_str(def_id));\n+                    late_report_deprecation(self, &message, None, lint, span, def_id, id);\n+                }\n+            };\n+        }\n+\n+        let is_staged_api =\n+            self.lookup_stability(DefId { index: CRATE_DEF_INDEX, ..def_id }).is_some();\n+        if !is_staged_api {\n+            return EvalResult::Allow;\n+        }\n+\n+        let stability = self.lookup_stability(def_id);\n+        debug!(\n+            \"stability: \\\n+                inspecting def_id={:?} span={:?} of stability={:?}\",\n+            def_id, span, stability\n+        );\n+\n+        if let Some(id) = id {\n+            if let Some(stability) = stability {\n+                if let Some(depr) = &stability.rustc_depr {\n+                    let (message, lint) =\n+                        rustc_deprecation_message(depr, &self.def_path_str(def_id));\n+                    late_report_deprecation(\n+                        self,\n+                        &message,\n+                        depr.suggestion,\n+                        lint,\n+                        span,\n+                        def_id,\n+                        id,\n+                    );\n+                }\n+            }\n+        }\n+\n+        // Only the cross-crate scenario matters when checking unstable APIs\n+        let cross_crate = !def_id.is_local();\n+        if !cross_crate {\n+            return EvalResult::Allow;\n+        }\n+\n+        // Issue #38412: private items lack stability markers.\n+        if self.skip_stability_check_due_to_privacy(def_id) {\n+            return EvalResult::Allow;\n+        }\n+\n+        match stability {\n+            Some(&Stability {\n+                level: attr::Unstable { reason, issue, is_soft }, feature, ..\n+            }) => {\n+                if span.allows_unstable(feature) {\n+                    debug!(\"stability: skipping span={:?} since it is internal\", span);\n+                    return EvalResult::Allow;\n+                }\n+                if self.stability().active_features.contains(&feature) {\n+                    return EvalResult::Allow;\n+                }\n+\n+                // When we're compiling the compiler itself we may pull in\n+                // crates from crates.io, but those crates may depend on other\n+                // crates also pulled in from crates.io. We want to ideally be\n+                // able to compile everything without requiring upstream\n+                // modifications, so in the case that this looks like a\n+                // `rustc_private` crate (e.g., a compiler crate) and we also have\n+                // the `-Z force-unstable-if-unmarked` flag present (we're\n+                // compiling a compiler crate), then let this missing feature\n+                // annotation slide.\n+                if feature == sym::rustc_private && issue == NonZeroU32::new(27812) {\n+                    if self.sess.opts.debugging_opts.force_unstable_if_unmarked {\n+                        return EvalResult::Allow;\n+                    }\n+                }\n+\n+                EvalResult::Deny { feature, reason, issue, is_soft }\n+            }\n+            Some(_) => {\n+                // Stable APIs are always ok to call and deprecated APIs are\n+                // handled by the lint emitting logic above.\n+                EvalResult::Allow\n+            }\n+            None => EvalResult::Unmarked,\n+        }\n+    }\n+\n+    /// Checks if an item is stable or error out.\n+    ///\n+    /// If the item defined by `def_id` is unstable and the corresponding `#![feature]` does not\n+    /// exist, emits an error.\n+    ///\n+    /// Additionally, this function will also check if the item is deprecated. If so, and `id` is\n+    /// not `None`, a deprecated lint attached to `id` will be emitted.\n+    pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n+        let soft_handler =\n+            |lint, span, msg: &_| self.lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, msg);\n+        match self.eval_stability(def_id, id, span) {\n+            EvalResult::Allow => {}\n+            EvalResult::Deny { feature, reason, issue, is_soft } => {\n+                report_unstable(self.sess, feature, reason, issue, is_soft, span, soft_handler)\n+            }\n+            EvalResult::Unmarked => {\n+                // The API could be uncallable for other reasons, for example when a private module\n+                // was referenced.\n+                self.sess.delay_span_bug(span, &format!(\"encountered unmarked API: {:?}\", def_id));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n+        self.lookup_deprecation_entry(id).map(|depr| depr.attr)\n+    }\n+}"}, {"sha": "d83a720170b03e1d1517c8fcb0472951bcb5dcb6", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36b6630771cb371ffc6aa737ae26c6c8806c7060/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b6630771cb371ffc6aa737ae26c6c8806c7060/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=36b6630771cb371ffc6aa737ae26c6c8806c7060", "patch": "@@ -2765,10 +2765,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         Lrc::new(tcx.glob_map.get(&id).cloned().unwrap_or_default())\n     };\n \n-    providers.stability_index = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.arena.alloc(stability::Index::new(tcx))\n-    };\n     providers.lookup_stability = |tcx, id| {\n         assert_eq!(id.krate, LOCAL_CRATE);\n         let id = tcx.hir().definitions().def_index_to_hir_id(id.index);"}, {"sha": "670ca30faf2c5a0132475f79e5eed2c81c072e96", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36b6630771cb371ffc6aa737ae26c6c8806c7060/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b6630771cb371ffc6aa737ae26c6c8806c7060/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=36b6630771cb371ffc6aa737ae26c6c8806c7060", "patch": "@@ -8,8 +8,8 @@ use rustc::dep_graph::DepGraph;\n use rustc::hir;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::lint;\n+use rustc::middle;\n use rustc::middle::cstore::{CrateStore, MetadataLoader, MetadataLoaderDyn};\n-use rustc::middle::{self, stability};\n use rustc::session::config::{self, CrateType, Input, OutputFilenames, OutputType};\n use rustc::session::config::{PpMode, PpSourceMode};\n use rustc::session::search_paths::PathKind;\n@@ -687,7 +687,6 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     typeck::provide(providers);\n     ty::provide(providers);\n     traits::provide(providers);\n-    stability::provide(providers);\n     rustc_passes::provide(providers);\n     rustc_resolve::provide(providers);\n     rustc_traits::provide(providers);\n@@ -881,7 +880,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                     },\n                     {\n                         time(sess, \"unused lib feature checking\", || {\n-                            stability::check_unused_or_stable_features(tcx)\n+                            rustc_passes::stability::check_unused_or_stable_features(tcx)\n                         });\n                     },\n                     {"}, {"sha": "a692c45ced40bedf4139cd40993653855665c3e9", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36b6630771cb371ffc6aa737ae26c6c8806c7060/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b6630771cb371ffc6aa737ae26c6c8806c7060/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=36b6630771cb371ffc6aa737ae26c6c8806c7060", "patch": "@@ -32,6 +32,7 @@ mod liveness;\n pub mod loops;\n mod reachable;\n mod region;\n+pub mod stability;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     check_const::provide(providers);\n@@ -43,4 +44,5 @@ pub fn provide(providers: &mut Providers<'_>) {\n     intrinsicck::provide(providers);\n     reachable::provide(providers);\n     region::provide(providers);\n+    stability::provide(providers);\n }"}, {"sha": "fcbc742b9a00b0b7253c9318ae7cc3ddf888ed97", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 77, "deletions": 465, "changes": 542, "blob_url": "https://github.com/rust-lang/rust/blob/36b6630771cb371ffc6aa737ae26c6c8806c7060/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b6630771cb371ffc6aa737ae26c6c8806c7060/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=36b6630771cb371ffc6aa737ae26c6c8806c7060", "patch": "@@ -1,26 +1,21 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n-pub use self::StabilityLevel::*;\n-\n-use crate::hir::def::{DefKind, Res};\n-use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use crate::hir::{self, Generics, HirId, Item, StructField, Variant};\n-use crate::lint::builtin::BuiltinLintDiagnostics;\n-use crate::lint::{self, in_derive_expansion, Lint};\n-use crate::middle::privacy::AccessLevels;\n-use crate::session::{DiagnosticMessageId, Session};\n-use crate::ty::query::Providers;\n-use crate::ty::{self, TyCtxt};\n-use crate::util::nodemap::{FxHashMap, FxHashSet};\n-use errors::DiagnosticBuilder;\n-use rustc_feature::GateIssue;\n-use rustc_span::{MultiSpan, Span};\n-use syntax::ast::{Attribute, CRATE_NODE_ID};\n-use syntax::attr::{self, ConstStability, Deprecation, RustcDeprecation, Stability};\n-use syntax::errors::Applicability;\n-use syntax::feature_gate::{feature_err, feature_err_issue};\n+use rustc::hir::def::{DefKind, Res};\n+use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::hir::{self, Generics, HirId, Item, StructField, Variant};\n+use rustc::lint;\n+use rustc::middle::privacy::AccessLevels;\n+use rustc::middle::stability::{DeprecationEntry, Index};\n+use rustc::session::Session;\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_span::Span;\n+use syntax::ast::Attribute;\n+use syntax::attr::{self, Stability};\n+use syntax::feature_gate::feature_err;\n use syntax::symbol::{sym, Symbol};\n \n use std::cmp::Ordering;\n@@ -29,18 +24,6 @@ use std::num::NonZeroU32;\n \n use rustc_error_codes::*;\n \n-#[derive(PartialEq, Clone, Copy, Debug)]\n-pub enum StabilityLevel {\n-    Unstable,\n-    Stable,\n-}\n-\n-impl StabilityLevel {\n-    pub fn from_attr_level(level: &attr::StabilityLevel) -> Self {\n-        if level.is_stable() { Stable } else { Unstable }\n-    }\n-}\n-\n #[derive(PartialEq)]\n enum AnnotationKind {\n     // Annotation is required if not inherited from unstable parents\n@@ -51,49 +34,6 @@ enum AnnotationKind {\n     Container,\n }\n \n-/// An entry in the `depr_map`.\n-#[derive(Clone, HashStable)]\n-pub struct DeprecationEntry {\n-    /// The metadata of the attribute associated with this entry.\n-    pub attr: Deprecation,\n-    /// The `DefId` where the attr was originally attached. `None` for non-local\n-    /// `DefId`'s.\n-    origin: Option<HirId>,\n-}\n-\n-impl DeprecationEntry {\n-    fn local(attr: Deprecation, id: HirId) -> DeprecationEntry {\n-        DeprecationEntry { attr, origin: Some(id) }\n-    }\n-\n-    pub fn external(attr: Deprecation) -> DeprecationEntry {\n-        DeprecationEntry { attr, origin: None }\n-    }\n-\n-    pub fn same_origin(&self, other: &DeprecationEntry) -> bool {\n-        match (self.origin, other.origin) {\n-            (Some(o1), Some(o2)) => o1 == o2,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-/// A stability index, giving the stability level for items and methods.\n-#[derive(HashStable)]\n-pub struct Index<'tcx> {\n-    /// This is mostly a cache, except the stabilities of local items\n-    /// are filled by the annotator.\n-    stab_map: FxHashMap<HirId, &'tcx Stability>,\n-    const_stab_map: FxHashMap<HirId, &'tcx ConstStability>,\n-    depr_map: FxHashMap<HirId, DeprecationEntry>,\n-\n-    /// Maps for each crate whether it is part of the staged API.\n-    staged_api: FxHashMap<CrateNum, bool>,\n-\n-    /// Features enabled for this crate.\n-    active_features: FxHashSet<Symbol>,\n-}\n-\n // A private tree-walker for producing an Index.\n struct Annotator<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -401,84 +341,70 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> Index<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n-        let is_staged_api =\n-            tcx.sess.opts.debugging_opts.force_unstable_if_unmarked || tcx.features().staged_api;\n-        let mut staged_api = FxHashMap::default();\n-        staged_api.insert(LOCAL_CRATE, is_staged_api);\n-        let mut index = Index {\n-            staged_api,\n-            stab_map: Default::default(),\n-            const_stab_map: Default::default(),\n-            depr_map: Default::default(),\n-            active_features: Default::default(),\n-        };\n+fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n+    let is_staged_api =\n+        tcx.sess.opts.debugging_opts.force_unstable_if_unmarked || tcx.features().staged_api;\n+    let mut staged_api = FxHashMap::default();\n+    staged_api.insert(LOCAL_CRATE, is_staged_api);\n+    let mut index = Index {\n+        staged_api,\n+        stab_map: Default::default(),\n+        const_stab_map: Default::default(),\n+        depr_map: Default::default(),\n+        active_features: Default::default(),\n+    };\n \n-        let active_lib_features = &tcx.features().declared_lib_features;\n-        let active_lang_features = &tcx.features().declared_lang_features;\n-\n-        // Put the active features into a map for quick lookup.\n-        index.active_features = active_lib_features\n-            .iter()\n-            .map(|&(ref s, ..)| s.clone())\n-            .chain(active_lang_features.iter().map(|&(ref s, ..)| s.clone()))\n-            .collect();\n-\n-        {\n-            let krate = tcx.hir().krate();\n-            let mut annotator = Annotator {\n-                tcx,\n-                index: &mut index,\n-                parent_stab: None,\n-                parent_depr: None,\n-                in_trait_impl: false,\n-            };\n-\n-            // If the `-Z force-unstable-if-unmarked` flag is passed then we provide\n-            // a parent stability annotation which indicates that this is private\n-            // with the `rustc_private` feature. This is intended for use when\n-            // compiling librustc crates themselves so we can leverage crates.io\n-            // while maintaining the invariant that all sysroot crates are unstable\n-            // by default and are unable to be used.\n-            if tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n-                let reason = \"this crate is being loaded from the sysroot, an \\\n-                              unstable location; did you mean to load this crate \\\n-                              from crates.io via `Cargo.toml` instead?\";\n-                let stability = tcx.intern_stability(Stability {\n-                    level: attr::StabilityLevel::Unstable {\n-                        reason: Some(Symbol::intern(reason)),\n-                        issue: NonZeroU32::new(27812),\n-                        is_soft: false,\n-                    },\n-                    feature: sym::rustc_private,\n-                    rustc_depr: None,\n-                });\n-                annotator.parent_stab = Some(stability);\n-            }\n+    let active_lib_features = &tcx.features().declared_lib_features;\n+    let active_lang_features = &tcx.features().declared_lang_features;\n \n-            annotator.annotate(\n-                hir::CRATE_HIR_ID,\n-                &krate.attrs,\n-                krate.span,\n-                AnnotationKind::Required,\n-                |v| intravisit::walk_crate(v, krate),\n-            );\n-        }\n-        return index;\n-    }\n+    // Put the active features into a map for quick lookup.\n+    index.active_features = active_lib_features\n+        .iter()\n+        .map(|&(ref s, ..)| s.clone())\n+        .chain(active_lang_features.iter().map(|&(ref s, ..)| s.clone()))\n+        .collect();\n \n-    pub fn local_stability(&self, id: HirId) -> Option<&'tcx Stability> {\n-        self.stab_map.get(&id).cloned()\n-    }\n+    {\n+        let krate = tcx.hir().krate();\n+        let mut annotator = Annotator {\n+            tcx,\n+            index: &mut index,\n+            parent_stab: None,\n+            parent_depr: None,\n+            in_trait_impl: false,\n+        };\n \n-    pub fn local_const_stability(&self, id: HirId) -> Option<&'tcx ConstStability> {\n-        self.const_stab_map.get(&id).cloned()\n-    }\n+        // If the `-Z force-unstable-if-unmarked` flag is passed then we provide\n+        // a parent stability annotation which indicates that this is private\n+        // with the `rustc_private` feature. This is intended for use when\n+        // compiling librustc crates themselves so we can leverage crates.io\n+        // while maintaining the invariant that all sysroot crates are unstable\n+        // by default and are unable to be used.\n+        if tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n+            let reason = \"this crate is being loaded from the sysroot, an \\\n+                          unstable location; did you mean to load this crate \\\n+                          from crates.io via `Cargo.toml` instead?\";\n+            let stability = tcx.intern_stability(Stability {\n+                level: attr::StabilityLevel::Unstable {\n+                    reason: Some(Symbol::intern(reason)),\n+                    issue: NonZeroU32::new(27812),\n+                    is_soft: false,\n+                },\n+                feature: sym::rustc_private,\n+                rustc_depr: None,\n+            });\n+            annotator.parent_stab = Some(stability);\n+        }\n \n-    pub fn local_deprecation_entry(&self, id: HirId) -> Option<DeprecationEntry> {\n-        self.depr_map.get(&id).cloned()\n+        annotator.annotate(\n+            hir::CRATE_HIR_ID,\n+            &krate.attrs,\n+            krate.span,\n+            AnnotationKind::Required,\n+            |v| intravisit::walk_crate(v, krate),\n+        );\n     }\n+    return index;\n }\n \n /// Cross-references the feature names of unstable APIs with enabled\n@@ -487,326 +413,18 @@ fn check_mod_unstable_api_usage(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut Checker { tcx }.as_deep_visitor());\n }\n \n-pub fn provide(providers: &mut Providers<'_>) {\n+pub(crate) fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers { check_mod_unstable_api_usage, ..*providers };\n-}\n-\n-pub fn report_unstable(\n-    sess: &Session,\n-    feature: Symbol,\n-    reason: Option<Symbol>,\n-    issue: Option<NonZeroU32>,\n-    is_soft: bool,\n-    span: Span,\n-    soft_handler: impl FnOnce(&'static lint::Lint, Span, &str),\n-) {\n-    let msg = match reason {\n-        Some(r) => format!(\"use of unstable library feature '{}': {}\", feature, r),\n-        None => format!(\"use of unstable library feature '{}'\", &feature),\n-    };\n-\n-    let msp: MultiSpan = span.into();\n-    let cm = &sess.parse_sess.source_map();\n-    let span_key = msp.primary_span().and_then(|sp: Span| {\n-        if !sp.is_dummy() {\n-            let file = cm.lookup_char_pos(sp.lo()).file;\n-            if file.name.is_macros() { None } else { Some(span) }\n-        } else {\n-            None\n-        }\n-    });\n-\n-    let error_id = (DiagnosticMessageId::StabilityId(issue), span_key, msg.clone());\n-    let fresh = sess.one_time_diagnostics.borrow_mut().insert(error_id);\n-    if fresh {\n-        if is_soft {\n-            soft_handler(lint::builtin::SOFT_UNSTABLE, span, &msg)\n-        } else {\n-            feature_err_issue(&sess.parse_sess, feature, span, GateIssue::Library(issue), &msg)\n-                .emit();\n-        }\n-    }\n-}\n-\n-/// Checks whether an item marked with `deprecated(since=\"X\")` is currently\n-/// deprecated (i.e., whether X is not greater than the current rustc version).\n-pub fn deprecation_in_effect(since: &str) -> bool {\n-    fn parse_version(ver: &str) -> Vec<u32> {\n-        // We ignore non-integer components of the version (e.g., \"nightly\").\n-        ver.split(|c| c == '.' || c == '-').flat_map(|s| s.parse()).collect()\n-    }\n-\n-    if let Some(rustc) = option_env!(\"CFG_RELEASE\") {\n-        let since: Vec<u32> = parse_version(since);\n-        let rustc: Vec<u32> = parse_version(rustc);\n-        // We simply treat invalid `since` attributes as relating to a previous\n-        // Rust version, thus always displaying the warning.\n-        if since.len() != 3 {\n-            return true;\n-        }\n-        since <= rustc\n-    } else {\n-        // By default, a deprecation warning applies to\n-        // the current version of the compiler.\n-        true\n-    }\n-}\n-\n-pub fn deprecation_suggestion(\n-    diag: &mut DiagnosticBuilder<'_>,\n-    suggestion: Option<Symbol>,\n-    span: Span,\n-) {\n-    if let Some(suggestion) = suggestion {\n-        diag.span_suggestion(\n-            span,\n-            \"replace the use of the deprecated item\",\n-            suggestion.to_string(),\n-            Applicability::MachineApplicable,\n-        );\n-    }\n-}\n-\n-fn deprecation_message_common(message: String, reason: Option<Symbol>) -> String {\n-    match reason {\n-        Some(reason) => format!(\"{}: {}\", message, reason),\n-        None => message,\n-    }\n-}\n-\n-pub fn deprecation_message(depr: &Deprecation, path: &str) -> (String, &'static Lint) {\n-    let message = format!(\"use of deprecated item '{}'\", path);\n-    (deprecation_message_common(message, depr.note), lint::builtin::DEPRECATED)\n-}\n-\n-pub fn rustc_deprecation_message(depr: &RustcDeprecation, path: &str) -> (String, &'static Lint) {\n-    let (message, lint) = if deprecation_in_effect(&depr.since.as_str()) {\n-        (format!(\"use of deprecated item '{}'\", path), lint::builtin::DEPRECATED)\n-    } else {\n-        (\n-            format!(\n-                \"use of item '{}' that will be deprecated in future version {}\",\n-                path, depr.since\n-            ),\n-            lint::builtin::DEPRECATED_IN_FUTURE,\n-        )\n+    providers.stability_index = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        tcx.arena.alloc(new_index(tcx))\n     };\n-    (deprecation_message_common(message, Some(depr.reason)), lint)\n-}\n-\n-pub fn early_report_deprecation(\n-    lint_buffer: &'a mut lint::LintBuffer,\n-    message: &str,\n-    suggestion: Option<Symbol>,\n-    lint: &'static Lint,\n-    span: Span,\n-) {\n-    if in_derive_expansion(span) {\n-        return;\n-    }\n-\n-    let diag = BuiltinLintDiagnostics::DeprecatedMacro(suggestion, span);\n-    lint_buffer.buffer_lint_with_diagnostic(lint, CRATE_NODE_ID, span, message, diag);\n-}\n-\n-fn late_report_deprecation(\n-    tcx: TyCtxt<'_>,\n-    message: &str,\n-    suggestion: Option<Symbol>,\n-    lint: &'static Lint,\n-    span: Span,\n-    def_id: DefId,\n-    hir_id: HirId,\n-) {\n-    if in_derive_expansion(span) {\n-        return;\n-    }\n-\n-    let mut diag = tcx.struct_span_lint_hir(lint, hir_id, span, message);\n-    if let hir::Node::Expr(_) = tcx.hir().get(hir_id) {\n-        deprecation_suggestion(&mut diag, suggestion, span);\n-    }\n-    diag.emit();\n-    if hir_id == hir::DUMMY_HIR_ID {\n-        span_bug!(span, \"emitted a {} lint with dummy HIR id: {:?}\", lint.name, def_id);\n-    }\n }\n \n struct Checker<'tcx> {\n     tcx: TyCtxt<'tcx>,\n }\n \n-/// Result of `TyCtxt::eval_stability`.\n-pub enum EvalResult {\n-    /// We can use the item because it is stable or we provided the\n-    /// corresponding feature gate.\n-    Allow,\n-    /// We cannot use the item because it is unstable and we did not provide the\n-    /// corresponding feature gate.\n-    Deny { feature: Symbol, reason: Option<Symbol>, issue: Option<NonZeroU32>, is_soft: bool },\n-    /// The item does not have the `#[stable]` or `#[unstable]` marker assigned.\n-    Unmarked,\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    // See issue #38412.\n-    fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n-        // Check if `def_id` is a trait method.\n-        match self.def_kind(def_id) {\n-            Some(DefKind::Method) | Some(DefKind::AssocTy) | Some(DefKind::AssocConst) => {\n-                if let ty::TraitContainer(trait_def_id) = self.associated_item(def_id).container {\n-                    // Trait methods do not declare visibility (even\n-                    // for visibility info in cstore). Use containing\n-                    // trait instead, so methods of `pub` traits are\n-                    // themselves considered `pub`.\n-                    def_id = trait_def_id;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        let visibility = self.visibility(def_id);\n-\n-        match visibility {\n-            // Must check stability for `pub` items.\n-            ty::Visibility::Public => false,\n-\n-            // These are not visible outside crate; therefore\n-            // stability markers are irrelevant, if even present.\n-            ty::Visibility::Restricted(..) | ty::Visibility::Invisible => true,\n-        }\n-    }\n-\n-    /// Evaluates the stability of an item.\n-    ///\n-    /// Returns `EvalResult::Allow` if the item is stable, or unstable but the corresponding\n-    /// `#![feature]` has been provided. Returns `EvalResult::Deny` which describes the offending\n-    /// unstable feature otherwise.\n-    ///\n-    /// If `id` is `Some(_)`, this function will also check if the item at `def_id` has been\n-    /// deprecated. If the item is indeed deprecated, we will emit a deprecation lint attached to\n-    /// `id`.\n-    pub fn eval_stability(self, def_id: DefId, id: Option<HirId>, span: Span) -> EvalResult {\n-        // Deprecated attributes apply in-crate and cross-crate.\n-        if let Some(id) = id {\n-            if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n-                let parent_def_id = self.hir().local_def_id(self.hir().get_parent_item(id));\n-                let skip = self\n-                    .lookup_deprecation_entry(parent_def_id)\n-                    .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n-\n-                if !skip {\n-                    let (message, lint) =\n-                        deprecation_message(&depr_entry.attr, &self.def_path_str(def_id));\n-                    late_report_deprecation(self, &message, None, lint, span, def_id, id);\n-                }\n-            };\n-        }\n-\n-        let is_staged_api =\n-            self.lookup_stability(DefId { index: CRATE_DEF_INDEX, ..def_id }).is_some();\n-        if !is_staged_api {\n-            return EvalResult::Allow;\n-        }\n-\n-        let stability = self.lookup_stability(def_id);\n-        debug!(\n-            \"stability: \\\n-                inspecting def_id={:?} span={:?} of stability={:?}\",\n-            def_id, span, stability\n-        );\n-\n-        if let Some(id) = id {\n-            if let Some(stability) = stability {\n-                if let Some(depr) = &stability.rustc_depr {\n-                    let (message, lint) =\n-                        rustc_deprecation_message(depr, &self.def_path_str(def_id));\n-                    late_report_deprecation(\n-                        self,\n-                        &message,\n-                        depr.suggestion,\n-                        lint,\n-                        span,\n-                        def_id,\n-                        id,\n-                    );\n-                }\n-            }\n-        }\n-\n-        // Only the cross-crate scenario matters when checking unstable APIs\n-        let cross_crate = !def_id.is_local();\n-        if !cross_crate {\n-            return EvalResult::Allow;\n-        }\n-\n-        // Issue #38412: private items lack stability markers.\n-        if self.skip_stability_check_due_to_privacy(def_id) {\n-            return EvalResult::Allow;\n-        }\n-\n-        match stability {\n-            Some(&Stability {\n-                level: attr::Unstable { reason, issue, is_soft }, feature, ..\n-            }) => {\n-                if span.allows_unstable(feature) {\n-                    debug!(\"stability: skipping span={:?} since it is internal\", span);\n-                    return EvalResult::Allow;\n-                }\n-                if self.stability().active_features.contains(&feature) {\n-                    return EvalResult::Allow;\n-                }\n-\n-                // When we're compiling the compiler itself we may pull in\n-                // crates from crates.io, but those crates may depend on other\n-                // crates also pulled in from crates.io. We want to ideally be\n-                // able to compile everything without requiring upstream\n-                // modifications, so in the case that this looks like a\n-                // `rustc_private` crate (e.g., a compiler crate) and we also have\n-                // the `-Z force-unstable-if-unmarked` flag present (we're\n-                // compiling a compiler crate), then let this missing feature\n-                // annotation slide.\n-                if feature == sym::rustc_private && issue == NonZeroU32::new(27812) {\n-                    if self.sess.opts.debugging_opts.force_unstable_if_unmarked {\n-                        return EvalResult::Allow;\n-                    }\n-                }\n-\n-                EvalResult::Deny { feature, reason, issue, is_soft }\n-            }\n-            Some(_) => {\n-                // Stable APIs are always ok to call and deprecated APIs are\n-                // handled by the lint emitting logic above.\n-                EvalResult::Allow\n-            }\n-            None => EvalResult::Unmarked,\n-        }\n-    }\n-\n-    /// Checks if an item is stable or error out.\n-    ///\n-    /// If the item defined by `def_id` is unstable and the corresponding `#![feature]` does not\n-    /// exist, emits an error.\n-    ///\n-    /// Additionally, this function will also check if the item is deprecated. If so, and `id` is\n-    /// not `None`, a deprecated lint attached to `id` will be emitted.\n-    pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n-        let soft_handler =\n-            |lint, span, msg: &_| self.lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, msg);\n-        match self.eval_stability(def_id, id, span) {\n-            EvalResult::Allow => {}\n-            EvalResult::Deny { feature, reason, issue, is_soft } => {\n-                report_unstable(self.sess, feature, reason, issue, is_soft, span, soft_handler)\n-            }\n-            EvalResult::Unmarked => {\n-                // The API could be uncallable for other reasons, for example when a private module\n-                // was referenced.\n-                self.sess.delay_span_bug(span, &format!(\"encountered unmarked API: {:?}\", def_id));\n-            }\n-        }\n-    }\n-}\n-\n impl Visitor<'tcx> for Checker<'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n@@ -894,12 +512,6 @@ impl Visitor<'tcx> for Checker<'tcx> {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n-        self.lookup_deprecation_entry(id).map(|depr| depr.attr)\n-    }\n-}\n-\n /// Given the list of enabled features that were not language features (i.e., that\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them."}]}