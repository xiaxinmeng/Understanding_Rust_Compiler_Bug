{"sha": "d6bee55855093d86c7e110116beebb369cd89654", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YmVlNTU4NTUwOTNkODZjN2UxMTAxMTZiZWViYjM2OWNkODk2NTQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-01T14:42:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-01T14:42:50Z"}, "message": "Rollup merge of #73776 - aszenz:refactor_mir_module, r=wesleywiser\n\nMove terminator to new module\n\nMoves terminator types from `librustc_middle/mir/mod.rs` into submodule\nFixes #73723", "tree": {"sha": "7f2a41870f824bdf48e99c39e26c1ed5929405f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f2a41870f824bdf48e99c39e26c1ed5929405f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6bee55855093d86c7e110116beebb369cd89654", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/KDqCRBK7hj4Ov3rIwAAdHIIADwND7le0uA8CCyCfMvwnvJM\nF1UeFn+Aas/Nvo0xIaLmadHuweRZhBTxvm29YFmZv47Nd5bWdFZ7NmDCQbAG5N00\n6bELFbKNzDgRLqvNwPI5W0oSN2y3fHEaFzyHsRFjdsGY/NZ5xJfJ0eR8nTrE8tkk\njOCYRogY4finJtHo/+WwQi8UkqxtSFwFyXzHjkHtAg7nB3JWWnDLgm6CKyLPyRI2\nJJfXZZxu5jI3A6ICLoRwqaG0UEb9sAlOIkF1eqaOt8i0ic8j5e4mMj2MpnS5xF2h\npT5yWjfw92ygvcW5FnCrKv0AHWYlTOwZgiwqRmHiYMdqPnf7OUs2EUkB61ROcOA=\n=kodX\n-----END PGP SIGNATURE-----\n", "payload": "tree 7f2a41870f824bdf48e99c39e26c1ed5929405f6\nparent 3951a98ec5a53e527f0b2d1791b3db31738a107a\nparent cf398a33ebff501a01c9c91fe5615992c936d292\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593614570 -0700\ncommitter GitHub <noreply@github.com> 1593614570 -0700\n\nRollup merge of #73776 - aszenz:refactor_mir_module, r=wesleywiser\n\nMove terminator to new module\n\nMoves terminator types from `librustc_middle/mir/mod.rs` into submodule\nFixes #73723\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6bee55855093d86c7e110116beebb369cd89654", "html_url": "https://github.com/rust-lang/rust/commit/d6bee55855093d86c7e110116beebb369cd89654", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6bee55855093d86c7e110116beebb369cd89654/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3951a98ec5a53e527f0b2d1791b3db31738a107a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3951a98ec5a53e527f0b2d1791b3db31738a107a", "html_url": "https://github.com/rust-lang/rust/commit/3951a98ec5a53e527f0b2d1791b3db31738a107a"}, {"sha": "cf398a33ebff501a01c9c91fe5615992c936d292", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf398a33ebff501a01c9c91fe5615992c936d292", "html_url": "https://github.com/rust-lang/rust/commit/cf398a33ebff501a01c9c91fe5615992c936d292"}], "stats": {"total": 1001, "additions": 509, "deletions": 492}, "files": [{"sha": "ae59f8c542d8c5ece510ba471023358990abe0ab", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 492, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/d6bee55855093d86c7e110116beebb369cd89654/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bee55855093d86c7e110116beebb369cd89654/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=d6bee55855093d86c7e110116beebb369cd89654", "patch": "@@ -19,7 +19,6 @@ use rustc_target::abi::VariantIdx;\n \n use polonius_engine::Atom;\n pub use rustc_ast::ast::Mutability;\n-use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors};\n@@ -45,6 +44,8 @@ pub mod mono;\n mod predecessors;\n mod query;\n pub mod tcx;\n+pub mod terminator;\n+pub use terminator::*;\n pub mod traversal;\n mod type_foldable;\n pub mod visit;\n@@ -1046,191 +1047,6 @@ pub struct BasicBlockData<'tcx> {\n     pub is_cleanup: bool,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Terminator<'tcx> {\n-    pub source_info: SourceInfo,\n-    pub kind: TerminatorKind<'tcx>,\n-}\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n-pub enum TerminatorKind<'tcx> {\n-    /// Block should have one successor in the graph; we jump there.\n-    Goto { target: BasicBlock },\n-\n-    /// Operand evaluates to an integer; jump depending on its value\n-    /// to one of the targets, and otherwise fallback to `otherwise`.\n-    SwitchInt {\n-        /// The discriminant value being tested.\n-        discr: Operand<'tcx>,\n-\n-        /// The type of value being tested.\n-        /// This is always the same as the type of `discr`.\n-        /// FIXME: remove this redundant information. Currently, it is relied on by pretty-printing.\n-        switch_ty: Ty<'tcx>,\n-\n-        /// Possible values. The locations to branch to in each case\n-        /// are found in the corresponding indices from the `targets` vector.\n-        values: Cow<'tcx, [u128]>,\n-\n-        /// Possible branch sites. The last element of this vector is used\n-        /// for the otherwise branch, so targets.len() == values.len() + 1\n-        /// should hold.\n-        //\n-        // This invariant is quite non-obvious and also could be improved.\n-        // One way to make this invariant is to have something like this instead:\n-        //\n-        // branches: Vec<(ConstInt, BasicBlock)>,\n-        // otherwise: Option<BasicBlock> // exhaustive if None\n-        //\n-        // However we\u2019ve decided to keep this as-is until we figure a case\n-        // where some other approach seems to be strictly better than other.\n-        targets: Vec<BasicBlock>,\n-    },\n-\n-    /// Indicates that the landing pad is finished and unwinding should\n-    /// continue. Emitted by `build::scope::diverge_cleanup`.\n-    Resume,\n-\n-    /// Indicates that the landing pad is finished and that the process\n-    /// should abort. Used to prevent unwinding for foreign items.\n-    Abort,\n-\n-    /// Indicates a normal return. The return place should have\n-    /// been filled in before this executes. This can occur multiple times\n-    /// in different basic blocks.\n-    Return,\n-\n-    /// Indicates a terminator that can never be reached.\n-    Unreachable,\n-\n-    /// Drop the `Place`.\n-    Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n-\n-    /// Drop the `Place` and assign the new value over it. This ensures\n-    /// that the assignment to `P` occurs *even if* the destructor for\n-    /// place unwinds. Its semantics are best explained by the\n-    /// elaboration:\n-    ///\n-    /// ```\n-    /// BB0 {\n-    ///   DropAndReplace(P <- V, goto BB1, unwind BB2)\n-    /// }\n-    /// ```\n-    ///\n-    /// becomes\n-    ///\n-    /// ```\n-    /// BB0 {\n-    ///   Drop(P, goto BB1, unwind BB2)\n-    /// }\n-    /// BB1 {\n-    ///   // P is now uninitialized\n-    ///   P <- V\n-    /// }\n-    /// BB2 {\n-    ///   // P is now uninitialized -- its dtor panicked\n-    ///   P <- V\n-    /// }\n-    /// ```\n-    DropAndReplace {\n-        place: Place<'tcx>,\n-        value: Operand<'tcx>,\n-        target: BasicBlock,\n-        unwind: Option<BasicBlock>,\n-    },\n-\n-    /// Block ends with a call of a converging function.\n-    Call {\n-        /// The function that\u2019s being called.\n-        func: Operand<'tcx>,\n-        /// Arguments the function is called with.\n-        /// These are owned by the callee, which is free to modify them.\n-        /// This allows the memory occupied by \"by-value\" arguments to be\n-        /// reused across function calls without duplicating the contents.\n-        args: Vec<Operand<'tcx>>,\n-        /// Destination for the return value. If some, the call is converging.\n-        destination: Option<(Place<'tcx>, BasicBlock)>,\n-        /// Cleanups to be done if the call unwinds.\n-        cleanup: Option<BasicBlock>,\n-        /// `true` if this is from a call in HIR rather than from an overloaded\n-        /// operator. True for overloaded function call.\n-        from_hir_call: bool,\n-        /// This `Span` is the span of the function, without the dot and receiver\n-        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n-        fn_span: Span,\n-    },\n-\n-    /// Jump to the target if the condition has the expected value,\n-    /// otherwise panic with a message and a cleanup target.\n-    Assert {\n-        cond: Operand<'tcx>,\n-        expected: bool,\n-        msg: AssertMessage<'tcx>,\n-        target: BasicBlock,\n-        cleanup: Option<BasicBlock>,\n-    },\n-\n-    /// A suspend point.\n-    Yield {\n-        /// The value to return.\n-        value: Operand<'tcx>,\n-        /// Where to resume to.\n-        resume: BasicBlock,\n-        /// The place to store the resume argument in.\n-        resume_arg: Place<'tcx>,\n-        /// Cleanup to be done if the generator is dropped at this suspend point.\n-        drop: Option<BasicBlock>,\n-    },\n-\n-    /// Indicates the end of the dropping of a generator.\n-    GeneratorDrop,\n-\n-    /// A block where control flow only ever takes one real path, but borrowck\n-    /// needs to be more conservative.\n-    FalseEdge {\n-        /// The target normal control flow will take.\n-        real_target: BasicBlock,\n-        /// A block control flow could conceptually jump to, but won't in\n-        /// practice.\n-        imaginary_target: BasicBlock,\n-    },\n-    /// A terminator for blocks that only take one path in reality, but where we\n-    /// reserve the right to unwind in borrowck, even if it won't happen in practice.\n-    /// This can arise in infinite loops with no function calls for example.\n-    FalseUnwind {\n-        /// The target normal control flow will take.\n-        real_target: BasicBlock,\n-        /// The imaginary cleanup block link. This particular path will never be taken\n-        /// in practice, but in order to avoid fragility we want to always\n-        /// consider it in borrowck. We don't want to accept programs which\n-        /// pass borrowck only when `panic=abort` or some assertions are disabled\n-        /// due to release vs. debug mode builds. This needs to be an `Option` because\n-        /// of the `remove_noop_landing_pads` and `no_landing_pads` passes.\n-        unwind: Option<BasicBlock>,\n-    },\n-\n-    /// Block ends with an inline assembly block. This is a terminator since\n-    /// inline assembly is allowed to diverge.\n-    InlineAsm {\n-        /// The template for the inline assembly, with placeholders.\n-        template: &'tcx [InlineAsmTemplatePiece],\n-\n-        /// The operands for the inline assembly, as `Operand`s or `Place`s.\n-        operands: Vec<InlineAsmOperand<'tcx>>,\n-\n-        /// Miscellaneous options for the inline assembly.\n-        options: InlineAsmOptions,\n-\n-        /// Source spans for each line of the inline assembly code. These are\n-        /// used to map assembler errors back to the line in the source code.\n-        line_spans: &'tcx [Span],\n-\n-        /// Destination block after the inline assembly returns, unless it is\n-        /// diverging (InlineAsmOptions::NORETURN).\n-        destination: Option<BasicBlock>,\n-    },\n-}\n-\n /// Information about an assertion failure.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n pub enum AssertKind<O> {\n@@ -1279,149 +1095,6 @@ pub type Successors<'a> =\n pub type SuccessorsMut<'a> =\n     iter::Chain<option::IntoIter<&'a mut BasicBlock>, slice::IterMut<'a, BasicBlock>>;\n \n-impl<'tcx> Terminator<'tcx> {\n-    pub fn successors(&self) -> Successors<'_> {\n-        self.kind.successors()\n-    }\n-\n-    pub fn successors_mut(&mut self) -> SuccessorsMut<'_> {\n-        self.kind.successors_mut()\n-    }\n-\n-    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n-        self.kind.unwind()\n-    }\n-\n-    pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n-        self.kind.unwind_mut()\n-    }\n-}\n-\n-impl<'tcx> TerminatorKind<'tcx> {\n-    pub fn if_(\n-        tcx: TyCtxt<'tcx>,\n-        cond: Operand<'tcx>,\n-        t: BasicBlock,\n-        f: BasicBlock,\n-    ) -> TerminatorKind<'tcx> {\n-        static BOOL_SWITCH_FALSE: &[u128] = &[0];\n-        TerminatorKind::SwitchInt {\n-            discr: cond,\n-            switch_ty: tcx.types.bool,\n-            values: From::from(BOOL_SWITCH_FALSE),\n-            targets: vec![f, t],\n-        }\n-    }\n-\n-    pub fn successors(&self) -> Successors<'_> {\n-        use self::TerminatorKind::*;\n-        match *self {\n-            Resume\n-            | Abort\n-            | GeneratorDrop\n-            | Return\n-            | Unreachable\n-            | Call { destination: None, cleanup: None, .. }\n-            | InlineAsm { destination: None, .. } => None.into_iter().chain(&[]),\n-            Goto { target: ref t }\n-            | Call { destination: None, cleanup: Some(ref t), .. }\n-            | Call { destination: Some((_, ref t)), cleanup: None, .. }\n-            | Yield { resume: ref t, drop: None, .. }\n-            | DropAndReplace { target: ref t, unwind: None, .. }\n-            | Drop { target: ref t, unwind: None, .. }\n-            | Assert { target: ref t, cleanup: None, .. }\n-            | FalseUnwind { real_target: ref t, unwind: None }\n-            | InlineAsm { destination: Some(ref t), .. } => Some(t).into_iter().chain(&[]),\n-            Call { destination: Some((_, ref t)), cleanup: Some(ref u), .. }\n-            | Yield { resume: ref t, drop: Some(ref u), .. }\n-            | DropAndReplace { target: ref t, unwind: Some(ref u), .. }\n-            | Drop { target: ref t, unwind: Some(ref u), .. }\n-            | Assert { target: ref t, cleanup: Some(ref u), .. }\n-            | FalseUnwind { real_target: ref t, unwind: Some(ref u) } => {\n-                Some(t).into_iter().chain(slice::from_ref(u))\n-            }\n-            SwitchInt { ref targets, .. } => None.into_iter().chain(&targets[..]),\n-            FalseEdge { ref real_target, ref imaginary_target } => {\n-                Some(real_target).into_iter().chain(slice::from_ref(imaginary_target))\n-            }\n-        }\n-    }\n-\n-    pub fn successors_mut(&mut self) -> SuccessorsMut<'_> {\n-        use self::TerminatorKind::*;\n-        match *self {\n-            Resume\n-            | Abort\n-            | GeneratorDrop\n-            | Return\n-            | Unreachable\n-            | Call { destination: None, cleanup: None, .. }\n-            | InlineAsm { destination: None, .. } => None.into_iter().chain(&mut []),\n-            Goto { target: ref mut t }\n-            | Call { destination: None, cleanup: Some(ref mut t), .. }\n-            | Call { destination: Some((_, ref mut t)), cleanup: None, .. }\n-            | Yield { resume: ref mut t, drop: None, .. }\n-            | DropAndReplace { target: ref mut t, unwind: None, .. }\n-            | Drop { target: ref mut t, unwind: None, .. }\n-            | Assert { target: ref mut t, cleanup: None, .. }\n-            | FalseUnwind { real_target: ref mut t, unwind: None }\n-            | InlineAsm { destination: Some(ref mut t), .. } => Some(t).into_iter().chain(&mut []),\n-            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut u), .. }\n-            | Yield { resume: ref mut t, drop: Some(ref mut u), .. }\n-            | DropAndReplace { target: ref mut t, unwind: Some(ref mut u), .. }\n-            | Drop { target: ref mut t, unwind: Some(ref mut u), .. }\n-            | Assert { target: ref mut t, cleanup: Some(ref mut u), .. }\n-            | FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => {\n-                Some(t).into_iter().chain(slice::from_mut(u))\n-            }\n-            SwitchInt { ref mut targets, .. } => None.into_iter().chain(&mut targets[..]),\n-            FalseEdge { ref mut real_target, ref mut imaginary_target } => {\n-                Some(real_target).into_iter().chain(slice::from_mut(imaginary_target))\n-            }\n-        }\n-    }\n-\n-    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n-        match *self {\n-            TerminatorKind::Goto { .. }\n-            | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n-            | TerminatorKind::Return\n-            | TerminatorKind::Unreachable\n-            | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::Yield { .. }\n-            | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::FalseEdge { .. }\n-            | TerminatorKind::InlineAsm { .. } => None,\n-            TerminatorKind::Call { cleanup: ref unwind, .. }\n-            | TerminatorKind::Assert { cleanup: ref unwind, .. }\n-            | TerminatorKind::DropAndReplace { ref unwind, .. }\n-            | TerminatorKind::Drop { ref unwind, .. }\n-            | TerminatorKind::FalseUnwind { ref unwind, .. } => Some(unwind),\n-        }\n-    }\n-\n-    pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n-        match *self {\n-            TerminatorKind::Goto { .. }\n-            | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n-            | TerminatorKind::Return\n-            | TerminatorKind::Unreachable\n-            | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::Yield { .. }\n-            | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::FalseEdge { .. }\n-            | TerminatorKind::InlineAsm { .. } => None,\n-            TerminatorKind::Call { cleanup: ref mut unwind, .. }\n-            | TerminatorKind::Assert { cleanup: ref mut unwind, .. }\n-            | TerminatorKind::DropAndReplace { ref mut unwind, .. }\n-            | TerminatorKind::Drop { ref mut unwind, .. }\n-            | TerminatorKind::FalseUnwind { ref mut unwind, .. } => Some(unwind),\n-        }\n-    }\n-}\n-\n impl<'tcx> BasicBlockData<'tcx> {\n     pub fn new(terminator: Option<Terminator<'tcx>>) -> BasicBlockData<'tcx> {\n         BasicBlockData { statements: vec![], terminator, is_cleanup: false }\n@@ -1628,169 +1301,6 @@ impl<O: fmt::Debug> fmt::Debug for AssertKind<O> {\n     }\n }\n \n-impl<'tcx> Debug for TerminatorKind<'tcx> {\n-    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        self.fmt_head(fmt)?;\n-        let successor_count = self.successors().count();\n-        let labels = self.fmt_successor_labels();\n-        assert_eq!(successor_count, labels.len());\n-\n-        match successor_count {\n-            0 => Ok(()),\n-\n-            1 => write!(fmt, \" -> {:?}\", self.successors().next().unwrap()),\n-\n-            _ => {\n-                write!(fmt, \" -> [\")?;\n-                for (i, target) in self.successors().enumerate() {\n-                    if i > 0 {\n-                        write!(fmt, \", \")?;\n-                    }\n-                    write!(fmt, \"{}: {:?}\", labels[i], target)?;\n-                }\n-                write!(fmt, \"]\")\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> TerminatorKind<'tcx> {\n-    /// Writes the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n-    /// successor basic block, if any. The only information not included is the list of possible\n-    /// successors, which may be rendered differently between the text and the graphviz format.\n-    pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> fmt::Result {\n-        use self::TerminatorKind::*;\n-        match self {\n-            Goto { .. } => write!(fmt, \"goto\"),\n-            SwitchInt { discr, .. } => write!(fmt, \"switchInt({:?})\", discr),\n-            Return => write!(fmt, \"return\"),\n-            GeneratorDrop => write!(fmt, \"generator_drop\"),\n-            Resume => write!(fmt, \"resume\"),\n-            Abort => write!(fmt, \"abort\"),\n-            Yield { value, resume_arg, .. } => write!(fmt, \"{:?} = yield({:?})\", resume_arg, value),\n-            Unreachable => write!(fmt, \"unreachable\"),\n-            Drop { place, .. } => write!(fmt, \"drop({:?})\", place),\n-            DropAndReplace { place, value, .. } => {\n-                write!(fmt, \"replace({:?} <- {:?})\", place, value)\n-            }\n-            Call { func, args, destination, .. } => {\n-                if let Some((destination, _)) = destination {\n-                    write!(fmt, \"{:?} = \", destination)?;\n-                }\n-                write!(fmt, \"{:?}(\", func)?;\n-                for (index, arg) in args.iter().enumerate() {\n-                    if index > 0 {\n-                        write!(fmt, \", \")?;\n-                    }\n-                    write!(fmt, \"{:?}\", arg)?;\n-                }\n-                write!(fmt, \")\")\n-            }\n-            Assert { cond, expected, msg, .. } => {\n-                write!(fmt, \"assert(\")?;\n-                if !expected {\n-                    write!(fmt, \"!\")?;\n-                }\n-                write!(fmt, \"{:?}, \", cond)?;\n-                msg.fmt_assert_args(fmt)?;\n-                write!(fmt, \")\")\n-            }\n-            FalseEdge { .. } => write!(fmt, \"falseEdge\"),\n-            FalseUnwind { .. } => write!(fmt, \"falseUnwind\"),\n-            InlineAsm { template, ref operands, options, .. } => {\n-                write!(fmt, \"asm!(\\\"{}\\\"\", InlineAsmTemplatePiece::to_string(template))?;\n-                for op in operands {\n-                    write!(fmt, \", \")?;\n-                    let print_late = |&late| if late { \"late\" } else { \"\" };\n-                    match op {\n-                        InlineAsmOperand::In { reg, value } => {\n-                            write!(fmt, \"in({}) {:?}\", reg, value)?;\n-                        }\n-                        InlineAsmOperand::Out { reg, late, place: Some(place) } => {\n-                            write!(fmt, \"{}out({}) {:?}\", print_late(late), reg, place)?;\n-                        }\n-                        InlineAsmOperand::Out { reg, late, place: None } => {\n-                            write!(fmt, \"{}out({}) _\", print_late(late), reg)?;\n-                        }\n-                        InlineAsmOperand::InOut {\n-                            reg,\n-                            late,\n-                            in_value,\n-                            out_place: Some(out_place),\n-                        } => {\n-                            write!(\n-                                fmt,\n-                                \"in{}out({}) {:?} => {:?}\",\n-                                print_late(late),\n-                                reg,\n-                                in_value,\n-                                out_place\n-                            )?;\n-                        }\n-                        InlineAsmOperand::InOut { reg, late, in_value, out_place: None } => {\n-                            write!(fmt, \"in{}out({}) {:?} => _\", print_late(late), reg, in_value)?;\n-                        }\n-                        InlineAsmOperand::Const { value } => {\n-                            write!(fmt, \"const {:?}\", value)?;\n-                        }\n-                        InlineAsmOperand::SymFn { value } => {\n-                            write!(fmt, \"sym_fn {:?}\", value)?;\n-                        }\n-                        InlineAsmOperand::SymStatic { def_id } => {\n-                            write!(fmt, \"sym_static {:?}\", def_id)?;\n-                        }\n-                    }\n-                }\n-                write!(fmt, \", options({:?}))\", options)\n-            }\n-        }\n-    }\n-\n-    /// Returns the list of labels for the edges to the successor basic blocks.\n-    pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n-        use self::TerminatorKind::*;\n-        match *self {\n-            Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n-            Goto { .. } => vec![\"\".into()],\n-            SwitchInt { ref values, switch_ty, .. } => ty::tls::with(|tcx| {\n-                let param_env = ty::ParamEnv::empty();\n-                let switch_ty = tcx.lift(&switch_ty).unwrap();\n-                let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n-                values\n-                    .iter()\n-                    .map(|&u| {\n-                        ty::Const::from_scalar(tcx, Scalar::from_uint(u, size), switch_ty)\n-                            .to_string()\n-                            .into()\n-                    })\n-                    .chain(iter::once(\"otherwise\".into()))\n-                    .collect()\n-            }),\n-            Call { destination: Some(_), cleanup: Some(_), .. } => {\n-                vec![\"return\".into(), \"unwind\".into()]\n-            }\n-            Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into()],\n-            Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into()],\n-            Call { destination: None, cleanup: None, .. } => vec![],\n-            Yield { drop: Some(_), .. } => vec![\"resume\".into(), \"drop\".into()],\n-            Yield { drop: None, .. } => vec![\"resume\".into()],\n-            DropAndReplace { unwind: None, .. } | Drop { unwind: None, .. } => {\n-                vec![\"return\".into()]\n-            }\n-            DropAndReplace { unwind: Some(_), .. } | Drop { unwind: Some(_), .. } => {\n-                vec![\"return\".into(), \"unwind\".into()]\n-            }\n-            Assert { cleanup: None, .. } => vec![\"\".into()],\n-            Assert { .. } => vec![\"success\".into(), \"unwind\".into()],\n-            FalseEdge { .. } => vec![\"real\".into(), \"imaginary\".into()],\n-            FalseUnwind { unwind: Some(_), .. } => vec![\"real\".into(), \"cleanup\".into()],\n-            FalseUnwind { unwind: None, .. } => vec![\"real\".into()],\n-            InlineAsm { destination: Some(_), .. } => vec![\"\".into()],\n-            InlineAsm { destination: None, .. } => vec![],\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Statements\n "}, {"sha": "1f5041141d55b93420b81cf1d3246928b6192bde", "filename": "src/librustc_middle/mir/terminator/mod.rs", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/d6bee55855093d86c7e110116beebb369cd89654/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bee55855093d86c7e110116beebb369cd89654/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs?ref=d6bee55855093d86c7e110116beebb369cd89654", "patch": "@@ -0,0 +1,507 @@\n+use crate::mir::interpret::Scalar;\n+use crate::ty::{self, Ty, TyCtxt};\n+use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+\n+use super::{\n+    AssertMessage, BasicBlock, InlineAsmOperand, Operand, Place, SourceInfo, Successors,\n+    SuccessorsMut,\n+};\n+pub use rustc_ast::ast::Mutability;\n+use rustc_macros::HashStable;\n+use rustc_span::Span;\n+use std::borrow::Cow;\n+use std::fmt::{self, Debug, Formatter, Write};\n+use std::iter;\n+use std::slice;\n+\n+pub use super::query::*;\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n+pub enum TerminatorKind<'tcx> {\n+    /// Block should have one successor in the graph; we jump there.\n+    Goto { target: BasicBlock },\n+\n+    /// Operand evaluates to an integer; jump depending on its value\n+    /// to one of the targets, and otherwise fallback to `otherwise`.\n+    SwitchInt {\n+        /// The discriminant value being tested.\n+        discr: Operand<'tcx>,\n+\n+        /// The type of value being tested.\n+        /// This is always the same as the type of `discr`.\n+        /// FIXME: remove this redundant information. Currently, it is relied on by pretty-printing.\n+        switch_ty: Ty<'tcx>,\n+\n+        /// Possible values. The locations to branch to in each case\n+        /// are found in the corresponding indices from the `targets` vector.\n+        values: Cow<'tcx, [u128]>,\n+\n+        /// Possible branch sites. The last element of this vector is used\n+        /// for the otherwise branch, so targets.len() == values.len() + 1\n+        /// should hold.\n+        //\n+        // This invariant is quite non-obvious and also could be improved.\n+        // One way to make this invariant is to have something like this instead:\n+        //\n+        // branches: Vec<(ConstInt, BasicBlock)>,\n+        // otherwise: Option<BasicBlock> // exhaustive if None\n+        //\n+        // However we\u2019ve decided to keep this as-is until we figure a case\n+        // where some other approach seems to be strictly better than other.\n+        targets: Vec<BasicBlock>,\n+    },\n+\n+    /// Indicates that the landing pad is finished and unwinding should\n+    /// continue. Emitted by `build::scope::diverge_cleanup`.\n+    Resume,\n+\n+    /// Indicates that the landing pad is finished and that the process\n+    /// should abort. Used to prevent unwinding for foreign items.\n+    Abort,\n+\n+    /// Indicates a normal return. The return place should have\n+    /// been filled in before this executes. This can occur multiple times\n+    /// in different basic blocks.\n+    Return,\n+\n+    /// Indicates a terminator that can never be reached.\n+    Unreachable,\n+\n+    /// Drop the `Place`.\n+    Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n+\n+    /// Drop the `Place` and assign the new value over it. This ensures\n+    /// that the assignment to `P` occurs *even if* the destructor for\n+    /// place unwinds. Its semantics are best explained by the\n+    /// elaboration:\n+    ///\n+    /// ```\n+    /// BB0 {\n+    ///   DropAndReplace(P <- V, goto BB1, unwind BB2)\n+    /// }\n+    /// ```\n+    ///\n+    /// becomes\n+    ///\n+    /// ```\n+    /// BB0 {\n+    ///   Drop(P, goto BB1, unwind BB2)\n+    /// }\n+    /// BB1 {\n+    ///   // P is now uninitialized\n+    ///   P <- V\n+    /// }\n+    /// BB2 {\n+    ///   // P is now uninitialized -- its dtor panicked\n+    ///   P <- V\n+    /// }\n+    /// ```\n+    DropAndReplace {\n+        place: Place<'tcx>,\n+        value: Operand<'tcx>,\n+        target: BasicBlock,\n+        unwind: Option<BasicBlock>,\n+    },\n+\n+    /// Block ends with a call of a converging function.\n+    Call {\n+        /// The function that\u2019s being called.\n+        func: Operand<'tcx>,\n+        /// Arguments the function is called with.\n+        /// These are owned by the callee, which is free to modify them.\n+        /// This allows the memory occupied by \"by-value\" arguments to be\n+        /// reused across function calls without duplicating the contents.\n+        args: Vec<Operand<'tcx>>,\n+        /// Destination for the return value. If some, the call is converging.\n+        destination: Option<(Place<'tcx>, BasicBlock)>,\n+        /// Cleanups to be done if the call unwinds.\n+        cleanup: Option<BasicBlock>,\n+        /// `true` if this is from a call in HIR rather than from an overloaded\n+        /// operator. True for overloaded function call.\n+        from_hir_call: bool,\n+        /// This `Span` is the span of the function, without the dot and receiver\n+        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n+        fn_span: Span,\n+    },\n+\n+    /// Jump to the target if the condition has the expected value,\n+    /// otherwise panic with a message and a cleanup target.\n+    Assert {\n+        cond: Operand<'tcx>,\n+        expected: bool,\n+        msg: AssertMessage<'tcx>,\n+        target: BasicBlock,\n+        cleanup: Option<BasicBlock>,\n+    },\n+\n+    /// A suspend point.\n+    Yield {\n+        /// The value to return.\n+        value: Operand<'tcx>,\n+        /// Where to resume to.\n+        resume: BasicBlock,\n+        /// The place to store the resume argument in.\n+        resume_arg: Place<'tcx>,\n+        /// Cleanup to be done if the generator is dropped at this suspend point.\n+        drop: Option<BasicBlock>,\n+    },\n+\n+    /// Indicates the end of the dropping of a generator.\n+    GeneratorDrop,\n+\n+    /// A block where control flow only ever takes one real path, but borrowck\n+    /// needs to be more conservative.\n+    FalseEdge {\n+        /// The target normal control flow will take.\n+        real_target: BasicBlock,\n+        /// A block control flow could conceptually jump to, but won't in\n+        /// practice.\n+        imaginary_target: BasicBlock,\n+    },\n+    /// A terminator for blocks that only take one path in reality, but where we\n+    /// reserve the right to unwind in borrowck, even if it won't happen in practice.\n+    /// This can arise in infinite loops with no function calls for example.\n+    FalseUnwind {\n+        /// The target normal control flow will take.\n+        real_target: BasicBlock,\n+        /// The imaginary cleanup block link. This particular path will never be taken\n+        /// in practice, but in order to avoid fragility we want to always\n+        /// consider it in borrowck. We don't want to accept programs which\n+        /// pass borrowck only when `panic=abort` or some assertions are disabled\n+        /// due to release vs. debug mode builds. This needs to be an `Option` because\n+        /// of the `remove_noop_landing_pads` and `no_landing_pads` passes.\n+        unwind: Option<BasicBlock>,\n+    },\n+\n+    /// Block ends with an inline assembly block. This is a terminator since\n+    /// inline assembly is allowed to diverge.\n+    InlineAsm {\n+        /// The template for the inline assembly, with placeholders.\n+        template: &'tcx [InlineAsmTemplatePiece],\n+\n+        /// The operands for the inline assembly, as `Operand`s or `Place`s.\n+        operands: Vec<InlineAsmOperand<'tcx>>,\n+\n+        /// Miscellaneous options for the inline assembly.\n+        options: InlineAsmOptions,\n+\n+        /// Source spans for each line of the inline assembly code. These are\n+        /// used to map assembler errors back to the line in the source code.\n+        line_spans: &'tcx [Span],\n+\n+        /// Destination block after the inline assembly returns, unless it is\n+        /// diverging (InlineAsmOptions::NORETURN).\n+        destination: Option<BasicBlock>,\n+    },\n+}\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct Terminator<'tcx> {\n+    pub source_info: SourceInfo,\n+    pub kind: TerminatorKind<'tcx>,\n+}\n+\n+impl<'tcx> Terminator<'tcx> {\n+    pub fn successors(&self) -> Successors<'_> {\n+        self.kind.successors()\n+    }\n+\n+    pub fn successors_mut(&mut self) -> SuccessorsMut<'_> {\n+        self.kind.successors_mut()\n+    }\n+\n+    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n+        self.kind.unwind()\n+    }\n+\n+    pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n+        self.kind.unwind_mut()\n+    }\n+}\n+\n+impl<'tcx> TerminatorKind<'tcx> {\n+    pub fn if_(\n+        tcx: TyCtxt<'tcx>,\n+        cond: Operand<'tcx>,\n+        t: BasicBlock,\n+        f: BasicBlock,\n+    ) -> TerminatorKind<'tcx> {\n+        static BOOL_SWITCH_FALSE: &[u128] = &[0];\n+        TerminatorKind::SwitchInt {\n+            discr: cond,\n+            switch_ty: tcx.types.bool,\n+            values: From::from(BOOL_SWITCH_FALSE),\n+            targets: vec![f, t],\n+        }\n+    }\n+\n+    pub fn successors(&self) -> Successors<'_> {\n+        use self::TerminatorKind::*;\n+        match *self {\n+            Resume\n+            | Abort\n+            | GeneratorDrop\n+            | Return\n+            | Unreachable\n+            | Call { destination: None, cleanup: None, .. }\n+            | InlineAsm { destination: None, .. } => None.into_iter().chain(&[]),\n+            Goto { target: ref t }\n+            | Call { destination: None, cleanup: Some(ref t), .. }\n+            | Call { destination: Some((_, ref t)), cleanup: None, .. }\n+            | Yield { resume: ref t, drop: None, .. }\n+            | DropAndReplace { target: ref t, unwind: None, .. }\n+            | Drop { target: ref t, unwind: None, .. }\n+            | Assert { target: ref t, cleanup: None, .. }\n+            | FalseUnwind { real_target: ref t, unwind: None }\n+            | InlineAsm { destination: Some(ref t), .. } => Some(t).into_iter().chain(&[]),\n+            Call { destination: Some((_, ref t)), cleanup: Some(ref u), .. }\n+            | Yield { resume: ref t, drop: Some(ref u), .. }\n+            | DropAndReplace { target: ref t, unwind: Some(ref u), .. }\n+            | Drop { target: ref t, unwind: Some(ref u), .. }\n+            | Assert { target: ref t, cleanup: Some(ref u), .. }\n+            | FalseUnwind { real_target: ref t, unwind: Some(ref u) } => {\n+                Some(t).into_iter().chain(slice::from_ref(u))\n+            }\n+            SwitchInt { ref targets, .. } => None.into_iter().chain(&targets[..]),\n+            FalseEdge { ref real_target, ref imaginary_target } => {\n+                Some(real_target).into_iter().chain(slice::from_ref(imaginary_target))\n+            }\n+        }\n+    }\n+\n+    pub fn successors_mut(&mut self) -> SuccessorsMut<'_> {\n+        use self::TerminatorKind::*;\n+        match *self {\n+            Resume\n+            | Abort\n+            | GeneratorDrop\n+            | Return\n+            | Unreachable\n+            | Call { destination: None, cleanup: None, .. }\n+            | InlineAsm { destination: None, .. } => None.into_iter().chain(&mut []),\n+            Goto { target: ref mut t }\n+            | Call { destination: None, cleanup: Some(ref mut t), .. }\n+            | Call { destination: Some((_, ref mut t)), cleanup: None, .. }\n+            | Yield { resume: ref mut t, drop: None, .. }\n+            | DropAndReplace { target: ref mut t, unwind: None, .. }\n+            | Drop { target: ref mut t, unwind: None, .. }\n+            | Assert { target: ref mut t, cleanup: None, .. }\n+            | FalseUnwind { real_target: ref mut t, unwind: None }\n+            | InlineAsm { destination: Some(ref mut t), .. } => Some(t).into_iter().chain(&mut []),\n+            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut u), .. }\n+            | Yield { resume: ref mut t, drop: Some(ref mut u), .. }\n+            | DropAndReplace { target: ref mut t, unwind: Some(ref mut u), .. }\n+            | Drop { target: ref mut t, unwind: Some(ref mut u), .. }\n+            | Assert { target: ref mut t, cleanup: Some(ref mut u), .. }\n+            | FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => {\n+                Some(t).into_iter().chain(slice::from_mut(u))\n+            }\n+            SwitchInt { ref mut targets, .. } => None.into_iter().chain(&mut targets[..]),\n+            FalseEdge { ref mut real_target, ref mut imaginary_target } => {\n+                Some(real_target).into_iter().chain(slice::from_mut(imaginary_target))\n+            }\n+        }\n+    }\n+\n+    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n+        match *self {\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::InlineAsm { .. } => None,\n+            TerminatorKind::Call { cleanup: ref unwind, .. }\n+            | TerminatorKind::Assert { cleanup: ref unwind, .. }\n+            | TerminatorKind::DropAndReplace { ref unwind, .. }\n+            | TerminatorKind::Drop { ref unwind, .. }\n+            | TerminatorKind::FalseUnwind { ref unwind, .. } => Some(unwind),\n+        }\n+    }\n+\n+    pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n+        match *self {\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::InlineAsm { .. } => None,\n+            TerminatorKind::Call { cleanup: ref mut unwind, .. }\n+            | TerminatorKind::Assert { cleanup: ref mut unwind, .. }\n+            | TerminatorKind::DropAndReplace { ref mut unwind, .. }\n+            | TerminatorKind::Drop { ref mut unwind, .. }\n+            | TerminatorKind::FalseUnwind { ref mut unwind, .. } => Some(unwind),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Debug for TerminatorKind<'tcx> {\n+    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n+        self.fmt_head(fmt)?;\n+        let successor_count = self.successors().count();\n+        let labels = self.fmt_successor_labels();\n+        assert_eq!(successor_count, labels.len());\n+\n+        match successor_count {\n+            0 => Ok(()),\n+\n+            1 => write!(fmt, \" -> {:?}\", self.successors().next().unwrap()),\n+\n+            _ => {\n+                write!(fmt, \" -> [\")?;\n+                for (i, target) in self.successors().enumerate() {\n+                    if i > 0 {\n+                        write!(fmt, \", \")?;\n+                    }\n+                    write!(fmt, \"{}: {:?}\", labels[i], target)?;\n+                }\n+                write!(fmt, \"]\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TerminatorKind<'tcx> {\n+    /// Writes the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n+    /// successor basic block, if any. The only information not included is the list of possible\n+    /// successors, which may be rendered differently between the text and the graphviz format.\n+    pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> fmt::Result {\n+        use self::TerminatorKind::*;\n+        match self {\n+            Goto { .. } => write!(fmt, \"goto\"),\n+            SwitchInt { discr, .. } => write!(fmt, \"switchInt({:?})\", discr),\n+            Return => write!(fmt, \"return\"),\n+            GeneratorDrop => write!(fmt, \"generator_drop\"),\n+            Resume => write!(fmt, \"resume\"),\n+            Abort => write!(fmt, \"abort\"),\n+            Yield { value, resume_arg, .. } => write!(fmt, \"{:?} = yield({:?})\", resume_arg, value),\n+            Unreachable => write!(fmt, \"unreachable\"),\n+            Drop { place, .. } => write!(fmt, \"drop({:?})\", place),\n+            DropAndReplace { place, value, .. } => {\n+                write!(fmt, \"replace({:?} <- {:?})\", place, value)\n+            }\n+            Call { func, args, destination, .. } => {\n+                if let Some((destination, _)) = destination {\n+                    write!(fmt, \"{:?} = \", destination)?;\n+                }\n+                write!(fmt, \"{:?}(\", func)?;\n+                for (index, arg) in args.iter().enumerate() {\n+                    if index > 0 {\n+                        write!(fmt, \", \")?;\n+                    }\n+                    write!(fmt, \"{:?}\", arg)?;\n+                }\n+                write!(fmt, \")\")\n+            }\n+            Assert { cond, expected, msg, .. } => {\n+                write!(fmt, \"assert(\")?;\n+                if !expected {\n+                    write!(fmt, \"!\")?;\n+                }\n+                write!(fmt, \"{:?}, \", cond)?;\n+                msg.fmt_assert_args(fmt)?;\n+                write!(fmt, \")\")\n+            }\n+            FalseEdge { .. } => write!(fmt, \"falseEdge\"),\n+            FalseUnwind { .. } => write!(fmt, \"falseUnwind\"),\n+            InlineAsm { template, ref operands, options, .. } => {\n+                write!(fmt, \"asm!(\\\"{}\\\"\", InlineAsmTemplatePiece::to_string(template))?;\n+                for op in operands {\n+                    write!(fmt, \", \")?;\n+                    let print_late = |&late| if late { \"late\" } else { \"\" };\n+                    match op {\n+                        InlineAsmOperand::In { reg, value } => {\n+                            write!(fmt, \"in({}) {:?}\", reg, value)?;\n+                        }\n+                        InlineAsmOperand::Out { reg, late, place: Some(place) } => {\n+                            write!(fmt, \"{}out({}) {:?}\", print_late(late), reg, place)?;\n+                        }\n+                        InlineAsmOperand::Out { reg, late, place: None } => {\n+                            write!(fmt, \"{}out({}) _\", print_late(late), reg)?;\n+                        }\n+                        InlineAsmOperand::InOut {\n+                            reg,\n+                            late,\n+                            in_value,\n+                            out_place: Some(out_place),\n+                        } => {\n+                            write!(\n+                                fmt,\n+                                \"in{}out({}) {:?} => {:?}\",\n+                                print_late(late),\n+                                reg,\n+                                in_value,\n+                                out_place\n+                            )?;\n+                        }\n+                        InlineAsmOperand::InOut { reg, late, in_value, out_place: None } => {\n+                            write!(fmt, \"in{}out({}) {:?} => _\", print_late(late), reg, in_value)?;\n+                        }\n+                        InlineAsmOperand::Const { value } => {\n+                            write!(fmt, \"const {:?}\", value)?;\n+                        }\n+                        InlineAsmOperand::SymFn { value } => {\n+                            write!(fmt, \"sym_fn {:?}\", value)?;\n+                        }\n+                        InlineAsmOperand::SymStatic { def_id } => {\n+                            write!(fmt, \"sym_static {:?}\", def_id)?;\n+                        }\n+                    }\n+                }\n+                write!(fmt, \", options({:?}))\", options)\n+            }\n+        }\n+    }\n+\n+    /// Returns the list of labels for the edges to the successor basic blocks.\n+    pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n+        use self::TerminatorKind::*;\n+        match *self {\n+            Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n+            Goto { .. } => vec![\"\".into()],\n+            SwitchInt { ref values, switch_ty, .. } => ty::tls::with(|tcx| {\n+                let param_env = ty::ParamEnv::empty();\n+                let switch_ty = tcx.lift(&switch_ty).unwrap();\n+                let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n+                values\n+                    .iter()\n+                    .map(|&u| {\n+                        ty::Const::from_scalar(tcx, Scalar::from_uint(u, size), switch_ty)\n+                            .to_string()\n+                            .into()\n+                    })\n+                    .chain(iter::once(\"otherwise\".into()))\n+                    .collect()\n+            }),\n+            Call { destination: Some(_), cleanup: Some(_), .. } => {\n+                vec![\"return\".into(), \"unwind\".into()]\n+            }\n+            Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into()],\n+            Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into()],\n+            Call { destination: None, cleanup: None, .. } => vec![],\n+            Yield { drop: Some(_), .. } => vec![\"resume\".into(), \"drop\".into()],\n+            Yield { drop: None, .. } => vec![\"resume\".into()],\n+            DropAndReplace { unwind: None, .. } | Drop { unwind: None, .. } => {\n+                vec![\"return\".into()]\n+            }\n+            DropAndReplace { unwind: Some(_), .. } | Drop { unwind: Some(_), .. } => {\n+                vec![\"return\".into(), \"unwind\".into()]\n+            }\n+            Assert { cleanup: None, .. } => vec![\"\".into()],\n+            Assert { .. } => vec![\"success\".into(), \"unwind\".into()],\n+            FalseEdge { .. } => vec![\"real\".into(), \"imaginary\".into()],\n+            FalseUnwind { unwind: Some(_), .. } => vec![\"real\".into(), \"cleanup\".into()],\n+            FalseUnwind { unwind: None, .. } => vec![\"real\".into()],\n+            InlineAsm { destination: Some(_), .. } => vec![\"\".into()],\n+            InlineAsm { destination: None, .. } => vec![],\n+        }\n+    }\n+}"}]}