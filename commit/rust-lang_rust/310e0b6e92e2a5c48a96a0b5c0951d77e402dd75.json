{"sha": "310e0b6e92e2a5c48a96a0b5c0951d77e402dd75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMGUwYjZlOTJlMmE1YzQ4YTk2YTBiNWMwOTUxZDc3ZTQwMmRkNzU=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-31T19:07:44Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-01T14:54:22Z"}, "message": "extra: Use external iterators in bitv implementation\n\nConvert some internally used functions to use a external iterators.\n\nChange all uses of remaining internal iterators to use `do` expr", "tree": {"sha": "d4ff7a2b7206379e3a4f0fa53fdd27cdc256be3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4ff7a2b7206379e3a4f0fa53fdd27cdc256be3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/310e0b6e92e2a5c48a96a0b5c0951d77e402dd75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/310e0b6e92e2a5c48a96a0b5c0951d77e402dd75", "html_url": "https://github.com/rust-lang/rust/commit/310e0b6e92e2a5c48a96a0b5c0951d77e402dd75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/310e0b6e92e2a5c48a96a0b5c0951d77e402dd75/comments", "author": null, "committer": null, "parents": [{"sha": "dbcb74e247b892a5174524bbbafbe93c51c53f65", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbcb74e247b892a5174524bbbafbe93c51c53f65", "html_url": "https://github.com/rust-lang/rust/commit/dbcb74e247b892a5174524bbbafbe93c51c53f65"}], "stats": {"total": 88, "additions": 55, "deletions": 33}, "files": [{"sha": "44e5ca56c436a67b208ef1bb1792b1205b4cc224", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 55, "deletions": 33, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/310e0b6e92e2a5c48a96a0b5c0951d77e402dd75/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310e0b6e92e2a5c48a96a0b5c0951d77e402dd75/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=310e0b6e92e2a5c48a96a0b5c0951d77e402dd75", "patch": "@@ -12,7 +12,8 @@\n \n \n use std::cmp;\n-use std::iterator::{DoubleEndedIterator, RandomAccessIterator, Invert};\n+use std::iterator::RandomAccessIterator;\n+use std::iterator::{Invert, Enumerate};\n use std::num;\n use std::ops;\n use std::uint;\n@@ -164,7 +165,7 @@ impl BigBitv {\n     }\n \n     #[inline]\n-    pub fn negate(&mut self) { for self.each_storage |w| { *w = !*w } }\n+    pub fn negate(&mut self) { do self.each_storage |w| { *w = !*w; true }; }\n \n     #[inline]\n     pub fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n@@ -723,12 +724,12 @@ impl cmp::Eq for BitvSet {\n         if self.size != other.size {\n             return false;\n         }\n-        for self.each_common(other) |_, w1, w2| {\n+        for self.common_iter(other).advance |(_, w1, w2)| {\n             if w1 != w2 {\n                 return false;\n             }\n         }\n-        for self.each_outlier(other) |_, _, w| {\n+        for self.outlier_iter(other).advance |(_, _, w)| {\n             if w != 0 {\n                 return false;\n             }\n@@ -746,7 +747,7 @@ impl Container for BitvSet {\n \n impl Mutable for BitvSet {\n     fn clear(&mut self) {\n-        for self.bitv.each_storage |w| { *w = 0; }\n+        do self.bitv.each_storage |w| { *w = 0; true };\n         self.size = 0;\n     }\n }\n@@ -757,22 +758,21 @@ impl Set<uint> for BitvSet {\n     }\n \n     fn is_disjoint(&self, other: &BitvSet) -> bool {\n-        for self.intersection(other) |_| {\n-            return false;\n+        do self.intersection(other) |_| {\n+            false\n         }\n-        return true;\n     }\n \n     fn is_subset(&self, other: &BitvSet) -> bool {\n-        for self.each_common(other) |_, w1, w2| {\n+        for self.common_iter(other).advance |(_, w1, w2)| {\n             if w1 & w2 != w1 {\n                 return false;\n             }\n         }\n         /* If anything is not ours, then everything is not ours so we're\n            definitely a subset in that case. Otherwise if there's any stray\n            ones that 'other' doesn't have, we're not a subset. */\n-        for self.each_outlier(other) |mine, _, w| {\n+        for self.outlier_iter(other).advance |(mine, _, w)| {\n             if !mine {\n                 return true;\n             } else if w != 0 {\n@@ -787,38 +787,38 @@ impl Set<uint> for BitvSet {\n     }\n \n     fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        for self.each_common(other) |i, w1, w2| {\n+        for self.common_iter(other).advance |(i, w1, w2)| {\n             if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n                 return false;\n             }\n         }\n         /* everything we have that they don't also shows up */\n-        self.each_outlier(other, |mine, i, w|\n+        self.outlier_iter(other).advance(|(mine, i, w)|\n             !mine || iterate_bits(i, w, |b| f(&b))\n         )\n     }\n \n     fn symmetric_difference(&self, other: &BitvSet,\n                             f: &fn(&uint) -> bool) -> bool {\n-        for self.each_common(other) |i, w1, w2| {\n+        for self.common_iter(other).advance |(i, w1, w2)| {\n             if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n                 return false;\n             }\n         }\n-        self.each_outlier(other, |_, i, w| iterate_bits(i, w, |b| f(&b)))\n+        self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n     }\n \n     fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        self.each_common(other, |i, w1, w2| iterate_bits(i, w1 & w2, |b| f(&b)))\n+        self.common_iter(other).advance(|(i, w1, w2)| iterate_bits(i, w1 & w2, |b| f(&b)))\n     }\n \n     fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        for self.each_common(other) |i, w1, w2| {\n+        for self.common_iter(other).advance |(i, w1, w2)| {\n             if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n                 return false;\n             }\n         }\n-        self.each_outlier(other, |_, i, w| iterate_bits(i, w, |b| f(&b)))\n+        self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n     }\n }\n \n@@ -861,13 +861,14 @@ impl BitvSet {\n     /// both have in common. The three yielded arguments are (bit location,\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n-    fn each_common(&self, other: &BitvSet,\n-                   f: &fn(uint, uint, uint) -> bool) -> bool {\n+    fn common_iter<'a>(&'a self, other: &'a BitvSet)\n+        -> MapE<(uint,&uint),(uint,uint,uint), &'a ~[uint],Enumerate<vec::VecIterator<'a,uint>>> {\n         let min = num::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n-        self.bitv.storage.slice(0, min).iter().enumerate().advance(|(i, &w)| {\n-            f(i * uint::bits, w, other.bitv.storage[i])\n-        })\n+        MapE{iter: self.bitv.storage.slice(0, min).iter().enumerate(),\n+             env: &other.bitv.storage,\n+             f: |(i, &w): (uint, &uint), o_store| (i * uint::bits, w, o_store[i])\n+        }\n     }\n \n     /// Visits each word in self or other that extends beyond the other. This\n@@ -877,24 +878,45 @@ impl BitvSet {\n     /// The yielded arguments are a bool, the bit offset, and a word. The bool\n     /// is true if the word comes from 'self', and false if it comes from\n     /// 'other'.\n-    fn each_outlier(&self, other: &BitvSet,\n-                    f: &fn(bool, uint, uint) -> bool) -> bool {\n+    fn outlier_iter<'a>(&'a self, other: &'a BitvSet)\n+        -> MapE<(uint, &uint),(bool, uint, uint), uint, Enumerate<vec::VecIterator<'a, uint>>> {\n         let len1 = self.bitv.storage.len();\n         let len2 = other.bitv.storage.len();\n         let min = num::min(len1, len2);\n \n-        /* only one of these loops will execute and that's the point */\n-        foreach (i, &w) in self.bitv.storage.slice(min, len1).iter().enumerate() {\n-            if !f(true, (i + min) * uint::bits, w) {\n-                return false;\n+        if min < len1 {\n+            MapE{iter: self.bitv.storage.slice(min, len1).iter().enumerate(),\n+                 env: min,\n+                 f: |(i, &w): (uint, &uint), min| (true, (i + min) * uint::bits, w)\n             }\n-        }\n-        foreach (i, &w) in other.bitv.storage.slice(min, len2).iter().enumerate() {\n-            if !f(false, (i + min) * uint::bits, w) {\n-                return false;\n+        } else {\n+            MapE{iter: other.bitv.storage.slice(min, len2).iter().enumerate(),\n+                 env: min,\n+                 f: |(i, &w): (uint, &uint), min| (false, (i + min) * uint::bits, w)\n             }\n         }\n-        return true;\n+    }\n+}\n+\n+/// Like iterator::Map with explicit env capture\n+struct MapE<A, B, Env, I> {\n+    priv env: Env,\n+    priv f: &'static fn(A, Env) -> B,\n+    priv iter: I,\n+}\n+\n+impl<'self, A, B, Env: Clone, I: Iterator<A>> Iterator<B> for MapE<A, B, Env, I> {\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        match self.iter.next() {\n+            Some(elt) => Some((self.f)(elt, self.env.clone())),\n+            None => None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n     }\n }\n "}]}