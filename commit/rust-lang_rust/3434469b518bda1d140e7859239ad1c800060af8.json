{"sha": "3434469b518bda1d140e7859239ad1c800060af8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MzQ0NjliNTE4YmRhMWQxNDBlNzg1OTIzOWFkMWM4MDAwNjBhZjg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-29T22:45:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-29T22:45:35Z"}, "message": "rollup merge of #24762: nrc/mod-debug-2\n\nCloses #20780\n\nr? @michaelwoerister\n\nI'm sure this could be done better with deeper knowledge of debuginfo, but this seems like a good start.", "tree": {"sha": "4309279953dcc29d7e59744ca3bab82644251e86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4309279953dcc29d7e59744ca3bab82644251e86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3434469b518bda1d140e7859239ad1c800060af8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3434469b518bda1d140e7859239ad1c800060af8", "html_url": "https://github.com/rust-lang/rust/commit/3434469b518bda1d140e7859239ad1c800060af8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3434469b518bda1d140e7859239ad1c800060af8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e14af089a47d00af85565956421200f889978c7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e14af089a47d00af85565956421200f889978c7a", "html_url": "https://github.com/rust-lang/rust/commit/e14af089a47d00af85565956421200f889978c7a"}, {"sha": "7bfb5ed826c3fa6544865095f3f9158d95efb3a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bfb5ed826c3fa6544865095f3f9158d95efb3a3", "html_url": "https://github.com/rust-lang/rust/commit/7bfb5ed826c3fa6544865095f3f9158d95efb3a3"}], "stats": {"total": 6658, "additions": 3424, "deletions": 3234}, "files": [{"sha": "4879975dde695c265bd7505b3e1127a0bccebf5c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3434469b518bda1d140e7859239ad1c800060af8", "patch": "@@ -2182,7 +2182,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n \n-            debuginfo::insert_reference_to_gdb_debug_scripts_section_global(ccx);\n+            debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(ccx);\n \n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {"}, {"sha": "9af22b788b77beaf0160dfa8cabe2f5e82762937", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=3434469b518bda1d140e7859239ad1c800060af8", "patch": "@@ -0,0 +1,514 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::metadata::file_metadata;\n+use super::utils::DIB;\n+\n+use llvm;\n+use llvm::debuginfo::{DIScope, DISubprogram};\n+use trans::common::CrateContext;\n+use middle::pat_util;\n+use util::nodemap::NodeMap;\n+\n+use libc::c_uint;\n+use syntax::codemap::{Span, Pos};\n+use syntax::{ast, codemap, ast_util};\n+\n+// This procedure builds the *scope map* for a given function, which maps any\n+// given ast::NodeId in the function's AST to the correct DIScope metadata instance.\n+//\n+// This builder procedure walks the AST in execution order and keeps track of\n+// what belongs to which scope, creating DIScope DIEs along the way, and\n+// introducing *artificial* lexical scope descriptors where necessary. These\n+// artificial scopes allow GDB to correctly handle name shadowing.\n+pub fn create_scope_map(cx: &CrateContext,\n+                        args: &[ast::Arg],\n+                        fn_entry_block: &ast::Block,\n+                        fn_metadata: DISubprogram,\n+                        fn_ast_id: ast::NodeId)\n+                        -> NodeMap<DIScope> {\n+    let mut scope_map = NodeMap();\n+\n+    let def_map = &cx.tcx().def_map;\n+\n+    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, name: None });\n+    scope_map.insert(fn_ast_id, fn_metadata);\n+\n+    // Push argument identifiers onto the stack so arguments integrate nicely\n+    // with variable shadowing.\n+    for arg in args {\n+        pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n+            scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n+                                               name: Some(path1.node.name) });\n+            scope_map.insert(node_id, fn_metadata);\n+        })\n+    }\n+\n+    // Clang creates a separate scope for function bodies, so let's do this too.\n+    with_new_scope(cx,\n+                   fn_entry_block.span,\n+                   &mut scope_stack,\n+                   &mut scope_map,\n+                   |cx, scope_stack, scope_map| {\n+        walk_block(cx, fn_entry_block, scope_stack, scope_map);\n+    });\n+\n+    return scope_map;\n+}\n+\n+// local helper functions for walking the AST.\n+fn with_new_scope<F>(cx: &CrateContext,\n+                     scope_span: Span,\n+                     scope_stack: &mut Vec<ScopeStackEntry> ,\n+                     scope_map: &mut NodeMap<DIScope>,\n+                     inner_walk: F) where\n+    F: FnOnce(&CrateContext, &mut Vec<ScopeStackEntry>, &mut NodeMap<DIScope>),\n+{\n+    // Create a new lexical scope and push it onto the stack\n+    let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n+    let parent_scope = scope_stack.last().unwrap().scope_metadata;\n+\n+    let scope_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateLexicalBlock(\n+            DIB(cx),\n+            parent_scope,\n+            file_metadata,\n+            loc.line as c_uint,\n+            loc.col.to_usize() as c_uint)\n+    };\n+\n+    scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata, name: None });\n+\n+    inner_walk(cx, scope_stack, scope_map);\n+\n+    // pop artificial scopes\n+    while scope_stack.last().unwrap().name.is_some() {\n+        scope_stack.pop();\n+    }\n+\n+    if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n+        cx.sess().span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n+    }\n+\n+    scope_stack.pop();\n+}\n+\n+struct ScopeStackEntry {\n+    scope_metadata: DIScope,\n+    name: Option<ast::Name>\n+}\n+\n+fn walk_block(cx: &CrateContext,\n+              block: &ast::Block,\n+              scope_stack: &mut Vec<ScopeStackEntry> ,\n+              scope_map: &mut NodeMap<DIScope>) {\n+    scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n+\n+    // The interesting things here are statements and the concluding expression.\n+    for statement in &block.stmts {\n+        scope_map.insert(ast_util::stmt_id(&**statement),\n+                         scope_stack.last().unwrap().scope_metadata);\n+\n+        match statement.node {\n+            ast::StmtDecl(ref decl, _) =>\n+                walk_decl(cx, &**decl, scope_stack, scope_map),\n+            ast::StmtExpr(ref exp, _) |\n+            ast::StmtSemi(ref exp, _) =>\n+                walk_expr(cx, &**exp, scope_stack, scope_map),\n+            ast::StmtMac(..) => () // Ignore macros (which should be expanded anyway).\n+        }\n+    }\n+\n+    if let Some(ref exp) = block.expr {\n+        walk_expr(cx, &**exp, scope_stack, scope_map);\n+    }\n+}\n+\n+fn walk_decl(cx: &CrateContext,\n+             decl: &ast::Decl,\n+             scope_stack: &mut Vec<ScopeStackEntry> ,\n+             scope_map: &mut NodeMap<DIScope>) {\n+    match *decl {\n+        codemap::Spanned { node: ast::DeclLocal(ref local), .. } => {\n+            scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n+\n+            if let Some(ref exp) = local.init {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+        }\n+        _ => ()\n+    }\n+}\n+\n+fn walk_pattern(cx: &CrateContext,\n+                pat: &ast::Pat,\n+                scope_stack: &mut Vec<ScopeStackEntry> ,\n+                scope_map: &mut NodeMap<DIScope>) {\n+\n+    let def_map = &cx.tcx().def_map;\n+\n+    // Unfortunately, we cannot just use pat_util::pat_bindings() or\n+    // ast_util::walk_pat() here because we have to visit *all* nodes in\n+    // order to put them into the scope map. The above functions don't do that.\n+    match pat.node {\n+        ast::PatIdent(_, ref path1, ref sub_pat_opt) => {\n+\n+            // Check if this is a binding. If so we need to put it on the\n+            // scope stack and maybe introduce an artificial scope\n+            if pat_util::pat_is_binding(def_map, &*pat) {\n+\n+                let name = path1.node.name;\n+\n+                // LLVM does not properly generate 'DW_AT_start_scope' fields\n+                // for variable DIEs. For this reason we have to introduce\n+                // an artificial scope at bindings whenever a variable with\n+                // the same name is declared in *any* parent scope.\n+                //\n+                // Otherwise the following error occurs:\n+                //\n+                // let x = 10;\n+                //\n+                // do_something(); // 'gdb print x' correctly prints 10\n+                //\n+                // {\n+                //     do_something(); // 'gdb print x' prints 0, because it\n+                //                     // already reads the uninitialized 'x'\n+                //                     // from the next line...\n+                //     let x = 100;\n+                //     do_something(); // 'gdb print x' correctly prints 100\n+                // }\n+\n+                // Is there already a binding with that name?\n+                // N.B.: this comparison must be UNhygienic... because\n+                // gdb knows nothing about the context, so any two\n+                // variables with the same name will cause the problem.\n+                let need_new_scope = scope_stack\n+                    .iter()\n+                    .any(|entry| entry.name == Some(name));\n+\n+                if need_new_scope {\n+                    // Create a new lexical scope and push it onto the stack\n+                    let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n+                    let file_metadata = file_metadata(cx, &loc.file.name);\n+                    let parent_scope = scope_stack.last().unwrap().scope_metadata;\n+\n+                    let scope_metadata = unsafe {\n+                        llvm::LLVMDIBuilderCreateLexicalBlock(\n+                            DIB(cx),\n+                            parent_scope,\n+                            file_metadata,\n+                            loc.line as c_uint,\n+                            loc.col.to_usize() as c_uint)\n+                    };\n+\n+                    scope_stack.push(ScopeStackEntry {\n+                        scope_metadata: scope_metadata,\n+                        name: Some(name)\n+                    });\n+\n+                } else {\n+                    // Push a new entry anyway so the name can be found\n+                    let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n+                    scope_stack.push(ScopeStackEntry {\n+                        scope_metadata: prev_metadata,\n+                        name: Some(name)\n+                    });\n+                }\n+            }\n+\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            if let Some(ref sub_pat) = *sub_pat_opt {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatWild(_) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+        }\n+\n+        ast::PatEnum(_, ref sub_pats_opt) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            if let Some(ref sub_pats) = *sub_pats_opt {\n+                for p in sub_pats {\n+                    walk_pattern(cx, &**p, scope_stack, scope_map);\n+                }\n+            }\n+        }\n+\n+        ast::PatQPath(..) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+        }\n+\n+        ast::PatStruct(_, ref field_pats, _) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            for &codemap::Spanned {\n+                node: ast::FieldPat { pat: ref sub_pat, .. },\n+                ..\n+            } in field_pats.iter() {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatTup(ref sub_pats) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            for sub_pat in sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat, _) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+        }\n+\n+        ast::PatLit(ref exp) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            walk_expr(cx, &**exp, scope_stack, scope_map);\n+        }\n+\n+        ast::PatRange(ref exp1, ref exp2) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            walk_expr(cx, &**exp1, scope_stack, scope_map);\n+            walk_expr(cx, &**exp2, scope_stack, scope_map);\n+        }\n+\n+        ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            for sub_pat in front_sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+\n+            if let Some(ref sub_pat) = *middle_sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+\n+            for sub_pat in back_sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatMac(_) => {\n+            cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded macro.\");\n+        }\n+    }\n+}\n+\n+fn walk_expr(cx: &CrateContext,\n+             exp: &ast::Expr,\n+             scope_stack: &mut Vec<ScopeStackEntry> ,\n+             scope_map: &mut NodeMap<DIScope>) {\n+\n+    scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n+\n+    match exp.node {\n+        ast::ExprLit(_)   |\n+        ast::ExprBreak(_) |\n+        ast::ExprAgain(_) |\n+        ast::ExprPath(..) => {}\n+\n+        ast::ExprCast(ref sub_exp, _)     |\n+        ast::ExprAddrOf(_, ref sub_exp)  |\n+        ast::ExprField(ref sub_exp, _) |\n+        ast::ExprTupField(ref sub_exp, _) |\n+        ast::ExprParen(ref sub_exp) =>\n+            walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+\n+        ast::ExprBox(ref place, ref sub_expr) => {\n+            place.as_ref().map(\n+                |e| walk_expr(cx, &**e, scope_stack, scope_map));\n+            walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprRet(ref exp_opt) => match *exp_opt {\n+            Some(ref sub_exp) => walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+            None => ()\n+        },\n+\n+        ast::ExprUnary(_, ref sub_exp) => {\n+            walk_expr(cx, &**sub_exp, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+        ast::ExprIndex(ref lhs, ref rhs) |\n+        ast::ExprBinary(_, ref lhs, ref rhs)    => {\n+            walk_expr(cx, &**lhs, scope_stack, scope_map);\n+            walk_expr(cx, &**rhs, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprRange(ref start, ref end) => {\n+            start.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+            end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+        }\n+\n+        ast::ExprVec(ref init_expressions) |\n+        ast::ExprTup(ref init_expressions) => {\n+            for ie in init_expressions {\n+                walk_expr(cx, &**ie, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::ExprAssign(ref sub_exp1, ref sub_exp2) |\n+        ast::ExprRepeat(ref sub_exp1, ref sub_exp2) => {\n+            walk_expr(cx, &**sub_exp1, scope_stack, scope_map);\n+            walk_expr(cx, &**sub_exp2, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprIf(ref cond_exp, ref then_block, ref opt_else_exp) => {\n+            walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+\n+            with_new_scope(cx,\n+                           then_block.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                walk_block(cx, &**then_block, scope_stack, scope_map);\n+            });\n+\n+            match *opt_else_exp {\n+                Some(ref else_exp) =>\n+                    walk_expr(cx, &**else_exp, scope_stack, scope_map),\n+                _ => ()\n+            }\n+        }\n+\n+        ast::ExprIfLet(..) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded if-let.\");\n+        }\n+\n+        ast::ExprWhile(ref cond_exp, ref loop_body, _) => {\n+            walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+\n+            with_new_scope(cx,\n+                           loop_body.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                walk_block(cx, &**loop_body, scope_stack, scope_map);\n+            })\n+        }\n+\n+        ast::ExprWhileLet(..) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded while-let.\");\n+        }\n+\n+        ast::ExprForLoop(..) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded for loop.\");\n+        }\n+\n+        ast::ExprMac(_) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded macro.\");\n+        }\n+\n+        ast::ExprLoop(ref block, _) |\n+        ast::ExprBlock(ref block)   => {\n+            with_new_scope(cx,\n+                           block.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                walk_block(cx, &**block, scope_stack, scope_map);\n+            })\n+        }\n+\n+        ast::ExprClosure(_, ref decl, ref block) => {\n+            with_new_scope(cx,\n+                           block.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                for &ast::Arg { pat: ref pattern, .. } in &decl.inputs {\n+                    walk_pattern(cx, &**pattern, scope_stack, scope_map);\n+                }\n+\n+                walk_block(cx, &**block, scope_stack, scope_map);\n+            })\n+        }\n+\n+        ast::ExprCall(ref fn_exp, ref args) => {\n+            walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n+\n+            for arg_exp in args {\n+                walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::ExprMethodCall(_, _, ref args) => {\n+            for arg_exp in args {\n+                walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::ExprMatch(ref discriminant_exp, ref arms, _) => {\n+            walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n+\n+            // For each arm we have to first walk the pattern as these might\n+            // introduce new artificial scopes. It should be sufficient to\n+            // walk only one pattern per arm, as they all must contain the\n+            // same binding names.\n+\n+            for arm_ref in arms {\n+                let arm_span = arm_ref.pats[0].span;\n+\n+                with_new_scope(cx,\n+                               arm_span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n+                    for pat in &arm_ref.pats {\n+                        walk_pattern(cx, &**pat, scope_stack, scope_map);\n+                    }\n+\n+                    if let Some(ref guard_exp) = arm_ref.guard {\n+                        walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n+                    }\n+\n+                    walk_expr(cx, &*arm_ref.body, scope_stack, scope_map);\n+                })\n+            }\n+        }\n+\n+        ast::ExprStruct(_, ref fields, ref base_exp) => {\n+            for &ast::Field { expr: ref exp, .. } in fields {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+\n+            match *base_exp {\n+                Some(ref exp) => walk_expr(cx, &**exp, scope_stack, scope_map),\n+                None => ()\n+            }\n+        }\n+\n+        ast::ExprInlineAsm(ast::InlineAsm { ref inputs,\n+                                            ref outputs,\n+                                            .. }) => {\n+            // inputs, outputs: Vec<(String, P<Expr>)>\n+            for &(_, ref exp) in inputs {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+\n+            for &(_, ref exp, _) in outputs {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "a91619b2f845a437732a2d2e8dc3c4b5363d9d6f", "filename": "src/librustc_trans/trans/debuginfo/doc.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs?ref=3434469b518bda1d140e7859239ad1c800060af8", "patch": "@@ -0,0 +1,189 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Debug Info Module\n+//!\n+//! This module serves the purpose of generating debug symbols. We use LLVM's\n+//! [source level debugging](http://!llvm.org/docs/SourceLevelDebugging.html)\n+//! features for generating the debug information. The general principle is\n+//! this:\n+//!\n+//! Given the right metadata in the LLVM IR, the LLVM code generator is able to\n+//! create DWARF debug symbols for the given code. The\n+//! [metadata](http://!llvm.org/docs/LangRef.html#metadata-type) is structured\n+//! much like DWARF *debugging information entries* (DIE), representing type\n+//! information such as datatype layout, function signatures, block layout,\n+//! variable location and scope information, etc. It is the purpose of this\n+//! module to generate correct metadata and insert it into the LLVM IR.\n+//!\n+//! As the exact format of metadata trees may change between different LLVM\n+//! versions, we now use LLVM\n+//! [DIBuilder](http://!llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n+//! to create metadata where possible. This will hopefully ease the adaption of\n+//! this module to future LLVM versions.\n+//!\n+//! The public API of the module is a set of functions that will insert the\n+//! correct metadata into the LLVM IR when called with the right parameters.\n+//! The module is thus driven from an outside client with functions like\n+//! `debuginfo::create_local_var_metadata(bcx: block, local: &ast::local)`.\n+//!\n+//! Internally the module will try to reuse already created metadata by\n+//! utilizing a cache. The way to get a shared metadata node when needed is\n+//! thus to just call the corresponding function in this module:\n+//!\n+//!     let file_metadata = file_metadata(crate_context, path);\n+//!\n+//! The function will take care of probing the cache for an existing node for\n+//! that exact file path.\n+//!\n+//! All private state used by the module is stored within either the\n+//! CrateDebugContext struct (owned by the CrateContext) or the\n+//! FunctionDebugContext (owned by the FunctionContext).\n+//!\n+//! This file consists of three conceptual sections:\n+//! 1. The public interface of the module\n+//! 2. Module-internal metadata creation functions\n+//! 3. Minor utility functions\n+//!\n+//!\n+//! ## Recursive Types\n+//!\n+//! Some kinds of types, such as structs and enums can be recursive. That means\n+//! that the type definition of some type X refers to some other type which in\n+//! turn (transitively) refers to X. This introduces cycles into the type\n+//! referral graph. A naive algorithm doing an on-demand, depth-first traversal\n+//! of this graph when describing types, can get trapped in an endless loop\n+//! when it reaches such a cycle.\n+//!\n+//! For example, the following simple type for a singly-linked list...\n+//!\n+//! ```\n+//! struct List {\n+//!     value: int,\n+//!     tail: Option<Box<List>>,\n+//! }\n+//! ```\n+//!\n+//! will generate the following callstack with a naive DFS algorithm:\n+//!\n+//! ```\n+//! describe(t = List)\n+//!   describe(t = int)\n+//!   describe(t = Option<Box<List>>)\n+//!     describe(t = Box<List>)\n+//!       describe(t = List) // at the beginning again...\n+//!       ...\n+//! ```\n+//!\n+//! To break cycles like these, we use \"forward declarations\". That is, when\n+//! the algorithm encounters a possibly recursive type (any struct or enum), it\n+//! immediately creates a type description node and inserts it into the cache\n+//! *before* describing the members of the type. This type description is just\n+//! a stub (as type members are not described and added to it yet) but it\n+//! allows the algorithm to already refer to the type. After the stub is\n+//! inserted into the cache, the algorithm continues as before. If it now\n+//! encounters a recursive reference, it will hit the cache and does not try to\n+//! describe the type anew.\n+//!\n+//! This behaviour is encapsulated in the 'RecursiveTypeDescription' enum,\n+//! which represents a kind of continuation, storing all state needed to\n+//! continue traversal at the type members after the type has been registered\n+//! with the cache. (This implementation approach might be a tad over-\n+//! engineered and may change in the future)\n+//!\n+//!\n+//! ## Source Locations and Line Information\n+//!\n+//! In addition to data type descriptions the debugging information must also\n+//! allow to map machine code locations back to source code locations in order\n+//! to be useful. This functionality is also handled in this module. The\n+//! following functions allow to control source mappings:\n+//!\n+//! + set_source_location()\n+//! + clear_source_location()\n+//! + start_emitting_source_locations()\n+//!\n+//! `set_source_location()` allows to set the current source location. All IR\n+//! instructions created after a call to this function will be linked to the\n+//! given source location, until another location is specified with\n+//! `set_source_location()` or the source location is cleared with\n+//! `clear_source_location()`. In the later case, subsequent IR instruction\n+//! will not be linked to any source location. As you can see, this is a\n+//! stateful API (mimicking the one in LLVM), so be careful with source\n+//! locations set by previous calls. It's probably best to not rely on any\n+//! specific state being present at a given point in code.\n+//!\n+//! One topic that deserves some extra attention is *function prologues*. At\n+//! the beginning of a function's machine code there are typically a few\n+//! instructions for loading argument values into allocas and checking if\n+//! there's enough stack space for the function to execute. This *prologue* is\n+//! not visible in the source code and LLVM puts a special PROLOGUE END marker\n+//! into the line table at the first non-prologue instruction of the function.\n+//! In order to find out where the prologue ends, LLVM looks for the first\n+//! instruction in the function body that is linked to a source location. So,\n+//! when generating prologue instructions we have to make sure that we don't\n+//! emit source location information until the 'real' function body begins. For\n+//! this reason, source location emission is disabled by default for any new\n+//! function being translated and is only activated after a call to the third\n+//! function from the list above, `start_emitting_source_locations()`. This\n+//! function should be called right before regularly starting to translate the\n+//! top-level block of the given function.\n+//!\n+//! There is one exception to the above rule: `llvm.dbg.declare` instruction\n+//! must be linked to the source location of the variable being declared. For\n+//! function parameters these `llvm.dbg.declare` instructions typically occur\n+//! in the middle of the prologue, however, they are ignored by LLVM's prologue\n+//! detection. The `create_argument_metadata()` and related functions take care\n+//! of linking the `llvm.dbg.declare` instructions to the correct source\n+//! locations even while source location emission is still disabled, so there\n+//! is no need to do anything special with source location handling here.\n+//!\n+//! ## Unique Type Identification\n+//!\n+//! In order for link-time optimization to work properly, LLVM needs a unique\n+//! type identifier that tells it across compilation units which types are the\n+//! same as others. This type identifier is created by\n+//! TypeMap::get_unique_type_id_of_type() using the following algorithm:\n+//!\n+//! (1) Primitive types have their name as ID\n+//! (2) Structs, enums and traits have a multipart identifier\n+//!\n+//!     (1) The first part is the SVH (strict version hash) of the crate they\n+//!          wereoriginally defined in\n+//!\n+//!     (2) The second part is the ast::NodeId of the definition in their\n+//!          originalcrate\n+//!\n+//!     (3) The final part is a concatenation of the type IDs of their concrete\n+//!          typearguments if they are generic types.\n+//!\n+//! (3) Tuple-, pointer and function types are structurally identified, which\n+//!     means that they are equivalent if their component types are equivalent\n+//!     (i.e. (int, int) is the same regardless in which crate it is used).\n+//!\n+//! This algorithm also provides a stable ID for types that are defined in one\n+//! crate but instantiated from metadata within another crate. We just have to\n+//! take care to always map crate and node IDs back to the original crate\n+//! context.\n+//!\n+//! As a side-effect these unique type IDs also help to solve a problem arising\n+//! from lifetime parameters. Since lifetime parameters are completely omitted\n+//! in debuginfo, more than one `Ty` instance may map to the same debuginfo\n+//! type metadata, that is, some struct `Struct<'a>` may have N instantiations\n+//! with different concrete substitutions for `'a`, and thus there will be N\n+//! `Ty` instances for the type `Struct<'a>` even though it is not generic\n+//! otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n+//! cheap identifier for type metadata---we have done this in the past, but it\n+//! led to unnecessary metadata duplication in the best case and LLVM\n+//! assertions in the worst. However, the unique type ID as described above\n+//! *can* be used as identifier. Since it is comparatively expensive to\n+//! construct, though, `ty::type_id()` is still used additionally as an\n+//! optimization for cases where the exact same type has been seen before\n+//! (which is most of the time)."}, {"sha": "a6f1199d0ffe7354997e18371da1e768a47626fc", "filename": "src/librustc_trans/trans/debuginfo/gdb.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs?ref=3434469b518bda1d140e7859239ad1c800060af8", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// .debug_gdb_scripts binary section.\n+\n+use llvm;\n+use llvm::ValueRef;\n+\n+use trans::common::{C_bytes, CrateContext};\n+use trans::declare;\n+use trans::type_::Type;\n+use middle::ty::ClosureTyper;\n+use session::config::NoDebugInfo;\n+\n+use std::ffi::CString;\n+use std::ptr;\n+use syntax::attr;\n+\n+\n+/// Inserts a side-effect free instruction sequence that makes sure that the\n+/// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n+pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext) {\n+    if needs_gdb_debug_scripts_section(ccx) {\n+        let empty = CString::new(\"\").unwrap();\n+        let gdb_debug_scripts_section_global =\n+            get_or_insert_gdb_debug_scripts_section_global(ccx);\n+        unsafe {\n+            let volative_load_instruction =\n+                llvm::LLVMBuildLoad(ccx.raw_builder(),\n+                                    gdb_debug_scripts_section_global,\n+                                    empty.as_ptr());\n+            llvm::LLVMSetVolatile(volative_load_instruction, llvm::True);\n+        }\n+    }\n+}\n+\n+/// Allocates the global variable responsible for the .debug_gdb_scripts binary\n+/// section.\n+pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n+                                                  -> llvm::ValueRef {\n+    let section_var_name = \"__rustc_debug_gdb_scripts_section__\";\n+\n+    let section_var = unsafe {\n+        llvm::LLVMGetNamedGlobal(ccx.llmod(),\n+                                 section_var_name.as_ptr() as *const _)\n+    };\n+\n+    if section_var == ptr::null_mut() {\n+        let section_name = b\".debug_gdb_scripts\\0\";\n+        let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n+\n+        unsafe {\n+            let llvm_type = Type::array(&Type::i8(ccx),\n+                                        section_contents.len() as u64);\n+\n+            let section_var = declare::define_global(ccx, section_var_name,\n+                                                     llvm_type).unwrap_or_else(||{\n+                ccx.sess().bug(&format!(\"symbol `{}` is already defined\", section_var_name))\n+            });\n+            llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n+            llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n+            llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n+            llvm::LLVMSetUnnamedAddr(section_var, llvm::True);\n+            llvm::SetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);\n+            // This should make sure that the whole section is not larger than\n+            // the string it contains. Otherwise we get a warning from GDB.\n+            llvm::LLVMSetAlignment(section_var, 1);\n+            section_var\n+        }\n+    } else {\n+        section_var\n+    }\n+}\n+\n+pub fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n+    let omit_gdb_pretty_printer_section =\n+        attr::contains_name(&ccx.tcx()\n+                                .map\n+                                .krate()\n+                                .attrs,\n+                            \"omit_gdb_pretty_printer_section\");\n+\n+    !omit_gdb_pretty_printer_section &&\n+    !ccx.sess().target.target.options.is_like_osx &&\n+    !ccx.sess().target.target.options.is_like_windows &&\n+    ccx.sess().opts.debuginfo != NoDebugInfo\n+}"}, {"sha": "9ff69e7f9dd294c2f43ba57f0dd28130e4fee0c5", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "renamed", "additions": 1272, "deletions": 3233, "changes": 4505, "blob_url": "https://github.com/rust-lang/rust/blob/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=3434469b518bda1d140e7859239ad1c800060af8", "previous_filename": "src/librustc_trans/trans/debuginfo.rs"}, {"sha": "e4312b669ad98d2cce97fbb5b57944cddb729033", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "added", "additions": 651, "deletions": 0, "changes": 651, "blob_url": "https://github.com/rust-lang/rust/blob/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=3434469b518bda1d140e7859239ad1c800060af8", "patch": "@@ -0,0 +1,651 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See doc.rs for documentation.\n+mod doc;\n+\n+use self::VariableAccess::*;\n+use self::VariableKind::*;\n+\n+use self::utils::{DIB, span_start, assert_type_for_node_id, contains_nodebug_attribute,\n+                  create_DIArray, is_node_local_to_unit};\n+use self::namespace::{namespace_for_item, NamespaceTreeNode};\n+use self::type_names::compute_debuginfo_type_name;\n+use self::metadata::{type_metadata, file_metadata, scope_metadata, TypeMap, compile_unit_metadata};\n+use self::source_loc::InternalDebugLocation;\n+\n+use llvm;\n+use llvm::{ModuleRef, ContextRef, ValueRef};\n+use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray,\n+                      DIDescriptor, FlagPrototyped};\n+use middle::subst::{self, Substs};\n+use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n+use trans;\n+use trans::monomorphize;\n+use middle::ty::{self, Ty, ClosureTyper};\n+use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n+use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n+\n+use libc::c_uint;\n+use std::cell::{Cell, RefCell};\n+use std::ffi::CString;\n+use std::ptr;\n+use std::rc::Rc;\n+use syntax::codemap::{Span, Pos};\n+use syntax::{ast, codemap, ast_util, ast_map};\n+use syntax::parse::token::{self, special_idents};\n+\n+pub mod gdb;\n+mod utils;\n+mod namespace;\n+mod type_names;\n+mod metadata;\n+mod create_scope_map;\n+mod source_loc;\n+\n+pub use self::source_loc::set_source_location;\n+pub use self::source_loc::clear_source_location;\n+pub use self::source_loc::start_emitting_source_locations;\n+pub use self::source_loc::get_cleanup_debug_loc_for_ast_node;\n+pub use self::source_loc::with_source_location_override;\n+pub use self::metadata::create_match_binding_metadata;\n+pub use self::metadata::create_argument_metadata;\n+pub use self::metadata::create_captured_var_metadata;\n+pub use self::metadata::create_global_var_metadata;\n+pub use self::metadata::create_local_var_metadata;\n+\n+#[allow(non_upper_case_globals)]\n+const DW_TAG_auto_variable: c_uint = 0x100;\n+#[allow(non_upper_case_globals)]\n+const DW_TAG_arg_variable: c_uint = 0x101;\n+\n+/// A context object for maintaining all state needed by the debuginfo module.\n+pub struct CrateDebugContext<'tcx> {\n+    llcontext: ContextRef,\n+    builder: DIBuilderRef,\n+    current_debug_location: Cell<InternalDebugLocation>,\n+    created_files: RefCell<FnvHashMap<String, DIFile>>,\n+    created_enum_disr_types: RefCell<DefIdMap<DIType>>,\n+\n+    type_map: RefCell<TypeMap<'tcx>>,\n+    namespace_map: RefCell<FnvHashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n+\n+    // This collection is used to assert that composite types (structs, enums,\n+    // ...) have their members only set once:\n+    composite_types_completed: RefCell<FnvHashSet<DIType>>,\n+}\n+\n+impl<'tcx> CrateDebugContext<'tcx> {\n+    pub fn new(llmod: ModuleRef) -> CrateDebugContext<'tcx> {\n+        debug!(\"CrateDebugContext::new\");\n+        let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n+        // DIBuilder inherits context from the module, so we'd better use the same one\n+        let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n+        return CrateDebugContext {\n+            llcontext: llcontext,\n+            builder: builder,\n+            current_debug_location: Cell::new(InternalDebugLocation::UnknownLocation),\n+            created_files: RefCell::new(FnvHashMap()),\n+            created_enum_disr_types: RefCell::new(DefIdMap()),\n+            type_map: RefCell::new(TypeMap::new()),\n+            namespace_map: RefCell::new(FnvHashMap()),\n+            composite_types_completed: RefCell::new(FnvHashSet()),\n+        };\n+    }\n+}\n+\n+pub enum FunctionDebugContext {\n+    RegularContext(Box<FunctionDebugContextData>),\n+    DebugInfoDisabled,\n+    FunctionWithoutDebugInfo,\n+}\n+\n+impl FunctionDebugContext {\n+    fn get_ref<'a>(&'a self,\n+                   cx: &CrateContext,\n+                   span: Span)\n+                   -> &'a FunctionDebugContextData {\n+        match *self {\n+            FunctionDebugContext::RegularContext(box ref data) => data,\n+            FunctionDebugContext::DebugInfoDisabled => {\n+                cx.sess().span_bug(span,\n+                                   FunctionDebugContext::debuginfo_disabled_message());\n+            }\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n+                cx.sess().span_bug(span,\n+                                   FunctionDebugContext::should_be_ignored_message());\n+            }\n+        }\n+    }\n+\n+    fn debuginfo_disabled_message() -> &'static str {\n+        \"debuginfo: Error trying to access FunctionDebugContext although debug info is disabled!\"\n+    }\n+\n+    fn should_be_ignored_message() -> &'static str {\n+        \"debuginfo: Error trying to access FunctionDebugContext for function that should be \\\n+         ignored by debug info!\"\n+    }\n+}\n+\n+struct FunctionDebugContextData {\n+    scope_map: RefCell<NodeMap<DIScope>>,\n+    fn_metadata: DISubprogram,\n+    argument_counter: Cell<usize>,\n+    source_locations_enabled: Cell<bool>,\n+    source_location_override: Cell<bool>,\n+}\n+\n+pub enum VariableAccess<'a> {\n+    // The llptr given is an alloca containing the variable's value\n+    DirectVariable { alloca: ValueRef },\n+    // The llptr given is an alloca containing the start of some pointer chain\n+    // leading to the variable's content.\n+    IndirectVariable { alloca: ValueRef, address_operations: &'a [i64] }\n+}\n+\n+pub enum VariableKind {\n+    ArgumentVariable(usize /*index*/),\n+    LocalVariable,\n+    CapturedVariable,\n+}\n+\n+/// Create any deferred debug metadata nodes\n+pub fn finalize(cx: &CrateContext) {\n+    if cx.dbg_cx().is_none() {\n+        return;\n+    }\n+\n+    debug!(\"finalize\");\n+    let _ = compile_unit_metadata(cx);\n+\n+    if gdb::needs_gdb_debug_scripts_section(cx) {\n+        // Add a .debug_gdb_scripts section to this compile-unit. This will\n+        // cause GDB to try and load the gdb_load_rust_pretty_printers.py file,\n+        // which activates the Rust pretty printers for binary this section is\n+        // contained in.\n+        gdb::get_or_insert_gdb_debug_scripts_section_global(cx);\n+    }\n+\n+    unsafe {\n+        llvm::LLVMDIBuilderFinalize(DIB(cx));\n+        llvm::LLVMDIBuilderDispose(DIB(cx));\n+        // Debuginfo generation in LLVM by default uses a higher\n+        // version of dwarf than OS X currently understands. We can\n+        // instruct LLVM to emit an older version of dwarf, however,\n+        // for OS X to understand. For more info see #11352\n+        // This can be overridden using --llvm-opts -dwarf-version,N.\n+        // Android has the same issue (#22398)\n+        if cx.sess().target.target.options.is_like_osx ||\n+           cx.sess().target.target.options.is_like_android {\n+            llvm::LLVMRustAddModuleFlag(cx.llmod(),\n+                                        \"Dwarf Version\\0\".as_ptr() as *const _,\n+                                        2)\n+        }\n+\n+        // Prevent bitcode readers from deleting the debug info.\n+        let ptr = \"Debug Info Version\\0\".as_ptr();\n+        llvm::LLVMRustAddModuleFlag(cx.llmod(), ptr as *const _,\n+                                    llvm::LLVMRustDebugMetadataVersion);\n+    };\n+}\n+\n+/// Creates the function-specific debug context.\n+///\n+/// Returns the FunctionDebugContext for the function which holds state needed\n+/// for debug info creation. The function may also return another variant of the\n+/// FunctionDebugContext enum which indicates why no debuginfo should be created\n+/// for the function.\n+pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                               fn_ast_id: ast::NodeId,\n+                                               param_substs: &Substs<'tcx>,\n+                                               llfn: ValueRef) -> FunctionDebugContext {\n+    if cx.sess().opts.debuginfo == NoDebugInfo {\n+        return FunctionDebugContext::DebugInfoDisabled;\n+    }\n+\n+    // Clear the debug location so we don't assign them in the function prelude.\n+    // Do this here already, in case we do an early exit from this function.\n+    source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n+\n+    if fn_ast_id == ast::DUMMY_NODE_ID {\n+        // This is a function not linked to any source location, so don't\n+        // generate debuginfo for it.\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+    }\n+\n+    let empty_generics = ast_util::empty_generics();\n+\n+    let fnitem = cx.tcx().map.get(fn_ast_id);\n+\n+    let (name, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n+        ast_map::NodeItem(ref item) => {\n+            if contains_nodebug_attribute(&item.attrs) {\n+                return FunctionDebugContext::FunctionWithoutDebugInfo;\n+            }\n+\n+            match item.node {\n+                ast::ItemFn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n+                    (item.ident.name, fn_decl, generics, top_level_block, item.span, true)\n+                }\n+                _ => {\n+                    cx.sess().span_bug(item.span,\n+                        \"create_function_debug_context: item bound to non-function\");\n+                }\n+            }\n+        }\n+        ast_map::NodeImplItem(impl_item) => {\n+            match impl_item.node {\n+                ast::MethodImplItem(ref sig, ref body) => {\n+                    if contains_nodebug_attribute(&impl_item.attrs) {\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                    }\n+\n+                    (impl_item.ident.name,\n+                     &sig.decl,\n+                     &sig.generics,\n+                     body,\n+                     impl_item.span,\n+                     true)\n+                }\n+                _ => {\n+                    cx.sess().span_bug(impl_item.span,\n+                                       \"create_function_debug_context() \\\n+                                        called on non-method impl item?!\")\n+                }\n+            }\n+        }\n+        ast_map::NodeExpr(ref expr) => {\n+            match expr.node {\n+                ast::ExprClosure(_, ref fn_decl, ref top_level_block) => {\n+                    let name = format!(\"fn{}\", token::gensym(\"fn\"));\n+                    let name = token::intern(&name[..]);\n+                    (name, fn_decl,\n+                        // This is not quite right. It should actually inherit\n+                        // the generics of the enclosing function.\n+                        &empty_generics,\n+                        top_level_block,\n+                        expr.span,\n+                        // Don't try to lookup the item path:\n+                        false)\n+                }\n+                _ => cx.sess().span_bug(expr.span,\n+                        \"create_function_debug_context: expected an expr_fn_block here\")\n+            }\n+        }\n+        ast_map::NodeTraitItem(trait_item) => {\n+            match trait_item.node {\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                    if contains_nodebug_attribute(&trait_item.attrs) {\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                    }\n+\n+                    (trait_item.ident.name,\n+                     &sig.decl,\n+                     &sig.generics,\n+                     body,\n+                     trait_item.span,\n+                     true)\n+                }\n+                _ => {\n+                    cx.sess()\n+                      .bug(&format!(\"create_function_debug_context: \\\n+                                    unexpected sort of node: {:?}\",\n+                                    fnitem))\n+                }\n+            }\n+        }\n+        ast_map::NodeForeignItem(..) |\n+        ast_map::NodeVariant(..) |\n+        ast_map::NodeStructCtor(..) => {\n+            return FunctionDebugContext::FunctionWithoutDebugInfo;\n+        }\n+        _ => cx.sess().bug(&format!(\"create_function_debug_context: \\\n+                                    unexpected sort of node: {:?}\",\n+                                   fnitem))\n+    };\n+\n+    // This can be the case for functions inlined from another crate\n+    if span == codemap::DUMMY_SP {\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+    }\n+\n+    let loc = span_start(cx, span);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n+\n+    let function_type_metadata = unsafe {\n+        let fn_signature = get_function_signature(cx,\n+                                                  fn_ast_id,\n+                                                  &*fn_decl,\n+                                                  param_substs,\n+                                                  span);\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n+    };\n+\n+    // Get_template_parameters() will append a `<...>` clause to the function\n+    // name if necessary.\n+    let mut function_name = String::from_str(&token::get_name(name));\n+    let template_parameters = get_template_parameters(cx,\n+                                                      generics,\n+                                                      param_substs,\n+                                                      file_metadata,\n+                                                      &mut function_name);\n+\n+    // There is no ast_map::Path for ast::ExprClosure-type functions. For now,\n+    // just don't put them into a namespace. In the future this could be improved\n+    // somehow (storing a path in the ast_map, or construct a path using the\n+    // enclosing function).\n+    let (linkage_name, containing_scope) = if has_path {\n+        let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n+        let linkage_name = namespace_node.mangled_name_of_contained_item(\n+            &function_name[..]);\n+        let containing_scope = namespace_node.scope;\n+        (linkage_name, containing_scope)\n+    } else {\n+        (function_name.clone(), file_metadata)\n+    };\n+\n+    // Clang sets this parameter to the opening brace of the function's block,\n+    // so let's do this too.\n+    let scope_line = span_start(cx, top_level_block.span).line;\n+\n+    let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n+\n+    let function_name = CString::new(function_name).unwrap();\n+    let linkage_name = CString::new(linkage_name).unwrap();\n+    let fn_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateFunction(\n+            DIB(cx),\n+            containing_scope,\n+            function_name.as_ptr(),\n+            linkage_name.as_ptr(),\n+            file_metadata,\n+            loc.line as c_uint,\n+            function_type_metadata,\n+            is_local_to_unit,\n+            true,\n+            scope_line as c_uint,\n+            FlagPrototyped as c_uint,\n+            cx.sess().opts.optimize != config::No,\n+            llfn,\n+            template_parameters,\n+            ptr::null_mut())\n+    };\n+\n+    let scope_map = create_scope_map::create_scope_map(cx,\n+                                                       &fn_decl.inputs,\n+                                                       &*top_level_block,\n+                                                       fn_metadata,\n+                                                       fn_ast_id);\n+\n+    // Initialize fn debug context (including scope map and namespace map)\n+    let fn_debug_context = box FunctionDebugContextData {\n+        scope_map: RefCell::new(scope_map),\n+        fn_metadata: fn_metadata,\n+        argument_counter: Cell::new(1),\n+        source_locations_enabled: Cell::new(false),\n+        source_location_override: Cell::new(false),\n+    };\n+\n+\n+\n+    return FunctionDebugContext::RegularContext(fn_debug_context);\n+\n+    fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                        fn_ast_id: ast::NodeId,\n+                                        fn_decl: &ast::FnDecl,\n+                                        param_substs: &Substs<'tcx>,\n+                                        error_reporting_span: Span) -> DIArray {\n+        if cx.sess().opts.debuginfo == LimitedDebugInfo {\n+            return create_DIArray(DIB(cx), &[]);\n+        }\n+\n+        let mut signature = Vec::with_capacity(fn_decl.inputs.len() + 1);\n+\n+        // Return type -- llvm::DIBuilder wants this at index 0\n+        assert_type_for_node_id(cx, fn_ast_id, error_reporting_span);\n+        let return_type = ty::node_id_to_type(cx.tcx(), fn_ast_id);\n+        let return_type = monomorphize::apply_param_substs(cx.tcx(),\n+                                                           param_substs,\n+                                                           &return_type);\n+        if ty::type_is_nil(return_type) {\n+            signature.push(ptr::null_mut())\n+        } else {\n+            signature.push(type_metadata(cx, return_type, codemap::DUMMY_SP));\n+        }\n+\n+        // Arguments types\n+        for arg in &fn_decl.inputs {\n+            assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n+            let arg_type = ty::node_id_to_type(cx.tcx(), arg.pat.id);\n+            let arg_type = monomorphize::apply_param_substs(cx.tcx(),\n+                                                            param_substs,\n+                                                            &arg_type);\n+            signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n+        }\n+\n+        return create_DIArray(DIB(cx), &signature[..]);\n+    }\n+\n+    fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                         generics: &ast::Generics,\n+                                         param_substs: &Substs<'tcx>,\n+                                         file_metadata: DIFile,\n+                                         name_to_append_suffix_to: &mut String)\n+                                         -> DIArray\n+    {\n+        let self_type = param_substs.self_ty();\n+        let self_type = monomorphize::normalize_associated_type(cx.tcx(), &self_type);\n+\n+        // Only true for static default methods:\n+        let has_self_type = self_type.is_some();\n+\n+        if !generics.is_type_parameterized() && !has_self_type {\n+            return create_DIArray(DIB(cx), &[]);\n+        }\n+\n+        name_to_append_suffix_to.push('<');\n+\n+        // The list to be filled with template parameters:\n+        let mut template_params: Vec<DIDescriptor> =\n+            Vec::with_capacity(generics.ty_params.len() + 1);\n+\n+        // Handle self type\n+        if has_self_type {\n+            let actual_self_type = self_type.unwrap();\n+            // Add self type name to <...> clause of function name\n+            let actual_self_type_name = compute_debuginfo_type_name(\n+                cx,\n+                actual_self_type,\n+                true);\n+\n+            name_to_append_suffix_to.push_str(&actual_self_type_name[..]);\n+\n+            if generics.is_type_parameterized() {\n+                name_to_append_suffix_to.push_str(\",\");\n+            }\n+\n+            // Only create type information if full debuginfo is enabled\n+            if cx.sess().opts.debuginfo == FullDebugInfo {\n+                let actual_self_type_metadata = type_metadata(cx,\n+                                                              actual_self_type,\n+                                                              codemap::DUMMY_SP);\n+\n+                let name = token::get_name(special_idents::type_self.name);\n+\n+                let name = CString::new(name.as_bytes()).unwrap();\n+                let param_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name.as_ptr(),\n+                        actual_self_type_metadata,\n+                        ptr::null_mut(),\n+                        0,\n+                        0)\n+                };\n+\n+                template_params.push(param_metadata);\n+            }\n+        }\n+\n+        // Handle other generic parameters\n+        let actual_types = param_substs.types.get_slice(subst::FnSpace);\n+        for (index, &ast::TyParam{ ident, .. }) in generics.ty_params.iter().enumerate() {\n+            let actual_type = actual_types[index];\n+            // Add actual type name to <...> clause of function name\n+            let actual_type_name = compute_debuginfo_type_name(cx,\n+                                                               actual_type,\n+                                                               true);\n+            name_to_append_suffix_to.push_str(&actual_type_name[..]);\n+\n+            if index != generics.ty_params.len() - 1 {\n+                name_to_append_suffix_to.push_str(\",\");\n+            }\n+\n+            // Again, only create type information if full debuginfo is enabled\n+            if cx.sess().opts.debuginfo == FullDebugInfo {\n+                let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n+                let ident = token::get_ident(ident);\n+                let name = CString::new(ident.as_bytes()).unwrap();\n+                let param_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name.as_ptr(),\n+                        actual_type_metadata,\n+                        ptr::null_mut(),\n+                        0,\n+                        0)\n+                };\n+                template_params.push(param_metadata);\n+            }\n+        }\n+\n+        name_to_append_suffix_to.push('>');\n+\n+        return create_DIArray(DIB(cx), &template_params[..]);\n+    }\n+}\n+\n+fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             variable_name: ast::Name,\n+                             variable_type: Ty<'tcx>,\n+                             scope_metadata: DIScope,\n+                             variable_access: VariableAccess,\n+                             variable_kind: VariableKind,\n+                             span: Span) {\n+    let cx: &CrateContext = bcx.ccx();\n+\n+    let filename = span_start(cx, span).file.name.clone();\n+    let file_metadata = file_metadata(cx, &filename[..]);\n+\n+    let name = token::get_name(variable_name);\n+    let loc = span_start(cx, span);\n+    let type_metadata = type_metadata(cx, variable_type, span);\n+\n+    let (argument_index, dwarf_tag) = match variable_kind {\n+        ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n+        LocalVariable    |\n+        CapturedVariable => (0, DW_TAG_auto_variable)\n+    };\n+\n+    let name = CString::new(name.as_bytes()).unwrap();\n+    match (variable_access, &[][..]) {\n+        (DirectVariable { alloca }, address_operations) |\n+        (IndirectVariable {alloca, address_operations}, _) => {\n+            let metadata = unsafe {\n+                llvm::LLVMDIBuilderCreateVariable(\n+                    DIB(cx),\n+                    dwarf_tag,\n+                    scope_metadata,\n+                    name.as_ptr(),\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    cx.sess().opts.optimize != config::No,\n+                    0,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    argument_index)\n+            };\n+            source_loc::set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n+                                                                          loc.line,\n+                                                                          loc.col.to_usize()));\n+            unsafe {\n+                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                    DIB(cx),\n+                    alloca,\n+                    metadata,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    bcx.llbb);\n+\n+                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n+            }\n+        }\n+    }\n+\n+    match variable_kind {\n+        ArgumentVariable(_) | CapturedVariable => {\n+            assert!(!bcx.fcx\n+                        .debug_context\n+                        .get_ref(cx, span)\n+                        .source_locations_enabled\n+                        .get());\n+            source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n+        }\n+        _ => { /* nothing to do */ }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum DebugLoc {\n+    At(ast::NodeId, Span),\n+    None\n+}\n+\n+impl DebugLoc {\n+    pub fn apply(&self, fcx: &FunctionContext) {\n+        match *self {\n+            DebugLoc::At(node_id, span) => {\n+                source_loc::set_source_location(fcx, node_id, span);\n+            }\n+            DebugLoc::None => {\n+                source_loc::clear_source_location(fcx);\n+            }\n+        }\n+    }\n+}\n+\n+pub trait ToDebugLoc {\n+    fn debug_loc(&self) -> DebugLoc;\n+}\n+\n+impl ToDebugLoc for ast::Expr {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n+\n+impl ToDebugLoc for NodeIdAndSpan {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n+\n+impl ToDebugLoc for Option<NodeIdAndSpan> {\n+    fn debug_loc(&self) -> DebugLoc {\n+        match *self {\n+            Some(NodeIdAndSpan { id, span }) => DebugLoc::At(id, span),\n+            None => DebugLoc::None\n+        }\n+    }\n+}"}, {"sha": "0aa0408c0ef33c31a89fd1566901207dfa7b56cb", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=3434469b518bda1d140e7859239ad1c800060af8", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Namespace Handling.\n+\n+use super::utils::{DIB, debug_context};\n+\n+use llvm;\n+use llvm::debuginfo::DIScope;\n+use trans::common::CrateContext;\n+use middle::ty::{self, ClosureTyper};\n+\n+use std::ffi::CString;\n+use std::ptr;\n+use std::rc::{Rc, Weak};\n+use syntax::{ast, ast_map};\n+use syntax::parse::token;\n+\n+pub struct NamespaceTreeNode {\n+    pub name: ast::Name,\n+    pub scope: DIScope,\n+    pub parent: Option<Weak<NamespaceTreeNode>>,\n+}\n+\n+impl NamespaceTreeNode {\n+    pub fn mangled_name_of_contained_item(&self, item_name: &str) -> String {\n+        fn fill_nested(node: &NamespaceTreeNode, output: &mut String) {\n+            match node.parent {\n+                Some(ref parent) => fill_nested(&*parent.upgrade().unwrap(), output),\n+                None => {}\n+            }\n+            let string = token::get_name(node.name);\n+            output.push_str(&format!(\"{}\", string.len()));\n+            output.push_str(&string);\n+        }\n+\n+        let mut name = String::from_str(\"_ZN\");\n+        fill_nested(self, &mut name);\n+        name.push_str(&format!(\"{}\", item_name.len()));\n+        name.push_str(item_name);\n+        name.push('E');\n+        name\n+    }\n+}\n+\n+pub fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n+    &cx.link_meta().crate_name\n+}\n+\n+pub fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n+    ty::with_path(cx.tcx(), def_id, |path| {\n+        // prepend crate name if not already present\n+        let krate = if def_id.krate == ast::LOCAL_CRATE {\n+            let crate_namespace_name = token::intern(crate_root_namespace(cx));\n+            Some(ast_map::PathMod(crate_namespace_name))\n+        } else {\n+            None\n+        };\n+        let mut path = krate.into_iter().chain(path).peekable();\n+\n+        let mut current_key = Vec::new();\n+        let mut parent_node: Option<Rc<NamespaceTreeNode>> = None;\n+\n+        // Create/Lookup namespace for each element of the path.\n+        loop {\n+            // Emulate a for loop so we can use peek below.\n+            let path_element = match path.next() {\n+                Some(e) => e,\n+                None => break\n+            };\n+            // Ignore the name of the item (the last path element).\n+            if path.peek().is_none() {\n+                break;\n+            }\n+\n+            let name = path_element.name();\n+            current_key.push(name);\n+\n+            let existing_node = debug_context(cx).namespace_map.borrow()\n+                                                 .get(&current_key).cloned();\n+            let current_node = match existing_node {\n+                Some(existing_node) => existing_node,\n+                None => {\n+                    // create and insert\n+                    let parent_scope = match parent_node {\n+                        Some(ref node) => node.scope,\n+                        None => ptr::null_mut()\n+                    };\n+                    let namespace_name = token::get_name(name);\n+                    let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n+                    let scope = unsafe {\n+                        llvm::LLVMDIBuilderCreateNameSpace(\n+                            DIB(cx),\n+                            parent_scope,\n+                            namespace_name.as_ptr(),\n+                            // cannot reconstruct file ...\n+                            ptr::null_mut(),\n+                            // ... or line information, but that's not so important.\n+                            0)\n+                    };\n+\n+                    let node = Rc::new(NamespaceTreeNode {\n+                        name: name,\n+                        scope: scope,\n+                        parent: parent_node.map(|parent| parent.downgrade()),\n+                    });\n+\n+                    debug_context(cx).namespace_map.borrow_mut()\n+                                     .insert(current_key.clone(), node.clone());\n+\n+                    node\n+                }\n+            };\n+\n+            parent_node = Some(current_node);\n+        }\n+\n+        match parent_node {\n+            Some(node) => node,\n+            None => {\n+                cx.sess().bug(&format!(\"debuginfo::namespace_for_item(): \\\n+                                       path too short for {:?}\",\n+                                      def_id));\n+            }\n+        }\n+    })\n+}"}, {"sha": "981a23fd664a91380c3376c9b3c55738d9d9caf0", "filename": "src/librustc_trans/trans/debuginfo/source_loc.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fsource_loc.rs?ref=3434469b518bda1d140e7859239ad1c800060af8", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::InternalDebugLocation::*;\n+\n+use super::utils::{debug_context, span_start, fn_should_be_ignored};\n+use super::metadata::{scope_metadata,UNKNOWN_COLUMN_NUMBER};\n+use super::{FunctionDebugContext, DebugLoc};\n+\n+use llvm;\n+use llvm::debuginfo::DIScope;\n+use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext};\n+\n+use libc::c_uint;\n+use std::ptr;\n+use syntax::codemap::{Span, Pos};\n+use syntax::{ast, codemap};\n+\n+pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                                    node_id: ast::NodeId,\n+                                                    node_span: Span,\n+                                                    is_block: bool)\n+                                                 -> NodeIdAndSpan {\n+    // A debug location needs two things:\n+    // (1) A span (of which only the beginning will actually be used)\n+    // (2) An AST node-id which will be used to look up the lexical scope\n+    //     for the location in the functions scope-map\n+    //\n+    // This function will calculate the debug location for compiler-generated\n+    // cleanup calls that are executed when control-flow leaves the\n+    // scope identified by `node_id`.\n+    //\n+    // For everything but block-like things we can simply take id and span of\n+    // the given expression, meaning that from a debugger's view cleanup code is\n+    // executed at the same source location as the statement/expr itself.\n+    //\n+    // Blocks are a special case. Here we want the cleanup to be linked to the\n+    // closing curly brace of the block. The *scope* the cleanup is executed in\n+    // is up to debate: It could either still be *within* the block being\n+    // cleaned up, meaning that locals from the block are still visible in the\n+    // debugger.\n+    // Or it could be in the scope that the block is contained in, so any locals\n+    // from within the block are already considered out-of-scope and thus not\n+    // accessible in the debugger anymore.\n+    //\n+    // The current implementation opts for the second option: cleanup of a block\n+    // already happens in the parent scope of the block. The main reason for\n+    // this decision is that scoping becomes controlflow dependent when variable\n+    // shadowing is involved and it's impossible to decide statically which\n+    // scope is actually left when the cleanup code is executed.\n+    // In practice it shouldn't make much of a difference.\n+\n+    let mut cleanup_span = node_span;\n+\n+    if is_block {\n+        // Not all blocks actually have curly braces (e.g. simple closure\n+        // bodies), in which case we also just want to return the span of the\n+        // whole expression.\n+        let code_snippet = cx.sess().codemap().span_to_snippet(node_span);\n+        if let Ok(code_snippet) = code_snippet {\n+            let bytes = code_snippet.as_bytes();\n+\n+            if !bytes.is_empty() && &bytes[bytes.len()-1..] == b\"}\" {\n+                cleanup_span = Span {\n+                    lo: node_span.hi - codemap::BytePos(1),\n+                    hi: node_span.hi,\n+                    expn_id: node_span.expn_id\n+                };\n+            }\n+        }\n+    }\n+\n+    NodeIdAndSpan {\n+        id: node_id,\n+        span: cleanup_span\n+    }\n+}\n+\n+\n+/// Sets the current debug location at the beginning of the span.\n+///\n+/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id\n+/// parameter is used to reliably find the correct visibility scope for the code\n+/// position.\n+pub fn set_source_location(fcx: &FunctionContext,\n+                           node_id: ast::NodeId,\n+                           span: Span) {\n+    match fcx.debug_context {\n+        FunctionDebugContext::DebugInfoDisabled => return,\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n+            set_debug_location(fcx.ccx, UnknownLocation);\n+            return;\n+        }\n+        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n+            if function_debug_context.source_location_override.get() {\n+                // Just ignore any attempts to set a new debug location while\n+                // the override is active.\n+                return;\n+            }\n+\n+            let cx = fcx.ccx;\n+\n+            debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n+\n+            if function_debug_context.source_locations_enabled.get() {\n+                let loc = span_start(cx, span);\n+                let scope = scope_metadata(fcx, node_id, span);\n+\n+                set_debug_location(cx, InternalDebugLocation::new(scope,\n+                                                                  loc.line,\n+                                                                  loc.col.to_usize()));\n+            } else {\n+                set_debug_location(cx, UnknownLocation);\n+            }\n+        }\n+    }\n+}\n+\n+/// This function makes sure that all debug locations emitted while executing\n+/// `wrapped_function` are set to the given `debug_loc`.\n+pub fn with_source_location_override<F, R>(fcx: &FunctionContext,\n+                                           debug_loc: DebugLoc,\n+                                           wrapped_function: F) -> R\n+    where F: FnOnce() -> R\n+{\n+    match fcx.debug_context {\n+        FunctionDebugContext::DebugInfoDisabled => {\n+            wrapped_function()\n+        }\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n+            set_debug_location(fcx.ccx, UnknownLocation);\n+            wrapped_function()\n+        }\n+        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n+            if function_debug_context.source_location_override.get() {\n+                wrapped_function()\n+            } else {\n+                debug_loc.apply(fcx);\n+                function_debug_context.source_location_override.set(true);\n+                let result = wrapped_function();\n+                function_debug_context.source_location_override.set(false);\n+                result\n+            }\n+        }\n+    }\n+}\n+\n+/// Clears the current debug location.\n+///\n+/// Instructions generated hereafter won't be assigned a source location.\n+pub fn clear_source_location(fcx: &FunctionContext) {\n+    if fn_should_be_ignored(fcx) {\n+        return;\n+    }\n+\n+    set_debug_location(fcx.ccx, UnknownLocation);\n+}\n+\n+/// Enables emitting source locations for the given functions.\n+///\n+/// Since we don't want source locations to be emitted for the function prelude,\n+/// they are disabled when beginning to translate a new function. This functions\n+/// switches source location emitting on and must therefore be called before the\n+/// first real statement/expression of the function is translated.\n+pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(box ref data) => {\n+            data.source_locations_enabled.set(true)\n+        },\n+        _ => { /* safe to ignore */ }\n+    }\n+}\n+\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum InternalDebugLocation {\n+    KnownLocation { scope: DIScope, line: usize, col: usize },\n+    UnknownLocation\n+}\n+\n+impl InternalDebugLocation {\n+    pub fn new(scope: DIScope, line: usize, col: usize) -> InternalDebugLocation {\n+        KnownLocation {\n+            scope: scope,\n+            line: line,\n+            col: col,\n+        }\n+    }\n+}\n+\n+pub fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation) {\n+    if debug_location == debug_context(cx).current_debug_location.get() {\n+        return;\n+    }\n+\n+    let metadata_node;\n+\n+    match debug_location {\n+        KnownLocation { scope, line, .. } => {\n+            // Always set the column to zero like Clang and GCC\n+            let col = UNKNOWN_COLUMN_NUMBER;\n+            debug!(\"setting debug location to {} {}\", line, col);\n+\n+            unsafe {\n+                metadata_node = llvm::LLVMDIBuilderCreateDebugLocation(\n+                    debug_context(cx).llcontext,\n+                    line as c_uint,\n+                    col as c_uint,\n+                    scope,\n+                    ptr::null_mut());\n+            }\n+        }\n+        UnknownLocation => {\n+            debug!(\"clearing debug location \");\n+            metadata_node = ptr::null_mut();\n+        }\n+    };\n+\n+    unsafe {\n+        llvm::LLVMSetCurrentDebugLocation(cx.raw_builder(), metadata_node);\n+    }\n+\n+    debug_context(cx).current_debug_location.set(debug_location);\n+}"}, {"sha": "2d0003d93a5d25a8a63e332fc42418331e8973a8", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=3434469b518bda1d140e7859239ad1c800060af8", "patch": "@@ -0,0 +1,230 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Type Names for Debug Info.\n+\n+use super::namespace::crate_root_namespace;\n+\n+use trans::common::CrateContext;\n+use middle::subst::{self, Substs};\n+use middle::ty::{self, Ty, ClosureTyper};\n+use syntax::ast;\n+use syntax::parse::token;\n+use util::ppaux;\n+\n+\n+// Compute the name of the type as it should be stored in debuginfo. Does not do\n+// any caching, i.e. calling the function twice with the same type will also do\n+// the work twice. The `qualified` parameter only affects the first level of the\n+// type name, further levels (i.e. type parameters) are always fully qualified.\n+pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                             t: Ty<'tcx>,\n+                                             qualified: bool)\n+                                             -> String {\n+    let mut result = String::with_capacity(64);\n+    push_debuginfo_type_name(cx, t, qualified, &mut result);\n+    result\n+}\n+\n+// Pushes the name of the type as it should be stored in debuginfo on the\n+// `output` String. See also compute_debuginfo_type_name().\n+pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                          t: Ty<'tcx>,\n+                                          qualified: bool,\n+                                          output: &mut String) {\n+    match t.sty {\n+        ty::ty_bool              => output.push_str(\"bool\"),\n+        ty::ty_char              => output.push_str(\"char\"),\n+        ty::ty_str               => output.push_str(\"str\"),\n+        ty::ty_int(ast::TyIs)     => output.push_str(\"isize\"),\n+        ty::ty_int(ast::TyI8)    => output.push_str(\"i8\"),\n+        ty::ty_int(ast::TyI16)   => output.push_str(\"i16\"),\n+        ty::ty_int(ast::TyI32)   => output.push_str(\"i32\"),\n+        ty::ty_int(ast::TyI64)   => output.push_str(\"i64\"),\n+        ty::ty_uint(ast::TyUs)    => output.push_str(\"usize\"),\n+        ty::ty_uint(ast::TyU8)   => output.push_str(\"u8\"),\n+        ty::ty_uint(ast::TyU16)  => output.push_str(\"u16\"),\n+        ty::ty_uint(ast::TyU32)  => output.push_str(\"u32\"),\n+        ty::ty_uint(ast::TyU64)  => output.push_str(\"u64\"),\n+        ty::ty_float(ast::TyF32) => output.push_str(\"f32\"),\n+        ty::ty_float(ast::TyF64) => output.push_str(\"f64\"),\n+        ty::ty_struct(def_id, substs) |\n+        ty::ty_enum(def_id, substs) => {\n+            push_item_name(cx, def_id, qualified, output);\n+            push_type_params(cx, substs, output);\n+        },\n+        ty::ty_tup(ref component_types) => {\n+            output.push('(');\n+            for &component_type in component_types {\n+                push_debuginfo_type_name(cx, component_type, true, output);\n+                output.push_str(\", \");\n+            }\n+            if !component_types.is_empty() {\n+                output.pop();\n+                output.pop();\n+            }\n+            output.push(')');\n+        },\n+        ty::ty_uniq(inner_type) => {\n+            output.push_str(\"Box<\");\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+            output.push('>');\n+        },\n+        ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n+            output.push('*');\n+            match mutbl {\n+                ast::MutImmutable => output.push_str(\"const \"),\n+                ast::MutMutable => output.push_str(\"mut \"),\n+            }\n+\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+        },\n+        ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n+            output.push('&');\n+            if mutbl == ast::MutMutable {\n+                output.push_str(\"mut \");\n+            }\n+\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+        },\n+        ty::ty_vec(inner_type, optional_length) => {\n+            output.push('[');\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+\n+            match optional_length {\n+                Some(len) => {\n+                    output.push_str(&format!(\"; {}\", len));\n+                }\n+                None => { /* nothing to do */ }\n+            };\n+\n+            output.push(']');\n+        },\n+        ty::ty_trait(ref trait_data) => {\n+            let principal = ty::erase_late_bound_regions(cx.tcx(), &trait_data.principal);\n+            push_item_name(cx, principal.def_id, false, output);\n+            push_type_params(cx, principal.substs, output);\n+        },\n+        ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            if unsafety == ast::Unsafety::Unsafe {\n+                output.push_str(\"unsafe \");\n+            }\n+\n+            if abi != ::syntax::abi::Rust {\n+                output.push_str(\"extern \\\"\");\n+                output.push_str(abi.name());\n+                output.push_str(\"\\\" \");\n+            }\n+\n+            output.push_str(\"fn(\");\n+\n+            let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+            if !sig.inputs.is_empty() {\n+                for &parameter_type in &sig.inputs {\n+                    push_debuginfo_type_name(cx, parameter_type, true, output);\n+                    output.push_str(\", \");\n+                }\n+                output.pop();\n+                output.pop();\n+            }\n+\n+            if sig.variadic {\n+                if !sig.inputs.is_empty() {\n+                    output.push_str(\", ...\");\n+                } else {\n+                    output.push_str(\"...\");\n+                }\n+            }\n+\n+            output.push(')');\n+\n+            match sig.output {\n+                ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n+                ty::FnConverging(result_type) => {\n+                    output.push_str(\" -> \");\n+                    push_debuginfo_type_name(cx, result_type, true, output);\n+                }\n+                ty::FnDiverging => {\n+                    output.push_str(\" -> !\");\n+                }\n+            }\n+        },\n+        ty::ty_closure(..) => {\n+            output.push_str(\"closure\");\n+        }\n+        ty::ty_err |\n+        ty::ty_infer(_) |\n+        ty::ty_projection(..) |\n+        ty::ty_param(_) => {\n+            cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n+                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)));\n+        }\n+    }\n+\n+    fn push_item_name(cx: &CrateContext,\n+                      def_id: ast::DefId,\n+                      qualified: bool,\n+                      output: &mut String) {\n+        ty::with_path(cx.tcx(), def_id, |path| {\n+            if qualified {\n+                if def_id.krate == ast::LOCAL_CRATE {\n+                    output.push_str(crate_root_namespace(cx));\n+                    output.push_str(\"::\");\n+                }\n+\n+                let mut path_element_count = 0;\n+                for path_element in path {\n+                    let name = token::get_name(path_element.name());\n+                    output.push_str(&name);\n+                    output.push_str(\"::\");\n+                    path_element_count += 1;\n+                }\n+\n+                if path_element_count == 0 {\n+                    cx.sess().bug(\"debuginfo: Encountered empty item path!\");\n+                }\n+\n+                output.pop();\n+                output.pop();\n+            } else {\n+                let name = token::get_name(path.last()\n+                                               .expect(\"debuginfo: Empty item path?\")\n+                                               .name());\n+                output.push_str(&name);\n+            }\n+        });\n+    }\n+\n+    // Pushes the type parameters in the given `Substs` to the output string.\n+    // This ignores region parameters, since they can't reliably be\n+    // reconstructed for items from non-local crates. For local crates, this\n+    // would be possible but with inlining and LTO we have to use the least\n+    // common denominator - otherwise we would run into conflicts.\n+    fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                  substs: &subst::Substs<'tcx>,\n+                                  output: &mut String) {\n+        if substs.types.is_empty() {\n+            return;\n+        }\n+\n+        output.push('<');\n+\n+        for &type_parameter in substs.types.iter() {\n+            push_debuginfo_type_name(cx, type_parameter, true, output);\n+            output.push_str(\", \");\n+        }\n+\n+        output.pop();\n+        output.pop();\n+\n+        output.push('>');\n+    }\n+}\n+"}, {"sha": "0c12f6ed095f1b9a36b648053a8dae0fa7e1363b", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3434469b518bda1d140e7859239ad1c800060af8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=3434469b518bda1d140e7859239ad1c800060af8", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Utility Functions.\n+\n+use super::{FunctionDebugContext, CrateDebugContext};\n+use super::namespace::namespace_for_item;\n+\n+use llvm;\n+use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n+use trans::machine;\n+use trans::common::{CrateContext, FunctionContext};\n+use trans::type_::Type;\n+\n+use syntax::codemap::Span;\n+use syntax::{ast, codemap};\n+\n+pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n+{\n+    // The is_local_to_unit flag indicates whether a function is local to the\n+    // current compilation unit (i.e. if it is *static* in the C-sense). The\n+    // *reachable* set should provide a good approximation of this, as it\n+    // contains everything that might leak out of the current crate (by being\n+    // externally visible or by being inlined into something externally\n+    // visible). It might better to use the `exported_items` set from\n+    // `driver::CrateAnalysis` in the future, but (atm) this set is not\n+    // available in the translation pass.\n+    !cx.reachable().contains(&node_id)\n+}\n+\n+#[allow(non_snake_case)]\n+pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n+    return unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n+    };\n+}\n+\n+pub fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n+    attributes.iter().any(|attr| {\n+        let meta_item: &ast::MetaItem = &*attr.node.value;\n+        match meta_item.node {\n+            ast::MetaWord(ref value) => &value[..] == \"no_debug\",\n+            _ => false\n+        }\n+    })\n+}\n+\n+/// Return codemap::Loc corresponding to the beginning of the span\n+pub fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n+    cx.sess().codemap().lookup_char_pos(span.lo)\n+}\n+\n+pub fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u64) {\n+    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type) as u64)\n+}\n+\n+pub fn bytes_to_bits(bytes: u64) -> u64 {\n+    bytes * 8\n+}\n+\n+#[inline]\n+pub fn debug_context<'a, 'tcx>(cx: &'a CrateContext<'a, 'tcx>)\n+                           -> &'a CrateDebugContext<'tcx> {\n+    let debug_context: &'a CrateDebugContext<'tcx> = cx.dbg_cx().as_ref().unwrap();\n+    debug_context\n+}\n+\n+#[inline]\n+#[allow(non_snake_case)]\n+pub fn DIB(cx: &CrateContext) -> DIBuilderRef {\n+    cx.dbg_cx().as_ref().unwrap().builder\n+}\n+\n+pub fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(_) => false,\n+        _ => true\n+    }\n+}\n+\n+pub fn assert_type_for_node_id(cx: &CrateContext,\n+                           node_id: ast::NodeId,\n+                           error_reporting_span: Span) {\n+    if !cx.tcx().node_types().contains_key(&node_id) {\n+        cx.sess().span_bug(error_reporting_span,\n+                           \"debuginfo: Could not find type for node id!\");\n+    }\n+}\n+\n+pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n+                                   -> (DIScope, Span) {\n+    let containing_scope = namespace_for_item(cx, def_id).scope;\n+    let definition_span = if def_id.krate == ast::LOCAL_CRATE {\n+        cx.tcx().map.span(def_id.node)\n+    } else {\n+        // For external items there is no span information\n+        codemap::DUMMY_SP\n+    };\n+\n+    (containing_scope, definition_span)\n+}"}]}