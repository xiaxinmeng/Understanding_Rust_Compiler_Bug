{"sha": "af0a433865321ee9fc5287eef63227baf4cba109", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMGE0MzM4NjUzMjFlZTlmYzUyODdlZWY2MzIyN2JhZjRjYmExMDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-09T15:48:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-09T15:48:58Z"}, "message": "Auto merge of #33048 - Amanieu:integer_atomics, r=alexcrichton\n\nAdd integer atomic types\n\nTracking issue: #32976\nRFC: rust-lang/rfcs#1543\n\nThe changes to AtomicBool in the RFC are not included, they are in a separate PR (#32365).", "tree": {"sha": "9bbb98039cceade0bed4ae51f46cefa0b603abc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bbb98039cceade0bed4ae51f46cefa0b603abc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af0a433865321ee9fc5287eef63227baf4cba109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af0a433865321ee9fc5287eef63227baf4cba109", "html_url": "https://github.com/rust-lang/rust/commit/af0a433865321ee9fc5287eef63227baf4cba109", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af0a433865321ee9fc5287eef63227baf4cba109/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cc90978e87c6681de18c265aaa1a324c064fc3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cc90978e87c6681de18c265aaa1a324c064fc3d", "html_url": "https://github.com/rust-lang/rust/commit/0cc90978e87c6681de18c265aaa1a324c064fc3d"}, {"sha": "03dd9b87cb00a3f11231c2c96f41c4c1ce6abe48", "url": "https://api.github.com/repos/rust-lang/rust/commits/03dd9b87cb00a3f11231c2c96f41c4c1ce6abe48", "html_url": "https://github.com/rust-lang/rust/commit/03dd9b87cb00a3f11231c2c96f41c4c1ce6abe48"}], "stats": {"total": 1212, "additions": 600, "deletions": 612}, "files": [{"sha": "ebb111a2e2e7378cb06c890a998e24bc868144a8", "filename": "src/doc/reference.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -2091,6 +2091,8 @@ The following configurations must be defined by the implementation:\n * `target_pointer_width = \"...\"` - Target pointer width in bits. This is set\n   to `\"32\"` for targets with 32-bit pointers, and likewise set to `\"64\"` for\n   64-bit pointers.\n+* `target_has_atomic = \"...\"` - Set of integer sizes on which the target can perform\n+  atomic operations. Values are `\"8\"`, `\"16\"`, `\"32\"`, `\"64\"` and `\"ptr\"`.\n * `target_vendor = \"...\"` - Vendor of the target, for example `apple`, `pc`, or\n   simply `\"unknown\"`.\n * `test` - Enabled when compiling the test harness (using the `--test` flag).\n@@ -2295,6 +2297,9 @@ The currently implemented features of the reference compiler are:\n * `cfg_target_vendor` - Allows conditional compilation using the `target_vendor`\n                         matcher which is subject to change.\n \n+* `cfg_target_has_atomic` - Allows conditional compilation using the `target_has_atomic`\n+                            matcher which is subject to change.\n+\n * `concat_idents` - Allows use of the `concat_idents` macro, which is in many\n                     ways insufficient for concatenating identifiers, and may be\n                     removed entirely for something more wholesome."}, {"sha": "873059d3cccebc9a6025af32c9166de76eaddc15", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -63,6 +63,7 @@\n #![feature(associated_type_defaults)]\n #![feature(concat_idents)]\n #![feature(const_fn)]\n+#![feature(cfg_target_has_atomic)]\n #![feature(custom_attribute)]\n #![feature(fundamental)]\n #![feature(inclusive_range_syntax)]"}, {"sha": "cf3e45cf3de79baf85a79adc15b4121353477a1c", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 418, "deletions": 602, "changes": 1020, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -83,11 +83,13 @@ use default::Default;\n use fmt;\n \n /// A boolean type which can be safely shared between threads.\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicBool {\n     v: UnsafeCell<usize>,\n }\n \n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for AtomicBool {\n     fn default() -> Self {\n@@ -96,58 +98,29 @@ impl Default for AtomicBool {\n }\n \n // Send is implicitly implemented for AtomicBool.\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl Sync for AtomicBool {}\n \n-/// A signed integer type which can be safely shared between threads.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct AtomicIsize {\n-    v: UnsafeCell<isize>,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for AtomicIsize {\n-    fn default() -> Self {\n-        Self::new(Default::default())\n-    }\n-}\n-\n-// Send is implicitly implemented for AtomicIsize.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl Sync for AtomicIsize {}\n-\n-/// An unsigned integer type which can be safely shared between threads.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct AtomicUsize {\n-    v: UnsafeCell<usize>,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for AtomicUsize {\n-    fn default() -> Self {\n-        Self::new(Default::default())\n-    }\n-}\n-\n-// Send is implicitly implemented for AtomicUsize.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl Sync for AtomicUsize {}\n-\n /// A raw pointer type which can be safely shared between threads.\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicPtr<T> {\n     p: UnsafeCell<*mut T>,\n }\n \n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for AtomicPtr<T> {\n     fn default() -> AtomicPtr<T> {\n         AtomicPtr::new(::ptr::null_mut())\n     }\n }\n \n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for AtomicPtr<T> {}\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Sync for AtomicPtr<T> {}\n \n@@ -189,18 +162,15 @@ pub enum Ordering {\n }\n \n /// An `AtomicBool` initialized to `false`.\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n-/// An `AtomicIsize` initialized to `0`.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const ATOMIC_ISIZE_INIT: AtomicIsize = AtomicIsize::new(0);\n-/// An `AtomicUsize` initialized to `0`.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const ATOMIC_USIZE_INIT: AtomicUsize = AtomicUsize::new(0);\n \n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n const UINT_TRUE: usize = !0;\n \n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n impl AtomicBool {\n     /// Creates a new `AtomicBool`.\n     ///\n@@ -543,557 +513,7 @@ impl AtomicBool {\n     }\n }\n \n-impl AtomicIsize {\n-    /// Creates a new `AtomicIsize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::AtomicIsize;\n-    ///\n-    /// let atomic_forty_two  = AtomicIsize::new(42);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub const fn new(v: isize) -> AtomicIsize {\n-        AtomicIsize {v: UnsafeCell::new(v)}\n-    }\n-\n-    /// Loads a value from the isize.\n-    ///\n-    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `order` is `Release` or `AcqRel`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let some_isize = AtomicIsize::new(5);\n-    ///\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 5);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn load(&self, order: Ordering) -> isize {\n-        unsafe { atomic_load(self.v.get(), order) }\n-    }\n-\n-    /// Stores a value into the isize.\n-    ///\n-    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let some_isize = AtomicIsize::new(5);\n-    ///\n-    /// some_isize.store(10, Ordering::Relaxed);\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `order` is `Acquire` or `AcqRel`.\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn store(&self, val: isize, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    /// Stores a value into the isize, returning the old value.\n-    ///\n-    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let some_isize = AtomicIsize::new(5);\n-    ///\n-    /// assert_eq!(some_isize.swap(10, Ordering::Relaxed), 5);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn swap(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_swap(self.v.get(), val, order) }\n-    }\n-\n-    /// Stores a value into the `isize` if the current value is the same as the `current` value.\n-    ///\n-    /// The return value is always the previous value. If it is equal to `current`, then the value\n-    /// was updated.\n-    ///\n-    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n-    /// this operation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let some_isize = AtomicIsize::new(5);\n-    ///\n-    /// assert_eq!(some_isize.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    ///\n-    /// assert_eq!(some_isize.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, current: isize, new: isize, order: Ordering) -> isize {\n-        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n-            Ok(x) => x,\n-            Err(x) => x,\n-        }\n-    }\n-\n-    /// Stores a value into the `isize` if the current value is the same as the `current` value.\n-    ///\n-    /// The return value is a result indicating whether the new value was written and containing\n-    /// the previous value. On success this value is guaranteed to be equal to `new`.\n-    ///\n-    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n-    /// operation. The first describes the required ordering if the operation succeeds while the\n-    /// second describes the required ordering when the operation fails. The failure ordering can't\n-    /// be `Release` or `AcqRel` and must be equivalent or weaker than the success ordering.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(extended_compare_and_swap)]\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let some_isize = AtomicIsize::new(5);\n-    ///\n-    /// assert_eq!(some_isize.compare_exchange(5, 10,\n-    ///                                        Ordering::Acquire,\n-    ///                                        Ordering::Relaxed),\n-    ///            Ok(5));\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    ///\n-    /// assert_eq!(some_isize.compare_exchange(6, 12,\n-    ///                                        Ordering::SeqCst,\n-    ///                                        Ordering::Acquire),\n-    ///            Err(10));\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n-    pub fn compare_exchange(&self,\n-                            current: isize,\n-                            new: isize,\n-                            success: Ordering,\n-                            failure: Ordering) -> Result<isize, isize> {\n-        unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n-    }\n-\n-    /// Stores a value into the `isize` if the current value is the same as the `current` value.\n-    ///\n-    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n-    /// comparison succeeds, which can result in more efficient code on some platforms. The\n-    /// return value is a result indicating whether the new value was written and containing the\n-    /// previous value.\n-    ///\n-    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if the operation\n-    /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than the\n-    /// success ordering.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(extended_compare_and_swap)]\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let val = AtomicIsize::new(4);\n-    ///\n-    /// let mut old = val.load(Ordering::Relaxed);\n-    /// loop {\n-    ///     let new = old * 2;\n-    ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n-    ///         Ok(_) => break,\n-    ///         Err(x) => old = x,\n-    ///     }\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n-    pub fn compare_exchange_weak(&self,\n-                                 current: isize,\n-                                 new: isize,\n-                                 success: Ordering,\n-                                 failure: Ordering) -> Result<isize, isize> {\n-        unsafe { atomic_compare_exchange_weak(self.v.get(), current, new, success, failure) }\n-    }\n-\n-    /// Add an isize to the current value, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let foo = AtomicIsize::new(0);\n-    /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_add(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_add(self.v.get(), val, order) }\n-    }\n-\n-    /// Subtract an isize from the current value, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let foo = AtomicIsize::new(0);\n-    /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 0);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), -10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_sub(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_sub(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise and with the current isize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let foo = AtomicIsize::new(0b101101);\n-    /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_and(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_and(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise or with the current isize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let foo = AtomicIsize::new(0b101101);\n-    /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_or(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_or(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise xor with the current isize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicIsize, Ordering};\n-    ///\n-    /// let foo = AtomicIsize::new(0b101101);\n-    /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_xor(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_xor(self.v.get(), val, order) }\n-    }\n-}\n-\n-impl AtomicUsize {\n-    /// Creates a new `AtomicUsize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::AtomicUsize;\n-    ///\n-    /// let atomic_forty_two = AtomicUsize::new(42);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub const fn new(v: usize) -> AtomicUsize {\n-        AtomicUsize { v: UnsafeCell::new(v) }\n-    }\n-\n-    /// Loads a value from the usize.\n-    ///\n-    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `order` is `Release` or `AcqRel`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let some_usize = AtomicUsize::new(5);\n-    ///\n-    /// assert_eq!(some_usize.load(Ordering::Relaxed), 5);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn load(&self, order: Ordering) -> usize {\n-        unsafe { atomic_load(self.v.get(), order) }\n-    }\n-\n-    /// Stores a value into the usize.\n-    ///\n-    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let some_usize = AtomicUsize::new(5);\n-    ///\n-    /// some_usize.store(10, Ordering::Relaxed);\n-    /// assert_eq!(some_usize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `order` is `Acquire` or `AcqRel`.\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn store(&self, val: usize, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    /// Stores a value into the usize, returning the old value.\n-    ///\n-    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let some_usize = AtomicUsize::new(5);\n-    ///\n-    /// assert_eq!(some_usize.swap(10, Ordering::Relaxed), 5);\n-    /// assert_eq!(some_usize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn swap(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_swap(self.v.get(), val, order) }\n-    }\n-\n-    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n-    ///\n-    /// The return value is always the previous value. If it is equal to `current`, then the value\n-    /// was updated.\n-    ///\n-    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n-    /// this operation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let some_usize = AtomicUsize::new(5);\n-    ///\n-    /// assert_eq!(some_usize.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n-    /// assert_eq!(some_usize.load(Ordering::Relaxed), 10);\n-    ///\n-    /// assert_eq!(some_usize.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n-    /// assert_eq!(some_usize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, current: usize, new: usize, order: Ordering) -> usize {\n-        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n-            Ok(x) => x,\n-            Err(x) => x,\n-        }\n-    }\n-\n-    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n-    ///\n-    /// The return value is a result indicating whether the new value was written and containing\n-    /// the previous value. On success this value is guaranteed to be equal to `new`.\n-    ///\n-    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n-    /// operation. The first describes the required ordering if the operation succeeds while the\n-    /// second describes the required ordering when the operation fails. The failure ordering can't\n-    /// be `Release` or `AcqRel` and must be equivalent or weaker than the success ordering.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(extended_compare_and_swap)]\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let some_isize = AtomicUsize::new(5);\n-    ///\n-    /// assert_eq!(some_isize.compare_exchange(5, 10,\n-    ///                                        Ordering::Acquire,\n-    ///                                        Ordering::Relaxed),\n-    ///            Ok(5));\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    ///\n-    /// assert_eq!(some_isize.compare_exchange(6, 12,\n-    ///                                        Ordering::SeqCst,\n-    ///                                        Ordering::Acquire),\n-    ///            Err(10));\n-    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n-    pub fn compare_exchange(&self,\n-                            current: usize,\n-                            new: usize,\n-                            success: Ordering,\n-                            failure: Ordering) -> Result<usize, usize> {\n-        unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n-    }\n-\n-    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n-    ///\n-    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n-    /// comparison succeeds, which can result in more efficient code on some platforms. The\n-    /// return value is a result indicating whether the new value was written and containing the\n-    /// previous value.\n-    ///\n-    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if the operation\n-    /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than the\n-    /// success ordering.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(extended_compare_and_swap)]\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let val = AtomicUsize::new(4);\n-    ///\n-    /// let mut old = val.load(Ordering::Relaxed);\n-    /// loop {\n-    ///     let new = old * 2;\n-    ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n-    ///         Ok(_) => break,\n-    ///         Err(x) => old = x,\n-    ///     }\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n-    pub fn compare_exchange_weak(&self,\n-                                 current: usize,\n-                                 new: usize,\n-                                 success: Ordering,\n-                                 failure: Ordering) -> Result<usize, usize> {\n-        unsafe { atomic_compare_exchange_weak(self.v.get(), current, new, success, failure) }\n-    }\n-\n-    /// Add to the current usize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let foo = AtomicUsize::new(0);\n-    /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_add(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_add(self.v.get(), val, order) }\n-    }\n-\n-    /// Subtract from the current usize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let foo = AtomicUsize::new(10);\n-    /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 10);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_sub(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_sub(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise and with the current usize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let foo = AtomicUsize::new(0b101101);\n-    /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_and(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_and(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise or with the current usize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let foo = AtomicUsize::new(0b101101);\n-    /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_or(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_or(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise xor with the current usize, returning the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomic::{AtomicUsize, Ordering};\n-    ///\n-    /// let foo = AtomicUsize::new(0b101101);\n-    /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n-    /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn fetch_xor(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_xor(self.v.get(), val, order) }\n-    }\n-}\n-\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n impl<T> AtomicPtr<T> {\n     /// Creates a new `AtomicPtr`.\n     ///\n@@ -1311,6 +731,405 @@ impl<T> AtomicPtr<T> {\n     }\n }\n \n+macro_rules! atomic_int {\n+    ($stable:meta,\n+     $stable_cxchg:meta,\n+     $stable_debug:meta,\n+     $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n+        /// An integer type which can be safely shared between threads.\n+        #[$stable]\n+        pub struct $atomic_type {\n+            v: UnsafeCell<$int_type>,\n+        }\n+\n+        /// An atomic integer initialized to `0`.\n+        #[$stable]\n+        pub const $atomic_init: $atomic_type = $atomic_type::new(0);\n+\n+        #[$stable]\n+        impl Default for $atomic_type {\n+            fn default() -> Self {\n+                Self::new(Default::default())\n+            }\n+        }\n+\n+        #[$stable_debug]\n+        impl fmt::Debug for $atomic_type {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                f.debug_tuple(stringify!($atomic_type))\n+                 .field(&self.load(Ordering::SeqCst))\n+                 .finish()\n+            }\n+        }\n+\n+        // Send is implicitly implemented.\n+        #[$stable]\n+        unsafe impl Sync for $atomic_type {}\n+\n+        impl $atomic_type {\n+            /// Creates a new atomic integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::AtomicIsize;\n+            ///\n+            /// let atomic_forty_two  = AtomicIsize::new(42);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub const fn new(v: $int_type) -> Self {\n+                $atomic_type {v: UnsafeCell::new(v)}\n+            }\n+\n+            /// Loads a value from the atomic integer.\n+            ///\n+            /// `load` takes an `Ordering` argument which describes the memory ordering of this\n+            /// operation.\n+            ///\n+            /// # Panics\n+            ///\n+            /// Panics if `order` is `Release` or `AcqRel`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let some_isize = AtomicIsize::new(5);\n+            ///\n+            /// assert_eq!(some_isize.load(Ordering::Relaxed), 5);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub fn load(&self, order: Ordering) -> $int_type {\n+                unsafe { atomic_load(self.v.get(), order) }\n+            }\n+\n+            /// Stores a value into the atomic integer.\n+            ///\n+            /// `store` takes an `Ordering` argument which describes the memory ordering of this\n+            /// operation.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let some_isize = AtomicIsize::new(5);\n+            ///\n+            /// some_isize.store(10, Ordering::Relaxed);\n+            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+            /// ```\n+            ///\n+            /// # Panics\n+            ///\n+            /// Panics if `order` is `Acquire` or `AcqRel`.\n+            #[inline]\n+            #[$stable]\n+            pub fn store(&self, val: $int_type, order: Ordering) {\n+                unsafe { atomic_store(self.v.get(), val, order); }\n+            }\n+\n+            /// Stores a value into the atomic integer, returning the old value.\n+            ///\n+            /// `swap` takes an `Ordering` argument which describes the memory ordering of this\n+            /// operation.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let some_isize = AtomicIsize::new(5);\n+            ///\n+            /// assert_eq!(some_isize.swap(10, Ordering::Relaxed), 5);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_swap(self.v.get(), val, order) }\n+            }\n+\n+            /// Stores a value into the atomic integer if the current value is the same as the\n+            /// `current` value.\n+            ///\n+            /// The return value is always the previous value. If it is equal to `current`, then the\n+            /// value was updated.\n+            ///\n+            /// `compare_and_swap` also takes an `Ordering` argument which describes the memory\n+            /// ordering of this operation.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let some_isize = AtomicIsize::new(5);\n+            ///\n+            /// assert_eq!(some_isize.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n+            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+            ///\n+            /// assert_eq!(some_isize.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n+            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub fn compare_and_swap(&self,\n+                                    current: $int_type,\n+                                    new: $int_type,\n+                                    order: Ordering) -> $int_type {\n+                match self.compare_exchange(current,\n+                                            new,\n+                                            order,\n+                                            strongest_failure_ordering(order)) {\n+                    Ok(x) => x,\n+                    Err(x) => x,\n+                }\n+            }\n+\n+            /// Stores a value into the atomic integer if the current value is the same as the\n+            /// `current` value.\n+            ///\n+            /// The return value is a result indicating whether the new value was written and\n+            /// containing the previous value. On success this value is guaranteed to be equal to\n+            /// `new`.\n+            ///\n+            /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of\n+            /// this operation. The first describes the required ordering if the operation succeeds\n+            /// while the second describes the required ordering when the operation fails. The\n+            /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker\n+            /// than the success ordering.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// # #![feature(extended_compare_and_swap)]\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let some_isize = AtomicIsize::new(5);\n+            ///\n+            /// assert_eq!(some_isize.compare_exchange(5, 10,\n+            ///                                        Ordering::Acquire,\n+            ///                                        Ordering::Relaxed),\n+            ///            Ok(5));\n+            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+            ///\n+            /// assert_eq!(some_isize.compare_exchange(6, 12,\n+            ///                                        Ordering::SeqCst,\n+            ///                                        Ordering::Acquire),\n+            ///            Err(10));\n+            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+            /// ```\n+            #[inline]\n+            #[$stable_cxchg]\n+            pub fn compare_exchange(&self,\n+                                    current: $int_type,\n+                                    new: $int_type,\n+                                    success: Ordering,\n+                                    failure: Ordering) -> Result<$int_type, $int_type> {\n+                unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+            }\n+\n+            /// Stores a value into the atomic integer if the current value is the same as the\n+            /// `current` value.\n+            ///\n+            /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+            /// comparison succeeds, which can result in more efficient code on some platforms. The\n+            /// return value is a result indicating whether the new value was written and containing\n+            /// the previous value.\n+            ///\n+            /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+            /// ordering of this operation. The first describes the required ordering if the\n+            /// operation succeeds while the second describes the required ordering when the\n+            /// operation fails. The failure ordering can't be `Release` or `AcqRel` and must be\n+            /// equivalent or weaker than the success ordering.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// # #![feature(extended_compare_and_swap)]\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let val = AtomicIsize::new(4);\n+            ///\n+            /// let mut old = val.load(Ordering::Relaxed);\n+            /// loop {\n+            ///     let new = old * 2;\n+            ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n+            ///         Ok(_) => break,\n+            ///         Err(x) => old = x,\n+            ///     }\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[$stable_cxchg]\n+            pub fn compare_exchange_weak(&self,\n+                                         current: $int_type,\n+                                         new: $int_type,\n+                                         success: Ordering,\n+                                         failure: Ordering) -> Result<$int_type, $int_type> {\n+                unsafe {\n+                    atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n+                }\n+            }\n+\n+            /// Add to the current value, returning the previous value.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let foo = AtomicIsize::new(0);\n+            /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_add(self.v.get(), val, order) }\n+            }\n+\n+            /// Subtract from the current value, returning the previous value.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let foo = AtomicIsize::new(0);\n+            /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 0);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), -10);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_sub(self.v.get(), val, order) }\n+            }\n+\n+            /// Bitwise and with the current value, returning the previous value.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let foo = AtomicIsize::new(0b101101);\n+            /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n+            #[inline]\n+            #[$stable]\n+            pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_and(self.v.get(), val, order) }\n+            }\n+\n+            /// Bitwise or with the current value, returning the previous value.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let foo = AtomicIsize::new(0b101101);\n+            /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n+            #[inline]\n+            #[$stable]\n+            pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_or(self.v.get(), val, order) }\n+            }\n+\n+            /// Bitwise xor with the current value, returning the previous value.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let foo = AtomicIsize::new(0b101101);\n+            /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n+            #[inline]\n+            #[$stable]\n+            pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_xor(self.v.get(), val, order) }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(target_has_atomic = \"8\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    i8 AtomicI8 ATOMIC_I8_INIT\n+}\n+#[cfg(target_has_atomic = \"8\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    u8 AtomicU8 ATOMIC_U8_INIT\n+}\n+#[cfg(target_has_atomic = \"16\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    i16 AtomicI16 ATOMIC_I16_INIT\n+}\n+#[cfg(target_has_atomic = \"16\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    u16 AtomicU16 ATOMIC_U16_INIT\n+}\n+#[cfg(target_has_atomic = \"32\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    i32 AtomicI32 ATOMIC_I32_INIT\n+}\n+#[cfg(target_has_atomic = \"32\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    u32 AtomicU32 ATOMIC_U32_INIT\n+}\n+#[cfg(target_has_atomic = \"64\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    i64 AtomicI64 ATOMIC_I64_INIT\n+}\n+#[cfg(target_has_atomic = \"64\")]\n+atomic_int! {\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    u64 AtomicU64 ATOMIC_U64_INIT\n+}\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n+atomic_int!{\n+    stable(feature = \"rust1\", since = \"1.0.0\"),\n+    unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\"),\n+    stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n+    isize AtomicIsize ATOMIC_ISIZE_INIT\n+}\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n+atomic_int!{\n+    stable(feature = \"rust1\", since = \"1.0.0\"),\n+    unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\"),\n+    stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n+    usize AtomicUsize ATOMIC_USIZE_INIT\n+}\n+\n #[inline]\n fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n@@ -1514,19 +1333,16 @@ pub fn fence(order: Ordering) {\n     }\n }\n \n-macro_rules! impl_Debug {\n-    ($($t:ident)*) => ($(\n-        #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n-        impl fmt::Debug for $t {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                f.debug_tuple(stringify!($t)).field(&self.load(Ordering::SeqCst)).finish()\n-            }\n-        }\n-    )*);\n-}\n \n-impl_Debug!{ AtomicUsize AtomicIsize AtomicBool }\n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n+#[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n+impl fmt::Debug for AtomicBool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"AtomicBool\").field(&self.load(Ordering::SeqCst)).finish()\n+    }\n+}\n \n+#[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl<T> fmt::Debug for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "82237e0abb763625cd1648ec5db713446c0c1126", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -695,6 +695,7 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     let os = &sess.target.target.target_os;\n     let env = &sess.target.target.target_env;\n     let vendor = &sess.target.target.target_vendor;\n+    let max_atomic_width = sess.target.target.options.max_atomic_width;\n \n     let fam = if let Some(ref fam) = sess.target.target.options.target_family {\n         intern(fam)\n@@ -721,6 +722,15 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     if sess.target.target.options.has_elf_tls {\n         ret.push(attr::mk_word_item(InternedString::new(\"target_thread_local\")));\n     }\n+    for &i in &[8, 16, 32, 64, 128] {\n+        if i <= max_atomic_width {\n+            let s = i.to_string();\n+            ret.push(mk(InternedString::new(\"target_has_atomic\"), intern(&s)));\n+            if &s == wordsz {\n+                ret.push(mk(InternedString::new(\"target_has_atomic\"), intern(\"ptr\")));\n+            }\n+        }\n+    }\n     if sess.opts.debug_assertions {\n         ret.push(attr::mk_word_item(InternedString::new(\"debug_assertions\")));\n     }"}, {"sha": "481338d1cee562fe05eb3fe3c6fefa6fe4e640dd", "filename": "src/librustc_back/target/aarch64_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -24,6 +24,7 @@ pub fn target() -> Target {\n         options: TargetOptions {\n             features: \"+neon,+fp-armv8,+cyclone\".to_string(),\n             eliminate_frame_pointer: false,\n+            max_atomic_width: 128,\n             .. opts(Arch::Arm64)\n         },\n     }"}, {"sha": "ed171822464666e651640c4d540e3d3308053902", "filename": "src/librustc_back/target/aarch64_linux_android.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -11,6 +11,8 @@\n use target::Target;\n \n pub fn target() -> Target {\n+    let mut base = super::android_base::opts();\n+    base.max_atomic_width = 128;\n     Target {\n         llvm_target: \"aarch64-linux-android\".to_string(),\n         target_endian: \"little\".to_string(),\n@@ -20,6 +22,6 @@ pub fn target() -> Target {\n         target_os: \"android\".to_string(),\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n-        options: super::android_base::opts(),\n+        options: base,\n     }\n }"}, {"sha": "aec1bae60c812f6085895f4574a1cc5980fc70aa", "filename": "src/librustc_back/target/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -11,7 +11,8 @@\n use target::Target;\n \n pub fn target() -> Target {\n-    let base = super::linux_base::opts();\n+    let mut base = super::linux_base::opts();\n+    base.max_atomic_width = 128;\n     Target {\n         llvm_target: \"aarch64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "ab662a97dc23c7c2462598f13511b117df1c127a", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::android_base::opts();\n     base.features = \"+v7,+vfp3,+d16\".to_string();\n+    base.max_atomic_width = 64;\n \n     Target {\n         llvm_target: \"arm-linux-androideabi\".to_string(),"}, {"sha": "60c4a7c3c90ce4356fecb378e41f7b7d2ee8516e", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -11,7 +11,8 @@\n use target::{Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = super::linux_base::opts();\n+    let mut base = super::linux_base::opts();\n+    base.max_atomic_width = 64;\n     Target {\n         llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "72128e30641c61da73e658fa83c1c37a803b9b2a", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -11,7 +11,8 @@\n use target::{Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = super::linux_base::opts();\n+    let mut base = super::linux_base::opts();\n+    base.max_atomic_width = 64;\n     Target {\n         llvm_target: \"arm-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "a2486a1330a53da4f2d9fa728e4b39093f7812e7", "filename": "src/librustc_back/target/armv7_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -23,6 +23,7 @@ pub fn target() -> Target {\n         target_vendor: \"apple\".to_string(),\n         options: TargetOptions {\n             features: \"+v7,+vfp3,+neon\".to_string(),\n+            max_atomic_width: 64,\n             .. opts(Arch::Armv7)\n         }\n     }"}, {"sha": "7bcca3a3934bed04d9e9d10b66a5cdb424a0976c", "filename": "src/librustc_back/target/armv7_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_gnueabihf.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -25,6 +25,7 @@ pub fn target() -> Target {\n         options: TargetOptions {\n             features: \"+v7,+vfp3,+neon\".to_string(),\n             cpu: \"cortex-a8\".to_string(),\n+            max_atomic_width: 64,\n             .. base\n         }\n     }"}, {"sha": "e5379aa1b42cd74571df00799e8dc015f7729da9", "filename": "src/librustc_back/target/armv7s_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -23,6 +23,7 @@ pub fn target() -> Target {\n         target_vendor: \"apple\".to_string(),\n         options: TargetOptions {\n             features: \"+v7,+vfp4,+neon\".to_string(),\n+            max_atomic_width: 64,\n             .. opts(Arch::Armv7s)\n         }\n     }"}, {"sha": "e6200177944bbbc6313b23c7ae5e848d32a6a9e7", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -22,6 +22,7 @@ pub fn target() -> Target {\n         linker_is_gnu: true,\n         allow_asm: false,\n         obj_is_bitcode: true,\n+        max_atomic_width: 32,\n         .. Default::default()\n     };\n     Target {"}, {"sha": "cf4020eeb587420d00f5f852dd457bc9028fc146", "filename": "src/librustc_back/target/i386_apple_ios.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetOptions};\n use super::apple_ios_base::{opts, Arch};\n \n pub fn target() -> Target {\n@@ -21,6 +21,9 @@ pub fn target() -> Target {\n         target_os: \"ios\".to_string(),\n         target_env: \"\".to_string(),\n         target_vendor: \"apple\".to_string(),\n-        options: opts(Arch::I386)\n+        options: TargetOptions {\n+            max_atomic_width: 64,\n+            .. opts(Arch::I386)\n+        }\n     }\n }"}, {"sha": "302691e9a5922462fa5b746a04845219d063cd46", "filename": "src/librustc_back/target/i686_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::apple_base::opts();\n     base.cpu = \"yonah\".to_string();\n+    base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m32\".to_string());\n \n     Target {"}, {"sha": "426be63cf21935f63a6d06d174a2f19438c9743d", "filename": "src/librustc_back/target/i686_linux_android.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::android_base::opts();\n     base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = 64;\n \n     Target {\n         llvm_target: \"i686-linux-android\".to_string(),"}, {"sha": "c2cc624c9f9e65f344b81039e39481cf9c15a9aa", "filename": "src/librustc_back/target/i686_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::windows_base::opts();\n     base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = 64;\n \n     // Mark all dynamic libraries and executables as compatible with the larger 4GiB address\n     // space available to x86 Windows binaries on x86_64."}, {"sha": "8c1bacc2807677e39b53844382f0bc2336b4db40", "filename": "src/librustc_back/target/i686_pc_windows_msvc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::windows_msvc_base::opts();\n     base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = 64;\n \n     // Mark all dynamic libraries and executables as compatible with the larger 4GiB address\n     // space available to x86 Windows binaries on x86_64."}, {"sha": "6446ac45f7d6e92b8174231a09f6860f3cb29ab8", "filename": "src/librustc_back/target/i686_unknown_dragonfly.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::dragonfly_base::opts();\n     base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m32\".to_string());\n \n     Target {"}, {"sha": "a7903d5db64132856579ec1f949abf4b8c21e0b6", "filename": "src/librustc_back/target/i686_unknown_freebsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::freebsd_base::opts();\n     base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m32\".to_string());\n \n     Target {"}, {"sha": "7813d5570762def942934dc70140624d42732527", "filename": "src/librustc_back/target/i686_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::linux_base::opts();\n     base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m32\".to_string());\n \n     Target {"}, {"sha": "527442958374236c4bea97272679bd1ea7faeab6", "filename": "src/librustc_back/target/i686_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n     base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m32\".to_string());\n     base.pre_link_args.push(\"-Wl,-melf_i386\".to_string());\n "}, {"sha": "f4f0262d476da75b3af893f37d96846622e56cea", "filename": "src/librustc_back/target/le32_unknown_nacl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -25,6 +25,7 @@ pub fn target() -> Target {\n         no_compiler_rt: false,\n         linker_is_gnu: true,\n         allow_asm: false,\n+        max_atomic_width: 32,\n         .. Default::default()\n     };\n     Target {"}, {"sha": "794e4d4996c9422ab649bd38e81be71e962aaf8c", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -23,6 +23,7 @@ pub fn target() -> Target {\n         options: TargetOptions {\n             cpu: \"mips32r2\".to_string(),\n             features: \"+mips32r2,+soft-float\".to_string(),\n+            max_atomic_width: 32,\n             ..super::linux_base::opts()\n         },\n     }"}, {"sha": "35366659d581ffa03e6fb5646b2d30b98d4be4dd", "filename": "src/librustc_back/target/mips_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -23,6 +23,7 @@ pub fn target() -> Target {\n         options: TargetOptions {\n             cpu: \"mips32r2\".to_string(),\n             features: \"+mips32r2,+soft-float\".to_string(),\n+            max_atomic_width: 32,\n             ..super::linux_base::opts()\n         }\n     }"}, {"sha": "ac1536b3d009b58950998e9de973538bfba0ee86", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -24,6 +24,7 @@ pub fn target() -> Target {\n         options: TargetOptions {\n             cpu: \"mips32\".to_string(),\n             features: \"+mips32\".to_string(),\n+            max_atomic_width: 32,\n             ..super::linux_base::opts()\n         },\n     }"}, {"sha": "a9ea52c42786233c2b6bc416960ba75f2a534db7", "filename": "src/librustc_back/target/mipsel_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -23,6 +23,7 @@ pub fn target() -> Target {\n         options: TargetOptions {\n             cpu: \"mips32\".to_string(),\n             features: \"+mips32\".to_string(),\n+            max_atomic_width: 32,\n             ..super::linux_base::opts()\n         }\n     }"}, {"sha": "2163a8a1689b601e7240806ed25563cf88294852", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -292,6 +292,10 @@ pub struct TargetOptions {\n     // If we give emcc .o files that are actually .bc files it\n     // will 'just work'.\n     pub obj_is_bitcode: bool,\n+\n+    /// Maximum integer size in bits that this target can perform atomic\n+    /// operations on.\n+    pub max_atomic_width: u64,\n }\n \n impl Default for TargetOptions {\n@@ -340,6 +344,7 @@ impl Default for TargetOptions {\n             allow_asm: true,\n             has_elf_tls: false,\n             obj_is_bitcode: false,\n+            max_atomic_width: 0,\n         }\n     }\n }\n@@ -392,6 +397,9 @@ impl Target {\n             options: Default::default(),\n         };\n \n+        // Default max-atomic-width to target-pointer-width\n+        base.options.max_atomic_width = base.target_pointer_width.parse().unwrap();\n+\n         macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n@@ -404,6 +412,12 @@ impl Target {\n                     .map(|o| o.as_boolean()\n                          .map(|s| base.options.$key_name = s));\n             } );\n+            ($key_name:ident, u64) => ( {\n+                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n+                obj.find(&name[..])\n+                    .map(|o| o.as_u64()\n+                         .map(|s| base.options.$key_name = s));\n+            } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n                 obj.find(&name[..]).map(|o| o.as_array()\n@@ -451,6 +465,7 @@ impl Target {\n         key!(archive_format);\n         key!(allow_asm, bool);\n         key!(custom_unwind_resume, bool);\n+        key!(max_atomic_width, u64);\n \n         base\n     }"}, {"sha": "be4be8e6fc964f93e71e02c9c411bd891aab9481", "filename": "src/librustc_back/target/powerpc64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -14,6 +14,7 @@ pub fn target() -> Target {\n     let mut base = super::linux_base::opts();\n     base.cpu = \"ppc64\".to_string();\n     base.pre_link_args.push(\"-m64\".to_string());\n+    base.max_atomic_width = 64;\n \n     Target {\n         llvm_target: \"powerpc64-unknown-linux-gnu\".to_string(),"}, {"sha": "b0a81ce7ec5018162f0a3a023810671f1da4cdd8", "filename": "src/librustc_back/target/powerpc64le_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -14,6 +14,7 @@ pub fn target() -> Target {\n     let mut base = super::linux_base::opts();\n     base.cpu = \"ppc64le\".to_string();\n     base.pre_link_args.push(\"-m64\".to_string());\n+    base.max_atomic_width = 64;\n \n     Target {\n         llvm_target: \"powerpc64le-unknown-linux-gnu\".to_string(),"}, {"sha": "aea57dc4b7f95404ddf26d41a75d07935b06a6b9", "filename": "src/librustc_back/target/powerpc_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::linux_base::opts();\n     base.pre_link_args.push(\"-m32\".to_string());\n+    base.max_atomic_width = 32;\n \n     Target {\n         llvm_target: \"powerpc-unknown-linux-gnu\".to_string(),"}, {"sha": "5542c9120a4022f653004819f2d8edec23558dcb", "filename": "src/librustc_back/target/x86_64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::apple_base::opts();\n     base.cpu = \"core2\".to_string();\n+    base.max_atomic_width = 128; // core2 support cmpxchg16b\n     base.eliminate_frame_pointer = false;\n     base.pre_link_args.push(\"-m64\".to_string());\n "}, {"sha": "8638241f8610b0cb65851324f4d793e912ad5a57", "filename": "src/librustc_back/target/x86_64_apple_ios.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetOptions};\n use super::apple_ios_base::{opts, Arch};\n \n pub fn target() -> Target {\n@@ -21,6 +21,9 @@ pub fn target() -> Target {\n         target_os: \"ios\".to_string(),\n         target_env: \"\".to_string(),\n         target_vendor: \"apple\".to_string(),\n-        options: opts(Arch::X86_64)\n+        options: TargetOptions {\n+            max_atomic_width: 64,\n+            .. opts(Arch::X86_64)\n+        }\n     }\n }"}, {"sha": "e243054d0230e9ab8659ce22e31f8bc4437f3f44", "filename": "src/librustc_back/target/x86_64_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -14,6 +14,7 @@ pub fn target() -> Target {\n     let mut base = super::windows_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.pre_link_args.push(\"-m64\".to_string());\n+    base.max_atomic_width = 64;\n \n     Target {\n         llvm_target: \"x86_64-pc-windows-gnu\".to_string(),"}, {"sha": "a23a807a0257ed8ab88b019f4cba646ec2ed5ea3", "filename": "src/librustc_back/target/x86_64_pc_windows_msvc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::windows_msvc_base::opts();\n     base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = 64;\n \n     Target {\n         llvm_target: \"x86_64-pc-windows-msvc\".to_string(),"}, {"sha": "af5d21c4d93e45b92500927def98078d74621364", "filename": "src/librustc_back/target/x86_64_rumprun_netbsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -15,6 +15,7 @@ pub fn target() -> Target {\n     base.pre_link_args.push(\"-m64\".to_string());\n     base.linker = \"x86_64-rumprun-netbsd-gcc\".to_string();\n     base.ar = \"x86_64-rumprun-netbsd-ar\".to_string();\n+    base.max_atomic_width = 64;\n \n     base.dynamic_linking = false;\n     base.has_rpath = false;"}, {"sha": "8f2c905cf2ee4990bdc568a8db3098753c3fb52b", "filename": "src/librustc_back/target/x86_64_sun_solaris.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_sun_solaris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_sun_solaris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_sun_solaris.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -14,6 +14,7 @@ pub fn target() -> Target {\n     let mut base = super::solaris_base::opts();\n     base.pre_link_args.push(\"-m64\".to_string());\n     base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = 64;\n \n     Target {\n         llvm_target: \"x86_64-pc-solaris\".to_string(),"}, {"sha": "87753da540a3646df48ac54bea6a4d873e268b7e", "filename": "src/librustc_back/target/x86_64_unknown_bitrig.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -12,6 +12,7 @@ use target::Target;\n \n pub fn target() -> Target {\n     let mut base = super::bitrig_base::opts();\n+    base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n     Target {"}, {"sha": "2535071f3089c91c34ec82689a23d24f415417f8", "filename": "src/librustc_back/target/x86_64_unknown_dragonfly.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::dragonfly_base::opts();\n     base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n     Target {"}, {"sha": "d3ad0578aeb6e734b4c501799a0443c569732cc7", "filename": "src/librustc_back/target/x86_64_unknown_freebsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::freebsd_base::opts();\n     base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n     Target {"}, {"sha": "7908e0d581ba1aaa6bbc6ae596805390baf4a78d", "filename": "src/librustc_back/target/x86_64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::linux_base::opts();\n     base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n     Target {"}, {"sha": "3301e0e0dc93f86d3b5ddd3b05752b1ae21ac0bd", "filename": "src/librustc_back/target/x86_64_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n     base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n     Target {"}, {"sha": "7e6d1b78469e27ccd3f37a1e85609f247cc360a0", "filename": "src/librustc_back/target/x86_64_unknown_netbsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_netbsd.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -12,6 +12,7 @@ use target::Target;\n \n pub fn target() -> Target {\n     let mut base = super::netbsd_base::opts();\n+    base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n     Target {"}, {"sha": "823b0994b0a00d5cda917ceec7a79e97ac5a638a", "filename": "src/librustc_back/target/x86_64_unknown_openbsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::openbsd_base::opts();\n     base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n     Target {"}, {"sha": "cf797b85f54860f4d6fa05ae68347dabc2f3d9f4", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -268,8 +268,11 @@ declare_features! (\n     // pub(restricted) visibilities (RFC 1422)\n     (active, pub_restricted, \"1.9.0\", Some(32409)),\n \n-     // Allow Drop types in statics/const functions (RFC 1440)\n-    (active, drop_types_in_const, \"1.9.0\", Some(33156))\n+    // Allow Drop types in statics/const functions (RFC 1440)\n+    (active, drop_types_in_const, \"1.9.0\", Some(33156)),\n+\n+    // Allows cfg(target_has_atomic = \"...\").\n+    (active, cfg_target_has_atomic, \"1.9.0\", Some(32976))\n );\n \n declare_features! (\n@@ -577,6 +580,7 @@ const GATED_CFGS: &'static [(&'static str, &'static str, fn(&Features) -> bool)]\n     (\"target_feature\", \"cfg_target_feature\", cfg_fn!(cfg_target_feature)),\n     (\"target_vendor\", \"cfg_target_vendor\", cfg_fn!(cfg_target_vendor)),\n     (\"target_thread_local\", \"cfg_target_thread_local\", cfg_fn!(cfg_target_thread_local)),\n+    (\"target_has_atomic\", \"cfg_target_has_atomic\", cfg_fn!(cfg_target_has_atomic)),\n ];\n \n #[derive(Debug, Eq, PartialEq)]"}, {"sha": "78e7bb231372f89820c6b1ffe6dd9f3a0190e27d", "filename": "src/test/run-make/atomic-lock-free/Makefile", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Ftest%2Frun-make%2Fatomic-lock-free%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Ftest%2Frun-make%2Fatomic-lock-free%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fatomic-lock-free%2FMakefile?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -0,0 +1,30 @@\n+-include ../tools.mk\n+\n+# This tests ensure that atomic types are never lowered into runtime library calls that are not\n+# guaranteed to be lock-free.\n+\n+all:\n+ifeq ($(UNAME),Linux)\n+\t$(RUSTC) --target=i686-unknown-linux-gnu atomic_lock_free.rs\n+\tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | grep -vq __atomic_fetch_add\n+\t$(RUSTC) --target=x86_64-unknown-linux-gnu atomic_lock_free.rs\n+\tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | grep -vq __atomic_fetch_add\n+\t$(RUSTC) --target=arm-unknown-linux-gnueabi atomic_lock_free.rs\n+\tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | grep -vq __atomic_fetch_add\n+\t$(RUSTC) --target=arm-unknown-linux-gnueabihf atomic_lock_free.rs\n+\tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | grep -vq __atomic_fetch_add\n+\t$(RUSTC) --target=armv7-unknown-linux-gnueabihf atomic_lock_free.rs\n+\tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | grep -vq __atomic_fetch_add\n+\t$(RUSTC) --target=aarch64-unknown-linux-gnu atomic_lock_free.rs\n+\tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | grep -vq __atomic_fetch_add\n+\t$(RUSTC) --target=mips-unknown-linux-gnu atomic_lock_free.rs\n+\tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | grep -vq __atomic_fetch_add\n+\t$(RUSTC) --target=mipsel-unknown-linux-gnu atomic_lock_free.rs\n+\tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | grep -vq __atomic_fetch_add\n+\t$(RUSTC) --target=powerpc-unknown-linux-gnu atomic_lock_free.rs\n+\tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | grep -vq __atomic_fetch_add\n+\t$(RUSTC) --target=powerpc64-unknown-linux-gnu atomic_lock_free.rs\n+\tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | grep -vq __atomic_fetch_add\n+\t$(RUSTC) --target=powerpc64le-unknown-linux-gnu atomic_lock_free.rs\n+\tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | grep -vq __atomic_fetch_add\n+endif"}, {"sha": "8731cd960f33c133195f940f0e922f4e484d3154", "filename": "src/test/run-make/atomic-lock-free/atomic_lock_free.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/af0a433865321ee9fc5287eef63227baf4cba109/src%2Ftest%2Frun-make%2Fatomic-lock-free%2Fatomic_lock_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a433865321ee9fc5287eef63227baf4cba109/src%2Ftest%2Frun-make%2Fatomic-lock-free%2Fatomic_lock_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fatomic-lock-free%2Fatomic_lock_free.rs?ref=af0a433865321ee9fc5287eef63227baf4cba109", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(cfg_target_has_atomic, no_core, intrinsics, lang_items)]\n+#![crate_type=\"rlib\"]\n+#![no_core]\n+\n+extern \"rust-intrinsic\" {\n+    fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+#[cfg(target_has_atomic = \"8\")]\n+pub unsafe fn atomic_u8(x: *mut u8) {\n+    atomic_xadd(x, 1);\n+    atomic_xadd(x, 1);\n+}\n+#[cfg(target_has_atomic = \"8\")]\n+pub unsafe fn atomic_i8(x: *mut i8) {\n+    atomic_xadd(x, 1);\n+}\n+#[cfg(target_has_atomic = \"16\")]\n+pub unsafe fn atomic_u16(x: *mut u16) {\n+    atomic_xadd(x, 1);\n+}\n+#[cfg(target_has_atomic = \"16\")]\n+pub unsafe fn atomic_i16(x: *mut i16) {\n+    atomic_xadd(x, 1);\n+}\n+#[cfg(target_has_atomic = \"32\")]\n+pub unsafe fn atomic_u32(x: *mut u32) {\n+    atomic_xadd(x, 1);\n+}\n+#[cfg(target_has_atomic = \"32\")]\n+pub unsafe fn atomic_i32(x: *mut i32) {\n+    atomic_xadd(x, 1);\n+}\n+#[cfg(target_has_atomic = \"64\")]\n+pub unsafe fn atomic_u64(x: *mut u64) {\n+    atomic_xadd(x, 1);\n+}\n+#[cfg(target_has_atomic = \"64\")]\n+pub unsafe fn atomic_i64(x: *mut i64) {\n+    atomic_xadd(x, 1);\n+}\n+#[cfg(target_has_atomic = \"ptr\")]\n+pub unsafe fn atomic_usize(x: *mut usize) {\n+    atomic_xadd(x, 1);\n+}\n+#[cfg(target_has_atomic = \"ptr\")]\n+pub unsafe fn atomic_isize(x: *mut isize) {\n+    atomic_xadd(x, 1);\n+}"}]}