{"sha": "a409a233e02b1864d1b76495a1f946bb56c7aeb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MDlhMjMzZTAyYjE4NjRkMWI3NjQ5NWExZjk0NmJiNTZjN2FlYjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-21T05:31:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-21T05:31:01Z"}, "message": "Auto merge of #75974 - SkiFire13:peekmut-opt-sift, r=LukasKalbertodt\n\nAvoid useless sift_down when std::collections::binary_heap::PeekMut is never mutably dereferenced\n\nIf `deref_mut` is never called then it's not possible for the element to be mutated without internal mutability, meaning there's no need to call `sift_down`.\n\nThis could be a little improvement in cases where you want to mutate the biggest element of the heap only if it satisfies a certain predicate that needs only read access to the element.", "tree": {"sha": "0898049b3dd32714fea96f03a843b6b532ad329b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0898049b3dd32714fea96f03a843b6b532ad329b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a409a233e02b1864d1b76495a1f946bb56c7aeb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a409a233e02b1864d1b76495a1f946bb56c7aeb2", "html_url": "https://github.com/rust-lang/rust/commit/a409a233e02b1864d1b76495a1f946bb56c7aeb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a409a233e02b1864d1b76495a1f946bb56c7aeb2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70148d7b3161912381b1a5c427c3a690e12c5b24", "url": "https://api.github.com/repos/rust-lang/rust/commits/70148d7b3161912381b1a5c427c3a690e12c5b24", "html_url": "https://github.com/rust-lang/rust/commit/70148d7b3161912381b1a5c427c3a690e12c5b24"}, {"sha": "ca15e9d8a11e7c25eb85930d1da3009647c1680e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca15e9d8a11e7c25eb85930d1da3009647c1680e", "html_url": "https://github.com/rust-lang/rust/commit/ca15e9d8a11e7c25eb85930d1da3009647c1680e"}], "stats": {"total": 98, "additions": 96, "deletions": 2}, "files": [{"sha": "5b6538ea6c6b34fdfaff70121aaa21c9b10b7fc5", "filename": "library/alloc/benches/binary_heap.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a409a233e02b1864d1b76495a1f946bb56c7aeb2/library%2Falloc%2Fbenches%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a409a233e02b1864d1b76495a1f946bb56c7aeb2/library%2Falloc%2Fbenches%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbinary_heap.rs?ref=a409a233e02b1864d1b76495a1f946bb56c7aeb2", "patch": "@@ -0,0 +1,91 @@\n+use std::collections::BinaryHeap;\n+\n+use rand::{seq::SliceRandom, thread_rng};\n+use test::{black_box, Bencher};\n+\n+#[bench]\n+fn bench_find_smallest_1000(b: &mut Bencher) {\n+    let mut rng = thread_rng();\n+    let mut vec: Vec<u32> = (0..100_000).collect();\n+    vec.shuffle(&mut rng);\n+\n+    b.iter(|| {\n+        let mut iter = vec.iter().copied();\n+        let mut heap: BinaryHeap<_> = iter.by_ref().take(1000).collect();\n+\n+        for x in iter {\n+            let mut max = heap.peek_mut().unwrap();\n+            // This comparison should be true only 1% of the time.\n+            // Unnecessary `sift_down`s will degrade performance\n+            if x < *max {\n+                *max = x;\n+            }\n+        }\n+\n+        heap\n+    })\n+}\n+\n+#[bench]\n+fn bench_peek_mut_deref_mut(b: &mut Bencher) {\n+    let mut bheap = BinaryHeap::from(vec![42]);\n+    let vec: Vec<u32> = (0..1_000_000).collect();\n+\n+    b.iter(|| {\n+        let vec = black_box(&vec);\n+        let mut peek_mut = bheap.peek_mut().unwrap();\n+        // The compiler shouldn't be able to optimize away the `sift_down`\n+        // assignment in `PeekMut`'s `DerefMut` implementation since\n+        // the loop may not run.\n+        for &i in vec.iter() {\n+            *peek_mut = i;\n+        }\n+        // Remove the already minimal overhead of the sift_down\n+        std::mem::forget(peek_mut);\n+    })\n+}\n+\n+#[bench]\n+fn bench_from_vec(b: &mut Bencher) {\n+    let mut rng = thread_rng();\n+    let mut vec: Vec<u32> = (0..100_000).collect();\n+    vec.shuffle(&mut rng);\n+\n+    b.iter(|| BinaryHeap::from(vec.clone()))\n+}\n+\n+#[bench]\n+fn bench_into_sorted_vec(b: &mut Bencher) {\n+    let bheap: BinaryHeap<i32> = (0..10_000).collect();\n+\n+    b.iter(|| bheap.clone().into_sorted_vec())\n+}\n+\n+#[bench]\n+fn bench_push(b: &mut Bencher) {\n+    let mut bheap = BinaryHeap::with_capacity(50_000);\n+    let mut rng = thread_rng();\n+    let mut vec: Vec<u32> = (0..50_000).collect();\n+    vec.shuffle(&mut rng);\n+\n+    b.iter(|| {\n+        for &i in vec.iter() {\n+            bheap.push(i);\n+        }\n+        black_box(&mut bheap);\n+        bheap.clear();\n+    })\n+}\n+\n+#[bench]\n+fn bench_pop(b: &mut Bencher) {\n+    let mut bheap = BinaryHeap::with_capacity(10_000);\n+\n+    b.iter(|| {\n+        bheap.extend((0..10_000).rev());\n+        black_box(&mut bheap);\n+        while let Some(elem) = bheap.pop() {\n+            black_box(elem);\n+        }\n+    })\n+}"}, {"sha": "32edb86d10119a0f436687826a123cf6bdf85076", "filename": "library/alloc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a409a233e02b1864d1b76495a1f946bb56c7aeb2/library%2Falloc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a409a233e02b1864d1b76495a1f946bb56c7aeb2/library%2Falloc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Flib.rs?ref=a409a233e02b1864d1b76495a1f946bb56c7aeb2", "patch": "@@ -8,6 +8,7 @@\n \n extern crate test;\n \n+mod binary_heap;\n mod btree;\n mod linked_list;\n mod slice;"}, {"sha": "ea75fa21965028300403b66758b2026a1b7e9295", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a409a233e02b1864d1b76495a1f946bb56c7aeb2/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a409a233e02b1864d1b76495a1f946bb56c7aeb2/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=a409a233e02b1864d1b76495a1f946bb56c7aeb2", "patch": "@@ -291,6 +291,7 @@ impl<T: Ord> Deref for PeekMut<'_, T> {\n impl<T: Ord> DerefMut for PeekMut<'_, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         debug_assert!(!self.heap.is_empty());\n+        self.sift = true;\n         // SAFE: PeekMut is only instantiated for non-empty heaps\n         unsafe { self.heap.data.get_unchecked_mut(0) }\n     }\n@@ -396,10 +397,11 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// Cost is *O*(1) in the worst case.\n+    /// If the item is modified then the worst case time complexity is *O*(log(*n*)),\n+    /// otherwise it's *O*(1).\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n-        if self.is_empty() { None } else { Some(PeekMut { heap: self, sift: true }) }\n+        if self.is_empty() { None } else { Some(PeekMut { heap: self, sift: false }) }\n     }\n \n     /// Removes the greatest item from the binary heap and returns it, or `None` if it"}]}