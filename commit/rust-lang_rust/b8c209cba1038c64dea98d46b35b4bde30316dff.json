{"sha": "b8c209cba1038c64dea98d46b35b4bde30316dff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YzIwOWNiYTEwMzhjNjRkZWE5OGQ0NmIzNWI0YmRlMzAzMTZkZmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-30T02:54:05Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-30T02:54:05Z"}, "message": "Refactor std::test\n\nSeparate the console output from the running of tests", "tree": {"sha": "68db00e92eb55c4aaed0cc37a68cc654925312c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68db00e92eb55c4aaed0cc37a68cc654925312c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8c209cba1038c64dea98d46b35b4bde30316dff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c209cba1038c64dea98d46b35b4bde30316dff", "html_url": "https://github.com/rust-lang/rust/commit/b8c209cba1038c64dea98d46b35b4bde30316dff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8c209cba1038c64dea98d46b35b4bde30316dff/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e6bb137fe89674e8f41f85a56e63444a8608231", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e6bb137fe89674e8f41f85a56e63444a8608231", "html_url": "https://github.com/rust-lang/rust/commit/4e6bb137fe89674e8f41f85a56e63444a8608231"}], "stats": {"total": 178, "additions": 108, "deletions": 70}, "files": [{"sha": "d751cceb2652cdb1baea42af9d0cc3115a001015", "filename": "src/lib/test.rs", "status": "modified", "additions": 108, "deletions": 70, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/b8c209cba1038c64dea98d46b35b4bde30316dff/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c209cba1038c64dea98d46b35b4bde30316dff/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=b8c209cba1038c64dea98d46b35b4bde30316dff", "patch": "@@ -99,105 +99,143 @@ fn run_tests_console(opts: &test_opts, tests: &test_desc[]) -> bool {\n fn run_tests_console_(opts: &test_opts, tests: &test_desc[],\n                       to_task: &test_to_task) -> bool {\n \n-    let filtered_tests = filter_tests(opts, tests);\n-\n-    let out = io::stdout();\n-\n-    let total = ivec::len(filtered_tests);\n-    out.write_line(#fmt(\"\\nrunning %u tests\", total));\n-\n-    let futures = ~[];\n-\n-    let passed = 0u;\n-    let failed = 0u;\n-    let ignored = 0u;\n-\n-    let failures = ~[];\n-\n-    // It's tempting to just spawn all the tests at once but that doesn't\n-    // provide a great user experience because you might sit waiting for the\n-    // result of a particular test for an unusually long amount of time.\n-    let concurrency = get_concurrency();\n-    log #fmt(\"using %u test tasks\", concurrency);\n-    let run_idx = 0u;\n-    let wait_idx = 0u;\n-\n-    while wait_idx < total {\n-        while ivec::len(futures) < concurrency && run_idx < total {\n-            futures += ~[run_test(filtered_tests.(run_idx), to_task)];\n-            run_idx += 1u;\n-        }\n-\n-        let future = futures.(0);\n-        out.write_str(#fmt(\"running %s ... \", future.test.name));\n-        let result = future.wait();\n-        alt result {\n-          tr_ok. {\n-            passed += 1u;\n-            write_ok(out, concurrency);\n-            out.write_line(\"\");\n-          }\n-          tr_failed. {\n-            failed += 1u;\n-            write_failed(out, concurrency);\n-            out.write_line(\"\");\n-            failures += ~[future.test];\n+    type test_state = @{\n+        out: io::writer,\n+        use_color: bool,\n+        mutable total: uint,\n+        mutable passed: uint,\n+        mutable failed: uint,\n+        mutable ignored: uint,\n+        mutable failures: test_desc[]\n+    };\n+\n+    fn callback(event: testevent, st: test_state) {\n+        alt event {\n+          te_filtered(filtered_tests) {\n+            st.total = ivec::len(filtered_tests);\n+            st.out.write_line(#fmt(\"\\nrunning %u tests\", st.total));\n           }\n-          tr_ignored. {\n-            ignored += 1u;\n-            write_ignored(out, concurrency);\n-            out.write_line(\"\");\n+          te_result(test, result) {\n+            st.out.write_str(#fmt(\"test %s ... \", test.name));\n+            alt result {\n+              tr_ok. {\n+                st.passed += 1u;\n+                write_ok(st.out, st.use_color);\n+                st.out.write_line(\"\");\n+              }\n+              tr_failed. {\n+                st.failed += 1u;\n+                write_failed(st.out, st.use_color);\n+                st.out.write_line(\"\");\n+                st.failures += ~[test];\n+              }\n+              tr_ignored. {\n+                st.ignored += 1u;\n+                write_ignored(st.out, st.use_color);\n+                st.out.write_line(\"\");\n+              }\n+            }\n           }\n         }\n-        futures = ivec::slice(futures, 1u, ivec::len(futures));\n-        wait_idx += 1u;\n     }\n \n-    assert (passed + failed + ignored == total);\n-    let success = failed == 0u;\n+    let st = @{\n+        out: io::stdout(),\n+        use_color: use_color(),\n+        mutable total: 0u,\n+        mutable passed: 0u,\n+        mutable failed: 0u,\n+        mutable ignored: 0u,\n+        mutable failures: ~[]\n+    };\n+\n+    run_tests(opts, tests, to_task,\n+              bind callback(_, st));\n+\n+    assert st.passed + st.failed + st.ignored == st.total;\n+    let success = st.failed == 0u;\n \n     if !success {\n-        out.write_line(\"\\nfailures:\");\n-        for test: test_desc  in failures {\n-            out.write_line(#fmt(\"    %s\", test.name));\n+        st.out.write_line(\"\\nfailures:\");\n+        for test: test_desc in st.failures {\n+            let testname = test.name; // Satisfy alias analysis\n+            st.out.write_line(#fmt(\"    %s\", testname));\n         }\n     }\n \n-    out.write_str(#fmt(\"\\nresult: \"));\n+    st.out.write_str(#fmt(\"\\nresult: \"));\n     if success {\n-        write_ok(out, concurrency);\n-    } else { write_failed(out, concurrency); }\n-    out.write_str(#fmt(\". %u passed; %u failed; %u ignored\\n\\n\", passed,\n-                       failed, ignored));\n+        write_ok(st.out, st.use_color);\n+    } else { write_failed(st.out, st.use_color); }\n+    st.out.write_str(#fmt(\". %u passed; %u failed; %u ignored\\n\\n\",\n+                       st.passed, st.failed, st.ignored));\n \n     ret success;\n \n-    fn write_ok(out: &io::writer, concurrency: uint) {\n-        write_pretty(out, \"ok\", term::color_green, concurrency);\n+    fn write_ok(out: &io::writer, use_color: bool) {\n+        write_pretty(out, \"ok\", term::color_green, use_color);\n     }\n \n-    fn write_failed(out: &io::writer, concurrency: uint) {\n-        write_pretty(out, \"FAILED\", term::color_red, concurrency);\n+    fn write_failed(out: &io::writer, use_color: bool) {\n+        write_pretty(out, \"FAILED\", term::color_red, use_color);\n     }\n \n-    fn write_ignored(out: &io::writer, concurrency: uint) {\n-        write_pretty(out, \"ignored\", term::color_yellow, concurrency);\n+    fn write_ignored(out: &io::writer, use_color: bool) {\n+        write_pretty(out, \"ignored\", term::color_yellow, use_color);\n     }\n \n     fn write_pretty(out: &io::writer, word: &str, color: u8,\n-                    concurrency: uint) {\n-        // In the presence of concurrency, outputing control characters\n-        // can cause some crazy artifacting\n-        if concurrency == 1u && term::color_supported() {\n+                    use_color: bool) {\n+        if use_color && term::color_supported() {\n             term::fg(out.get_buf_writer(), color);\n         }\n         out.write_str(word);\n-        if concurrency == 1u && term::color_supported() {\n+        if use_color && term::color_supported() {\n             term::reset(out.get_buf_writer());\n         }\n     }\n }\n \n+fn use_color() -> bool {\n+    ret get_concurrency() == 1u;\n+}\n+\n+tag testevent {\n+    te_filtered(test_desc[]);\n+    te_result(test_desc, test_result);\n+}\n+\n+fn run_tests(opts: &test_opts, tests: &test_desc[],\n+             to_task: &test_to_task, callback: fn(testevent)) {\n+\n+    let filtered_tests = filter_tests(opts, tests);\n+\n+    callback(te_filtered(filtered_tests));\n+\n+    // It's tempting to just spawn all the tests at once but that doesn't\n+    // provide a great user experience because you might sit waiting for the\n+    // result of a particular test for an unusually long amount of time.\n+    let concurrency = get_concurrency();\n+    log #fmt(\"using %u test tasks\", concurrency);\n+    let total = ivec::len(filtered_tests);\n+    let run_idx = 0u;\n+    let wait_idx = 0u;\n+    let futures = ~[];\n+\n+    while wait_idx < total {\n+        while ivec::len(futures) < concurrency && run_idx < total {\n+            futures += ~[run_test(filtered_tests.(run_idx), to_task)];\n+            run_idx += 1u;\n+        }\n+\n+        let future = futures.(0);\n+        let result = future.wait();\n+        callback(te_result(future.test, result));\n+        futures = ivec::slice(futures, 1u, ivec::len(futures));\n+        wait_idx += 1u;\n+    }\n+}\n+\n fn get_concurrency() -> uint {\n     alt getenv(\"RUST_THREADS\") {\n       option::some(t) {"}]}