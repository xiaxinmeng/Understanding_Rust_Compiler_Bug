{"sha": "eae265271089011c309ce6b8386bdd98f29f2aaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhZTI2NTI3MTA4OTAxMWMzMDljZTZiODM4NmJkZDk4ZjI5ZjJhYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-04T15:41:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-04T15:41:50Z"}, "message": "auto merge of #13301 : erickt/rust/remove-refcell-get, r=huonw\n\n`RefCell::get` can be a bit surprising, because it actually clones the wrapped value. This removes `RefCell::get` and replaces all the users with `RefCell::borrow()` when it can, and `RefCell::borrow().clone()` when it can't. It removes `RefCell::set` for consistency. This closes #13182.\r\n\r\nIt also fixes an infinite loop in a test when debugging is on.", "tree": {"sha": "9092c1bd9f73378c6ba3797011701220caf7f0b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9092c1bd9f73378c6ba3797011701220caf7f0b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eae265271089011c309ce6b8386bdd98f29f2aaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eae265271089011c309ce6b8386bdd98f29f2aaf", "html_url": "https://github.com/rust-lang/rust/commit/eae265271089011c309ce6b8386bdd98f29f2aaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eae265271089011c309ce6b8386bdd98f29f2aaf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46e6194ee138b09d7376fa3dcdb539cf41dc68dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/46e6194ee138b09d7376fa3dcdb539cf41dc68dd", "html_url": "https://github.com/rust-lang/rust/commit/46e6194ee138b09d7376fa3dcdb539cf41dc68dd"}, {"sha": "1b6997d0692e743066dfc40e7ab4b65f8ed2e7fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b6997d0692e743066dfc40e7ab4b65f8ed2e7fd", "html_url": "https://github.com/rust-lang/rust/commit/1b6997d0692e743066dfc40e7ab4b65f8ed2e7fd"}], "stats": {"total": 223, "additions": 105, "deletions": 118}, "files": [{"sha": "af5b3f8b0cdd3b666b4efbcb15ea63218239d8c8", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -212,9 +212,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let time_passes = sess.time_passes();\n \n     sess.building_library.set(session::building_library(&sess.opts, &krate));\n-    sess.crate_types.set(session::collect_crate_types(sess,\n-                                                      krate.attrs\n-                                                           .as_slice()));\n+    *sess.crate_types.borrow_mut() = session::collect_crate_types(sess, krate.attrs.as_slice());\n \n     time(time_passes, \"gated feature checking\", (), |_|\n          front::feature_gate::check_crate(sess, &krate));"}, {"sha": "82e2e3147c93db1b0b39b18f39def54c789028d3", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -90,7 +90,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     fn fold_item(&mut self, i: @ast::Item) -> SmallVector<@ast::Item> {\n         self.cx.path.borrow_mut().push(i.ident);\n         debug!(\"current path: {}\",\n-               ast_util::path_name_i(self.cx.path.get().as_slice()));\n+               ast_util::path_name_i(self.cx.path.borrow().as_slice()));\n \n         if is_test_fn(&self.cx, i) || is_bench_fn(&self.cx, i) {\n             match i.node {\n@@ -104,7 +104,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     debug!(\"this is a test function\");\n                     let test = Test {\n                         span: i.span,\n-                        path: self.cx.path.get(),\n+                        path: self.cx.path.borrow().clone(),\n                         bench: is_bench_fn(&self.cx, i),\n                         ignore: is_ignored(&self.cx, i),\n                         should_fail: should_fail(i)"}, {"sha": "e453acac8109e74ffbf1bb390e9b600de8f1d34e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -1345,7 +1345,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     }\n \n     ebml_w.end_tag();\n-    return /*bad*/(*index).get();\n+    return /*bad*/index.borrow().clone();\n }\n \n \n@@ -1365,7 +1365,7 @@ fn create_index<T:Clone + Hash + 'static>(\n \n     let mut buckets_frozen = Vec::new();\n     for bucket in buckets.iter() {\n-        buckets_frozen.push(@/*bad*/(**bucket).get());\n+        buckets_frozen.push(@/*bad*/bucket.borrow().clone());\n     }\n     return buckets_frozen;\n }"}, {"sha": "d0bf70ea1c2c10c45b39ca6eaf573d9c1c20f645", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -270,7 +270,7 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n     }\n \n     // Seed entry point\n-    match tcx.sess.entry_fn.get() {\n+    match *tcx.sess.entry_fn.borrow() {\n         Some((id, _)) => worklist.push(id),\n         None => ()\n     }"}, {"sha": "441a3a3672983e9eb1bd0603415916b7cf432500", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -123,13 +123,13 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n \n fn configure_main(this: &mut EntryContext) {\n     if this.start_fn.is_some() {\n-        this.session.entry_fn.set(this.start_fn);\n+        *this.session.entry_fn.borrow_mut() = this.start_fn;\n         this.session.entry_type.set(Some(session::EntryStart));\n     } else if this.attr_main_fn.is_some() {\n-        this.session.entry_fn.set(this.attr_main_fn);\n+        *this.session.entry_fn.borrow_mut() = this.attr_main_fn;\n         this.session.entry_type.set(Some(session::EntryMain));\n     } else if this.main_fn.is_some() {\n-        this.session.entry_fn.set(this.main_fn);\n+        *this.session.entry_fn.borrow_mut() = this.main_fn;\n         this.session.entry_type.set(Some(session::EntryMain));\n     } else {\n         if !this.session.building_library.get() {"}, {"sha": "143b02f96d22f69ba995d13bf5e3d9f5aaefdb6e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 64, "deletions": 57, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -385,6 +385,10 @@ struct ImportResolution {\n     type_id: Cell<NodeId>,\n }\n \n+fn get<T: Clone>(cell: &RefCell<T>) -> T {\n+    cell.borrow().clone()\n+}\n+\n impl ImportResolution {\n     fn new(id: NodeId, is_public: bool) -> ImportResolution {\n         ImportResolution {\n@@ -400,8 +404,8 @@ impl ImportResolution {\n     fn target_for_namespace(&self, namespace: Namespace)\n                                 -> Option<Target> {\n         match namespace {\n-            TypeNS      => return self.type_target.get(),\n-            ValueNS     => return self.value_target.get(),\n+            TypeNS      => return self.type_target.borrow().clone(),\n+            ValueNS     => return self.value_target.borrow().clone(),\n         }\n     }\n \n@@ -546,22 +550,23 @@ impl NameBindings {\n         // Merges the module with the existing type def or creates a new one.\n         let module_ = @Module::new(parent_link, def_id, kind, external,\n                                        is_public);\n-        match self.type_def.get() {\n+        let type_def = self.type_def.borrow().clone();\n+        match type_def {\n             None => {\n-                self.type_def.set(Some(TypeNsDef {\n+                *self.type_def.borrow_mut() = Some(TypeNsDef {\n                     is_public: is_public,\n                     module_def: Some(module_),\n                     type_def: None,\n                     type_span: Some(sp)\n-                }));\n+                });\n             }\n             Some(type_def) => {\n-                self.type_def.set(Some(TypeNsDef {\n+                *self.type_def.borrow_mut() = Some(TypeNsDef {\n                     is_public: is_public,\n                     module_def: Some(module_),\n                     type_span: Some(sp),\n                     type_def: type_def.type_def\n-                }));\n+                });\n             }\n         }\n     }\n@@ -574,16 +579,17 @@ impl NameBindings {\n                        external: bool,\n                        is_public: bool,\n                        _sp: Span) {\n-        match self.type_def.get() {\n+        let type_def = self.type_def.borrow().clone();\n+        match type_def {\n             None => {\n                 let module = @Module::new(parent_link, def_id, kind,\n                                               external, is_public);\n-                self.type_def.set(Some(TypeNsDef {\n+                *self.type_def.borrow_mut() = Some(TypeNsDef {\n                     is_public: is_public,\n                     module_def: Some(module),\n                     type_def: None,\n                     type_span: None,\n-                }))\n+                });\n             }\n             Some(type_def) => {\n                 match type_def.module_def {\n@@ -593,12 +599,12 @@ impl NameBindings {\n                                                       kind,\n                                                       external,\n                                                       is_public);\n-                        self.type_def.set(Some(TypeNsDef {\n+                        *self.type_def.borrow_mut() = Some(TypeNsDef {\n                             is_public: is_public,\n                             module_def: Some(module),\n                             type_def: type_def.type_def,\n                             type_span: None,\n-                        }))\n+                        });\n                     }\n                     Some(module_def) => module_def.kind.set(kind),\n                 }\n@@ -609,33 +615,34 @@ impl NameBindings {\n     /// Records a type definition.\n     fn define_type(&self, def: Def, sp: Span, is_public: bool) {\n         // Merges the type with the existing type def or creates a new one.\n-        match self.type_def.get() {\n+        let type_def = self.type_def.borrow().clone();\n+        match type_def {\n             None => {\n-                self.type_def.set(Some(TypeNsDef {\n+                *self.type_def.borrow_mut() = Some(TypeNsDef {\n                     module_def: None,\n                     type_def: Some(def),\n                     type_span: Some(sp),\n                     is_public: is_public,\n-                }));\n+                });\n             }\n             Some(type_def) => {\n-                self.type_def.set(Some(TypeNsDef {\n+                *self.type_def.borrow_mut() = Some(TypeNsDef {\n                     type_def: Some(def),\n                     type_span: Some(sp),\n                     module_def: type_def.module_def,\n                     is_public: is_public,\n-                }));\n+                });\n             }\n         }\n     }\n \n     /// Records a value definition.\n     fn define_value(&self, def: Def, sp: Span, is_public: bool) {\n-        self.value_def.set(Some(ValueNsDef {\n+        *self.value_def.borrow_mut() = Some(ValueNsDef {\n             def: def,\n             value_span: Some(sp),\n             is_public: is_public,\n-        }));\n+        });\n     }\n \n     /// Returns the module node if applicable.\n@@ -662,17 +669,17 @@ impl NameBindings {\n \n     fn defined_in_namespace(&self, namespace: Namespace) -> bool {\n         match namespace {\n-            TypeNS   => return self.type_def.get().is_some(),\n-            ValueNS  => return self.value_def.get().is_some()\n+            TypeNS   => return self.type_def.borrow().is_some(),\n+            ValueNS  => return self.value_def.borrow().is_some()\n         }\n     }\n \n     fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n         match namespace {\n-            TypeNS => match self.type_def.get() {\n+            TypeNS => match *self.type_def.borrow() {\n                 Some(def) => def.is_public, None => false\n             },\n-            ValueNS => match self.value_def.get() {\n+            ValueNS => match *self.value_def.borrow() {\n                 Some(def) => def.is_public, None => false\n             }\n         }\n@@ -681,7 +688,7 @@ impl NameBindings {\n     fn def_for_namespace(&self, namespace: Namespace) -> Option<Def> {\n         match namespace {\n             TypeNS => {\n-                match self.type_def.get() {\n+                match *self.type_def.borrow() {\n                     None => None,\n                     Some(type_def) => {\n                         match type_def.type_def {\n@@ -702,7 +709,7 @@ impl NameBindings {\n                 }\n             }\n             ValueNS => {\n-                match self.value_def.get() {\n+                match *self.value_def.borrow() {\n                     None => None,\n                     Some(value_def) => Some(value_def.def)\n                 }\n@@ -714,13 +721,13 @@ impl NameBindings {\n         if self.defined_in_namespace(namespace) {\n             match namespace {\n                 TypeNS  => {\n-                    match self.type_def.get() {\n+                    match *self.type_def.borrow() {\n                         None => None,\n                         Some(type_def) => type_def.type_span\n                     }\n                 }\n                 ValueNS => {\n-                    match self.value_def.get() {\n+                    match *self.value_def.borrow() {\n                         None => None,\n                         Some(value_def) => value_def.value_span\n                     }\n@@ -1620,7 +1627,8 @@ impl<'a> Resolver<'a> {\n         match def {\n           DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n           DefTy(def_id) => {\n-            match child_name_bindings.type_def.get() {\n+            let type_def = child_name_bindings.type_def.borrow().clone();\n+            match type_def {\n               Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n                 debug!(\"(building reduced graph for external crate) \\\n                         already created module\");\n@@ -1812,7 +1820,8 @@ impl<'a> Resolver<'a> {\n                                 // Process the static methods. First,\n                                 // create the module.\n                                 let type_module;\n-                                match child_name_bindings.type_def.get() {\n+                                let type_def = child_name_bindings.type_def.borrow().clone();\n+                                match type_def {\n                                     Some(TypeNsDef {\n                                         module_def: Some(module_def),\n                                         ..\n@@ -2408,8 +2417,8 @@ impl<'a> Resolver<'a> {\n         match value_result {\n             BoundResult(target_module, name_bindings) => {\n                 debug!(\"(resolving single import) found value target\");\n-                import_resolution.value_target.set(\n-                    Some(Target::new(target_module, name_bindings)));\n+                *import_resolution.value_target.borrow_mut() =\n+                    Some(Target::new(target_module, name_bindings));\n                 import_resolution.value_id.set(directive.id);\n                 value_used_public = name_bindings.defined_in_public_namespace(ValueNS);\n             }\n@@ -2421,9 +2430,9 @@ impl<'a> Resolver<'a> {\n         match type_result {\n             BoundResult(target_module, name_bindings) => {\n                 debug!(\"(resolving single import) found type target: {:?}\",\n-                       {name_bindings.type_def.get().unwrap().type_def});\n-                import_resolution.type_target.set(\n-                    Some(Target::new(target_module, name_bindings)));\n+                       { name_bindings.type_def.borrow().clone().unwrap().type_def });\n+                *import_resolution.type_target.borrow_mut() =\n+                    Some(Target::new(target_module, name_bindings));\n                 import_resolution.type_id.set(directive.id);\n                 type_used_public = name_bindings.defined_in_public_namespace(TypeNS);\n             }\n@@ -2433,8 +2442,8 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        if import_resolution.value_target.get().is_none() &&\n-           import_resolution.type_target.get().is_none() {\n+        if import_resolution.value_target.borrow().is_none() &&\n+           import_resolution.type_target.borrow().is_none() {\n             let msg = format!(\"unresolved import: there is no \\\n                                `{}` in `{}`\",\n                               token::get_ident(source),\n@@ -2452,7 +2461,7 @@ impl<'a> Resolver<'a> {\n         // record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        let value_private = match import_resolution.value_target.get() {\n+        let value_private = match *import_resolution.value_target.borrow() {\n             Some(target) => {\n                 let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n                 self.def_map.borrow_mut().insert(directive.id, def);\n@@ -2463,7 +2472,7 @@ impl<'a> Resolver<'a> {\n             // _exists is false.\n             None => None,\n         };\n-        let type_private = match import_resolution.type_target.get() {\n+        let type_private = match *import_resolution.type_target.borrow() {\n             Some(target) => {\n                 let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n                 self.def_map.borrow_mut().insert(directive.id, def);\n@@ -2513,7 +2522,7 @@ impl<'a> Resolver<'a> {\n         for (ident, target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {:?} into `{}`\",\n-                   target_import_resolution.type_target.get().is_none(),\n+                   target_import_resolution.type_target.borrow().is_none(),\n                    self.module_to_str(module_));\n \n             if !target_import_resolution.is_public.get() {\n@@ -2528,10 +2537,10 @@ impl<'a> Resolver<'a> {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n                         @ImportResolution::new(id, is_public);\n-                    new_import_resolution.value_target.set(\n-                        target_import_resolution.value_target.get());\n-                    new_import_resolution.type_target.set(\n-                        target_import_resolution.type_target.get());\n+                    *new_import_resolution.value_target.borrow_mut() =\n+                        get(&target_import_resolution.value_target);\n+                    *new_import_resolution.type_target.borrow_mut() =\n+                        get(&target_import_resolution.type_target);\n \n                     import_resolutions.insert\n                         (*ident, new_import_resolution);\n@@ -2540,22 +2549,20 @@ impl<'a> Resolver<'a> {\n                     // Merge the two import resolutions at a finer-grained\n                     // level.\n \n-                    match target_import_resolution.value_target.get() {\n+                    match *target_import_resolution.value_target.borrow() {\n                         None => {\n                             // Continue.\n                         }\n                         Some(value_target) => {\n-                            dest_import_resolution.value_target.set(\n-                                Some(value_target));\n+                            *dest_import_resolution.value_target.borrow_mut() = Some(value_target);\n                         }\n                     }\n-                    match target_import_resolution.type_target.get() {\n+                    match *target_import_resolution.type_target.borrow() {\n                         None => {\n                             // Continue.\n                         }\n                         Some(type_target) => {\n-                            dest_import_resolution.type_target.set(\n-                                Some(type_target));\n+                            *dest_import_resolution.type_target.borrow_mut() = Some(type_target);\n                         }\n                     }\n                     dest_import_resolution.is_public.set(is_public);\n@@ -2627,14 +2634,14 @@ impl<'a> Resolver<'a> {\n         // Merge the child item into the import resolution.\n         if name_bindings.defined_in_public_namespace(ValueNS) {\n             debug!(\"(resolving glob import) ... for value target\");\n-            dest_import_resolution.value_target.set(\n-                Some(Target::new(containing_module, name_bindings)));\n+            *dest_import_resolution.value_target.borrow_mut() =\n+                Some(Target::new(containing_module, name_bindings));\n             dest_import_resolution.value_id.set(id);\n         }\n         if name_bindings.defined_in_public_namespace(TypeNS) {\n             debug!(\"(resolving glob import) ... for type target\");\n-            dest_import_resolution.type_target.set(\n-                Some(Target::new(containing_module, name_bindings)));\n+            *dest_import_resolution.type_target.borrow_mut() =\n+                Some(Target::new(containing_module, name_bindings));\n             dest_import_resolution.type_id.set(id);\n         }\n         dest_import_resolution.is_public.set(is_public);\n@@ -2692,7 +2699,7 @@ impl<'a> Resolver<'a> {\n                 Success((target, used_proxy)) => {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n-                    match target.bindings.type_def.get() {\n+                    match *target.bindings.type_def.borrow() {\n                         Some(type_def) => {\n                             match type_def.module_def {\n                                 None => {\n@@ -3004,7 +3011,7 @@ impl<'a> Resolver<'a> {\n         match resolve_result {\n             Success((target, _)) => {\n                 let bindings = &*target.bindings;\n-                match bindings.type_def.get() {\n+                match *bindings.type_def.borrow() {\n                     Some(type_def) => {\n                         match type_def.module_def {\n                             None => {\n@@ -4526,8 +4533,8 @@ impl<'a> Resolver<'a> {\n                 debug!(\"(resolve bare identifier pattern) succeeded in \\\n                          finding {} at {:?}\",\n                         token::get_ident(name),\n-                        target.bindings.value_def.get());\n-                match target.bindings.value_def.get() {\n+                        target.bindings.value_def.borrow());\n+                match *target.bindings.value_def.borrow() {\n                     None => {\n                         fail!(\"resolved name in the value namespace to a \\\n                               set of name bindings with no def?!\");"}, {"sha": "9657265e14038aaea488192267d81d9100445061", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -1128,7 +1128,7 @@ pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-            let bcx = fcx.entry_bcx.get().unwrap();\n+            let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n             Alloca(bcx, lloutputtype, \"__make_return_pointer\")\n         }\n     }\n@@ -1209,7 +1209,7 @@ pub fn init_function<'a>(\n                      param_substs: Option<@param_substs>) {\n     let entry_bcx = fcx.new_temp_block(\"entry-block\");\n \n-    fcx.entry_bcx.set(Some(entry_bcx));\n+    *fcx.entry_bcx.borrow_mut() = Some(entry_bcx);\n \n     // Use a dummy instruction as the insertion point for all allocas.\n     // This is later removed in FunctionContext::cleanup.\n@@ -1399,7 +1399,7 @@ pub fn trans_closure(ccx: &CrateContext,\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-    let bcx_top = fcx.entry_bcx.get().unwrap();\n+    let bcx_top = fcx.entry_bcx.borrow().clone().unwrap();\n     let mut bcx = bcx_top;\n     let block_ty = node_id_type(bcx, body.id);\n \n@@ -1547,7 +1547,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n \n     let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n \n-    let bcx = fcx.entry_bcx.get().unwrap();\n+    let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n \n     if !type_is_zero_size(fcx.ccx, result_ty) {\n         let repr = adt::represent_type(ccx, result_ty);\n@@ -1752,7 +1752,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n }\n \n pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n-    match sess.entry_fn.get() {\n+    match *sess.entry_fn.borrow() {\n         Some((entry_id, _)) => node_id == entry_id,\n         None => false\n     }"}, {"sha": "4671e21170e869bea654b35e18d8cd5c2db5ab51", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -464,7 +464,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx, llfn, -1, true, f.sig.output, None, None, &arena);\n     init_function(&fcx, true, f.sig.output, None);\n-    let bcx = fcx.entry_bcx.get().unwrap();\n+    let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n \n     let args = create_datums_for_fn_args(&fcx,\n                                          ty::ty_fn_args(closure_ty)"}, {"sha": "369807e98d7e04e11780fc896cd0d9172bdcb3f9", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -322,7 +322,7 @@ impl<'a> FunctionContext<'a> {\n                                                      .unwrap());\n         }\n         // Remove the cycle between fcx and bcx, so memory can be freed\n-        self.entry_bcx.set(None);\n+        *self.entry_bcx.borrow_mut() = None;\n     }\n \n     pub fn get_llreturn(&self) -> BasicBlockRef {"}, {"sha": "87234ce3683531907f91b501a7c71a700cc54d77", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -463,7 +463,7 @@ fn make_generic_glue(ccx: &CrateContext,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let bcx = fcx.entry_bcx.get().unwrap();\n+    let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, fcx.arg_pos(0) as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);\n     finish_fn(&fcx, bcx);"}, {"sha": "28a39718e7fb6a32b6a79d300cd04cd941e89d5e", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -199,7 +199,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n \n     set_always_inline(fcx.llfn);\n \n-    let mut bcx = fcx.entry_bcx.get().unwrap();\n+    let mut bcx = fcx.entry_bcx.borrow().clone().unwrap();\n     let first_real_arg = fcx.arg_pos(0u);\n \n     let name = token::get_ident(item.ident);"}, {"sha": "1adf5cf8afe5d2d40526ce64da878dc09d9ac5da", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -300,7 +300,7 @@ impl<'a> Reflector<'a> {\n                     //\n                     llvm::LLVMGetParam(llfdecl, fcx.arg_pos(0u) as c_uint)\n                 };\n-                let bcx = fcx.entry_bcx.get().unwrap();\n+                let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, repr, arg, Some(Type::i64(ccx)));\n                 Store(bcx, ret, fcx.llretptr.get().unwrap());"}, {"sha": "8f9b67f81e884ac63445c63e4f068cb17db72340", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -2209,8 +2209,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         fcx.write_ty(expr.id, fty);\n \n         let (inherited_purity, id) =\n-            ty::determine_inherited_purity((fcx.ps.get().purity,\n-                                            fcx.ps.get().def),\n+            ty::determine_inherited_purity((fcx.ps.borrow().purity,\n+                                            fcx.ps.borrow().def),\n                                            (purity, expr.id),\n                                            sigil);\n \n@@ -3333,7 +3333,7 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n         };\n     });\n \n-    fcx.ps.set(prev);\n+    *fcx.ps.borrow_mut() = prev;\n }\n \n pub fn check_const(ccx: &CrateCtxt,"}, {"sha": "c8613fd70652ee60e8f5909de52c6c4029ea69de", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -398,7 +398,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n     let method_call = MethodCall::expr(expr.id);\n-    let has_method_map = rcx.fcx.inh.method_map.get().contains_key(&method_call);\n+    let has_method_map = rcx.fcx.inh.method_map.borrow().contains_key(&method_call);\n \n     // Check any autoderefs or autorefs that appear.\n     for &adjustment in rcx.fcx.inh.adjustments.borrow().find(&expr.id).iter() {\n@@ -498,7 +498,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         ast::ExprUnary(ast::UnDeref, base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let method_call = MethodCall::expr(expr.id);\n-            let base_ty = match rcx.fcx.inh.method_map.get().find(&method_call) {\n+            let base_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n                 Some(method) => {\n                     constrain_call(rcx, None, expr, Some(base), [], true);\n                     ty::ty_fn_ret(method.ty)\n@@ -852,7 +852,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                i, derefs);\n \n         let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n-        derefd_ty = match rcx.fcx.inh.method_map.get().find(&method_call) {\n+        derefd_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n             Some(method) => {\n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case."}, {"sha": "9c947fb3360e455014adeb480934f15f3fad864e", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -1286,6 +1286,6 @@ impl LifeGiver {\n     }\n \n     fn get_generated_lifetimes(&self) -> Vec<ast::Lifetime> {\n-        self.generated.get()\n+        self.generated.borrow().clone()\n     }\n }"}, {"sha": "446d2ff055cca90fd819f53f7e3819fac87537ec", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -431,7 +431,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n fn check_for_entry_fn(ccx: &CrateCtxt) {\n     let tcx = ccx.tcx;\n     if !tcx.sess.building_library.get() {\n-        match tcx.sess.entry_fn.get() {\n+        match *tcx.sess.entry_fn.borrow() {\n           Some((id, sp)) => match tcx.sess.entry_type.get() {\n               Some(session::EntryMain) => check_main_fn_ty(ccx, id, sp),\n               Some(session::EntryStart) => check_start_fn_ty(ccx, id, sp),"}, {"sha": "40c6c3ebccf0be857d272acd67257bdce729b534", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -164,33 +164,11 @@ impl<T> RefCell<T> {\n             None => fail!(\"RefCell<T> already borrowed\")\n         }\n     }\n-\n-    /// Sets the value, replacing what was there.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value is currently borrowed.\n-    #[inline]\n-    pub fn set(&self, value: T) {\n-        *self.borrow_mut() = value;\n-    }\n-}\n-\n-impl<T:Clone> RefCell<T> {\n-    /// Returns a copy of the contained value.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value is currently mutably borrowed.\n-    #[inline]\n-    pub fn get(&self) -> T {\n-        (*self.borrow()).clone()\n-    }\n }\n \n impl<T: Clone> Clone for RefCell<T> {\n     fn clone(&self) -> RefCell<T> {\n-        RefCell::new(self.get())\n+        RefCell::new(self.borrow().clone())\n     }\n }\n \n@@ -216,7 +194,7 @@ impl<'b, T> Drop for Ref<'b, T> {\n impl<'b, T> Deref<T> for Ref<'b, T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        unsafe{ &*self.parent.value.get() }\n+        unsafe { &*self.parent.value.get() }\n     }\n }\n \n@@ -236,14 +214,14 @@ impl<'b, T> Drop for RefMut<'b, T> {\n impl<'b, T> Deref<T> for RefMut<'b, T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        unsafe{ &*self.parent.value.get() }\n+        unsafe { &*self.parent.value.get() }\n     }\n }\n \n impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n-        unsafe{ &mut *self.parent.value.get() }\n+        unsafe { &mut *self.parent.value.get() }\n     }\n }\n "}, {"sha": "ca1ea0169e66a269f51f248b1885c1253c49b970", "filename": "src/libstd/option.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -651,7 +651,8 @@ mod tests {\n         impl ::ops::Drop for R {\n            fn drop(&mut self) {\n                 let ii = &*self.i;\n-                ii.set(ii.get() + 1);\n+                let i = ii.borrow().clone();\n+                *ii.borrow_mut() = i + 1;\n             }\n         }\n \n@@ -667,7 +668,7 @@ mod tests {\n             let opt = Some(x);\n             let _y = opt.unwrap();\n         }\n-        assert_eq!(i.get(), 1);\n+        assert_eq!(*i.borrow(), 1);\n     }\n \n     #[test]"}, {"sha": "e61510f2ef2d8e8136fa284c8d9cf516705e8751", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -21,5 +21,5 @@ pub type header_map = HashMap<~str, @RefCell<Vec<@~str>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let _x = (**((**req.get(&~\"METHOD\")).clone()).get().get(0)).clone();\n+  let _x = (**((**req.get(&~\"METHOD\")).clone()).borrow().clone().get(0)).clone();\n }"}, {"sha": "c6f353136bada19302eb77ac6b236caec27d2b42", "filename": "src/test/run-pass/cycle-collection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Ftest%2Frun-pass%2Fcycle-collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Ftest%2Frun-pass%2Fcycle-collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -19,7 +19,7 @@ enum taggy {\n \n fn f() {\n     let a_box = @RefCell::new(nil);\n-    a_box.set(cons(a_box));\n+    *a_box.borrow_mut() = cons(a_box);\n }\n \n pub fn main() {"}, {"sha": "06f95bae5593bcb68fb817a3e99c5ae48766ff7a", "filename": "src/test/run-pass/issue-980.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Ftest%2Frun-pass%2Fissue-980.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Ftest%2Frun-pass%2Fissue-980.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-980.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -23,7 +23,7 @@ struct Pointy {\n \n pub fn main() {\n     let m = @RefCell::new(Pointy { x : no_pointy });\n-    m.set(Pointy {\n+    *m.borrow_mut() = Pointy {\n         x: yes_pointy(m)\n-    });\n+    };\n }"}, {"sha": "71fde8667032207ba9db4c6a23a5adaa73cbaec0", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae265271089011c309ce6b8386bdd98f29f2aaf/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=eae265271089011c309ce6b8386bdd98f29f2aaf", "patch": "@@ -17,6 +17,9 @@ use std::os;\n use std::str;\n \n // lifted from the test module\n+// Inlining to avoid llvm turning the recursive functions into tail calls,\n+// which doesn't consume stack.\n+#[inline(always)]\n pub fn black_box<T>(dummy: T) { unsafe { asm!(\"\" : : \"r\"(&dummy)) } }\n \n fn silent_recurse() {"}]}