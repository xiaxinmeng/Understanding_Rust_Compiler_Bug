{"sha": "c9b86a91786ca54e898b54f30a6e11546b8e8026", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5Yjg2YTkxNzg2Y2E1NGU4OThiNTRmMzBhNmUxMTU0NmI4ZTgwMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-03T07:24:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-03T07:24:11Z"}, "message": "Auto merge of #48689 - Manishearth:rollup, r=Manishearth\n\nRollup (unsupervised)\n\nless risky PRs, to run overnight", "tree": {"sha": "ff7cd48f4d47920056d504f74758f48ad49d955b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff7cd48f4d47920056d504f74758f48ad49d955b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9b86a91786ca54e898b54f30a6e11546b8e8026", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b86a91786ca54e898b54f30a6e11546b8e8026", "html_url": "https://github.com/rust-lang/rust/commit/c9b86a91786ca54e898b54f30a6e11546b8e8026", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9b86a91786ca54e898b54f30a6e11546b8e8026/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f1f628765df7b4918df5b8bcbd8d8da93b03494", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f1f628765df7b4918df5b8bcbd8d8da93b03494", "html_url": "https://github.com/rust-lang/rust/commit/5f1f628765df7b4918df5b8bcbd8d8da93b03494"}, {"sha": "40d2a98503b4eb4efe73cf5734e5a13ddcf3ac8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/40d2a98503b4eb4efe73cf5734e5a13ddcf3ac8a", "html_url": "https://github.com/rust-lang/rust/commit/40d2a98503b4eb4efe73cf5734e5a13ddcf3ac8a"}], "stats": {"total": 975, "additions": 621, "deletions": 354}, "files": [{"sha": "6c597301ac2045cfeea0158268455c9d6eb19364", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -281,3 +281,32 @@ bench_sums! {\n     bench_take_while_chain_ref_sum,\n     (0i64..1000000).chain(1000000..).take_while(|&x| x < 1111111)\n }\n+\n+// Checks whether Skip<Zip<A,B>> is as fast as Zip<Skip<A>, Skip<B>>, from\n+// https://users.rust-lang.org/t/performance-difference-between-iterator-zip-and-skip-order/15743\n+#[bench]\n+fn bench_zip_then_skip(b: &mut Bencher) {\n+    let v: Vec<_> = (0..100_000).collect();\n+    let t: Vec<_> = (0..100_000).collect();\n+\n+    b.iter(|| {\n+        let s = v.iter().zip(t.iter()).skip(10000)\n+            .take_while(|t| *t.0 < 10100)\n+            .map(|(a, b)| *a + *b)\n+            .sum::<u64>();\n+        assert_eq!(s, 2009900);\n+    });\n+}\n+#[bench]\n+fn bench_skip_then_zip(b: &mut Bencher) {\n+    let v: Vec<_> = (0..100_000).collect();\n+    let t: Vec<_> = (0..100_000).collect();\n+\n+    b.iter(|| {\n+        let s = v.iter().skip(10000).zip(t.iter().skip(10000))\n+            .take_while(|t| *t.0 < 10100)\n+            .map(|(a, b)| *a + *b)\n+            .sum::<u64>();\n+        assert_eq!(s, 2009900);\n+    });\n+}"}, {"sha": "b98470449827e66a99d13e46e876b4bea2ac247e", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -343,7 +343,7 @@ impl Ordering {\n /// v.sort_by_key(|&num| (num > 3, Reverse(num)));\n /// assert_eq!(v, vec![3, 2, 1, 6, 5, 4]);\n /// ```\n-#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n+#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\n #[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n pub struct Reverse<T>(#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")] pub T);\n "}, {"sha": "257d7d6caaaf85f074377944ba286aedd30c8a9a", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -1045,6 +1045,11 @@ impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         ZipImpl::size_hint(self)\n     }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        ZipImpl::nth(self, n)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1065,6 +1070,14 @@ trait ZipImpl<A, B> {\n     fn new(a: A, b: B) -> Self;\n     fn next(&mut self) -> Option<Self::Item>;\n     fn size_hint(&self) -> (usize, Option<usize>);\n+    fn nth(&mut self, n: usize) -> Option<Self::Item>;\n+    fn super_nth(&mut self, mut n: usize) -> Option<Self::Item> {\n+        while let Some(x) = self.next() {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n     fn next_back(&mut self) -> Option<Self::Item>\n         where A: DoubleEndedIterator + ExactSizeIterator,\n               B: DoubleEndedIterator + ExactSizeIterator;\n@@ -1094,6 +1107,11 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         })\n     }\n \n+    #[inline]\n+    default fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.super_nth(n)\n+    }\n+\n     #[inline]\n     default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n         where A: DoubleEndedIterator + ExactSizeIterator,\n@@ -1174,6 +1192,24 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         (len, Some(len))\n     }\n \n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let delta = cmp::min(n, self.len - self.index);\n+        let end = self.index + delta;\n+        while self.index < end {\n+            let i = self.index;\n+            self.index += 1;\n+            if A::may_have_side_effect() {\n+                unsafe { self.a.get_unchecked(i); }\n+            }\n+            if B::may_have_side_effect() {\n+                unsafe { self.b.get_unchecked(i); }\n+            }\n+        }\n+\n+        self.super_nth(n - delta)\n+    }\n+\n     #[inline]\n     fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n         where A: DoubleEndedIterator + ExactSizeIterator,"}, {"sha": "6270e5892b3a0b4141da929e105fe71300bed165", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 30, "deletions": 78, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -740,8 +740,6 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let s: &str = \"123\";\n     /// let ptr: *const u8 = s.as_ptr();\n     ///\n@@ -750,7 +748,7 @@ impl<T: ?Sized> *const T {\n     ///     println!(\"{}\", *ptr.add(2) as char);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn add(self, count: usize) -> Self\n         where T: Sized,\n@@ -799,8 +797,6 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let s: &str = \"123\";\n     ///\n     /// unsafe {\n@@ -809,7 +805,7 @@ impl<T: ?Sized> *const T {\n     ///     println!(\"{}\", *end.sub(2) as char);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn sub(self, count: usize) -> Self\n         where T: Sized,\n@@ -836,8 +832,6 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// // Iterate using a raw pointer in increments of two elements\n     /// let data = [1u8, 2, 3, 4, 5];\n     /// let mut ptr: *const u8 = data.as_ptr();\n@@ -852,7 +846,7 @@ impl<T: ?Sized> *const T {\n     ///     ptr = ptr.wrapping_add(step);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_add(self, count: usize) -> Self\n         where T: Sized,\n@@ -879,8 +873,6 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// // Iterate using a raw pointer in increments of two elements (backwards)\n     /// let data = [1u8, 2, 3, 4, 5];\n     /// let mut ptr: *const u8 = data.as_ptr();\n@@ -895,7 +887,7 @@ impl<T: ?Sized> *const T {\n     ///     ptr = ptr.wrapping_sub(step);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_sub(self, count: usize) -> Self\n         where T: Sized,\n@@ -922,16 +914,14 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let x = 12;\n     /// let y = &x as *const i32;\n     ///\n     /// unsafe {\n     ///     assert_eq!(y.read(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read(self) -> T\n         where T: Sized,\n@@ -974,16 +964,14 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let x = 12;\n     /// let y = &x as *const i32;\n     ///\n     /// unsafe {\n     ///     assert_eq!(y.read_volatile(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_volatile(self) -> T\n         where T: Sized,\n@@ -1010,16 +998,14 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let x = 12;\n     /// let y = &x as *const i32;\n     ///\n     /// unsafe {\n     ///     assert_eq!(y.read_unaligned(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_unaligned(self) -> T\n         where T: Sized,\n@@ -1046,8 +1032,6 @@ impl<T: ?Sized> *const T {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// # #[allow(dead_code)]\n     /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n@@ -1056,7 +1040,7 @@ impl<T: ?Sized> *const T {\n     ///     dst\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n         where T: Sized,\n@@ -1085,8 +1069,6 @@ impl<T: ?Sized> *const T {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// # #[allow(dead_code)]\n     /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n@@ -1095,7 +1077,7 @@ impl<T: ?Sized> *const T {\n     ///     dst\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n         where T: Sized,\n@@ -1443,8 +1425,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let s: &str = \"123\";\n     /// let ptr: *const u8 = s.as_ptr();\n     ///\n@@ -1453,7 +1433,7 @@ impl<T: ?Sized> *mut T {\n     ///     println!(\"{}\", *ptr.add(2) as char);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn add(self, count: usize) -> Self\n         where T: Sized,\n@@ -1502,8 +1482,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let s: &str = \"123\";\n     ///\n     /// unsafe {\n@@ -1512,7 +1490,7 @@ impl<T: ?Sized> *mut T {\n     ///     println!(\"{}\", *end.sub(2) as char);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn sub(self, count: usize) -> Self\n         where T: Sized,\n@@ -1539,8 +1517,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// // Iterate using a raw pointer in increments of two elements\n     /// let data = [1u8, 2, 3, 4, 5];\n     /// let mut ptr: *const u8 = data.as_ptr();\n@@ -1555,7 +1531,7 @@ impl<T: ?Sized> *mut T {\n     ///     ptr = ptr.wrapping_add(step);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_add(self, count: usize) -> Self\n         where T: Sized,\n@@ -1582,8 +1558,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// // Iterate using a raw pointer in increments of two elements (backwards)\n     /// let data = [1u8, 2, 3, 4, 5];\n     /// let mut ptr: *const u8 = data.as_ptr();\n@@ -1598,7 +1572,7 @@ impl<T: ?Sized> *mut T {\n     ///     ptr = ptr.wrapping_sub(step);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_sub(self, count: usize) -> Self\n         where T: Sized,\n@@ -1625,16 +1599,14 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let x = 12;\n     /// let y = &x as *const i32;\n     ///\n     /// unsafe {\n     ///     assert_eq!(y.read(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read(self) -> T\n         where T: Sized,\n@@ -1668,7 +1640,7 @@ impl<T: ?Sized> *mut T {\n     /// Beyond accepting a raw pointer, this is unsafe because it semantically\n     /// moves the value out of `self` without preventing further usage of `self`.\n     /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `src` is not used before the data is overwritten again (e.g. with `write`,\n+    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n     /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n     /// because it will attempt to drop the value previously at `*self`.\n     ///\n@@ -1677,16 +1649,14 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let x = 12;\n     /// let y = &x as *const i32;\n     ///\n     /// unsafe {\n     ///     assert_eq!(y.read_volatile(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_volatile(self) -> T\n         where T: Sized,\n@@ -1713,16 +1683,14 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let x = 12;\n     /// let y = &x as *const i32;\n     ///\n     /// unsafe {\n     ///     assert_eq!(y.read_unaligned(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_unaligned(self) -> T\n         where T: Sized,\n@@ -1749,8 +1717,6 @@ impl<T: ?Sized> *mut T {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// # #[allow(dead_code)]\n     /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n@@ -1759,7 +1725,7 @@ impl<T: ?Sized> *mut T {\n     ///     dst\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n         where T: Sized,\n@@ -1788,8 +1754,6 @@ impl<T: ?Sized> *mut T {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// # #[allow(dead_code)]\n     /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n@@ -1798,7 +1762,7 @@ impl<T: ?Sized> *mut T {\n     ///     dst\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n         where T: Sized,\n@@ -1825,8 +1789,6 @@ impl<T: ?Sized> *mut T {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// # #[allow(dead_code)]\n     /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst: Vec<T> = Vec::with_capacity(elts);\n@@ -1835,7 +1797,7 @@ impl<T: ?Sized> *mut T {\n     ///     dst\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_from(self, src: *const T, count: usize)\n         where T: Sized,\n@@ -1864,8 +1826,6 @@ impl<T: ?Sized> *mut T {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// # #[allow(dead_code)]\n     /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst: Vec<T> = Vec::with_capacity(elts);\n@@ -1874,7 +1834,7 @@ impl<T: ?Sized> *mut T {\n     ///     dst\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)\n         where T: Sized,\n@@ -1899,7 +1859,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This has all the same safety problems as `ptr::read` with respect to\n     /// invalid pointers, types, and double drops.\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn drop_in_place(self) {\n         drop_in_place(self)\n@@ -1929,8 +1889,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let mut x = 0;\n     /// let y = &mut x as *mut i32;\n     /// let z = 12;\n@@ -1940,7 +1898,7 @@ impl<T: ?Sized> *mut T {\n     ///     assert_eq!(y.read(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write(self, val: T)\n         where T: Sized,\n@@ -1954,16 +1912,14 @@ impl<T: ?Sized> *mut T {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let mut vec = vec![0; 4];\n     /// unsafe {\n     ///     let vec_ptr = vec.as_mut_ptr();\n     ///     vec_ptr.write_bytes(b'a', 2);\n     /// }\n     /// assert_eq!(vec, [b'a', b'a', 0, 0]);\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_bytes(self, val: u8, count: usize)\n         where T: Sized,\n@@ -2008,8 +1964,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let mut x = 0;\n     /// let y = &mut x as *mut i32;\n     /// let z = 12;\n@@ -2019,7 +1973,7 @@ impl<T: ?Sized> *mut T {\n     ///     assert_eq!(y.read_volatile(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_volatile(self, val: T)\n         where T: Sized,\n@@ -2040,8 +1994,8 @@ impl<T: ?Sized> *mut T {\n     /// allocations or resources, so care must be taken not to overwrite an object\n     /// that should be dropped.\n     ///\n-    /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n-    /// location pointed to by `dst`.\n+    /// Additionally, it does not drop `self`. Semantically, `self` is moved into the\n+    /// location pointed to by `val`.\n     ///\n     /// This is appropriate for initializing uninitialized memory, or overwriting\n     /// memory that has previously been `read` from.\n@@ -2051,8 +2005,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let mut x = 0;\n     /// let y = &mut x as *mut i32;\n     /// let z = 12;\n@@ -2062,7 +2014,7 @@ impl<T: ?Sized> *mut T {\n     ///     assert_eq!(y.read_unaligned(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_unaligned(self, val: T)\n         where T: Sized,\n@@ -2077,7 +2029,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This is only unsafe because it accepts a raw pointer.\n     /// Otherwise, this operation is identical to `mem::replace`.\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn replace(self, src: T) -> T\n         where T: Sized,\n@@ -2095,7 +2047,7 @@ impl<T: ?Sized> *mut T {\n     /// as arguments.\n     ///\n     /// Ensure that these pointers are valid before calling `swap`.\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn swap(self, with: *mut T)\n         where T: Sized,"}, {"sha": "a962efadd64e9aed3cca29088bd9cee74ec2823c", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -144,6 +144,43 @@ fn test_iterator_chain_find() {\n     assert_eq!(iter.next(), None);\n }\n \n+#[test]\n+fn test_zip_nth() {\n+    let xs = [0, 1, 2, 4, 5];\n+    let ys = [10, 11, 12];\n+\n+    let mut it = xs.iter().zip(&ys);\n+    assert_eq!(it.nth(0), Some((&0, &10)));\n+    assert_eq!(it.nth(1), Some((&2, &12)));\n+    assert_eq!(it.nth(0), None);\n+\n+    let mut it = xs.iter().zip(&ys);\n+    assert_eq!(it.nth(3), None);\n+\n+    let mut it = ys.iter().zip(&xs);\n+    assert_eq!(it.nth(3), None);\n+}\n+\n+#[test]\n+fn test_zip_nth_side_effects() {\n+    let mut a = Vec::new();\n+    let mut b = Vec::new();\n+    let value = [1, 2, 3, 4, 5, 6].iter().cloned()\n+        .map(|n| {\n+            a.push(n);\n+            n * 10\n+        })\n+        .zip([2, 3, 4, 5, 6, 7, 8].iter().cloned().map(|n| {\n+            b.push(n * 100);\n+            n * 1000\n+        }))\n+        .skip(1)\n+        .nth(3);\n+    assert_eq!(value, Some((50, 6000)));\n+    assert_eq!(a, vec![1, 2, 3, 4, 5]);\n+    assert_eq!(b, vec![200, 300, 400, 500, 600]);\n+}\n+\n #[test]\n fn test_iterator_step_by() {\n     // Identity"}, {"sha": "e56333aba9be571c5d52c738a81909b291b87a17", "filename": "src/librustc/dep_graph/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -54,7 +54,7 @@ pub struct EdgeFilter {\n }\n \n impl EdgeFilter {\n-    pub fn new(test: &str) -> Result<EdgeFilter, Box<Error>> {\n+    pub fn new(test: &str) -> Result<EdgeFilter, Box<dyn Error>> {\n         let parts: Vec<_> = test.split(\"->\").collect();\n         if parts.len() != 2 {\n             Err(format!(\"expected a filter like `a&b -> c&d`, not `{}`\", test).into())"}, {"sha": "fa745bf165577cc3de2d14e6f1b7e8877c61ced6", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -80,13 +80,13 @@ pub struct LoweringContext<'a> {\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n     sess: &'a Session,\n \n-    cstore: &'a CrateStore,\n+    cstore: &'a dyn CrateStore,\n \n     // As we walk the AST we must keep track of the current 'parent' def id (in\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n     parent_def: Option<DefIndex>,\n-    resolver: &'a mut Resolver,\n+    resolver: &'a mut dyn Resolver,\n     name_map: FxHashMap<Ident, Name>,\n \n     /// The items being lowered are collected here.\n@@ -177,10 +177,10 @@ enum ImplTraitContext {\n }\n \n pub fn lower_crate(sess: &Session,\n-                   cstore: &CrateStore,\n+                   cstore: &dyn CrateStore,\n                    dep_graph: &DepGraph,\n                    krate: &Crate,\n-                   resolver: &mut Resolver)\n+                   resolver: &mut dyn Resolver)\n                    -> hir::Crate {\n     // We're constructing the HIR here; we don't care what we will\n     // read, since we haven't even constructed the *input* to"}, {"sha": "9bbda9d74479b7e060c545a5bc32ebec0dff59f3", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n     pub(super) fn finalize_and_compute_crate_hash(self,\n                                                   crate_disambiguator: CrateDisambiguator,\n-                                                  cstore: &CrateStore,\n+                                                  cstore: &dyn CrateStore,\n                                                   codemap: &CodeMap,\n                                                   commandline_args_hash: u64)\n                                                   -> (Vec<MapEntry<'hir>>, Svh) {"}, {"sha": "cdd6395747865576a1f6d6d876587c05241bf2e4", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -26,7 +26,7 @@ pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n     expansion: Mark,\n-    pub visit_macro_invoc: Option<&'a mut FnMut(MacroInvocationData)>,\n+    pub visit_macro_invoc: Option<&'a mut dyn FnMut(MacroInvocationData)>,\n }\n \n pub struct MacroInvocationData {"}, {"sha": "61fae4609d54fe7813b76857c5baa5fb6e48ed09", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -19,6 +19,8 @@ use dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n \n use hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId, DefIndexAddressSpace};\n \n+use middle::cstore::CrateStore;\n+\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n@@ -1136,8 +1138,9 @@ impl Named for StructField { fn name(&self) -> Name { self.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n+\n pub fn map_crate<'hir>(sess: &::session::Session,\n-                       cstore: &::middle::cstore::CrateStore,\n+                       cstore: &dyn CrateStore,\n                        forest: &'hir mut Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {"}, {"sha": "ed8cea3eb65634abca355cd2fa49500692f4bbbf", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -62,7 +62,7 @@ pub trait PpAnn {\n \n pub struct NoAnn;\n impl PpAnn for NoAnn {}\n-pub const NO_ANN: &'static PpAnn = &NoAnn;\n+pub const NO_ANN: &'static dyn PpAnn = &NoAnn;\n \n impl PpAnn for hir::Crate {\n     fn nested(&self, state: &mut State, nested: Nested) -> io::Result<()> {\n@@ -83,7 +83,7 @@ pub struct State<'a> {\n     literals: Peekable<vec::IntoIter<comments::Literal>>,\n     cur_cmnt: usize,\n     boxes: Vec<pp::Breaks>,\n-    ann: &'a (PpAnn + 'a),\n+    ann: &'a (dyn PpAnn + 'a),\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n@@ -126,9 +126,9 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        sess: &ParseSess,\n                        krate: &hir::Crate,\n                        filename: FileName,\n-                       input: &mut Read,\n-                       out: Box<Write + 'a>,\n-                       ann: &'a PpAnn,\n+                       input: &mut dyn Read,\n+                       out: Box<dyn Write + 'a>,\n+                       ann: &'a dyn PpAnn,\n                        is_expanded: bool)\n                        -> io::Result<()> {\n     let mut s = State::new_from_input(cm, sess, filename, input, out, ann, is_expanded);\n@@ -145,9 +145,9 @@ impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n                           sess: &ParseSess,\n                           filename: FileName,\n-                          input: &mut Read,\n-                          out: Box<Write + 'a>,\n-                          ann: &'a PpAnn,\n+                          input: &mut dyn Read,\n+                          out: Box<dyn Write + 'a>,\n+                          ann: &'a dyn PpAnn,\n                           is_expanded: bool)\n                           -> State<'a> {\n         let (cmnts, lits) = comments::gather_comments_and_literals(sess, filename, input);\n@@ -167,8 +167,8 @@ impl<'a> State<'a> {\n     }\n \n     pub fn new(cm: &'a CodeMap,\n-               out: Box<Write + 'a>,\n-               ann: &'a PpAnn,\n+               out: Box<dyn Write + 'a>,\n+               ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n                literals: Option<Vec<comments::Literal>>)\n                -> State<'a> {\n@@ -184,7 +184,7 @@ impl<'a> State<'a> {\n     }\n }\n \n-pub fn to_string<F>(ann: &PpAnn, f: F) -> String\n+pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n     where F: FnOnce(&mut State) -> io::Result<()>\n {\n     let mut wr = Vec::new();"}, {"sha": "4dcab6a04ee20bdbe814f07d4ea9048cb7512487", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -49,7 +49,7 @@ pub fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n pub struct StableHashingContext<'gcx> {\n     sess: &'gcx Session,\n     definitions: &'gcx Definitions,\n-    cstore: &'gcx CrateStore,\n+    cstore: &'gcx dyn CrateStore,\n     body_resolver: BodyResolver<'gcx>,\n     hash_spans: bool,\n     hash_bodies: bool,\n@@ -88,7 +88,7 @@ impl<'gcx> StableHashingContext<'gcx> {\n     pub fn new(sess: &'gcx Session,\n                krate: &'gcx hir::Crate,\n                definitions: &'gcx Definitions,\n-               cstore: &'gcx CrateStore)\n+               cstore: &'gcx dyn CrateStore)\n                -> Self {\n         let hash_spans_initial = !sess.opts.debugging_opts.incremental_ignore_spans;\n "}, {"sha": "ed89d1d2f57a54150165df2b490910a6e7779883", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -896,7 +896,7 @@ impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n-    fn for_each_region(&self, f: &mut FnMut(ty::Region<'tcx>)) {\n+    fn for_each_region(&self, f: &mut dyn FnMut(ty::Region<'tcx>)) {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) | &VerifyBound::AllRegions(ref rs) => for &r in rs {\n                 f(r);"}, {"sha": "d08a41010ab166ab452ac807e248f1b2479d35bc", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -41,8 +41,6 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n \n-#![cfg_attr(not(stage0), allow(bare_trait_object))]\n-\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]"}, {"sha": "affd02aa51868a3ae6e05b31650e937ce48a7d85", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -280,8 +280,8 @@ pub trait EarlyLintPass: LintPass {\n }\n \n /// A lint pass boxed up as a trait object.\n-pub type EarlyLintPassObject = Box<EarlyLintPass + 'static>;\n-pub type LateLintPassObject = Box<for<'a, 'tcx> LateLintPass<'a, 'tcx> + 'static>;\n+pub type EarlyLintPassObject = Box<dyn EarlyLintPass + 'static>;\n+pub type LateLintPassObject = Box<dyn for<'a, 'tcx> LateLintPass<'a, 'tcx> + 'static>;\n \n /// Identifies a lint known to the compiler.\n #[derive(Clone, Copy, Debug)]"}, {"sha": "bdb5ad525a75c7fa75ba38a6491c739f1845d820", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -225,10 +225,10 @@ pub struct ExternBodyNestedBodies {\n /// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n /// during resolve)\n pub trait CrateStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<Any>;\n+    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<dyn Any>;\n \n     // access to the metadata loader\n-    fn metadata_loader(&self) -> &MetadataLoader;\n+    fn metadata_loader(&self) -> &dyn MetadataLoader;\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey;\n@@ -297,7 +297,7 @@ pub struct DummyCrateStore;\n \n #[allow(unused_variables)]\n impl CrateStore for DummyCrateStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<Any>\n+    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<dyn Any>\n         { bug!(\"crate_data_as_rc_any\") }\n     // item info\n     fn visibility_untracked(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n@@ -351,7 +351,7 @@ impl CrateStore for DummyCrateStore {\n     fn postorder_cnums_untracked(&self) -> Vec<CrateNum> { bug!(\"postorder_cnums_untracked\") }\n \n     // access to the metadata loader\n-    fn metadata_loader(&self) -> &MetadataLoader { bug!(\"metadata_loader\") }\n+    fn metadata_loader(&self) -> &dyn MetadataLoader { bug!(\"metadata_loader\") }\n }\n \n pub trait CrateLoader {"}, {"sha": "e7055827c491fd6eb74f8252e118c07cc566aac2", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -319,7 +319,7 @@ fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyLis\n // also skip this step entirely.\n fn activate_injected_dep(injected: Option<CrateNum>,\n                          list: &mut DependencyList,\n-                         replaces_injected: &Fn(CrateNum) -> bool) {\n+                         replaces_injected: &dyn Fn(CrateNum) -> bool) {\n     for (i, slot) in list.iter().enumerate() {\n         let cnum = CrateNum::new(i + 1);\n         if !replaces_injected(cnum) {"}, {"sha": "28524678e9916bcc8f3bc35e590da1d9d6cfc7b1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -239,7 +239,7 @@ impl OverloadedCallType {\n // This is the code that actually walks the tree.\n pub struct ExprUseVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     mc: mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n-    delegate: &'a mut Delegate<'tcx>,\n+    delegate: &'a mut dyn Delegate<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n@@ -274,7 +274,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n     ///   `None` means that rvalues will be given more conservative lifetimes.\n     ///\n     /// See also `with_infer`, which is used *during* typeck.\n-    pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n+    pub fn new(delegate: &'a mut (dyn Delegate<'tcx>+'a),\n                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                param_env: ty::ParamEnv<'tcx>,\n                region_scope_tree: &'a region::ScopeTree,\n@@ -294,7 +294,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n-    pub fn with_infer(delegate: &'a mut (Delegate<'tcx>+'a),\n+    pub fn with_infer(delegate: &'a mut (dyn Delegate<'tcx>+'a),\n                       infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n                       param_env: ty::ParamEnv<'tcx>,\n                       region_scope_tree: &'a region::ScopeTree,"}, {"sha": "d13b16dce89864f99ce699e5d1a842f213319dd1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -673,7 +673,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn write_vars<F>(&self,\n-                     wr: &mut Write,\n+                     wr: &mut dyn Write,\n                      ln: LiveNode,\n                      mut test: F)\n                      -> io::Result<()> where\n@@ -694,7 +694,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn ln_str(&self, ln: LiveNode) -> String {\n         let mut wr = Vec::new();\n         {\n-            let wr = &mut wr as &mut Write;\n+            let wr = &mut wr as &mut dyn Write;\n             write!(wr, \"[ln({:?}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n             self.write_vars(wr, ln, |idx| self.users[idx].reader);\n             write!(wr, \"  writes\");"}, {"sha": "f9ea544156ce3d661fb0ec8e9a0b012d8df76a9c", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -35,7 +35,7 @@ impl<'tcx> From<EvalErrorKind<'tcx>> for EvalError<'tcx> {\n pub enum EvalErrorKind<'tcx> {\n     /// This variant is used by machines to signal their own errors that do not\n     /// match an existing variant\n-    MachineError(Box<Error>),\n+    MachineError(Box<dyn Error>),\n     FunctionPointerTyMismatch(FnSig<'tcx>, FnSig<'tcx>),\n     NoMirFor(String),\n     UnterminatedCString(MemoryPointer),\n@@ -248,7 +248,7 @@ impl<'tcx> Error for EvalError<'tcx> {\n         }\n     }\n \n-    fn cause(&self) -> Option<&Error> {\n+    fn cause(&self) -> Option<&dyn Error> {\n         use self::EvalErrorKind::*;\n         match self.kind {\n             MachineError(ref inner) => Some(&**inner),"}, {"sha": "157614f847a1242cea3386ceea96d6dd08bf815f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 123, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -341,7 +341,7 @@ macro_rules! hash_option {\n     ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [UNTRACKED]) => ({});\n     ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => ({\n         if $sub_hashes.insert(stringify!($opt_name),\n-                              $opt_expr as &dep_tracking::DepTrackingHash).is_some() {\n+                              $opt_expr as &dyn dep_tracking::DepTrackingHash).is_some() {\n             bug!(\"Duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n         }\n     });\n@@ -420,10 +420,7 @@ top_level_options!(\n         lint_cap: Option<lint::Level> [TRACKED],\n         describe_lints: bool [UNTRACKED],\n         output_types: OutputTypes [TRACKED],\n-        // FIXME(mw): We track this for now but it actually doesn't make too\n-        //            much sense: The search path can stay the same while the\n-        //            things discovered there might have changed on disk.\n-        search_paths: SearchPaths [TRACKED],\n+        search_paths: SearchPaths [UNTRACKED],\n         libs: Vec<(String, Option<String>, Option<cstore::NativeLibraryKind>)> [TRACKED],\n         maybe_sysroot: Option<PathBuf> [TRACKED],\n \n@@ -442,10 +439,7 @@ top_level_options!(\n         // version of `debugging_opts.borrowck`, which is just a plain string.\n         borrowck_mode: BorrowckMode [UNTRACKED],\n         cg: CodegenOptions [TRACKED],\n-        // FIXME(mw): We track this for now but it actually doesn't make too\n-        //            much sense: The value of this option can stay the same\n-        //            while the files they refer to might have changed on disk.\n-        externs: Externs [TRACKED],\n+        externs: Externs [UNTRACKED],\n         crate_name: Option<String> [TRACKED],\n         // An optional name to use as the crate for std during std injection,\n         // written `extern crate std = \"name\"`. Default to \"std\". Used by\n@@ -1456,7 +1450,7 @@ pub enum OptionStability {\n }\n \n pub struct RustcOptGroup {\n-    pub apply: Box<Fn(&mut getopts::Options) -> &mut getopts::Options>,\n+    pub apply: Box<dyn Fn(&mut getopts::Options) -> &mut getopts::Options>,\n     pub name: &'static str,\n     pub stability: OptionStability,\n }\n@@ -2141,13 +2135,12 @@ impl fmt::Display for CrateType {\n mod dep_tracking {\n     use lint;\n     use middle::cstore;\n-    use session::search_paths::{PathKind, SearchPaths};\n     use std::collections::BTreeMap;\n     use std::hash::Hash;\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n     use super::{Passes, CrateType, OptLevel, DebugInfoLevel, Lto,\n-                OutputTypes, Externs, ErrorOutputType, Sanitizer, Epoch};\n+                OutputTypes, ErrorOutputType, Sanitizer, Epoch};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_back::{PanicStrategy, RelroLevel};\n \n@@ -2204,7 +2197,6 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(Lto);\n     impl_dep_tracking_hash_via_hash!(DebugInfoLevel);\n     impl_dep_tracking_hash_via_hash!(UnstableFeatures);\n-    impl_dep_tracking_hash_via_hash!(Externs);\n     impl_dep_tracking_hash_via_hash!(OutputTypes);\n     impl_dep_tracking_hash_via_hash!(cstore::NativeLibraryKind);\n     impl_dep_tracking_hash_via_hash!(Sanitizer);\n@@ -2218,15 +2210,6 @@ mod dep_tracking {\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, Option<String>,\n                                                  Option<cstore::NativeLibraryKind>));\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, u64));\n-    impl DepTrackingHash for SearchPaths {\n-        fn hash(&self, hasher: &mut DefaultHasher, _: ErrorOutputType) {\n-            let mut elems: Vec<_> = self\n-                .iter(PathKind::All)\n-                .collect();\n-            elems.sort();\n-            Hash::hash(&elems, hasher);\n-        }\n-    }\n \n     impl<T1, T2> DepTrackingHash for (T1, T2)\n         where T1: DepTrackingHash,\n@@ -2256,7 +2239,7 @@ mod dep_tracking {\n     }\n \n     // This is a stable hash because BTreeMap is a sorted container\n-    pub fn stable_hash(sub_hashes: BTreeMap<&'static str, &DepTrackingHash>,\n+    pub fn stable_hash(sub_hashes: BTreeMap<&'static str, &dyn DepTrackingHash>,\n                        hasher: &mut DefaultHasher,\n                        error_format: ErrorOutputType) {\n         for (key, sub_hash) in sub_hashes {\n@@ -2413,43 +2396,6 @@ mod tests {\n         assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n     }\n \n-    #[test]\n-    fn test_externs_tracking_hash_different_values() {\n-        let mut v1 = super::basic_options();\n-        let mut v2 = super::basic_options();\n-        let mut v3 = super::basic_options();\n-\n-        v1.externs = Externs::new(mk_map(vec![\n-            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n-                                            String::from(\"c\")])),\n-            (String::from(\"d\"), mk_set(vec![String::from(\"e\"),\n-                                            String::from(\"f\")])),\n-        ]));\n-\n-        v2.externs = Externs::new(mk_map(vec![\n-            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n-                                            String::from(\"c\")])),\n-            (String::from(\"X\"), mk_set(vec![String::from(\"e\"),\n-                                            String::from(\"f\")])),\n-        ]));\n-\n-        v3.externs = Externs::new(mk_map(vec![\n-            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n-                                            String::from(\"c\")])),\n-            (String::from(\"d\"), mk_set(vec![String::from(\"X\"),\n-                                            String::from(\"f\")])),\n-        ]));\n-\n-        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-        assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    }\n-\n     #[test]\n     fn test_externs_tracking_hash_different_construction_order() {\n         let mut v1 = super::basic_options();\n@@ -2540,69 +2486,6 @@ mod tests {\n         assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n     }\n \n-    #[test]\n-    fn test_search_paths_tracking_hash_different_values() {\n-        let mut v1 = super::basic_options();\n-        let mut v2 = super::basic_options();\n-        let mut v3 = super::basic_options();\n-        let mut v4 = super::basic_options();\n-        let mut v5 = super::basic_options();\n-\n-        // Reference\n-        v1.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n-        v1.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n-        v1.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n-        v1.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n-        v1.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n-\n-        // Native changed\n-        v2.search_paths.add_path(\"native=XXX\", super::ErrorOutputType::Json(false));\n-        v2.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n-        v2.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n-        v2.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n-        v2.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n-\n-        // Crate changed\n-        v2.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n-        v2.search_paths.add_path(\"crate=XXX\", super::ErrorOutputType::Json(false));\n-        v2.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n-        v2.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n-        v2.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n-\n-        // Dependency changed\n-        v3.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n-        v3.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n-        v3.search_paths.add_path(\"dependency=XXX\", super::ErrorOutputType::Json(false));\n-        v3.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n-        v3.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n-\n-        // Framework changed\n-        v4.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n-        v4.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n-        v4.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n-        v4.search_paths.add_path(\"framework=XXX\", super::ErrorOutputType::Json(false));\n-        v4.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n-\n-        // All changed\n-        v5.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n-        v5.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n-        v5.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n-        v5.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n-        v5.search_paths.add_path(\"all=XXX\", super::ErrorOutputType::Json(false));\n-\n-        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() != v4.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() != v5.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-        assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n-        assert_eq!(v5.dep_tracking_hash(), v5.clone().dep_tracking_hash());\n-    }\n-\n     #[test]\n     fn test_search_paths_tracking_hash_different_order() {\n         let mut v1 = super::basic_options();"}, {"sha": "bd87a8f918ab37b767817917206466712dcb6df7", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -905,7 +905,7 @@ pub fn build_session_with_codemap(sopts: config::Options,\n                                   local_crate_source_file: Option<PathBuf>,\n                                   registry: errors::registry::Registry,\n                                   codemap: Lrc<codemap::CodeMap>,\n-                                  emitter_dest: Option<Box<Write + Send>>)\n+                                  emitter_dest: Option<Box<dyn Write + Send>>)\n                                   -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n     // normal diagnostic warnings, since the warning lint can also be denied and changed\n@@ -924,7 +924,7 @@ pub fn build_session_with_codemap(sopts: config::Options,\n \n     let external_macro_backtrace = sopts.debugging_opts.external_macro_backtrace;\n \n-    let emitter: Box<Emitter> = match (sopts.error_format, emitter_dest) {\n+    let emitter: Box<dyn Emitter> = match (sopts.error_format, emitter_dest) {\n         (config::ErrorOutputType::HumanReadable(color_config), None) => {\n             Box::new(EmitterWriter::stderr(color_config, Some(codemap.clone()),\n                      false, sopts.debugging_opts.teach)\n@@ -1123,7 +1123,7 @@ pub enum IncrCompSession {\n }\n \n pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n-    let emitter: Box<Emitter> = match output {\n+    let emitter: Box<dyn Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n             Box::new(EmitterWriter::stderr(color_config, None, false, false))\n         }\n@@ -1138,7 +1138,7 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n }\n \n pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n-    let emitter: Box<Emitter> = match output {\n+    let emitter: Box<dyn Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n             Box::new(EmitterWriter::stderr(color_config, None, false, false))\n         }"}, {"sha": "b1d214206069939ee6e103e758b7181560967f6e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -499,7 +499,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                         item_name: ast::Name,\n                                         _impl_item_def_id: DefId,\n                                         trait_item_def_id: DefId,\n-                                        requirement: &fmt::Display)\n+                                        requirement: &dyn fmt::Display)\n                                         -> DiagnosticBuilder<'tcx>\n     {\n         let msg = \"impl has stricter requirements than trait\";"}, {"sha": "dbf15ad17079df2ebf9e85934fd011bbae8ee5a1", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -190,13 +190,13 @@ impl<'a, 'gcx, 'tcx> Children {\n         Ok(Inserted::BecameNewSibling(last_lint))\n     }\n \n-    fn iter_mut(&'a mut self) -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n+    fn iter_mut(&'a mut self) -> Box<dyn Iterator<Item = &'a mut DefId> + 'a> {\n         let nonblanket = self.nonblanket_impls.iter_mut().flat_map(|(_, v)| v.iter_mut());\n         Box::new(self.blanket_impls.iter_mut().chain(nonblanket))\n     }\n \n     fn filtered_mut(&'a mut self, sty: SimplifiedType)\n-                    -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n+                    -> Box<dyn Iterator<Item = &'a mut DefId> + 'a> {\n         let nonblanket = self.nonblanket_impls.entry(sty).or_insert(vec![]).iter_mut();\n         Box::new(self.blanket_impls.iter_mut().chain(nonblanket))\n     }"}, {"sha": "d04c4771017318cda43639e45c5b80c7feeef420", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -799,7 +799,7 @@ pub struct GlobalCtxt<'tcx> {\n     global_arenas: &'tcx GlobalArenas<'tcx>,\n     global_interners: CtxtInterners<'tcx>,\n \n-    cstore: &'tcx CrateStore,\n+    cstore: &'tcx dyn CrateStore,\n \n     pub sess: &'tcx Session,\n \n@@ -883,7 +883,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// This is intended to only get used during the trans phase of the compiler\n     /// when satisfying the query for a particular codegen unit. Internally in\n     /// the query it'll send data along this channel to get processed later.\n-    pub tx_to_llvm_workers: mpsc::Sender<Box<Any + Send>>,\n+    pub tx_to_llvm_workers: mpsc::Sender<Box<dyn Any + Send>>,\n \n     output_filenames: Arc<OutputFilenames>,\n }\n@@ -1131,15 +1131,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n-                                  cstore: &'tcx CrateStore,\n+                                  cstore: &'tcx dyn CrateStore,\n                                   local_providers: ty::maps::Providers<'tcx>,\n                                   extern_providers: ty::maps::Providers<'tcx>,\n                                   arenas: &'tcx AllArenas<'tcx>,\n                                   resolutions: ty::Resolutions,\n                                   hir: hir_map::Map<'tcx>,\n                                   on_disk_query_result_cache: maps::OnDiskCache<'tcx>,\n                                   crate_name: &str,\n-                                  tx: mpsc::Sender<Box<Any + Send>>,\n+                                  tx: mpsc::Sender<Box<dyn Any + Send>>,\n                                   output_filenames: &OutputFilenames,\n                                   f: F) -> R\n                                   where F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'tcx>) -> R\n@@ -1312,7 +1312,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n-    pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Lrc<Any> {\n+    pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Lrc<dyn Any> {\n         self.cstore.crate_data_as_rc_any(cnum)\n     }\n "}, {"sha": "4cc7406af721e8760f56a6d8f8274efb99c17463", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -277,7 +277,7 @@ pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     skipped_regions: &'a mut bool,\n     current_depth: u32,\n-    fld_r: &'a mut (FnMut(ty::Region<'tcx>, u32) -> ty::Region<'tcx> + 'a),\n+    fld_r: &'a mut (dyn FnMut(ty::Region<'tcx>, u32) -> ty::Region<'tcx> + 'a),\n }\n \n impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n-    fld_r: &'a mut (FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n+    fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n     map: BTreeMap<ty::BoundRegion, ty::Region<'tcx>>\n }\n "}, {"sha": "47ad7cbcb56f7087bc02f5a7c2f6a3e54ae585f1", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -419,7 +419,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn calculate_dtor(\n         self,\n         adt_did: DefId,\n-        validate: &mut FnMut(Self, DefId) -> Result<(), ErrorReported>\n+        validate: &mut dyn FnMut(Self, DefId) -> Result<(), ErrorReported>\n     ) -> Option<ty::Destructor> {\n         let drop_trait = if let Some(def_id) = self.lang_items().drop_trait() {\n             def_id"}, {"sha": "bdb120ea59c8a9985d7ce9d91218e3bd04503223", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -38,7 +38,7 @@ pub struct ErrorReported;\n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n \n lazy_static! {\n-    static ref DEFAULT_HOOK: Box<Fn(&panic::PanicInfo) + Sync + Send + 'static> = {\n+    static ref DEFAULT_HOOK: Box<dyn Fn(&panic::PanicInfo) + Sync + Send + 'static> = {\n         let hook = panic::take_hook();\n         panic::set_hook(Box::new(panic_hook));\n         hook"}, {"sha": "b6d8e14b74757eaf73702bce621e6a77fa9c2d31", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -176,7 +176,7 @@ impl<'gcx, 'tcx> UseFinder<'gcx, 'tcx> {\n         None\n     }\n \n-    fn def_use(&self, location: Location, thing: &MirVisitable<'tcx>) -> (bool, bool) {\n+    fn def_use(&self, location: Location, thing: &dyn MirVisitable<'tcx>) -> (bool, bool) {\n         let mut visitor = DefUseVisitor {\n             defined: false,\n             used: false,"}, {"sha": "dbfb8a6d06e63575cbc9d28f03ed4dfcdc5a7894", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -260,10 +260,10 @@ fn dump_annotation<'a, 'gcx, 'tcx>(\n \n fn for_each_region_constraint(\n     closure_region_requirements: &ClosureRegionRequirements,\n-    with_msg: &mut FnMut(&str) -> io::Result<()>,\n+    with_msg: &mut dyn FnMut(&str) -> io::Result<()>,\n ) -> io::Result<()> {\n     for req in &closure_region_requirements.outlives_requirements {\n-        let subject: &Debug = match &req.subject {\n+        let subject: &dyn Debug = match &req.subject {\n             ClosureOutlivesSubject::Region(subject) => subject,\n             ClosureOutlivesSubject::Ty(ty) => ty,\n         };"}, {"sha": "631b1d0f8941dbfa91dbb0f6ab0031b1de3be4de", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -23,7 +23,7 @@ const REGION_WIDTH: usize = 8;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Write out our state into the `.mir` files.\n-    pub(crate) fn dump_mir(&self, out: &mut Write) -> io::Result<()> {\n+    pub(crate) fn dump_mir(&self, out: &mut dyn Write) -> io::Result<()> {\n         writeln!(out, \"| Free Region Mapping\")?;\n \n         for region in self.regions() {\n@@ -67,7 +67,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// inference resulted in the values that it did when debugging.\n     fn for_each_constraint(\n         &self,\n-        with_msg: &mut FnMut(&str) -> io::Result<()>,\n+        with_msg: &mut dyn FnMut(&str) -> io::Result<()>,\n     ) -> io::Result<()> {\n         for region in self.definitions.indices() {\n             let value = self.liveness_constraints.region_value_str(region);"}, {"sha": "db773240809c5d7b99d6cd8c135a2a2ba1fdfee6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -20,7 +20,7 @@ use super::*;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Write out the region constraint graph.\n-    pub(crate) fn dump_graphviz(&self, mut w: &mut Write) -> io::Result<()> {\n+    pub(crate) fn dump_graphviz(&self, mut w: &mut dyn Write) -> io::Result<()> {\n         dot::render(self, &mut w)\n     }\n }"}, {"sha": "a06d39d225c45ccc34076495b2534ac9db756cb4", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -127,7 +127,7 @@ fn type_check_internal<'gcx, 'tcx>(\n     mir: &Mir<'tcx>,\n     region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n-    extra: &mut FnMut(&mut TypeChecker<'_, 'gcx, 'tcx>),\n+    extra: &mut dyn FnMut(&mut TypeChecker<'_, 'gcx, 'tcx>),\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let mut checker = TypeChecker::new(\n         infcx,\n@@ -231,7 +231,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.cx.infcx.tcx\n     }\n \n-    fn sanitize_type(&mut self, parent: &fmt::Debug, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn sanitize_type(&mut self, parent: &dyn fmt::Debug, ty: Ty<'tcx>) -> Ty<'tcx> {\n         if ty.has_escaping_regions() || ty.references_error() {\n             span_mirbug_and_err!(self, parent, \"bad type {:?}\", ty)\n         } else {\n@@ -516,7 +516,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n     fn field_ty(\n         &mut self,\n-        parent: &fmt::Debug,\n+        parent: &dyn fmt::Debug,\n         base_ty: PlaceTy<'tcx>,\n         field: Field,\n         location: Location,\n@@ -1171,7 +1171,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn assert_iscleanup(\n         &mut self,\n         mir: &Mir<'tcx>,\n-        ctxt: &fmt::Debug,\n+        ctxt: &dyn fmt::Debug,\n         bb: BasicBlock,\n         iscleanuppad: bool,\n     ) {"}, {"sha": "aa7bb6f97786c5f66f2cce89b84e491297fd370d", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -61,7 +61,7 @@ pub(crate) struct DataflowBuilder<'a, 'tcx: 'a, BD> where BD: BitDenotation\n pub(crate) struct DebugFormatted(String);\n \n impl DebugFormatted {\n-    pub fn new(input: &fmt::Debug) -> DebugFormatted {\n+    pub fn new(input: &dyn fmt::Debug) -> DebugFormatted {\n         DebugFormatted(format!(\"{:?}\", input))\n     }\n }"}, {"sha": "bc555368f0f5fb95d460470537010de9ebf43c1e", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -168,7 +168,7 @@ impl Error for ConstEvalError {\n         }\n     }\n \n-    fn cause(&self) -> Option<&Error> {\n+    fn cause(&self) -> Option<&dyn Error> {\n         None\n     }\n }"}, {"sha": "8c15d1cf8b03afc7efabe3bb149d70e11b8e51f5", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -15,7 +15,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n */\n \n #![deny(warnings)]\n-#![cfg_attr(not(stage0), allow(bare_trait_object))]\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "a16ef2adea9be8f6c922eb1c938e983603b65860", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -49,7 +49,7 @@ impl fmt::Display for Disambiguator {\n \n \n pub fn on_mir_pass<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             pass_num: &fmt::Display,\n+                             pass_num: &dyn fmt::Display,\n                              pass_name: &str,\n                              source: MirSource,\n                              mir: &Mir<'tcx>,"}, {"sha": "9d1f76313759b6d22b1657d6c7ee476ee893e3e8", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -161,7 +161,7 @@ pub macro run_passes($tcx:ident, $mir:ident, $def_id:ident, $suite_index:expr; $\n             promoted\n         };\n         let mut index = 0;\n-        let mut run_pass = |pass: &MirPass| {\n+        let mut run_pass = |pass: &dyn MirPass| {\n             let run_hooks = |mir: &_, index, is_after| {\n                 dump_mir::on_mir_pass($tcx, &format_args!(\"{:03}-{:03}\", suite_index, index),\n                                       &pass.name(), source, mir, is_after);"}, {"sha": "42ddabddd2dcd8e5dcec6d311fd8d339b578dbed", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -425,12 +425,12 @@ pub fn write_mir_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     src: MirSource,\n     mir: &Mir<'tcx>,\n-    w: &mut Write,\n+    w: &mut dyn Write,\n     result: &LivenessResult,\n ) -> io::Result<()> {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n-        let print = |w: &mut Write, prefix, result: &IndexVec<BasicBlock, LocalSet>| {\n+        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LocalSet>| {\n             let live: Vec<String> = mir.local_decls\n                 .indices()\n                 .filter(|i| result[block].contains(i))"}, {"sha": "4509cace794d4836eee91aa18e4e9f33b2c5a98b", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -72,14 +72,14 @@ pub enum PassWhere {\n ///   or `typeck` and `bar` both appear in the name.\n pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    pass_num: Option<&Display>,\n+    pass_num: Option<&dyn Display>,\n     pass_name: &str,\n-    disambiguator: &Display,\n+    disambiguator: &dyn Display,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     extra_data: F,\n ) where\n-    F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n+    F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n@@ -127,15 +127,15 @@ pub fn dump_enabled<'a, 'gcx, 'tcx>(\n \n fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    pass_num: Option<&Display>,\n+    pass_num: Option<&dyn Display>,\n     pass_name: &str,\n     node_path: &str,\n-    disambiguator: &Display,\n+    disambiguator: &dyn Display,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     mut extra_data: F,\n ) where\n-    F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n+    F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n     let _: io::Result<()> = do catch {\n         let mut file = create_dump_file(tcx, \"mir\", pass_num, pass_name, disambiguator, source)?;\n@@ -169,9 +169,9 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n fn dump_path(\n     tcx: TyCtxt<'_, '_, '_>,\n     extension: &str,\n-    pass_num: Option<&Display>,\n+    pass_num: Option<&dyn Display>,\n     pass_name: &str,\n-    disambiguator: &Display,\n+    disambiguator: &dyn Display,\n     source: MirSource,\n ) -> PathBuf {\n     let promotion_id = match source.promoted {\n@@ -217,9 +217,9 @@ fn dump_path(\n pub(crate) fn create_dump_file(\n     tcx: TyCtxt<'_, '_, '_>,\n     extension: &str,\n-    pass_num: Option<&Display>,\n+    pass_num: Option<&dyn Display>,\n     pass_name: &str,\n-    disambiguator: &Display,\n+    disambiguator: &dyn Display,\n     source: MirSource,\n ) -> io::Result<fs::File> {\n     let file_path = dump_path(tcx, extension, pass_num, pass_name, disambiguator, source);\n@@ -233,7 +233,7 @@ pub(crate) fn create_dump_file(\n pub fn write_mir_pretty<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     single: Option<DefId>,\n-    w: &mut Write,\n+    w: &mut dyn Write,\n ) -> io::Result<()> {\n     writeln!(\n         w,\n@@ -274,10 +274,10 @@ pub fn write_mir_fn<'a, 'gcx, 'tcx, F>(\n     src: MirSource,\n     mir: &Mir<'tcx>,\n     extra_data: &mut F,\n-    w: &mut Write,\n+    w: &mut dyn Write,\n ) -> io::Result<()>\n where\n-    F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n+    F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n@@ -298,10 +298,10 @@ pub fn write_basic_block<'cx, 'gcx, 'tcx, F>(\n     block: BasicBlock,\n     mir: &Mir<'tcx>,\n     extra_data: &mut F,\n-    w: &mut Write,\n+    w: &mut dyn Write,\n ) -> io::Result<()>\n where\n-    F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n+    F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n     let data = &mir[block];\n \n@@ -362,7 +362,7 @@ where\n /// a statement.\n fn write_extra<'cx, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    write: &mut Write,\n+    write: &mut dyn Write,\n     mut visit_op: F,\n ) -> io::Result<()>\n where\n@@ -450,7 +450,7 @@ fn write_scope_tree(\n     tcx: TyCtxt,\n     mir: &Mir,\n     scope_tree: &FxHashMap<VisibilityScope, Vec<VisibilityScope>>,\n-    w: &mut Write,\n+    w: &mut dyn Write,\n     parent: VisibilityScope,\n     depth: usize,\n ) -> io::Result<()> {\n@@ -515,7 +515,7 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     src: MirSource,\n     mir: &Mir,\n-    w: &mut Write,\n+    w: &mut dyn Write,\n ) -> io::Result<()> {\n     write_mir_sig(tcx, src, mir, w)?;\n     writeln!(w, \"{{\")?;\n@@ -553,7 +553,7 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n     Ok(())\n }\n \n-fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write) -> io::Result<()> {\n+fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut dyn Write) -> io::Result<()> {\n     let id = tcx.hir.as_local_node_id(src.def_id).unwrap();\n     let body_owner_kind = tcx.hir.body_owner_kind(id);\n     match (body_owner_kind, src.promoted) {\n@@ -597,7 +597,7 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write) -> io::R\n     Ok(())\n }\n \n-fn write_temp_decls(mir: &Mir, w: &mut Write) -> io::Result<()> {\n+fn write_temp_decls(mir: &Mir, w: &mut dyn Write) -> io::Result<()> {\n     // Compiler-introduced temporary types.\n     for temp in mir.temps_iter() {\n         writeln!("}, {"sha": "e28ccdb766ae5d634666a4f031e553cbdbfb99b8", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -259,8 +259,8 @@ impl TcpStream {\n     /// Sets the read timeout to the timeout specified.\n     ///\n     /// If the value specified is [`None`], then [`read`] calls will block\n-    /// indefinitely. It is an error to pass the zero `Duration` to this\n-    /// method.\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n     ///\n     /// # Platform-specific behavior\n     ///\n@@ -269,9 +269,11 @@ impl TcpStream {\n     /// error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     /// [`read`]: ../../std/io/trait.Read.html#tymethod.read\n     /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n     /// [`TimedOut`]: ../../std/io/enum.ErrorKind.html#variant.TimedOut\n+    /// [`Duration`]: ../../std/time/struct.Duration.html\n     ///\n     /// # Examples\n     ///\n@@ -282,6 +284,20 @@ impl TcpStream {\n     ///                        .expect(\"Couldn't connect to the server...\");\n     /// stream.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::TcpStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n+    /// let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_read_timeout(dur)\n@@ -290,8 +306,8 @@ impl TcpStream {\n     /// Sets the write timeout to the timeout specified.\n     ///\n     /// If the value specified is [`None`], then [`write`] calls will block\n-    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n-    /// method.\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n     ///\n     /// # Platform-specific behavior\n     ///\n@@ -300,6 +316,7 @@ impl TcpStream {\n     /// an error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     /// [`write`]: ../../std/io/trait.Write.html#tymethod.write\n     /// [`Duration`]: ../../std/time/struct.Duration.html\n     /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n@@ -314,6 +331,20 @@ impl TcpStream {\n     ///                        .expect(\"Couldn't connect to the server...\");\n     /// stream.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::TcpStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n+    /// let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_write_timeout(dur)"}, {"sha": "8e56954bea439f3950935cb657769486ddfdeaa7", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -228,8 +228,8 @@ impl UdpSocket {\n     /// Sets the read timeout to the timeout specified.\n     ///\n     /// If the value specified is [`None`], then [`read`] calls will block\n-    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n-    /// method.\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n     ///\n     /// # Platform-specific behavior\n     ///\n@@ -238,6 +238,7 @@ impl UdpSocket {\n     /// error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     /// [`read`]: ../../std/io/trait.Read.html#tymethod.read\n     /// [`Duration`]: ../../std/time/struct.Duration.html\n     /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n@@ -251,6 +252,20 @@ impl UdpSocket {\n     /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n     /// socket.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::UdpSocket;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n+    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_read_timeout(dur)\n@@ -259,8 +274,8 @@ impl UdpSocket {\n     /// Sets the write timeout to the timeout specified.\n     ///\n     /// If the value specified is [`None`], then [`write`] calls will block\n-    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n-    /// method.\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n     ///\n     /// # Platform-specific behavior\n     ///\n@@ -269,6 +284,7 @@ impl UdpSocket {\n     /// an error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     /// [`write`]: ../../std/io/trait.Write.html#tymethod.write\n     /// [`Duration`]: ../../std/time/struct.Duration.html\n     /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n@@ -282,6 +298,20 @@ impl UdpSocket {\n     /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n     /// socket.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::UdpSocket;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n+    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_write_timeout(dur)"}, {"sha": "ad437658d144a53ef35bb95af6acba7a88d31879", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -387,10 +387,11 @@ impl UnixStream {\n     /// Sets the read timeout for the socket.\n     ///\n     /// If the provided value is [`None`], then [`read`] calls will block\n-    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n     /// method.\n     ///\n     /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n     /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n     /// [`Duration`]: ../../../../std/time/struct.Duration.html\n     ///\n@@ -403,6 +404,20 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n@@ -411,10 +426,11 @@ impl UnixStream {\n     /// Sets the write timeout for the socket.\n     ///\n     /// If the provided value is [`None`], then [`write`] calls will block\n-    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n-    /// method.\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n     ///\n     /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n     /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n     /// [`Duration`]: ../../../../std/time/struct.Duration.html\n     ///\n@@ -427,6 +443,20 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::UdpSocket;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n+    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n@@ -1250,10 +1280,11 @@ impl UnixDatagram {\n     /// Sets the read timeout for the socket.\n     ///\n     /// If the provided value is [`None`], then [`recv`] and [`recv_from`] calls will\n-    /// block indefinitely. It is an error to pass the zero [`Duration`] to this\n-    /// method.\n+    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`]\n+    /// is passed to this method.\n     ///\n     /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n     /// [`recv`]: #method.recv\n     /// [`recv_from`]: #method.recv_from\n     /// [`Duration`]: ../../../../std/time/struct.Duration.html\n@@ -1267,6 +1298,20 @@ impl UnixDatagram {\n     /// let sock = UnixDatagram::unbound().unwrap();\n     /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n@@ -1275,7 +1320,7 @@ impl UnixDatagram {\n     /// Sets the write timeout for the socket.\n     ///\n     /// If the provided value is [`None`], then [`send`] and [`send_to`] calls will\n-    /// block indefinitely. It is an error to pass the zero [`Duration`] to this\n+    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n     /// method.\n     ///\n     /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n@@ -1293,6 +1338,20 @@ impl UnixDatagram {\n     /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n     ///     .expect(\"set_write_timeout function failed\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_SNDTIMEO)"}, {"sha": "92584f5b51946151c4ebb36ffc2510b9b1d462a3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 121, "deletions": 31, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -652,9 +652,11 @@ impl<'a> Parser<'a> {\n             } else {\n                 let token_str = Parser::token_to_string(t);\n                 let this_token_str = self.this_token_to_string();\n-                Err(self.fatal(&format!(\"expected `{}`, found `{}`\",\n-                                   token_str,\n-                                   this_token_str)))\n+                let mut err = self.fatal(&format!(\"expected `{}`, found `{}`\",\n+                                                  token_str,\n+                                                  this_token_str));\n+                err.span_label(self.span, format!(\"expected `{}`\", token_str));\n+                Err(err)\n             }\n         } else {\n             self.expect_one_of(unsafe { slice::from_raw_parts(t, 1) }, &[])\n@@ -1172,7 +1174,7 @@ impl<'a> Parser<'a> {\n                                      sep: SeqSep,\n                                      f: F)\n                                      -> PResult<'a, Vec<T>> where\n-        F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+        F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     {\n         self.expect(bra)?;\n         let result = self.parse_seq_to_before_end(ket, sep, f)?;\n@@ -1190,7 +1192,7 @@ impl<'a> Parser<'a> {\n                            sep: SeqSep,\n                            f: F)\n                            -> PResult<'a, Spanned<Vec<T>>> where\n-        F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+        F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     {\n         let lo = self.span;\n         self.expect(bra)?;\n@@ -1485,7 +1487,10 @@ impl<'a> Parser<'a> {\n                 }\n                 _ => {\n                     let token_str = self.this_token_to_string();\n-                    return Err(self.fatal(&format!(\"expected `;` or `{{`, found `{}`\", token_str)));\n+                    let mut err = self.fatal(&format!(\"expected `;` or `{{`, found `{}`\",\n+                                                      token_str));\n+                    err.span_label(self.span, \"expected `;` or `{`\");\n+                    return Err(err);\n                 }\n             };\n             (ident, ast::TraitItemKind::Method(sig, body), generics)\n@@ -2216,7 +2221,12 @@ impl<'a> Parser<'a> {\n                 TokenTree::Delimited(_, delimited) => Ok((delim, delimited.stream().into())),\n                 _ => unreachable!(),\n             },\n-            _ => Err(self.fatal(\"expected open delimiter\")),\n+            _ => {\n+                let msg = \"expected open delimiter\";\n+                let mut err = self.fatal(msg);\n+                err.span_label(self.span, msg);\n+                Err(err)\n+            }\n         }\n     }\n \n@@ -2349,7 +2359,10 @@ impl<'a> Parser<'a> {\n                     if self.eat_keyword(keywords::Loop) {\n                         return self.parse_loop_expr(Some(label), lo, attrs)\n                     }\n-                    return Err(self.fatal(\"expected `while`, `for`, or `loop` after a label\"))\n+                    let msg = \"expected `while`, `for`, or `loop` after a label\";\n+                    let mut err = self.fatal(msg);\n+                    err.span_label(self.span, msg);\n+                    return Err(err);\n                 }\n                 if self.eat_keyword(keywords::Loop) {\n                     let lo = self.prev_span;\n@@ -2408,6 +2421,7 @@ impl<'a> Parser<'a> {\n                     // Catch this syntax error here, instead of in `parse_ident`, so\n                     // that we can explicitly mention that let is not to be used as an expression\n                     let mut db = self.fatal(\"expected expression, found statement (`let`)\");\n+                    db.span_label(self.span, \"expected expression\");\n                     db.note(\"variable declaration using `let` is a statement\");\n                     return Err(db);\n                 } else if self.token.is_path_start() {\n@@ -2443,7 +2457,9 @@ impl<'a> Parser<'a> {\n                             self.cancel(&mut err);\n                             let msg = format!(\"expected expression, found {}\",\n                                               self.this_token_descr());\n-                            return Err(self.fatal(&msg));\n+                            let mut err = self.fatal(&msg);\n+                            err.span_label(self.span, \"expected expression\");\n+                            return Err(err);\n                         }\n                     }\n                 }\n@@ -2733,7 +2749,9 @@ impl<'a> Parser<'a> {\n                              self.look_ahead(1, |t| t.is_ident()) => {\n                 self.bump();\n                 let name = match self.token { token::Ident(ident) => ident, _ => unreachable!() };\n-                self.fatal(&format!(\"unknown macro variable `{}`\", name)).emit();\n+                let mut err = self.fatal(&format!(\"unknown macro variable `{}`\", name));\n+                err.span_label(self.span, \"unknown macro variable\");\n+                err.emit();\n                 return\n             }\n             token::Interpolated(ref nt) => {\n@@ -3212,7 +3230,13 @@ impl<'a> Parser<'a> {\n             err.span_label(sp, \"expected if condition here\");\n             return Err(err)\n         }\n-        let thn = self.parse_block()?;\n+        let not_block = self.token != token::OpenDelim(token::Brace);\n+        let thn = self.parse_block().map_err(|mut err| {\n+            if not_block {\n+                err.span_label(lo, \"this `if` statement has a condition, but no block\");\n+            }\n+            err\n+        })?;\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span;\n         if self.eat_keyword(keywords::Else) {\n@@ -3404,14 +3428,52 @@ impl<'a> Parser<'a> {\n         } else {\n             None\n         };\n+        let arrow_span = self.span;\n         self.expect(&token::FatArrow)?;\n-        let expr = self.parse_expr_res(Restrictions::STMT_EXPR, None)?;\n+        let arm_start_span = self.span;\n+\n+        let expr = self.parse_expr_res(Restrictions::STMT_EXPR, None)\n+            .map_err(|mut err| {\n+                err.span_label(arrow_span, \"while parsing the `match` arm starting here\");\n+                err\n+            })?;\n \n         let require_comma = classify::expr_requires_semi_to_be_stmt(&expr)\n             && self.token != token::CloseDelim(token::Brace);\n \n         if require_comma {\n-            self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)])?;\n+            let cm = self.sess.codemap();\n+            self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)])\n+                .map_err(|mut err| {\n+                    match (cm.span_to_lines(expr.span), cm.span_to_lines(arm_start_span)) {\n+                        (Ok(ref expr_lines), Ok(ref arm_start_lines))\n+                        if arm_start_lines.lines[0].end_col == expr_lines.lines[0].end_col\n+                            && expr_lines.lines.len() == 2\n+                            && self.token == token::FatArrow => {\n+                            // We check wether there's any trailing code in the parse span, if there\n+                            // isn't, we very likely have the following:\n+                            //\n+                            // X |     &Y => \"y\"\n+                            //   |        --    - missing comma\n+                            //   |        |\n+                            //   |        arrow_span\n+                            // X |     &X => \"x\"\n+                            //   |      - ^^ self.span\n+                            //   |      |\n+                            //   |      parsed until here as `\"y\" & X`\n+                            err.span_suggestion_short(\n+                                cm.next_point(arm_start_span),\n+                                \"missing a comma here to end this `match` arm\",\n+                                \",\".to_owned()\n+                            );\n+                        }\n+                        _ => {\n+                            err.span_label(arrow_span,\n+                                           \"while parsing the `match` arm starting here\");\n+                        }\n+                    }\n+                    err\n+                })?;\n         } else {\n             self.eat(&token::Comma);\n         }\n@@ -3609,8 +3671,9 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 if self.token != token::CloseDelim(token::Brace) {\n                     let token_str = self.this_token_to_string();\n-                    return Err(self.fatal(&format!(\"expected `{}`, found `{}`\", \"}\",\n-                                       token_str)))\n+                    let mut err = self.fatal(&format!(\"expected `{}`, found `{}`\", \"}\", token_str));\n+                    err.span_label(self.span, \"expected `}`\");\n+                    return Err(err);\n                 }\n                 etc = true;\n                 break;\n@@ -3721,7 +3784,10 @@ impl<'a> Parser<'a> {\n                 self.expect_and()?;\n                 let mutbl = self.parse_mutability();\n                 if let token::Lifetime(ident) = self.token {\n-                    return Err(self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", ident)));\n+                    let mut err = self.fatal(&format!(\"unexpected lifetime `{}` in pattern\",\n+                                                      ident));\n+                    err.span_label(self.span, \"unexpected lifetime\");\n+                    return Err(err);\n                 }\n                 let subpat = self.parse_pat()?;\n                 pat = PatKind::Ref(subpat, mutbl);\n@@ -3806,7 +3872,10 @@ impl<'a> Parser<'a> {\n                     }\n                     token::OpenDelim(token::Brace) => {\n                         if qself.is_some() {\n-                            return Err(self.fatal(\"unexpected `{` after qualified path\"));\n+                            let msg = \"unexpected `{` after qualified path\";\n+                            let mut err = self.fatal(msg);\n+                            err.span_label(self.span, msg);\n+                            return Err(err);\n                         }\n                         // Parse struct pattern\n                         self.bump();\n@@ -3820,7 +3889,10 @@ impl<'a> Parser<'a> {\n                     }\n                     token::OpenDelim(token::Paren) => {\n                         if qself.is_some() {\n-                            return Err(self.fatal(\"unexpected `(` after qualified path\"));\n+                            let msg = \"unexpected `(` after qualified path\";\n+                            let mut err = self.fatal(msg);\n+                            err.span_label(self.span, msg);\n+                            return Err(err);\n                         }\n                         // Parse tuple struct or enum pattern\n                         let (fields, ddpos, _) = self.parse_parenthesized_pat_list()?;\n@@ -3850,7 +3922,9 @@ impl<'a> Parser<'a> {\n                     Err(mut err) => {\n                         self.cancel(&mut err);\n                         let msg = format!(\"expected pattern, found {}\", self.this_token_descr());\n-                        return Err(self.fatal(&msg));\n+                        let mut err = self.fatal(&msg);\n+                        err.span_label(self.span, \"expected pattern\");\n+                        return Err(err);\n                     }\n                 }\n             }\n@@ -4250,9 +4324,11 @@ impl<'a> Parser<'a> {\n                         \"\"\n                     };\n                     let tok_str = self.this_token_to_string();\n-                    return Err(self.fatal(&format!(\"expected {}`(` or `{{`, found `{}`\",\n-                                       ident_str,\n-                                       tok_str)))\n+                    let mut err = self.fatal(&format!(\"expected {}`(` or `{{`, found `{}`\",\n+                                                      ident_str,\n+                                                      tok_str));\n+                    err.span_label(self.span, format!(\"expected {}`(` or `{{`\", ident_str));\n+                    return Err(err)\n                 },\n             };\n \n@@ -5559,8 +5635,12 @@ impl<'a> Parser<'a> {\n             body\n         } else {\n             let token_str = self.this_token_to_string();\n-            return Err(self.fatal(&format!(\"expected `where`, `{{`, `(`, or `;` after struct \\\n-                                            name, found `{}`\", token_str)))\n+            let mut err = self.fatal(&format!(\n+                \"expected `where`, `{{`, `(`, or `;` after struct name, found `{}`\",\n+                token_str\n+            ));\n+            err.span_label(self.span, \"expected `where`, `{`, `(`, or `;` after struct name\");\n+            return Err(err);\n         };\n \n         Ok((class_name, ItemKind::Struct(vdata, generics), None))\n@@ -5579,8 +5659,10 @@ impl<'a> Parser<'a> {\n             VariantData::Struct(self.parse_record_struct_body()?, ast::DUMMY_NODE_ID)\n         } else {\n             let token_str = self.this_token_to_string();\n-            return Err(self.fatal(&format!(\"expected `where` or `{{` after union \\\n-                                            name, found `{}`\", token_str)))\n+            let mut err = self.fatal(&format!(\n+                \"expected `where` or `{{` after union name, found `{}`\", token_str));\n+            err.span_label(self.span, \"expected `where` or `{` after union name\");\n+            return Err(err);\n         };\n \n         Ok((class_name, ItemKind::Union(vdata, generics), None))\n@@ -5627,9 +5709,10 @@ impl<'a> Parser<'a> {\n             self.eat(&token::CloseDelim(token::Brace));\n         } else {\n             let token_str = self.this_token_to_string();\n-            return Err(self.fatal(&format!(\"expected `where`, or `{{` after struct \\\n-                                name, found `{}`\",\n-                                token_str)));\n+            let mut err = self.fatal(&format!(\n+                    \"expected `where`, or `{{` after struct name, found `{}`\", token_str));\n+            err.span_label(self.span, \"expected `where`, or `{` after struct name\");\n+            return Err(err);\n         }\n \n         Ok(fields)\n@@ -5802,9 +5885,11 @@ impl<'a> Parser<'a> {\n         if !self.eat(term) {\n             let token_str = self.this_token_to_string();\n             let mut err = self.fatal(&format!(\"expected item, found `{}`\", token_str));\n-            let msg = \"consider removing this semicolon\";\n             if token_str == \";\" {\n+                let msg = \"consider removing this semicolon\";\n                 err.span_suggestion_short(self.span, msg, \"\".to_string());\n+            } else {\n+                err.span_label(self.span, \"expected item\");\n             }\n             return Err(err);\n         }\n@@ -6961,7 +7046,12 @@ impl<'a> Parser<'a> {\n                 self.expect_no_suffix(sp, \"string literal\", suf);\n                 Ok((s, style))\n             }\n-            _ =>  Err(self.fatal(\"expected string literal\"))\n+            _ => {\n+                let msg = \"expected string literal\";\n+                let mut err = self.fatal(msg);\n+                err.span_label(self.span, msg);\n+                Err(err)\n+            }\n         }\n     }\n }"}, {"sha": "629e618505129fb85c40d59eaf612dc0c5827e96", "filename": "src/test/run-make/reproducible-build/Makefile", "status": "modified", "additions": 67, "deletions": 9, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Frun-make%2Freproducible-build%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Frun-make%2Freproducible-build%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Freproducible-build%2FMakefile?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -1,20 +1,78 @@\n -include ../tools.mk\n-all:\n+all:  \\\n+\tsmoke \\\n+\tdebug \\\n+\topt \\\n+\tlink_paths \\\n+\tremap_paths \\\n+\tdifferent_source_dirs \\\n+\textern_flags\n+\n+smoke:\n+\trm -rf $(TMPDIR) && mkdir $(TMPDIR)\n \t$(RUSTC) reproducible-build-aux.rs\n \t$(RUSTC) reproducible-build.rs -o\"$(TMPDIR)/reproducible-build1\"\n \t$(RUSTC) reproducible-build.rs -o\"$(TMPDIR)/reproducible-build2\"\n+\t$(B2)\n \tnm \"$(TMPDIR)/reproducible-build1\" | sort > \"$(TMPDIR)/reproducible-build1.nm\"\n \tnm \"$(TMPDIR)/reproducible-build2\" | sort > \"$(TMPDIR)/reproducible-build2.nm\"\n \tcmp \"$(TMPDIR)/reproducible-build1.nm\" \"$(TMPDIR)/reproducible-build2.nm\" || exit 1\n+\n+debug:\n+\trm -rf $(TMPDIR) && mkdir $(TMPDIR)\n \t$(RUSTC) reproducible-build-aux.rs -g\n-\t$(RUSTC) reproducible-build.rs -g -o\"$(TMPDIR)/reproducible-build1-debug\"\n-\t$(RUSTC) reproducible-build.rs -g -o\"$(TMPDIR)/reproducible-build2-debug\"\n-\tnm \"$(TMPDIR)/reproducible-build1-debug\" | sort > \"$(TMPDIR)/reproducible-build1-debug.nm\"\n-\tnm \"$(TMPDIR)/reproducible-build2-debug\" | sort > \"$(TMPDIR)/reproducible-build2-debug.nm\"\n+\t$(RUSTC) reproducible-build.rs -o\"$(TMPDIR)/reproducible-build1\" -g\n+\t$(RUSTC) reproducible-build.rs -o\"$(TMPDIR)/reproducible-build2\" -g\n+\tnm \"$(TMPDIR)/reproducible-build1\" | sort > \"$(TMPDIR)/reproducible-build1-debug.nm\"\n+\tnm \"$(TMPDIR)/reproducible-build2\" | sort > \"$(TMPDIR)/reproducible-build2-debug.nm\"\n \tcmp \"$(TMPDIR)/reproducible-build1-debug.nm\" \"$(TMPDIR)/reproducible-build2-debug.nm\" || exit 1\n+\n+opt:\n+\trm -rf $(TMPDIR) && mkdir $(TMPDIR)\n \t$(RUSTC) reproducible-build-aux.rs -O\n-\t$(RUSTC) reproducible-build.rs -O -o\"$(TMPDIR)/reproducible-build1-opt\"\n-\t$(RUSTC) reproducible-build.rs -O -o\"$(TMPDIR)/reproducible-build2-opt\"\n-\tnm \"$(TMPDIR)/reproducible-build1-opt\" | sort > \"$(TMPDIR)/reproducible-build1-opt.nm\"\n-\tnm \"$(TMPDIR)/reproducible-build2-opt\" | sort > \"$(TMPDIR)/reproducible-build2-opt.nm\"\n+\t$(RUSTC) reproducible-build.rs -o\"$(TMPDIR)/reproducible-build1\" -O\n+\t$(RUSTC) reproducible-build.rs -o\"$(TMPDIR)/reproducible-build2\" -O\n+\tnm \"$(TMPDIR)/reproducible-build1\" | sort > \"$(TMPDIR)/reproducible-build1-opt.nm\"\n+\tnm \"$(TMPDIR)/reproducible-build2\" | sort > \"$(TMPDIR)/reproducible-build2-opt.nm\"\n \tcmp \"$(TMPDIR)/reproducible-build1-opt.nm\" \"$(TMPDIR)/reproducible-build2-opt.nm\" || exit 1\n+\n+link_paths:\n+\trm -rf $(TMPDIR) && mkdir $(TMPDIR)\n+\t$(RUSTC) reproducible-build-aux.rs\n+\t$(RUSTC) reproducible-build.rs --crate-type rlib -L /b\n+\tcp $(TMPDIR)/libreproducible_build.rlib $(TMPDIR)/libfoo.rlib\n+\t$(RUSTC) reproducible-build.rs --crate-type rlib -L /a\n+\tcmp \"$(TMPDIR)/libreproducible_build.rlib\" \"$(TMPDIR)/libfoo.rlib\" || exit 1\n+\n+remap_paths:\n+\trm -rf $(TMPDIR) && mkdir $(TMPDIR)\n+\t$(RUSTC) reproducible-build-aux.rs\n+\t$(RUSTC) reproducible-build.rs --crate-type rlib --remap-path-prefix=/a=/c\n+\tcp $(TMPDIR)/libreproducible_build.rlib $(TMPDIR)/libfoo.rlib\n+\t$(RUSTC) reproducible-build.rs --crate-type rlib --remap-path-prefix=/b=/c\n+\tcmp \"$(TMPDIR)/libreproducible_build.rlib\" \"$(TMPDIR)/libfoo.rlib\" || exit 1\n+\n+different_source_dirs:\n+\trm -rf $(TMPDIR) && mkdir $(TMPDIR)\n+\t$(RUSTC) reproducible-build-aux.rs\n+\tmkdir $(TMPDIR)/test\n+\tcp reproducible-build.rs $(TMPDIR)/test\n+\t$(RUSTC) reproducible-build.rs --crate-type rlib --remap-path-prefix=$$PWD=/b\n+\tcp $(TMPDIR)/libreproducible_build.rlib $(TMPDIR)/libfoo.rlib\n+\t(cd $(TMPDIR)/test && $(RUSTC) reproducible-build.rs \\\n+\t\t--remap-path-prefix=$(TMPDIR)/test=/b \\\n+\t\t--crate-type rlib)\n+\tcmp \"$(TMPDIR)/libreproducible_build.rlib\" \"$(TMPDIR)/libfoo.rlib\" || exit 1\n+\n+extern_flags:\n+\trm -rf $(TMPDIR) && mkdir $(TMPDIR)\n+\t$(RUSTC) reproducible-build-aux.rs\n+\t$(RUSTC) reproducible-build.rs \\\n+\t\t--extern reproducible_build_aux=$(TMPDIR)/libreproducible_build_aux.rlib \\\n+\t\t--crate-type rlib\n+\tcp $(TMPDIR)/libreproducible_build_aux.rlib $(TMPDIR)/libbar.rlib\n+\tcp $(TMPDIR)/libreproducible_build.rlib $(TMPDIR)/libfoo.rlib\n+\t$(RUSTC) reproducible-build.rs \\\n+\t\t--extern reproducible_build_aux=$(TMPDIR)/libbar.rlib \\\n+\t\t--crate-type rlib\n+\tcmp \"$(TMPDIR)/libreproducible_build.rlib\" \"$(TMPDIR)/libfoo.rlib\" || exit 1"}, {"sha": "a040c0f858d78d85a566c3c2d03a749240fd4023", "filename": "src/test/run-make/reproducible-build/reproducible-build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Frun-make%2Freproducible-build%2Freproducible-build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Frun-make%2Freproducible-build%2Freproducible-build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Freproducible-build%2Freproducible-build.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -28,7 +28,7 @@\n // - Trait object shims\n // - Fn Pointer shims\n \n-#![allow(dead_code)]\n+#![allow(dead_code, warnings)]\n \n extern crate reproducible_build_aux;\n "}, {"sha": "a9db5214e6a2eabdc1c8a326373890bb6ef662f1", "filename": "src/test/ui/cross-file-errors/main.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fcross-file-errors%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fcross-file-errors%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross-file-errors%2Fmain.stderr?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -2,7 +2,7 @@ error: expected expression, found `_`\n   --> $DIR/underscore.rs:18:9\n    |\n LL |         _\n-   |         ^\n+   |         ^ expected expression\n    | \n   ::: $DIR/main.rs:15:5\n    |"}, {"sha": "e576393500fea734315dbed1f9a1a314a4896b3d", "filename": "src/test/ui/did_you_mean/issue-40006.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -19,7 +19,7 @@ error: expected `[`, found `#`\n   --> $DIR/issue-40006.rs:20:17\n    |\n LL |     fn xxx() { ### } //~ ERROR missing\n-   |                 ^\n+   |                 ^ expected `[`\n \n error: missing `fn`, `type`, or `const` for trait-item declaration\n   --> $DIR/issue-40006.rs:20:21"}, {"sha": "ce3de3b302dd3678e52d41dec61fddeb660cb66c", "filename": "src/test/ui/if-without-block.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fif-without-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fif-without-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-without-block.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let n = 1;\n+    if 5 == {\n+    //~^ NOTE this `if` statement has a condition, but no block\n+        println!(\"five\");\n+    }\n+}\n+//~^ ERROR expected `{`, found `}`"}, {"sha": "bc8e7310ce37198eed4f852a03ef3ede5d01c3dc", "filename": "src/test/ui/if-without-block.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fif-without-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fif-without-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-without-block.stderr?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -0,0 +1,11 @@\n+error: expected `{`, found `}`\n+  --> $DIR/if-without-block.rs:17:1\n+   |\n+LL |     if 5 == {\n+   |     -- this `if` statement has a condition, but no block\n+...\n+LL | }\n+   | ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "4dc6bbe4d656c36aa7973dffc0468013c3f7ac0c", "filename": "src/test/ui/macro-context.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fmacro-context.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fmacro-context.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro-context.stderr?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -38,7 +38,7 @@ error: expected expression, found reserved keyword `typeof`\n   --> $DIR/macro-context.rs:13:17\n    |\n LL |     () => ( i ; typeof );   //~ ERROR expected expression, found reserved keyword `typeof`\n-   |                 ^^^^^^\n+   |                 ^^^^^^ expected expression\n ...\n LL |     m!();\n    |     ----- in this macro invocation"}, {"sha": "a48eff890b331448750f525310b98f1341d2e44e", "filename": "src/test/ui/missing-block-hint.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fmissing-block-hint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fmissing-block-hint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing-block-hint.stderr?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -2,11 +2,15 @@ error: expected `{`, found `=>`\n   --> $DIR/missing-block-hint.rs:13:18\n    |\n LL |         if (foo) => {} //~ ERROR expected `{`, found `=>`\n-   |                  ^^\n+   |         --       ^^\n+   |         |\n+   |         this `if` statement has a condition, but no block\n \n error: expected `{`, found `bar`\n   --> $DIR/missing-block-hint.rs:17:13\n    |\n+LL |         if (foo)\n+   |         -- this `if` statement has a condition, but no block\n LL |             bar; //~ ERROR expected `{`, found `bar`\n    |             ^^^-\n    |             |"}, {"sha": "c6d32c6726ea576e13b881b552f52267adc5b05c", "filename": "src/test/ui/resolve/token-error-correct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -26,7 +26,7 @@ error: expected expression, found `;`\n   --> $DIR/token-error-correct.rs:14:13\n    |\n LL |     foo(bar(;\n-   |             ^\n+   |             ^ expected expression\n \n error: aborting due to 3 previous errors\n "}, {"sha": "6f86cdea3cf5e867806e81fedab1cc537e70d867", "filename": "src/test/ui/suggestions/missing-comma-in-match.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-comma-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-comma-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-comma-in-match.rs?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    match &Some(3) {\n+        &None => 1\n+        &Some(2) => { 3 }\n+        //~^ ERROR expected one of `,`, `.`, `?`, `}`, or an operator, found `=>`\n+        //~| NOTE expected one of `,`, `.`, `?`, `}`, or an operator here\n+        _ => 2\n+    };\n+}"}, {"sha": "b71a50b66318e6abbd9e9e521472aac4fd30f66a", "filename": "src/test/ui/suggestions/missing-comma-in-match.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-comma-in-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-comma-in-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-comma-in-match.stderr?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -0,0 +1,10 @@\n+error: expected one of `,`, `.`, `?`, `}`, or an operator, found `=>`\n+  --> $DIR/missing-comma-in-match.rs:14:18\n+   |\n+LL |         &None => 1\n+   |                   - help: missing a comma here to end this `match` arm\n+LL |         &Some(2) => { 3 }\n+   |                  ^^ expected one of `,`, `.`, `?`, `}`, or an operator here\n+\n+error: aborting due to previous error\n+"}, {"sha": "26816ca0ca22ab6c149f3dc6bbf33f7d28584d83", "filename": "src/test/ui/token/issue-10636-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Ftoken%2Fissue-10636-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9b86a91786ca54e898b54f30a6e11546b8e8026/src%2Ftest%2Fui%2Ftoken%2Fissue-10636-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftoken%2Fissue-10636-2.stderr?ref=c9b86a91786ca54e898b54f30a6e11546b8e8026", "patch": "@@ -20,7 +20,7 @@ error: expected expression, found `)`\n   --> $DIR/issue-10636-2.rs:18:1\n    |\n LL | } //~ ERROR: incorrect close delimiter\n-   | ^\n+   | ^ expected expression\n \n error[E0601]: main function not found\n "}]}