{"sha": "74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0YjMxN2RkYzI0ZmIwYjVmZmNiYWFmYjA5ODNjYzVkZGZkNGE3MTQ=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-01T00:07:08Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-01T04:22:51Z"}, "message": "modernize smallintmap\n\n* switch to explicit self\n* get rid of the @ box\n* replace DVec with ~[] (to get rid of the mutable field)\n* implement the new container::Map trait", "tree": {"sha": "3da6136f5526c3c45e6a3e0a65f8a14d4c238b53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3da6136f5526c3c45e6a3e0a65f8a14d4c238b53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714", "html_url": "https://github.com/rust-lang/rust/commit/74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "348d770fedcddad7d814bd41072efc0602c739c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/348d770fedcddad7d814bd41072efc0602c739c8", "html_url": "https://github.com/rust-lang/rust/commit/348d770fedcddad7d814bd41072efc0602c739c8"}], "stats": {"total": 245, "additions": 103, "deletions": 142}, "files": [{"sha": "a21328b3d6340e671707ef38632bd2593b375033", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 94, "deletions": 133, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714", "patch": "@@ -15,77 +15,20 @@\n #[forbid(deprecated_mode)];\n \n use core::container::{Container, Mutable, Map, Set};\n-use core::dvec::DVec;\n-use core::ops;\n use core::option::{Some, None};\n-use core::option;\n use core::prelude::*;\n \n-// FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n-// requires this to be.\n-struct SmallIntMap_<T> {\n-    v: DVec<Option<T>>,\n-}\n-\n-pub enum SmallIntMap<T> {\n-    SmallIntMap_(@SmallIntMap_<T>)\n-}\n-\n-/// Create a smallintmap\n-pub fn mk<T: Copy>() -> SmallIntMap<T> {\n-    let v = DVec();\n-    SmallIntMap_(@SmallIntMap_ { v: v } )\n-}\n-\n-/**\n- * Add a value to the map. If the map already contains a value for\n- * the specified key then the original value is replaced.\n- */\n-#[inline(always)]\n-pub fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, val: T) {\n-    //io::println(fmt!(\"%?\", key));\n-    self.v.grow_set_elt(key, &None, Some(val));\n-}\n-\n-/**\n- * Get the value for the specified key. If the key does not exist\n- * in the map then returns none\n- */\n-pub pure fn find<T: Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n-    if key < self.v.len() { return self.v.get_elt(key); }\n-    return None::<T>;\n-}\n-\n-/**\n- * Get the value for the specified key\n- *\n- * # Failure\n- *\n- * If the key does not exist in the map\n- */\n-pub pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n-    match find(self, key) {\n-      None => {\n-        error!(\"smallintmap::get(): key not present\");\n-        fail;\n-      }\n-      Some(move v) => return v\n-    }\n-}\n-\n-/// Returns true if the map contains a value for the specified key\n-pub pure fn contains_key<T: Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n-    return !find(self, key).is_none();\n+pub struct SmallIntMap<T> {\n+    priv v: ~[Option<T>],\n }\n \n impl<V> SmallIntMap<V>: Container {\n     /// Return the number of elements in the map\n     pure fn len(&self) -> uint {\n-        let mut sz = 0u;\n+        let mut sz = 0;\n         for self.v.each |item| {\n-            match *item {\n-              Some(_) => sz += 1u,\n-              _ => ()\n+            if item.is_some() {\n+                sz += 1;\n             }\n         }\n         sz\n@@ -96,118 +39,136 @@ impl<V> SmallIntMap<V>: Container {\n }\n \n impl<V> SmallIntMap<V>: Mutable {\n-    fn clear(&mut self) { self.v.set(~[]) }\n+    /// Clear the map, removing all key-value pairs.\n+    fn clear(&mut self) { self.v.clear() }\n }\n \n-/// Implements the map::map interface for smallintmap\n-impl<V: Copy> SmallIntMap<V> {\n-    #[inline(always)]\n-    fn insert(key: uint, value: V) -> bool {\n-        let exists = contains_key(self, key);\n-        insert(self, key, value);\n-        return !exists;\n+impl<V> SmallIntMap<V>: Map<uint, V> {\n+    /// Return true if the map contains a value for the specified key\n+    pure fn contains_key(&self, key: &uint) -> bool {\n+        self.find(key).is_some()\n     }\n-    fn remove(key: uint) -> bool {\n-        if key >= self.v.len() {\n-            return false;\n+\n+    /// Visit all key-value pairs\n+    pure fn each(&self, it: fn(key: &uint, value: &V) -> bool) {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref elt) => if !it(&i, elt) { break },\n+              None => ()\n+            }\n         }\n-        let old = self.v.get_elt(key);\n-        self.v.set_elt(key, None);\n-        old.is_some()\n     }\n-    pure fn contains_key(key: uint) -> bool {\n-        contains_key(self, key)\n+\n+    /// Visit all keys\n+    pure fn each_key(&self, blk: fn(key: &uint) -> bool) {\n+        self.each(|k, _| blk(k))\n     }\n-    pure fn contains_key_ref(key: &uint) -> bool {\n-        contains_key(self, *key)\n+\n+    /// Visit all values\n+    pure fn each_value(&self, blk: fn(value: &V) -> bool) {\n+        self.each(|_, v| blk(v))\n     }\n-    pure fn get(key: uint) -> V { get(self, key) }\n-    pure fn find(key: uint) -> Option<V> { find(self, key) }\n \n-    fn update_with_key(key: uint, val: V, ff: fn(uint, V, V) -> V) -> bool {\n-        match self.find(key) {\n-            None            => return self.insert(key, val),\n-            Some(copy orig) => return self.insert(key, ff(key, orig, val)),\n+    /// Return the value corresponding to the key in the map\n+    pure fn find(&self, key: &uint) -> Option<&self/V> {\n+        if *key < self.v.len() {\n+            match self.v[*key] {\n+              Some(ref value) => Some(value),\n+              None => None\n+            }\n+        } else {\n+            None\n         }\n     }\n \n-    fn update(key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n-        return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    fn insert(&mut self, key: uint, value: V) -> bool {\n+        let exists = self.contains_key(&key);\n+        let len = self.v.len();\n+        if len <= key {\n+            vec::grow_fn(&mut self.v, key - len + 1, |_| None);\n+        }\n+        self.v[key] = Some(value);\n+        !exists\n     }\n \n-    pure fn each(it: fn(key: uint, value: V) -> bool) {\n-        self.each_ref(|k, v| it(*k, *v))\n-    }\n-    pure fn each_key(it: fn(key: uint) -> bool) {\n-        self.each_ref(|k, _v| it(*k))\n-    }\n-    pure fn each_value(it: fn(value: V) -> bool) {\n-        self.each_ref(|_k, v| it(*v))\n-    }\n-    pure fn each_ref(it: fn(key: &uint, value: &V) -> bool) {\n-        let mut idx = 0u, l = self.v.len();\n-        while idx < l {\n-            match self.v.get_elt(idx) {\n-              Some(ref elt) => if !it(&idx, elt) { break },\n-              None => ()\n-            }\n-            idx += 1u;\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    fn remove(&mut self, key: &uint) -> bool {\n+        if *key >= self.v.len() {\n+            return false;\n         }\n+        let removed = self.v[*key].is_some();\n+        self.v[*key] = None;\n+        removed\n     }\n-    pure fn each_key_ref(blk: fn(key: &uint) -> bool) {\n-        self.each_ref(|k, _v| blk(k))\n-    }\n-    pure fn each_value_ref(blk: fn(value: &V) -> bool) {\n-        self.each_ref(|_k, v| blk(v))\n+}\n+\n+pub impl<V> SmallIntMap<V> {\n+    /// Create an empty SmallIntMap\n+    static pure fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n+\n+    pure fn get(&self, key: &uint) -> &self/V {\n+        self.find(key).expect(\"key not present\")\n     }\n }\n \n-impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n-    pure fn index(&self, key: uint) -> V {\n-        unsafe {\n-            get(*self, key)\n+pub impl<V: Copy> SmallIntMap<V> {\n+    // FIXME: #4733, remove after the next snapshot\n+    #[cfg(stage2)]\n+    fn update_with_key(&mut self, key: uint, val: V,\n+                       ff: fn(uint, V, V) -> V) -> bool {\n+        match self.find(&key) {\n+          None => self.insert(key, val),\n+          Some(orig) => self.insert(key, ff(key, copy *orig, val)),\n         }\n     }\n+\n+    // FIXME: #4733, remove after the next snapshot\n+    #[cfg(stage2)]\n+    fn update(&mut self, key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n+        self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n-    use super::{mk, SmallIntMap};\n-\n-    use core::option::None;\n+    use super::SmallIntMap;\n \n     #[test]\n     fn test_len() {\n-        let mut map = mk();\n+        let mut map = SmallIntMap::new();\n         assert map.len() == 0;\n         assert map.is_empty();\n-        map.insert(5, 20);\n+        assert map.insert(5, 20);\n         assert map.len() == 1;\n         assert !map.is_empty();\n-        map.insert(11, 12);\n+        assert map.insert(11, 12);\n         assert map.len() == 2;\n         assert !map.is_empty();\n-        map.insert(14, 22);\n+        assert map.insert(14, 22);\n         assert map.len() == 3;\n         assert !map.is_empty();\n     }\n \n     #[test]\n     fn test_clear() {\n-        let mut map = mk();\n-        map.insert(5, 20);\n-        map.insert(11, 12);\n-        map.insert(14, 22);\n+        let mut map = SmallIntMap::new();\n+        assert map.insert(5, 20);\n+        assert map.insert(11, 12);\n+        assert map.insert(14, 22);\n         map.clear();\n         assert map.is_empty();\n-        assert map.find(5).is_none();\n-        assert map.find(11).is_none();\n-        assert map.find(14).is_none();\n+        assert map.find(&5).is_none();\n+        assert map.find(&11).is_none();\n+        assert map.find(&14).is_none();\n     }\n \n     #[test]\n     fn test_insert_with_key() {\n-        let map: SmallIntMap<uint> = mk();\n+        let mut map = SmallIntMap::new();\n \n         // given a new key, initialize it with this new count, given\n         // given an existing key, add more to its count\n@@ -227,11 +188,11 @@ mod tests {\n         map.update_with_key(3, 2, addMoreToCount);\n \n         // check the total counts\n-        assert map.find(3).get() == 10;\n-        assert map.find(5).get() == 3;\n-        assert map.find(9).get() == 1;\n+        assert map.find(&3).get() == &10;\n+        assert map.find(&5).get() == &3;\n+        assert map.find(&9).get() == &1;\n \n         // sadly, no sevens were counted\n-        assert None == map.find(7);\n+        assert map.find(&7).is_none();\n     }\n }"}, {"sha": "dc73b430099ab23b60904a63f48dcd903c6b65e7", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714", "patch": "@@ -82,6 +82,7 @@ pub mod list;\n pub mod map;\n pub mod priority_queue;\n pub mod rope;\n+pub mod smallintmap;\n pub mod oldsmallintmap;\n pub mod sort;\n pub mod treemap;"}, {"sha": "0687799cf288c8c085c2382080a36c8fa668a0ad", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714", "patch": "@@ -8,22 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Microbenchmark for the oldsmallintmap library\n+// Microbenchmark for the smallintmap library\n \n extern mod std;\n-use std::oldsmallintmap;\n-use std::oldsmallintmap::SmallIntMap;\n+use std::smallintmap::SmallIntMap;\n use io::WriterUtil;\n \n-fn append_sequential(min: uint, max: uint, map: SmallIntMap<uint>) {\n+fn append_sequential(min: uint, max: uint, map: &mut SmallIntMap<uint>) {\n     for uint::range(min, max) |i| {\n         map.insert(i, i + 22u);\n     }\n }\n \n-fn check_sequential(min: uint, max: uint, map: SmallIntMap<uint>) {\n+fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n     for uint::range(min, max) |i| {\n-        assert map.get(i) == i + 22u;\n+        assert *map.get(&i) == i + 22u;\n     }\n }\n \n@@ -43,11 +42,11 @@ fn main() {\n     let mut appendf = 0.0;\n \n     for uint::range(0u, rep) |_r| {\n-        let map = oldsmallintmap::mk();\n+        let mut map = SmallIntMap::new();\n         let start = std::time::precise_time_s();\n-        append_sequential(0u, max, map);\n+        append_sequential(0u, max, &mut map);\n         let mid = std::time::precise_time_s();\n-        check_sequential(0u, max, map);\n+        check_sequential(0u, max, &map);\n         let end = std::time::precise_time_s();\n \n         checkf += (end - mid) as float;"}]}