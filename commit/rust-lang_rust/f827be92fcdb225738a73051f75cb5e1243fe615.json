{"sha": "f827be92fcdb225738a73051f75cb5e1243fe615", "node_id": "C_kwDOAAsO6NoAKGY4MjdiZTkyZmNkYjIyNTczOGE3MzA1MWY3NWNiNWUxMjQzZmU2MTU", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-02-13T02:11:06Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-10-24T20:05:39Z"}, "message": "Add lint to tell about let else pattern", "tree": {"sha": "8b8638e8cc4710291062e0ec76b1bee978bc2e54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b8638e8cc4710291062e0ec76b1bee978bc2e54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f827be92fcdb225738a73051f75cb5e1243fe615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f827be92fcdb225738a73051f75cb5e1243fe615", "html_url": "https://github.com/rust-lang/rust/commit/f827be92fcdb225738a73051f75cb5e1243fe615", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f827be92fcdb225738a73051f75cb5e1243fe615/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b09d4e1f7082aff024faf27263f78e7fc7190a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b09d4e1f7082aff024faf27263f78e7fc7190a2", "html_url": "https://github.com/rust-lang/rust/commit/5b09d4e1f7082aff024faf27263f78e7fc7190a2"}], "stats": {"total": 458, "additions": 457, "deletions": 1}, "files": [{"sha": "b5a1d194794ca0acbb4792f41fed97b8b429f81d", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f827be92fcdb225738a73051f75cb5e1243fe615/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/f827be92fcdb225738a73051f75cb5e1243fe615/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=f827be92fcdb225738a73051f75cb5e1243fe615", "patch": "@@ -3997,6 +3997,7 @@ Released 2018-09-13\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map\n [`manual_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_flatten\n [`manual_instant_elapsed`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_instant_elapsed\n+[`manual_let_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_let_else\n [`manual_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_map\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive"}, {"sha": "2bb8dfee152517c9214040ac3fb8f2f71130e8cb", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f827be92fcdb225738a73051f75cb5e1243fe615/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f827be92fcdb225738a73051f75cb5e1243fe615/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=f827be92fcdb225738a73051f75cb5e1243fe615", "patch": "@@ -251,6 +251,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::manual_bits::MANUAL_BITS_INFO,\n     crate::manual_clamp::MANUAL_CLAMP_INFO,\n     crate::manual_instant_elapsed::MANUAL_INSTANT_ELAPSED_INFO,\n+    crate::manual_let_else::MANUAL_LET_ELSE_INFO,\n     crate::manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE_INFO,\n     crate::manual_rem_euclid::MANUAL_REM_EUCLID_INFO,\n     crate::manual_retain::MANUAL_RETAIN_INFO,"}, {"sha": "b261beab793685358e2a9ed16f9b8fe90ef31271", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f827be92fcdb225738a73051f75cb5e1243fe615/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f827be92fcdb225738a73051f75cb5e1243fe615/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f827be92fcdb225738a73051f75cb5e1243fe615", "patch": "@@ -170,6 +170,7 @@ mod manual_async_fn;\n mod manual_bits;\n mod manual_clamp;\n mod manual_instant_elapsed;\n+mod manual_let_else;\n mod manual_non_exhaustive;\n mod manual_rem_euclid;\n mod manual_retain;\n@@ -603,6 +604,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         ))\n     });\n     store.register_late_pass(move |_| Box::new(matches::Matches::new(msrv)));\n+    store.register_late_pass(move |_| Box::new(manual_let_else::ManualLetElse::new(msrv)));\n     store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveStruct::new(msrv)));\n     store.register_late_pass(move |_| Box::new(manual_non_exhaustive::ManualNonExhaustiveEnum::new(msrv)));\n     store.register_late_pass(move |_| Box::new(manual_strip::ManualStrip::new(msrv)));"}, {"sha": "8983cd7ae1cf9ecfc5dcd2473e53f4dd7d929bcd", "filename": "clippy_lints/src/manual_let_else.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/f827be92fcdb225738a73051f75cb5e1243fe615/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f827be92fcdb225738a73051f75cb5e1243fe615/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_let_else.rs?ref=f827be92fcdb225738a73051f75cb5e1243fe615", "patch": "@@ -0,0 +1,160 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::visitors::{for_each_expr, Descend};\n+use clippy_utils::{higher, meets_msrv, msrvs, peel_blocks};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, ExprKind, Pat, QPath, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use std::ops::ControlFlow;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Warn of cases where `let...else` could be used\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// `let...else` provides a standard construct for this pattern\n+    /// that people can easily recognize. It's also more compact.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # let w = Some(0);\n+    /// let v = if let Some(v) = w { v } else { return };\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// # #![feature(let_else)]\n+    /// # fn main () {\n+    /// # let w = Some(0);\n+    /// let Some(v) = w else { return };\n+    /// # }\n+    /// ```\n+    #[clippy::version = \"1.67.0\"]\n+    pub MANUAL_LET_ELSE,\n+    pedantic,\n+    \"manual implementation of a let...else statement\"\n+}\n+\n+pub struct ManualLetElse {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl ManualLetElse {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(ManualLetElse => [MANUAL_LET_ELSE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualLetElse {\n+    fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &'tcx Stmt<'tcx>) {\n+        if !meets_msrv(self.msrv, msrvs::LET_ELSE) {\n+            return;\n+        }\n+\n+        if in_external_macro(cx.sess(), stmt.span) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let StmtKind::Local(local) = stmt.kind;\n+            if let Some(init) = local.init;\n+            if let Some(higher::IfLet { let_pat, let_expr: _, if_then, if_else }) = higher::IfLet::hir(cx, init);\n+            if if_then_simple_identity(let_pat, if_then);\n+            if let Some(if_else) = if_else;\n+            if expr_diverges(cx, if_else);\n+            then {\n+                span_lint(\n+                    cx,\n+                    MANUAL_LET_ELSE,\n+                    stmt.span,\n+                    \"this could be rewritten as `let else`\",\n+                );\n+            }\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn expr_diverges(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n+    fn is_never(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n+        if let Some(ty) = cx.typeck_results().expr_ty_opt(expr) {\n+            return ty.is_never();\n+        }\n+        false\n+    }\n+    // We can't just call is_never on expr and be done, because the type system\n+    // sometimes coerces the ! type to something different before we can get\n+    // our hands on it. So instead, we do a manual search. We do fall back to\n+    // is_never in some places when there is no better alternative.\n+    for_each_expr(expr, |ex| {\n+        match ex.kind {\n+            ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => ControlFlow::Break(()),\n+            ExprKind::Call(call, _) => {\n+                if is_never(cx, ex) || is_never(cx, call) {\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(Descend::Yes)\n+            },\n+            ExprKind::MethodCall(..) => {\n+                if is_never(cx, ex) {\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(Descend::Yes)\n+            },\n+            ExprKind::If(if_expr, if_then, if_else) => {\n+                let else_diverges = if_else.map_or(false, |ex| expr_diverges(cx, ex));\n+                let diverges = expr_diverges(cx, if_expr) || (else_diverges && expr_diverges(cx, if_then));\n+                if diverges {\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(Descend::No)\n+            },\n+            ExprKind::Match(match_expr, match_arms, _) => {\n+                let diverges =\n+                    expr_diverges(cx, match_expr) || match_arms.iter().all(|arm| expr_diverges(cx, arm.body));\n+                if diverges {\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(Descend::No)\n+            },\n+\n+            // Don't continue into loops or labeled blocks, as they are breakable,\n+            // and we'd have to start checking labels.\n+            ExprKind::Block(_, Some(_)) | ExprKind::Loop(..) => ControlFlow::Continue(Descend::No),\n+\n+            // Default: descend\n+            _ => ControlFlow::Continue(Descend::Yes),\n+        }\n+    })\n+    .is_some()\n+}\n+\n+/// Checks if the passed `if_then` is a simple identity\n+fn if_then_simple_identity(let_pat: &'_ Pat<'_>, if_then: &'_ Expr<'_>) -> bool {\n+    // TODO support patterns with multiple bindings and tuples, like:\n+    //   let (foo, bar) = if let (Some(foo), bar) = g() { (foo, bar) } else { ... }\n+    if_chain! {\n+        if let ExprKind::Path(QPath::Resolved(_ty, path)) = &peel_blocks(if_then).kind;\n+        if let [path_seg] = path.segments;\n+        then {\n+            let mut pat_bindings = Vec::new();\n+            let_pat.each_binding(|_ann, _hir_id, _sp, ident| {\n+                pat_bindings.push(ident);\n+            });\n+            if let [binding] = &pat_bindings[..] {\n+                return path_seg.ident == *binding;\n+            }\n+        }\n+    }\n+    false\n+}"}, {"sha": "1aa86efd38f838ffa31b440582c9a01a7e28fd1e", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f827be92fcdb225738a73051f75cb5e1243fe615/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f827be92fcdb225738a73051f75cb5e1243fe615/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=f827be92fcdb225738a73051f75cb5e1243fe615", "patch": "@@ -213,7 +213,7 @@ define_Conf! {\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS, ERR_EXPECT, CAST_ABS_TO_UNSIGNED, UNINLINED_FORMAT_ARGS, MANUAL_CLAMP.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS, ERR_EXPECT, CAST_ABS_TO_UNSIGNED, UNINLINED_FORMAT_ARGS, MANUAL_CLAMP, MANUAL_LET_ELSE.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),"}, {"sha": "9780794fa99cad538dcf4ab93c35aee3aab29df6", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f827be92fcdb225738a73051f75cb5e1243fe615/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f827be92fcdb225738a73051f75cb5e1243fe615/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=f827be92fcdb225738a73051f75cb5e1243fe615", "patch": "@@ -12,6 +12,7 @@ macro_rules! msrv_aliases {\n \n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n+    1,65,0 { LET_ELSE }\n     1,62,0 { BOOL_THEN_SOME }\n     1,58,0 { FORMAT_ARGS_CAPTURE }\n     1,53,0 { OR_PATTERNS, MANUAL_BITS, BTREE_MAP_RETAIN, BTREE_SET_RETAIN, ARRAY_INTO_ITERATOR }"}, {"sha": "14166709f7fd6f67fe907bdcebdd267ad722f6b9", "filename": "src/docs/manual_let_else.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f827be92fcdb225738a73051f75cb5e1243fe615/src%2Fdocs%2Fmanual_let_else.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f827be92fcdb225738a73051f75cb5e1243fe615/src%2Fdocs%2Fmanual_let_else.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_let_else.txt?ref=f827be92fcdb225738a73051f75cb5e1243fe615", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+\n+Warn of cases where `let...else` could be used\n+\n+### Why is this bad?\n+\n+`let...else` provides a standard construct for this pattern\n+that people can easily recognize. It's also more compact.\n+\n+### Example\n+\n+```\n+let v = if let Some(v) = w { v } else { return };\n+```\n+\n+Could be written:\n+\n+```\n+let Some(v) = w else { return };\n+```\n\\ No newline at end of file"}, {"sha": "f2827e225002268b0c3570142e610a56d372069b", "filename": "tests/ui/manual_let_else.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/f827be92fcdb225738a73051f75cb5e1243fe615/tests%2Fui%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f827be92fcdb225738a73051f75cb5e1243fe615/tests%2Fui%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else.rs?ref=f827be92fcdb225738a73051f75cb5e1243fe615", "patch": "@@ -0,0 +1,167 @@\n+#![allow(unused_braces, unused_variables, dead_code)]\n+#![allow(\n+    clippy::collapsible_else_if,\n+    clippy::unused_unit,\n+    clippy::never_loop,\n+    clippy::let_unit_value\n+)]\n+#![warn(clippy::manual_let_else)]\n+\n+fn g() -> Option<()> {\n+    None\n+}\n+\n+fn main() {}\n+\n+fn fire() {\n+    let v = if let Some(v_some) = g() { v_some } else { return };\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        return;\n+    };\n+\n+    let v = if let Some(v) = g() {\n+        // Blocks around the identity should have no impact\n+        {\n+            { v }\n+        }\n+    } else {\n+        // Some computation should still make it fire\n+        g();\n+        return;\n+    };\n+\n+    // continue and break diverge\n+    loop {\n+        let v = if let Some(v_some) = g() { v_some } else { continue };\n+        let v = if let Some(v_some) = g() { v_some } else { break };\n+    }\n+\n+    // panic also diverges\n+    let v = if let Some(v_some) = g() { v_some } else { panic!() };\n+\n+    // abort also diverges\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        std::process::abort()\n+    };\n+\n+    // If whose two branches diverge also diverges\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        if true { return } else { panic!() }\n+    };\n+\n+    // Top level else if\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else if true {\n+        return;\n+    } else {\n+        panic!(\"diverge\");\n+    };\n+\n+    // All match arms diverge\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        match (g(), g()) {\n+            (Some(_), None) => return,\n+            (None, Some(_)) => {\n+                if true {\n+                    return;\n+                } else {\n+                    panic!();\n+                }\n+            },\n+            _ => return,\n+        }\n+    };\n+\n+    // Tuples supported for the declared variables\n+    let (v, w) = if let Some(v_some) = g().map(|v| (v, 42)) {\n+        v_some\n+    } else {\n+        return;\n+    };\n+}\n+\n+fn not_fire() {\n+    let v = if let Some(v_some) = g() {\n+        // Nothing returned. Should not fire.\n+    } else {\n+        return;\n+    };\n+\n+    let w = 0;\n+    let v = if let Some(v_some) = g() {\n+        // Different variable than v_some. Should not fire.\n+        w\n+    } else {\n+        return;\n+    };\n+\n+    let v = if let Some(v_some) = g() {\n+        // Computation in then clause. Should not fire.\n+        g();\n+        v_some\n+    } else {\n+        return;\n+    };\n+\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        if false {\n+            return;\n+        }\n+        // This doesn't diverge. Should not fire.\n+        ()\n+    };\n+\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        // There is one match arm that doesn't diverge. Should not fire.\n+        match (g(), g()) {\n+            (Some(_), None) => return,\n+            (None, Some(_)) => return,\n+            (Some(_), Some(_)) => (),\n+            _ => return,\n+        }\n+    };\n+\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        // loop with a break statement inside does not diverge.\n+        loop {\n+            break;\n+        }\n+    };\n+\n+\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        enum Uninhabited {}\n+        fn un() -> Uninhabited {\n+            panic!()\n+        }\n+        // Don't lint if the type is uninhabited but not !\n+        un()\n+    };\n+\n+    fn question_mark() -> Option<()> {\n+        let v = if let Some(v) = g() {\n+            v\n+        } else {\n+            // Question mark does not diverge\n+            g()?\n+        };\n+        Some(v)\n+    }\n+}"}, {"sha": "461de79f6b91e5d645e785afc5d83c54fddd63e5", "filename": "tests/ui/manual_let_else.stderr", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f827be92fcdb225738a73051f75cb5e1243fe615/tests%2Fui%2Fmanual_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f827be92fcdb225738a73051f75cb5e1243fe615/tests%2Fui%2Fmanual_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else.stderr?ref=f827be92fcdb225738a73051f75cb5e1243fe615", "patch": "@@ -0,0 +1,104 @@\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else.rs:17:5\n+   |\n+LL |     let v = if let Some(v_some) = g() { v_some } else { return };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::manual-let-else` implied by `-D warnings`\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else.rs:18:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         return;\n+LL | |     };\n+   | |______^\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else.rs:24:5\n+   |\n+LL | /     let v = if let Some(v) = g() {\n+LL | |         // Blocks around the identity should have no impact\n+LL | |         {\n+LL | |             { v }\n+...  |\n+LL | |         return;\n+LL | |     };\n+   | |______^\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else.rs:37:9\n+   |\n+LL |         let v = if let Some(v_some) = g() { v_some } else { continue };\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else.rs:38:9\n+   |\n+LL |         let v = if let Some(v_some) = g() { v_some } else { break };\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else.rs:42:5\n+   |\n+LL |     let v = if let Some(v_some) = g() { v_some } else { panic!() };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else.rs:45:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         std::process::abort()\n+LL | |     };\n+   | |______^\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else.rs:52:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         if true { return } else { panic!() }\n+LL | |     };\n+   | |______^\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else.rs:59:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else if true {\n+LL | |         return;\n+LL | |     } else {\n+LL | |         panic!(\"diverge\");\n+LL | |     };\n+   | |______^\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else.rs:68:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         match (g(), g()) {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |______^\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else.rs:85:5\n+   |\n+LL | /     let (v, w) = if let Some(v_some) = g().map(|v| (v, 42)) {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         return;\n+LL | |     };\n+   | |______^\n+\n+error: aborting due to 11 previous errors\n+"}]}