{"sha": "c66e88289e6ffa8be4701933369820613b9d345d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NmU4ODI4OWU2ZmZhOGJlNDcwMTkzMzM2OTgyMDYxM2I5ZDM0NWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-19T01:48:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-19T01:48:27Z"}, "message": "Auto merge of #31013 - nrc:fmt-rbml, r=sfackler", "tree": {"sha": "6fec1b853bbf90f92da2164abe0f6a0e64e6ac8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fec1b853bbf90f92da2164abe0f6a0e64e6ac8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c66e88289e6ffa8be4701933369820613b9d345d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c66e88289e6ffa8be4701933369820613b9d345d", "html_url": "https://github.com/rust-lang/rust/commit/c66e88289e6ffa8be4701933369820613b9d345d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c66e88289e6ffa8be4701933369820613b9d345d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a7307e5cf08ad25de62d4f9e13ddd58c59881c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a7307e5cf08ad25de62d4f9e13ddd58c59881c8", "html_url": "https://github.com/rust-lang/rust/commit/7a7307e5cf08ad25de62d4f9e13ddd58c59881c8"}, {"sha": "8863d37f24ab94a15c3cba9472fb25af24d943e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8863d37f24ab94a15c3cba9472fb25af24d943e1", "html_url": "https://github.com/rust-lang/rust/commit/8863d37f24ab94a15c3cba9472fb25af24d943e1"}], "stats": {"total": 955, "additions": 505, "deletions": 450}, "files": [{"sha": "0c5356c0222359c70151d13a3da43bdc8aa07ce4", "filename": "src/librbml/leb128.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c66e88289e6ffa8be4701933369820613b9d345d/src%2Flibrbml%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66e88289e6ffa8be4701933369820613b9d345d/src%2Flibrbml%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fleb128.rs?ref=c66e88289e6ffa8be4701933369820613b9d345d", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n #[inline]\n-pub fn write_to_vec(vec: &mut Vec<u8>, position: &mut usize, byte: u8)\n-{\n+pub fn write_to_vec(vec: &mut Vec<u8>, position: &mut usize, byte: u8) {\n     if *position == vec.len() {\n         vec.push(byte);\n     } else {\n@@ -20,13 +19,9 @@ pub fn write_to_vec(vec: &mut Vec<u8>, position: &mut usize, byte: u8)\n     *position += 1;\n }\n \n-pub fn write_unsigned_leb128(out: &mut Vec<u8>,\n-                             start_position: usize,\n-                             mut value: u64)\n-                             -> usize {\n+pub fn write_unsigned_leb128(out: &mut Vec<u8>, start_position: usize, mut value: u64) -> usize {\n     let mut position = start_position;\n-    loop\n-    {\n+    loop {\n         let mut byte = (value & 0x7F) as u8;\n         value >>= 7;\n         if value != 0 {\n@@ -43,9 +38,7 @@ pub fn write_unsigned_leb128(out: &mut Vec<u8>,\n     return position - start_position;\n }\n \n-pub fn read_unsigned_leb128(data: &[u8],\n-                            start_position: usize)\n-                            -> (u64, usize) {\n+pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u64, usize) {\n     let mut result = 0;\n     let mut shift = 0;\n     let mut position = start_position;\n@@ -63,15 +56,13 @@ pub fn read_unsigned_leb128(data: &[u8],\n }\n \n \n-pub fn write_signed_leb128(out: &mut Vec<u8>,\n-                           start_position: usize,\n-                           mut value: i64) -> usize {\n+pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, mut value: i64) -> usize {\n     let mut position = start_position;\n \n     loop {\n         let mut byte = (value as u8) & 0x7f;\n         value >>= 7;\n-        let more = !((((value == 0 ) && ((byte & 0x40) == 0)) ||\n+        let more = !((((value == 0) && ((byte & 0x40) == 0)) ||\n                       ((value == -1) && ((byte & 0x40) != 0))));\n         if more {\n             byte |= 0x80; // Mark this byte to show that more bytes will follow.\n@@ -87,9 +78,7 @@ pub fn write_signed_leb128(out: &mut Vec<u8>,\n     return position - start_position;\n }\n \n-pub fn read_signed_leb128(data: &[u8],\n-                          start_position: usize)\n-                          -> (i64, usize) {\n+pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i64, usize) {\n     let mut result = 0;\n     let mut shift = 0;\n     let mut position = start_position;\n@@ -107,7 +96,7 @@ pub fn read_signed_leb128(data: &[u8],\n     }\n \n     if (shift < 64) && ((byte & 0x40) != 0) {\n-        /* sign extend */\n+        // sign extend\n         result |= -(1i64 << shift);\n     }\n "}, {"sha": "913314c4899a2260c69eb34c8cd5bb3c07440fb0", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 330, "deletions": 258, "changes": 588, "blob_url": "https://github.com/rust-lang/rust/blob/c66e88289e6ffa8be4701933369820613b9d345d/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66e88289e6ffa8be4701933369820613b9d345d/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=c66e88289e6ffa8be4701933369820613b9d345d", "patch": "@@ -131,9 +131,11 @@ extern crate serialize;\n #[cfg(test)]\n extern crate serialize as rustc_serialize; // Used by RustcEncodable\n \n-#[macro_use] extern crate log;\n+#[macro_use]\n+extern crate log;\n \n-#[cfg(test)] extern crate test;\n+#[cfg(test)]\n+extern crate test;\n \n pub mod opaque;\n pub mod leb128;\n@@ -154,7 +156,11 @@ pub struct Doc<'a> {\n \n impl<'doc> Doc<'doc> {\n     pub fn new(data: &'doc [u8]) -> Doc<'doc> {\n-        Doc { data: data, start: 0, end: data.len() }\n+        Doc {\n+            data: data,\n+            start: 0,\n+            end: data.len(),\n+        }\n     }\n \n     pub fn get<'a>(&'a self, tag: usize) -> Doc<'a> {\n@@ -183,36 +189,35 @@ pub struct TaggedDoc<'a> {\n pub enum EbmlEncoderTag {\n     // tags 00..1f are reserved for auto-serialization.\n     // first NUM_IMPLICIT_TAGS tags are implicitly sized and lengths are not encoded.\n-\n-    EsU8       = 0x00, // + 1 byte\n-    EsU16      = 0x01, // + 2 bytes\n-    EsU32      = 0x02, // + 4 bytes\n-    EsU64      = 0x03, // + 8 bytes\n-    EsI8       = 0x04, // + 1 byte\n-    EsI16      = 0x05, // + 2 bytes\n-    EsI32      = 0x06, // + 4 bytes\n-    EsI64      = 0x07, // + 8 bytes\n-    EsBool     = 0x08, // + 1 byte\n-    EsChar     = 0x09, // + 4 bytes\n-    EsF32      = 0x0a, // + 4 bytes\n-    EsF64      = 0x0b, // + 8 bytes\n-    EsSub8     = 0x0c, // + 1 byte\n-    EsSub32    = 0x0d, // + 4 bytes\n+    EsU8 = 0x00, // + 1 byte\n+    EsU16 = 0x01, // + 2 bytes\n+    EsU32 = 0x02, // + 4 bytes\n+    EsU64 = 0x03, // + 8 bytes\n+    EsI8 = 0x04, // + 1 byte\n+    EsI16 = 0x05, // + 2 bytes\n+    EsI32 = 0x06, // + 4 bytes\n+    EsI64 = 0x07, // + 8 bytes\n+    EsBool = 0x08, // + 1 byte\n+    EsChar = 0x09, // + 4 bytes\n+    EsF32 = 0x0a, // + 4 bytes\n+    EsF64 = 0x0b, // + 8 bytes\n+    EsSub8 = 0x0c, // + 1 byte\n+    EsSub32 = 0x0d, // + 4 bytes\n     // 0x0e and 0x0f are reserved\n-\n-    EsStr      = 0x10,\n-    EsEnum     = 0x11, // encodes the variant id as the first EsSub*\n-    EsVec      = 0x12, // encodes the # of elements as the first EsSub*\n-    EsVecElt   = 0x13,\n-    EsMap      = 0x14, // encodes the # of pairs as the first EsSub*\n-    EsMapKey   = 0x15,\n-    EsMapVal   = 0x16,\n-    EsOpaque   = 0x17,\n+    EsStr = 0x10,\n+    EsEnum = 0x11, // encodes the variant id as the first EsSub*\n+    EsVec = 0x12, // encodes the # of elements as the first EsSub*\n+    EsVecElt = 0x13,\n+    EsMap = 0x14, // encodes the # of pairs as the first EsSub*\n+    EsMapKey = 0x15,\n+    EsMapVal = 0x16,\n+    EsOpaque = 0x17,\n }\n \n const NUM_TAGS: usize = 0x1000;\n const NUM_IMPLICIT_TAGS: usize = 0x0e;\n \n+#[cfg_attr(rustfmt, rustfmt_skip)]\n static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n     1, 2, 4, 8, // EsU*\n     1, 2, 4, 8, // ESI*\n@@ -228,7 +233,7 @@ pub enum Error {\n     InvalidTag(usize),\n     Expected(String),\n     IoError(std::io::Error),\n-    ApplicationError(String)\n+    ApplicationError(String),\n }\n \n impl fmt::Display for Error {\n@@ -248,11 +253,10 @@ pub mod reader {\n     use serialize;\n \n     use super::opaque;\n-    use super::{ ApplicationError, EsVec, EsMap, EsEnum, EsSub8, EsSub32,\n-        EsVecElt, EsMapKey, EsU64, EsU32, EsU16, EsU8, EsI64,\n-        EsI32, EsI16, EsI8, EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n-        EsOpaque, EbmlEncoderTag, Doc, TaggedDoc,\n-        Error, IntTooBig, InvalidTag, Expected, NUM_IMPLICIT_TAGS, TAG_IMPLICIT_LEN };\n+    use super::{ApplicationError, EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n+                EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8, EsBool, EsF64, EsF32,\n+                EsChar, EsStr, EsMapVal, EsOpaque, EbmlEncoderTag, Doc, TaggedDoc, Error,\n+                IntTooBig, InvalidTag, Expected, NUM_IMPLICIT_TAGS, TAG_IMPLICIT_LEN};\n \n     pub type DecodeResult<T> = Result<T, Error>;\n     // rbml reading\n@@ -272,15 +276,21 @@ pub mod reader {\n     #[derive(Copy, Clone)]\n     pub struct Res {\n         pub val: usize,\n-        pub next: usize\n+        pub next: usize,\n     }\n \n     pub fn tag_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n         let v = data[start] as usize;\n         if v < 0xf0 {\n-            Ok(Res { val: v, next: start + 1 })\n+            Ok(Res {\n+                val: v,\n+                next: start + 1,\n+            })\n         } else if v > 0xf0 {\n-            Ok(Res { val: ((v & 0xf) << 8) | data[start + 1] as usize, next: start + 2 })\n+            Ok(Res {\n+                val: ((v & 0xf) << 8) | data[start + 1] as usize,\n+                next: start + 2,\n+            })\n         } else {\n             // every tag starting with byte 0xf0 is an overlong form, which is prohibited.\n             Err(InvalidTag(v))\n@@ -291,25 +301,31 @@ pub mod reader {\n     fn vuint_at_slow(data: &[u8], start: usize) -> DecodeResult<Res> {\n         let a = data[start];\n         if a & 0x80 != 0 {\n-            return Ok(Res {val: (a & 0x7f) as usize, next: start + 1});\n+            return Ok(Res {\n+                val: (a & 0x7f) as usize,\n+                next: start + 1,\n+            });\n         }\n         if a & 0x40 != 0 {\n-            return Ok(Res {val: ((a & 0x3f) as usize) << 8 |\n-                        (data[start + 1] as usize),\n-                    next: start + 2});\n+            return Ok(Res {\n+                val: ((a & 0x3f) as usize) << 8 | (data[start + 1] as usize),\n+                next: start + 2,\n+            });\n         }\n         if a & 0x20 != 0 {\n-            return Ok(Res {val: ((a & 0x1f) as usize) << 16 |\n-                        (data[start + 1] as usize) << 8 |\n-                        (data[start + 2] as usize),\n-                    next: start + 3});\n+            return Ok(Res {\n+                val: ((a & 0x1f) as usize) << 16 | (data[start + 1] as usize) << 8 |\n+                     (data[start + 2] as usize),\n+                next: start + 3,\n+            });\n         }\n         if a & 0x10 != 0 {\n-            return Ok(Res {val: ((a & 0x0f) as usize) << 24 |\n-                        (data[start + 1] as usize) << 16 |\n-                        (data[start + 2] as usize) << 8 |\n-                        (data[start + 3] as usize),\n-                    next: start + 4});\n+            return Ok(Res {\n+                val: ((a & 0x0f) as usize) << 24 | (data[start + 1] as usize) << 16 |\n+                     (data[start + 2] as usize) << 8 |\n+                     (data[start + 3] as usize),\n+                next: start + 4,\n+            });\n         }\n         Err(IntTooBig(a as usize))\n     }\n@@ -338,13 +354,22 @@ pub mod reader {\n         // most significant bit is set etc. we can replace up to three\n         // \"and+branch\" with a single table lookup which gives us a measured\n         // speedup of around 2x on x86_64.\n-        static SHIFT_MASK_TABLE: [(usize, u32); 16] = [\n-            (0, 0x0), (0, 0x0fffffff),\n-            (8, 0x1fffff), (8, 0x1fffff),\n-            (16, 0x3fff), (16, 0x3fff), (16, 0x3fff), (16, 0x3fff),\n-            (24, 0x7f), (24, 0x7f), (24, 0x7f), (24, 0x7f),\n-            (24, 0x7f), (24, 0x7f), (24, 0x7f), (24, 0x7f)\n-        ];\n+        static SHIFT_MASK_TABLE: [(usize, u32); 16] = [(0, 0x0),\n+                                                       (0, 0x0fffffff),\n+                                                       (8, 0x1fffff),\n+                                                       (8, 0x1fffff),\n+                                                       (16, 0x3fff),\n+                                                       (16, 0x3fff),\n+                                                       (16, 0x3fff),\n+                                                       (16, 0x3fff),\n+                                                       (24, 0x7f),\n+                                                       (24, 0x7f),\n+                                                       (24, 0x7f),\n+                                                       (24, 0x7f),\n+                                                       (24, 0x7f),\n+                                                       (24, 0x7f),\n+                                                       (24, 0x7f),\n+                                                       (24, 0x7f)];\n \n         unsafe {\n             let ptr = data.as_ptr().offset(start as isize) as *const u32;\n@@ -361,7 +386,10 @@ pub mod reader {\n \n     pub fn tag_len_at(data: &[u8], tag: Res) -> DecodeResult<Res> {\n         if tag.val < NUM_IMPLICIT_TAGS && TAG_IMPLICIT_LEN[tag.val] >= 0 {\n-            Ok(Res { val: TAG_IMPLICIT_LEN[tag.val] as usize, next: tag.next })\n+            Ok(Res {\n+                val: TAG_IMPLICIT_LEN[tag.val] as usize,\n+                next: tag.next,\n+            })\n         } else {\n             vuint_at(data, tag.next)\n         }\n@@ -373,7 +401,11 @@ pub mod reader {\n         let end = elt_size.next + elt_size.val;\n         Ok(TaggedDoc {\n             tag: elt_tag.val,\n-            doc: Doc { data: data, start: elt_size.next, end: end }\n+            doc: Doc {\n+                data: data,\n+                start: elt_size.next,\n+                end: end,\n+            },\n         })\n     }\n \n@@ -384,8 +416,11 @@ pub mod reader {\n             let elt_size = try_or!(tag_len_at(d.data, elt_tag), None);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n-                return Some(Doc { data: d.data, start: elt_size.next,\n-                                  end: pos });\n+                return Some(Doc {\n+                    data: d.data,\n+                    start: elt_size.next,\n+                    end: pos,\n+                });\n             }\n         }\n         None\n@@ -402,9 +437,7 @@ pub mod reader {\n     }\n \n     pub fn docs<'a>(d: Doc<'a>) -> DocsIterator<'a> {\n-        DocsIterator {\n-            d: d\n-        }\n+        DocsIterator { d: d }\n     }\n \n     pub struct DocsIterator<'a> {\n@@ -465,8 +498,8 @@ pub mod reader {\n         }\n     }\n \n-    pub fn with_doc_data<T, F>(d: Doc, f: F) -> T where\n-        F: FnOnce(&[u8]) -> T,\n+    pub fn with_doc_data<T, F>(d: Doc, f: F) -> T\n+        where F: FnOnce(&[u8]) -> T\n     {\n         f(&d.data[d.start..d.end])\n     }\n@@ -485,30 +518,48 @@ pub mod reader {\n             // of the page and segfault.\n \n             let mut b = [0; 8];\n-            b.clone_from_slice(&d.data[d.end-8..d.end]);\n+            b.clone_from_slice(&d.data[d.end - 8..d.end]);\n             let data = unsafe { (*(b.as_ptr() as *const u64)).to_be() };\n             let len = d.end - d.start;\n             if len < 8 {\n-                data & ((1<<(len*8))-1)\n+                data & ((1 << (len * 8)) - 1)\n             } else {\n                 data\n             }\n         } else {\n             let mut result = 0;\n             for b in &d.data[d.start..d.end] {\n-                result = (result<<8) + (*b as u64);\n+                result = (result << 8) + (*b as u64);\n             }\n             result\n         }\n     }\n \n-    #[inline] pub fn doc_as_u16(d: Doc) -> u16 { doc_as_u64(d) as u16 }\n-    #[inline] pub fn doc_as_u32(d: Doc) -> u32 { doc_as_u64(d) as u32 }\n+    #[inline]\n+    pub fn doc_as_u16(d: Doc) -> u16 {\n+        doc_as_u64(d) as u16\n+    }\n+    #[inline]\n+    pub fn doc_as_u32(d: Doc) -> u32 {\n+        doc_as_u64(d) as u32\n+    }\n \n-    #[inline] pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n-    #[inline] pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n-    #[inline] pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n-    #[inline] pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n+    #[inline]\n+    pub fn doc_as_i8(d: Doc) -> i8 {\n+        doc_as_u8(d) as i8\n+    }\n+    #[inline]\n+    pub fn doc_as_i16(d: Doc) -> i16 {\n+        doc_as_u16(d) as i16\n+    }\n+    #[inline]\n+    pub fn doc_as_i32(d: Doc) -> i32 {\n+        doc_as_u32(d) as i32\n+    }\n+    #[inline]\n+    pub fn doc_as_i64(d: Doc) -> i64 {\n+        doc_as_u64(d) as i64\n+    }\n \n     pub struct Decoder<'a> {\n         parent: Doc<'a>,\n@@ -519,18 +570,16 @@ pub mod reader {\n         pub fn new(d: Doc<'doc>) -> Decoder<'doc> {\n             Decoder {\n                 parent: d,\n-                pos: d.start\n+                pos: d.start,\n             }\n         }\n \n         fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n             debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n             if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in \\\n-                                             current node!\")));\n+                return Err(Expected(format!(\"no more documents in current node!\")));\n             }\n-            let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                try!(doc_at(self.parent.data, self.pos));\n+            let TaggedDoc { tag: r_tag, doc: r_doc } = try!(doc_at(self.parent.data, self.pos));\n             debug!(\"self.parent={:?}-{:?} self.pos={:?} r_tag={:?} r_doc={:?}-{:?}\",\n                    self.parent.start,\n                    self.parent.end,\n@@ -539,20 +588,22 @@ pub mod reader {\n                    r_doc.start,\n                    r_doc.end);\n             if r_tag != (exp_tag as usize) {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} but \\\n-                                             found tag {:?}\", exp_tag, r_tag)));\n+                return Err(Expected(format!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n+                                            exp_tag,\n+                                            r_tag)));\n             }\n             if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to \\\n-                                             {:#x}, parent to {:#x}\",\n-                                            r_doc.end, self.parent.end)));\n+                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n+                                             {:#x}\",\n+                                            r_doc.end,\n+                                            self.parent.end)));\n             }\n             self.pos = r_doc.end;\n             Ok(r_doc)\n         }\n \n-        fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n             let d = try!(self.next_doc(exp_tag));\n             let old_parent = self.parent;\n@@ -571,20 +622,23 @@ pub mod reader {\n                 return Ok(0);\n             }\n \n-            let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                try!(doc_at(self.parent.data, self.pos));\n+            let TaggedDoc { tag: r_tag, doc: r_doc } = try!(doc_at(self.parent.data, self.pos));\n             let r = if r_tag == (EsSub8 as usize) {\n                 doc_as_u8(r_doc) as usize\n             } else if r_tag == (EsSub32 as usize) {\n                 doc_as_u32(r_doc) as usize\n             } else {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but \\\n-                                             found tag {:?}\", EsSub8, EsSub32, r_tag)));\n+                return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but found \\\n+                                             tag {:?}\",\n+                                            EsSub8,\n+                                            EsSub32,\n+                                            r_tag)));\n             };\n             if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to \\\n-                                             {:#x}, parent to {:#x}\",\n-                                            r_doc.end, self.parent.end)));\n+                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n+                                             {:#x}\",\n+                                            r_doc.end,\n+                                            self.parent.end)));\n             }\n             self.pos = r_doc.end;\n             debug!(\"_next_sub result={:?}\", r);\n@@ -597,14 +651,13 @@ pub mod reader {\n         // all tags between them should be valid, in the order of u8, u16, u32 and u64.\n         fn _next_int(&mut self,\n                      first_tag: EbmlEncoderTag,\n-                     last_tag: EbmlEncoderTag) -> DecodeResult<u64> {\n+                     last_tag: EbmlEncoderTag)\n+                     -> DecodeResult<u64> {\n             if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in \\\n-                                             current node!\")));\n+                return Err(Expected(format!(\"no more documents in current node!\")));\n             }\n \n-            let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                try!(doc_at(self.parent.data, self.pos));\n+            let TaggedDoc { tag: r_tag, doc: r_doc } = try!(doc_at(self.parent.data, self.pos));\n             let r = if first_tag as usize <= r_tag && r_tag <= last_tag as usize {\n                 match r_tag - first_tag as usize {\n                     0 => doc_as_u8(r_doc) as u64,\n@@ -615,26 +668,29 @@ pub mod reader {\n                 }\n             } else {\n                 return Err(Expected(format!(\"expected EBML doc with tag {:?} through {:?} but \\\n-                                             found tag {:?}\", first_tag, last_tag, r_tag)));\n+                                             found tag {:?}\",\n+                                            first_tag,\n+                                            last_tag,\n+                                            r_tag)));\n             };\n             if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to \\\n-                                             {:#x}, parent to {:#x}\",\n-                                            r_doc.end, self.parent.end)));\n+                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n+                                             {:#x}\",\n+                                            r_doc.end,\n+                                            self.parent.end)));\n             }\n             self.pos = r_doc.end;\n             debug!(\"_next_int({:?}, {:?}) result={:?}\", first_tag, last_tag, r);\n             Ok(r)\n         }\n \n-        pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R> where\n-            F: FnOnce(&mut opaque::Decoder, Doc) -> DecodeResult<R>,\n+        pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R>\n+            where F: FnOnce(&mut opaque::Decoder, Doc) -> DecodeResult<R>\n         {\n             let doc = try!(self.next_doc(EsOpaque));\n \n             let result = {\n-                let mut opaque_decoder = opaque::Decoder::new(doc.data,\n-                                                              doc.start);\n+                let mut opaque_decoder = opaque::Decoder::new(doc.data, doc.start);\n                 try!(op(&mut opaque_decoder, doc))\n             };\n \n@@ -652,12 +708,22 @@ pub mod reader {\n \n     impl<'doc> serialize::Decoder for Decoder<'doc> {\n         type Error = Error;\n-        fn read_nil(&mut self) -> DecodeResult<()> { Ok(()) }\n+        fn read_nil(&mut self) -> DecodeResult<()> {\n+            Ok(())\n+        }\n \n-        fn read_u64(&mut self) -> DecodeResult<u64> { self._next_int(EsU8, EsU64) }\n-        fn read_u32(&mut self) -> DecodeResult<u32> { Ok(try!(self._next_int(EsU8, EsU32)) as u32) }\n-        fn read_u16(&mut self) -> DecodeResult<u16> { Ok(try!(self._next_int(EsU8, EsU16)) as u16) }\n-        fn read_u8(&mut self) -> DecodeResult<u8> { Ok(doc_as_u8(try!(self.next_doc(EsU8)))) }\n+        fn read_u64(&mut self) -> DecodeResult<u64> {\n+            self._next_int(EsU8, EsU64)\n+        }\n+        fn read_u32(&mut self) -> DecodeResult<u32> {\n+            Ok(try!(self._next_int(EsU8, EsU32)) as u32)\n+        }\n+        fn read_u16(&mut self) -> DecodeResult<u16> {\n+            Ok(try!(self._next_int(EsU8, EsU16)) as u16)\n+        }\n+        fn read_u8(&mut self) -> DecodeResult<u8> {\n+            Ok(doc_as_u8(try!(self.next_doc(EsU8))))\n+        }\n         fn read_uint(&mut self) -> DecodeResult<usize> {\n             let v = try!(self._next_int(EsU8, EsU64));\n             if v > (::std::usize::MAX as u64) {\n@@ -667,10 +733,18 @@ pub mod reader {\n             }\n         }\n \n-        fn read_i64(&mut self) -> DecodeResult<i64> { Ok(try!(self._next_int(EsI8, EsI64)) as i64) }\n-        fn read_i32(&mut self) -> DecodeResult<i32> { Ok(try!(self._next_int(EsI8, EsI32)) as i32) }\n-        fn read_i16(&mut self) -> DecodeResult<i16> { Ok(try!(self._next_int(EsI8, EsI16)) as i16) }\n-        fn read_i8(&mut self) -> DecodeResult<i8> { Ok(doc_as_u8(try!(self.next_doc(EsI8))) as i8) }\n+        fn read_i64(&mut self) -> DecodeResult<i64> {\n+            Ok(try!(self._next_int(EsI8, EsI64)) as i64)\n+        }\n+        fn read_i32(&mut self) -> DecodeResult<i32> {\n+            Ok(try!(self._next_int(EsI8, EsI32)) as i32)\n+        }\n+        fn read_i16(&mut self) -> DecodeResult<i16> {\n+            Ok(try!(self._next_int(EsI8, EsI16)) as i16)\n+        }\n+        fn read_i8(&mut self) -> DecodeResult<i8> {\n+            Ok(doc_as_u8(try!(self.next_doc(EsI8))) as i8)\n+        }\n         fn read_int(&mut self) -> DecodeResult<isize> {\n             let v = try!(self._next_int(EsI8, EsI64)) as i64;\n             if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n@@ -701,8 +775,8 @@ pub mod reader {\n         }\n \n         // Compound types:\n-        fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n             debug!(\"read_enum({})\", name);\n \n@@ -719,9 +793,8 @@ pub mod reader {\n             Ok(result)\n         }\n \n-        fn read_enum_variant<T, F>(&mut self, _: &[&str],\n-                                   mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>,\n+        fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n+            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n         {\n             debug!(\"read_enum_variant()\");\n             let idx = try!(self._next_sub());\n@@ -730,16 +803,15 @@ pub mod reader {\n             f(self, idx)\n         }\n \n-        fn read_enum_variant_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        fn read_enum_variant_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n             debug!(\"read_enum_variant_arg(idx={})\", idx);\n             f(self)\n         }\n \n-        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str],\n-                                          mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>,\n+        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n+            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n         {\n             debug!(\"read_enum_struct_variant()\");\n             let idx = try!(self._next_sub());\n@@ -752,84 +824,81 @@ pub mod reader {\n                                                 name: &str,\n                                                 idx: usize,\n                                                 f: F)\n-                                                -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+                                                -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n-                debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n+            debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n             f(self)\n         }\n \n-        fn read_struct<T, F>(&mut self, name: &str, _: usize, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        fn read_struct<T, F>(&mut self, name: &str, _: usize, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n             debug!(\"read_struct(name={})\", name);\n             f(self)\n         }\n \n-        fn read_struct_field<T, F>(&mut self, name: &str, idx: usize, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        fn read_struct_field<T, F>(&mut self, name: &str, idx: usize, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n             debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n             f(self)\n         }\n \n-        fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n             debug!(\"read_tuple()\");\n             self.read_seq(move |d, len| {\n                 if len == tuple_len {\n                     f(d)\n                 } else {\n-                    Err(Expected(format!(\"Expected tuple of length `{}`, \\\n-                                          found tuple of length `{}`\", tuple_len, len)))\n+                    Err(Expected(format!(\"Expected tuple of length `{}`, found tuple of length \\\n+                                          `{}`\",\n+                                         tuple_len,\n+                                         len)))\n                 }\n             })\n         }\n \n-        fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n             debug!(\"read_tuple_arg(idx={})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n-        fn read_tuple_struct<T, F>(&mut self, name: &str, len: usize, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        fn read_tuple_struct<T, F>(&mut self, name: &str, len: usize, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n             debug!(\"read_tuple_struct(name={})\", name);\n             self.read_tuple(len, f)\n         }\n \n-        fn read_tuple_struct_arg<T, F>(&mut self,\n-                                       idx: usize,\n-                                       f: F)\n-                                       -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n             debug!(\"read_tuple_struct_arg(idx={})\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n \n-        fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T> where\n-            F: FnMut(&mut Decoder<'doc>, bool) -> DecodeResult<T>,\n+        fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T>\n+            where F: FnMut(&mut Decoder<'doc>, bool) -> DecodeResult<T>\n         {\n             debug!(\"read_option()\");\n             self.read_enum(\"Option\", move |this| {\n                 this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n                     match idx {\n                         0 => f(this, false),\n                         1 => f(this, true),\n-                        _ => {\n-                            Err(Expected(format!(\"Expected None or Some\")))\n-                        }\n+                        _ => Err(Expected(format!(\"Expected None or Some\"))),\n                     }\n                 })\n             })\n         }\n \n-        fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>,\n+        fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n         {\n             debug!(\"read_seq()\");\n             self.push_doc(EsVec, move |d| {\n@@ -839,15 +908,15 @@ pub mod reader {\n             })\n         }\n \n-        fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n             debug!(\"read_seq_elt(idx={})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n-        fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>,\n+        fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n         {\n             debug!(\"read_map()\");\n             self.push_doc(EsMap, move |d| {\n@@ -857,15 +926,15 @@ pub mod reader {\n             })\n         }\n \n-        fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n             debug!(\"read_map_elt_key(idx={})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n-        fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n             debug!(\"read_map_elt_val(idx={})\", idx);\n             self.push_doc(EsMapVal, f)\n@@ -883,10 +952,9 @@ pub mod writer {\n     use std::io::{self, SeekFrom, Cursor};\n \n     use super::opaque;\n-    use super::{ EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n-        EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8,\n-        EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n-        EsOpaque, NUM_IMPLICIT_TAGS, NUM_TAGS };\n+    use super::{EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey, EsU64, EsU32, EsU16,\n+                EsU8, EsI64, EsI32, EsI16, EsI8, EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n+                EsOpaque, NUM_IMPLICIT_TAGS, NUM_TAGS};\n \n     use serialize;\n \n@@ -906,38 +974,41 @@ pub mod writer {\n         } else if 0x100 <= n && n < NUM_TAGS {\n             w.write_all(&[0xf0 | (n >> 8) as u8, n as u8])\n         } else {\n-            Err(io::Error::new(io::ErrorKind::Other,\n-                               &format!(\"invalid tag: {}\", n)[..]))\n+            Err(io::Error::new(io::ErrorKind::Other, &format!(\"invalid tag: {}\", n)[..]))\n         }\n     }\n \n     fn write_sized_vuint<W: Write>(w: &mut W, n: usize, size: usize) -> EncodeResult {\n         match size {\n             1 => w.write_all(&[0x80 | (n as u8)]),\n             2 => w.write_all(&[0x40 | ((n >> 8) as u8), n as u8]),\n-            3 => w.write_all(&[0x20 | ((n >> 16) as u8), (n >> 8) as u8,\n-                            n as u8]),\n-            4 => w.write_all(&[0x10 | ((n >> 24) as u8), (n >> 16) as u8,\n-                            (n >> 8) as u8, n as u8]),\n-            _ => Err(io::Error::new(io::ErrorKind::Other,\n-                                    &format!(\"isize too big: {}\", n)[..]))\n+            3 => w.write_all(&[0x20 | ((n >> 16) as u8), (n >> 8) as u8, n as u8]),\n+            4 => w.write_all(&[0x10 | ((n >> 24) as u8), (n >> 16) as u8, (n >> 8) as u8, n as u8]),\n+            _ => Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..])),\n         }\n     }\n \n     pub fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n-        if n < 0x7f { return write_sized_vuint(w, n, 1); }\n-        if n < 0x4000 { return write_sized_vuint(w, n, 2); }\n-        if n < 0x200000 { return write_sized_vuint(w, n, 3); }\n-        if n < 0x10000000 { return write_sized_vuint(w, n, 4); }\n-        Err(io::Error::new(io::ErrorKind::Other,\n-                           &format!(\"isize too big: {}\", n)[..]))\n+        if n < 0x7f {\n+            return write_sized_vuint(w, n, 1);\n+        }\n+        if n < 0x4000 {\n+            return write_sized_vuint(w, n, 2);\n+        }\n+        if n < 0x200000 {\n+            return write_sized_vuint(w, n, 3);\n+        }\n+        if n < 0x10000000 {\n+            return write_sized_vuint(w, n, 4);\n+        }\n+        Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..]))\n     }\n \n     impl<'a> Encoder<'a> {\n         pub fn new(w: &'a mut Cursor<Vec<u8>>) -> Encoder<'a> {\n             Encoder {\n                 writer: w,\n-                size_positions: vec!(),\n+                size_positions: vec![],\n                 relax_limit: 0,\n             }\n         }\n@@ -970,7 +1041,7 @@ pub mod writer {\n                 let mut buf = [0u8; RELAX_MAX_SIZE];\n                 {\n                     let last_size_pos = last_size_pos as usize;\n-                    let data = &self.writer.get_ref()[last_size_pos+4..cur_pos as usize];\n+                    let data = &self.writer.get_ref()[last_size_pos + 4..cur_pos as usize];\n                     buf[..size].clone_from_slice(data);\n                 }\n \n@@ -987,8 +1058,8 @@ pub mod writer {\n             Ok(())\n         }\n \n-        pub fn wr_tag<F>(&mut self, tag_id: usize, blk: F) -> EncodeResult where\n-            F: FnOnce() -> EncodeResult,\n+        pub fn wr_tag<F>(&mut self, tag_id: usize, blk: F) -> EncodeResult\n+            where F: FnOnce() -> EncodeResult\n         {\n             try!(self.start_tag(tag_id));\n             try!(blk());\n@@ -1006,12 +1077,12 @@ pub mod writer {\n             let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n             // tagged integers are emitted in big-endian, with no\n             // leading zeros.\n-            let leading_zero_bytes = v.leading_zeros()/8;\n+            let leading_zero_bytes = v.leading_zeros() / 8;\n             self.wr_tagged_bytes(tag_id, &bytes[leading_zero_bytes as usize..])\n         }\n \n         #[inline]\n-        pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32)  -> EncodeResult {\n+        pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n             self.wr_tagged_u64(tag_id, v as u64)\n         }\n \n@@ -1060,7 +1131,7 @@ pub mod writer {\n             self.wr_tagged_raw_bytes(tag_id, &bytes)\n         }\n \n-        fn wr_tagged_raw_u32(&mut self, tag_id: usize, v: u32)  -> EncodeResult{\n+        fn wr_tagged_raw_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n             let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_raw_bytes(tag_id, &bytes)\n         }\n@@ -1120,13 +1191,12 @@ pub mod writer {\n                 self.wr_tagged_raw_u32(EsSub32 as usize, v as u32)\n             } else {\n                 Err(io::Error::new(io::ErrorKind::Other,\n-                                   &format!(\"length or variant id too big: {}\",\n-                                            v)[..]))\n+                                   &format!(\"length or variant id too big: {}\", v)[..]))\n             }\n         }\n \n-        pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut opaque::Encoder) -> EncodeResult,\n+        pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult\n+            where F: FnOnce(&mut opaque::Encoder) -> EncodeResult\n         {\n             try!(self.start_tag(EsOpaque as usize));\n \n@@ -1223,27 +1293,23 @@ pub mod writer {\n             self.wr_tagged_str(EsStr as usize, v)\n         }\n \n-        fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             try!(self.start_tag(EsEnum as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_enum_variant<F>(&mut self,\n-                                _: &str,\n-                                v_id: usize,\n-                                _: usize,\n-                                f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_enum_variant<F>(&mut self, _: &str, v_id: usize, _: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             try!(self._emit_tagged_sub(v_id));\n             f(self)\n         }\n \n-        fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             f(self)\n         }\n@@ -1252,72 +1318,70 @@ pub mod writer {\n                                        v_name: &str,\n                                        v_id: usize,\n                                        cnt: usize,\n-                                       f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+                                       f: F)\n+                                       -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n \n-        fn emit_enum_struct_variant_field<F>(&mut self,\n-                                             _: &str,\n-                                             idx: usize,\n-                                             f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             f(self)\n         }\n \n-        fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             f(self)\n         }\n \n-        fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_option<F>(&mut self, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             self.emit_enum(\"Option\", f)\n         }\n         fn emit_option_none(&mut self) -> EncodeResult {\n             self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n         }\n-        fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n \n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n-        fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             if len == 0 {\n                 // empty vector optimization\n@@ -1330,17 +1394,17 @@ pub mod writer {\n             self.end_tag()\n         }\n \n-        fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n \n             try!(self.start_tag(EsVecElt as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             if len == 0 {\n                 // empty map optimization\n@@ -1353,17 +1417,17 @@ pub mod writer {\n             self.end_tag()\n         }\n \n-        fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n \n             try!(self.start_tag(EsMapKey as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+        fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n             try!(self.start_tag(EsMapVal as usize));\n             try!(f(self));\n@@ -1461,12 +1525,14 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_A_aligned(b: &mut Bencher) {\n-        let data = (0..4*100).map(|i| {\n-            match i % 2 {\n-              0 => 0x80,\n-              _ => i as u8,\n-            }\n-        }).collect::<Vec<_>>();\n+        let data = (0..4 * 100)\n+                       .map(|i| {\n+                           match i % 2 {\n+                               0 => 0x80,\n+                               _ => i as u8,\n+                           }\n+                       })\n+                       .collect::<Vec<_>>();\n         let mut sum = 0;\n         b.iter(|| {\n             let mut i = 0;\n@@ -1479,12 +1545,14 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_A_unaligned(b: &mut Bencher) {\n-        let data = (0..4*100+1).map(|i| {\n-            match i % 2 {\n-              1 => 0x80,\n-              _ => i as u8\n-            }\n-        }).collect::<Vec<_>>();\n+        let data = (0..4 * 100 + 1)\n+                       .map(|i| {\n+                           match i % 2 {\n+                               1 => 0x80,\n+                               _ => i as u8,\n+                           }\n+                       })\n+                       .collect::<Vec<_>>();\n         let mut sum = 0;\n         b.iter(|| {\n             let mut i = 1;\n@@ -1497,13 +1565,15 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_D_aligned(b: &mut Bencher) {\n-        let data = (0..4*100).map(|i| {\n-            match i % 4 {\n-              0 => 0x10,\n-              3 => i as u8,\n-              _ => 0\n-            }\n-        }).collect::<Vec<_>>();\n+        let data = (0..4 * 100)\n+                       .map(|i| {\n+                           match i % 4 {\n+                               0 => 0x10,\n+                               3 => i as u8,\n+                               _ => 0,\n+                           }\n+                       })\n+                       .collect::<Vec<_>>();\n         let mut sum = 0;\n         b.iter(|| {\n             let mut i = 0;\n@@ -1516,13 +1586,15 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_D_unaligned(b: &mut Bencher) {\n-        let data = (0..4*100+1).map(|i| {\n-            match i % 4 {\n-              1 => 0x10,\n-              0 => i as u8,\n-              _ => 0\n-            }\n-        }).collect::<Vec<_>>();\n+        let data = (0..4 * 100 + 1)\n+                       .map(|i| {\n+                           match i % 4 {\n+                               1 => 0x10,\n+                               0 => i as u8,\n+                               _ => 0,\n+                           }\n+                       })\n+                       .collect::<Vec<_>>();\n         let mut sum = 0;\n         b.iter(|| {\n             let mut i = 1;"}, {"sha": "531a25dc1b766d8047e0e4ee47bd8a044e8825b1", "filename": "src/librbml/opaque.rs", "status": "modified", "additions": 167, "deletions": 173, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/c66e88289e6ffa8be4701933369820613b9d345d/src%2Flibrbml%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66e88289e6ffa8be4701933369820613b9d345d/src%2Flibrbml%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fopaque.rs?ref=c66e88289e6ffa8be4701933369820613b9d345d", "patch": "@@ -10,24 +10,21 @@\n \n use Error as DecodeError;\n use writer::EncodeResult;\n-use leb128::{read_signed_leb128, read_unsigned_leb128, write_signed_leb128,\n-             write_unsigned_leb128};\n+use leb128::{read_signed_leb128, read_unsigned_leb128, write_signed_leb128, write_unsigned_leb128};\n use std::io::{self, Write};\n use serialize;\n \n-//=-----------------------------------------------------------------------------\n+// -----------------------------------------------------------------------------\n // Encoder\n-//=-----------------------------------------------------------------------------\n+// -----------------------------------------------------------------------------\n \n pub struct Encoder<'a> {\n     pub cursor: &'a mut io::Cursor<Vec<u8>>,\n }\n \n impl<'a> Encoder<'a> {\n     pub fn new(cursor: &'a mut io::Cursor<Vec<u8>>) -> Encoder<'a> {\n-        Encoder {\n-            cursor: cursor\n-        }\n+        Encoder { cursor: cursor }\n     }\n }\n \n@@ -101,7 +98,11 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     }\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-        self.emit_u8(if v { 1 } else { 0 })\n+        self.emit_u8(if v {\n+            1\n+        } else {\n+            0\n+        })\n     }\n \n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n@@ -125,84 +126,84 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     }\n \n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult {\n+        where F: FnOnce(&mut Self) -> EncodeResult\n+    {\n         f(self)\n     }\n \n     fn emit_enum_variant<F>(&mut self,\n                             _v_name: &str,\n                             v_id: usize,\n                             _len: usize,\n-                            f: F) -> EncodeResult\n+                            f: F)\n+                            -> EncodeResult\n         where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         try!(self.emit_uint(v_id));\n         f(self)\n     }\n \n-    fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         f(self)\n     }\n \n     fn emit_enum_struct_variant<F>(&mut self,\n-                                       v_name: &str,\n-                                       v_id: usize,\n-                                       cnt: usize,\n-                                       f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+                                   v_name: &str,\n+                                   v_id: usize,\n+                                   cnt: usize,\n+                                   f: F)\n+                                   -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         self.emit_enum_variant(v_name, v_id, cnt, f)\n     }\n \n-    fn emit_enum_struct_variant_field<F>(&mut self,\n-                                         _: &str,\n-                                         idx: usize,\n-                                         f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         f(self)\n     }\n \n-    fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         f(self)\n     }\n \n-    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         self.emit_seq(len, f)\n     }\n \n-    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         self.emit_seq(len, f)\n     }\n \n-    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_option<F>(&mut self, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         self.emit_enum(\"Option\", f)\n     }\n@@ -211,40 +212,40 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n     }\n \n-    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         self.emit_enum_variant(\"Some\", 1, 1, f)\n     }\n \n-    fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         try!(self.emit_uint(len));\n         f(self)\n     }\n \n-    fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         f(self)\n     }\n \n-    fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         try!(self.emit_uint(len));\n         f(self)\n     }\n \n-    fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         f(self)\n     }\n \n-    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n         f(self)\n     }\n@@ -256,15 +257,13 @@ impl<'a> Encoder<'a> {\n     }\n \n     pub fn from_rbml<'b: 'c, 'c>(rbml: &'c mut ::writer::Encoder<'b>) -> Encoder<'c> {\n-        Encoder {\n-            cursor: rbml.writer\n-        }\n+        Encoder { cursor: rbml.writer }\n     }\n }\n \n-//=-----------------------------------------------------------------------------\n+// -----------------------------------------------------------------------------\n // Decoder\n-//=-----------------------------------------------------------------------------\n+// -----------------------------------------------------------------------------\n \n pub struct Decoder<'a> {\n     pub data: &'a [u8],\n@@ -275,7 +274,7 @@ impl<'a> Decoder<'a> {\n     pub fn new(data: &'a [u8], position: usize) -> Decoder<'a> {\n         Decoder {\n             data: data,\n-            position: position\n+            position: position,\n         }\n     }\n \n@@ -349,9 +348,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     fn read_i8(&mut self) -> Result<i8, Self::Error> {\n         let as_u8 = self.data[self.position];\n         self.position += 1;\n-        unsafe {\n-            Ok(::std::mem::transmute(as_u8))\n-        }\n+        unsafe { Ok(::std::mem::transmute(as_u8)) }\n     }\n \n     fn read_int(&mut self) -> Result<isize, Self::Error> {\n@@ -380,37 +377,32 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n \n     fn read_str(&mut self) -> Result<String, Self::Error> {\n         let len = try!(self.read_uint());\n-        let s = ::std::str::from_utf8(&self.data[self.position .. self.position + len]).unwrap();\n+        let s = ::std::str::from_utf8(&self.data[self.position..self.position + len]).unwrap();\n         self.position += len;\n         Ok(s.to_string())\n     }\n \n-    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    fn read_enum_variant<T, F>(&mut self,\n-                               _: &[&str],\n-                               mut f: F)\n-                               -> Result<T, Self::Error>\n-        where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>,\n+    fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> Result<T, Self::Error>\n+        where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n     {\n         let disr = try!(self.read_uint());\n         f(self, disr)\n     }\n \n-    fn read_enum_variant_arg<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    fn read_enum_variant_arg<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    fn read_enum_struct_variant<T, F>(&mut self,\n-                                      _: &[&str],\n-                                      mut f: F) -> Result<T, Self::Error>\n-        where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>,\n+    fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> Result<T, Self::Error>\n+        where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n     {\n         let disr = try!(self.read_uint());\n         f(self, disr)\n@@ -420,68 +412,59 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n                                             _name: &str,\n                                             _idx: usize,\n                                             f: F)\n-                                            -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+                                            -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    fn read_struct<T, F>(&mut self, _name: &str, _: usize, f: F) -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    fn read_struct<T, F>(&mut self, _name: &str, _: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    fn read_struct_field<T, F>(&mut self,\n-                               _name: &str,\n-                               _idx: usize, f: F)\n-                               -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    fn read_struct_field<T, F>(&mut self, _name: &str, _idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n     {\n         self.read_seq(move |d, len| {\n             if len == tuple_len {\n                 f(d)\n             } else {\n                 let err = format!(\"Invalid tuple length. Expected {}, found {}\",\n-                                   tuple_len,\n-                                   len);\n+                                  tuple_len,\n+                                  len);\n                 Err(DecodeError::Expected(err))\n             }\n         })\n     }\n \n-    fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n     {\n         self.read_seq_elt(idx, f)\n     }\n \n-    fn read_tuple_struct<T, F>(&mut self,\n-                               _name: &str,\n-                               len: usize, f: F)\n-                               -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    fn read_tuple_struct<T, F>(&mut self, _name: &str, len: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n     {\n         self.read_tuple(len, f)\n     }\n \n-    fn read_tuple_struct_arg<T, F>(&mut self,\n-                                   idx: usize,\n-                                   f: F)\n-                                   -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n     {\n         self.read_tuple_arg(idx, f)\n     }\n \n-    fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error> where\n-        F: FnMut(&mut Decoder<'a>, bool) -> Result<T, Self::Error>,\n+    fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error>\n+        where F: FnMut(&mut Decoder<'a>, bool) -> Result<T, Self::Error>\n     {\n         self.read_enum(\"Option\", move |this| {\n             this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n@@ -497,34 +480,34 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         })\n     }\n \n-    fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>,\n+    fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n     {\n         let len = try!(self.read_uint());\n         f(self, len)\n     }\n \n-    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>,\n+    fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n     {\n         let len = try!(self.read_uint());\n         f(self, len)\n     }\n \n-    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error> where\n-        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n@@ -538,7 +521,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n #[cfg(test)]\n mod tests {\n     use serialize::{Encodable, Decodable};\n-    use std::io::{Cursor};\n+    use std::io::Cursor;\n     use std::fmt::Debug;\n     use super::{Encoder, Decoder};\n \n@@ -566,7 +549,7 @@ mod tests {\n     }\n \n \n-    fn check_round_trip<T: Encodable+Decodable+PartialEq+Debug>(values: Vec<T>) {\n+    fn check_round_trip<T: Encodable + Decodable + PartialEq + Debug>(values: Vec<T>) {\n         let mut cursor = Cursor::new(Vec::new());\n \n         for value in &values {\n@@ -591,15 +574,15 @@ mod tests {\n     #[test]\n     fn test_u8() {\n         let mut vec = vec![];\n-        for i in ::std::u8::MIN .. ::std::u8::MAX {\n+        for i in ::std::u8::MIN..::std::u8::MAX {\n             vec.push(i);\n         }\n         check_round_trip(vec);\n     }\n \n     #[test]\n     fn test_u16() {\n-        for i in ::std::u16::MIN .. ::std::u16::MAX {\n+        for i in ::std::u16::MIN..::std::u16::MAX {\n             check_round_trip(vec![1, 2, 3, i, i, i]);\n         }\n     }\n@@ -622,15 +605,15 @@ mod tests {\n     #[test]\n     fn test_i8() {\n         let mut vec = vec![];\n-        for i in ::std::i8::MIN .. ::std::i8::MAX {\n+        for i in ::std::i8::MIN..::std::i8::MAX {\n             vec.push(i);\n         }\n         check_round_trip(vec);\n     }\n \n     #[test]\n     fn test_i16() {\n-        for i in ::std::i16::MIN .. ::std::i16::MAX {\n+        for i in ::std::i16::MIN..::std::i16::MAX {\n             check_round_trip(vec![-1, 2, -3, i, i, i, 2]);\n         }\n     }\n@@ -658,17 +641,17 @@ mod tests {\n     #[test]\n     fn test_f32() {\n         let mut vec = vec![];\n-        for i in -100 .. 100 {\n-            vec.push( (i as f32) / 3.0 );\n+        for i in -100..100 {\n+            vec.push((i as f32) / 3.0);\n         }\n         check_round_trip(vec);\n     }\n \n     #[test]\n     fn test_f64() {\n         let mut vec = vec![];\n-        for i in -100 .. 100 {\n-            vec.push( (i as f64) / 3.0 );\n+        for i in -100..100 {\n+            vec.push((i as f64) / 3.0);\n         }\n         check_round_trip(vec);\n     }\n@@ -681,14 +664,13 @@ mod tests {\n \n     #[test]\n     fn test_string() {\n-        let vec = vec![\n-            \"abcbu\u00d6eiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n-            \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n-            \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpapmaebn\".to_string(),\n-            \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmeabpnvapeapmaebn\".to_string(),\n-            \"abcbu\u00d6ganei\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n-            \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpmaebn\".to_string(),\n-            \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5nvapeapmaebn\".to_string()];\n+        let vec = vec![\"abcbu\u00d6eiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n+                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n+                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpapmaebn\".to_string(),\n+                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmeabpnvapeapmaebn\".to_string(),\n+                       \"abcbu\u00d6ganei\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n+                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpmaebn\".to_string(),\n+                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5nvapeapmaebn\".to_string()];\n \n         check_round_trip(vec);\n     }\n@@ -720,70 +702,82 @@ mod tests {\n     #[test]\n     fn test_struct() {\n         check_round_trip(vec![Struct {\n-            a: (),\n-            b: 10,\n-            c: 11,\n-            d: 12,\n-            e: 13,\n-            f: 14,\n-\n-            g: 15,\n-            h: 16,\n-            i: 17,\n-            j: 18,\n-            k: 19,\n-\n-            l: 'x',\n-            m: \"abc\".to_string(),\n-            n: 20.5,\n-            o: 21.5,\n-            p: false,\n-            q: None,\n-        }]);\n+                                  a: (),\n+                                  b: 10,\n+                                  c: 11,\n+                                  d: 12,\n+                                  e: 13,\n+                                  f: 14,\n+\n+                                  g: 15,\n+                                  h: 16,\n+                                  i: 17,\n+                                  j: 18,\n+                                  k: 19,\n+\n+                                  l: 'x',\n+                                  m: \"abc\".to_string(),\n+                                  n: 20.5,\n+                                  o: 21.5,\n+                                  p: false,\n+                                  q: None,\n+                              }]);\n \n         check_round_trip(vec![Struct {\n-            a: (),\n-            b: 101,\n-            c: 111,\n-            d: 121,\n-            e: 131,\n-            f: 141,\n-\n-            g: -15,\n-            h: -16,\n-            i: -17,\n-            j: -18,\n-            k: -19,\n-\n-            l: 'y',\n-            m: \"def\".to_string(),\n-            n: -20.5,\n-            o: -21.5,\n-            p: true,\n-            q: Some(1234567),\n-        }]);\n+                                  a: (),\n+                                  b: 101,\n+                                  c: 111,\n+                                  d: 121,\n+                                  e: 131,\n+                                  f: 141,\n+\n+                                  g: -15,\n+                                  h: -16,\n+                                  i: -17,\n+                                  j: -18,\n+                                  k: -19,\n+\n+                                  l: 'y',\n+                                  m: \"def\".to_string(),\n+                                  n: -20.5,\n+                                  o: -21.5,\n+                                  p: true,\n+                                  q: Some(1234567),\n+                              }]);\n     }\n \n     #[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n     enum Enum {\n         Variant1,\n         Variant2(usize, f32),\n-        Variant3 { a: i32, b: char, c: bool }\n+        Variant3 {\n+            a: i32,\n+            b: char,\n+            c: bool,\n+        },\n     }\n \n     #[test]\n     fn test_enum() {\n         check_round_trip(vec![Enum::Variant1,\n                               Enum::Variant2(1, 2.5),\n-                              Enum::Variant3 { a: 3, b: 'b', c: false },\n-                              Enum::Variant3 { a: -4, b: 'f', c: true }]);\n+                              Enum::Variant3 {\n+                                  a: 3,\n+                                  b: 'b',\n+                                  c: false,\n+                              },\n+                              Enum::Variant3 {\n+                                  a: -4,\n+                                  b: 'f',\n+                                  c: true,\n+                              }]);\n     }\n \n     #[test]\n     fn test_sequence() {\n         let mut vec = vec![];\n-        for i in -100i64 .. 100i64 {\n-            vec.push(i*100000);\n+        for i in -100i64..100i64 {\n+            vec.push(i * 100000);\n         }\n \n         check_round_trip(vec![vec]);\n@@ -793,8 +787,8 @@ mod tests {\n     fn test_hash_map() {\n         use std::collections::HashMap;\n         let mut map = HashMap::new();\n-        for i in -100i64 .. 100i64 {\n-            map.insert(i*100000, i*10000);\n+        for i in -100i64..100i64 {\n+            map.insert(i * 100000, i * 10000);\n         }\n \n         check_round_trip(vec![map]);"}]}