{"sha": "98450d0dade3c9a1b91a3384426cc4e824b82052", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NDUwZDBkYWRlM2M5YTFiOTFhMzM4NDQyNmNjNGU4MjRiODIwNTI=", "commit": {"author": {"name": "Kevin Atkinson", "email": "kevina@cs.utah.edu", "date": "2012-01-26T23:34:05Z"}, "committer": {"name": "Kevin Atkinson", "email": "kevina@cs.utah.edu", "date": "2012-02-04T03:28:11Z"}, "message": "Rename AST builders to use uniform naming scheme.  Also add a few more.", "tree": {"sha": "7e2091a34f7b6a9b90ebbacf3ce8c44f46cc3282", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e2091a34f7b6a9b90ebbacf3ce8c44f46cc3282"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98450d0dade3c9a1b91a3384426cc4e824b82052", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98450d0dade3c9a1b91a3384426cc4e824b82052", "html_url": "https://github.com/rust-lang/rust/commit/98450d0dade3c9a1b91a3384426cc4e824b82052", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98450d0dade3c9a1b91a3384426cc4e824b82052/comments", "author": {"login": "kevina", "id": 1271492, "node_id": "MDQ6VXNlcjEyNzE0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1271492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kevina", "html_url": "https://github.com/kevina", "followers_url": "https://api.github.com/users/kevina/followers", "following_url": "https://api.github.com/users/kevina/following{/other_user}", "gists_url": "https://api.github.com/users/kevina/gists{/gist_id}", "starred_url": "https://api.github.com/users/kevina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kevina/subscriptions", "organizations_url": "https://api.github.com/users/kevina/orgs", "repos_url": "https://api.github.com/users/kevina/repos", "events_url": "https://api.github.com/users/kevina/events{/privacy}", "received_events_url": "https://api.github.com/users/kevina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kevina", "id": 1271492, "node_id": "MDQ6VXNlcjEyNzE0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1271492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kevina", "html_url": "https://github.com/kevina", "followers_url": "https://api.github.com/users/kevina/followers", "following_url": "https://api.github.com/users/kevina/following{/other_user}", "gists_url": "https://api.github.com/users/kevina/gists{/gist_id}", "starred_url": "https://api.github.com/users/kevina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kevina/subscriptions", "organizations_url": "https://api.github.com/users/kevina/orgs", "repos_url": "https://api.github.com/users/kevina/repos", "events_url": "https://api.github.com/users/kevina/events{/privacy}", "received_events_url": "https://api.github.com/users/kevina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ef53382aeac2de7e6dcc43c156312d2e68c15e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ef53382aeac2de7e6dcc43c156312d2e68c15e4", "html_url": "https://github.com/rust-lang/rust/commit/5ef53382aeac2de7e6dcc43c156312d2e68c15e4"}], "stats": {"total": 114, "additions": 68, "deletions": 46}, "files": [{"sha": "ec7ff4707cdb0db90b7c3073c4d0652a914b4b1a", "filename": "src/comp/syntax/ext/build.rs", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/98450d0dade3c9a1b91a3384426cc4e824b82052/src%2Fcomp%2Fsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98450d0dade3c9a1b91a3384426cc4e824b82052/src%2Fcomp%2Fsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbuild.rs?ref=98450d0dade3c9a1b91a3384426cc4e824b82052", "patch": "@@ -6,42 +6,78 @@ import syntax::ext::base::ext_ctxt;\n // NOTE: Moved from fmt.rs which had this fixme:\n // FIXME: Cleanup the naming of these functions\n \n-fn make_new_lit(cx: ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n+fn mk_lit(cx: ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n     let sp_lit = @{node: lit, span: sp};\n     ret @{id: cx.next_id(), node: ast::expr_lit(sp_lit), span: sp};\n }\n-fn make_new_str(cx: ext_ctxt, sp: span, s: str) -> @ast::expr {\n+fn mk_str(cx: ext_ctxt, sp: span, s: str) -> @ast::expr {\n     let lit = ast::lit_str(s);\n-    ret make_new_lit(cx, sp, lit);\n+    ret mk_lit(cx, sp, lit);\n }\n-fn make_new_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {\n+fn mk_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {\n     let lit = ast::lit_int(i as i64, ast::ty_i);\n-    ret make_new_lit(cx, sp, lit);\n+    ret mk_lit(cx, sp, lit);\n }\n-fn make_new_uint(cx: ext_ctxt, sp: span, u: uint) -> @ast::expr {\n+fn mk_uint(cx: ext_ctxt, sp: span, u: uint) -> @ast::expr {\n     let lit = ast::lit_uint(u as u64, ast::ty_u);\n-    ret make_new_lit(cx, sp, lit);\n+    ret mk_lit(cx, sp, lit);\n }\n-fn make_add_expr(cx: ext_ctxt, sp: span, lhs: @ast::expr, rhs: @ast::expr)\n+fn mk_binary(cx: ext_ctxt, sp: span, op: ast::binop,\n+             lhs: @ast::expr, rhs: @ast::expr)\n    -> @ast::expr {\n-    let binexpr = ast::expr_binary(ast::add, lhs, rhs);\n+    let binexpr = ast::expr_binary(op, lhs, rhs);\n     ret @{id: cx.next_id(), node: binexpr, span: sp};\n }\n-fn make_path_expr(cx: ext_ctxt, sp: span, idents: [ast::ident]) ->\n-   @ast::expr {\n+fn mk_unary(cx: ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n+    -> @ast::expr {\n+    let expr = ast::expr_unary(op, e);\n+    ret @{id: cx.next_id(), node: expr, span: sp};\n+}\n+fn mk_path(cx: ext_ctxt, sp: span, idents: [ast::ident]) ->\n+    @ast::expr {\n     let path = {global: false, idents: idents, types: []};\n     let sp_path = @{node: path, span: sp};\n     let pathexpr = ast::expr_path(sp_path);\n     ret @{id: cx.next_id(), node: pathexpr, span: sp};\n }\n-fn make_vec_expr(cx: ext_ctxt, sp: span, exprs: [@ast::expr]) ->\n+fn mk_access_(cx: ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n+    -> @ast::expr {\n+    let expr = ast::expr_field(p, m, []);\n+    ret @{id: cx.next_id(), node: expr, span: sp};\n+}\n+fn mk_access(cx: ext_ctxt, sp: span, p: [ast::ident], m: ast::ident)\n+    -> @ast::expr {\n+    let pathexpr = mk_path(cx, sp, p);\n+    ret mk_access_(cx, sp, pathexpr, m);\n+}\n+fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n+            args: [@ast::expr]) -> @ast::expr {\n+    let callexpr = ast::expr_call(fn_expr, args, false);\n+    ret @{id: cx.next_id(), node: callexpr, span: sp};\n+}\n+fn mk_call(cx: ext_ctxt, sp: span, fn_path: [ast::ident],\n+             args: [@ast::expr]) -> @ast::expr {\n+    let pathexpr = mk_path(cx, sp, fn_path);\n+    ret mk_call_(cx, sp, pathexpr, args);\n+}\n+// e = expr, t = type\n+fn mk_vec_e(cx: ext_ctxt, sp: span, exprs: [@ast::expr]) ->\n    @ast::expr {\n     let vecexpr = ast::expr_vec(exprs, ast::imm);\n     ret @{id: cx.next_id(), node: vecexpr, span: sp};\n }\n-fn make_call(cx: ext_ctxt, sp: span, fn_path: [ast::ident],\n-             args: [@ast::expr]) -> @ast::expr {\n-    let pathexpr = make_path_expr(cx, sp, fn_path);\n-    let callexpr = ast::expr_call(pathexpr, args, false);\n-    ret @{id: cx.next_id(), node: callexpr, span: sp};\n+fn mk_rec_e(cx: ext_ctxt, sp: span,\n+            fields: [{ident: ast::ident, ex: @ast::expr}]) ->\n+    @ast::expr {\n+    let astfields: [ast::field] = [];\n+    for field: {ident: ast::ident, ex: @ast::expr} in fields {\n+        let ident = field.ident;\n+        let val = field.ex;\n+        let astfield =\n+            {node: {mut: ast::imm, ident: ident, expr: val}, span: sp};\n+        astfields += [astfield];\n+    }\n+    let recexpr = ast::expr_rec(astfields, option::none::<@ast::expr>);\n+    ret @{id: cx.next_id(), node: recexpr, span: sp};\n }\n+"}, {"sha": "9deceaeccf7909fc45ce7c8665cf1fbb72605854", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98450d0dade3c9a1b91a3384426cc4e824b82052/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98450d0dade3c9a1b91a3384426cc4e824b82052/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=98450d0dade3c9a1b91a3384426cc4e824b82052", "patch": "@@ -56,7 +56,7 @@ fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n fn expand_qquote(cx: ext_ctxt, sp: span, e: @ast::expr) -> ast::expr_ {\n     import syntax::ext::build::*;\n     let str = codemap::span_to_snippet(sp, cx.session().parse_sess.cm);\n-    let expr = make_new_str(cx, e.span, str);\n+    let expr = mk_str(cx, e.span, str);\n     ret expr.node;\n }\n "}, {"sha": "84994c0e5dca0d15df6fb2997a2aa7f0bbc16dcb", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/98450d0dade3c9a1b91a3384426cc4e824b82052/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98450d0dade3c9a1b91a3384426cc4e824b82052/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=98450d0dade3c9a1b91a3384426cc4e824b82052", "patch": "@@ -45,26 +45,12 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: @ast::expr,\n // NOTE: Moved many of the common ones to build.rs --kevina\n fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n    -> @ast::expr {\n-    fn make_rec_expr(cx: ext_ctxt, sp: span,\n-                     fields: [{ident: ast::ident, ex: @ast::expr}]) ->\n-       @ast::expr {\n-        let astfields: [ast::field] = [];\n-        for field: {ident: ast::ident, ex: @ast::expr} in fields {\n-            let ident = field.ident;\n-            let val = field.ex;\n-            let astfield =\n-                {node: {mut: ast::imm, ident: ident, expr: val}, span: sp};\n-            astfields += [astfield];\n-        }\n-        let recexpr = ast::expr_rec(astfields, option::none::<@ast::expr>);\n-        ret @{id: cx.next_id(), node: recexpr, span: sp};\n-    }\n     fn make_path_vec(_cx: ext_ctxt, ident: ast::ident) -> [ast::ident] {\n         ret [\"extfmt\", \"rt\", ident];\n     }\n     fn make_rt_path_expr(cx: ext_ctxt, sp: span, ident: str) -> @ast::expr {\n         let path = make_path_vec(cx, ident);\n-        ret make_path_expr(cx, sp, path);\n+        ret mk_path(cx, sp, path);\n     }\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n@@ -90,18 +76,18 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n             if vec::len::<@ast::expr>(flagexprs) == 0u {\n                 flagexprs += [make_rt_path_expr(cx, sp, \"flag_none\")];\n             }\n-            ret make_vec_expr(cx, sp, flagexprs);\n+            ret mk_vec_e(cx, sp, flagexprs);\n         }\n         fn make_count(cx: ext_ctxt, sp: span, cnt: count) -> @ast::expr {\n             alt cnt {\n               count_implied {\n                 ret make_rt_path_expr(cx, sp, \"count_implied\");\n               }\n               count_is(c) {\n-                let count_lit = make_new_int(cx, sp, c);\n+                let count_lit = mk_int(cx, sp, c);\n                 let count_is_path = make_path_vec(cx, \"count_is\");\n                 let count_is_args = [count_lit];\n-                ret make_call(cx, sp, count_is_path, count_is_args);\n+                ret mk_call(cx, sp, count_is_path, count_is_args);\n               }\n               _ { cx.span_unimpl(sp, \"unimplemented #fmt conversion\"); }\n             }\n@@ -124,11 +110,11 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n         fn make_conv_rec(cx: ext_ctxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n-            ret make_rec_expr(cx, sp,\n-                              [{ident: \"flags\", ex: flags_expr},\n-                               {ident: \"width\", ex: width_expr},\n-                               {ident: \"precision\", ex: precision_expr},\n-                               {ident: \"ty\", ex: ty_expr}]);\n+            ret mk_rec_e(cx, sp,\n+                         [{ident: \"flags\", ex: flags_expr},\n+                          {ident: \"width\", ex: width_expr},\n+                          {ident: \"precision\", ex: precision_expr},\n+                          {ident: \"ty\", ex: ty_expr}]);\n         }\n         let rt_conv_flags = make_flags(cx, sp, cnv.flags);\n         let rt_conv_width = make_count(cx, sp, cnv.width);\n@@ -143,7 +129,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n         let path = make_path_vec(cx, fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = [cnv_expr, arg];\n-        ret make_call(cx, arg.span, path, args);\n+        ret mk_call(cx, arg.span, path, args);\n     }\n     fn make_new_conv(cx: ext_ctxt, sp: span, cnv: conv, arg: @ast::expr) ->\n        @ast::expr {\n@@ -272,13 +258,13 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n     }\n     let fmt_sp = args[0].span;\n     let n = 0u;\n-    let tmp_expr = make_new_str(cx, sp, \"\");\n+    let tmp_expr = mk_str(cx, sp, \"\");\n     let nargs = vec::len::<@ast::expr>(args);\n     for pc: piece in pieces {\n         alt pc {\n           piece_string(s) {\n-            let s_expr = make_new_str(cx, fmt_sp, s);\n-            tmp_expr = make_add_expr(cx, fmt_sp, tmp_expr, s_expr);\n+            let s_expr = mk_str(cx, fmt_sp, s);\n+            tmp_expr = mk_binary(cx, fmt_sp, ast::add, tmp_expr, s_expr);\n           }\n           piece_conv(conv) {\n             n += 1u;\n@@ -291,7 +277,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n             log_conv(conv);\n             let arg_expr = args[n];\n             let c_expr = make_new_conv(cx, fmt_sp, conv, arg_expr);\n-            tmp_expr = make_add_expr(cx, fmt_sp, tmp_expr, c_expr);\n+            tmp_expr = mk_binary(cx, fmt_sp, ast::add, tmp_expr, c_expr);\n           }\n         }\n     }"}]}