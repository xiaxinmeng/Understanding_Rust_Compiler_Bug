{"sha": "59bf09d4d473c803609d3ad925a0ebf13bdbb0ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5YmYwOWQ0ZDQ3M2M4MDM2MDlkM2FkOTI1YTBlYmYxM2JkYmIwYWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-25T06:16:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-25T06:16:19Z"}, "message": "Auto merge of #46117 - SimonSapin:min-align, r=alexcrichton\n\nallocators: don\u2019t assume MIN_ALIGN for small sizes\n\nSee individual commit messages.", "tree": {"sha": "8357c4f6e256ae8b198de5f1bd729118d6dd1f74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8357c4f6e256ae8b198de5f1bd729118d6dd1f74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59bf09d4d473c803609d3ad925a0ebf13bdbb0ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59bf09d4d473c803609d3ad925a0ebf13bdbb0ab", "html_url": "https://github.com/rust-lang/rust/commit/59bf09d4d473c803609d3ad925a0ebf13bdbb0ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59bf09d4d473c803609d3ad925a0ebf13bdbb0ab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca8ef2629363ead527452d15ab628633c8fd2d52", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca8ef2629363ead527452d15ab628633c8fd2d52", "html_url": "https://github.com/rust-lang/rust/commit/ca8ef2629363ead527452d15ab628633c8fd2d52"}, {"sha": "43e32b53462e139c560672102724e8a8c859dbf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/43e32b53462e139c560672102724e8a8c859dbf7", "html_url": "https://github.com/rust-lang/rust/commit/43e32b53462e139c560672102724e8a8c859dbf7"}], "stats": {"total": 83, "additions": 65, "deletions": 18}, "files": [{"sha": "d3ce12056bb49e0d8114e5655872a87265f7cdb9", "filename": "src/liballoc/tests/heap.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/59bf09d4d473c803609d3ad925a0ebf13bdbb0ab/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59bf09d4d473c803609d3ad925a0ebf13bdbb0ab/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=59bf09d4d473c803609d3ad925a0ebf13bdbb0ab", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc_system::System;\n+use std::heap::{Heap, Alloc, Layout};\n+\n+/// https://github.com/rust-lang/rust/issues/45955\n+///\n+/// Note that `#[global_allocator]` is not used,\n+/// so `liballoc_jemalloc` is linked (on some platforms).\n+#[test]\n+fn alloc_system_overaligned_request() {\n+    check_overalign_requests(System)\n+}\n+\n+#[test]\n+fn std_heap_overaligned_request() {\n+    check_overalign_requests(Heap)\n+}\n+\n+fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n+    let size = 8;\n+    let align = 16; // greater than size\n+    let iterations = 100;\n+    unsafe {\n+        let pointers: Vec<_> = (0..iterations).map(|_| {\n+            allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n+        }).collect();\n+        for &ptr in &pointers {\n+            assert_eq!((ptr as usize) % align, 0, \"Got a pointer less aligned than requested\")\n+        }\n+\n+        // Clean up\n+        for &ptr in &pointers {\n+            allocator.dealloc(ptr, Layout::from_size_align(size, align).unwrap())\n+        }\n+    }\n+}"}, {"sha": "f1e95883b38279bddd120fb82cf48974fe76c071", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59bf09d4d473c803609d3ad925a0ebf13bdbb0ab/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59bf09d4d473c803609d3ad925a0ebf13bdbb0ab/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=59bf09d4d473c803609d3ad925a0ebf13bdbb0ab", "patch": "@@ -10,6 +10,8 @@\n \n #![deny(warnings)]\n \n+#![feature(allocator_api)]\n+#![feature(alloc_system)]\n #![feature(attr_literals)]\n #![feature(box_syntax)]\n #![feature(inclusive_range_syntax)]\n@@ -29,6 +31,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n \n+extern crate alloc_system;\n extern crate std_unicode;\n extern crate rand;\n \n@@ -39,6 +42,7 @@ mod binary_heap;\n mod btree;\n mod cow_str;\n mod fmt;\n+mod heap;\n mod linked_list;\n mod slice;\n mod str;"}, {"sha": "d7370ae400dac762d2e7a81771c9812606657cf9", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/59bf09d4d473c803609d3ad925a0ebf13bdbb0ab/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59bf09d4d473c803609d3ad925a0ebf13bdbb0ab/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=59bf09d4d473c803609d3ad925a0ebf13bdbb0ab", "patch": "@@ -72,8 +72,7 @@ mod contents {\n     const MALLOCX_ZERO: c_int = 0x40;\n \n     // The minimum alignment guaranteed by the architecture. This value is used to\n-    // add fast paths for low alignment values. In practice, the alignment is a\n-    // constant at the call site and the branch will be optimized out.\n+    // add fast paths for low alignment values.\n     #[cfg(all(any(target_arch = \"arm\",\n                   target_arch = \"mips\",\n                   target_arch = \"powerpc\")))]\n@@ -92,8 +91,8 @@ mod contents {\n         a.trailing_zeros() as c_int\n     }\n \n-    fn align_to_flags(align: usize) -> c_int {\n-        if align <= MIN_ALIGN {\n+    fn align_to_flags(align: usize, size: usize) -> c_int {\n+        if align <= MIN_ALIGN && align <= size {\n             0\n         } else {\n             mallocx_align(align)\n@@ -111,7 +110,7 @@ mod contents {\n     pub unsafe extern fn __rde_alloc(size: usize,\n                                      align: usize,\n                                      err: *mut u8) -> *mut u8 {\n-        let flags = align_to_flags(align);\n+        let flags = align_to_flags(align, size);\n         let ptr = mallocx(size as size_t, flags) as *mut u8;\n         if ptr.is_null() {\n             let layout = Layout::from_size_align_unchecked(size, align);\n@@ -132,7 +131,7 @@ mod contents {\n     pub unsafe extern fn __rde_dealloc(ptr: *mut u8,\n                                        size: usize,\n                                        align: usize) {\n-        let flags = align_to_flags(align);\n+        let flags = align_to_flags(align, size);\n         sdallocx(ptr as *mut c_void, size, flags);\n     }\n \n@@ -142,7 +141,7 @@ mod contents {\n                                            min: *mut usize,\n                                            max: *mut usize) {\n         let layout = &*(layout as *const Layout);\n-        let flags = align_to_flags(layout.align());\n+        let flags = align_to_flags(layout.align(), layout.size());\n         let size = nallocx(layout.size(), flags) as usize;\n         *min = layout.size();\n         if size > 0 {\n@@ -166,7 +165,7 @@ mod contents {\n             return 0 as *mut u8\n         }\n \n-        let flags = align_to_flags(new_align);\n+        let flags = align_to_flags(new_align, new_size);\n         let ptr = rallocx(ptr as *mut c_void, new_size, flags) as *mut u8;\n         if ptr.is_null() {\n             let layout = Layout::from_size_align_unchecked(new_size, new_align);\n@@ -181,10 +180,10 @@ mod contents {\n     pub unsafe extern fn __rde_alloc_zeroed(size: usize,\n                                             align: usize,\n                                             err: *mut u8) -> *mut u8 {\n-        let ptr = if align <= MIN_ALIGN {\n+        let ptr = if align <= MIN_ALIGN && align <= size {\n             calloc(size as size_t, 1) as *mut u8\n         } else {\n-            let flags = align_to_flags(align) | MALLOCX_ZERO;\n+            let flags = align_to_flags(align, size) | MALLOCX_ZERO;\n             mallocx(size as size_t, flags) as *mut u8\n         };\n         if ptr.is_null() {\n@@ -203,7 +202,7 @@ mod contents {\n                                             err: *mut u8) -> *mut u8 {\n         let p = __rde_alloc(size, align, err);\n         if !p.is_null() {\n-            let flags = align_to_flags(align);\n+            let flags = align_to_flags(align, size);\n             *excess = nallocx(size, flags) as usize;\n         }\n         return p\n@@ -220,7 +219,7 @@ mod contents {\n                                               err: *mut u8) -> *mut u8 {\n         let p = __rde_realloc(ptr, old_size, old_align, new_size, new_align, err);\n         if !p.is_null() {\n-            let flags = align_to_flags(new_align);\n+            let flags = align_to_flags(new_align, new_size);\n             *excess = nallocx(new_size, flags) as usize;\n         }\n         p\n@@ -244,7 +243,7 @@ mod contents {\n                                                new_size: usize,\n                                                new_align: usize) -> u8 {\n         if old_align == new_align {\n-            let flags = align_to_flags(new_align);\n+            let flags = align_to_flags(new_align, new_size);\n             (xallocx(ptr as *mut c_void, new_size, 0, flags) == new_size) as u8\n         } else {\n             0"}, {"sha": "27259cc31a5ed56824c2138084e9dcc9b1065adb", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59bf09d4d473c803609d3ad925a0ebf13bdbb0ab/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59bf09d4d473c803609d3ad925a0ebf13bdbb0ab/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=59bf09d4d473c803609d3ad925a0ebf13bdbb0ab", "patch": "@@ -25,8 +25,7 @@\n #![rustc_alloc_kind = \"lib\"]\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n-// add fast paths for low alignment values. In practice, the alignment is a\n-// constant at the call site and the branch will be optimized out.\n+// add fast paths for low alignment values.\n #[cfg(all(any(target_arch = \"x86\",\n               target_arch = \"arm\",\n               target_arch = \"mips\",\n@@ -132,7 +131,7 @@ mod platform {\n     unsafe impl<'a> Alloc for &'a System {\n         #[inline]\n         unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-            let ptr = if layout.align() <= MIN_ALIGN {\n+            let ptr = if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n                 libc::malloc(layout.size()) as *mut u8\n             } else {\n                 aligned_malloc(&layout)\n@@ -148,7 +147,7 @@ mod platform {\n         unsafe fn alloc_zeroed(&mut self, layout: Layout)\n             -> Result<*mut u8, AllocErr>\n         {\n-            if layout.align() <= MIN_ALIGN {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n                 let ptr = libc::calloc(layout.size(), 1) as *mut u8;\n                 if !ptr.is_null() {\n                     Ok(ptr)\n@@ -180,7 +179,7 @@ mod platform {\n                 })\n             }\n \n-            if new_layout.align() <= MIN_ALIGN {\n+            if new_layout.align() <= MIN_ALIGN  && new_layout.align() <= new_layout.size(){\n                 let ptr = libc::realloc(ptr as *mut libc::c_void, new_layout.size());\n                 if !ptr.is_null() {\n                     Ok(ptr as *mut u8)"}]}