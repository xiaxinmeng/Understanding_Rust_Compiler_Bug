{"sha": "b0824bf75fba159f40e498dd88386174feea5cf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwODI0YmY3NWZiYTE1OWY0MGU0OThkZDg4Mzg2MTc0ZmVlYTVjZjU=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-06T10:31:46Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:40:24Z"}, "message": "move map_unwrap_or to its own module", "tree": {"sha": "7af4cf2035dd8f01c8800ee069a3fe8b35111464", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7af4cf2035dd8f01c8800ee069a3fe8b35111464"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0824bf75fba159f40e498dd88386174feea5cf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0824bf75fba159f40e498dd88386174feea5cf5", "html_url": "https://github.com/rust-lang/rust/commit/b0824bf75fba159f40e498dd88386174feea5cf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0824bf75fba159f40e498dd88386174feea5cf5/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5557596926b493f1fdb85aef6bd78941f231f962", "url": "https://api.github.com/repos/rust-lang/rust/commits/5557596926b493f1fdb85aef6bd78941f231f962", "html_url": "https://github.com/rust-lang/rust/commit/5557596926b493f1fdb85aef6bd78941f231f962"}], "stats": {"total": 151, "additions": 80, "deletions": 71}, "files": [{"sha": "63b2cf87f32ada410984e722fcd10bb817ea259f", "filename": "clippy_lints/src/methods/map_unwrap_or.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b0824bf75fba159f40e498dd88386174feea5cf5/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0824bf75fba159f40e498dd88386174feea5cf5/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs?ref=b0824bf75fba159f40e498dd88386174feea5cf5", "patch": "@@ -0,0 +1,76 @@\n+use crate::utils::usage::mutated_variables;\n+use crate::utils::{is_type_diagnostic_item, meets_msrv, snippet, span_lint, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_semver::RustcVersion;\n+use rustc_span::symbol::sym;\n+\n+use super::MAP_UNWRAP_OR;\n+\n+const MAP_UNWRAP_OR_MSRV: RustcVersion = RustcVersion::new(1, 41, 0);\n+\n+/// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n+/// Return true if lint triggered\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    map_args: &'tcx [hir::Expr<'_>],\n+    unwrap_args: &'tcx [hir::Expr<'_>],\n+    msrv: Option<&RustcVersion>,\n+) -> bool {\n+    if !meets_msrv(msrv, &MAP_UNWRAP_OR_MSRV) {\n+        return false;\n+    }\n+    // lint if the caller of `map()` is an `Option`\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::result_type);\n+\n+    if is_option || is_result {\n+        // Don't make a suggestion that may fail to compile due to mutably borrowing\n+        // the same variable twice.\n+        let map_mutated_vars = mutated_variables(&map_args[0], cx);\n+        let unwrap_mutated_vars = mutated_variables(&unwrap_args[1], cx);\n+        if let (Some(map_mutated_vars), Some(unwrap_mutated_vars)) = (map_mutated_vars, unwrap_mutated_vars) {\n+            if map_mutated_vars.intersection(&unwrap_mutated_vars).next().is_some() {\n+                return false;\n+            }\n+        } else {\n+            return false;\n+        }\n+\n+        // lint message\n+        let msg = if is_option {\n+            \"called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling \\\n+            `map_or_else(<g>, <f>)` instead\"\n+        } else {\n+            \"called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling \\\n+            `.map_or_else(<g>, <f>)` instead\"\n+        };\n+        // get snippets for args to map() and unwrap_or_else()\n+        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        // lint, with note if neither arg is > 1 line and both map() and\n+        // unwrap_or_else() have the same span\n+        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n+        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n+        if same_span && !multiline {\n+            let var_snippet = snippet(cx, map_args[0].span, \"..\");\n+            span_lint_and_sugg(\n+                cx,\n+                MAP_UNWRAP_OR,\n+                expr.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.map_or_else({}, {})\", var_snippet, unwrap_snippet, map_snippet),\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n+        } else if same_span && multiline {\n+            span_lint(cx, MAP_UNWRAP_OR, expr.span, msg);\n+            return true;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "5f62942530c40e75a1e1c935dccdd865ee84645c", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 4, "deletions": 71, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b0824bf75fba159f40e498dd88386174feea5cf5/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0824bf75fba159f40e498dd88386174feea5cf5/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=b0824bf75fba159f40e498dd88386174feea5cf5", "patch": "@@ -28,6 +28,7 @@ mod iterator_step_by_zero;\n mod manual_saturating_arithmetic;\n mod map_collect_result_unit;\n mod map_flatten;\n+mod map_unwrap_or;\n mod ok_expect;\n mod option_as_ref_deref;\n mod option_map_or_none;\n@@ -66,11 +67,10 @@ use rustc_span::symbol::{sym, Symbol, SymbolStr};\n use rustc_typeck::hir_ty_to_ty;\n \n use crate::utils::eager_or_lazy::is_lazyness_candidate;\n-use crate::utils::usage::mutated_variables;\n use crate::utils::{\n     contains_return, contains_ty, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of,\n-    is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath, match_type, meets_msrv,\n-    method_calls, method_chain_args, paths, return_ty, single_segment_path, snippet, snippet_with_applicability,\n+    is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath, match_type, method_calls,\n+    method_chain_args, paths, return_ty, single_segment_path, snippet, snippet_with_applicability,\n     snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, SpanlessEq,\n };\n \n@@ -1689,7 +1689,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"expect\", ..] => expect_used::check(cx, expr, arg_lists[0]),\n             [\"unwrap_or\", \"map\"] => option_map_unwrap_or::check(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n             [\"unwrap_or_else\", \"map\"] => {\n-                if !lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0], self.msrv.as_ref()) {\n+                if !map_unwrap_or::check(cx, expr, arg_lists[1], arg_lists[0], self.msrv.as_ref()) {\n                     unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"unwrap_or\");\n                 }\n             },\n@@ -2365,73 +2365,6 @@ fn derefs_to_slice<'tcx>(\n     }\n }\n \n-const MAP_UNWRAP_OR_MSRV: RustcVersion = RustcVersion::new(1, 41, 0);\n-\n-/// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n-/// Return true if lint triggered\n-fn lint_map_unwrap_or_else<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-    map_args: &'tcx [hir::Expr<'_>],\n-    unwrap_args: &'tcx [hir::Expr<'_>],\n-    msrv: Option<&RustcVersion>,\n-) -> bool {\n-    if !meets_msrv(msrv, &MAP_UNWRAP_OR_MSRV) {\n-        return false;\n-    }\n-    // lint if the caller of `map()` is an `Option`\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type);\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::result_type);\n-\n-    if is_option || is_result {\n-        // Don't make a suggestion that may fail to compile due to mutably borrowing\n-        // the same variable twice.\n-        let map_mutated_vars = mutated_variables(&map_args[0], cx);\n-        let unwrap_mutated_vars = mutated_variables(&unwrap_args[1], cx);\n-        if let (Some(map_mutated_vars), Some(unwrap_mutated_vars)) = (map_mutated_vars, unwrap_mutated_vars) {\n-            if map_mutated_vars.intersection(&unwrap_mutated_vars).next().is_some() {\n-                return false;\n-            }\n-        } else {\n-            return false;\n-        }\n-\n-        // lint message\n-        let msg = if is_option {\n-            \"called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling \\\n-            `map_or_else(<g>, <f>)` instead\"\n-        } else {\n-            \"called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling \\\n-            `.map_or_else(<g>, <f>)` instead\"\n-        };\n-        // get snippets for args to map() and unwrap_or_else()\n-        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n-        // lint, with note if neither arg is > 1 line and both map() and\n-        // unwrap_or_else() have the same span\n-        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n-        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n-        if same_span && !multiline {\n-            let var_snippet = snippet(cx, map_args[0].span, \"..\");\n-            span_lint_and_sugg(\n-                cx,\n-                MAP_UNWRAP_OR,\n-                expr.span,\n-                msg,\n-                \"try this\",\n-                format!(\"{}.map_or_else({}, {})\", var_snippet, unwrap_snippet, map_snippet),\n-                Applicability::MachineApplicable,\n-            );\n-            return true;\n-        } else if same_span && multiline {\n-            span_lint(cx, MAP_UNWRAP_OR, expr.span, msg);\n-            return true;\n-        }\n-    }\n-\n-    false\n-}\n-\n /// Used for `lint_binary_expr_with_method_call`.\n #[derive(Copy, Clone)]\n struct BinaryExprInfo<'a> {"}]}