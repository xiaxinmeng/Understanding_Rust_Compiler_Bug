{"sha": "97a2096e5e779fe2473c77b051725bf9f0f8b01d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3YTIwOTZlNWU3NzlmZTI0NzNjNzdiMDUxNzI1YmY5ZjBmOGIwMWQ=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-18T16:07:35Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:03:31Z"}, "message": "Inline and cleanup build_return_block", "tree": {"sha": "f866c9aa32ef88984d0f4598e7bcc0cbca47d199", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f866c9aa32ef88984d0f4598e7bcc0cbca47d199"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97a2096e5e779fe2473c77b051725bf9f0f8b01d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97a2096e5e779fe2473c77b051725bf9f0f8b01d", "html_url": "https://github.com/rust-lang/rust/commit/97a2096e5e779fe2473c77b051725bf9f0f8b01d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97a2096e5e779fe2473c77b051725bf9f0f8b01d/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "515d14f0944a5e5e6b2df206549e08ebe39e18f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/515d14f0944a5e5e6b2df206549e08ebe39e18f1", "html_url": "https://github.com/rust-lang/rust/commit/515d14f0944a5e5e6b2df206549e08ebe39e18f1"}], "stats": {"total": 168, "additions": 87, "deletions": 81}, "files": [{"sha": "f9b8b18a5ec2bbcc9f4e9ca904f8f88299eba9f2", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 35, "deletions": 66, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/97a2096e5e779fe2473c77b051725bf9f0f8b01d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a2096e5e779fe2473c77b051725bf9f0f8b01d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=97a2096e5e779fe2473c77b051725bf9f0f8b01d", "patch": "@@ -564,68 +564,6 @@ pub fn alloc_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, ty: Ty<'tcx>, name: &\n     bcx.fcx().alloca(type_of::type_of(bcx.ccx(), ty), name)\n }\n \n-impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    // Builds the return block for a function.\n-    pub fn build_return_block(&self, ret_cx: &BlockAndBuilder<'a, 'tcx>) {\n-        if self.llretslotptr.is_none() || self.fn_ty.ret.is_indirect() {\n-            return ret_cx.ret_void();\n-        }\n-\n-        let retslot = self.llretslotptr.unwrap();\n-        let retptr = Value(retslot);\n-        let llty = self.fn_ty.ret.original_ty;\n-        match (retptr.get_dominating_store(ret_cx), self.fn_ty.ret.cast) {\n-            // If there's only a single store to the ret slot, we can directly return\n-            // the value that was stored and omit the store and the alloca.\n-            // However, we only want to do this when there is no cast needed.\n-            (Some(s), None) => {\n-                let mut retval = s.get_operand(0).unwrap().get();\n-                s.erase_from_parent();\n-\n-                if retptr.has_no_uses() {\n-                    retptr.erase_from_parent();\n-                }\n-\n-                if self.fn_ty.ret.is_indirect() {\n-                    ret_cx.store(retval, get_param(self.llfn, 0));\n-                    ret_cx.ret_void()\n-                } else {\n-                    if llty == Type::i1(self.ccx) {\n-                        retval = ret_cx.trunc(retval, llty);\n-                    }\n-                    ret_cx.ret(retval)\n-                }\n-            }\n-            (_, cast_ty) if self.fn_ty.ret.is_indirect() => {\n-                // Otherwise, copy the return value to the ret slot.\n-                assert_eq!(cast_ty, None);\n-                let llsz = llsize_of(self.ccx, self.fn_ty.ret.ty);\n-                let llalign = llalign_of_min(self.ccx, self.fn_ty.ret.ty);\n-                call_memcpy(&ret_cx, get_param(self.llfn, 0),\n-                            retslot, llsz, llalign as u32);\n-                ret_cx.ret_void()\n-            }\n-            (_, Some(cast_ty)) => {\n-                let load = ret_cx.load(ret_cx.pointercast(retslot, cast_ty.ptr_to()));\n-                let llalign = llalign_of_min(self.ccx, self.fn_ty.ret.ty);\n-                unsafe {\n-                    llvm::LLVMSetAlignment(load, llalign);\n-                }\n-                ret_cx.ret(load)\n-            }\n-            (_, None) => {\n-                let retval = if llty == Type::i1(self.ccx) {\n-                    let val = ret_cx.load_range_assert(retslot, 0, 2, llvm::False);\n-                    ret_cx.trunc(val, llty)\n-                } else {\n-                    ret_cx.load(retslot)\n-                };\n-                ret_cx.ret(retval)\n-            }\n-        }\n-    }\n-}\n-\n pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n     let _s = if ccx.sess().trans_stats() {\n         let mut instance_name = String::new();\n@@ -683,9 +621,17 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let fcx = FunctionContext::new(ccx, llfndecl, fn_ty, None, false);\n     let bcx = fcx.get_entry_block();\n-\n     if !fcx.fn_ty.ret.is_ignore() {\n-        let dest = fcx.llretslotptr.unwrap();\n+        // But if there are no nested returns, we skip the indirection\n+        // and have a single retslot\n+        let dest = if fcx.fn_ty.ret.is_indirect() {\n+            get_param(fcx.llfn, 0)\n+        } else {\n+            // We create an alloca to hold a pointer of type `ret.original_ty`\n+            // which will hold the pointer to the right alloca which has the\n+            // final ret value\n+            fcx.alloca(fcx.fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n+        };\n         let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n         let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n@@ -703,9 +649,32 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         adt::trans_set_discr(&bcx, sig.output(), dest, disr);\n-    }\n \n-    fcx.build_return_block(&bcx);\n+        if fcx.fn_ty.ret.is_indirect() {\n+            bcx.ret_void();\n+            return;\n+        }\n+\n+        if let Some(cast_ty) = fcx.fn_ty.ret.cast {\n+            let load = bcx.load(bcx.pointercast(dest, cast_ty.ptr_to()));\n+            let llalign = llalign_of_min(fcx.ccx, fcx.fn_ty.ret.ty);\n+            unsafe {\n+                llvm::LLVMSetAlignment(load, llalign);\n+            }\n+            bcx.ret(load)\n+        } else {\n+            let llty = fcx.fn_ty.ret.original_ty;\n+            let retval = if llty == Type::i1(fcx.ccx) {\n+                let val = bcx.load_range_assert(dest, 0, 2, llvm::False);\n+                bcx.trunc(val, llty)\n+            } else {\n+                bcx.load(dest)\n+            };\n+            bcx.ret(retval)\n+        }\n+    } else {\n+        bcx.ret_void();\n+    }\n }\n \n pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {"}, {"sha": "e0ecd1d8bf57a50fee29dd3c5a73221bb21f7709", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/97a2096e5e779fe2473c77b051725bf9f0f8b01d/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a2096e5e779fe2473c77b051725bf9f0f8b01d/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=97a2096e5e779fe2473c77b051725bf9f0f8b01d", "patch": "@@ -16,7 +16,7 @@\n \n pub use self::CalleeData::*;\n \n-use llvm::{self, ValueRef, get_params};\n+use llvm::{self, ValueRef, get_param, get_params};\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n@@ -390,8 +390,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let fn_ret = callee.ty.fn_ret();\n     let fn_ty = callee.direct_fn_type(bcx.ccx(), &[]);\n \n-    let first_llarg = if fn_ty.ret.is_indirect() {\n-        fcx.llretslotptr\n+    let first_llarg = if fn_ty.ret.is_indirect() && !fcx.fn_ty.ret.is_ignore() {\n+        Some(get_param(fcx.llfn, 0))\n     } else {\n         None\n     };\n@@ -409,17 +409,16 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     }\n     fn_ty.apply_attrs_callsite(llret);\n \n-    if !fn_ty.ret.is_indirect() {\n-        if let Some(llretslot) = fcx.llretslotptr {\n-            fn_ty.ret.store(&bcx, llret, llretslot);\n-        }\n-    }\n-\n     if fn_ret.0.is_never() {\n         bcx.unreachable();\n     }\n     self_scope.trans(&bcx);\n-    fcx.build_return_block(&bcx);\n+\n+    if fcx.fn_ty.ret.is_indirect() || fcx.fn_ty.ret.is_ignore() {\n+        bcx.ret_void();\n+    } else {\n+        bcx.ret(llret);\n+    }\n \n     ccx.instances().borrow_mut().insert(method_instance, lloncefn);\n \n@@ -539,9 +538,31 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n         data: Fn(llfnpointer),\n         ty: bare_fn_ty\n     };\n-    callee.call(&bcx, &llargs[(self_idx + 1)..], fcx.llretslotptr, None);\n-    fcx.build_return_block(&bcx);\n \n+    let fn_ret = callee.ty.fn_ret();\n+    let fn_ty = callee.direct_fn_type(ccx, &[]);\n+\n+    let mut args = Vec::new();\n+\n+    if fn_ty.ret.is_indirect() {\n+        if !fn_ty.ret.is_ignore() {\n+            args.push(get_param(fcx.llfn, 0));\n+        }\n+    }\n+    args.extend_from_slice(&llargs[(self_idx + 1)..]);\n+\n+    let llret = bcx.call(llfnpointer, &args, None);\n+    fn_ty.apply_attrs_callsite(llret);\n+\n+    if fn_ret.0.is_never() {\n+        bcx.unreachable();\n+    }\n+\n+    if fn_ty.ret.is_indirect() || fcx.fn_ty.ret.is_ignore() {\n+        bcx.ret_void();\n+    } else {\n+        bcx.ret(llret);\n+    }\n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty_maybe_ref, llfn);\n \n     llfn"}, {"sha": "4778f3685546545d2c50c07375c8af132d056c53", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97a2096e5e779fe2473c77b051725bf9f0f8b01d/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a2096e5e779fe2473c77b051725bf9f0f8b01d/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=97a2096e5e779fe2473c77b051725bf9f0f8b01d", "patch": "@@ -201,7 +201,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n     // type, so we don't need to explicitly cast the function parameter.\n \n     let bcx = make_drop_glue(bcx, get_param(llfn, 0), g);\n-    fcx.build_return_block(&bcx);\n+    bcx.ret_void();\n }\n \n fn trans_custom_dtor<'a, 'tcx>(mut bcx: BlockAndBuilder<'a, 'tcx>,"}, {"sha": "33b43e9a3ab06ac1234d7886df66aade07630ac2", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/97a2096e5e779fe2473c77b051725bf9f0f8b01d/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a2096e5e779fe2473c77b051725bf9f0f8b01d/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=97a2096e5e779fe2473c77b051725bf9f0f8b01d", "patch": "@@ -85,8 +85,24 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let bcx = fcx.get_entry_block();\n \n     let llargs = get_params(fcx.llfn);\n-    callee.call(&bcx, &llargs[fcx.fn_ty.ret.is_indirect() as usize..], fcx.llretslotptr, None);\n-    fcx.build_return_block(&bcx);\n+    let fn_ret = callee.ty.fn_ret();\n+    let fn_ty = callee.direct_fn_type(ccx, &[]);\n+\n+    let mut args = Vec::new();\n+\n+    args.extend_from_slice(&llargs);\n+    let llret = bcx.call(callee.reify(ccx), &args, None);\n+    fn_ty.apply_attrs_callsite(llret);\n+\n+    if fn_ret.0.is_never() {\n+        bcx.unreachable();\n+    }\n+\n+    if fn_ty.ret.is_indirect() || fcx.fn_ty.ret.is_ignore() {\n+        bcx.ret_void();\n+    } else {\n+        bcx.ret(llret);\n+    }\n \n     llfn\n }"}]}