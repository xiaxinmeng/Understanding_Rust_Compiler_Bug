{"sha": "0930b953958232022727b83cf9e08a2397656f62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MzBiOTUzOTU4MjMyMDIyNzI3YjgzY2Y5ZTA4YTIzOTc2NTZmNjI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-24T18:27:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-24T18:29:07Z"}, "message": "rustc: Typecheck struct literals", "tree": {"sha": "590b07dd867be46dd4bf0c76c6f8b4ee01922ab8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/590b07dd867be46dd4bf0c76c6f8b4ee01922ab8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0930b953958232022727b83cf9e08a2397656f62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0930b953958232022727b83cf9e08a2397656f62", "html_url": "https://github.com/rust-lang/rust/commit/0930b953958232022727b83cf9e08a2397656f62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0930b953958232022727b83cf9e08a2397656f62/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf96298ff91ffdd2297d74046bf9d343f0e65efa", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf96298ff91ffdd2297d74046bf9d343f0e65efa", "html_url": "https://github.com/rust-lang/rust/commit/bf96298ff91ffdd2297d74046bf9d343f0e65efa"}], "stats": {"total": 137, "additions": 134, "deletions": 3}, "files": [{"sha": "9871857fe61ae8ecff7c96e76c9a38816c318f77", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 134, "deletions": 3, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/0930b953958232022727b83cf9e08a2397656f62/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0930b953958232022727b83cf9e08a2397656f62/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=0930b953958232022727b83cf9e08a2397656f62", "patch": "@@ -66,7 +66,8 @@ type parameter).\n \n */\n \n-import astconv::{ast_conv, ast_ty_to_ty, ast_region_to_region};\n+import astconv::{ast_conv, ast_path_to_ty, ast_ty_to_ty};\n+import astconv::{ast_region_to_region};\n import collect::{methods}; // ccx.to_ty()\n import middle::ty::{tv_vid, vid};\n import regionmanip::{replace_bound_regions_in_fn_ty, region_of};\n@@ -76,6 +77,8 @@ import syntax::ast::ty_i;\n import typeck::infer::{unify_methods}; // infcx.set()\n import typeck::infer::{resolve_type, force_tvar};\n \n+import std::map::str_hash;\n+\n type fn_ctxt_ =\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n@@ -1628,8 +1631,136 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n         }\n       }\n-      ast::expr_struct(*) {\n-        fail ~\"XXX structs\";\n+      ast::expr_struct(path, fields) {\n+        // Resolve the path.\n+        let class_id;\n+        alt tcx.def_map.find(id) {\n+            some(ast::def_class(type_def_id)) => {\n+                class_id = type_def_id;\n+            }\n+            _ => {\n+                tcx.sess.span_bug(path.span, ~\"structure constructor does \\\n+                                               not name a structure type\");\n+            }\n+        }\n+\n+        // Look up the number of type parameters and the raw type, and\n+        // determine whether the class is region-parameterized.\n+        let type_parameter_count, region_parameterized, raw_type;\n+        if class_id.crate == ast::local_crate {\n+            region_parameterized =\n+                tcx.region_paramd_items.contains_key(class_id.node);\n+            alt tcx.items.find(class_id.node) {\n+                some(ast_map::node_item(@{\n+                        node: ast::item_class(type_parameters, _, _, _, _),\n+                        _\n+                    }, _)) => {\n+\n+                    type_parameter_count = type_parameters.len();\n+\n+                    let self_region;\n+                    if region_parameterized {\n+                        self_region = some(ty::re_bound(ty::br_self));\n+                    } else {\n+                        self_region = none;\n+                    }\n+\n+                    raw_type = ty::mk_class(tcx, class_id, {\n+                        self_r: self_region,\n+                        self_ty: none,\n+                        tps: ty::ty_params_to_tys(tcx, type_parameters)\n+                    });\n+                }\n+                _ => {\n+                    tcx.sess.span_bug(expr.span,\n+                                      ~\"resolve didn't map this to a class\");\n+                }\n+            }\n+        } else {\n+            let item_type = ty::lookup_item_type(tcx, class_id);\n+            type_parameter_count = (*item_type.bounds).len();\n+            region_parameterized = item_type.rp;\n+            raw_type = item_type.ty;\n+        }\n+\n+        // Generate the struct type.\n+        let self_region;\n+        if region_parameterized {\n+            self_region = some(fcx.infcx.next_region_var_nb());\n+        } else {\n+            self_region = none;\n+        }\n+\n+        let type_parameters = fcx.infcx.next_ty_vars(type_parameter_count);\n+        let substitutions = {\n+            self_r: self_region,\n+            self_ty: none,\n+            tps: type_parameters\n+        };\n+\n+        let struct_type = ty::subst(tcx, substitutions, raw_type);\n+        \n+        // Look up the class fields and build up a map.\n+        let class_fields = ty::lookup_class_fields(tcx, class_id);\n+        let class_field_map = str_hash();\n+        let mut fields_found = 0;\n+        for class_fields.each |field| {\n+            // XXX: Check visibility here.\n+            class_field_map.insert(*field.ident, (field.id, false));\n+        }\n+\n+        // Typecheck each field.\n+        for fields.each |field| {\n+            alt class_field_map.find(*field.node.ident) {\n+                none => {\n+                    tcx.sess.span_err(field.span,\n+                                      #fmt(\"structure has no field named \\\n+                                            field named `%s`\",\n+                                           *field.node.ident));\n+                }\n+                some((_, true)) => {\n+                    tcx.sess.span_err(field.span,\n+                                      #fmt(\"field `%s` specified more than \\\n+                                            once\",\n+                                           *field.node.ident));\n+                }\n+                some((field_id, false)) => {\n+                    let expected_field_type =\n+                        ty::lookup_field_type(tcx, class_id, field_id,\n+                                              substitutions);\n+                    bot |= check_expr(fcx,\n+                                      field.node.expr,\n+                                      some(expected_field_type));\n+                    fields_found += 1;\n+                }\n+            }\n+        }\n+\n+        // Make sure the programmer specified all the fields.\n+        assert fields_found <= class_fields.len();\n+        if fields_found < class_fields.len() {\n+            let mut missing_fields = ~[];\n+            for class_fields.each |class_field| {\n+                let name = *class_field.ident;\n+                let (_, seen) = class_field_map.get(name);\n+                if !seen {\n+                    vec::push(missing_fields,\n+                              ~\"`\" + name + ~\"`\");\n+                }\n+            }\n+\n+            tcx.sess.span_err(expr.span,\n+                              #fmt(\"missing field%s: %s\",\n+                                   if missing_fields.len() == 1 {\n+                                       ~\"\"\n+                                   } else {\n+                                       ~\"s\"\n+                                   },\n+                                   str::connect(missing_fields, ~\", \")));\n+        }\n+\n+        // Write in the resulting type.\n+        fcx.write_ty(id, struct_type);\n       }\n       ast::expr_field(base, field, tys) {\n         bot = check_field(fcx, expr, false, base, field, tys);"}]}