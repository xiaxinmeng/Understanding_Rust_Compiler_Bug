{"sha": "419d39c072825bb622e262c59b0243fcfe69d337", "node_id": "C_kwDOAAsO6NoAKDQxOWQzOWMwNzI4MjViYjYyMmUyNjJjNTliMDI0M2ZjZmU2OWQzMzc", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-06T18:26:41Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-07-25T17:19:23Z"}, "message": "Clippy fallout.", "tree": {"sha": "6bb902154179148f4bcd2bfd37c14e3de60ab7ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bb902154179148f4bcd2bfd37c14e3de60ab7ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/419d39c072825bb622e262c59b0243fcfe69d337", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/419d39c072825bb622e262c59b0243fcfe69d337", "html_url": "https://github.com/rust-lang/rust/commit/419d39c072825bb622e262c59b0243fcfe69d337", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/419d39c072825bb622e262c59b0243fcfe69d337/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcd2241c9a90c5ec7b30fb8e80edd374d2331a09", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcd2241c9a90c5ec7b30fb8e80edd374d2331a09", "html_url": "https://github.com/rust-lang/rust/commit/bcd2241c9a90c5ec7b30fb8e80edd374d2331a09"}], "stats": {"total": 78, "additions": 46, "deletions": 32}, "files": [{"sha": "826353aafc0690c2a9caf64d26fd95358f49cb1a", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 46, "deletions": 32, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/419d39c072825bb622e262c59b0243fcfe69d337/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419d39c072825bb622e262c59b0243fcfe69d337/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=419d39c072825bb622e262c59b0243fcfe69d337", "patch": "@@ -9,12 +9,14 @@ use rustc_hir::intravisit::{\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n     BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, Impl, ImplItem,\n-    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, LifetimeParamKind, ParamName, PolyTraitRef,\n-    PredicateOrigin, TraitBoundModifier, TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n+    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, PredicateOrigin,\n+    TraitBoundModifier, TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter as middle_nested_filter;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, Ident, Symbol};\n \n@@ -129,7 +131,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n enum RefLt {\n     Unnamed,\n     Static,\n-    Named(Symbol),\n+    Named(LocalDefId),\n }\n \n fn check_fn_inner<'tcx>(\n@@ -232,7 +234,7 @@ fn could_use_elision<'tcx>(\n     // level of the current item.\n \n     // check named LTs\n-    let allowed_lts = allowed_lts_from(named_generics);\n+    let allowed_lts = allowed_lts_from(cx.tcx, named_generics);\n \n     // these will collect all the lifetimes for references in arg/return types\n     let mut input_visitor = RefVisitor::new(cx);\n@@ -254,22 +256,6 @@ fn could_use_elision<'tcx>(\n         return false;\n     }\n \n-    if allowed_lts\n-        .intersection(\n-            &input_visitor\n-                .nested_elision_site_lts\n-                .iter()\n-                .chain(output_visitor.nested_elision_site_lts.iter())\n-                .cloned()\n-                .filter(|v| matches!(v, RefLt::Named(_)))\n-                .collect(),\n-        )\n-        .next()\n-        .is_some()\n-    {\n-        return false;\n-    }\n-\n     let input_lts = input_visitor.lts;\n     let output_lts = output_visitor.lts;\n \n@@ -303,6 +289,31 @@ fn could_use_elision<'tcx>(\n         }\n     }\n \n+    // check for higher-ranked trait bounds\n+    if !input_visitor.nested_elision_site_lts.is_empty() || !output_visitor.nested_elision_site_lts.is_empty() {\n+        let allowed_lts: FxHashSet<_> = allowed_lts\n+            .iter()\n+            .filter_map(|lt| match lt {\n+                RefLt::Named(def_id) => Some(cx.tcx.item_name(def_id.to_def_id())),\n+                _ => None,\n+            })\n+            .collect();\n+        for lt in input_visitor.nested_elision_site_lts {\n+            if let RefLt::Named(def_id) = lt {\n+                if allowed_lts.contains(&cx.tcx.item_name(def_id.to_def_id())) {\n+                    return false;\n+                }\n+            }\n+        }\n+        for lt in output_visitor.nested_elision_site_lts {\n+            if let RefLt::Named(def_id) = lt {\n+                if allowed_lts.contains(&cx.tcx.item_name(def_id.to_def_id())) {\n+                    return false;\n+                }\n+            }\n+        }\n+    }\n+\n     // no input lifetimes? easy case!\n     if input_lts.is_empty() {\n         false\n@@ -335,14 +346,11 @@ fn could_use_elision<'tcx>(\n     }\n }\n \n-fn allowed_lts_from(named_generics: &[GenericParam<'_>]) -> FxHashSet<RefLt> {\n+fn allowed_lts_from(tcx: TyCtxt<'_>, named_generics: &[GenericParam<'_>]) -> FxHashSet<RefLt> {\n     let mut allowed_lts = FxHashSet::default();\n     for par in named_generics.iter() {\n-        if let GenericParamKind::Lifetime {\n-            kind: LifetimeParamKind::Explicit,\n-        } = par.kind\n-        {\n-            allowed_lts.insert(RefLt::Named(par.name.ident().name));\n+        if let GenericParamKind::Lifetime { .. } = par.kind {\n+            allowed_lts.insert(RefLt::Named(tcx.hir().local_def_id(par.hir_id)));\n         }\n     }\n     allowed_lts.insert(RefLt::Unnamed);\n@@ -385,8 +393,10 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n                 self.lts.push(RefLt::Unnamed);\n             } else if lt.is_elided() {\n                 self.lts.push(RefLt::Unnamed);\n+            } else if let LifetimeName::Param(def_id, _) = lt.name {\n+                self.lts.push(RefLt::Named(def_id));\n             } else {\n-                self.lts.push(RefLt::Named(lt.name.ident().name));\n+                self.lts.push(RefLt::Unnamed);\n             }\n         } else {\n             self.lts.push(RefLt::Unnamed);\n@@ -434,10 +444,15 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             TyKind::OpaqueDef(item, bounds) => {\n                 let map = self.cx.tcx.hir();\n                 let item = map.item(item);\n+                let len = self.lts.len();\n                 walk_item(self, item);\n-                walk_ty(self, ty);\n+                self.lts.truncate(len);\n                 self.lts.extend(bounds.iter().filter_map(|bound| match bound {\n-                    GenericArg::Lifetime(l) => Some(RefLt::Named(l.name.ident().name)),\n+                    GenericArg::Lifetime(l) => Some(if let LifetimeName::Param(def_id, _) = l.name {\n+                        RefLt::Named(def_id)\n+                    } else {\n+                        RefLt::Unnamed\n+                    }),\n                     _ => None,\n                 }));\n             },\n@@ -456,9 +471,8 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n                 }\n                 return;\n             },\n-            _ => (),\n+            _ => walk_ty(self, ty),\n         }\n-        walk_ty(self, ty);\n     }\n }\n \n@@ -477,7 +491,7 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, generics: &'tcx Generics<'_\n                     return true;\n                 }\n                 // if the bounds define new lifetimes, they are fine to occur\n-                let allowed_lts = allowed_lts_from(pred.bound_generic_params);\n+                let allowed_lts = allowed_lts_from(cx.tcx, pred.bound_generic_params);\n                 // now walk the bounds\n                 for bound in pred.bounds.iter() {\n                     walk_param_bound(&mut visitor, bound);"}]}