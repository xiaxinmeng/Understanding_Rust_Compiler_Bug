{"sha": "3540f9396aff85110277af03b68b3303f3a8b7d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NDBmOTM5NmFmZjg1MTEwMjc3YWYwM2I2OGIzMzAzZjNhOGI3ZDM=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-12-07T22:44:40Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-01-23T20:41:17Z"}, "message": "Add disambiugator to ExpnData\n\nDue to macro expansion, its possible to end up with two distinct\n`ExpnId`s that have the same `ExpnData` contents. This violates the\ncontract of `HashStable`, since two unequal `ExpnId`s will end up with\nequal `Fingerprint`s.\n\nThis commit adds a `disambiguator` field to `ExpnData`, which is used to\nforce two otherwise-equivalent `ExpnData`s to be distinct.", "tree": {"sha": "5d497b506bb534dcadec15a5d792ca1cda9d81b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d497b506bb534dcadec15a5d792ca1cda9d81b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3540f9396aff85110277af03b68b3303f3a8b7d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmAMimsACgkQtAh+UQ6Y\nsWRTJBAAnyi/HTR7fF9DwurBaw5/X5v9ed/ian45oFvJLXPYyF62O7Xxu3HNwY6R\nrdIzrSyTCpz23sLpKjsIVk6pifqqTaxopCBCQ4ziI9K5dXyqTPddOBgWs8U5zMkN\nk25RZMtMRCGd1+tsUhXr47+rWMTLq+kAH+Z/7Q0xkul0UuTsuBO8XyedWiSgxc8X\nNeglCmGWPZA5QnhpHBIFkYFaYDrREq9rtbaSqrAth6cLAiCwm1lDFYvBePo5XHVt\nYmkyKPbTRnwncFAiaiNCsTb7VoNU0b8tgmx0fJcckFBBVwiQnhwE46NQiH1ax7RN\nPLB4ZviBTdkN2kssakJ1u65/+PlfGYwWB6ydP4KgI3ZFf9Q5BXPT0mSYO7N7MWXE\nvDzLCBUPNL/G8cdKMSKFlnZKH5koO4UOToAd3Cwpfco/4EPKR8i04aUWadSng+w+\nJYRCgLDIShE0+6gcRaPC4KBet/L4osO2HwbwPYPps394ecuK8YHlnU1tMqrI7QaL\n5kHH26DFnT27UqoOBDw0PDXkufaAnBhq+ha1AS2Jykn06qj8cIUkeJKc7UjQgFLA\nPH3cUCrF+QDLaWdeNBC/wYTmN5owhgZ7xgME8Pkh5yGK9jSHlSz9y0CXK2cad66X\nVb/pZuRM85RhznKCgga/1a01WfqkHt/VrG9R7jTLnYTNLzA9tP0=\n=YkId\n-----END PGP SIGNATURE-----", "payload": "tree 5d497b506bb534dcadec15a5d792ca1cda9d81b0\nparent 4d0dd02ee07bddad9136f95c9f7846ebf3eb3fc5\nauthor Aaron Hill <aa1ronham@gmail.com> 1607381080 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1611434477 -0500\n\nAdd disambiugator to ExpnData\n\nDue to macro expansion, its possible to end up with two distinct\n`ExpnId`s that have the same `ExpnData` contents. This violates the\ncontract of `HashStable`, since two unequal `ExpnId`s will end up with\nequal `Fingerprint`s.\n\nThis commit adds a `disambiguator` field to `ExpnData`, which is used to\nforce two otherwise-equivalent `ExpnData`s to be distinct.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3540f9396aff85110277af03b68b3303f3a8b7d3", "html_url": "https://github.com/rust-lang/rust/commit/3540f9396aff85110277af03b68b3303f3a8b7d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3540f9396aff85110277af03b68b3303f3a8b7d3/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d0dd02ee07bddad9136f95c9f7846ebf3eb3fc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d0dd02ee07bddad9136f95c9f7846ebf3eb3fc5", "html_url": "https://github.com/rust-lang/rust/commit/4d0dd02ee07bddad9136f95c9f7846ebf3eb3fc5"}], "stats": {"total": 187, "additions": 173, "deletions": 14}, "files": [{"sha": "51b650e5adef8e174e45f03cb1a98fba03862efa", "filename": "compiler/rustc_middle/src/ich/hcx.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3540f9396aff85110277af03b68b3303f3a8b7d3/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3540f9396aff85110277af03b68b3303f3a8b7d3/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs?ref=3540f9396aff85110277af03b68b3303f3a8b7d3", "patch": "@@ -17,6 +17,7 @@ use rustc_span::{BytePos, CachingSourceMapView, SourceFile, SpanData};\n use rustc_span::def_id::{CrateNum, CRATE_DEF_INDEX};\n use smallvec::SmallVec;\n use std::cmp::Ord;\n+use std::thread::LocalKey;\n \n fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n     debug_assert!(!ich::IGNORED_ATTRIBUTES.is_empty());\n@@ -242,6 +243,13 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n         hcx.def_path_hash(def_id).hash_stable(hcx, hasher);\n     }\n \n+    fn expn_id_cache() -> &'static LocalKey<rustc_span::ExpnIdCache> {\n+        thread_local! {\n+            static CACHE: rustc_span::ExpnIdCache = Default::default();\n+        }\n+        &CACHE\n+    }\n+\n     fn byte_pos_to_line_and_col(\n         &mut self,\n         byte: BytePos,"}, {"sha": "9f265f37f35f65f35d8dc17a988fcc3316e9b422", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 152, "deletions": 5, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/3540f9396aff85110277af03b68b3303f3a8b7d3/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3540f9396aff85110277af03b68b3303f3a8b7d3/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=3540f9396aff85110277af03b68b3303f3a8b7d3", "patch": "@@ -27,14 +27,18 @@\n use crate::edition::Edition;\n use crate::symbol::{kw, sym, Symbol};\n use crate::SESSION_GLOBALS;\n-use crate::{Span, DUMMY_SP};\n+use crate::{BytePos, CachingSourceMapView, ExpnIdCache, SourceFile, Span, DUMMY_SP};\n \n use crate::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_macros::HashStable_Generic;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt;\n+use std::hash::Hash;\n+use std::thread::LocalKey;\n use tracing::*;\n \n /// A `SyntaxContext` represents a chain of pairs `(ExpnId, Transparency)` named \"marks\".\n@@ -80,7 +84,12 @@ pub enum Transparency {\n \n impl ExpnId {\n     pub fn fresh(expn_data: Option<ExpnData>) -> Self {\n-        HygieneData::with(|data| data.fresh_expn(expn_data))\n+        let has_data = expn_data.is_some();\n+        let expn_id = HygieneData::with(|data| data.fresh_expn(expn_data));\n+        if has_data {\n+            update_disambiguator(expn_id);\n+        }\n+        expn_id\n     }\n \n     /// The ID of the theoretical expansion that generates freshly parsed, unexpanded AST.\n@@ -111,7 +120,8 @@ impl ExpnId {\n             assert!(old_expn_data.is_none(), \"expansion data is reset for an expansion ID\");\n             expn_data.orig_id.replace(self.as_u32()).expect_none(\"orig_id should be None\");\n             *old_expn_data = Some(expn_data);\n-        })\n+        });\n+        update_disambiguator(self)\n     }\n \n     pub fn is_descendant_of(self, ancestor: ExpnId) -> bool {\n@@ -152,6 +162,12 @@ pub struct HygieneData {\n     expn_data: Vec<Option<ExpnData>>,\n     syntax_context_data: Vec<SyntaxContextData>,\n     syntax_context_map: FxHashMap<(SyntaxContext, ExpnId, Transparency), SyntaxContext>,\n+    /// Maps the `Fingerprint` of an `ExpnData` to the next disambiguator value.\n+    /// This is used by `update_disambiguator` to keep track of which `ExpnData`s\n+    /// would have collisions without a disambiguator.\n+    /// The keys of this map are always computed with `ExpnData.disambiguator`\n+    /// set to 0.\n+    expn_data_disambiguators: FxHashMap<Fingerprint, u32>,\n }\n \n impl HygieneData {\n@@ -175,6 +191,7 @@ impl HygieneData {\n                 dollar_crate_name: kw::DollarCrate,\n             }],\n             syntax_context_map: FxHashMap::default(),\n+            expn_data_disambiguators: FxHashMap::default(),\n         }\n     }\n \n@@ -649,8 +666,8 @@ impl Span {\n         expn_data: ExpnData,\n         transparency: Transparency,\n     ) -> Span {\n+        let expn_id = ExpnId::fresh(Some(expn_data));\n         HygieneData::with(|data| {\n-            let expn_id = data.fresh_expn(Some(expn_data));\n             self.with_ctxt(data.apply_mark(SyntaxContext::root(), expn_id, transparency))\n         })\n     }\n@@ -726,10 +743,23 @@ pub struct ExpnData {\n     // be considered equivalent.\n     #[stable_hasher(ignore)]\n     orig_id: Option<u32>,\n+\n+    /// Used to force two `ExpnData`s to have different `Fingerprint`s.\n+    /// Due to macro expansion, it's possible to end up with two `ExpnId`s\n+    /// that have identical `ExpnData`s. This violates the constract of `HashStable`\n+    /// - the two `ExpnId`s are not equal, but their `Fingerprint`s are equal\n+    /// (since the numerical `ExpnId` value is not considered by the `HashStable`\n+    /// implementation).\n+    ///\n+    /// The `disambiguator` field is set by `update_disambiguator` when two distinct\n+    /// `ExpnId`s would end up with the same `Fingerprint`. Since `ExpnData` includes\n+    /// a `krate` field, this value only needs to be unique within a single crate.\n+    disambiguator: u32,\n }\n \n-// This would require special handling of `orig_id` and `parent`\n+// These would require special handling of `orig_id`.\n impl !PartialEq for ExpnData {}\n+impl !Hash for ExpnData {}\n \n impl ExpnData {\n     pub fn new(\n@@ -755,6 +785,7 @@ impl ExpnData {\n             macro_def_id,\n             krate: LOCAL_CRATE,\n             orig_id: None,\n+            disambiguator: 0,\n         }\n     }\n \n@@ -777,6 +808,7 @@ impl ExpnData {\n             macro_def_id,\n             krate: LOCAL_CRATE,\n             orig_id: None,\n+            disambiguator: 0,\n         }\n     }\n \n@@ -1276,3 +1308,118 @@ impl<D: Decoder> Decodable<D> for SyntaxContext {\n         panic!(\"cannot decode `SyntaxContext` with `{}`\", std::any::type_name::<D>());\n     }\n }\n+\n+/// Updates the `disambiguator` field of the corresponding `ExpnData`\n+/// such that the `Fingerprint` of the `ExpnData` does not collide with\n+/// any other `ExpnIds`.\n+///\n+/// This method is called only when an `ExpnData` is first associated\n+/// with an `ExpnId` (when the `ExpnId` is initially constructed, or via\n+/// `set_expn_data`). It is *not* called for foreign `ExpnId`s deserialized\n+/// from another crate's metadata - since `ExpnData` includes a `krate` field,\n+/// collisions are only possible between `ExpnId`s within the same crate.\n+fn update_disambiguator(expn_id: ExpnId) {\n+    /// A `HashStableContext` which hashes the raw id values for `DefId`\n+    /// and `CrateNum`, rather than using their computed stable hash.\n+    ///\n+    /// This allows us to use the `HashStable` implementation on `ExpnId`\n+    /// early on in compilation, before we've constructed a `TyCtxt`.\n+    /// The `Fingerprint`s created by this context are not 'stable', since\n+    /// the raw `CrateNum` and `DefId` values for an item may change between\n+    /// sessions due to unrelated changes (e.g. adding/removing an different item).\n+    ///\n+    /// However, this is fine for our purposes - we only need to detect\n+    /// when two `ExpnData`s have the same `Fingerprint`. Since the hashes produced\n+    /// by this context still obey the properties of `HashStable`, we have\n+    /// that\n+    /// `hash_stable(expn1, DummyHashStableContext) == hash_stable(expn2, DummyHashStableContext)`\n+    /// iff `hash_stable(expn1, StableHashingContext) == hash_stable(expn2, StableHasingContext)`.\n+    ///\n+    /// This is sufficient for determining when we need to update the disambiguator.\n+    struct DummyHashStableContext<'a> {\n+        caching_source_map: CachingSourceMapView<'a>,\n+    }\n+\n+    impl<'a> crate::HashStableContext for DummyHashStableContext<'a> {\n+        fn hash_def_id(&mut self, def_id: DefId, hasher: &mut StableHasher) {\n+            def_id.krate.as_u32().hash_stable(self, hasher);\n+            def_id.index.as_u32().hash_stable(self, hasher);\n+        }\n+\n+        fn expn_id_cache() -> &'static LocalKey<ExpnIdCache> {\n+            // This cache is only used by `DummyHashStableContext`,\n+            // so we won't pollute the cache values of the normal `StableHashingContext`\n+            thread_local! {\n+                static CACHE: ExpnIdCache = Default::default();\n+            }\n+\n+            &CACHE\n+        }\n+\n+        fn hash_crate_num(&mut self, krate: CrateNum, hasher: &mut StableHasher) {\n+            krate.as_u32().hash_stable(self, hasher);\n+        }\n+        fn hash_spans(&self) -> bool {\n+            true\n+        }\n+        fn byte_pos_to_line_and_col(\n+            &mut self,\n+            byte: BytePos,\n+        ) -> Option<(Lrc<SourceFile>, usize, BytePos)> {\n+            self.caching_source_map.byte_pos_to_line_and_col(byte)\n+        }\n+        fn span_data_to_lines_and_cols(\n+            &mut self,\n+            span: &crate::SpanData,\n+        ) -> Option<(Lrc<SourceFile>, usize, BytePos, usize, BytePos)> {\n+            self.caching_source_map.span_data_to_lines_and_cols(span)\n+        }\n+    }\n+\n+    let source_map = SESSION_GLOBALS\n+        .with(|session_globals| session_globals.source_map.borrow().as_ref().unwrap().clone());\n+\n+    let mut ctx =\n+        DummyHashStableContext { caching_source_map: CachingSourceMapView::new(&source_map) };\n+\n+    let mut hasher = StableHasher::new();\n+\n+    let expn_data = expn_id.expn_data();\n+    // This disambiguator should not have been set yet.\n+    assert_eq!(\n+        expn_data.disambiguator, 0,\n+        \"Already set disambiguator for ExpnData: {:?}\",\n+        expn_data\n+    );\n+    expn_data.hash_stable(&mut ctx, &mut hasher);\n+    let first_hash = hasher.finish();\n+\n+    let modified = HygieneData::with(|data| {\n+        // If this is the first ExpnData with a given hash, then keep our\n+        // disambiguator at 0 (the default u32 value)\n+        let disambig = data.expn_data_disambiguators.entry(first_hash).or_default();\n+        data.expn_data[expn_id.0 as usize].as_mut().unwrap().disambiguator = *disambig;\n+        *disambig += 1;\n+\n+        *disambig != 1\n+    });\n+\n+    if modified {\n+        info!(\"Set disambiguator for {:?} (hash {:?})\", expn_id, first_hash);\n+        info!(\"expn_data = {:?}\", expn_id.expn_data());\n+\n+        // Verify that the new disambiguator makes the hash unique\n+        #[cfg(debug_assertions)]\n+        {\n+            hasher = StableHasher::new();\n+            expn_id.expn_data().hash_stable(&mut ctx, &mut hasher);\n+            let new_hash: Fingerprint = hasher.finish();\n+\n+            HygieneData::with(|data| {\n+                data.expn_data_disambiguators\n+                    .get(&new_hash)\n+                    .expect_none(\"Hash collision after disambiguator update!\");\n+            });\n+        };\n+    }\n+}"}, {"sha": "f3d876a5770a8b445bd697f2c3a7f0c298b52a13", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3540f9396aff85110277af03b68b3303f3a8b7d3/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3540f9396aff85110277af03b68b3303f3a8b7d3/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=3540f9396aff85110277af03b68b3303f3a8b7d3", "patch": "@@ -65,6 +65,7 @@ use std::hash::Hash;\n use std::ops::{Add, Range, Sub};\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n+use std::thread::LocalKey;\n \n use md5::Md5;\n use sha1::Digest;\n@@ -1865,6 +1866,11 @@ fn lookup_line(lines: &[BytePos], pos: BytePos) -> isize {\n /// instead of implementing everything in rustc_middle.\n pub trait HashStableContext {\n     fn hash_def_id(&mut self, _: DefId, hasher: &mut StableHasher);\n+    /// Obtains a cache for storing the `Fingerprint` of an `ExpnId`.\n+    /// This method allows us to have multiple `HashStableContext` implementations\n+    /// that hash things in a different way, without the results of one polluting\n+    /// the cache of the other.\n+    fn expn_id_cache() -> &'static LocalKey<ExpnIdCache>;\n     fn hash_crate_num(&mut self, _: CrateNum, hasher: &mut StableHasher);\n     fn hash_spans(&self) -> bool;\n     fn byte_pos_to_line_and_col(\n@@ -1961,15 +1967,10 @@ impl<CTX: HashStableContext> HashStable<CTX> for SyntaxContext {\n     }\n }\n \n+pub type ExpnIdCache = RefCell<Vec<Option<Fingerprint>>>;\n+\n impl<CTX: HashStableContext> HashStable<CTX> for ExpnId {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        // Since the same expansion context is usually referenced many\n-        // times, we cache a stable hash of it and hash that instead of\n-        // recursing every time.\n-        thread_local! {\n-            static CACHE: RefCell<Vec<Option<Fingerprint>>> = Default::default();\n-        }\n-\n         const TAG_ROOT: u8 = 0;\n         const TAG_NOT_ROOT: u8 = 1;\n \n@@ -1978,8 +1979,11 @@ impl<CTX: HashStableContext> HashStable<CTX> for ExpnId {\n             return;\n         }\n \n+        // Since the same expansion context is usually referenced many\n+        // times, we cache a stable hash of it and hash that instead of\n+        // recursing every time.\n         let index = self.as_u32() as usize;\n-        let res = CACHE.with(|cache| cache.borrow().get(index).copied().flatten());\n+        let res = CTX::expn_id_cache().with(|cache| cache.borrow().get(index).copied().flatten());\n \n         if let Some(res) = res {\n             res.hash_stable(ctx, hasher);\n@@ -1991,7 +1995,7 @@ impl<CTX: HashStableContext> HashStable<CTX> for ExpnId {\n             self.expn_data().hash_stable(ctx, &mut sub_hasher);\n             let sub_hash: Fingerprint = sub_hasher.finish();\n \n-            CACHE.with(|cache| {\n+            CTX::expn_id_cache().with(|cache| {\n                 let mut cache = cache.borrow_mut();\n                 if cache.len() < new_len {\n                     cache.resize(new_len, None);"}]}