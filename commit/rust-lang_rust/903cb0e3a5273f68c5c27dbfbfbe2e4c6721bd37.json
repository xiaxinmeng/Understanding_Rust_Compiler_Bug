{"sha": "903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwM2NiMGUzYTUyNzNmNjhjNWMyN2RiZmJmYmUyZTRjNjcyMWJkMzc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-15T05:07:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-16T19:31:34Z"}, "message": "core: Factor out uint/u8/16/32/64 mods into uint-template", "tree": {"sha": "1318da03df0e97bdd3793b17779c3e7b294b1ff1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1318da03df0e97bdd3793b17779c3e7b294b1ff1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "html_url": "https://github.com/rust-lang/rust/commit/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bb181341b05221df7b10a61eca60e6011292f52", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bb181341b05221df7b10a61eca60e6011292f52", "html_url": "https://github.com/rust-lang/rust/commit/6bb181341b05221df7b10a61eca60e6011292f52"}], "stats": {"total": 793, "additions": 351, "deletions": 442}, "files": [{"sha": "3659e53e993070588e49bdb373e6d99269d598b6", "filename": "src/libcore/core.rc", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "patch": "@@ -81,18 +81,61 @@ mod i64 {\n     mod inst;\n }\n \n+#[doc = \"Operations and constants for `uint`\"]\n+#[path = \"uint-template\"]\n+mod uint {\n+    import inst::{\n+        div_ceil, div_round, div_floor, hash, iterate,\n+        next_power_of_two, parse_buf, from_str, to_str, str\n+    };\n+    export div_ceil, div_round, div_floor, hash, iterate,\n+    next_power_of_two, parse_buf, from_str, to_str, str;\n+\n+    #[path = \"uint.rs\"]\n+    mod inst;\n+}\n+\n+#[doc = \"Operations and constants for `u8`\"]\n+#[path = \"uint-template\"]\n+mod u8 {\n+    import inst::is_ascii;\n+    export is_ascii;\n+\n+    #[path = \"u8.rs\"]\n+    mod inst;\n+}\n+\n+#[doc = \"Operations and constants for `u16`\"]\n+#[path = \"uint-template\"]\n+mod u16 {\n+    #[path = \"u16.rs\"]\n+    mod inst;\n+}\n+\n+#[doc = \"Operations and constants for `u32`\"]\n+#[path = \"uint-template\"]\n+mod u32 {\n+    #[path = \"u32.rs\"]\n+    mod inst;\n+}\n+\n+#[doc = \"Operations and constants for `u64`\"]\n+#[path = \"uint-template\"]\n+mod u64 {\n+    import inst::{ to_str, str, from_str };\n+    export to_str, str, from_str;\n+\n+    #[path = \"u64.rs\"]\n+    mod inst;\n+}\n+\n mod box;\n mod char;\n mod float;\n mod f32;\n mod f64;\n mod str;\n mod ptr;\n-mod uint;\n-mod u8;\n-mod u16;\n-mod u32;\n-mod u64;\n mod vec;\n mod bool;\n "}, {"sha": "16ca4800f81ceabfb8cc1e2972a006be6bb47fac", "filename": "src/libcore/u16.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6bb181341b05221df7b10a61eca60e6011292f52/src%2Flibcore%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb181341b05221df7b10a61eca60e6011292f52/src%2Flibcore%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu16.rs?ref=6bb181341b05221df7b10a61eca60e6011292f52", "patch": "@@ -1,36 +0,0 @@\n-#[doc = \"Operations and constants for `u16`\"];\n-\n-const min_value: u16 = 0u16;\n-const max_value: u16 = 0u16 - 1u16;\n-\n-pure fn min(x: u16, y: u16) -> u16 { if x < y { x } else { y } }\n-pure fn max(x: u16, y: u16) -> u16 { if x > y { x } else { y } }\n-\n-pure fn add(x: u16, y: u16) -> u16 { x + y }\n-pure fn sub(x: u16, y: u16) -> u16 { x - y }\n-pure fn mul(x: u16, y: u16) -> u16 { x * y }\n-pure fn div(x: u16, y: u16) -> u16 { x / y }\n-pure fn rem(x: u16, y: u16) -> u16 { x % y }\n-\n-pure fn lt(x: u16, y: u16) -> bool { x < y }\n-pure fn le(x: u16, y: u16) -> bool { x <= y }\n-pure fn eq(x: u16, y: u16) -> bool { x == y }\n-pure fn ne(x: u16, y: u16) -> bool { x != y }\n-pure fn ge(x: u16, y: u16) -> bool { x >= y }\n-pure fn gt(x: u16, y: u16) -> bool { x > y }\n-\n-pure fn is_positive(x: u16) -> bool { x > 0u16 }\n-pure fn is_negative(x: u16) -> bool { x < 0u16 }\n-pure fn is_nonpositive(x: u16) -> bool { x <= 0u16 }\n-pure fn is_nonnegative(x: u16) -> bool { x >= 0u16 }\n-\n-#[doc = \"Iterate over the range [`lo`..`hi`)\"]\n-fn range(lo: u16, hi: u16, it: fn(u16)) {\n-    let mut i = lo;\n-    while i < hi { it(i); i += 1u16; }\n-}\n-\n-#[doc = \"Computes the bitwise complement\"]\n-pure fn compl(i: u16) -> u16 {\n-    max_value ^ i\n-}"}, {"sha": "dfe88b19e6a6ebbe76bb7ba29826aa93588f56aa", "filename": "src/libcore/u32.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6bb181341b05221df7b10a61eca60e6011292f52/src%2Flibcore%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb181341b05221df7b10a61eca60e6011292f52/src%2Flibcore%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu32.rs?ref=6bb181341b05221df7b10a61eca60e6011292f52", "patch": "@@ -1,41 +0,0 @@\n-#[doc = \"Operations and constants for `u32`\"];\n-\n-const min_value: u32 = 0u32;\n-const max_value: u32 = 0u32 - 1u32;\n-\n-pure fn min(x: u32, y: u32) -> u32 { if x < y { x } else { y } }\n-pure fn max(x: u32, y: u32) -> u32 { if x > y { x } else { y } }\n-\n-pure fn add(x: u32, y: u32) -> u32 { ret x + y; }\n-pure fn sub(x: u32, y: u32) -> u32 { ret x - y; }\n-pure fn mul(x: u32, y: u32) -> u32 { ret x * y; }\n-pure fn div(x: u32, y: u32) -> u32 { ret x / y; }\n-pure fn rem(x: u32, y: u32) -> u32 { ret x % y; }\n-\n-pure fn lt(x: u32, y: u32) -> bool { ret x < y; }\n-pure fn le(x: u32, y: u32) -> bool { ret x <= y; }\n-pure fn eq(x: u32, y: u32) -> bool { ret x == y; }\n-pure fn ne(x: u32, y: u32) -> bool { ret x != y; }\n-pure fn ge(x: u32, y: u32) -> bool { ret x >= y; }\n-pure fn gt(x: u32, y: u32) -> bool { ret x > y; }\n-\n-#[doc = \"Iterate over the range [`lo`..`hi`)\"]\n-fn range(lo: u32, hi: u32, it: fn(u32)) {\n-    let mut i = lo;\n-    while i < hi { it(i); i += 1u32; }\n-}\n-\n-#[doc = \"Computes the bitwise complement\"]\n-pure fn compl(i: u32) -> u32 {\n-    max_value ^ i\n-}\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "613b1d6b15b96e55ac0dcd46750e2151aa3406a7", "filename": "src/libcore/u8.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6bb181341b05221df7b10a61eca60e6011292f52/src%2Flibcore%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb181341b05221df7b10a61eca60e6011292f52/src%2Flibcore%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu8.rs?ref=6bb181341b05221df7b10a61eca60e6011292f52", "patch": "@@ -1,41 +0,0 @@\n-#[doc = \"Operations and constants for `u8`\"];\n-\n-const min_value: u8 = 0u8;\n-const max_value: u8 = 0u8 - 1u8;\n-\n-pure fn min(x: u8, y: u8) -> u8 { if x < y { x } else { y } }\n-pure fn max(x: u8, y: u8) -> u8 { if x > y { x } else { y } }\n-\n-pure fn add(x: u8, y: u8) -> u8 { ret x + y; }\n-pure fn sub(x: u8, y: u8) -> u8 { ret x - y; }\n-pure fn mul(x: u8, y: u8) -> u8 { ret x * y; }\n-pure fn div(x: u8, y: u8) -> u8 { ret x / y; }\n-pure fn rem(x: u8, y: u8) -> u8 { ret x % y; }\n-\n-pure fn lt(x: u8, y: u8) -> bool { ret x < y; }\n-pure fn le(x: u8, y: u8) -> bool { ret x <= y; }\n-pure fn eq(x: u8, y: u8) -> bool { ret x == y; }\n-pure fn ne(x: u8, y: u8) -> bool { ret x != y; }\n-pure fn ge(x: u8, y: u8) -> bool { ret x >= y; }\n-pure fn gt(x: u8, y: u8) -> bool { ret x > y; }\n-\n-pure fn is_ascii(x: u8) -> bool { ret 0u8 == x & 128u8; }\n-\n-#[doc = \"Iterate over the range [`lo`..`hi`)\"]\n-fn range(lo: u8, hi: u8, it: fn(u8)) {\n-    let mut i = lo;\n-    while i < hi { it(i); i += 1u8; }\n-}\n-\n-#[doc = \"Computes the bitwise complement\"]\n-pure fn compl(i: u8) -> u8 {\n-    max_value ^ i\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "0b95aadcb6afe0fc243b9c990c526c403b678260", "filename": "src/libcore/uint-template.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "patch": "@@ -0,0 +1,45 @@\n+import T = inst::T;\n+\n+export min_value, max_value;\n+export min, max;\n+export add, sub, mul, div, rem;\n+export lt, le, eq, ne, ge, gt;\n+export is_positive, is_negative;\n+export is_nonpositive, is_nonnegative;\n+export range;\n+export compl;\n+\n+const min_value: T = 0 as T;\n+const max_value: T = 0 as T - 1 as T;\n+\n+pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n+pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n+\n+pure fn add(x: T, y: T) -> T { x + y }\n+pure fn sub(x: T, y: T) -> T { x - y }\n+pure fn mul(x: T, y: T) -> T { x * y }\n+pure fn div(x: T, y: T) -> T { x / y }\n+pure fn rem(x: T, y: T) -> T { x % y }\n+\n+pure fn lt(x: T, y: T) -> bool { x < y }\n+pure fn le(x: T, y: T) -> bool { x <= y }\n+pure fn eq(x: T, y: T) -> bool { x == y }\n+pure fn ne(x: T, y: T) -> bool { x != y }\n+pure fn ge(x: T, y: T) -> bool { x >= y }\n+pure fn gt(x: T, y: T) -> bool { x > y }\n+\n+pure fn is_positive(x: T) -> bool { x > 0 as T }\n+pure fn is_negative(x: T) -> bool { x < 0 as T }\n+pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n+pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n+\n+#[doc = \"Iterate over the range [`lo`..`hi`)\"]\n+fn range(lo: T, hi: T, it: fn(T)) {\n+    let mut i = lo;\n+    while i < hi { it(i); i += 1 as T; }\n+}\n+\n+#[doc = \"Computes the bitwise complement\"]\n+pure fn compl(i: T) -> T {\n+    max_value ^ i\n+}"}, {"sha": "8d03656d6fe1dcd306999f1426696208b7590ce5", "filename": "src/libcore/uint-template/u16.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu16.rs?ref=903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "patch": "@@ -0,0 +1 @@\n+type T = u16;"}, {"sha": "df9cf28a16c0e54d1910c42433e46e4270a06405", "filename": "src/libcore/uint-template/u32.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu32.rs?ref=903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "patch": "@@ -0,0 +1 @@\n+type T = u32;"}, {"sha": "5de83d41da3584d4b4670c7171cb0083372c2f49", "filename": "src/libcore/uint-template/u64.rs", "status": "renamed", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu64.rs?ref=903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "patch": "@@ -1,30 +1,10 @@\n-#[doc = \"Operations and constants for `u64`\"];\n+type T = u64;\n \n-const min_value: u64 = 0u64;\n-const max_value: u64 = 0u64 - 1u64;\n+// Type-specific functions here. These must be reexported by the\n+// parent module so that they appear in core::u8 and not core::u8::u8;\n \n-pure fn min(x: u64, y: u64) -> u64 { if x < y { x } else { y } }\n-pure fn max(x: u64, y: u64) -> u64 { if x > y { x } else { y } }\n-\n-pure fn add(x: u64, y: u64) -> u64 { ret x + y; }\n-pure fn sub(x: u64, y: u64) -> u64 { ret x - y; }\n-pure fn mul(x: u64, y: u64) -> u64 { ret x * y; }\n-pure fn div(x: u64, y: u64) -> u64 { ret x / y; }\n-pure fn rem(x: u64, y: u64) -> u64 { ret x % y; }\n-\n-pure fn lt(x: u64, y: u64) -> bool { ret x < y; }\n-pure fn le(x: u64, y: u64) -> bool { ret x <= y; }\n-pure fn eq(x: u64, y: u64) -> bool { ret x == y; }\n-pure fn ne(x: u64, y: u64) -> bool { ret x != y; }\n-pure fn ge(x: u64, y: u64) -> bool { ret x >= y; }\n-pure fn gt(x: u64, y: u64) -> bool { ret x > y; }\n-\n-#[doc = \"Iterate over the range [`lo`..`hi`)\"]\n-fn range(lo: u64, hi: u64, it: fn(u64)) {\n-    let mut i = lo;\n-    while i < hi { it(i); i += 1u64; }\n-}\n \n+// FIXME: Surely we can generalize this to apply to all uint types\n #[doc = \"Convert to a string in a given base\"]\n fn to_str(n: u64, radix: uint) -> str {\n     assert (0u < radix && radix <= 16u);\n@@ -80,8 +60,3 @@ fn from_str(buf: str, radix: u64) -> option<u64> {\n         i -= 1u;\n     };\n }\n-\n-#[doc = \"Computes the bitwise complement\"]\n-pure fn compl(i: u64) -> u64 {\n-    max_value ^ i\n-}", "previous_filename": "src/libcore/u64.rs"}, {"sha": "bc73536c4a4072b86643483efab7cf426036f153", "filename": "src/libcore/uint-template/u8.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu8.rs?ref=903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "patch": "@@ -0,0 +1,6 @@\n+type T = u8;\n+\n+// Type-specific functions here. These must be reexported by the\n+// parent module so that they appear in core::u8 and not core::u8::u8;\n+\n+pure fn is_ascii(x: T) -> bool { ret 0 as T == x & 128 as T; }"}, {"sha": "27a8c26a2483da51fa98d54990dcacb0cf2c83f0", "filename": "src/libcore/uint-template/uint.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37/src%2Flibcore%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fuint.rs?ref=903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "patch": "@@ -0,0 +1,246 @@\n+type T = uint;\n+\n+#[doc = \"\n+Divide two numbers, return the result, rounded up.\n+\n+# Arguments\n+\n+* x - an integer\n+* y - an integer distinct from 0u\n+\n+# Return value\n+\n+The smallest integer `q` such that `x/y <= q`.\n+\"]\n+pure fn div_ceil(x: uint, y: uint) -> uint {\n+    let div = div(x, y);\n+    if x % y == 0u { ret div;}\n+    else { ret div + 1u; }\n+}\n+\n+#[doc = \"\n+Divide two numbers, return the result, rounded to the closest integer.\n+\n+# Arguments\n+\n+* x - an integer\n+* y - an integer distinct from 0u\n+\n+# Return value\n+\n+The integer `q` closest to `x/y`.\n+\"]\n+pure fn div_round(x: uint, y: uint) -> uint {\n+    let div = div(x, y);\n+    if x % y * 2u  < y { ret div;}\n+    else { ret div + 1u; }\n+}\n+\n+#[doc = \"\n+Divide two numbers, return the result, rounded down.\n+\n+Note: This is the same function as `div`.\n+\n+# Arguments\n+\n+* x - an integer\n+* y - an integer distinct from 0u\n+\n+# Return value\n+\n+The smallest integer `q` such that `x/y <= q`. This\n+is either `x/y` or `x/y + 1`.\n+\"]\n+pure fn div_floor(x: uint, y: uint) -> uint { ret x / y; }\n+\n+#[doc = \"Produce a uint suitable for use in a hash table\"]\n+pure fn hash(x: uint) -> uint { ret x; }\n+\n+#[doc = \"\n+Iterate over the range [`lo`..`hi`), or stop when requested\n+\n+# Arguments\n+\n+* lo - The integer at which to start the loop (included)\n+* hi - The integer at which to stop the loop (excluded)\n+* it - A block to execute with each consecutive integer of the range.\n+       Return `true` to continue, `false` to stop.\n+\n+# Return value\n+\n+`true` If execution proceeded correctly, `false` if it was interrupted,\n+that is if `it` returned `false` at any point.\n+\"]\n+fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n+    let mut i = lo;\n+    while i < hi {\n+        if (!it(i)) { ret false; }\n+        i += 1u;\n+    }\n+    ret true;\n+}\n+\n+#[doc = \"Returns the smallest power of 2 greater than or equal to `n`\"]\n+fn next_power_of_two(n: uint) -> uint {\n+    let halfbits: uint = sys::size_of::<uint>() * 4u;\n+    let mut tmp: uint = n - 1u;\n+    let mut shift: uint = 1u;\n+    while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n+    ret tmp + 1u;\n+}\n+\n+#[doc = \"\n+Parse a buffer of bytes\n+\n+# Arguments\n+\n+* buf - A byte buffer\n+* radix - The base of the number\n+\n+# Failure\n+\n+`buf` must not be empty\n+\"]\n+fn parse_buf(buf: [u8], radix: uint) -> option<uint> {\n+    if vec::len(buf) == 0u { ret none; }\n+    let mut i = vec::len(buf) - 1u;\n+    let mut power = 1u;\n+    let mut n = 0u;\n+    loop {\n+        alt char::to_digit(buf[i] as char, radix) {\n+          some(d) { n += d * power; }\n+          none { ret none; }\n+        }\n+        power *= radix;\n+        if i == 0u { ret some(n); }\n+        i -= 1u;\n+    };\n+}\n+\n+#[doc = \"Parse a string to an int\"]\n+fn from_str(s: str) -> option<uint> { parse_buf(str::bytes(s), 10u) }\n+\n+#[doc = \"Convert to a string in a given base\"]\n+fn to_str(num: uint, radix: uint) -> str {\n+    let mut n = num;\n+    assert (0u < radix && radix <= 16u);\n+    fn digit(n: uint) -> char {\n+        ret alt n {\n+              0u { '0' }\n+              1u { '1' }\n+              2u { '2' }\n+              3u { '3' }\n+              4u { '4' }\n+              5u { '5' }\n+              6u { '6' }\n+              7u { '7' }\n+              8u { '8' }\n+              9u { '9' }\n+              10u { 'a' }\n+              11u { 'b' }\n+              12u { 'c' }\n+              13u { 'd' }\n+              14u { 'e' }\n+              15u { 'f' }\n+              _ { fail }\n+            };\n+    }\n+    if n == 0u { ret \"0\"; }\n+    let mut s: str = \"\";\n+    while n != 0u {\n+        s += str::from_byte(digit(n % radix) as u8);\n+        n /= radix;\n+    }\n+    let mut s1: str = \"\";\n+    let mut len: uint = str::len(s);\n+    while len != 0u { len -= 1u; s1 += str::from_byte(s[len]); }\n+    ret s1;\n+}\n+\n+#[doc = \"Convert to a string\"]\n+fn str(i: uint) -> str { ret to_str(i, 10u); }\n+\n+#[test]\n+fn test_from_str() {\n+    assert uint::from_str(\"0\") == some(0u);\n+    assert uint::from_str(\"3\") == some(3u);\n+    assert uint::from_str(\"10\") == some(10u);\n+    assert uint::from_str(\"123456789\") == some(123456789u);\n+    assert uint::from_str(\"00100\") == some(100u);\n+\n+    assert uint::from_str(\"\") == none;\n+    assert uint::from_str(\" \") == none;\n+    assert uint::from_str(\"x\") == none;\n+}\n+\n+#[Test]\n+fn test_parse_buf() {\n+    import str::bytes;\n+    assert uint::parse_buf(bytes(\"123\"), 10u) == some(123u);\n+    assert uint::parse_buf(bytes(\"1001\"), 2u) == some(9u);\n+    assert uint::parse_buf(bytes(\"123\"), 8u) == some(83u);\n+    assert uint::parse_buf(bytes(\"123\"), 16u) == some(291u);\n+    assert uint::parse_buf(bytes(\"ffff\"), 16u) == some(65535u);\n+    assert uint::parse_buf(bytes(\"z\"), 36u) == some(35u);\n+\n+    assert uint::parse_buf(str::bytes(\"Z\"), 10u) == none;\n+    assert uint::parse_buf(str::bytes(\"_\"), 2u) == none;\n+}\n+\n+#[test]\n+fn test_next_power_of_two() {\n+    assert (uint::next_power_of_two(0u) == 0u);\n+    assert (uint::next_power_of_two(1u) == 1u);\n+    assert (uint::next_power_of_two(2u) == 2u);\n+    assert (uint::next_power_of_two(3u) == 4u);\n+    assert (uint::next_power_of_two(4u) == 4u);\n+    assert (uint::next_power_of_two(5u) == 8u);\n+    assert (uint::next_power_of_two(6u) == 8u);\n+    assert (uint::next_power_of_two(7u) == 8u);\n+    assert (uint::next_power_of_two(8u) == 8u);\n+    assert (uint::next_power_of_two(9u) == 16u);\n+    assert (uint::next_power_of_two(10u) == 16u);\n+    assert (uint::next_power_of_two(11u) == 16u);\n+    assert (uint::next_power_of_two(12u) == 16u);\n+    assert (uint::next_power_of_two(13u) == 16u);\n+    assert (uint::next_power_of_two(14u) == 16u);\n+    assert (uint::next_power_of_two(15u) == 16u);\n+    assert (uint::next_power_of_two(16u) == 16u);\n+    assert (uint::next_power_of_two(17u) == 32u);\n+    assert (uint::next_power_of_two(18u) == 32u);\n+    assert (uint::next_power_of_two(19u) == 32u);\n+    assert (uint::next_power_of_two(20u) == 32u);\n+    assert (uint::next_power_of_two(21u) == 32u);\n+    assert (uint::next_power_of_two(22u) == 32u);\n+    assert (uint::next_power_of_two(23u) == 32u);\n+    assert (uint::next_power_of_two(24u) == 32u);\n+    assert (uint::next_power_of_two(25u) == 32u);\n+    assert (uint::next_power_of_two(26u) == 32u);\n+    assert (uint::next_power_of_two(27u) == 32u);\n+    assert (uint::next_power_of_two(28u) == 32u);\n+    assert (uint::next_power_of_two(29u) == 32u);\n+    assert (uint::next_power_of_two(30u) == 32u);\n+    assert (uint::next_power_of_two(31u) == 32u);\n+    assert (uint::next_power_of_two(32u) == 32u);\n+    assert (uint::next_power_of_two(33u) == 64u);\n+    assert (uint::next_power_of_two(34u) == 64u);\n+    assert (uint::next_power_of_two(35u) == 64u);\n+    assert (uint::next_power_of_two(36u) == 64u);\n+    assert (uint::next_power_of_two(37u) == 64u);\n+    assert (uint::next_power_of_two(38u) == 64u);\n+    assert (uint::next_power_of_two(39u) == 64u);\n+}\n+\n+#[test]\n+fn test_overflows() {\n+    assert (uint::max_value > 0u);\n+    assert (uint::min_value <= 0u);\n+    assert (uint::min_value + uint::max_value + 1u == 0u);\n+}\n+\n+#[test]\n+fn test_div() {\n+    assert(uint::div_floor(3u, 4u) == 0u);\n+    assert(uint::div_ceil(3u, 4u)  == 1u);\n+    assert(uint::div_round(3u, 4u) == 1u);\n+}"}, {"sha": "d2b04d78dca271d4b0d320111ce2529ecc849bda", "filename": "src/libcore/uint.rs", "status": "removed", "additions": 0, "deletions": 290, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/6bb181341b05221df7b10a61eca60e6011292f52/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb181341b05221df7b10a61eca60e6011292f52/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=6bb181341b05221df7b10a61eca60e6011292f52", "patch": "@@ -1,290 +0,0 @@\n-#[doc = \"Operations and constants for `uint`\"];\n-\n-const min_value: uint = 0u;\n-const max_value: uint = 0u - 1u;\n-\n-pure fn min(x: uint, y: uint) -> uint { if x < y { x } else { y } }\n-pure fn max(x: uint, y: uint) -> uint { if x > y { x } else { y } }\n-\n-pure fn add(x: uint, y: uint) -> uint { ret x + y; }\n-pure fn sub(x: uint, y: uint) -> uint { ret x - y; }\n-pure fn mul(x: uint, y: uint) -> uint { ret x * y; }\n-pure fn div(x: uint, y: uint) -> uint { ret x / y; }\n-pure fn rem(x: uint, y: uint) -> uint { ret x % y; }\n-\n-pure fn lt(x: uint, y: uint) -> bool { ret x < y; }\n-pure fn le(x: uint, y: uint) -> bool { ret x <= y; }\n-pure fn eq(x: uint, y: uint) -> bool { ret x == y; }\n-pure fn ne(x: uint, y: uint) -> bool { ret x != y; }\n-pure fn ge(x: uint, y: uint) -> bool { ret x >= y; }\n-pure fn gt(x: uint, y: uint) -> bool { ret x > y; }\n-\n-\n-#[doc = \"\n-Divide two numbers, return the result, rounded up.\n-\n-# Arguments\n-\n-* x - an integer\n-* y - an integer distinct from 0u\n-\n-# Return value\n-\n-The smallest integer `q` such that `x/y <= q`.\n-\"]\n-pure fn div_ceil(x: uint, y: uint) -> uint {\n-    let div = div(x, y);\n-    if x % y == 0u { ret div;}\n-    else { ret div + 1u; }\n-}\n-\n-#[doc = \"\n-Divide two numbers, return the result, rounded to the closest integer.\n-\n-# Arguments\n-\n-* x - an integer\n-* y - an integer distinct from 0u\n-\n-# Return value\n-\n-The integer `q` closest to `x/y`.\n-\"]\n-pure fn div_round(x: uint, y: uint) -> uint {\n-    let div = div(x, y);\n-    if x % y * 2u  < y { ret div;}\n-    else { ret div + 1u; }\n-}\n-\n-#[doc = \"\n-Divide two numbers, return the result, rounded down.\n-\n-Note: This is the same function as `div`.\n-\n-# Arguments\n-\n-* x - an integer\n-* y - an integer distinct from 0u\n-\n-# Return value\n-\n-The smallest integer `q` such that `x/y <= q`. This\n-is either `x/y` or `x/y + 1`.\n-\"]\n-pure fn div_floor(x: uint, y: uint) -> uint { ret x / y; }\n-\n-#[doc = \"Produce a uint suitable for use in a hash table\"]\n-pure fn hash(x: uint) -> uint { ret x; }\n-\n-#[doc = \"Iterate over the range [`lo`..`hi`)\"]\n-#[inline(always)]\n-fn range(lo: uint, hi: uint, it: fn(uint)) {\n-    let mut i = lo;\n-    while i < hi { it(i); i += 1u; }\n-}\n-\n-#[doc = \"\n-Iterate over the range [`lo`..`hi`), or stop when requested\n-\n-# Arguments\n-\n-* lo - The integer at which to start the loop (included)\n-* hi - The integer at which to stop the loop (excluded)\n-* it - A block to execute with each consecutive integer of the range.\n-       Return `true` to continue, `false` to stop.\n-\n-# Return value\n-\n-`true` If execution proceeded correctly, `false` if it was interrupted,\n-that is if `it` returned `false` at any point.\n-\"]\n-fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n-    let mut i = lo;\n-    while i < hi {\n-        if (!it(i)) { ret false; }\n-        i += 1u;\n-    }\n-    ret true;\n-}\n-\n-#[doc = \"Returns the smallest power of 2 greater than or equal to `n`\"]\n-fn next_power_of_two(n: uint) -> uint {\n-    let halfbits: uint = sys::size_of::<uint>() * 4u;\n-    let mut tmp: uint = n - 1u;\n-    let mut shift: uint = 1u;\n-    while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n-    ret tmp + 1u;\n-}\n-\n-#[doc = \"\n-Parse a buffer of bytes\n-\n-# Arguments\n-\n-* buf - A byte buffer\n-* radix - The base of the number\n-\n-# Failure\n-\n-`buf` must not be empty\n-\"]\n-fn parse_buf(buf: [u8], radix: uint) -> option<uint> {\n-    if vec::len(buf) == 0u { ret none; }\n-    let mut i = vec::len(buf) - 1u;\n-    let mut power = 1u;\n-    let mut n = 0u;\n-    loop {\n-        alt char::to_digit(buf[i] as char, radix) {\n-          some(d) { n += d * power; }\n-          none { ret none; }\n-        }\n-        power *= radix;\n-        if i == 0u { ret some(n); }\n-        i -= 1u;\n-    };\n-}\n-\n-#[doc = \"Parse a string to an int\"]\n-fn from_str(s: str) -> option<uint> { parse_buf(str::bytes(s), 10u) }\n-\n-#[doc = \"Convert to a string in a given base\"]\n-fn to_str(num: uint, radix: uint) -> str {\n-    let mut n = num;\n-    assert (0u < radix && radix <= 16u);\n-    fn digit(n: uint) -> char {\n-        ret alt n {\n-              0u { '0' }\n-              1u { '1' }\n-              2u { '2' }\n-              3u { '3' }\n-              4u { '4' }\n-              5u { '5' }\n-              6u { '6' }\n-              7u { '7' }\n-              8u { '8' }\n-              9u { '9' }\n-              10u { 'a' }\n-              11u { 'b' }\n-              12u { 'c' }\n-              13u { 'd' }\n-              14u { 'e' }\n-              15u { 'f' }\n-              _ { fail }\n-            };\n-    }\n-    if n == 0u { ret \"0\"; }\n-    let mut s: str = \"\";\n-    while n != 0u {\n-        s += str::from_byte(digit(n % radix) as u8);\n-        n /= radix;\n-    }\n-    let mut s1: str = \"\";\n-    let mut len: uint = str::len(s);\n-    while len != 0u { len -= 1u; s1 += str::from_byte(s[len]); }\n-    ret s1;\n-}\n-\n-#[doc = \"Convert to a string\"]\n-fn str(i: uint) -> str { ret to_str(i, 10u); }\n-\n-#[doc = \"Computes the bitwise complement\"]\n-pure fn compl(i: uint) -> uint {\n-    max_value ^ i\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-    #[test]\n-    fn test_from_str() {\n-        assert uint::from_str(\"0\") == some(0u);\n-        assert uint::from_str(\"3\") == some(3u);\n-        assert uint::from_str(\"10\") == some(10u);\n-        assert uint::from_str(\"123456789\") == some(123456789u);\n-        assert uint::from_str(\"00100\") == some(100u);\n-\n-        assert uint::from_str(\"\") == none;\n-        assert uint::from_str(\" \") == none;\n-        assert uint::from_str(\"x\") == none;\n-    }\n-\n-    #[Test]\n-    fn test_parse_buf() {\n-        import str::bytes;\n-        assert uint::parse_buf(bytes(\"123\"), 10u) == some(123u);\n-        assert uint::parse_buf(bytes(\"1001\"), 2u) == some(9u);\n-        assert uint::parse_buf(bytes(\"123\"), 8u) == some(83u);\n-        assert uint::parse_buf(bytes(\"123\"), 16u) == some(291u);\n-        assert uint::parse_buf(bytes(\"ffff\"), 16u) == some(65535u);\n-        assert uint::parse_buf(bytes(\"z\"), 36u) == some(35u);\n-\n-        assert uint::parse_buf(str::bytes(\"Z\"), 10u) == none;\n-        assert uint::parse_buf(str::bytes(\"_\"), 2u) == none;\n-    }\n-\n-    #[test]\n-    fn test_next_power_of_two() {\n-        assert (uint::next_power_of_two(0u) == 0u);\n-        assert (uint::next_power_of_two(1u) == 1u);\n-        assert (uint::next_power_of_two(2u) == 2u);\n-        assert (uint::next_power_of_two(3u) == 4u);\n-        assert (uint::next_power_of_two(4u) == 4u);\n-        assert (uint::next_power_of_two(5u) == 8u);\n-        assert (uint::next_power_of_two(6u) == 8u);\n-        assert (uint::next_power_of_two(7u) == 8u);\n-        assert (uint::next_power_of_two(8u) == 8u);\n-        assert (uint::next_power_of_two(9u) == 16u);\n-        assert (uint::next_power_of_two(10u) == 16u);\n-        assert (uint::next_power_of_two(11u) == 16u);\n-        assert (uint::next_power_of_two(12u) == 16u);\n-        assert (uint::next_power_of_two(13u) == 16u);\n-        assert (uint::next_power_of_two(14u) == 16u);\n-        assert (uint::next_power_of_two(15u) == 16u);\n-        assert (uint::next_power_of_two(16u) == 16u);\n-        assert (uint::next_power_of_two(17u) == 32u);\n-        assert (uint::next_power_of_two(18u) == 32u);\n-        assert (uint::next_power_of_two(19u) == 32u);\n-        assert (uint::next_power_of_two(20u) == 32u);\n-        assert (uint::next_power_of_two(21u) == 32u);\n-        assert (uint::next_power_of_two(22u) == 32u);\n-        assert (uint::next_power_of_two(23u) == 32u);\n-        assert (uint::next_power_of_two(24u) == 32u);\n-        assert (uint::next_power_of_two(25u) == 32u);\n-        assert (uint::next_power_of_two(26u) == 32u);\n-        assert (uint::next_power_of_two(27u) == 32u);\n-        assert (uint::next_power_of_two(28u) == 32u);\n-        assert (uint::next_power_of_two(29u) == 32u);\n-        assert (uint::next_power_of_two(30u) == 32u);\n-        assert (uint::next_power_of_two(31u) == 32u);\n-        assert (uint::next_power_of_two(32u) == 32u);\n-        assert (uint::next_power_of_two(33u) == 64u);\n-        assert (uint::next_power_of_two(34u) == 64u);\n-        assert (uint::next_power_of_two(35u) == 64u);\n-        assert (uint::next_power_of_two(36u) == 64u);\n-        assert (uint::next_power_of_two(37u) == 64u);\n-        assert (uint::next_power_of_two(38u) == 64u);\n-        assert (uint::next_power_of_two(39u) == 64u);\n-    }\n-\n-    #[test]\n-    fn test_overflows() {\n-        assert (uint::max_value > 0u);\n-        assert (uint::min_value <= 0u);\n-        assert (uint::min_value + uint::max_value + 1u == 0u);\n-    }\n-\n-    #[test]\n-    fn test_div() {\n-        assert(uint::div_floor(3u, 4u) == 0u);\n-        assert(uint::div_ceil(3u, 4u)  == 1u);\n-        assert(uint::div_round(3u, 4u) == 1u);\n-    }\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}]}