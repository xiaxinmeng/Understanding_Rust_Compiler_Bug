{"sha": "54684c438f83f84c01024fb44fdfdba54c88b7da", "node_id": "C_kwDOAAsO6NoAKDU0Njg0YzQzOGY4M2Y4NGMwMTAyNGZiNDRmZGZkYmE1NGM4OGI3ZGE", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-09-10T20:24:28Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-09-10T21:52:34Z"}, "message": "Alternate approach; just modify Drain", "tree": {"sha": "20264d761283b5ec85728dc6e95aefe7542baddb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20264d761283b5ec85728dc6e95aefe7542baddb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54684c438f83f84c01024fb44fdfdba54c88b7da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54684c438f83f84c01024fb44fdfdba54c88b7da", "html_url": "https://github.com/rust-lang/rust/commit/54684c438f83f84c01024fb44fdfdba54c88b7da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54684c438f83f84c01024fb44fdfdba54c88b7da/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25f4cb59d3a6cc365b54a82088aafc95c4aad0e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/25f4cb59d3a6cc365b54a82088aafc95c4aad0e2", "html_url": "https://github.com/rust-lang/rust/commit/25f4cb59d3a6cc365b54a82088aafc95c4aad0e2"}], "stats": {"total": 111, "additions": 59, "deletions": 52}, "files": [{"sha": "41baa7102cdcedb2866ca80c913b81781ef6de3f", "filename": "library/alloc/src/collections/vec_deque/drain.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/54684c438f83f84c01024fb44fdfdba54c88b7da/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54684c438f83f84c01024fb44fdfdba54c88b7da/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs?ref=54684c438f83f84c01024fb44fdfdba54c88b7da", "patch": "@@ -1,10 +1,12 @@\n+use core::fmt;\n use core::iter::FusedIterator;\n+use core::marker::PhantomData;\n+use core::mem::{self, MaybeUninit};\n use core::ptr::{self, NonNull};\n-use core::{fmt, mem};\n \n use crate::alloc::{Allocator, Global};\n \n-use super::{count, Iter, VecDeque};\n+use super::{count, wrap_index, VecDeque};\n \n /// A draining iterator over the elements of a `VecDeque`.\n ///\n@@ -20,18 +22,24 @@ pub struct Drain<\n > {\n     after_tail: usize,\n     after_head: usize,\n-    iter: Iter<'a, T>,\n+    ring: NonNull<[T]>,\n+    tail: usize,\n+    head: usize,\n     deque: NonNull<VecDeque<T, A>>,\n+    _phantom: PhantomData<&'a T>,\n }\n \n impl<'a, T, A: Allocator> Drain<'a, T, A> {\n     pub(super) unsafe fn new(\n         after_tail: usize,\n         after_head: usize,\n-        iter: Iter<'a, T>,\n+        ring: &'a [MaybeUninit<T>],\n+        tail: usize,\n+        head: usize,\n         deque: NonNull<VecDeque<T, A>>,\n     ) -> Self {\n-        Drain { after_tail, after_head, iter, deque }\n+        let ring = unsafe { NonNull::new_unchecked(ring as *const [MaybeUninit<T>] as *mut _) };\n+        Drain { after_tail, after_head, ring, tail, head, deque, _phantom: PhantomData }\n     }\n }\n \n@@ -41,7 +49,9 @@ impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n         f.debug_tuple(\"Drain\")\n             .field(&self.after_tail)\n             .field(&self.after_head)\n-            .field(&self.iter)\n+            .field(&self.ring)\n+            .field(&self.tail)\n+            .field(&self.head)\n             .finish()\n     }\n }\n@@ -118,20 +128,36 @@ impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        self.iter.next().map(|elt| unsafe { ptr::read(elt) })\n+        if self.tail == self.head {\n+            return None;\n+        }\n+        let tail = self.tail;\n+        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n+        // Safety:\n+        // - `self.tail` in a ring buffer is always a valid index.\n+        // - `self.head` and `self.tail` equality is checked above.\n+        unsafe { Some(ptr::read(self.ring.as_ptr().get_unchecked_mut(tail))) }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+        let len = count(self.tail, self.head, self.ring.len());\n+        (len, Some(len))\n     }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n-        self.iter.next_back().map(|elt| unsafe { ptr::read(elt) })\n+        if self.tail == self.head {\n+            return None;\n+        }\n+        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n+        // Safety:\n+        // - `self.head` in a ring buffer is always a valid index.\n+        // - `self.head` and `self.tail` equality is checked above.\n+        unsafe { Some(ptr::read(self.ring.as_ptr().get_unchecked_mut(self.head))) }\n     }\n }\n "}, {"sha": "e696d7ed636b5ceb89fb1db60d4545b450ab91cf", "filename": "library/alloc/src/collections/vec_deque/iter.rs", "status": "modified", "additions": 23, "deletions": 41, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/54684c438f83f84c01024fb44fdfdba54c88b7da/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54684c438f83f84c01024fb44fdfdba54c88b7da/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs?ref=54684c438f83f84c01024fb44fdfdba54c88b7da", "patch": "@@ -1,9 +1,7 @@\n use core::fmt;\n use core::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n-use core::marker::PhantomData;\n use core::mem::MaybeUninit;\n use core::ops::Try;\n-use core::ptr::NonNull;\n \n use super::{count, wrap_index, RingSlices};\n \n@@ -15,53 +13,38 @@ use super::{count, wrap_index, RingSlices};\n /// [`iter`]: super::VecDeque::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    ring: NonNull<[T]>,\n+    ring: &'a [MaybeUninit<T>],\n     tail: usize,\n     head: usize,\n-    _marker: PhantomData<&'a T>,\n }\n \n impl<'a, T> Iter<'a, T> {\n     pub(super) fn new(ring: &'a [MaybeUninit<T>], tail: usize, head: usize) -> Self {\n-        Iter {\n-            ring: unsafe { NonNull::new_unchecked(ring as *const [MaybeUninit<T>] as *mut _) },\n-            tail,\n-            head,\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    unsafe fn ring(&self) -> &'a [MaybeUninit<T>] {\n-        unsafe {\n-            core::slice::from_raw_parts(\n-                self.ring.as_ptr() as *const MaybeUninit<T>,\n-                self.ring.len(),\n-            )\n-        }\n+        Iter { ring, tail, head }\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for Iter<'_, T> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Send for Iter<'_, T> {}\n-\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (front, back) = unsafe { RingSlices::ring_slices(self.ring(), self.head, self.tail) };\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         // Safety:\n         // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n         // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        f.debug_tuple(\"Iter\").field(&front).field(&back).finish()\n+        unsafe {\n+            f.debug_tuple(\"Iter\")\n+                .field(&MaybeUninit::slice_assume_init_ref(front))\n+                .field(&MaybeUninit::slice_assume_init_ref(back))\n+                .finish()\n+        }\n     }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Iter<'_, T> {\n     fn clone(&self) -> Self {\n-        Iter { ring: self.ring, tail: self.tail, head: self.head, _marker: PhantomData }\n+        Iter { ring: self.ring, tail: self.tail, head: self.head }\n     }\n }\n \n@@ -79,7 +62,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         // Safety:\n         // - `self.tail` in a ring buffer is always a valid index.\n         // - `self.head` and `self.tail` equality is checked above.\n-        unsafe { Some(self.ring().get_unchecked(tail).assume_init_ref()) }\n+        unsafe { Some(self.ring.get_unchecked(tail).assume_init_ref()) }\n     }\n \n     #[inline]\n@@ -92,11 +75,11 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         // Safety:\n         // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n         // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n         unsafe {\n-            let (front, back) = RingSlices::ring_slices(self.ring(), self.head, self.tail);\n             accum = MaybeUninit::slice_assume_init_ref(front).iter().fold(accum, &mut f);\n             MaybeUninit::slice_assume_init_ref(back).iter().fold(accum, &mut f)\n         }\n@@ -111,13 +94,12 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         let (mut iter, final_res);\n         if self.tail <= self.head {\n             // Safety: single slice self.ring[self.tail..self.head] is initialized.\n-            iter =\n-                unsafe { MaybeUninit::slice_assume_init_ref(&self.ring()[self.tail..self.head]) }\n-                    .iter();\n+            iter = unsafe { MaybeUninit::slice_assume_init_ref(&self.ring[self.tail..self.head]) }\n+                .iter();\n             final_res = iter.try_fold(init, &mut f);\n         } else {\n-            // Safety: two slices: self.ring()[self.tail..], self.ring()[..self.head] both are initialized.\n-            let (front, back) = unsafe { self.ring().split_at(self.tail) };\n+            // Safety: two slices: self.ring[self.tail..], self.ring[..self.head] both are initialized.\n+            let (front, back) = self.ring.split_at(self.tail);\n \n             let mut back_iter = unsafe { MaybeUninit::slice_assume_init_ref(back).iter() };\n             let res = back_iter.try_fold(init, &mut f);\n@@ -151,7 +133,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         // that is in bounds.\n         unsafe {\n             let idx = wrap_index(self.tail.wrapping_add(idx), self.ring.len());\n-            self.ring().get_unchecked(idx).assume_init_ref()\n+            self.ring.get_unchecked(idx).assume_init_ref()\n         }\n     }\n }\n@@ -167,18 +149,18 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n         // Safety:\n         // - `self.head` in a ring buffer is always a valid index.\n         // - `self.head` and `self.tail` equality is checked above.\n-        unsafe { Some(self.ring().get_unchecked(self.head).assume_init_ref()) }\n+        unsafe { Some(self.ring.get_unchecked(self.head).assume_init_ref()) }\n     }\n \n     fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         // Safety:\n         // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n         // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n         unsafe {\n-            let (front, back) = RingSlices::ring_slices(self.ring(), self.head, self.tail);\n             accum = MaybeUninit::slice_assume_init_ref(back).iter().rfold(accum, &mut f);\n             MaybeUninit::slice_assume_init_ref(front).iter().rfold(accum, &mut f)\n         }\n@@ -192,14 +174,14 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     {\n         let (mut iter, final_res);\n         if self.tail <= self.head {\n-            // Safety: single slice self.ring()[self.tail..self.head] is initialized.\n+            // Safety: single slice self.ring[self.tail..self.head] is initialized.\n             iter = unsafe {\n-                MaybeUninit::slice_assume_init_ref(&self.ring()[self.tail..self.head]).iter()\n+                MaybeUninit::slice_assume_init_ref(&self.ring[self.tail..self.head]).iter()\n             };\n             final_res = iter.try_rfold(init, &mut f);\n         } else {\n-            // Safety: two slices: self.ring()[self.tail..], self.ring()[..self.head] both are initialized.\n-            let (front, back) = unsafe { self.ring().split_at(self.tail) };\n+            // Safety: two slices: self.ring[self.tail..], self.ring[..self.head] both are initialized.\n+            let (front, back) = self.ring.split_at(self.tail);\n \n             let mut front_iter =\n                 unsafe { MaybeUninit::slice_assume_init_ref(&front[..self.head]).iter() };"}, {"sha": "e3f4deb0875b9e86fe9a122ef68aa3762df7ebe9", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/54684c438f83f84c01024fb44fdfdba54c88b7da/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54684c438f83f84c01024fb44fdfdba54c88b7da/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=54684c438f83f84c01024fb44fdfdba54c88b7da", "patch": "@@ -1334,9 +1334,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             // it.  We do not write to `self` nor reborrow to a mutable reference.\n             // Hence the raw pointer we created above, for `deque`, remains valid.\n             let ring = self.buffer_as_slice();\n-            let iter = Iter::new(ring, drain_tail, drain_head);\n \n-            Drain::new(drain_head, head, iter, deque)\n+            Drain::new(drain_head, head, ring, drain_tail, drain_head, deque)\n         }\n     }\n "}]}