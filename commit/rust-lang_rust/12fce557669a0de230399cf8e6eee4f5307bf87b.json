{"sha": "12fce557669a0de230399cf8e6eee4f5307bf87b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZmNlNTU3NjY5YTBkZTIzMDM5OWNmOGU2ZWVlNGY1MzA3YmY4N2I=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-02T21:35:32Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-06T14:43:47Z"}, "message": "Fix all occurences of `needless_borrow` internally", "tree": {"sha": "6757cf92609e12c46ee23897093c46a7970c0a05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6757cf92609e12c46ee23897093c46a7970c0a05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12fce557669a0de230399cf8e6eee4f5307bf87b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmBsc60ACgkQ2lnoZDo37QYzSwD/b7ZxXY/FP5NbmrUNwLEJw50r\naR3My2LkGVhCPSSz9zYA/1NvNWP3yOa8tfU8lAC12K9iOZ5i/+UI1GoymKV25WoI\n=pduD\n-----END PGP SIGNATURE-----", "payload": "tree 6757cf92609e12c46ee23897093c46a7970c0a05\nparent d2ba77715967fe1658a2f721757a37901992ac3f\nauthor Jason Newcomb <jsnewcomb@pm.me> 1617399332 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1617720227 -0400\n\nFix all occurences of `needless_borrow` internally\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12fce557669a0de230399cf8e6eee4f5307bf87b", "html_url": "https://github.com/rust-lang/rust/commit/12fce557669a0de230399cf8e6eee4f5307bf87b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12fce557669a0de230399cf8e6eee4f5307bf87b/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2ba77715967fe1658a2f721757a37901992ac3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ba77715967fe1658a2f721757a37901992ac3f", "html_url": "https://github.com/rust-lang/rust/commit/d2ba77715967fe1658a2f721757a37901992ac3f"}], "stats": {"total": 4312, "additions": 2150, "deletions": 2162}, "files": [{"sha": "1517cdc9419626600ad03b60cbc28e1ef1cc7d42", "filename": "clippy_dev/src/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Ffmt.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -68,7 +68,7 @@ pub fn run(check: bool, verbose: bool) {\n                 continue;\n             }\n \n-            success &= rustfmt(context, &path)?;\n+            success &= rustfmt(context, path)?;\n         }\n \n         Ok(success)"}, {"sha": "1e5a140e9648f6fd39b73ee0ea37954f326cb2aa", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -101,7 +101,7 @@ impl Lint {\n #[must_use]\n pub fn gen_lint_group_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n     lints\n-        .map(|l| format!(\"        LintId::of(&{}::{}),\", l.module, l.name.to_uppercase()))\n+        .map(|l| format!(\"        LintId::of({}::{}),\", l.module, l.name.to_uppercase()))\n         .sorted()\n         .collect::<Vec<String>>()\n }\n@@ -154,17 +154,17 @@ pub fn gen_register_lint_list<'a>(\n     let header = \"    store.register_lints(&[\".to_string();\n     let footer = \"    ]);\".to_string();\n     let internal_lints = internal_lints\n-        .sorted_by_key(|l| format!(\"        &{}::{},\", l.module, l.name.to_uppercase()))\n+        .sorted_by_key(|l| format!(\"        {}::{},\", l.module, l.name.to_uppercase()))\n         .map(|l| {\n             format!(\n-                \"        #[cfg(feature = \\\"internal-lints\\\")]\\n        &{}::{},\",\n+                \"        #[cfg(feature = \\\"internal-lints\\\")]\\n        {}::{},\",\n                 l.module,\n                 l.name.to_uppercase()\n             )\n         });\n     let other_lints = usable_lints\n-        .sorted_by_key(|l| format!(\"        &{}::{},\", l.module, l.name.to_uppercase()))\n-        .map(|l| format!(\"        &{}::{},\", l.module, l.name.to_uppercase()))\n+        .sorted_by_key(|l| format!(\"        {}::{},\", l.module, l.name.to_uppercase()))\n+        .map(|l| format!(\"        {}::{},\", l.module, l.name.to_uppercase()))\n         .sorted();\n     let mut lint_list = vec![header];\n     lint_list.extend(internal_lints);\n@@ -550,9 +550,9 @@ fn test_gen_lint_group_list() {\n         Lint::new(\"internal\", \"internal_style\", \"abc\", None, \"module_name\"),\n     ];\n     let expected = vec![\n-        \"        LintId::of(&module_name::ABC),\".to_string(),\n-        \"        LintId::of(&module_name::INTERNAL),\".to_string(),\n-        \"        LintId::of(&module_name::SHOULD_ASSERT_EQ),\".to_string(),\n+        \"        LintId::of(module_name::ABC),\".to_string(),\n+        \"        LintId::of(module_name::INTERNAL),\".to_string(),\n+        \"        LintId::of(module_name::SHOULD_ASSERT_EQ),\".to_string(),\n     ];\n     assert_eq!(expected, gen_lint_group_list(lints.iter()));\n }"}, {"sha": "5fbf4bdbd187b642db39ba3852b0b82e28ec79ae", "filename": "clippy_lints/src/absurd_extreme_comparisons.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -44,7 +44,7 @@ declare_lint_pass!(AbsurdExtremeComparisons => [ABSURD_EXTREME_COMPARISONS]);\n \n impl<'tcx> LateLintPass<'tcx> for AbsurdExtremeComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n+        if let ExprKind::Binary(ref cmp, lhs, rhs) = expr.kind {\n             if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n                 if !expr.span.from_expansion() {\n                     let msg = \"this comparison involving the minimum or maximum element for this \\\n@@ -95,7 +95,7 @@ enum AbsurdComparisonResult {\n }\n \n fn is_cast_between_fixed_and_target<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n+    if let ExprKind::Cast(cast_exp, _) = expr.kind {\n         let precast_ty = cx.typeck_results().expr_ty(cast_exp);\n         let cast_ty = cx.typeck_results().expr_ty(expr);\n "}, {"sha": "a0993bb6913e7c62a3ac67be103e223d88b2ea76", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n                 return;\n             }\n             if_chain! {\n-                if let ExprKind::Unary(_, ref lit) = e.kind;\n+                if let ExprKind::Unary(_, lit) = e.kind;\n                 if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), lit);\n                 if is_true;\n                 then {\n@@ -82,7 +82,7 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n             if assert_span.from_expansion() {\n                 return;\n             }\n-            if let Some(assert_match) = match_assert_with_message(&cx, e) {\n+            if let Some(assert_match) = match_assert_with_message(cx, e) {\n                 match assert_match {\n                     // matched assert but not message\n                     AssertKind::WithoutMessage(false) => lint_false_without_message(),\n@@ -113,17 +113,17 @@ enum AssertKind {\n /// where `message` is any expression and `c` is a constant bool.\n fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n     if_chain! {\n-        if let ExprKind::If(ref cond, ref then, _) = expr.kind;\n-        if let ExprKind::Unary(UnOp::Not, ref expr) = cond.kind;\n+        if let ExprKind::If(cond, then, _) = expr.kind;\n+        if let ExprKind::Unary(UnOp::Not, expr) = cond.kind;\n         // bind the first argument of the `assert!` macro\n         if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n         // block\n-        if let ExprKind::Block(ref block, _) = then.kind;\n+        if let ExprKind::Block(block, _) = then.kind;\n         if block.stmts.is_empty();\n         if let Some(block_expr) = &block.expr;\n         // inner block is optional. unwrap it if it exists, or use the expression as is otherwise.\n         if let Some(begin_panic_call) = match block_expr.kind {\n-            ExprKind::Block(ref inner_block, _) => &inner_block.expr,\n+            ExprKind::Block(inner_block, _) => &inner_block.expr,\n             _ => &block.expr,\n         };\n         // function call"}, {"sha": "7ceb01f5590fcf2e38fa9b7ba17455eaa1a5e611", "filename": "clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -85,7 +85,7 @@ fn match_ordering_def_path(cx: &LateContext<'_>, did: DefId, orderings: &[&str])\n \n fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method_path, _, args, _) = &expr.kind;\n+        if let ExprKind::MethodCall(method_path, _, args, _) = &expr.kind;\n         let method = method_path.ident.name.as_str();\n         if type_is_atomic(cx, &args[0]);\n         if method == \"load\" || method == \"store\";\n@@ -120,7 +120,7 @@ fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n fn check_memory_fence(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::Call(ref func, ref args) = expr.kind;\n+        if let ExprKind::Call(func, args) = expr.kind;\n         if let ExprKind::Path(ref func_qpath) = func.kind;\n         if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n         if [\"fence\", \"compiler_fence\"]\n@@ -152,7 +152,7 @@ fn opt_ordering_defid(cx: &LateContext<'_>, ord_arg: &Expr<'_>) -> Option<DefId>\n \n fn check_atomic_compare_exchange(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method_path, _, args, _) = &expr.kind;\n+        if let ExprKind::MethodCall(method_path, _, args, _) = &expr.kind;\n         let method = method_path.ident.name.as_str();\n         if type_is_atomic(cx, &args[0]);\n         if method == \"compare_exchange\" || method == \"compare_exchange_weak\" || method == \"fetch_update\";"}, {"sha": "382fb03d9200bc17b0e364eb83f0a5f1ef6c20c9", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -602,7 +602,7 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n             if let NestedMetaItem::MetaItem(meta) = item {\n                 match &meta.kind {\n                     MetaItemKind::List(list) => {\n-                        mismatched.extend(find_mismatched_target_os(&list));\n+                        mismatched.extend(find_mismatched_target_os(list));\n                     },\n                     MetaItemKind::Word => {\n                         if_chain! {\n@@ -629,7 +629,7 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n         then {\n             let mess = \"operating system used in target family position\";\n \n-            span_lint_and_then(cx, MISMATCHED_TARGET_OS, attr.span, &mess, |diag| {\n+            span_lint_and_then(cx, MISMATCHED_TARGET_OS, attr.span, mess, |diag| {\n                 // Avoid showing the unix suggestion multiple times in case\n                 // we have more than one mismatch for unix-like systems\n                 let mut unix_suggested = false;"}, {"sha": "1739a57a240b2807731ca31c40190fe6d3a49a7c", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -101,7 +101,7 @@ impl LateLintPass<'_> for AwaitHolding {\n             let typeck_results = cx.tcx.typeck_body(body_id);\n             check_interior_types(\n                 cx,\n-                &typeck_results.generator_interior_types.as_ref().skip_binder(),\n+                typeck_results.generator_interior_types.as_ref().skip_binder(),\n                 body.value.span,\n             );\n         }"}, {"sha": "877ae002d36e9de67bb360716112cf266929ae4d", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -38,17 +38,17 @@ declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n impl<'tcx> LateLintPass<'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref count, _, ref count_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(count, _, count_args, _) = expr.kind;\n             if count.ident.name == sym!(count);\n             if count_args.len() == 1;\n-            if let ExprKind::MethodCall(ref filter, _, ref filter_args, _) = count_args[0].kind;\n+            if let ExprKind::MethodCall(filter, _, filter_args, _) = count_args[0].kind;\n             if filter.ident.name == sym!(filter);\n             if filter_args.len() == 2;\n             if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].kind;\n             let body = cx.tcx.hir().body(body_id);\n             if body.params.len() == 1;\n-            if let Some(argname) = get_pat_name(&body.params[0].pat);\n-            if let ExprKind::Binary(ref op, ref l, ref r) = body.value.kind;\n+            if let Some(argname) = get_pat_name(body.params[0].pat);\n+            if let ExprKind::Binary(ref op, l, r) = body.value.kind;\n             if op.node == BinOpKind::Eq;\n             if match_type(cx,\n                        cx.typeck_results().expr_ty(&filter_args[0]).peel_refs(),\n@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                 if ty::Uint(UintTy::U8) != *cx.typeck_results().expr_ty(needle).peel_refs().kind() {\n                     return;\n                 }\n-                let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) =\n+                let haystack = if let ExprKind::MethodCall(path, _, args, _) =\n                         filter_args[0].kind {\n                     let p = path.ident.name;\n                     if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n@@ -98,10 +98,10 @@ fn check_arg(name: Symbol, arg: Symbol, needle: &Expr<'_>) -> bool {\n \n fn get_path_name(expr: &Expr<'_>) -> Option<Symbol> {\n     match expr.kind {\n-        ExprKind::Box(ref e) | ExprKind::AddrOf(BorrowKind::Ref, _, ref e) | ExprKind::Unary(UnOp::Deref, ref e) => {\n+        ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) | ExprKind::Unary(UnOp::Deref, e) => {\n             get_path_name(e)\n         },\n-        ExprKind::Block(ref b, _) => {\n+        ExprKind::Block(b, _) => {\n             if b.stmts.is_empty() {\n                 b.expr.as_ref().and_then(|p| get_path_name(p))\n             } else {"}, {"sha": "62a119d662bb251f1cb3a0af16dff3b8817bc41a", "filename": "clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -10,7 +10,7 @@ use rustc_target::abi::LayoutOf;\n use super::CAST_PTR_ALIGNMENT;\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Cast(ref cast_expr, cast_to) = expr.kind {\n+    if let ExprKind::Cast(cast_expr, cast_to) = expr.kind {\n         if is_hir_ty_cfg_dependant(cx, cast_to) {\n             return;\n         }"}, {"sha": "040e0ca886458d3f63265acdc953822bc1409a9c", "filename": "clippy_lints/src/casts/cast_sign_loss.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -30,7 +30,7 @@ fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast\n             }\n \n             // Don't lint for positive constants.\n-            let const_val = constant(cx, &cx.typeck_results(), cast_op);\n+            let const_val = constant(cx, cx.typeck_results(), cast_op);\n             if_chain! {\n                 if let Some((Constant::Int(n), _)) = const_val;\n                 if let ty::Int(ity) = *cast_from.kind();\n@@ -41,14 +41,14 @@ fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast\n             }\n \n             // Don't lint for the result of methods that always return non-negative values.\n-            if let ExprKind::MethodCall(ref path, _, _, _) = cast_op.kind {\n+            if let ExprKind::MethodCall(path, _, _, _) = cast_op.kind {\n                 let mut method_name = path.ident.name.as_str();\n                 let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n \n                 if_chain! {\n                     if method_name == \"unwrap\";\n                     if let Some(arglist) = method_chain_args(cast_op, &[\"unwrap\"]);\n-                    if let ExprKind::MethodCall(ref inner_path, _, _, _) = &arglist[0][0].kind;\n+                    if let ExprKind::MethodCall(inner_path, _, _, _) = &arglist[0][0].kind;\n                     then {\n                         method_name = inner_path.ident.name.as_str();\n                     }"}, {"sha": "ae4fdd12c41e8361f0999613c6bd5cd30671774b", "filename": "clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -372,7 +372,7 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             return;\n         }\n \n-        if let ExprKind::Cast(ref cast_expr, cast_to) = expr.kind {\n+        if let ExprKind::Cast(cast_expr, cast_to) = expr.kind {\n             if is_hir_ty_cfg_dependant(cx, cast_to) {\n                 return;\n             }"}, {"sha": "d7136f84cc3af3d4d9471cb367c086e4cf994872", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for CheckedConversions {\n \n         let result = if_chain! {\n             if !in_external_macro(cx.sess(), item.span);\n-            if let ExprKind::Binary(op, ref left, ref right) = &item.kind;\n+            if let ExprKind::Binary(op, left, right) = &item.kind;\n \n             then {\n                 match op.node {\n@@ -200,7 +200,7 @@ impl ConversionType {\n /// Check for `expr <= (to_type::MAX as from_type)`\n fn check_upper_bound<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n     if_chain! {\n-         if let ExprKind::Binary(ref op, ref left, ref right) = &expr.kind;\n+         if let ExprKind::Binary(ref op, left, right) = &expr.kind;\n          if let Some((candidate, check)) = normalize_le_ge(op, left, right);\n          if let Some((from, to)) = get_types_from_cast(check, INTS, \"max_value\", \"MAX\");\n \n@@ -219,7 +219,7 @@ fn check_lower_bound<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n     }\n \n     // First of we need a binary containing the expression & the cast\n-    if let ExprKind::Binary(ref op, ref left, ref right) = &expr.kind {\n+    if let ExprKind::Binary(ref op, left, right) = &expr.kind {\n         normalize_le_ge(op, right, left).and_then(|(l, r)| check_function(l, r))\n     } else {\n         None\n@@ -260,7 +260,7 @@ fn get_types_from_cast<'a>(\n     // or `to_type::MAX as from_type`\n     let call_from_cast: Option<(&Expr<'_>, &str)> = if_chain! {\n         // to_type::max_value(), from_type\n-        if let ExprKind::Cast(ref limit, ref from_type) = &expr.kind;\n+        if let ExprKind::Cast(limit, from_type) = &expr.kind;\n         if let TyKind::Path(ref from_type_path) = &from_type.kind;\n         if let Some(from_sym) = int_ty_to_sym(from_type_path);\n \n@@ -275,7 +275,7 @@ fn get_types_from_cast<'a>(\n     let limit_from: Option<(&Expr<'_>, &str)> = call_from_cast.or_else(|| {\n         if_chain! {\n             // `from_type::from, to_type::max_value()`\n-            if let ExprKind::Call(ref from_func, ref args) = &expr.kind;\n+            if let ExprKind::Call(from_func, args) = &expr.kind;\n             // `to_type::max_value()`\n             if args.len() == 1;\n             if let limit = &args[0];\n@@ -317,9 +317,9 @@ fn get_types_from_cast<'a>(\n /// Gets the type which implements the called function\n fn get_implementing_type<'a>(path: &QPath<'_>, candidates: &'a [&str], function: &str) -> Option<&'a str> {\n     if_chain! {\n-        if let QPath::TypeRelative(ref ty, ref path) = &path;\n+        if let QPath::TypeRelative(ty, path) = &path;\n         if path.ident.name.as_str() == function;\n-        if let TyKind::Path(QPath::Resolved(None, ref tp)) = &ty.kind;\n+        if let TyKind::Path(QPath::Resolved(None, tp)) = &ty.kind;\n         if let [int] = &*tp.segments;\n         then {\n             let name = &int.ident.name.as_str();\n@@ -333,7 +333,7 @@ fn get_implementing_type<'a>(path: &QPath<'_>, candidates: &'a [&str], function:\n /// Gets the type as a string, if it is a supported integer\n fn int_ty_to_sym<'tcx>(path: &QPath<'_>) -> Option<&'tcx str> {\n     if_chain! {\n-        if let QPath::Resolved(_, ref path) = *path;\n+        if let QPath::Resolved(_, path) = *path;\n         if let [ty] = &*path.segments;\n         then {\n             let name = &ty.ident.name.as_str();"}, {"sha": "f62c6a9c3251c9cc54562d5611eba8194d07b8d3", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -152,7 +152,7 @@ impl<'tcx> Visitor<'tcx> for CcHelper {\n             ExprKind::If(_, _, _) => {\n                 self.cc += 1;\n             },\n-            ExprKind::Match(_, ref arms, _) => {\n+            ExprKind::Match(_, arms, _) => {\n                 if arms.len() > 1 {\n                     self.cc += 1;\n                 }"}, {"sha": "31ae63b51849cb6e9a2b7ba32c48e45d3f530dcb", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -71,10 +71,8 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n         }\n \n         for cond in conds.windows(2) {\n-            if let (\n-                &ExprKind::Binary(ref kind1, ref lhs1, ref rhs1),\n-                &ExprKind::Binary(ref kind2, ref lhs2, ref rhs2),\n-            ) = (&cond[0].kind, &cond[1].kind)\n+            if let (&ExprKind::Binary(ref kind1, lhs1, rhs1), &ExprKind::Binary(ref kind2, lhs2, rhs2)) =\n+                (&cond[0].kind, &cond[1].kind)\n             {\n                 if !kind_is_cmp(kind1.node) || !kind_is_cmp(kind2.node) {\n                     return;"}, {"sha": "8b503c9a0306b383c415b3335562036d8423d03e", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -160,7 +160,7 @@ impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n             if let ExprKind::If(_, _, _) = expr.kind {\n                 // skip ifs directly in else, it will be checked in the parent if\n                 if let Some(&Expr {\n-                    kind: ExprKind::If(_, _, Some(ref else_expr)),\n+                    kind: ExprKind::If(_, _, Some(else_expr)),\n                     ..\n                 }) = get_parent_expr(cx, expr)\n                 {\n@@ -247,7 +247,7 @@ fn lint_same_then_else<'tcx>(\n \n             for value in &end_walker.uses {\n                 // Well we can't move this and all prev statements. So reset\n-                if block_defs.contains(&value) {\n+                if block_defs.contains(value) {\n                     moved_start = Some(index + 1);\n                     end_walker.defs.drain().for_each(|x| {\n                         block_defs.insert(x);\n@@ -555,7 +555,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UsedValueFinderVisitor<'a, 'tcx> {\n     }\n \n     fn visit_qpath(&mut self, qpath: &'tcx rustc_hir::QPath<'tcx>, id: HirId, _span: rustc_span::Span) {\n-        if let rustc_hir::QPath::Resolved(_, ref path) = *qpath {\n+        if let rustc_hir::QPath::Resolved(_, path) = *qpath {\n             if path.segments.len() == 1 {\n                 if let rustc_hir::def::Res::Local(var) = self.cx.qpath_res(qpath, id) {\n                     self.uses.insert(var);"}, {"sha": "7b5cce6462a436bc738052fc222cf8aff9324acc", "filename": "clippy_lints/src/create_dir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcreate_dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fcreate_dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcreate_dir.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -33,7 +33,7 @@ declare_lint_pass!(CreateDir => [CREATE_DIR]);\n impl LateLintPass<'_> for CreateDir {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref func, ref args) = expr.kind;\n+            if let ExprKind::Call(func, args) = expr.kind;\n             if let ExprKind::Path(ref path) = func.kind;\n             if let Some(def_id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::STD_FS_CREATE_DIR);"}, {"sha": "710da8fe9e037ea6bc21eceeafc3afe205c07410", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -77,7 +77,7 @@ impl LateLintPass<'_> for Default {\n         if_chain! {\n             // Avoid cases already linted by `field_reassign_with_default`\n             if !self.reassigned_linted.contains(&expr.span);\n-            if let ExprKind::Call(ref path, ..) = expr.kind;\n+            if let ExprKind::Call(path, ..) = expr.kind;\n             if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n             if let ExprKind::Path(ref qpath) = path.kind;\n             if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n@@ -246,7 +246,7 @@ impl LateLintPass<'_> for Default {\n /// Checks if the given expression is the `default` method belonging to the `Default` trait.\n fn is_expr_default<'tcx>(expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> bool {\n     if_chain! {\n-        if let ExprKind::Call(ref fn_expr, _) = &expr.kind;\n+        if let ExprKind::Call(fn_expr, _) = &expr.kind;\n         if let ExprKind::Path(qpath) = &fn_expr.kind;\n         if let Res::Def(_, def_id) = cx.qpath_res(qpath, fn_expr.hir_id);\n         then {\n@@ -262,11 +262,11 @@ fn is_expr_default<'tcx>(expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> bool\n fn field_reassigned_by_stmt<'tcx>(this: &Stmt<'tcx>, binding_name: Symbol) -> Option<(Ident, &'tcx Expr<'tcx>)> {\n     if_chain! {\n         // only take assignments\n-        if let StmtKind::Semi(ref later_expr) = this.kind;\n-        if let ExprKind::Assign(ref assign_lhs, ref assign_rhs, _) = later_expr.kind;\n+        if let StmtKind::Semi(later_expr) = this.kind;\n+        if let ExprKind::Assign(assign_lhs, assign_rhs, _) = later_expr.kind;\n         // only take assignments to fields where the left-hand side field is a field of\n         // the same binding as the previous statement\n-        if let ExprKind::Field(ref binding, field_ident) = assign_lhs.kind;\n+        if let ExprKind::Field(binding, field_ident) = assign_lhs.kind;\n         if let ExprKind::Path(QPath::Resolved(_, path)) = binding.kind;\n         if let Some(second_binding_name) = path.segments.last();\n         if second_binding_name.ident.name == binding_name;"}, {"sha": "647af3bdc04d073124fbedfa84a93fb96fa9d1b6", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -199,7 +199,7 @@ fn check_hash_peq<'tcx>(\n         then {\n             // Look for the PartialEq implementations for `ty`\n             cx.tcx.for_each_relevant_impl(peq_trait_def_id, ty, |impl_id| {\n-                let peq_is_automatically_derived = is_automatically_derived(&cx.tcx.get_attrs(impl_id));\n+                let peq_is_automatically_derived = is_automatically_derived(cx.tcx.get_attrs(impl_id));\n \n                 if peq_is_automatically_derived == hash_is_automatically_derived {\n                     return;\n@@ -253,7 +253,7 @@ fn check_ord_partial_ord<'tcx>(\n         then {\n             // Look for the PartialOrd implementations for `ty`\n             cx.tcx.for_each_relevant_impl(partial_ord_trait_def_id, ty, |impl_id| {\n-                let partial_ord_is_automatically_derived = is_automatically_derived(&cx.tcx.get_attrs(impl_id));\n+                let partial_ord_is_automatically_derived = is_automatically_derived(cx.tcx.get_attrs(impl_id));\n \n                 if partial_ord_is_automatically_derived == ord_is_automatically_derived {\n                     return;"}, {"sha": "fb53b55ebd6acdd41e0d2a9f94676248bccf4343", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -710,8 +710,8 @@ impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n \n         // check for `begin_panic`\n         if_chain! {\n-            if let ExprKind::Call(ref func_expr, _) = expr.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.kind;\n+            if let ExprKind::Call(func_expr, _) = expr.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = func_expr.kind;\n             if let Some(path_def_id) = path.res.opt_def_id();\n             if match_panic_def_id(self.cx, path_def_id);\n             if is_expn_of(expr.span, \"unreachable\").is_none();"}, {"sha": "58543ae6e4e314a64a3244b8f9bb911c00d7b971", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> DoubleComparisons {\n             },\n             _ => return,\n         };\n-        if !(eq_expr_value(cx, &llhs, &rlhs) && eq_expr_value(cx, &lrhs, &rrhs)) {\n+        if !(eq_expr_value(cx, llhs, rlhs) && eq_expr_value(cx, lrhs, rrhs)) {\n             return;\n         }\n         macro_rules! lint_double_comparison {\n@@ -88,7 +88,7 @@ impl<'tcx> DoubleComparisons {\n \n impl<'tcx> LateLintPass<'tcx> for DoubleComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = expr.kind {\n+        if let ExprKind::Binary(ref kind, lhs, rhs) = expr.kind {\n             Self::check_binop(cx, kind.node, lhs, rhs, expr.span);\n         }\n     }"}, {"sha": "e4e4a93b011fd2e8f68c5dc0e93008e4b5278e2b", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -50,23 +50,23 @@ impl EarlyLintPass for DoubleParens {\n         match expr.kind {\n             ExprKind::Paren(ref in_paren) => match in_paren.kind {\n                 ExprKind::Paren(_) | ExprKind::Tup(_) => {\n-                    span_lint(cx, DOUBLE_PARENS, expr.span, &msg);\n+                    span_lint(cx, DOUBLE_PARENS, expr.span, msg);\n                 },\n                 _ => {},\n             },\n             ExprKind::Call(_, ref params) => {\n                 if params.len() == 1 {\n                     let param = &params[0];\n                     if let ExprKind::Paren(_) = param.kind {\n-                        span_lint(cx, DOUBLE_PARENS, param.span, &msg);\n+                        span_lint(cx, DOUBLE_PARENS, param.span, msg);\n                     }\n                 }\n             },\n             ExprKind::MethodCall(_, ref params, _) => {\n                 if params.len() == 2 {\n                     let param = &params[1];\n                     if let ExprKind::Paren(_) = param.kind {\n-                        span_lint(cx, DOUBLE_PARENS, param.span, &msg);\n+                        span_lint(cx, DOUBLE_PARENS, param.span, msg);\n                     }\n                 }\n             },"}, {"sha": "b5b29760636ba5ce61627b21f30559317b886324", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -113,7 +113,7 @@ declare_lint_pass!(DropForgetRef => [DROP_REF, FORGET_REF, DROP_COPY, FORGET_COP\n impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref path, ref args) = expr.kind;\n+            if let ExprKind::Call(path, args) = expr.kind;\n             if let ExprKind::Path(ref qpath) = path.kind;\n             if args.len() == 1;\n             if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();"}, {"sha": "529807770f3cd76cbf67adb4ab68ae6e8898bf63", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -43,8 +43,8 @@ declare_lint_pass!(DurationSubsec => [DURATION_SUBSEC]);\n impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.kind;\n-            if let ExprKind::MethodCall(ref method_path, _ , ref args, _) = left.kind;\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, left, right) = expr.kind;\n+            if let ExprKind::MethodCall(method_path, _ , args, _) = left.kind;\n             if match_type(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), &paths::DURATION);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right);\n             then {"}, {"sha": "a815df1691a1c9f8d9334d1695d268c2978a3c9b", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -57,14 +57,14 @@ declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n \n impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::If(ref check, ref then_block, ref else_block) = expr.kind {\n-            if let ExprKind::Unary(UnOp::Not, ref check) = check.kind {\n+        if let ExprKind::If(check, then_block, ref else_block) = expr.kind {\n+            if let ExprKind::Unary(UnOp::Not, check) = check.kind {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n                     let sole_expr = {\n                         else_block.is_none()\n-                            && if let ExprKind::Block(ref then_block, _) = then_block.kind {\n+                            && if let ExprKind::Block(then_block, _) = then_block.kind {\n                                 (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n                             } else {\n                                 true\n@@ -81,9 +81,9 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n                         sole_expr,\n                     };\n \n-                    walk_expr(&mut visitor, &**then_block);\n+                    walk_expr(&mut visitor, then_block);\n                 }\n-            } else if let Some(ref else_block) = *else_block {\n+            } else if let Some(else_block) = *else_block {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n                     let mut visitor = InsertVisitor {\n                         cx,\n@@ -103,10 +103,10 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n \n fn check_cond<'a>(cx: &LateContext<'_>, check: &'a Expr<'a>) -> Option<(&'static str, &'a Expr<'a>, &'a Expr<'a>)> {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref path, _, ref params, _) = check.kind;\n+        if let ExprKind::MethodCall(path, _, params, _) = check.kind;\n         if params.len() >= 2;\n         if path.ident.name == sym!(contains_key);\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref key) = params[1].kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, key) = params[1].kind;\n         then {\n             let map = &params[0];\n             let obj_ty = cx.typeck_results().expr_ty(map).peel_refs();\n@@ -140,7 +140,7 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref params, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, params, _) = expr.kind;\n             if params.len() == 3;\n             if path.ident.name == sym!(insert);\n             if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);"}, {"sha": "90f391b5f5c89efa3613b7936c232d99e1e41137", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -65,12 +65,12 @@ const ASSERT_MACRO_NAMES: [&str; 4] = [\"assert_eq\", \"assert_ne\", \"debug_assert_e\n impl<'tcx> LateLintPass<'tcx> for EqOp {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Block(ref block, _) = e.kind {\n+        if let ExprKind::Block(block, _) = e.kind {\n             for stmt in block.stmts {\n                 for amn in &ASSERT_MACRO_NAMES {\n                     if_chain! {\n                         if is_expn_of(stmt.span, amn).is_some();\n-                        if let StmtKind::Semi(ref matchexpr) = stmt.kind;\n+                        if let StmtKind::Semi(matchexpr) = stmt.kind;\n                         if let Some(macro_args) = higher::extract_assert_macro_args(matchexpr);\n                         if macro_args.len() == 2;\n                         let (lhs, rhs) = (macro_args[0], macro_args[1]);\n@@ -88,12 +88,12 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                 }\n             }\n         }\n-        if let ExprKind::Binary(op, ref left, ref right) = e.kind {\n+        if let ExprKind::Binary(op, left, right) = e.kind {\n             if e.span.from_expansion() {\n                 return;\n             }\n             let macro_with_not_op = |expr_kind: &ExprKind<'_>| {\n-                if let ExprKind::Unary(_, ref expr) = *expr_kind {\n+                if let ExprKind::Unary(_, expr) = *expr_kind {\n                     in_macro(expr.span)\n                 } else {\n                     false\n@@ -135,7 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     // do not suggest to dereference literals\n                     (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n                     // &foo == &bar\n-                    (&ExprKind::AddrOf(BorrowKind::Ref, _, ref l), &ExprKind::AddrOf(BorrowKind::Ref, _, ref r)) => {\n+                    (&ExprKind::AddrOf(BorrowKind::Ref, _, l), &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n                         let lty = cx.typeck_results().expr_ty(l);\n                         let rty = cx.typeck_results().expr_ty(r);\n                         let lcpy = is_copy(cx, lty);\n@@ -198,7 +198,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                         }\n                     },\n                     // &foo == bar\n-                    (&ExprKind::AddrOf(BorrowKind::Ref, _, ref l), _) => {\n+                    (&ExprKind::AddrOf(BorrowKind::Ref, _, l), _) => {\n                         let lty = cx.typeck_results().expr_ty(l);\n                         let lcpy = is_copy(cx, lty);\n                         if (requires_ref || lcpy)\n@@ -222,7 +222,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                         }\n                     },\n                     // foo == &bar\n-                    (_, &ExprKind::AddrOf(BorrowKind::Ref, _, ref r)) => {\n+                    (_, &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n                         let rty = cx.typeck_results().expr_ty(r);\n                         let rcpy = is_copy(cx, rty);\n                         if (requires_ref || rcpy)"}, {"sha": "f95ca86a2d015ec3602369e0e00e65ea755aedbb", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> LateLintPass<'tcx> for ErasingOp {\n         if e.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.kind {\n+        if let ExprKind::Binary(ref cmp, left, right) = e.kind {\n             match cmp.node {\n                 BinOpKind::Mul | BinOpKind::BitAnd => {\n                     check(cx, left, e.span);"}, {"sha": "2f1aa53236d3324dd219001ade629bb8a8f950fb", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n }\n \n fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-    if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.kind {\n+    if let ExprKind::Closure(_, decl, eid, _, _) = expr.kind {\n         let body = cx.tcx.hir().body(eid);\n         let ex = &body.value;\n \n@@ -109,7 +109,7 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         }\n \n         if_chain!(\n-            if let ExprKind::Call(ref caller, ref args) = ex.kind;\n+            if let ExprKind::Call(caller, args) = ex.kind;\n \n             if let ExprKind::Path(_) = caller.kind;\n \n@@ -142,7 +142,7 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         );\n \n         if_chain!(\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = ex.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = ex.kind;\n \n             // Not the same number of arguments, there is no way the closure is the same as the function return;\n             if args.len() == decl.inputs.len();\n@@ -178,7 +178,7 @@ fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_a\n     let actual_type_of_self = &cx.typeck_results().node_type(self_arg.hir_id);\n \n     if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n-        if match_borrow_depth(expected_type_of_self, &actual_type_of_self)\n+        if match_borrow_depth(expected_type_of_self, actual_type_of_self)\n             && implements_trait(cx, actual_type_of_self, trait_id, &[])\n         {\n             return Some(cx.tcx.def_path_str(trait_id));\n@@ -187,16 +187,16 @@ fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_a\n \n     cx.tcx.impl_of_method(method_def_id).and_then(|_| {\n         //a type may implicitly implement other type's methods (e.g. Deref)\n-        if match_types(expected_type_of_self, &actual_type_of_self) {\n-            return Some(get_type_name(cx, &actual_type_of_self));\n+        if match_types(expected_type_of_self, actual_type_of_self) {\n+            return Some(get_type_name(cx, actual_type_of_self));\n         }\n         None\n     })\n }\n \n fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n     match (&lhs.kind(), &rhs.kind()) {\n-        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(&t1, &t2),\n+        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(t1, t2),\n         (l, r) => !matches!((l, r), (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _))),\n     }\n }\n@@ -218,7 +218,7 @@ fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n fn get_type_name(cx: &LateContext<'_>, ty: Ty<'_>) -> String {\n     match ty.kind() {\n         ty::Adt(t, _) => cx.tcx.def_path_str(t.did),\n-        ty::Ref(_, r, _) => get_type_name(cx, &r),\n+        ty::Ref(_, r, _) => get_type_name(cx, r),\n         _ => ty.to_string(),\n     }\n }\n@@ -230,7 +230,7 @@ fn compare_inputs(\n     for (closure_input, function_arg) in closure_inputs.zip(call_args) {\n         if let PatKind::Binding(_, _, ident, _) = closure_input.pat.kind {\n             // XXXManishearth Should I be checking the binding mode here?\n-            if let ExprKind::Path(QPath::Resolved(None, ref p)) = function_arg.kind {\n+            if let ExprKind::Path(QPath::Resolved(None, p)) = function_arg.kind {\n                 if p.segments.len() != 1 {\n                     // If it's a proper path, it can't be a local variable\n                     return false;"}, {"sha": "762f64fe37ad6862f19edf05576a747ec76e158e", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> LateLintPass<'tcx> for EvalOrderDependence {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Find a write to a local variable.\n         match expr.kind {\n-            ExprKind::Assign(ref lhs, ..) | ExprKind::AssignOp(_, ref lhs, _) => {\n+            ExprKind::Assign(lhs, ..) | ExprKind::AssignOp(_, lhs, _) => {\n                 if let Some(var) = path_to_local(lhs) {\n                     let mut visitor = ReadVisitor {\n                         cx,\n@@ -87,12 +87,12 @@ impl<'tcx> LateLintPass<'tcx> for EvalOrderDependence {\n     }\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         match stmt.kind {\n-            StmtKind::Local(ref local) => {\n-                if let Local { init: Some(ref e), .. } = **local {\n+            StmtKind::Local(local) => {\n+                if let Local { init: Some(e), .. } = local {\n                     DivergenceVisitor { cx }.visit_expr(e);\n                 }\n             },\n-            StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => DivergenceVisitor { cx }.maybe_walk_expr(e),\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => DivergenceVisitor { cx }.maybe_walk_expr(e),\n             StmtKind::Item(..) => {},\n         }\n     }\n@@ -106,7 +106,7 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n     fn maybe_walk_expr(&mut self, e: &'tcx Expr<'_>) {\n         match e.kind {\n             ExprKind::Closure(..) => {},\n-            ExprKind::Match(ref e, arms, _) => {\n+            ExprKind::Match(e, arms, _) => {\n                 self.visit_expr(e);\n                 for arm in arms {\n                     if let Some(Guard::If(if_expr)) = arm.guard {\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n         match e.kind {\n             ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n-            ExprKind::Call(ref func, _) => {\n+            ExprKind::Call(func, _) => {\n                 let typ = self.cx.typeck_results().expr_ty(func);\n                 match typ.kind() {\n                     ty::FnDef(..) | ty::FnPtr(_) => {\n@@ -266,10 +266,10 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr<'_>) -\n \n fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt<'_>) -> StopEarly {\n     match stmt.kind {\n-        StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => check_expr(vis, expr),\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => check_expr(vis, expr),\n         // If the declaration is of a local variable, check its initializer\n         // expression if it has one. Otherwise, keep going.\n-        StmtKind::Local(ref local) => local\n+        StmtKind::Local(local) => local\n             .init\n             .as_ref()\n             .map_or(StopEarly::KeepGoing, |expr| check_expr(vis, expr)),\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n /// Returns `true` if `expr` is the LHS of an assignment, like `expr = ...`.\n fn is_in_assignment_position(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n-        if let ExprKind::Assign(ref lhs, ..) = parent.kind {\n+        if let ExprKind::Assign(lhs, ..) = parent.kind {\n             return lhs.hir_id == expr.hir_id;\n         }\n     }"}, {"sha": "16246e548b6131e2e73790c9f15a65dfdd17783f", "filename": "clippy_lints/src/exit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fexit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fexit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexit.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -28,7 +28,7 @@ declare_lint_pass!(Exit => [EXIT]);\n impl<'tcx> LateLintPass<'tcx> for Exit {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref path_expr, ref _args) = e.kind;\n+            if let ExprKind::Call(path_expr, _args) = e.kind;\n             if let ExprKind::Path(ref path) = path_expr.kind;\n             if let Some(def_id) = cx.qpath_res(path, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::EXIT);"}, {"sha": "da4936ff25b6d22d19e38f502e8d32c106cce991", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -34,11 +34,11 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(unwrap_fun, _, unwrap_args, _) = expr.kind;\n             if unwrap_fun.ident.name == sym::unwrap;\n             // match call to write_fmt\n             if !unwrap_args.is_empty();\n-            if let ExprKind::MethodCall(ref write_fun, _, write_args, _) =\n+            if let ExprKind::MethodCall(write_fun, _, write_args, _) =\n                 unwrap_args[0].kind;\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n@@ -135,10 +135,10 @@ fn write_output_string(write_args: &[Expr<'_>]) -> Option<String> {\n     if_chain! {\n         // Obtain the string that should be printed\n         if write_args.len() > 1;\n-        if let ExprKind::Call(_, ref output_args) = write_args[1].kind;\n+        if let ExprKind::Call(_, output_args) = write_args[1].kind;\n         if !output_args.is_empty();\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref output_string_expr) = output_args[0].kind;\n-        if let ExprKind::Array(ref string_exprs) = output_string_expr.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, output_string_expr) = output_args[0].kind;\n+        if let ExprKind::Array(string_exprs) = output_string_expr.kind;\n         // we only want to provide an automatic suggestion for simple (non-format) strings\n         if string_exprs.len() == 1;\n         if let ExprKind::Lit(ref lit) = string_exprs[0].kind;"}, {"sha": "2937fcb9ca0f3d02bc93154dfe1cf087a9715ee4", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -81,8 +81,8 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n         fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n             // check for `begin_panic`\n             if_chain! {\n-                if let ExprKind::Call(ref func_expr, _) = expr.kind;\n-                if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.kind;\n+                if let ExprKind::Call(func_expr, _) = expr.kind;\n+                if let ExprKind::Path(QPath::Resolved(_, path)) = func_expr.kind;\n                 if let Some(path_def_id) = path.res.opt_def_id();\n                 if match_panic_def_id(self.lcx, path_def_id);\n                 if is_expn_of(expr.span, \"unreachable\").is_none();"}, {"sha": "b5ebe5f90ba25c6733ccafe8f054db109f08ed1f", "filename": "clippy_lints/src/float_equality_without_abs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n         let rhs;\n \n         // check if expr is a binary expression with a lt or gt operator\n-        if let ExprKind::Binary(op, ref left, ref right) = expr.kind {\n+        if let ExprKind::Binary(op, left, right) = expr.kind {\n             match op.node {\n                 BinOpKind::Lt => {\n                     lhs = left;\n@@ -88,8 +88,8 @@ impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n             if let ty::Float(_) = t_val_r.kind();\n \n             then {\n-                let sug_l = sugg::Sugg::hir(cx, &val_l, \"..\");\n-                let sug_r = sugg::Sugg::hir(cx, &val_r, \"..\");\n+                let sug_l = sugg::Sugg::hir(cx, val_l, \"..\");\n+                let sug_r = sugg::Sugg::hir(cx, val_r, \"..\");\n                 // format the suggestion\n                 let suggestion = format!(\"{}.abs()\", sugg::make_assoc(AssocOp::Subtract, &sug_l, &sug_r).maybe_par());\n                 // spans the lint"}, {"sha": "e0b687b02052146415a089a4b379eb06e0fc4163", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -131,7 +131,7 @@ fn prepare_receiver_sugg<'a>(cx: &LateContext<'_>, mut expr: &'a Expr<'a>) -> Su\n     let mut suggestion = Sugg::hir(cx, expr, \"..\");\n \n     if let ExprKind::Unary(UnOp::Neg, inner_expr) = &expr.kind {\n-        expr = &inner_expr;\n+        expr = inner_expr;\n     }\n \n     if_chain! {\n@@ -313,8 +313,8 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                     Spanned {\n                         node: BinOpKind::Add, ..\n                     },\n-                    ref lhs,\n-                    ref rhs,\n+                    lhs,\n+                    rhs,\n                 ) = parent.kind\n                 {\n                     let other_addend = if lhs.hir_id == expr.hir_id { rhs } else { lhs };\n@@ -329,7 +329,7 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                             \"{}.mul_add({}, {})\",\n                             Sugg::hir(cx, &args[0], \"..\"),\n                             Sugg::hir(cx, &args[0], \"..\"),\n-                            Sugg::hir(cx, &other_addend, \"..\"),\n+                            Sugg::hir(cx, other_addend, \"..\"),\n                         ),\n                         Applicability::MachineApplicable,\n                     );\n@@ -356,18 +356,18 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n         Spanned {\n             node: BinOpKind::Add, ..\n         },\n-        ref add_lhs,\n-        ref add_rhs,\n+        add_lhs,\n+        add_rhs,\n     ) = args[0].kind\n     {\n         // check if expression of the form x * x + y * y\n         if_chain! {\n-            if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lmul_lhs, ref lmul_rhs) = add_lhs.kind;\n-            if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref rmul_lhs, ref rmul_rhs) = add_rhs.kind;\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, lmul_lhs, lmul_rhs) = add_lhs.kind;\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, rmul_lhs, rmul_rhs) = add_rhs.kind;\n             if eq_expr_value(cx, lmul_lhs, lmul_rhs);\n             if eq_expr_value(cx, rmul_lhs, rmul_rhs);\n             then {\n-                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &lmul_lhs, \"..\"), Sugg::hir(cx, &rmul_lhs, \"..\")));\n+                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, lmul_lhs, \"..\"), Sugg::hir(cx, rmul_lhs, \"..\")));\n             }\n         }\n \n@@ -376,13 +376,13 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: lmethod_name, .. },\n                 ref _lspan,\n-                ref largs,\n+                largs,\n                 _\n             ) = add_lhs.kind;\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: rmethod_name, .. },\n                 ref _rspan,\n-                ref rargs,\n+                rargs,\n                 _\n             ) = add_rhs.kind;\n             if lmethod_name.as_str() == \"powi\" && rmethod_name.as_str() == \"powi\";\n@@ -416,11 +416,11 @@ fn check_hypot(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n // and suggest usage of `x.exp_m1() - (y - 1)` instead\n fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, ref lhs, ref rhs) = expr.kind;\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, lhs, rhs) = expr.kind;\n         if cx.typeck_results().expr_ty(lhs).is_floating_point();\n         if let Some((value, _)) = constant(cx, cx.typeck_results(), rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n-        if let ExprKind::MethodCall(ref path, _, ref method_args, _) = lhs.kind;\n+        if let ExprKind::MethodCall(path, _, method_args, _) = lhs.kind;\n         if cx.typeck_results().expr_ty(&method_args[0]).is_floating_point();\n         if path.ident.name.as_str() == \"exp\";\n         then {\n@@ -442,7 +442,7 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n fn is_float_mul_expr<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n     if_chain! {\n-        if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lhs, ref rhs) = &expr.kind;\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, lhs, rhs) = &expr.kind;\n         if cx.typeck_results().expr_ty(lhs).is_floating_point();\n         if cx.typeck_results().expr_ty(rhs).is_floating_point();\n         then {\n@@ -604,8 +604,8 @@ fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n fn are_same_base_logs(cx: &LateContext<'_>, expr_a: &Expr<'_>, expr_b: &Expr<'_>) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, _, ref args_a, _) = expr_a.kind;\n-        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, _, ref args_b, _) = expr_b.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, _, args_a, _) = expr_a.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, _, args_b, _) = expr_b.kind;\n         then {\n             return method_name_a.as_str() == method_name_b.as_str() &&\n                 args_a.len() == args_b.len() &&\n@@ -630,8 +630,8 @@ fn check_log_division(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             rhs,\n         ) = &expr.kind;\n         if are_same_base_logs(cx, lhs, rhs);\n-        if let ExprKind::MethodCall(_, _, ref largs, _) = lhs.kind;\n-        if let ExprKind::MethodCall(_, _, ref rargs, _) = rhs.kind;\n+        if let ExprKind::MethodCall(_, _, largs, _) = lhs.kind;\n+        if let ExprKind::MethodCall(_, _, rargs, _) = rhs.kind;\n         then {\n             span_lint_and_sugg(\n                 cx,\n@@ -675,7 +675,7 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                     expr.span,\n                     \"conversion to degrees can be done more accurately\",\n                     \"consider using\",\n-                    format!(\"{}.to_degrees()\", Sugg::hir(cx, &mul_lhs, \"..\")),\n+                    format!(\"{}.to_degrees()\", Sugg::hir(cx, mul_lhs, \"..\")),\n                     Applicability::MachineApplicable,\n                 );\n             } else if\n@@ -688,7 +688,7 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                     expr.span,\n                     \"conversion to radians can be done more accurately\",\n                     \"consider using\",\n-                    format!(\"{}.to_radians()\", Sugg::hir(cx, &mul_lhs, \"..\")),\n+                    format!(\"{}.to_radians()\", Sugg::hir(cx, mul_lhs, \"..\")),\n                     Applicability::MachineApplicable,\n                 );\n             }\n@@ -698,7 +698,7 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(ref path, _, args, _) = &expr.kind {\n+        if let ExprKind::MethodCall(path, _, args, _) = &expr.kind {\n             let recv_ty = cx.typeck_results().expr_ty(&args[0]);\n \n             if recv_ty.is_floating_point() {"}, {"sha": "4729abbd8e3f7ff99ad2f2e29dfe653043243262", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -78,8 +78,8 @@ fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg:\n \n fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref format_args) = expr.kind;\n-        if let ExprKind::Array(ref elems) = arms[0].body.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, format_args) = expr.kind;\n+        if let ExprKind::Array(elems) = arms[0].body.kind;\n         if elems.len() == 1;\n         if let Some(args) = match_function_call(cx, &elems[0], &paths::FMT_ARGUMENTV1_NEW);\n         // matches `core::fmt::Display::fmt`\n@@ -88,10 +88,10 @@ fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &\n         if let Some(did) = cx.qpath_res(qpath, args[1].hir_id).opt_def_id();\n         if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n         // check `(arg0,)` in match block\n-        if let PatKind::Tuple(ref pats, None) = arms[0].pat.kind;\n+        if let PatKind::Tuple(pats, None) = arms[0].pat.kind;\n         if pats.len() == 1;\n         then {\n-            let ty = cx.typeck_results().pat_ty(&pats[0]).peel_refs();\n+            let ty = cx.typeck_results().pat_ty(pats[0]).peel_refs();\n             if *ty.kind() != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym::string_type) {\n                 return None;\n             }\n@@ -101,7 +101,7 @@ fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &\n                 }\n             } else {\n                 let snip = snippet(cx, format_args.span, \"<arg>\");\n-                if let ExprKind::MethodCall(ref path, _, _, _) = format_args.kind {\n+                if let ExprKind::MethodCall(path, _, _, _) = format_args.kind {\n                     if path.ident.name == sym!(to_string) {\n                         return Some(format!(\"{}\", snip));\n                     }\n@@ -120,16 +120,16 @@ fn on_new_v1<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<Strin\n         if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1);\n         if args.len() == 2;\n         // Argument 1 in `new_v1()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arr) = args[0].kind;\n-        if let ExprKind::Array(ref pieces) = arr.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, arr) = args[0].kind;\n+        if let ExprKind::Array(pieces) = arr.kind;\n         if pieces.len() == 1;\n         if let ExprKind::Lit(ref lit) = pieces[0].kind;\n         if let LitKind::Str(ref s, _) = lit.node;\n         // Argument 2 in `new_v1()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg1) = args[1].kind;\n-        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, arg1) = args[1].kind;\n+        if let ExprKind::Match(matchee, arms, MatchSource::Normal) = arg1.kind;\n         if arms.len() == 1;\n-        if let ExprKind::Tup(ref tup) = matchee.kind;\n+        if let ExprKind::Tup(tup) = matchee.kind;\n         then {\n             // `format!(\"foo\")` expansion contains `match () { () => [], }`\n             if tup.is_empty() {\n@@ -152,16 +152,16 @@ fn on_new_v1_fmt<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<S\n         if args.len() == 3;\n         if check_unformatted(&args[2]);\n         // Argument 1 in `new_v1_formatted()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arr) = args[0].kind;\n-        if let ExprKind::Array(ref pieces) = arr.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, arr) = args[0].kind;\n+        if let ExprKind::Array(pieces) = arr.kind;\n         if pieces.len() == 1;\n         if let ExprKind::Lit(ref lit) = pieces[0].kind;\n         if let LitKind::Str(..) = lit.node;\n         // Argument 2 in `new_v1_formatted()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg1) = args[1].kind;\n-        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, arg1) = args[1].kind;\n+        if let ExprKind::Match(matchee, arms, MatchSource::Normal) = arg1.kind;\n         if arms.len() == 1;\n-        if let ExprKind::Tup(ref tup) = matchee.kind;\n+        if let ExprKind::Tup(tup) = matchee.kind;\n         then {\n             return on_argumentv1_new(cx, &tup[0], arms);\n         }\n@@ -182,14 +182,14 @@ fn on_new_v1_fmt<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<S\n /// ```\n fn check_unformatted(expr: &Expr<'_>) -> bool {\n     if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) = expr.kind;\n-        if let ExprKind::Array(ref exprs) = expr.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n+        if let ExprKind::Array(exprs) = expr.kind;\n         if exprs.len() == 1;\n         // struct `core::fmt::rt::v1::Argument`\n-        if let ExprKind::Struct(_, ref fields, _) = exprs[0].kind;\n+        if let ExprKind::Struct(_, fields, _) = exprs[0].kind;\n         if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n         // struct `core::fmt::rt::v1::FormatSpec`\n-        if let ExprKind::Struct(_, ref fields, _) = format_field.expr.kind;\n+        if let ExprKind::Struct(_, fields, _) = format_field.expr.kind;\n         if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym::precision);\n         if let ExprKind::Path(ref precision_path) = precision_field.expr.kind;\n         if last_path_segment(precision_path).ident.name == sym::Implied;"}, {"sha": "db5fe90b663ad04c06324e4bb0740a505fa1735f", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -25,12 +25,12 @@ pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         let is_public = cx.access_levels.is_exported(item.hir_id());\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n-            check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n+            check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n             return;\n         } else if is_public && !is_proc_macro(cx.sess(), attrs) && attr_by_name(attrs, \"no_mangle\").is_none() {\n             check_must_use_candidate(\n                 cx,\n-                &sig.decl,\n+                sig.decl,\n                 cx.tcx.hir().body(*body_id),\n                 item.span,\n                 item.hir_id(),\n@@ -48,11 +48,11 @@ pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n         let attr = must_use_attr(attrs);\n         if let Some(attr) = attr {\n-            check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n+            check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n         } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.hir_id()).is_none() {\n             check_must_use_candidate(\n                 cx,\n-                &sig.decl,\n+                sig.decl,\n                 cx.tcx.hir().body(*body_id),\n                 item.span,\n                 item.hir_id(),\n@@ -71,13 +71,13 @@ pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitIte\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n         let attr = must_use_attr(attrs);\n         if let Some(attr) = attr {\n-            check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n+            check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n         } else if let hir::TraitFn::Provided(eid) = *eid {\n             let body = cx.tcx.hir().body(eid);\n             if attr.is_none() && is_public && !is_proc_macro(cx.sess(), attrs) {\n                 check_must_use_candidate(\n                     cx,\n-                    &sig.decl,\n+                    sig.decl,\n                     body,\n                     item.span,\n                     item.hir_id(),\n@@ -160,8 +160,8 @@ fn check_must_use_candidate<'tcx>(\n fn returns_unit(decl: &hir::FnDecl<'_>) -> bool {\n     match decl.output {\n         hir::FnRetTy::DefaultReturn(_) => true,\n-        hir::FnRetTy::Return(ref ty) => match ty.kind {\n-            hir::TyKind::Tup(ref tys) => tys.is_empty(),\n+        hir::FnRetTy::Return(ty) => match ty.kind {\n+            hir::TyKind::Tup(tys) => tys.is_empty(),\n             hir::TyKind::Never => true,\n             _ => false,\n         },\n@@ -170,15 +170,15 @@ fn returns_unit(decl: &hir::FnDecl<'_>) -> bool {\n \n fn has_mutable_arg(cx: &LateContext<'_>, body: &hir::Body<'_>) -> bool {\n     let mut tys = DefIdSet::default();\n-    body.params.iter().any(|param| is_mutable_pat(cx, &param.pat, &mut tys))\n+    body.params.iter().any(|param| is_mutable_pat(cx, param.pat, &mut tys))\n }\n \n fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut DefIdSet) -> bool {\n     if let hir::PatKind::Wild = pat.kind {\n         return false; // ignore `_` patterns\n     }\n     if cx.tcx.has_typeck_results(pat.hir_id.owner.to_def_id()) {\n-        is_mutable_ty(cx, &cx.tcx.typeck(pat.hir_id.owner).pat_ty(pat), pat.span, tys)\n+        is_mutable_ty(cx, cx.tcx.typeck(pat.hir_id.owner).pat_ty(pat), pat.span, tys)\n     } else {\n         false\n     }\n@@ -190,12 +190,12 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n     match *ty.kind() {\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n-        ty::Adt(ref adt, ref substs) => {\n+        ty::Adt(adt, substs) => {\n             tys.insert(adt.did) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n                 || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n                     && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n         },\n-        ty::Tuple(ref substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n+        ty::Tuple(substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n         ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n         ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n             mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)\n@@ -239,7 +239,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n                     tys.clear();\n                 }\n             },\n-            Assign(ref target, ..) | AssignOp(_, ref target, _) | AddrOf(_, hir::Mutability::Mut, ref target) => {\n+            Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target) => {\n                 self.mutates_static |= is_mutated_static(target)\n             },\n             _ => {},\n@@ -257,7 +257,7 @@ fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n     match e.kind {\n         Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n         Path(_) => true,\n-        Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(inner),\n+        Field(inner, _) | Index(inner, _) => is_mutated_static(inner),\n         _ => false,\n     }\n }"}, {"sha": "b8ea69908665655e1c4ad7eeee612cfd1d2d8d21", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -27,7 +27,7 @@ pub(super) fn check_fn(\n pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(eid)) = item.kind {\n         let body = cx.tcx.hir().body(eid);\n-        check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id());\n+        check_raw_ptr(cx, sig.header.unsafety, sig.decl, body, item.hir_id());\n     }\n }\n \n@@ -77,7 +77,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n         match expr.kind {\n-            hir::ExprKind::Call(ref f, args) => {\n+            hir::ExprKind::Call(f, args) => {\n                 let ty = self.typeck_results.expr_ty(f);\n \n                 if type_is_unsafe_function(self.cx, ty) {\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprKind::Unary(hir::UnOp::Deref, ref ptr) => self.check_arg(ptr),\n+            hir::ExprKind::Unary(hir::UnOp::Deref, ptr) => self.check_arg(ptr),\n             _ => (),\n         }\n "}, {"sha": "c073f312d386f3fc0d0155e7f9693bd4912e441b", "filename": "clippy_lints/src/functions/result_unit_err.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -18,7 +18,7 @@ pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         let is_public = cx.access_levels.is_exported(item.hir_id());\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if is_public {\n-            check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n+            check_result_unit_err(cx, sig.decl, item.span, fn_header_span);\n         }\n     }\n }\n@@ -28,7 +28,7 @@ pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<\n         let is_public = cx.access_levels.is_exported(item.hir_id());\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if is_public && trait_ref_of_method(cx, item.hir_id()).is_none() {\n-            check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n+            check_result_unit_err(cx, sig.decl, item.span, fn_header_span);\n         }\n     }\n }\n@@ -38,15 +38,15 @@ pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitIte\n         let is_public = cx.access_levels.is_exported(item.hir_id());\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if is_public {\n-            check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n+            check_result_unit_err(cx, sig.decl, item.span, fn_header_span);\n         }\n     }\n }\n \n fn check_result_unit_err(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, item_span: Span, fn_header_span: Span) {\n     if_chain! {\n         if !in_external_macro(cx.sess(), item_span);\n-        if let hir::FnRetTy::Return(ref ty) = decl.output;\n+        if let hir::FnRetTy::Return(ty) = decl.output;\n         let ty = hir_ty_to_ty(cx.tcx, ty);\n         if is_type_diagnostic_item(cx, ty, sym::result_type);\n         if let ty::Adt(_, substs) = ty.kind();"}, {"sha": "63a14d8d4cde897a04387e97e9649ea30ead2d63", "filename": "clippy_lints/src/functions/too_many_arguments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -49,7 +49,7 @@ pub(super) fn check_trait_item(\n         if sig.header.abi == Abi::Rust {\n             check_arg_number(\n                 cx,\n-                &sig.decl,\n+                sig.decl,\n                 item.span.with_hi(sig.decl.output.span().hi()),\n                 too_many_arguments_threshold,\n             );"}, {"sha": "3707e792177d3317408cb59dcf6c9c51022011d5", "filename": "clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for GetLastWithLen {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // Is a method call\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n \n             // Method name is \"get\"\n             if path.ident.name == sym!(get);"}, {"sha": "366b3b46a8aecdc0f9939b68f7424c5dc3083924", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -35,7 +35,7 @@ impl<'tcx> LateLintPass<'tcx> for IdentityOp {\n         if e.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Binary(cmp, ref left, ref right) = e.kind {\n+        if let ExprKind::Binary(cmp, left, right) = e.kind {\n             if is_allowed(cx, cmp, left, right) {\n                 return;\n             }"}, {"sha": "f661f7ede821a6d486a33448eab7c56fd8e106da", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -55,16 +55,16 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n             cx,\n         };\n         if let ExprKind::Match(\n-            ref op,\n-            ref arms,\n+            op,\n+            arms,\n             MatchSource::IfLetDesugar {\n                 contains_else_clause: true,\n             },\n         ) = ex.kind\n         {\n             op_visit.visit_expr(op);\n             if op_visit.mutex_lock_called {\n-                for arm in *arms {\n+                for arm in arms {\n                     arm_visit.visit_arm(arm);\n                 }\n "}, {"sha": "611da3744eeeeba2b4fabbaa368d01a6d0475cb8", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -44,9 +44,9 @@ declare_lint_pass!(OkIfLet => [IF_LET_SOME_RESULT]);\n impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! { //begin checking variables\n-            if let ExprKind::Match(ref op, ref body, MatchSource::IfLetDesugar { .. }) = expr.kind; //test if expr is if let\n-            if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n-            if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n+            if let ExprKind::Match(op, body, MatchSource::IfLetDesugar { .. }) = expr.kind; //test if expr is if let\n+            if let ExprKind::MethodCall(_, ok_span, result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n+            if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&result_types[0]), sym::result_type);\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";"}, {"sha": "ee16519692f9a8b83e64728b2270ec316569edf8", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -72,15 +72,15 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n         }\n \n         if_chain! {\n-            if let ExprKind::If(ref cond, ref then, Some(ref els)) = expr.kind;\n-            if let ExprKind::Block(ref then_block, _) = then.kind;\n-            if let Some(ref then_expr) = then_block.expr;\n-            if let ExprKind::Call(ref then_call, [then_arg]) = then_expr.kind;\n+            if let ExprKind::If(cond, then, Some(els)) = expr.kind;\n+            if let ExprKind::Block(then_block, _) = then.kind;\n+            if let Some(then_expr) = then_block.expr;\n+            if let ExprKind::Call(then_call, [then_arg]) = then_expr.kind;\n             if let ExprKind::Path(ref then_call_qpath) = then_call.kind;\n             if match_qpath(then_call_qpath, &clippy_utils::paths::OPTION_SOME);\n-            if let ExprKind::Block(ref els_block, _) = els.kind;\n+            if let ExprKind::Block(els_block, _) = els.kind;\n             if els_block.stmts.is_empty();\n-            if let Some(ref els_expr) = els_block.expr;\n+            if let Some(els_expr) = els_block.expr;\n             if let ExprKind::Path(ref els_call_qpath) = els_expr.kind;\n             if match_qpath(els_call_qpath, &clippy_utils::paths::OPTION_NONE);\n             then {"}, {"sha": "77a38544edc87151198181708d4d83f1d8261e19", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -207,7 +207,7 @@ enum ImplicitHasherType<'tcx> {\n impl<'tcx> ImplicitHasherType<'tcx> {\n     /// Checks that `ty` is a target type without a `BuildHasher`.\n     fn new(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> Option<Self> {\n-        if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.kind {\n+        if let TyKind::Path(QPath::Resolved(None, path)) = hir_ty.kind {\n             let params: Vec<_> = path\n                 .segments\n                 .last()\n@@ -330,8 +330,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n \n     fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref fun, ref args) = e.kind;\n-            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.kind;\n+            if let ExprKind::Call(fun, args) = e.kind;\n+            if let ExprKind::Path(QPath::TypeRelative(ty, method)) = fun.kind;\n             if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n             then {\n                 if !TyS::same_type(self.target.ty(), self.maybe_typeck_results.unwrap().expr_ty(e)) {"}, {"sha": "6b379b0d59b2bb0c807d23687de2c578524cb12a", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -100,10 +100,10 @@ fn expr_match(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n             if check_all_arms {\n                 for arm in arms {\n-                    expr_match(cx, &arm.body);\n+                    expr_match(cx, arm.body);\n                 }\n             } else {\n-                expr_match(cx, &arms.first().expect(\"`if let` doesn't have a single arm\").body);\n+                expr_match(cx, arms.first().expect(\"`if let` doesn't have a single arm\").body);\n             }\n         },\n         // skip if it already has a return statement"}, {"sha": "cba3183e86950aaf83e8e9cbfe6a0e759a572b42", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -46,21 +46,21 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n             if let ExprKind::If(cond, then, None) = &expr.kind;\n \n             // Check if the conditional expression is a binary operation\n-            if let ExprKind::Binary(ref cond_op, ref cond_left, ref cond_right) = cond.kind;\n+            if let ExprKind::Binary(ref cond_op, cond_left, cond_right) = cond.kind;\n \n             // Ensure that the binary operator is >, != and <\n             if BinOpKind::Ne == cond_op.node || BinOpKind::Gt == cond_op.node || BinOpKind::Lt == cond_op.node;\n \n             // Check if the true condition block has only one statement\n-            if let ExprKind::Block(ref block, _) = then.kind;\n+            if let ExprKind::Block(block, _) = then.kind;\n             if block.stmts.len() == 1 && block.expr.is_none();\n \n             // Check if assign operation is done\n-            if let StmtKind::Semi(ref e) = block.stmts[0].kind;\n+            if let StmtKind::Semi(e) = block.stmts[0].kind;\n             if let Some(target) = subtracts_one(cx, e);\n \n             // Extracting out the variable name\n-            if let ExprKind::Path(QPath::Resolved(_, ref ares_path)) = target.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, ares_path)) = target.kind;\n \n             then {\n                 // Handle symmetric conditions in the if statement\n@@ -104,7 +104,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                             print_lint_and_sugg(cx, &var_name, expr);\n                         };\n                     },\n-                    ExprKind::Call(ref func, _) => {\n+                    ExprKind::Call(func, _) => {\n                         if let ExprKind::Path(ref cond_num_path) = func.kind {\n                             if INT_TYPES.iter().any(|int_type| match_qpath(cond_num_path, &[int_type, \"min_value\"])) {\n                                 print_lint_and_sugg(cx, &var_name, expr);\n@@ -120,7 +120,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n \n fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &Expr<'a>) -> Option<&'a Expr<'a>> {\n     match expr.kind {\n-        ExprKind::AssignOp(ref op1, ref target, ref value) => {\n+        ExprKind::AssignOp(ref op1, target, value) => {\n             if_chain! {\n                 if BinOpKind::Sub == op1.node;\n                 // Check if literal being subtracted is one\n@@ -133,9 +133,9 @@ fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &Expr<'a>) -> Option<&'a Expr<'\n                 }\n             }\n         },\n-        ExprKind::Assign(ref target, ref value, _) => {\n+        ExprKind::Assign(target, value, _) => {\n             if_chain! {\n-                if let ExprKind::Binary(ref op1, ref left1, ref right1) = value.kind;\n+                if let ExprKind::Binary(ref op1, left1, right1) = value.kind;\n                 if BinOpKind::Sub == op1.node;\n \n                 if SpanlessEq::new(cx).eq_expr(left1, target);"}, {"sha": "1c54599abc40558fd6306d49023ee89c8de7c64e", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -88,7 +88,7 @@ declare_lint_pass!(IndexingSlicing => [INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING]\n \n impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Index(ref array, ref index) = &expr.kind {\n+        if let ExprKind::Index(array, index) = &expr.kind {\n             let ty = cx.typeck_results().expr_ty(array).peel_refs();\n             if let Some(range) = higher::range(index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]"}, {"sha": "bbb4ddc613af5ca60cdd773dba6b5a193d042b41", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -139,7 +139,7 @@ const HEURISTICS: [(&str, usize, Heuristic, Finiteness); 19] = [\n \n fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(ref method, _, ref args, _) => {\n+        ExprKind::MethodCall(method, _, args, _) => {\n             for &(name, len, heuristic, cap) in &HEURISTICS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n                     return (match heuristic {\n@@ -159,9 +159,9 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n             }\n             Finite\n         },\n-        ExprKind::Block(ref block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n-        ExprKind::Box(ref e) | ExprKind::AddrOf(BorrowKind::Ref, _, ref e) => is_infinite(cx, e),\n-        ExprKind::Call(ref path, _) => {\n+        ExprKind::Block(block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n+        ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) => is_infinite(cx, e),\n+        ExprKind::Call(path, _) => {\n             if let ExprKind::Path(ref qpath) = path.kind {\n                 match_qpath(qpath, &paths::REPEAT).into()\n             } else {\n@@ -215,7 +215,7 @@ const INFINITE_COLLECTORS: [&[&str]; 8] = [\n \n fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(ref method, _, ref args, _) => {\n+        ExprKind::MethodCall(method, _, args, _) => {\n             for &(name, len) in &COMPLETING_METHODS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n                     return is_infinite(cx, &args[0]);\n@@ -240,7 +240,7 @@ fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n                 }\n             }\n         },\n-        ExprKind::Binary(op, ref l, ref r) => {\n+        ExprKind::Binary(op, l, r) => {\n             if op.node.is_comparison() {\n                 return is_infinite(cx, l).and(is_infinite(cx, r)).and(MaybeInfinite);\n             }"}, {"sha": "c67c02eefa5f6b680eb704e3f9b7d0ac03bccc6b", "filename": "clippy_lints/src/invalid_upcast_comparisons.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -86,7 +86,7 @@ impl Ord for FullInt {\n }\n \n fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n-    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n+    if let ExprKind::Cast(cast_exp, _) = expr.kind {\n         let pre_cast_ty = cx.typeck_results().expr_ty(cast_exp);\n         let cast_ty = cx.typeck_results().expr_ty(expr);\n         // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n@@ -131,7 +131,7 @@ fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) ->\n }\n \n fn err_upcast_comparison(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, always: bool) {\n-    if let ExprKind::Cast(ref cast_val, _) = expr.kind {\n+    if let ExprKind::Cast(cast_val, _) = expr.kind {\n         span_lint(\n             cx,\n             INVALID_UPCAST_COMPARISONS,\n@@ -203,7 +203,7 @@ fn upcast_comparison_bounds_err<'tcx>(\n \n impl<'tcx> LateLintPass<'tcx> for InvalidUpcastComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n+        if let ExprKind::Binary(ref cmp, lhs, rhs) = expr.kind {\n             let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n             let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n                 val"}, {"sha": "f166748d86b81a021822759440e66456206309b5", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -113,7 +113,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n                             );\n                             if variant.fields.len() == 1 {\n                                 let span = match def.variants[i].data {\n-                                    VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, ..) => {\n+                                    VariantData::Struct(fields, ..) | VariantData::Tuple(fields, ..) => {\n                                         fields[0].ty.span\n                                     },\n                                     VariantData::Unit(..) => unreachable!(),"}, {"sha": "bb57adff7bea1eb1e004e3f9246d609f7ccec534", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -121,7 +121,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             return;\n         }\n \n-        if let ItemKind::Trait(_, _, _, _, ref trait_items) = item.kind {\n+        if let ItemKind::Trait(_, _, _, _, trait_items) = item.kind {\n             check_trait_items(cx, item, trait_items);\n         }\n     }\n@@ -162,7 +162,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             return;\n         }\n \n-        if let ExprKind::Binary(Spanned { node: cmp, .. }, ref left, ref right) = expr.kind {\n+        if let ExprKind::Binary(Spanned { node: cmp, .. }, left, right) = expr.kind {\n             match cmp {\n                 BinOpKind::Eq => {\n                     check_cmp(cx, expr.span, left, right, \"\", 0); // len == 0\n@@ -372,8 +372,7 @@ fn check_for_is_empty(\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(ref method_path, _, ref args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind)\n-    {\n+    if let (&ExprKind::MethodCall(method_path, _, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {\n@@ -451,7 +450,7 @@ fn is_empty_string(expr: &Expr<'_>) -> bool {\n }\n \n fn is_empty_array(expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Array(ref arr) = expr.kind {\n+    if let ExprKind::Array(arr) = expr.kind {\n         return arr.is_empty();\n     }\n     false\n@@ -480,17 +479,17 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n             cx.tcx\n                 .associated_items(*imp)\n                 .in_definition_order()\n-                .any(|item| is_is_empty(cx, &item))\n+                .any(|item| is_is_empty(cx, item))\n         })\n     }\n \n     let ty = &cx.typeck_results().expr_ty(expr).peel_refs();\n     match ty.kind() {\n-        ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {\n+        ty::Dynamic(tt, ..) => tt.principal().map_or(false, |principal| {\n             cx.tcx\n                 .associated_items(principal.def_id())\n                 .in_definition_order()\n-                .any(|item| is_is_empty(cx, &item))\n+                .any(|item| is_is_empty(cx, item))\n         }),\n         ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n         ty::Adt(id, _) => has_is_empty_impl(cx, id.did),"}, {"sha": "67eae4d87bbdb44524b36a17e673f52302e582e5", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -61,13 +61,13 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n         while let Some(stmt) = it.next() {\n             if_chain! {\n                 if let Some(expr) = it.peek();\n-                if let hir::StmtKind::Local(ref local) = stmt.kind;\n+                if let hir::StmtKind::Local(local) = stmt.kind;\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n-                if let hir::StmtKind::Expr(ref if_) = expr.kind;\n-                if let hir::ExprKind::If(ref cond, ref then, ref else_) = if_.kind;\n+                if let hir::StmtKind::Expr(if_) = expr.kind;\n+                if let hir::ExprKind::If(cond, then, ref else_) = if_.kind;\n                 let mut used_visitor = LocalUsedVisitor::new(cx, canonical_id);\n                 if !used_visitor.check_expr(cond);\n-                if let hir::ExprKind::Block(ref then, _) = then.kind;\n+                if let hir::ExprKind::Block(then, _) = then.kind;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n                 if !used_visitor.check_expr(value);\n                 then {\n@@ -79,20 +79,20 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                     );\n                     if has_interior_mutability { return; }\n \n-                    let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n-                        if let hir::ExprKind::Block(ref else_, _) = else_.kind {\n+                    let (default_multi_stmts, default) = if let Some(else_) = *else_ {\n+                        if let hir::ExprKind::Block(else_, _) = else_.kind {\n                             if let Some(default) = check_assign(cx, canonical_id, else_) {\n                                 (else_.stmts.len() > 1, default)\n-                            } else if let Some(ref default) = local.init {\n-                                (true, &**default)\n+                            } else if let Some(default) = local.init {\n+                                (true, default)\n                             } else {\n                                 continue;\n                             }\n                         } else {\n                             continue;\n                         }\n-                    } else if let Some(ref default) = local.init {\n-                        (false, &**default)\n+                    } else if let Some(default) = local.init {\n+                        (false, default)\n                     } else {\n                         continue;\n                     };\n@@ -144,8 +144,8 @@ fn check_assign<'tcx>(\n     if_chain! {\n         if block.expr.is_none();\n         if let Some(expr) = block.stmts.iter().last();\n-        if let hir::StmtKind::Semi(ref expr) = expr.kind;\n-        if let hir::ExprKind::Assign(ref var, ref value, _) = expr.kind;\n+        if let hir::StmtKind::Semi(expr) = expr.kind;\n+        if let hir::ExprKind::Assign(var, value, _) = expr.kind;\n         if path_to_local_id(var, decl);\n         then {\n             let mut v = LocalUsedVisitor::new(cx, decl);"}, {"sha": "17e23781db7d6a73c4653d7a29035f6fddb53a00", "filename": "clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_underscore.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -116,7 +116,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n \n         if_chain! {\n             if let PatKind::Wild = local.pat.kind;\n-            if let Some(ref init) = local.init;\n+            if let Some(init) = local.init;\n             then {\n                 let init_ty = cx.typeck_results().expr_ty(init);\n                 let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {"}, {"sha": "cd92b551abd6eaeed1c38e34c6f0bad3e8992132", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1223, "deletions": 1223, "changes": 2446, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b"}, {"sha": "116ad072837928a7cf573aa1e790528059b4e942", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -81,7 +81,7 @@ declare_lint_pass!(Lifetimes => [NEEDLESS_LIFETIMES, EXTRA_UNUSED_LIFETIMES]);\n impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Fn(ref sig, ref generics, id) = item.kind {\n-            check_fn_inner(cx, &sig.decl, Some(id), generics, item.span, true);\n+            check_fn_inner(cx, sig.decl, Some(id), generics, item.span, true);\n         }\n     }\n \n@@ -90,7 +90,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n             let report_extra_lifetimes = trait_ref_of_method(cx, item.hir_id()).is_none();\n             check_fn_inner(\n                 cx,\n-                &sig.decl,\n+                sig.decl,\n                 Some(id),\n                 &item.generics,\n                 item.span,\n@@ -105,7 +105,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n                 TraitFn::Required(_) => None,\n                 TraitFn::Provided(id) => Some(id),\n             };\n-            check_fn_inner(cx, &sig.decl, body, &item.generics, item.span, true);\n+            check_fn_inner(cx, sig.decl, body, &item.generics, item.span, true);\n         }\n     }\n }\n@@ -149,7 +149,7 @@ fn check_fn_inner<'tcx>(\n                     .last()\n                     .expect(\"a path must have at least one segment\")\n                     .args;\n-                if let Some(ref params) = *params {\n+                if let Some(params) = *params {\n                     let lifetimes = params.args.iter().filter_map(|arg| match arg {\n                         GenericArg::Lifetime(lt) => Some(lt),\n                         _ => None,\n@@ -163,7 +163,7 @@ fn check_fn_inner<'tcx>(\n             }\n         }\n     }\n-    if could_use_elision(cx, decl, body, &generics.params) {\n+    if could_use_elision(cx, decl, body, generics.params) {\n         span_lint(\n             cx,\n             NEEDLESS_LIFETIMES,\n@@ -201,7 +201,7 @@ fn could_use_elision<'tcx>(\n         input_visitor.visit_ty(arg);\n     }\n     // extract lifetimes in output type\n-    if let Return(ref ty) = func.output {\n+    if let Return(ty) = func.output {\n         output_visitor.visit_ty(ty);\n     }\n     for lt in named_generics {\n@@ -416,12 +416,12 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereCl\n                 // a predicate like F: Trait or F: for<'a> Trait<'a>\n                 let mut visitor = RefVisitor::new(cx);\n                 // walk the type F, it may not contain LT refs\n-                walk_ty(&mut visitor, &pred.bounded_ty);\n+                walk_ty(&mut visitor, pred.bounded_ty);\n                 if !visitor.all_lts().is_empty() {\n                     return true;\n                 }\n                 // if the bounds define new lifetimes, they are fine to occur\n-                let allowed_lts = allowed_lts_from(&pred.bound_generic_params);\n+                let allowed_lts = allowed_lts_from(pred.bound_generic_params);\n                 // now walk the bounds\n                 for bound in pred.bounds.iter() {\n                     walk_param_bound(&mut visitor, bound);\n@@ -433,8 +433,8 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereCl\n             },\n             WherePredicate::EqPredicate(ref pred) => {\n                 let mut visitor = RefVisitor::new(cx);\n-                walk_ty(&mut visitor, &pred.lhs_ty);\n-                walk_ty(&mut visitor, &pred.rhs_ty);\n+                walk_ty(&mut visitor, pred.lhs_ty);\n+                walk_ty(&mut visitor, pred.rhs_ty);\n                 if !visitor.lts.is_empty() {\n                     return true;\n                 }"}, {"sha": "1d63af25803dd1436d358eec0cf1936f507001ec", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -248,7 +248,7 @@ impl LiteralDigitGrouping {\n     fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         if_chain! {\n             if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(mut num_lit) = NumericLiteral::from_lit(&src, &lit);\n+            if let Some(mut num_lit) = NumericLiteral::from_lit(&src, lit);\n             then {\n                 if !Self::check_for_mistyped_suffix(cx, lit.span, &mut num_lit) {\n                     return;\n@@ -438,7 +438,7 @@ impl DecimalLiteralRepresentation {\n         if_chain! {\n             if let LitKind::Int(val, _) = lit.kind;\n             if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(num_lit) = NumericLiteral::from_lit(&src, &lit);\n+            if let Some(num_lit) = NumericLiteral::from_lit(&src, lit);\n             if num_lit.radix == Radix::Decimal;\n             if val >= u128::from(self.threshold);\n             then {"}, {"sha": "98e60f7ed85cf16c939e8917a97f66976515ab0b", "filename": "clippy_lints/src/loops/explicit_counter_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -26,7 +26,7 @@ pub(super) fn check<'tcx>(\n \n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n-    if let Some(block) = get_enclosing_block(&cx, expr.hir_id) {\n+    if let Some(block) = get_enclosing_block(cx, expr.hir_id) {\n         for id in increment_visitor.into_results() {\n             let mut initialize_visitor = InitializeVisitor::new(cx, expr, id);\n             walk_block(&mut initialize_visitor, block);"}, {"sha": "666b8c58728c27ffeb2158527a97aa871f53c0dd", "filename": "clippy_lints/src/loops/for_kv_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -19,7 +19,7 @@ pub(super) fn check<'tcx>(\n ) {\n     let pat_span = pat.span;\n \n-    if let PatKind::Tuple(ref pat, _) = pat.kind {\n+    if let PatKind::Tuple(pat, _) = pat.kind {\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n             let (new_pat_span, kind, ty, mutbl) = match *cx.typeck_results().expr_ty(arg).kind() {\n@@ -35,7 +35,7 @@ pub(super) fn check<'tcx>(\n                 Mutability::Mut => \"_mut\",\n             };\n             let arg = match arg.kind {\n-                ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) => &**expr,\n+                ExprKind::AddrOf(BorrowKind::Ref, _, expr) => expr,\n                 _ => arg,\n             };\n "}, {"sha": "94743cfcf4657705f708f7e5d94ff61592c900d5", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -18,7 +18,7 @@ pub(super) fn check<'tcx>(\n     body: &'tcx Expr<'_>,\n     span: Span,\n ) {\n-    if let ExprKind::Block(ref block, _) = body.kind {\n+    if let ExprKind::Block(block, _) = body.kind {\n         // Ensure the `if let` statement is the only expression or statement in the for-loop\n         let inner_expr = if block.stmts.len() == 1 && block.expr.is_none() {\n             let match_stmt = &block.stmts[0];\n@@ -36,7 +36,7 @@ pub(super) fn check<'tcx>(\n         if_chain! {\n             if let Some(inner_expr) = inner_expr;\n             if let ExprKind::Match(\n-                ref match_expr, ref match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n+                match_expr, match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n             ) = inner_expr.kind;\n             // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n             if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;"}, {"sha": "47005aba38890927d0032c025252ab51c4a97f43", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -63,8 +63,8 @@ pub(super) fn check<'tcx>(\n                             if let ExprKind::Index(base_right, idx_right) = rhs.kind;\n                             if is_slice_like(cx, cx.typeck_results().expr_ty(base_left));\n                             if is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n-                            if let Some((start_left, offset_left)) = get_details_from_idx(cx, &idx_left, &starts);\n-                            if let Some((start_right, offset_right)) = get_details_from_idx(cx, &idx_right, &starts);\n+                            if let Some((start_left, offset_left)) = get_details_from_idx(cx, idx_left, &starts);\n+                            if let Some((start_right, offset_right)) = get_details_from_idx(cx, idx_right, &starts);\n \n                             // Source and destination must be different\n                             if path_to_local(base_left) != path_to_local(base_right);\n@@ -168,8 +168,8 @@ fn build_manual_memcpy_suggestion<'tcx>(\n         },\n     };\n \n-    let (dst_offset, dst_limit) = print_offset_and_limit(&dst);\n-    let (src_offset, src_limit) = print_offset_and_limit(&src);\n+    let (dst_offset, dst_limit) = print_offset_and_limit(dst);\n+    let (src_offset, src_limit) = print_offset_and_limit(src);\n \n     let dst_base_str = snippet(cx, dst.base.span, \"???\");\n     let src_base_str = snippet(cx, src.base.span, \"???\");\n@@ -435,7 +435,7 @@ fn get_loop_counters<'a, 'tcx>(\n \n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n-    get_enclosing_block(&cx, expr.hir_id).and_then(|block| {\n+    get_enclosing_block(cx, expr.hir_id).and_then(|block| {\n         increment_visitor\n             .into_results()\n             .filter_map(move |var_id| {"}, {"sha": "28acefd51fef74554630f7bea55ae5469c18b2cb", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -562,15 +562,15 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")\n         // (even if the \"match\" or \"if let\" is used for declaration)\n-        if let ExprKind::Loop(ref block, _, LoopSource::Loop, _) = expr.kind {\n+        if let ExprKind::Loop(block, _, LoopSource::Loop, _) = expr.kind {\n             // also check for empty `loop {}` statements, skipping those in #[panic_handler]\n             empty_loop::check(cx, expr, block);\n             while_let_loop::check(cx, expr, block);\n         }\n \n         while_let_on_iterator::check(cx, expr);\n \n-        if let Some((cond, body)) = higher::while_loop(&expr) {\n+        if let Some((cond, body)) = higher::while_loop(expr) {\n             while_immutable_condition::check(cx, cond, body);\n         }\n \n@@ -602,7 +602,7 @@ fn check_for_loop<'tcx>(\n fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n \n-    if let ExprKind::MethodCall(ref method, _, ref args, _) = arg.kind {\n+    if let ExprKind::MethodCall(method, _, args, _) = arg.kind {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n             let method_name = &*method.ident.as_str();"}, {"sha": "4d73aef76e87e8604294791aac254627716f9f62", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -21,10 +21,10 @@ pub(super) fn check<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n }\n fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n-        if let ExprKind::MethodCall(ref chain_method, method0_span, _, _) = args[0].kind;\n+        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n+        if let ExprKind::MethodCall(chain_method, method0_span, _, _) = args[0].kind;\n         if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n-        if let Some(ref generic_args) = chain_method.args;\n+        if let Some(generic_args) = chain_method.args;\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n         let ty = cx.typeck_results().node_type(ty.hir_id);\n         if is_type_diagnostic_item(cx, ty, sym::vec_type)\n@@ -58,16 +58,16 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n }\n \n fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    if let ExprKind::Block(ref block, _) = expr.kind {\n-        for ref stmt in block.stmts {\n+    if let ExprKind::Block(block, _) = expr.kind {\n+        for stmt in block.stmts {\n             if_chain! {\n                 if let StmtKind::Local(\n                     Local { pat: Pat { hir_id: pat_id, kind: PatKind::Binding(_, _, ident, .. ), .. },\n-                    init: Some(ref init_expr), .. }\n+                    init: Some(init_expr), .. }\n                 ) = stmt.kind;\n-                if let ExprKind::MethodCall(ref method_name, collect_span, &[ref iter_source], ..) = init_expr.kind;\n-                if method_name.ident.name == sym!(collect) && is_trait_method(cx, &init_expr, sym::Iterator);\n-                if let Some(ref generic_args) = method_name.args;\n+                if let ExprKind::MethodCall(method_name, collect_span, &[ref iter_source], ..) = init_expr.kind;\n+                if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n+                if let Some(generic_args) = method_name.args;\n                 if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n                 if let ty = cx.typeck_results().node_type(ty.hir_id);\n                 if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n@@ -165,8 +165,8 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n         if_chain! {\n-            if let ExprKind::MethodCall(method_name, _, ref args, _) = &expr.kind;\n-            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. }) = args.get(0);\n+            if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n+            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, path)), .. }) = args.get(0);\n             if let &[name] = &path.segments;\n             if name.ident == self.target;\n             then {\n@@ -193,7 +193,7 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n         }\n         // Check if the collection is used for anything else\n         if_chain! {\n-            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. } = expr;\n+            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, path)), .. } = expr;\n             if let &[name] = &path.segments;\n             if name.ident == self.target;\n             then {"}, {"sha": "56141fb38376482a4e86bb63ff6725cadb46d20a", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -96,7 +96,7 @@ pub(super) fn check<'tcx>(\n                 let take = if let Some(end) = *end {\n                     let mut take_expr = end;\n \n-                    if let ExprKind::Binary(ref op, ref left, ref right) = end.kind {\n+                    if let ExprKind::Binary(ref op, left, right) = end.kind {\n                         if let BinOpKind::Add = op.node {\n                             let start_equal_left = SpanlessEq::new(cx).eq_expr(start, left);\n                             let start_equal_right = SpanlessEq::new(cx).eq_expr(start, right);\n@@ -190,10 +190,10 @@ pub(super) fn check<'tcx>(\n \n fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref len_args, _) = expr.kind;\n+        if let ExprKind::MethodCall(method, _, len_args, _) = expr.kind;\n         if len_args.len() == 1;\n         if method.ident.name == sym!(len);\n-        if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].kind;\n+        if let ExprKind::Path(QPath::Resolved(_, path)) = len_args[0].kind;\n         if path.segments.len() == 1;\n         if path.segments[0].ident.name == var;\n         then {\n@@ -254,7 +254,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n         if_chain! {\n             // the indexed container is referenced by a name\n             if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n-            if let QPath::Resolved(None, ref seqvar) = *seqpath;\n+            if let QPath::Resolved(None, seqvar) = *seqpath;\n             if seqvar.segments.len() == 1;\n             let index_used_directly = path_to_local_id(idx, self.var);\n             let indexed_indirectly = {\n@@ -310,7 +310,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // a range index op\n-            if let ExprKind::MethodCall(ref meth, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(meth, _, args, _) = expr.kind;\n             if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n                 || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(&args[1], &args[0], expr);\n@@ -319,7 +319,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n \n         if_chain! {\n             // an index op\n-            if let ExprKind::Index(ref seqexpr, ref idx) = expr.kind;\n+            if let ExprKind::Index(seqexpr, idx) = expr.kind;\n             if !self.check(idx, seqexpr, expr);\n             then { return }\n         }\n@@ -340,19 +340,19 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n \n         let old = self.prefer_mutable;\n         match expr.kind {\n-            ExprKind::AssignOp(_, ref lhs, ref rhs) | ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            ExprKind::AssignOp(_, lhs, rhs) | ExprKind::Assign(lhs, rhs, _) => {\n                 self.prefer_mutable = true;\n                 self.visit_expr(lhs);\n                 self.prefer_mutable = false;\n                 self.visit_expr(rhs);\n             },\n-            ExprKind::AddrOf(BorrowKind::Ref, mutbl, ref expr) => {\n+            ExprKind::AddrOf(BorrowKind::Ref, mutbl, expr) => {\n                 if mutbl == Mutability::Mut {\n                     self.prefer_mutable = true;\n                 }\n                 self.visit_expr(expr);\n             },\n-            ExprKind::Call(ref f, args) => {\n+            ExprKind::Call(f, args) => {\n                 self.visit_expr(f);\n                 for expr in args {\n                     let ty = self.cx.typeck_results().expr_ty_adjusted(expr);"}, {"sha": "e2cb4638018aaea6ed40297c3e6e45b33bcfc7c9", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -5,7 +5,7 @@ use rustc_lint::LateContext;\n use std::iter::{once, Iterator};\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Loop(ref block, _, _, _) = expr.kind {\n+    if let ExprKind::Loop(block, _, _, _) = expr.kind {\n         match never_loop_block(block, expr.hir_id) {\n             NeverLoopResult::AlwaysBreak => span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n             NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n@@ -76,44 +76,44 @@ fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_lo\n \n fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     match stmt.kind {\n-        StmtKind::Semi(ref e, ..) | StmtKind::Expr(ref e, ..) => Some(e),\n-        StmtKind::Local(ref local) => local.init.as_deref(),\n+        StmtKind::Semi(e, ..) | StmtKind::Expr(e, ..) => Some(e),\n+        StmtKind::Local(local) => local.init.as_deref(),\n         StmtKind::Item(..) => None,\n     }\n }\n \n fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n     match expr.kind {\n-        ExprKind::Box(ref e)\n-        | ExprKind::Unary(_, ref e)\n-        | ExprKind::Cast(ref e, _)\n-        | ExprKind::Type(ref e, _)\n-        | ExprKind::Field(ref e, _)\n-        | ExprKind::AddrOf(_, _, ref e)\n-        | ExprKind::Struct(_, _, Some(ref e))\n-        | ExprKind::Repeat(ref e, _)\n-        | ExprKind::DropTemps(ref e) => never_loop_expr(e, main_loop_id),\n-        ExprKind::Array(ref es) | ExprKind::MethodCall(_, _, ref es, _) | ExprKind::Tup(ref es) => {\n+        ExprKind::Box(e)\n+        | ExprKind::Unary(_, e)\n+        | ExprKind::Cast(e, _)\n+        | ExprKind::Type(e, _)\n+        | ExprKind::Field(e, _)\n+        | ExprKind::AddrOf(_, _, e)\n+        | ExprKind::Struct(_, _, Some(e))\n+        | ExprKind::Repeat(e, _)\n+        | ExprKind::DropTemps(e) => never_loop_expr(e, main_loop_id),\n+        ExprKind::Array(es) | ExprKind::MethodCall(_, _, es, _) | ExprKind::Tup(es) => {\n             never_loop_expr_all(&mut es.iter(), main_loop_id)\n         },\n-        ExprKind::Call(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n-        ExprKind::Binary(_, ref e1, ref e2)\n-        | ExprKind::Assign(ref e1, ref e2, _)\n-        | ExprKind::AssignOp(_, ref e1, ref e2)\n-        | ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n-        ExprKind::Loop(ref b, _, _, _) => {\n+        ExprKind::Call(e, es) => never_loop_expr_all(&mut once(e).chain(es.iter()), main_loop_id),\n+        ExprKind::Binary(_, e1, e2)\n+        | ExprKind::Assign(e1, e2, _)\n+        | ExprKind::AssignOp(_, e1, e2)\n+        | ExprKind::Index(e1, e2) => never_loop_expr_all(&mut [e1, e2].iter().cloned(), main_loop_id),\n+        ExprKind::Loop(b, _, _, _) => {\n             // Break can come from the inner loop so remove them.\n             absorb_break(&never_loop_block(b, main_loop_id))\n         },\n-        ExprKind::If(ref e, ref e2, ref e3) => {\n+        ExprKind::If(e, e2, ref e3) => {\n             let e1 = never_loop_expr(e, main_loop_id);\n             let e2 = never_loop_expr(e2, main_loop_id);\n             let e3 = e3\n                 .as_ref()\n                 .map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n             combine_seq(e1, combine_branches(e2, e3))\n         },\n-        ExprKind::Match(ref e, ref arms, _) => {\n+        ExprKind::Match(e, arms, _) => {\n             let e = never_loop_expr(e, main_loop_id);\n             if arms.is_empty() {\n                 e\n@@ -122,7 +122,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 combine_seq(e, arms)\n             }\n         },\n-        ExprKind::Block(ref b, _) => never_loop_block(b, main_loop_id),\n+        ExprKind::Block(b, _) => never_loop_block(b, main_loop_id),\n         ExprKind::Continue(d) => {\n             let id = d\n                 .target_id\n@@ -136,7 +136,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n             combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n         }),\n-        ExprKind::InlineAsm(ref asm) => asm\n+        ExprKind::InlineAsm(asm) => asm\n             .operands\n             .iter()\n             .map(|(o, _)| match o {"}, {"sha": "cb2c83e90294accb9185a56ad28f395f1c98cf06", "filename": "clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -161,7 +161,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n         if vec_push_option.is_none() {\n             // Current statement is not a push so visit inside\n             match &s.kind {\n-                StmtKind::Expr(expr) | StmtKind::Semi(expr) => self.visit_expr(&expr),\n+                StmtKind::Expr(expr) | StmtKind::Semi(expr) => self.visit_expr(expr),\n                 _ => {},\n             }\n         } else {"}, {"sha": "fc067e81bcafb7cd25b0817fc0f0e58106daae25", "filename": "clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -15,12 +15,12 @@ pub(super) fn check<'tcx>(\n     expr: &'tcx Expr<'_>,\n ) {\n     if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg_expr) = arg.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, arg_expr) = arg.kind;\n         if let PatKind::Binding(.., target, _) = pat.kind;\n         if let ExprKind::Array([arg_expression]) = arg_expr.kind;\n         if let ExprKind::Path(ref list_item) = arg_expression.kind;\n         if let Some(list_item_name) = single_segment_path(list_item).map(|ps| ps.ident.name);\n-        if let ExprKind::Block(ref block, _) = body.kind;\n+        if let ExprKind::Block(block, _) = body.kind;\n         if !block.stmts.is_empty();\n \n         then {"}, {"sha": "4db6644b9d705fb1a6f28f2e05549bc5c7f0cd0f", "filename": "clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Futils.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                 }\n \n                 match parent.kind {\n-                    ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+                    ExprKind::AssignOp(op, lhs, rhs) => {\n                         if lhs.hir_id == expr.hir_id {\n                             *state = if op.node == BinOpKind::Add\n                                 && is_integer_const(self.cx, rhs, 1)\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                             };\n                         }\n                     },\n-                    ExprKind::Assign(ref lhs, _, _) if lhs.hir_id == expr.hir_id => {\n+                    ExprKind::Assign(lhs, _, _) if lhs.hir_id == expr.hir_id => {\n                         *state = IncrementVisitorVarState::DontWarn\n                     },\n                     ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n         // Look for declarations of the variable\n         if_chain! {\n-            if let StmtKind::Local(ref local) = stmt.kind;\n+            if let StmtKind::Local(local) = stmt.kind;\n             if local.pat.hir_id == self.var_id;\n             if let PatKind::Binding(.., ident, _) = local.pat.kind;\n             then {\n@@ -191,10 +191,10 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n \n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n                 match parent.kind {\n-                    ExprKind::AssignOp(_, ref lhs, _) if lhs.hir_id == expr.hir_id => {\n+                    ExprKind::AssignOp(_, lhs, _) if lhs.hir_id == expr.hir_id => {\n                         self.state = InitializeVisitorState::DontWarn;\n                     },\n-                    ExprKind::Assign(ref lhs, ref rhs, _) if lhs.hir_id == expr.hir_id => {\n+                    ExprKind::Assign(lhs, rhs, _) if lhs.hir_id == expr.hir_id => {\n                         self.state = if_chain! {\n                             if self.depth == 0;\n                             if let InitializeVisitorState::Declared(name)\n@@ -273,7 +273,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n             return;\n         }\n         match expr.kind {\n-            ExprKind::Assign(ref path, _, _) | ExprKind::AssignOp(_, ref path, _) => {\n+            ExprKind::Assign(path, _, _) | ExprKind::AssignOp(_, path, _) => {\n                 if path_to_local_id(path, self.iterator) {\n                     self.nesting = RuledOut;\n                 }\n@@ -327,15 +327,15 @@ pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic\n         // (&mut x).into_iter() ==> x.iter_mut()\n         match &arg.kind {\n             ExprKind::AddrOf(BorrowKind::Ref, mutability, arg_inner)\n-                if has_iter_method(cx, cx.typeck_results().expr_ty(&arg_inner)).is_some() =>\n+                if has_iter_method(cx, cx.typeck_results().expr_ty(arg_inner)).is_some() =>\n             {\n                 let meth_name = match mutability {\n                     Mutability::Mut => \"iter_mut\",\n                     Mutability::Not => \"iter\",\n                 };\n                 format!(\n                     \"{}.{}()\",\n-                    sugg::Sugg::hir_with_applicability(cx, &arg_inner, \"_\", applic_ref).maybe_par(),\n+                    sugg::Sugg::hir_with_applicability(cx, arg_inner, \"_\", applic_ref).maybe_par(),\n                     meth_name,\n                 )\n             }"}, {"sha": "9c1720798529de1187bdddf8e47f7c02b0a09f23", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -11,14 +11,14 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'\n     let inner_stmt_expr = extract_expr_from_first_stmt(loop_block);\n     // or extract the first expression (if any) from the block\n     if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(loop_block)) {\n-        if let ExprKind::Match(ref matchexpr, ref arms, ref source) = inner.kind {\n+        if let ExprKind::Match(matchexpr, arms, ref source) = inner.kind {\n             // ensure \"if let\" compatible match structure\n             match *source {\n                 MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n                     if arms.len() == 2\n                         && arms[0].guard.is_none()\n                         && arms[1].guard.is_none()\n-                        && is_simple_break_expr(&arms[1].body)\n+                        && is_simple_break_expr(arms[1].body)\n                     {\n                         if in_external_macro(cx.sess(), expr.span) {\n                             return;\n@@ -57,7 +57,7 @@ fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<\n     if block.stmts.is_empty() {\n         return None;\n     }\n-    if let StmtKind::Local(ref local) = block.stmts[0].kind {\n+    if let StmtKind::Local(local) = block.stmts[0].kind {\n         local.init //.map(|expr| expr)\n     } else {\n         None\n@@ -67,9 +67,9 @@ fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<\n /// If a block begins with an expression (with or without semicolon), return it.\n fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     match block.expr {\n-        Some(ref expr) if block.stmts.is_empty() => Some(expr),\n+        Some(expr) if block.stmts.is_empty() => Some(expr),\n         None if !block.stmts.is_empty() => match block.stmts[0].kind {\n-            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => Some(expr),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => Some(expr),\n             StmtKind::Local(..) | StmtKind::Item(..) => None,\n         },\n         _ => None,\n@@ -82,7 +82,7 @@ fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n-        ExprKind::Block(ref b, _) => extract_first_expr(b).map_or(false, |subexpr| is_simple_break_expr(subexpr)),\n+        ExprKind::Block(b, _) => extract_first_expr(b).map_or(false, |subexpr| is_simple_break_expr(subexpr)),\n         _ => false,\n     }\n }"}, {"sha": "82715d9bafacca72c8e6317b992e7134b8ba7024", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -16,12 +16,10 @@ use rustc_middle::hir::map::Map;\n use rustc_span::symbol::sym;\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Match(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.kind {\n+    if let ExprKind::Match(match_expr, arms, MatchSource::WhileLetDesugar) = expr.kind {\n         let pat = &arms[0].pat.kind;\n-        if let (\n-            &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n-            &ExprKind::MethodCall(ref method_path, _, ref method_args, _),\n-        ) = (pat, &match_expr.kind)\n+        if let (&PatKind::TupleStruct(ref qpath, pat_args, _), &ExprKind::MethodCall(method_path, _, method_args, _)) =\n+            (pat, &match_expr.kind)\n         {\n             let iter_expr = &method_args[0];\n \n@@ -40,8 +38,8 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n                 && is_trait_method(cx, match_expr, sym::Iterator)\n                 && lhs_constructor.ident.name == sym::Some\n                 && (pat_args.is_empty()\n-                    || !is_refutable(cx, &pat_args[0])\n-                        && !is_used_inside(cx, iter_expr, &arms[0].body)\n+                    || !is_refutable(cx, pat_args[0])\n+                        && !is_used_inside(cx, iter_expr, arms[0].body)\n                         && !is_iterator_used_after_while_let(cx, iter_expr)\n                         && !is_nested(cx, expr, &method_args[0]))\n             {"}, {"sha": "dfa464ddb81ac4e1043cb17907b998092af7a5d5", "filename": "clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -91,7 +91,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n                 } else {\n                     return;\n                 };\n-                let target_res = cx.qpath_res(&target_path, target_arg.hir_id);\n+                let target_res = cx.qpath_res(target_path, target_arg.hir_id);\n                 if target_res == Res::Err {\n                     return;\n                 };\n@@ -174,7 +174,7 @@ fn eq_pattern_length<'tcx>(cx: &LateContext<'tcx>, pattern: &Expr<'_>, expr: &'t\n \n // Tests if `expr` is a `&str`.\n fn is_ref_str(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    match cx.typeck_results().expr_ty_adjusted(&expr).kind() {\n+    match cx.typeck_results().expr_ty_adjusted(expr).kind() {\n         ty::Ref(_, ty, _) => ty.is_str(),\n         _ => false,\n     }"}, {"sha": "99c35ae3bbf4c68393408490c906e8d5bb069a26", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n         }\n \n         if_chain! {\n-            if let hir::ExprKind::MethodCall(ref method, _, ref args, _) = e.kind;\n+            if let hir::ExprKind::MethodCall(method, _, args, _) = e.kind;\n             if args.len() == 2;\n             if method.ident.name == sym::map;\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n@@ -62,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                 let closure_body = cx.tcx.hir().body(body_id);\n                 let closure_expr = remove_blocks(&closure_body.value);\n                 match closure_body.params[0].pat.kind {\n-                    hir::PatKind::Ref(ref inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n+                    hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated, .., name, None\n                     ) = inner.kind {\n                         if ident_eq(name, closure_expr) {\n@@ -71,14 +71,14 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                     },\n                     hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n                         match closure_expr.kind {\n-                            hir::ExprKind::Unary(hir::UnOp::Deref, ref inner) => {\n+                            hir::ExprKind::Unary(hir::UnOp::Deref, inner) => {\n                                 if ident_eq(name, inner) {\n                                     if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind() {\n                                         lint(cx, e.span, args[0].span, true);\n                                     }\n                                 }\n                             },\n-                            hir::ExprKind::MethodCall(ref method, _, [obj], _) => if_chain! {\n+                            hir::ExprKind::MethodCall(method, _, [obj], _) => if_chain! {\n                                 if ident_eq(name, obj) && method.ident.name == sym::clone;\n                                 if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n                                 if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);\n@@ -109,7 +109,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n }\n \n fn ident_eq(name: Ident, path: &hir::Expr<'_>) -> bool {\n-    if let hir::ExprKind::Path(hir::QPath::Resolved(None, ref path)) = path.kind {\n+    if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = path.kind {\n         path.segments.len() == 1 && path.segments[0].ident == name\n     } else {\n         false"}, {"sha": "425a9734e5feeeaa1bd951df116e965eb0e401bb", "filename": "clippy_lints/src/map_err_ignore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_err_ignore.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> LateLintPass<'tcx> for MapErrIgnore {\n         }\n \n         // check if this is a method call (e.g. x.foo())\n-        if let ExprKind::MethodCall(ref method, _t_span, ref args, _) = e.kind {\n+        if let ExprKind::MethodCall(method, _t_span, args, _) = e.kind {\n             // only work if the method name is `map_err` and there are only 2 arguments (e.g. x.map_err(|_|[1]\n             // Enum::Variant[2]))\n             if method.ident.as_str() == \"map_err\" && args.len() == 2 {"}, {"sha": "e7719e7663d643737787a9846f2eb0bfade3296b", "filename": "clippy_lints/src/map_identity.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_identity.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for MapIdentity {\n /// map(). Otherwise, returns None.\n fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a [Expr<'a>]> {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n+        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n         if args.len() == 2 && method.ident.name == sym::map;\n         let caller_ty = cx.typeck_results().expr_ty(&args[0]);\n         if is_trait_method(cx, expr, sym::Iterator)\n@@ -80,7 +80,7 @@ fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a\n fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Closure(_, _, body_id, _, _) => is_body_identity_function(cx, cx.tcx.hir().body(body_id)),\n-        ExprKind::Path(QPath::Resolved(_, ref path)) => match_path(path, &paths::STD_CONVERT_IDENTITY),\n+        ExprKind::Path(QPath::Resolved(_, path)) => match_path(path, &paths::STD_CONVERT_IDENTITY),\n         _ => false,\n     }\n }\n@@ -99,12 +99,12 @@ fn is_body_identity_function(cx: &LateContext<'_>, func: &Body<'_>) -> bool {\n \n     match body.kind {\n         ExprKind::Path(QPath::Resolved(None, _)) => match_expr_param(cx, body, params[0].pat),\n-        ExprKind::Ret(Some(ref ret_val)) => match_expr_param(cx, ret_val, params[0].pat),\n-        ExprKind::Block(ref block, _) => {\n+        ExprKind::Ret(Some(ret_val)) => match_expr_param(cx, ret_val, params[0].pat),\n+        ExprKind::Block(block, _) => {\n             if_chain! {\n                 if block.stmts.len() == 1;\n-                if let StmtKind::Semi(ref expr) | StmtKind::Expr(ref expr) = block.stmts[0].kind;\n-                if let ExprKind::Ret(Some(ref ret_val)) = expr.kind;\n+                if let StmtKind::Semi(expr) | StmtKind::Expr(expr) = block.stmts[0].kind;\n+                if let ExprKind::Ret(Some(ret_val)) = expr.kind;\n                 then {\n                     match_expr_param(cx, ret_val, params[0].pat)\n                 } else {"}, {"sha": "57cd907e77e8da975a56773a5e357e0125de3394", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -133,7 +133,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) ->\n             // Calls can't be reduced any more\n             Some(expr.span)\n         },\n-        hir::ExprKind::Block(ref block, _) => {\n+        hir::ExprKind::Block(block, _) => {\n             match (block.stmts, block.expr.as_ref()) {\n                 (&[], Some(inner_expr)) => {\n                     // If block only contains an expression,\n@@ -144,8 +144,8 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) ->\n                     // If block only contains statements,\n                     // reduce `{ X; }` to `X` or `X;`\n                     match inner_stmt.kind {\n-                        hir::StmtKind::Local(ref local) => Some(local.span),\n-                        hir::StmtKind::Expr(ref e) => Some(e.span),\n+                        hir::StmtKind::Local(local) => Some(local.span),\n+                        hir::StmtKind::Expr(e) => Some(e.span),\n                         hir::StmtKind::Semi(..) => Some(inner_stmt.span),\n                         hir::StmtKind::Item(..) => None,\n                     }\n@@ -169,12 +169,12 @@ fn unit_closure<'tcx>(\n     expr: &hir::Expr<'_>,\n ) -> Option<(&'tcx hir::Param<'tcx>, &'tcx hir::Expr<'tcx>)> {\n     if_chain! {\n-        if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.kind;\n+        if let hir::ExprKind::Closure(_, decl, inner_expr_id, _, _) = expr.kind;\n         let body = cx.tcx.hir().body(inner_expr_id);\n         let body_expr = &body.value;\n         if decl.inputs.len() == 1;\n         if is_unit_expression(cx, body_expr);\n-        if let Some(binding) = iter_input_pats(&decl, body).next();\n+        if let Some(binding) = iter_input_pats(decl, body).next();\n         then {\n             return Some((binding, body_expr));\n         }\n@@ -267,7 +267,7 @@ impl<'tcx> LateLintPass<'tcx> for MapUnit {\n             return;\n         }\n \n-        if let hir::StmtKind::Semi(ref expr) = stmt.kind {\n+        if let hir::StmtKind::Semi(expr) = stmt.kind {\n             if let Some(arglists) = method_chain_args(expr, &[\"map\"]) {\n                 lint_map_unit_fn(cx, stmt, expr, arglists[0]);\n             }"}, {"sha": "ca6fb0831fe223879806e205b5b62226dde677be", "filename": "clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchOnVecItems {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if_chain! {\n             if !in_external_macro(cx.sess(), expr.span);\n-            if let ExprKind::Match(ref match_expr, _, MatchSource::Normal) = expr.kind;\n+            if let ExprKind::Match(match_expr, _, MatchSource::Normal) = expr.kind;\n             if let Some(idx_expr) = is_vec_indexing(cx, match_expr);\n             if let ExprKind::Index(vec, idx) = idx_expr.kind;\n \n@@ -78,7 +78,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchOnVecItems {\n \n fn is_vec_indexing<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n-        if let ExprKind::Index(ref array, ref index) = expr.kind;\n+        if let ExprKind::Index(array, index) = expr.kind;\n         if is_vector(cx, array);\n         if !is_full_range(cx, index);\n "}, {"sha": "a892e24482b943a3ddeaceaf6a2873d79ca1f520", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -589,7 +589,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             lint_match_arms(cx, expr);\n         }\n \n-        if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.kind {\n+        if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n             check_single_match(cx, ex, arms, expr);\n             check_match_bool(cx, ex, arms, expr);\n             check_overlapping_arms(cx, ex, arms);\n@@ -604,7 +604,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 check_match_single_binding(cx, ex, arms, expr);\n             }\n         }\n-        if let ExprKind::Match(ref ex, ref arms, _) = expr.kind {\n+        if let ExprKind::Match(ex, arms, _) = expr.kind {\n             check_match_ref_pats(cx, ex, arms, expr);\n         }\n     }\n@@ -613,14 +613,14 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         if_chain! {\n             if !in_external_macro(cx.sess(), local.span);\n             if !in_macro(local.span);\n-            if let Some(ref expr) = local.init;\n-            if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.kind;\n+            if let Some(expr) = local.init;\n+            if let ExprKind::Match(target, arms, MatchSource::Normal) = expr.kind;\n             if arms.len() == 1 && arms[0].guard.is_none();\n             if let PatKind::TupleStruct(\n-                QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pat.kind;\n+                QPath::Resolved(None, variant_name), args, _) = arms[0].pat.kind;\n             if args.len() == 1;\n-            if let PatKind::Binding(_, arg, ..) = strip_pat_refs(&args[0]).kind;\n-            let body = remove_blocks(&arms[0].body);\n+            if let PatKind::Binding(_, arg, ..) = strip_pat_refs(args[0]).kind;\n+            let body = remove_blocks(arms[0].body);\n             if path_to_local_id(body, arg);\n \n             then {\n@@ -649,7 +649,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         if_chain! {\n             if !in_external_macro(cx.sess(), pat.span);\n             if !in_macro(pat.span);\n-            if let PatKind::Struct(QPath::Resolved(_, ref path), fields, true) = pat.kind;\n+            if let PatKind::Struct(QPath::Resolved(_, path), fields, true) = pat.kind;\n             if let Some(def_id) = path.res.opt_def_id();\n             let ty = cx.tcx.type_of(def_id);\n             if let ty::Adt(def, _) = ty.kind();\n@@ -761,7 +761,7 @@ fn report_single_match_single_pattern(\n                 // PartialEq for different reference counts may not exist.\n                 \"&\".repeat(ref_count_diff),\n                 snippet(cx, arms[0].pat.span, \"..\"),\n-                expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n+                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n                 els_str,\n             );\n             (msg, sugg)\n@@ -771,7 +771,7 @@ fn report_single_match_single_pattern(\n                 \"if let {} = {} {}{}\",\n                 snippet(cx, arms[0].pat.span, \"..\"),\n                 snippet(cx, ex.span, \"..\"),\n-                expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n+                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n                 els_str,\n             );\n             (msg, sugg)\n@@ -809,7 +809,7 @@ fn check_single_match_opt_like(\n     ];\n \n     let path = match arms[1].pat.kind {\n-        PatKind::TupleStruct(ref path, ref inner, _) => {\n+        PatKind::TupleStruct(ref path, inner, _) => {\n             // Contains any non wildcard patterns (e.g., `Err(err)`)?\n             if !inner.iter().all(is_wild) {\n                 return;\n@@ -841,7 +841,7 @@ fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr:\n             move |diag| {\n                 if arms.len() == 2 {\n                     // no guards\n-                    let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pat.kind {\n+                    let exprs = if let PatKind::Lit(arm_bool) = arms[0].pat.kind {\n                         if let ExprKind::Lit(ref lit) = arm_bool.kind {\n                             match lit.node {\n                                 LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n@@ -917,7 +917,7 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n     let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n     if is_type_diagnostic_item(cx, ex_ty, sym::result_type) {\n         for arm in arms {\n-            if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.kind {\n+            if let PatKind::TupleStruct(ref path, inner, _) = arm.pat.kind {\n                 let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n                 if path_str == \"Err\" {\n                     let mut matching_wild = inner.iter().any(is_wild);\n@@ -937,7 +937,7 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n                     }\n                     if_chain! {\n                         if matching_wild;\n-                        if let ExprKind::Block(ref block, _) = arm.body.kind;\n+                        if let ExprKind::Block(block, _) = arm.body.kind;\n                         if is_panic_block(block);\n                         then {\n                             // `Err(_)` or `Err(_e)` arm with `panic!` found\n@@ -1143,9 +1143,7 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n // If the block contains only a `panic!` macro (as expression or statement)\n fn is_panic_block(block: &Block<'_>) -> bool {\n     match (&block.expr, block.stmts.len(), block.stmts.first()) {\n-        (&Some(ref exp), 0, _) => {\n-            is_expn_of(exp.span, \"panic\").is_some() && is_expn_of(exp.span, \"unreachable\").is_none()\n-        },\n+        (&Some(exp), 0, _) => is_expn_of(exp.span, \"panic\").is_some() && is_expn_of(exp.span, \"unreachable\").is_none(),\n         (&None, 1, Some(stmt)) => {\n             is_expn_of(stmt.span, \"panic\").is_some() && is_expn_of(stmt.span, \"unreachable\").is_none()\n         },\n@@ -1156,7 +1154,7 @@ fn is_panic_block(block: &Block<'_>) -> bool {\n fn check_match_ref_pats(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if has_only_ref_pats(arms) {\n         let mut suggs = Vec::with_capacity(arms.len() + 1);\n-        let (title, msg) = if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = ex.kind {\n+        let (title, msg) = if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n             let span = ex.span.source_callsite();\n             suggs.push((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n             (\n@@ -1173,7 +1171,7 @@ fn check_match_ref_pats(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], e\n         };\n \n         suggs.extend(arms.iter().filter_map(|a| {\n-            if let PatKind::Ref(ref refp, _) = a.pat.kind {\n+            if let PatKind::Ref(refp, _) = a.pat.kind {\n                 Some((a.pat.span, snippet(cx, refp.span, \"..\").to_string()))\n             } else {\n                 None\n@@ -1242,7 +1240,7 @@ fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n \n fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n     for arm in arms {\n-        if let PatKind::Or(ref fields) = arm.pat.kind {\n+        if let PatKind::Or(fields) = arm.pat.kind {\n             // look for multiple fields in this arm that contains at least one Wild pattern\n             if fields.len() > 1 && fields.iter().any(is_wild) {\n                 span_lint_and_help(\n@@ -1308,7 +1306,7 @@ fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr\n             // strip potential borrows (#6503), but only if the type is a reference\n             let mut ex_new = ex;\n             if let ExprKind::AddrOf(BorrowKind::Ref, .., ex_inner) = ex.kind {\n-                if let ty::Ref(..) = cx.typeck_results().expr_ty(&ex_inner).kind() {\n+                if let ty::Ref(..) = cx.typeck_results().expr_ty(ex_inner).kind() {\n                     ex_new = ex_inner;\n                 }\n             };\n@@ -1385,7 +1383,7 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n \n     let matched_vars = ex.span;\n     let bind_names = arms[0].pat.span;\n-    let match_body = remove_blocks(&arms[0].body);\n+    let match_body = remove_blocks(arms[0].body);\n     let mut snippet_body = if match_body.span.from_expansion() {\n         Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n     } else {\n@@ -1396,13 +1394,13 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n     match match_body.kind {\n         ExprKind::Block(block, _) => {\n             // macro + expr_ty(body) == ()\n-            if block.span.from_expansion() && cx.typeck_results().expr_ty(&match_body).is_unit() {\n+            if block.span.from_expansion() && cx.typeck_results().expr_ty(match_body).is_unit() {\n                 snippet_body.push(';');\n             }\n         },\n         _ => {\n             // expr_ty(body) == ()\n-            if cx.typeck_results().expr_ty(&match_body).is_unit() {\n+            if cx.typeck_results().expr_ty(match_body).is_unit() {\n                 snippet_body.push(';');\n             }\n         },\n@@ -1502,10 +1500,7 @@ fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'\n fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<Constant>> {\n     arms.iter()\n         .flat_map(|arm| {\n-            if let Arm {\n-                ref pat, guard: None, ..\n-            } = *arm\n-            {\n+            if let Arm { pat, guard: None, .. } = *arm {\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n                     let lhs = match lhs {\n                         Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n@@ -1525,7 +1520,7 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                     });\n                 }\n \n-                if let PatKind::Lit(ref value) = pat.kind {\n+                if let PatKind::Lit(value) = pat.kind {\n                     let value = constant(cx, cx.typeck_results(), value)?.0;\n                     return Some(SpannedRange {\n                         span: pat.span,\n@@ -1572,8 +1567,8 @@ fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n \n fn is_unit_expr(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n-        ExprKind::Tup(ref v) if v.is_empty() => true,\n-        ExprKind::Block(ref b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n+        ExprKind::Tup(v) if v.is_empty() => true,\n+        ExprKind::Block(b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n         _ => false,\n     }\n }\n@@ -1586,14 +1581,14 @@ fn is_none_arm(arm: &Arm<'_>) -> bool {\n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n fn is_ref_some_arm(arm: &Arm<'_>) -> Option<BindingAnnotation> {\n     if_chain! {\n-        if let PatKind::TupleStruct(ref path, ref pats, _) = arm.pat.kind;\n+        if let PatKind::TupleStruct(ref path, pats, _) = arm.pat.kind;\n         if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n         if let PatKind::Binding(rb, .., ident, _) = pats[0].kind;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n-        if let ExprKind::Call(ref e, ref args) = remove_blocks(&arm.body).kind;\n+        if let ExprKind::Call(e, args) = remove_blocks(arm.body).kind;\n         if let ExprKind::Path(ref some_path) = e.kind;\n         if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n-        if let ExprKind::Path(QPath::Resolved(_, ref path2)) = args[0].kind;\n+        if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {\n             return Some(rb)\n@@ -1685,7 +1680,7 @@ where\n             (&Kind::End(a, _), &Kind::Start(b, _)) if a != Bound::Included(b) => (),\n             _ => {\n                 // skip if the range `a` is completely included into the range `b`\n-                if let Ordering::Equal | Ordering::Less = a.cmp(&b) {\n+                if let Ordering::Equal | Ordering::Less = a.cmp(b) {\n                     let kind_a = Kind::End(a.range().node.1, a.range());\n                     let kind_b = Kind::End(b.range().node.1, b.range());\n                     if let Ordering::Equal | Ordering::Greater = kind_a.cmp(&kind_b) {\n@@ -1737,7 +1732,7 @@ mod redundant_pattern_match {\n             kind = &inner.kind;\n         }\n         let good_method = match kind {\n-            PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n+            PatKind::TupleStruct(ref path, patterns, _) if patterns.len() == 1 => {\n                 if let PatKind::Wild = patterns[0].kind {\n                     if match_qpath(path, &paths::RESULT_OK) {\n                         \"is_ok()\"\n@@ -1818,8 +1813,8 @@ mod redundant_pattern_match {\n \n             let found_good_method = match node_pair {\n                 (\n-                    PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n-                    PatKind::TupleStruct(ref path_right, ref patterns_right, _),\n+                    PatKind::TupleStruct(ref path_left, patterns_left, _),\n+                    PatKind::TupleStruct(ref path_right, patterns_right, _),\n                 ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n                     if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n                         find_good_method_for_match(\n@@ -1846,8 +1841,8 @@ mod redundant_pattern_match {\n                         None\n                     }\n                 },\n-                (PatKind::TupleStruct(ref path_left, ref patterns, _), PatKind::Path(ref path_right))\n-                | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, ref patterns, _))\n+                (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n+                | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n                     if patterns.len() == 1 =>\n                 {\n                     if let PatKind::Wild = patterns[0].kind {\n@@ -1969,10 +1964,10 @@ fn test_overlapping() {\n \n /// Implementation of `MATCH_SAME_ARMS`.\n fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n+    if let ExprKind::Match(_, arms, MatchSource::Normal) = expr.kind {\n         let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n             let mut h = SpanlessHash::new(cx);\n-            h.hash_expr(&arm.body);\n+            h.hash_expr(arm.body);\n             h.finish()\n         };\n \n@@ -2008,7 +2003,7 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n             (min_index..=max_index).all(|index| arms[index].guard.is_none())\n                 && SpanlessEq::new(cx)\n                     .expr_fallback(eq_fallback)\n-                    .eq_expr(&lhs.body, &rhs.body)\n+                    .eq_expr(lhs.body, rhs.body)\n                 // these checks could be removed to allow unused bindings\n                 && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n                 && bindings_eq(rhs.pat, local_map.values().copied().collect())"}, {"sha": "a735c616f6e416fdeb06e0b8d6232875252b7a80", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -34,7 +34,7 @@ declare_lint_pass!(MemDiscriminant => [MEM_DISCRIMINANT_NON_ENUM]);\n impl<'tcx> LateLintPass<'tcx> for MemDiscriminant {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n+            if let ExprKind::Call(func, func_args) = expr.kind;\n             // is `mem::discriminant`\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n             if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n@@ -59,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for MemDiscriminant {\n                             let mut derefs_needed = ptr_depth;\n                             let mut cur_expr = param;\n                             while derefs_needed > 0  {\n-                                if let ExprKind::AddrOf(BorrowKind::Ref, _, ref inner_expr) = cur_expr.kind {\n+                                if let ExprKind::AddrOf(BorrowKind::Ref, _, inner_expr) = cur_expr.kind {\n                                     derefs_needed -= 1;\n                                     cur_expr = inner_expr;\n                                 } else {"}, {"sha": "a28cb5f32fe8abe016001d8674d0a6e016a89a80", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -28,7 +28,7 @@ declare_lint_pass!(MemForget => [MEM_FORGET]);\n \n impl<'tcx> LateLintPass<'tcx> for MemForget {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Call(ref path_expr, ref args) = e.kind {\n+        if let ExprKind::Call(path_expr, args) = e.kind {\n             if let ExprKind::Path(ref qpath) = path_expr.kind {\n                 if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n                     if match_def_path(cx, def_id, &paths::MEM_FORGET) {"}, {"sha": "e1d351aee45479426fa299d54ec73f022e6a05ee", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -109,14 +109,14 @@ fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &E\n             // argument's type. All that's left is to get\n             // replacee's path.\n             let replaced_path = match dest.kind {\n-                ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, ref replaced) => {\n-                    if let ExprKind::Path(QPath::Resolved(None, ref replaced_path)) = replaced.kind {\n+                ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, replaced) => {\n+                    if let ExprKind::Path(QPath::Resolved(None, replaced_path)) = replaced.kind {\n                         replaced_path\n                     } else {\n                         return;\n                     }\n                 },\n-                ExprKind::Path(QPath::Resolved(None, ref replaced_path)) => replaced_path,\n+                ExprKind::Path(QPath::Resolved(None, replaced_path)) => replaced_path,\n                 _ => return,\n             };\n \n@@ -161,7 +161,7 @@ fn check_replace_with_uninit(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'\n     }\n \n     if_chain! {\n-        if let ExprKind::Call(ref repl_func, ref repl_args) = src.kind;\n+        if let ExprKind::Call(repl_func, repl_args) = src.kind;\n         if repl_args.is_empty();\n         if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n         if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n@@ -214,7 +214,7 @@ fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<\n         .iter()\n         .any(|symbol| is_diagnostic_assoc_item(cx, def_id, *symbol))\n     {\n-        if let QPath::TypeRelative(_, ref method) = path {\n+        if let QPath::TypeRelative(_, method) = path {\n             if method.ident.name == sym::new {\n                 return true;\n             }\n@@ -226,7 +226,7 @@ fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<\n \n fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n     if_chain! {\n-        if let ExprKind::Call(ref repl_func, _) = src.kind;\n+        if let ExprKind::Call(repl_func, _) = src.kind;\n         if !in_external_macro(cx.tcx.sess, expr_span);\n         if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n         if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n@@ -273,11 +273,11 @@ impl<'tcx> LateLintPass<'tcx> for MemReplace {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // Check that `expr` is a call to `mem::replace()`\n-            if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n+            if let ExprKind::Call(func, func_args) = expr.kind;\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n             if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::MEM_REPLACE);\n-            if let [dest, src] = &**func_args;\n+            if let [dest, src] = func_args;\n             then {\n                 check_replace_option_with_none(cx, src, dest, expr.span);\n                 check_replace_with_uninit(cx, src, dest, expr.span);"}, {"sha": "287bff886bfbf020663880d11fccd2546ed34421", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -71,7 +71,7 @@ pub(crate) trait BindInsteadOfMap {\n         closure_args_span: Span,\n     ) -> bool {\n         if_chain! {\n-            if let hir::ExprKind::Call(ref some_expr, [inner_expr]) = closure_expr.kind;\n+            if let hir::ExprKind::Call(some_expr, [inner_expr]) = closure_expr.kind;\n             if let hir::ExprKind::Path(QPath::Resolved(_, path)) = some_expr.kind;\n             if Self::is_variant(cx, path.res);\n             if !contains_return(inner_expr);\n@@ -107,7 +107,7 @@ pub(crate) trait BindInsteadOfMap {\n         let can_sugg: bool = find_all_ret_expressions(cx, closure_expr, |ret_expr| {\n             if_chain! {\n                 if !in_macro(ret_expr.span);\n-                if let hir::ExprKind::Call(ref func_path, [arg]) = ret_expr.kind;\n+                if let hir::ExprKind::Call(func_path, [arg]) = ret_expr.kind;\n                 if let hir::ExprKind::Path(QPath::Resolved(_, path)) = func_path.kind;\n                 if Self::is_variant(cx, path.res);\n                 if !contains_return(arg);"}, {"sha": "514c411876551150478608f8f4756d0ecb5074ef", "filename": "clippy_lints/src/methods/chars_cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -19,7 +19,7 @@ pub(super) fn check(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprKind::Call(ref fun, ref arg_char) = info.other.kind;\n+        if let hir::ExprKind::Call(fun, arg_char) = info.other.kind;\n         if arg_char.len() == 1;\n         if let hir::ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(segment) = single_segment_path(qpath);"}, {"sha": "03cb41697d509dd46717ed6d1a1c43094749f605", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -100,9 +100,9 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Spa\n         applicability: &mut Applicability,\n     ) -> Vec<String> {\n         if_chain! {\n-            if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref format_arg) = a.kind;\n-            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.kind;\n-            if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.kind;\n+            if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, format_arg) = a.kind;\n+            if let hir::ExprKind::Match(format_arg_expr, _, _) = format_arg.kind;\n+            if let hir::ExprKind::Tup(format_arg_expr_tup) = format_arg_expr.kind;\n \n             then {\n                 format_arg_expr_tup\n@@ -155,7 +155,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Spa\n         if block.stmts.len() == 1;\n         if let hir::StmtKind::Local(local) = &block.stmts[0].kind;\n         if let Some(arg_root) = &local.init;\n-        if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg_root.kind;\n+        if let hir::ExprKind::Call(inner_fun, inner_args) = arg_root.kind;\n         if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1;\n         if let hir::ExprKind::Call(_, format_args) = &inner_args[0].kind;\n         then {"}, {"sha": "35fae450eeb93177612141992e50a89ca5815bc1", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -19,7 +19,7 @@ use super::OPTION_FILTER_MAP;\n \n fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Symbol) -> bool {\n     match &expr.kind {\n-        hir::ExprKind::Path(QPath::TypeRelative(_, ref mname)) => mname.ident.name == method_name,\n+        hir::ExprKind::Path(QPath::TypeRelative(_, mname)) => mname.ident.name == method_name,\n         hir::ExprKind::Path(QPath::Resolved(_, segments)) => {\n             segments.segments.last().unwrap().ident.name == method_name\n         },\n@@ -28,7 +28,7 @@ fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n             let closure_expr = remove_blocks(&body.value);\n             let arg_id = body.params[0].pat.hir_id;\n             match closure_expr.kind {\n-                hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, _, ref args, _) => {\n+                hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, _, args, _) => {\n                     if_chain! {\n                     if ident.name == method_name;\n                     if let hir::ExprKind::Path(path) = &args[0].kind;\n@@ -61,7 +61,7 @@ fn lint_filter_some_map_unwrap(\n     methods_span: Span,\n ) {\n     let iterator = is_trait_method(cx, expr, sym::Iterator);\n-    let option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&filter_recv), sym::option_type);\n+    let option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(filter_recv), sym::option_type);\n     if (iterator || option) && is_option_filter_map(cx, filter_arg, map_arg) {\n         let msg = \"`filter` for `Some` followed by `unwrap`\";\n         let help = \"consider using `flatten` instead\";"}, {"sha": "dd613d0cd6384f827c311c580beab208091cb273", "filename": "clippy_lints/src/methods/flat_map_identity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -35,7 +35,7 @@ pub(super) fn check<'tcx>(\n             let body = cx.tcx.hir().body(*body_id);\n \n             if let hir::PatKind::Binding(_, _, binding_ident, _) = body.params[0].pat.kind;\n-            if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = body.value.kind;\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = body.value.kind;\n \n             if path.segments.len() == 1;\n             if path.segments[0].ident.name == binding_ident.name;"}, {"sha": "1211e2f2bf7cb23105c687a05c208d3bdf8f33eb", "filename": "clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -13,7 +13,7 @@ use clippy_utils::is_diagnostic_assoc_item;\n pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, trait_diagnostic: Symbol) {\n     if_chain! {\n         if let ExprKind::MethodCall(method_path, _, [arg], _) = &expr.kind;\n-        let return_type = cx.typeck_results().expr_ty(&expr);\n+        let return_type = cx.typeck_results().expr_ty(expr);\n         let input_type = cx.typeck_results().expr_ty(arg).peel_refs();\n         if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(ty_name) = input_type.ty_adt_def().map(|adt_def| cx.tcx.item_name(adt_def.did));"}, {"sha": "a49851de38e1eec3e13fdfda8da0e815fc465687", "filename": "clippy_lints/src/methods/iter_next_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -27,7 +27,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, cal\n     if derefs_to_slice(cx, caller_expr, cx.typeck_results().expr_ty(caller_expr)).is_some() {\n         // caller is a Slice\n         if_chain! {\n-            if let hir::ExprKind::Index(ref caller_var, ref index_expr) = &caller_expr.kind;\n+            if let hir::ExprKind::Index(caller_var, index_expr) = &caller_expr.kind;\n             if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n                 = higher::range(index_expr);\n             if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;"}, {"sha": "b1ade5addd6aa089e36707a7960d76860a9a09a3", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -1740,10 +1740,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         check_methods(cx, expr, self.msrv.as_ref());\n \n         match expr.kind {\n-            hir::ExprKind::Call(ref func, ref args) => {\n+            hir::ExprKind::Call(func, args) => {\n                 from_iter_instead_of_collect::check(cx, expr, args, &func.kind);\n             },\n-            hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args, _) => {\n+            hir::ExprKind::MethodCall(method_call, ref method_span, args, _) => {\n                 or_fun_call::check(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 expect_fun_call::check(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 clone_on_copy::check(cx, expr, method_call.ident.name, args);\n@@ -1753,17 +1753,15 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 into_iter_on_ref::check(cx, expr, *method_span, method_call.ident.name, args);\n                 single_char_pattern::check(cx, expr, method_call.ident.name, args);\n             },\n-            hir::ExprKind::Binary(op, ref lhs, ref rhs)\n-                if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne =>\n-            {\n+            hir::ExprKind::Binary(op, lhs, rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n                 let mut info = BinaryExprInfo {\n                     expr,\n                     chain: lhs,\n                     other: rhs,\n                     eq: op.node == hir::BinOpKind::Eq,\n                 };\n                 lint_binary_expr_with_method_call(cx, &mut info);\n-            }\n+            },\n             _ => (),\n         }\n     }\n@@ -1781,7 +1779,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         let implements_trait = matches!(item.kind, hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }));\n         if_chain! {\n             if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind;\n-            if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n+            if let Some(first_arg) = iter_input_pats(sig.decl, cx.tcx.hir().body(id)).next();\n \n             let method_sig = cx.tcx.fn_sig(impl_item.def_id);\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n@@ -1801,7 +1799,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                             method_config.output_type.matches(&sig.decl.output) &&\n                             method_config.self_kind.matches(cx, self_ty, first_arg_ty) &&\n                             fn_header_equals(method_config.fn_header, sig.header) &&\n-                            method_config.lifetime_param_cond(&impl_item)\n+                            method_config.lifetime_param_cond(impl_item)\n                         {\n                             span_lint_and_help(\n                                 cx,\n@@ -2272,10 +2270,10 @@ impl OutType {\n         let is_unit = |ty: &hir::Ty<'_>| matches!(ty.kind, hir::TyKind::Tup(&[]));\n         match (self, ty) {\n             (Self::Unit, &hir::FnRetTy::DefaultReturn(_)) => true,\n-            (Self::Unit, &hir::FnRetTy::Return(ref ty)) if is_unit(ty) => true,\n-            (Self::Bool, &hir::FnRetTy::Return(ref ty)) if is_bool(ty) => true,\n-            (Self::Any, &hir::FnRetTy::Return(ref ty)) if !is_unit(ty) => true,\n-            (Self::Ref, &hir::FnRetTy::Return(ref ty)) => matches!(ty.kind, hir::TyKind::Rptr(_, _)),\n+            (Self::Unit, &hir::FnRetTy::Return(ty)) if is_unit(ty) => true,\n+            (Self::Bool, &hir::FnRetTy::Return(ty)) if is_bool(ty) => true,\n+            (Self::Any, &hir::FnRetTy::Return(ty)) if !is_unit(ty) => true,\n+            (Self::Ref, &hir::FnRetTy::Return(ty)) => matches!(ty.kind, hir::TyKind::Rptr(_, _)),\n             _ => false,\n         }\n     }"}, {"sha": "7e9c8fa829decd77f9feb3ce6b1b5fe66ae30955", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -77,10 +77,10 @@ pub(super) fn check<'tcx>(\n                         }\n                     }\n                 },\n-                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref inner) if same_mutability(m) => {\n+                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, inner) if same_mutability(m) => {\n                     if_chain! {\n-                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner1) = inner.kind;\n-                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner2) = inner1.kind;\n+                        if let hir::ExprKind::Unary(hir::UnOp::Deref, inner1) = inner.kind;\n+                        if let hir::ExprKind::Unary(hir::UnOp::Deref, inner2) = inner1.kind;\n                         then {\n                             path_to_local_id(inner2, closure_body.params[0].pat.hir_id)\n                         } else {"}, {"sha": "df89da5d3e00e4a8ad44db3afb17fc481b21f2b3", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -86,7 +86,7 @@ pub(super) fn check<'tcx>(\n             (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n         ];\n \n-        if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n+        if let hir::ExprKind::MethodCall(path, _, args, _) = &arg.kind {\n             if path.ident.as_str() == \"len\" {\n                 let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n \n@@ -105,7 +105,7 @@ pub(super) fn check<'tcx>(\n             if KNOW_TYPES.iter().any(|k| k.2.contains(&name));\n \n             if is_lazyness_candidate(cx, arg);\n-            if !contains_return(&arg);\n+            if !contains_return(arg);\n \n             let self_ty = cx.typeck_results().expr_ty(self_expr);\n \n@@ -158,7 +158,7 @@ pub(super) fn check<'tcx>(\n \n     if args.len() == 2 {\n         match args[1].kind {\n-            hir::ExprKind::Call(ref fun, ref or_args) => {\n+            hir::ExprKind::Call(fun, or_args) => {\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n                     let fun_span = if or_has_args { None } else { Some(fun.span) };"}, {"sha": "ecec6fc3bb7fa6b4742bed27dcfa3ce22597e93d", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -45,7 +45,7 @@ pub(super) fn check<'tcx>(\n                 then {\n                     if let hir::PatKind::Ref(..) = closure_arg.pat.kind {\n                         Some(search_snippet.replacen('&', \"\", 1))\n-                    } else if let PatKind::Binding(_, _, ident, _) = strip_pat_refs(&closure_arg.pat).kind {\n+                    } else if let PatKind::Binding(_, _, ident, _) = strip_pat_refs(closure_arg.pat).kind {\n                         let name = &*ident.name.as_str();\n                         Some(search_snippet.replace(&format!(\"*{}\", name), name))\n                     } else {\n@@ -108,8 +108,8 @@ pub(super) fn check<'tcx>(\n             }\n         };\n         if_chain! {\n-            if is_string_or_str_slice(&search_recv);\n-            if is_string_or_str_slice(&search_arg);\n+            if is_string_or_str_slice(search_recv);\n+            if is_string_or_str_slice(search_arg);\n             then {\n                 let msg = format!(\"called `{}()` after calling `find()` on a string\", option_check_method);\n                 match option_check_method {"}, {"sha": "0ae65c0c01dba0e06c429fc776362bc9be4e9db6", "filename": "clippy_lints/src/methods/uninit_assumed_init.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -10,7 +10,7 @@ use super::UNINIT_ASSUMED_INIT;\n /// lint for `MaybeUninit::uninit().assume_init()` (we already have the latter)\n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     if_chain! {\n-        if let hir::ExprKind::Call(ref callee, ref args) = recv.kind;\n+        if let hir::ExprKind::Call(callee, args) = recv.kind;\n         if args.is_empty();\n         if let hir::ExprKind::Path(ref path) = callee.kind;\n         if match_qpath(path, &paths::MEM_MAYBEUNINIT_UNINIT);\n@@ -28,9 +28,9 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n \n fn is_maybe_uninit_ty_valid(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     match ty.kind() {\n-        ty::Array(ref component, _) => is_maybe_uninit_ty_valid(cx, component),\n-        ty::Tuple(ref types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n-        ty::Adt(ref adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n+        ty::Array(component, _) => is_maybe_uninit_ty_valid(cx, component),\n+        ty::Tuple(types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n+        ty::Adt(adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n         _ => false,\n     }\n }"}, {"sha": "0f28bfdf09e89c3be43a26fe34925201a966b03c", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -20,9 +20,9 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         let mutates_arg =\n             mutated_variables(&body.value, cx).map_or(true, |used_mutably| used_mutably.contains(&arg_id));\n \n-        let (mut found_mapping, mut found_filtering) = check_expression(&cx, arg_id, &body.value);\n+        let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, &body.value);\n \n-        let mut return_visitor = ReturnVisitor::new(&cx, arg_id);\n+        let mut return_visitor = ReturnVisitor::new(cx, arg_id);\n         return_visitor.visit_expr(&body.value);\n         found_mapping |= return_visitor.found_mapping;\n         found_filtering |= return_visitor.found_filtering;\n@@ -52,7 +52,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n // returns (found_mapping, found_filtering)\n fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> (bool, bool) {\n     match &expr.kind {\n-        hir::ExprKind::Call(ref func, ref args) => {\n+        hir::ExprKind::Call(func, args) => {\n             if let hir::ExprKind::Path(ref path) = func.kind {\n                 if match_qpath(path, &paths::OPTION_SOME) {\n                     if path_to_local_id(&args[0], arg_id) {\n@@ -65,22 +65,22 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n             }\n             (true, true)\n         },\n-        hir::ExprKind::Block(ref block, _) => block\n+        hir::ExprKind::Block(block, _) => block\n             .expr\n             .as_ref()\n-            .map_or((false, false), |expr| check_expression(cx, arg_id, &expr)),\n+            .map_or((false, false), |expr| check_expression(cx, arg_id, expr)),\n         hir::ExprKind::Match(_, arms, _) => {\n             let mut found_mapping = false;\n             let mut found_filtering = false;\n             for arm in *arms {\n-                let (m, f) = check_expression(cx, arg_id, &arm.body);\n+                let (m, f) = check_expression(cx, arg_id, arm.body);\n                 found_mapping |= m;\n                 found_filtering |= f;\n             }\n             (found_mapping, found_filtering)\n         },\n         // There must be an else_arm or there will be a type error\n-        hir::ExprKind::If(_, ref if_arm, Some(ref else_arm)) => {\n+        hir::ExprKind::If(_, if_arm, Some(else_arm)) => {\n             let if_check = check_expression(cx, arg_id, if_arm);\n             let else_check = check_expression(cx, arg_id, else_arm);\n             (if_check.0 | else_check.0, if_check.1 | else_check.1)"}, {"sha": "75517c48a21c90efdcf80bed24239cf6cf14830d", "filename": "clippy_lints/src/methods/unnecessary_fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -34,13 +34,13 @@ pub(super) fn check(\n             let closure_expr = remove_blocks(&closure_body.value);\n \n             // Check if the closure body is of the form `acc <op> some_expr(x)`\n-            if let hir::ExprKind::Binary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.kind;\n+            if let hir::ExprKind::Binary(ref bin_op, left_expr, right_expr) = closure_expr.kind;\n             if bin_op.node == op;\n \n             // Extract the names of the two arguments to the closure\n             if let [param_a, param_b] = closure_body.params;\n-            if let PatKind::Binding(_, first_arg_id, ..) = strip_pat_refs(&param_a.pat).kind;\n-            if let PatKind::Binding(_, second_arg_id, second_arg_ident, _) = strip_pat_refs(&param_b.pat).kind;\n+            if let PatKind::Binding(_, first_arg_id, ..) = strip_pat_refs(param_a.pat).kind;\n+            if let PatKind::Binding(_, second_arg_id, second_arg_ident, _) = strip_pat_refs(param_b.pat).kind;\n \n             if path_to_local_id(left_expr, first_arg_id);\n             if replacement_has_args || path_to_local_id(right_expr, second_arg_id);"}, {"sha": "f6bf37e08b96614007217d910fe0778d3c8ffa6b", "filename": "clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -26,7 +26,7 @@ pub(super) fn derefs_to_slice<'tcx>(\n         }\n     }\n \n-    if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n+    if let hir::ExprKind::MethodCall(path, _, args, _) = expr.kind {\n         if path.ident.name == sym::iter && may_slice(cx, cx.typeck_results().expr_ty(&args[0])) {\n             Some(&args[0])\n         } else {"}, {"sha": "866cf616679c29a0d5adf02572ca971f43fbb41d", "filename": "clippy_lints/src/methods/zst_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -8,7 +8,7 @@ use super::ZST_OFFSET;\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     if_chain! {\n-        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.typeck_results().expr_ty(recv).kind();\n+        if let ty::RawPtr(ty::TypeAndMut { ty, .. }) = cx.typeck_results().expr_ty(recv).kind();\n         if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n         if layout.is_zst();\n         then {"}, {"sha": "45948f4d926bc6efe292203c932c2adfda9d83ca", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -67,7 +67,7 @@ enum MinMax {\n \n fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n     match expr.kind {\n-        ExprKind::Call(ref path, ref args) => {\n+        ExprKind::Call(path, args) => {\n             if let ExprKind::Path(ref qpath) = path.kind {\n                 cx.typeck_results()\n                     .qpath_res(qpath, path.hir_id)\n@@ -85,7 +85,7 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n                 None\n             }\n         },\n-        ExprKind::MethodCall(ref path, _, ref args, _) => {\n+        ExprKind::MethodCall(path, _, args, _) => {\n             if_chain! {\n                 if let [obj, _] = args;\n                 if cx.typeck_results().expr_ty(obj).is_floating_point() || match_trait_method(cx, expr, &paths::ORD);"}, {"sha": "afced5a5ce58a246ad38591d9a74f3e326fc4867", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -304,9 +304,9 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if_chain! {\n             if !in_external_macro(cx.tcx.sess, stmt.span);\n-            if let StmtKind::Local(ref local) = stmt.kind;\n+            if let StmtKind::Local(local) = stmt.kind;\n             if let PatKind::Binding(an, .., name, None) = local.pat.kind;\n-            if let Some(ref init) = local.init;\n+            if let Some(init) = local.init;\n             if !higher::is_from_for_desugar(local);\n             if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut;\n             then {\n@@ -322,7 +322,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                 } else {\n                     (\"\", sugg_init.addr())\n                 };\n-                let tyopt = if let Some(ref ty) = local.ty {\n+                let tyopt = if let Some(ty) = local.ty {\n                     format!(\": &{mutopt}{ty}\", mutopt=mutopt, ty=snippet(cx, ty.span, \"..\"))\n                 } else {\n                     String::new()\n@@ -350,8 +350,8 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             }\n         };\n         if_chain! {\n-            if let StmtKind::Semi(ref expr) = stmt.kind;\n-            if let ExprKind::Binary(ref binop, ref a, ref b) = expr.kind;\n+            if let StmtKind::Semi(expr) = stmt.kind;\n+            if let ExprKind::Binary(ref binop, a, b) = expr.kind;\n             if binop.node == BinOpKind::And || binop.node == BinOpKind::Or;\n             if let Some(sugg) = Sugg::hir_opt(cx, a);\n             then {\n@@ -378,11 +378,11 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         match expr.kind {\n-            ExprKind::Cast(ref e, ref ty) => {\n+            ExprKind::Cast(e, ty) => {\n                 check_cast(cx, expr.span, e, ty);\n                 return;\n             },\n-            ExprKind::Binary(ref cmp, ref left, ref right) => {\n+            ExprKind::Binary(ref cmp, left, right) => {\n                 check_binary(cx, expr, cmp, left, right);\n                 return;\n             },\n@@ -501,12 +501,12 @@ fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n // Return true if `expr` is the result of `signum()` invoked on a float value.\n fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     // The negation of a signum is still a signum\n-    if let ExprKind::Unary(UnOp::Neg, ref child_expr) = expr.kind {\n-        return is_signum(cx, &child_expr);\n+    if let ExprKind::Unary(UnOp::Neg, child_expr) = expr.kind {\n+        return is_signum(cx, child_expr);\n     }\n \n     if_chain! {\n-        if let ExprKind::MethodCall(ref method_name, _, ref expressions, _) = expr.kind;\n+        if let ExprKind::MethodCall(method_name, _, expressions, _) = expr.kind;\n         if sym!(signum) == method_name.ident.name;\n         // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n         // the method call)\n@@ -552,7 +552,7 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n     }\n \n     let (arg_ty, snip) = match expr.kind {\n-        ExprKind::MethodCall(.., ref args, _) if args.len() == 1 => {\n+        ExprKind::MethodCall(.., args, _) if args.len() == 1 => {\n             if_chain!(\n                 if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n                 if is_diagnostic_assoc_item(cx, expr_def_id, sym::ToString)\n@@ -564,7 +564,7 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n                 }\n             )\n         },\n-        ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n+        ExprKind::Call(path, v) if v.len() == 1 => {\n             if let ExprKind::Path(ref path) = path.kind {\n                 if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n                     (cx.typeck_results().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n@@ -649,7 +649,7 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n /// of what it means for an expression to be \"used\".\n fn is_used(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     get_parent_expr(cx, expr).map_or(true, |parent| match parent.kind {\n-        ExprKind::Assign(_, ref rhs, _) | ExprKind::AssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n+        ExprKind::Assign(_, rhs, _) | ExprKind::AssignOp(_, _, rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n         _ => is_used(cx, parent),\n     })\n }"}, {"sha": "0dc02431ad5383141ebfbe54c140330f2d1f9c36", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -138,7 +138,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n \n         let mir = cx.tcx.optimized_mir(def_id);\n \n-        if let Err((span, err)) = is_min_const_fn(cx.tcx, &mir) {\n+        if let Err((span, err)) = is_min_const_fn(cx.tcx, mir) {\n             if rustc_mir::const_eval::is_min_const_fn(cx.tcx, def_id.to_def_id()) {\n                 cx.tcx.sess.span_err(span, &err);\n             }"}, {"sha": "041fe64a1a9785a77e30d1f68dc82505dd92d2cf", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n                 let attrs = cx.tcx.hir().attrs(it.hir_id());\n                 check_missing_inline_attrs(cx, attrs, it.span, desc);\n             },\n-            hir::ItemKind::Trait(ref _is_auto, ref _unsafe, ref _generics, ref _bounds, trait_items) => {\n+            hir::ItemKind::Trait(ref _is_auto, ref _unsafe, ref _generics, _bounds, trait_items) => {\n                 // note: we need to check if the trait is exported so we can't use\n                 // `LateLintPass::check_trait_item` here.\n                 for tit in trait_items {"}, {"sha": "ed7b9cd62dcb9fc114b3bf59e7b3c6752c2b632b", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -58,21 +58,21 @@ declare_lint_pass!(MutableKeyType => [ MUTABLE_KEY_TYPE ]);\n impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         if let hir::ItemKind::Fn(ref sig, ..) = item.kind {\n-            check_sig(cx, item.hir_id(), &sig.decl);\n+            check_sig(cx, item.hir_id(), sig.decl);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'tcx>) {\n         if let hir::ImplItemKind::Fn(ref sig, ..) = item.kind {\n             if trait_ref_of_method(cx, item.hir_id()).is_none() {\n-                check_sig(cx, item.hir_id(), &sig.decl);\n+                check_sig(cx, item.hir_id(), sig.decl);\n             }\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'tcx>) {\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n-            check_sig(cx, item.hir_id(), &sig.decl);\n+            check_sig(cx, item.hir_id(), sig.decl);\n         }\n     }\n "}, {"sha": "4b9c51d0c16ccbb3bad95282c25eded9feb57fd6", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             // Let's ignore the generated code.\n             intravisit::walk_expr(self, arg);\n             intravisit::walk_expr(self, body);\n-        } else if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, ref e) = expr.kind {\n+        } else if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e) = expr.kind {\n             if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, _) = e.kind {\n                 span_lint(\n                     self.cx,\n@@ -85,7 +85,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n         if let hir::TyKind::Rptr(\n             _,\n             hir::MutTy {\n-                ty: ref pty,\n+                ty: pty,\n                 mutbl: hir::Mutability::Mut,\n             },\n         ) = ty.kind"}, {"sha": "b85cc4b95482300c3800f08e54602c32a86e2b27", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -32,7 +32,7 @@ declare_lint_pass!(UnnecessaryMutPassed => [UNNECESSARY_MUT_PASSED]);\n impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         match e.kind {\n-            ExprKind::Call(ref fn_expr, ref arguments) => {\n+            ExprKind::Call(fn_expr, arguments) => {\n                 if let ExprKind::Path(ref path) = fn_expr.kind {\n                     check_arguments(\n                         cx,\n@@ -43,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n                     );\n                 }\n             },\n-            ExprKind::MethodCall(ref path, _, ref arguments, _) => {\n+            ExprKind::MethodCall(path, _, arguments, _) => {\n                 let def_id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n                 let substs = cx.typeck_results().node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);"}, {"sha": "96a58d1410f226b01058fd56dc9ecbbb6ca9bba2", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -71,7 +71,7 @@ declare_lint_pass!(NeedlessBool => [NEEDLESS_BOOL]);\n impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         use self::Expression::{Bool, RetBool};\n-        if let ExprKind::If(ref pred, ref then_block, Some(ref else_expr)) = e.kind {\n+        if let ExprKind::If(pred, then_block, Some(else_expr)) = e.kind {\n             let reduce = |ret, not| {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let snip = Sugg::hir_with_applicability(cx, pred, \"<predicate>\", &mut applicability);\n@@ -81,7 +81,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     snip = snip.make_return();\n                 }\n \n-                if parent_node_is_if_expr(&e, &cx) {\n+                if parent_node_is_if_expr(e, cx) {\n                     snip = snip.blockify()\n                 }\n \n@@ -95,7 +95,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     applicability,\n                 );\n             };\n-            if let ExprKind::Block(ref then_block, _) = then_block.kind {\n+            if let ExprKind::Block(then_block, _) = then_block.kind {\n                 match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                     (RetBool(true), RetBool(true)) | (Bool(true), Bool(true)) => {\n                         span_lint(\n@@ -225,7 +225,7 @@ fn check_comparison<'a, 'tcx>(\n ) {\n     use self::Expression::{Bool, Other};\n \n-    if let ExprKind::Binary(op, ref left_side, ref right_side) = e.kind {\n+    if let ExprKind::Binary(op, left_side, right_side) = e.kind {\n         let (l_ty, r_ty) = (\n             cx.typeck_results().expr_ty(left_side),\n             cx.typeck_results().expr_ty(right_side),\n@@ -237,7 +237,7 @@ fn check_comparison<'a, 'tcx>(\n             let mut applicability = Applicability::MachineApplicable;\n \n             if let BinOpKind::Eq = op.node {\n-                let expression_info = one_side_is_unary_not(&left_side, &right_side);\n+                let expression_info = one_side_is_unary_not(left_side, right_side);\n                 if expression_info.one_side_is_unary_not {\n                     span_lint_and_sugg(\n                         cx,\n@@ -324,9 +324,9 @@ fn fetch_bool_block(block: &Block<'_>) -> Expression {\n     match (&*block.stmts, block.expr.as_ref()) {\n         (&[], Some(e)) => fetch_bool_expr(&**e),\n         (&[ref e], None) => {\n-            if let StmtKind::Semi(ref e) = e.kind {\n+            if let StmtKind::Semi(e) = e.kind {\n                 if let ExprKind::Ret(_) = e.kind {\n-                    fetch_bool_expr(&**e)\n+                    fetch_bool_expr(e)\n                 } else {\n                     Expression::Other\n                 }\n@@ -340,15 +340,15 @@ fn fetch_bool_block(block: &Block<'_>) -> Expression {\n \n fn fetch_bool_expr(expr: &Expr<'_>) -> Expression {\n     match expr.kind {\n-        ExprKind::Block(ref block, _) => fetch_bool_block(block),\n+        ExprKind::Block(block, _) => fetch_bool_block(block),\n         ExprKind::Lit(ref lit_ptr) => {\n             if let LitKind::Bool(value) = lit_ptr.node {\n                 Expression::Bool(value)\n             } else {\n                 Expression::Other\n             }\n         },\n-        ExprKind::Ret(Some(ref expr)) => match fetch_bool_expr(expr) {\n+        ExprKind::Ret(Some(expr)) => match fetch_bool_expr(expr) {\n             Expression::Bool(value) => Expression::RetBool(value),\n             _ => Expression::Other,\n         },"}, {"sha": "eef3c16730b133baea1e05f498728e7b3a7bb1ac", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n         if e.span.from_expansion() || self.derived_item.is_some() {\n             return;\n         }\n-        if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = e.kind {\n+        if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = e.kind {\n             if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty(inner).kind() {\n                 for adj3 in cx.typeck_results().expr_adjustments(e).windows(3) {\n                     if let [Adjustment {"}, {"sha": "0e976b130ebf14f6334a6b1c3eca8ad0bcc1261a", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n \n         if_chain! {\n             // Only lint immutable refs, because `&mut ref T` may be useful.\n-            if let PatKind::Ref(ref sub_pat, Mutability::Not) = pat.kind;\n+            if let PatKind::Ref(sub_pat, Mutability::Not) = pat.kind;\n \n             // Check sub_pat got a `ref` keyword (excluding `ref mut`).\n             if let PatKind::Binding(BindingAnnotation::Ref, .., spanned_name, _) = sub_pat.kind;"}, {"sha": "079b6642d5833c66f242172d32a4c07053d6721a", "filename": "clippy_lints/src/needless_for_each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -70,7 +70,7 @@ impl LateLintPass<'_> for NeedlessForEach {\n                 ExprKind::Array(..) | ExprKind::Call(..) | ExprKind::Path(..)\n             );\n             // Checks the type of the `iter` method receiver is NOT a user defined type.\n-            if has_iter_method(cx, cx.typeck_results().expr_ty(&iter_recv)).is_some();\n+            if has_iter_method(cx, cx.typeck_results().expr_ty(iter_recv)).is_some();\n             // Skip the lint if the body is not block because this is simpler than `for` loop.\n             // e.g. `v.iter().for_each(f)` is simpler and clearer than using `for` loop.\n             if let ExprKind::Closure(_, _, body_id, ..) = for_each_arg.kind;"}, {"sha": "780e224129347492b47447beaf512dba264affa5", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -208,7 +208,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                             if is_type_diagnostic_item(cx, ty, sym::vec_type);\n                             if let Some(clone_spans) =\n                                 get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]);\n-                            if let TyKind::Path(QPath::Resolved(_, ref path)) = input.kind;\n+                            if let TyKind::Path(QPath::Resolved(_, path)) = input.kind;\n                             if let Some(elem_ty) = path.segments.iter()\n                                 .find(|seg| seg.ident.name == sym::Vec)\n                                 .and_then(|ps| ps.args.as_ref())"}, {"sha": "8f325404deb45bffcb0ae58fc1fd91cdd0586276", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -49,7 +49,7 @@ declare_lint_pass!(NeedlessUpdate => [NEEDLESS_UPDATE]);\n \n impl<'tcx> LateLintPass<'tcx> for NeedlessUpdate {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.kind {\n+        if let ExprKind::Struct(_, fields, Some(base)) = expr.kind {\n             let ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Adt(def, _) = ty.kind() {\n                 if fields.len() == def.non_enum_variant().fields.len()"}, {"sha": "0704173a01178cb11a1a478b29f6da6780d84011", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -51,8 +51,8 @@ impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n         if_chain! {\n \n             if !in_external_macro(cx.sess(), expr.span);\n-            if let ExprKind::Unary(UnOp::Not, ref inner) = expr.kind;\n-            if let ExprKind::Binary(ref op, ref left, _) = inner.kind;\n+            if let ExprKind::Unary(UnOp::Not, inner) = expr.kind;\n+            if let ExprKind::Binary(ref op, left, _) = inner.kind;\n             if let BinOpKind::Le | BinOpKind::Ge | BinOpKind::Lt | BinOpKind::Gt = op.node;\n \n             then {"}, {"sha": "34fd012572f4b88ae8bb13ae79d879f6aed80f7c", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -28,12 +28,12 @@ declare_lint_pass!(NegMultiply => [NEG_MULTIPLY]);\n #[allow(clippy::match_same_arms)]\n impl<'tcx> LateLintPass<'tcx> for NegMultiply {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref op, ref left, ref right) = e.kind {\n+        if let ExprKind::Binary(ref op, left, right) = e.kind {\n             if BinOpKind::Mul == op.node {\n                 match (&left.kind, &right.kind) {\n                     (&ExprKind::Unary(..), &ExprKind::Unary(..)) => {},\n-                    (&ExprKind::Unary(UnOp::Neg, ref lit), _) => check_mul(cx, e.span, lit, right),\n-                    (_, &ExprKind::Unary(UnOp::Neg, ref lit)) => check_mul(cx, e.span, lit, left),\n+                    (&ExprKind::Unary(UnOp::Neg, lit), _) => check_mul(cx, e.span, lit, right),\n+                    (_, &ExprKind::Unary(UnOp::Neg, lit)) => check_mul(cx, e.span, lit, left),\n                     _ => {},\n                 }\n             }"}, {"sha": "cfcaf5094716bb7710adc32131786cae232bc29e", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -51,23 +51,21 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Lit(..) | ExprKind::Closure(..) => true,\n         ExprKind::Path(..) => !has_drop(cx, cx.typeck_results().expr_ty(expr)),\n-        ExprKind::Index(ref a, ref b) | ExprKind::Binary(_, ref a, ref b) => {\n-            has_no_effect(cx, a) && has_no_effect(cx, b)\n-        },\n-        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n-        ExprKind::Repeat(ref inner, _)\n-        | ExprKind::Cast(ref inner, _)\n-        | ExprKind::Type(ref inner, _)\n-        | ExprKind::Unary(_, ref inner)\n-        | ExprKind::Field(ref inner, _)\n-        | ExprKind::AddrOf(_, _, ref inner)\n-        | ExprKind::Box(ref inner) => has_no_effect(cx, inner),\n-        ExprKind::Struct(_, ref fields, ref base) => {\n+        ExprKind::Index(a, b) | ExprKind::Binary(_, a, b) => has_no_effect(cx, a) && has_no_effect(cx, b),\n+        ExprKind::Array(v) | ExprKind::Tup(v) => v.iter().all(|val| has_no_effect(cx, val)),\n+        ExprKind::Repeat(inner, _)\n+        | ExprKind::Cast(inner, _)\n+        | ExprKind::Type(inner, _)\n+        | ExprKind::Unary(_, inner)\n+        | ExprKind::Field(inner, _)\n+        | ExprKind::AddrOf(_, _, inner)\n+        | ExprKind::Box(inner) => has_no_effect(cx, inner),\n+        ExprKind::Struct(_, fields, ref base) => {\n             !has_drop(cx, cx.typeck_results().expr_ty(expr))\n-                && fields.iter().all(|field| has_no_effect(cx, &field.expr))\n+                && fields.iter().all(|field| has_no_effect(cx, field.expr))\n                 && base.as_ref().map_or(true, |base| has_no_effect(cx, base))\n         },\n-        ExprKind::Call(ref callee, ref args) => {\n+        ExprKind::Call(callee, args) => {\n             if let ExprKind::Path(ref qpath) = callee.kind {\n                 let res = cx.qpath_res(qpath, callee.hir_id);\n                 match res {\n@@ -81,7 +79,7 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 false\n             }\n         },\n-        ExprKind::Block(ref block, _) => {\n+        ExprKind::Block(block, _) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| has_no_effect(cx, expr))\n         },\n         _ => false,\n@@ -92,7 +90,7 @@ declare_lint_pass!(NoEffect => [NO_EFFECT, UNNECESSARY_OPERATION]);\n \n impl<'tcx> LateLintPass<'tcx> for NoEffect {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n-        if let StmtKind::Semi(ref expr) = stmt.kind {\n+        if let StmtKind::Semi(expr) = stmt.kind {\n             if has_no_effect(cx, expr) {\n                 span_lint(cx, NO_EFFECT, stmt.span, \"statement with no effect\");\n             } else if let Some(reduced) = reduce_expression(cx, expr) {\n@@ -127,26 +125,26 @@ fn reduce_expression<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Vec\n         return None;\n     }\n     match expr.kind {\n-        ExprKind::Index(ref a, ref b) => Some(vec![&**a, &**b]),\n-        ExprKind::Binary(ref binop, ref a, ref b) if binop.node != BinOpKind::And && binop.node != BinOpKind::Or => {\n-            Some(vec![&**a, &**b])\n+        ExprKind::Index(a, b) => Some(vec![a, b]),\n+        ExprKind::Binary(ref binop, a, b) if binop.node != BinOpKind::And && binop.node != BinOpKind::Or => {\n+            Some(vec![a, b])\n         },\n-        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => Some(v.iter().collect()),\n-        ExprKind::Repeat(ref inner, _)\n-        | ExprKind::Cast(ref inner, _)\n-        | ExprKind::Type(ref inner, _)\n-        | ExprKind::Unary(_, ref inner)\n-        | ExprKind::Field(ref inner, _)\n-        | ExprKind::AddrOf(_, _, ref inner)\n-        | ExprKind::Box(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n-        ExprKind::Struct(_, ref fields, ref base) => {\n+        ExprKind::Array(v) | ExprKind::Tup(v) => Some(v.iter().collect()),\n+        ExprKind::Repeat(inner, _)\n+        | ExprKind::Cast(inner, _)\n+        | ExprKind::Type(inner, _)\n+        | ExprKind::Unary(_, inner)\n+        | ExprKind::Field(inner, _)\n+        | ExprKind::AddrOf(_, _, inner)\n+        | ExprKind::Box(inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n+        ExprKind::Struct(_, fields, ref base) => {\n             if has_drop(cx, cx.typeck_results().expr_ty(expr)) {\n                 None\n             } else {\n                 Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect())\n             }\n         },\n-        ExprKind::Call(ref callee, ref args) => {\n+        ExprKind::Call(callee, args) => {\n             if let ExprKind::Path(ref qpath) = callee.kind {\n                 let res = cx.qpath_res(qpath, callee.hir_id);\n                 match res {\n@@ -161,7 +159,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Vec\n                 None\n             }\n         },\n-        ExprKind::Block(ref block, _) => {\n+        ExprKind::Block(block, _) => {\n             if block.stmts.is_empty() {\n                 block.expr.as_ref().and_then(|e| {\n                     match block.rules {"}, {"sha": "a83daea97bf6bfc5871a8080a30ca69e7623aa2f", "filename": "clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -44,7 +44,7 @@ impl LateLintPass<'_> for NonOctalUnixPermissions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         match &expr.kind {\n             ExprKind::MethodCall(path, _, [func, param], _) => {\n-                let obj_ty = cx.typeck_results().expr_ty(&func).peel_refs();\n+                let obj_ty = cx.typeck_results().expr_ty(func).peel_refs();\n \n                 if_chain! {\n                     if (path.ident.name == sym!(mode)\n@@ -65,7 +65,7 @@ impl LateLintPass<'_> for NonOctalUnixPermissions {\n                     }\n                 }\n             },\n-            ExprKind::Call(ref func, [param]) => {\n+            ExprKind::Call(func, [param]) => {\n                 if_chain! {\n                     if let ExprKind::Path(ref path) = func.kind;\n                     if let Some(def_id) = cx.qpath_res(path, func.hir_id).opt_def_id();"}, {"sha": "9efe45336bfce55c31435de8c444ff616b960972", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -31,7 +31,7 @@ declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for OpenOptions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(ref path, _, ref arguments, _) = e.kind {\n+        if let ExprKind::MethodCall(path, _, arguments, _) = e.kind {\n             let obj_ty = cx.typeck_results().expr_ty(&arguments[0]).peel_refs();\n             if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n@@ -59,7 +59,7 @@ enum OpenOption {\n }\n \n fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n-    if let ExprKind::MethodCall(ref path, _, ref arguments, _) = argument.kind {\n+    if let ExprKind::MethodCall(path, _, arguments, _) = argument.kind {\n         let obj_ty = cx.typeck_results().expr_ty(&arguments[0]).peel_refs();\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions"}, {"sha": "1b9120ae45f54c763dd72209e3b6295ec54b3d6a", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -66,9 +66,9 @@ declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n \n /// Returns true iff the given expression is the result of calling `Result::ok`\n fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n-    if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n+    if let ExprKind::MethodCall(path, _, &[ref receiver], _) = &expr.kind {\n         path.ident.name.as_str() == \"ok\"\n-            && is_type_diagnostic_item(cx, &cx.typeck_results().expr_ty(&receiver), sym::result_type)\n+            && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(receiver), sym::result_type)\n     } else {\n         false\n     }\n@@ -97,9 +97,9 @@ fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n     ) = &arm.body.kind\n     {\n         if let [] = statements {\n-            Some(&expr)\n+            Some(expr)\n         } else {\n-            Some(&arm.body)\n+            Some(arm.body)\n         }\n     } else {\n         None"}, {"sha": "e222782c2cc8c597f2b7755b4098ff88ddd860e5", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -31,11 +31,11 @@ impl<'tcx> LateLintPass<'tcx> for OverflowCheckConditional {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let eq = |l, r| SpanlessEq::new(cx).eq_path_segment(l, r);\n         if_chain! {\n-            if let ExprKind::Binary(ref op, ref first, ref second) = expr.kind;\n-            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = first.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = second.kind;\n+            if let ExprKind::Binary(ref op, first, second) = expr.kind;\n+            if let ExprKind::Binary(ref op2, ident1, ident2) = first.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path1)) = ident1.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path2)) = ident2.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path3)) = second.kind;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.typeck_results().expr_ty(ident1).is_integral();\n             if cx.typeck_results().expr_ty(ident2).is_integral();\n@@ -56,11 +56,11 @@ impl<'tcx> LateLintPass<'tcx> for OverflowCheckConditional {\n         }\n \n         if_chain! {\n-            if let ExprKind::Binary(ref op, ref first, ref second) = expr.kind;\n-            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = second.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = first.kind;\n+            if let ExprKind::Binary(ref op, first, second) = expr.kind;\n+            if let ExprKind::Binary(ref op2, ident1, ident2) = second.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path1)) = ident1.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path2)) = ident2.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path3)) = first.kind;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.typeck_results().expr_ty(ident1).is_integral();\n             if cx.typeck_results().expr_ty(ident2).is_integral();"}, {"sha": "c86a847b2ee1d4aae636ae1413856747dfa0eeaf", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -141,11 +141,11 @@ impl<'tcx> PassByRefOrValue {\n                     };\n \n                     if_chain! {\n-                        if !output_lts.contains(&input_lt);\n+                        if !output_lts.contains(input_lt);\n                         if is_copy(cx, ty);\n                         if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n                         if size <= self.ref_min_size;\n-                        if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.kind;\n+                        if let hir::TyKind::Rptr(_, MutTy { ty: decl_ty, .. }) = input.kind;\n                         then {\n                             let value_type = if is_self_ty(decl_ty) {\n                                 \"self\".into()"}, {"sha": "0024592638104a39ecd638b073c990be980b5155", "filename": "clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -45,7 +45,7 @@ declare_lint_pass!(PathBufPushOverwrite => [PATH_BUF_PUSH_OVERWRITE]);\n impl<'tcx> LateLintPass<'tcx> for PathBufPushOverwrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n             if path.ident.name == sym!(push);\n             if args.len() == 2;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), sym::PathBuf);"}, {"sha": "8c198cecd6a7f2919e0e028cf3184b45e2b1a4a1", "filename": "clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -86,7 +86,7 @@ declare_lint_pass!(PatternTypeMismatch => [PATTERN_TYPE_MISMATCH]);\n \n impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n-        if let StmtKind::Local(ref local) = stmt.kind {\n+        if let StmtKind::Local(local) = stmt.kind {\n             if let Some(init) = &local.init {\n                 if let Some(init_ty) = cx.typeck_results().node_type_opt(init.hir_id) {\n                     let pat = &local.pat;\n@@ -104,7 +104,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(ref expr, arms, source) = expr.kind {\n+        if let ExprKind::Match(expr, arms, source) = expr.kind {\n             match source {\n                 MatchSource::Normal | MatchSource::IfLetDesugar { .. } | MatchSource::WhileLetDesugar => {\n                     if let Some(expr_ty) = cx.typeck_results().node_type_opt(expr.hir_id) {\n@@ -135,7 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     ) {\n         if let Some(fn_sig) = cx.typeck_results().liberated_fn_sigs().get(hir_id) {\n             for (param, ty) in body.params.iter().zip(fn_sig.inputs().iter()) {\n-                apply_lint(cx, &param.pat, ty, DerefPossible::Impossible);\n+                apply_lint(cx, param.pat, ty, DerefPossible::Impossible);\n             }\n         }\n     }\n@@ -187,7 +187,7 @@ fn find_first_mismatch<'tcx>(\n     ty: Ty<'tcx>,\n     level: Level,\n ) -> Option<(Span, Mutability, Level)> {\n-    if let PatKind::Ref(ref sub_pat, _) = pat.kind {\n+    if let PatKind::Ref(sub_pat, _) = pat.kind {\n         if let TyKind::Ref(_, sub_ty, _) = ty.kind() {\n             return find_first_mismatch(cx, sub_pat, sub_ty, Level::Lower);\n         }\n@@ -199,17 +199,17 @@ fn find_first_mismatch<'tcx>(\n         }\n     }\n \n-    if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.kind {\n-        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind() {\n+    if let PatKind::Struct(ref qpath, field_pats, _) = pat.kind {\n+        if let TyKind::Adt(adt_def, substs_ref) = ty.kind() {\n             if let Some(variant) = get_variant(adt_def, qpath) {\n                 let field_defs = &variant.fields;\n                 return find_first_mismatch_in_struct(cx, field_pats, field_defs, substs_ref);\n             }\n         }\n     }\n \n-    if let PatKind::TupleStruct(ref qpath, ref pats, _) = pat.kind {\n-        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind() {\n+    if let PatKind::TupleStruct(ref qpath, pats, _) = pat.kind {\n+        if let TyKind::Adt(adt_def, substs_ref) = ty.kind() {\n             if let Some(variant) = get_variant(adt_def, qpath) {\n                 let field_defs = &variant.fields;\n                 let ty_iter = field_defs.iter().map(|field_def| field_def.ty(cx.tcx, substs_ref));\n@@ -218,7 +218,7 @@ fn find_first_mismatch<'tcx>(\n         }\n     }\n \n-    if let PatKind::Tuple(ref pats, _) = pat.kind {\n+    if let PatKind::Tuple(pats, _) = pat.kind {\n         if let TyKind::Tuple(..) = ty.kind() {\n             return find_first_mismatch_in_tuple(cx, pats, ty.tuple_fields());\n         }"}, {"sha": "09fcdb5faf84272c37e10a7de8a4a7922be48768", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -124,7 +124,7 @@ declare_lint_pass!(Ptr => [PTR_ARG, CMP_NULL, MUT_FROM_REF]);\n impl<'tcx> LateLintPass<'tcx> for Ptr {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Fn(ref sig, _, body_id) = item.kind {\n-            check_fn(cx, &sig.decl, item.hir_id(), Some(body_id));\n+            check_fn(cx, sig.decl, item.hir_id(), Some(body_id));\n         }\n     }\n \n@@ -136,7 +136,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n                     return; // ignore trait impls\n                 }\n             }\n-            check_fn(cx, &sig.decl, item.hir_id(), Some(body_id));\n+            check_fn(cx, sig.decl, item.hir_id(), Some(body_id));\n         }\n     }\n \n@@ -147,12 +147,12 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n             } else {\n                 None\n             };\n-            check_fn(cx, &sig.decl, item.hir_id(), body_id);\n+            check_fn(cx, sig.decl, item.hir_id(), body_id);\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref op, ref l, ref r) = expr.kind {\n+        if let ExprKind::Binary(ref op, l, r) = expr.kind {\n             if (op.node == BinOpKind::Eq || op.node == BinOpKind::Ne) && (is_null_path(l) || is_null_path(r)) {\n                 span_lint(\n                     cx,\n@@ -262,10 +262,10 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n                 }\n             } else if match_type(cx, ty, &paths::COW) {\n                 if_chain! {\n-                    if let TyKind::Rptr(_, MutTy { ref ty, ..} ) = arg.kind;\n-                    if let TyKind::Path(QPath::Resolved(None, ref pp)) = ty.kind;\n+                    if let TyKind::Rptr(_, MutTy { ty, ..} ) = arg.kind;\n+                    if let TyKind::Path(QPath::Resolved(None, pp)) = ty.kind;\n                     if let [ref bx] = *pp.segments;\n-                    if let Some(ref params) = bx.args;\n+                    if let Some(params) = bx.args;\n                     if !params.parenthesized;\n                     if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n                         GenericArg::Type(ty) => Some(ty),\n@@ -289,7 +289,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n         }\n     }\n \n-    if let FnRetTy::Return(ref ty) = decl.output {\n+    if let FnRetTy::Return(ty) = decl.output {\n         if let Some((out, Mutability::Mut, _)) = get_rptr_lm(ty) {\n             let mut immutables = vec![];\n             for (_, ref mutbl, ref argspan) in decl\n@@ -322,8 +322,8 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n \n fn get_only_generic_arg_snippet(cx: &LateContext<'_>, arg: &Ty<'_>) -> Option<String> {\n     if_chain! {\n-        if let TyKind::Path(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).kind;\n-        if let Some(&PathSegment{args: Some(ref parameters), ..}) = path.segments.last();\n+        if let TyKind::Path(QPath::Resolved(_, path)) = walk_ptrs_hir_ty(arg).kind;\n+        if let Some(&PathSegment{args: Some(parameters), ..}) = path.segments.last();\n         let types: Vec<_> = parameters.args.iter().filter_map(|arg| match arg {\n             GenericArg::Type(ty) => Some(ty),\n             _ => None,\n@@ -346,7 +346,7 @@ fn get_rptr_lm<'tcx>(ty: &'tcx Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutability,\n }\n \n fn is_null_path(expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Call(ref pathexp, ref args) = expr.kind {\n+    if let ExprKind::Call(pathexp, args) = expr.kind {\n         if args.is_empty() {\n             if let ExprKind::Path(ref path) = pathexp.kind {\n                 return match_qpath(path, &paths::PTR_NULL) || match_qpath(path, &paths::PTR_NULL_MUT);"}, {"sha": "77cfa3f6b176cd076c433af4c607a9fbd5d23cf9", "filename": "clippy_lints/src/ptr_eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_eq.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -46,11 +46,11 @@ impl LateLintPass<'_> for PtrEq {\n             return;\n         }\n \n-        if let ExprKind::Binary(ref op, ref left, ref right) = expr.kind {\n+        if let ExprKind::Binary(ref op, left, right) = expr.kind {\n             if BinOpKind::Eq == op.node {\n                 let (left, right) = match (expr_as_cast_to_usize(cx, left), expr_as_cast_to_usize(cx, right)) {\n                     (Some(lhs), Some(rhs)) => (lhs, rhs),\n-                    _ => (&**left, &**right),\n+                    _ => (left, right),\n                 };\n \n                 if_chain! {\n@@ -79,7 +79,7 @@ impl LateLintPass<'_> for PtrEq {\n // E.g., `foo as *const _ as usize` returns `foo as *const _`.\n fn expr_as_cast_to_usize<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if cx.typeck_results().expr_ty(cast_expr) == cx.tcx.types.usize {\n-        if let ExprKind::Cast(ref expr, _) = cast_expr.kind {\n+        if let ExprKind::Cast(expr, _) = cast_expr.kind {\n             return Some(expr);\n         }\n     }\n@@ -90,7 +90,7 @@ fn expr_as_cast_to_usize<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>\n // E.g., `foo as *const _` returns `foo`.\n fn expr_as_cast_to_raw_pointer<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if cx.typeck_results().expr_ty(cast_expr).is_unsafe_ptr() {\n-        if let ExprKind::Cast(ref expr, _) = cast_expr.kind {\n+        if let ExprKind::Cast(expr, _) = cast_expr.kind {\n             return Some(expr);\n         }\n     }"}, {"sha": "afb198f49559aac2c666237d7ff309210335a859", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -78,8 +78,8 @@ impl<'tcx> LateLintPass<'tcx> for PtrOffsetWithCast {\n \n // If the given expression is a cast from a usize, return the lhs of the cast\n fn expr_as_cast_from_usize<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    if let ExprKind::Cast(ref cast_lhs_expr, _) = expr.kind {\n-        if is_expr_ty_usize(cx, &cast_lhs_expr) {\n+    if let ExprKind::Cast(cast_lhs_expr, _) = expr.kind {\n+        if is_expr_ty_usize(cx, cast_lhs_expr) {\n             return Some(cast_lhs_expr);\n         }\n     }\n@@ -92,7 +92,7 @@ fn expr_as_ptr_offset_call<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n ) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, Method)> {\n-    if let ExprKind::MethodCall(ref path_segment, _, ref args, _) = expr.kind {\n+    if let ExprKind::MethodCall(path_segment, _, args, _) = expr.kind {\n         if is_expr_ty_raw_ptr(cx, &args[0]) {\n             if path_segment.ident.name == sym::offset {\n                 return Some((&args[0], &args[1], Method::Offset));"}, {"sha": "6d720f43851a0d56402553fc4d404610571f2947", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -148,14 +148,14 @@ impl QuestionMark {\n \n     fn expression_returns_none(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n         match expression.kind {\n-            ExprKind::Block(ref block, _) => {\n+            ExprKind::Block(block, _) => {\n                 if let Some(return_expression) = Self::return_expression(block) {\n-                    return Self::expression_returns_none(cx, &return_expression);\n+                    return Self::expression_returns_none(cx, return_expression);\n                 }\n \n                 false\n             },\n-            ExprKind::Ret(Some(ref expr)) => Self::expression_returns_none(cx, expr),\n+            ExprKind::Ret(Some(expr)) => Self::expression_returns_none(cx, expr),\n             ExprKind::Path(ref qp) => {\n                 if let Res::Def(DefKind::Ctor(def::CtorOf::Variant, def::CtorKind::Const), def_id) =\n                     cx.qpath_res(qp, expression.hir_id)\n@@ -174,7 +174,7 @@ impl QuestionMark {\n         if_chain! {\n             if block.stmts.len() == 1;\n             if let Some(expr) = block.stmts.iter().last();\n-            if let StmtKind::Semi(ref expr) = expr.kind;\n+            if let StmtKind::Semi(expr) = expr.kind;\n             if let ExprKind::Ret(Some(ret_expr)) = expr.kind;\n \n             then {"}, {"sha": "1c3c125e579132a7ef28745d57e65dcb81fb1034", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -183,10 +183,10 @@ impl_lint_pass!(Ranges => [\n impl<'tcx> LateLintPass<'tcx> for Ranges {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         match expr.kind {\n-            ExprKind::MethodCall(ref path, _, ref args, _) => {\n+            ExprKind::MethodCall(path, _, args, _) => {\n                 check_range_zip_with_len(cx, path, args, expr.span);\n             },\n-            ExprKind::Binary(ref op, ref l, ref r) => {\n+            ExprKind::Binary(ref op, l, r) => {\n                 if meets_msrv(self.msrv.as_ref(), &MANUAL_RANGE_CONTAINS_MSRV) {\n                     check_possible_range_contains(cx, op.node, l, r, expr);\n                 }\n@@ -287,7 +287,7 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n }\n \n fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant, Ident, Span, Span, Ordering, bool)> {\n-    if let ExprKind::Binary(ref op, ref l, ref r) = ex.kind {\n+    if let ExprKind::Binary(ref op, l, r) = ex.kind {\n         let (inclusive, ordering) = match op.node {\n             BinOpKind::Gt => (false, Ordering::Greater),\n             BinOpKind::Ge => (true, Ordering::Greater),\n@@ -324,18 +324,18 @@ fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args:\n         if path.ident.as_str() == \"zip\";\n         if let [iter, zip_arg] = args;\n         // `.iter()` call\n-        if let ExprKind::MethodCall(ref iter_path, _, ref iter_args, _) = iter.kind;\n+        if let ExprKind::MethodCall(iter_path, _, iter_args, _) = iter.kind;\n         if iter_path.ident.name == sym::iter;\n         // range expression in `.zip()` call: `0..x.len()`\n         if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n         if is_integer_const(cx, start, 0);\n         // `.len()` call\n-        if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n+        if let ExprKind::MethodCall(len_path, _, len_args, _) = end.kind;\n         if len_path.ident.name == sym!(len) && len_args.len() == 1;\n         // `.iter()` and `.len()` called on same `Path`\n-        if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].kind;\n-        if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].kind;\n-        if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n+        if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_args[0].kind;\n+        if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_args[0].kind;\n+        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n         then {\n             span_lint(cx,\n                 RANGE_ZIP_WITH_LEN,\n@@ -508,8 +508,8 @@ fn y_plus_one<'t>(cx: &LateContext<'_>, expr: &'t Expr<'_>) -> Option<&'t Expr<'\n             Spanned {\n                 node: BinOpKind::Add, ..\n             },\n-            ref lhs,\n-            ref rhs,\n+            lhs,\n+            rhs,\n         ) => {\n             if is_integer_const(cx, lhs, 1) {\n                 Some(rhs)\n@@ -529,8 +529,8 @@ fn y_minus_one<'t>(cx: &LateContext<'_>, expr: &'t Expr<'_>) -> Option<&'t Expr<\n             Spanned {\n                 node: BinOpKind::Sub, ..\n             },\n-            ref lhs,\n-            ref rhs,\n+            lhs,\n+            rhs,\n         ) if is_integer_const(cx, rhs, 1) => Some(lhs),\n         _ => None,\n     }"}, {"sha": "19650c41b840a20889aa8bc2240d8d1e47863547", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -94,7 +94,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n             .into_results_cursor(mir);\n         let mut possible_borrower = {\n             let mut vis = PossibleBorrowerVisitor::new(cx, mir);\n-            vis.visit_body(&mir);\n+            vis.visit_body(mir);\n             vis.into_map(cx, maybe_storage_live_result)\n         };\n \n@@ -126,7 +126,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 continue;\n             }\n \n-            if let ty::Adt(ref def, _) = arg_ty.kind() {\n+            if let ty::Adt(def, _) = arg_ty.kind() {\n                 if match_def_path(cx, def.did, &paths::MEM_MANUALLY_DROP) {\n                     continue;\n                 }\n@@ -206,7 +206,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                     clone_consumed_or_mutated: true,\n                 }\n             } else {\n-                let clone_usage = visit_clone_usage(local, ret_local, &mir, bb);\n+                let clone_usage = visit_clone_usage(local, ret_local, mir, bb);\n                 if clone_usage.cloned_used && clone_usage.clone_consumed_or_mutated {\n                     // cloned value is used, and the clone is modified or moved\n                     continue;\n@@ -426,7 +426,7 @@ fn visit_clone_usage(cloned: mir::Local, clone: mir::Local, mir: &mir::Body<'_>,\n         // TODO: Actually check for mutation of non-temporaries.\n         clone_consumed_or_mutated: mir.local_kind(clone) != mir::LocalKind::Temp,\n     };\n-    traversal::ReversePostorder::new(&mir, bb)\n+    traversal::ReversePostorder::new(mir, bb)\n         .skip(1)\n         .fold(init, |usage, (tbb, tdata)| {\n             // Short-circuit\n@@ -588,7 +588,7 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n             // If the call returns something with lifetimes,\n             // let's conservatively assume the returned value contains lifetime of all the arguments.\n             // For example, given `let y: Foo<'a> = foo(x)`, `y` is considered to be a possible borrower of `x`.\n-            if ContainsRegion.visit_ty(&self.body.local_decls[*dest].ty).is_continue() {\n+            if ContainsRegion.visit_ty(self.body.local_decls[*dest].ty).is_continue() {\n                 return;\n             }\n "}, {"sha": "92921bedf4dffd1604bd9a05ddd3e66a5500dda8", "filename": "clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -111,8 +111,8 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n \n                 fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n                     if_chain! {\n-                        if let hir::ExprKind::Call(ref closure, _) = expr.kind;\n-                        if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = closure.kind;\n+                        if let hir::ExprKind::Call(closure, _) = expr.kind;\n+                        if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = closure.kind;\n                         if self.path.segments[0].ident == path.segments[0].ident;\n                         if self.path.res == path.res;\n                         then {\n@@ -133,14 +133,14 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n \n         for w in block.stmts.windows(2) {\n             if_chain! {\n-                if let hir::StmtKind::Local(ref local) = w[0].kind;\n-                if let Option::Some(ref t) = local.init;\n+                if let hir::StmtKind::Local(local) = w[0].kind;\n+                if let Option::Some(t) = local.init;\n                 if let hir::ExprKind::Closure(..) = t.kind;\n                 if let hir::PatKind::Binding(_, _, ident, _) = local.pat.kind;\n-                if let hir::StmtKind::Semi(ref second) = w[1].kind;\n-                if let hir::ExprKind::Assign(_, ref call, _) = second.kind;\n-                if let hir::ExprKind::Call(ref closure, _) = call.kind;\n-                if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = closure.kind;\n+                if let hir::StmtKind::Semi(second) = w[1].kind;\n+                if let hir::ExprKind::Assign(_, call, _) = second.kind;\n+                if let hir::ExprKind::Call(closure, _) = call.kind;\n+                if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = closure.kind;\n                 if ident == path.segments[0].ident;\n                 if count_closure_usage(cx, block, path) == 1;\n                 then {"}, {"sha": "0cf4e0ce7fe225bc0400d100b80b844e50f98a2e", "filename": "clippy_lints/src/ref_option_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fref_option_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fref_option_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fref_option_ref.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for RefOptionRef {\n             if let Some(def_id) = res.opt_def_id();\n \n             if cx.tcx.is_diagnostic_item(sym::option_type, def_id);\n-            if let Some(ref params) = last_path_segment(qpath).args ;\n+            if let Some(params) = last_path_segment(qpath).args ;\n             if !params.parenthesized;\n             if let Some(inner_ty) = params.args.iter().find_map(|arg| match arg {\n                 GenericArg::Type(inner_ty) => Some(inner_ty),"}, {"sha": "4b5306de58ecdc4e911a4f3c7a9b78929e730d15", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -60,7 +60,7 @@ impl_lint_pass!(Regex => [INVALID_REGEX, TRIVIAL_REGEX]);\n impl<'tcx> LateLintPass<'tcx> for Regex {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+            if let ExprKind::Call(fun, args) = expr.kind;\n             if let ExprKind::Path(ref qpath) = fun.kind;\n             if args.len() == 1;\n             if let Some(def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n@@ -134,7 +134,7 @@ fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n \n fn check_set<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n     if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) = expr.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n         if let ExprKind::Array(exprs) = expr.kind;\n         then {\n             for expr in exprs {"}, {"sha": "560a5e7c9200aa0295a407b6fee9d6efe5dd7259", "filename": "clippy_lints/src/repeat_once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frepeat_once.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -45,10 +45,10 @@ impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n         if_chain! {\n             if let ExprKind::MethodCall(path, _, [receiver, count], _) = &expr.kind;\n             if path.ident.name == sym!(repeat);\n-            if let Some(Constant::Int(1)) = constant_context(cx, cx.typeck_results()).expr(&count);\n+            if let Some(Constant::Int(1)) = constant_context(cx, cx.typeck_results()).expr(count);\n             if !in_macro(receiver.span);\n             then {\n-                let ty = cx.typeck_results().expr_ty(&receiver).peel_refs();\n+                let ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n                 if ty.is_str() {\n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "af772cf4a145d30bb67aa50d648bc29a6c7d895d", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -102,7 +102,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n                         err.span_label(local.span, \"unnecessary `let` binding\");\n \n                         if let Some(mut snippet) = snippet_opt(cx, initexpr.span) {\n-                            if !cx.typeck_results().expr_adjustments(&retexpr).is_empty() {\n+                            if !cx.typeck_results().expr_adjustments(retexpr).is_empty() {\n                                 snippet.push_str(\" as _\");\n                             }\n                             err.multipart_suggestion(\n@@ -143,7 +143,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n                 check_final_expr(cx, &body.value, Some(body.value.span), replacement)\n             },\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n-                if let ExprKind::Block(ref block, _) = body.value.kind {\n+                if let ExprKind::Block(block, _) = body.value.kind {\n                     check_block_return(cx, block);\n                 }\n             },\n@@ -160,7 +160,7 @@ fn check_block_return<'tcx>(cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n         check_final_expr(cx, expr, Some(expr.span), RetReplacement::Empty);\n     } else if let Some(stmt) = block.stmts.iter().last() {\n         match stmt.kind {\n-            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => {\n                 check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n             },\n             _ => (),\n@@ -192,11 +192,11 @@ fn check_final_expr<'tcx>(\n             }\n         },\n         // a whole block? check it!\n-        ExprKind::Block(ref block, _) => {\n+        ExprKind::Block(block, _) => {\n             check_block_return(cx, block);\n         },\n         ExprKind::If(_, then, else_clause_opt) => {\n-            if let ExprKind::Block(ref ifblock, _) = then.kind {\n+            if let ExprKind::Block(ifblock, _) = then.kind {\n                 check_block_return(cx, ifblock);\n             }\n             if let Some(else_clause) = else_clause_opt {\n@@ -207,16 +207,16 @@ fn check_final_expr<'tcx>(\n         // an if/if let expr, check both exprs\n         // note, if without else is going to be a type checking error anyways\n         // (except for unit type functions) so we don't match it\n-        ExprKind::Match(_, ref arms, source) => match source {\n+        ExprKind::Match(_, arms, source) => match source {\n             MatchSource::Normal => {\n                 for arm in arms.iter() {\n-                    check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n+                    check_final_expr(cx, arm.body, Some(arm.body.span), RetReplacement::Block);\n                 }\n             },\n             MatchSource::IfLetDesugar {\n                 contains_else_clause: true,\n             } => {\n-                if let ExprKind::Block(ref ifblock, _) = arms[0].body.kind {\n+                if let ExprKind::Block(ifblock, _) = arms[0].body.kind {\n                     check_block_return(cx, ifblock);\n                 }\n                 check_final_expr(cx, arms[1].body, None, RetReplacement::Empty);"}, {"sha": "553987a426b57c2243eef297e56f220ef3000da6", "filename": "clippy_lints/src/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -51,7 +51,7 @@ impl LateLintPass<'_> for SemicolonIfNothingReturned {\n                     return;\n                 }\n \n-                let sugg = sugg::Sugg::hir_with_macro_callsite(cx, &expr, \"..\");\n+                let sugg = sugg::Sugg::hir_with_macro_callsite(cx, expr, \"..\");\n                 let suggestion = format!(\"{0};\", sugg);\n                 span_lint_and_sugg(\n                     cx,"}, {"sha": "d6101bd5e36a2d53744cc224acf5436e82add96c", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -130,12 +130,12 @@ fn check_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'_>, bindings: &\n     let len = bindings.len();\n     for stmt in block.stmts {\n         match stmt.kind {\n-            StmtKind::Local(ref local) => check_local(cx, local, bindings),\n-            StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => check_expr(cx, e, bindings),\n+            StmtKind::Local(local) => check_local(cx, local, bindings),\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => check_expr(cx, e, bindings),\n             StmtKind::Item(..) => {},\n         }\n     }\n-    if let Some(ref o) = block.expr {\n+    if let Some(o) = block.expr {\n         check_expr(cx, o, bindings);\n     }\n     bindings.truncate(len);\n@@ -149,16 +149,16 @@ fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &\n         return;\n     }\n     let Local {\n-        ref pat,\n+        pat,\n         ref ty,\n         ref init,\n         span,\n         ..\n     } = *local;\n-    if let Some(ref t) = *ty {\n+    if let Some(t) = *ty {\n         check_ty(cx, t, bindings)\n     }\n-    if let Some(ref o) = *init {\n+    if let Some(o) = *init {\n         check_expr(cx, o, bindings);\n         check_pat(cx, pat, Some(o), span, bindings);\n     } else {\n@@ -196,34 +196,34 @@ fn check_pat<'tcx>(\n                     bindings.push((name, ident.span));\n                 }\n             }\n-            if let Some(ref p) = *inner {\n+            if let Some(p) = *inner {\n                 check_pat(cx, p, init, span, bindings);\n             }\n         },\n         PatKind::Struct(_, pfields, _) => {\n             if let Some(init_struct) = init {\n-                if let ExprKind::Struct(_, ref efields, _) = init_struct.kind {\n+                if let ExprKind::Struct(_, efields, _) = init_struct.kind {\n                     for field in pfields {\n                         let name = field.ident.name;\n                         let efield = efields\n                             .iter()\n                             .find_map(|f| if f.ident.name == name { Some(&*f.expr) } else { None });\n-                        check_pat(cx, &field.pat, efield, span, bindings);\n+                        check_pat(cx, field.pat, efield, span, bindings);\n                     }\n                 } else {\n                     for field in pfields {\n-                        check_pat(cx, &field.pat, init, span, bindings);\n+                        check_pat(cx, field.pat, init, span, bindings);\n                     }\n                 }\n             } else {\n                 for field in pfields {\n-                    check_pat(cx, &field.pat, None, span, bindings);\n+                    check_pat(cx, field.pat, None, span, bindings);\n                 }\n             }\n         },\n         PatKind::Tuple(inner, _) => {\n             if let Some(init_tup) = init {\n-                if let ExprKind::Tup(ref tup) = init_tup.kind {\n+                if let ExprKind::Tup(tup) = init_tup.kind {\n                     for (i, p) in inner.iter().enumerate() {\n                         check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n                     }\n@@ -238,18 +238,18 @@ fn check_pat<'tcx>(\n                 }\n             }\n         },\n-        PatKind::Box(ref inner) => {\n+        PatKind::Box(inner) => {\n             if let Some(initp) = init {\n-                if let ExprKind::Box(ref inner_init) = initp.kind {\n-                    check_pat(cx, inner, Some(&**inner_init), span, bindings);\n+                if let ExprKind::Box(inner_init) = initp.kind {\n+                    check_pat(cx, inner, Some(inner_init), span, bindings);\n                 } else {\n                     check_pat(cx, inner, init, span, bindings);\n                 }\n             } else {\n                 check_pat(cx, inner, init, span, bindings);\n             }\n         },\n-        PatKind::Ref(ref inner, _) => check_pat(cx, inner, init, span, bindings),\n+        PatKind::Ref(inner, _) => check_pat(cx, inner, init, span, bindings),\n         // PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n         _ => (),\n     }\n@@ -323,30 +323,29 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n         return;\n     }\n     match expr.kind {\n-        ExprKind::Unary(_, ref e)\n-        | ExprKind::Field(ref e, _)\n-        | ExprKind::AddrOf(_, _, ref e)\n-        | ExprKind::Box(ref e) => check_expr(cx, e, bindings),\n-        ExprKind::Block(ref block, _) | ExprKind::Loop(ref block, ..) => check_block(cx, block, bindings),\n+        ExprKind::Unary(_, e) | ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) | ExprKind::Box(e) => {\n+            check_expr(cx, e, bindings)\n+        },\n+        ExprKind::Block(block, _) | ExprKind::Loop(block, ..) => check_block(cx, block, bindings),\n         // ExprKind::Call\n         // ExprKind::MethodCall\n         ExprKind::Array(v) | ExprKind::Tup(v) => {\n             for e in v {\n                 check_expr(cx, e, bindings)\n             }\n         },\n-        ExprKind::If(ref cond, ref then, ref otherwise) => {\n+        ExprKind::If(cond, then, ref otherwise) => {\n             check_expr(cx, cond, bindings);\n-            check_expr(cx, &**then, bindings);\n-            if let Some(ref o) = *otherwise {\n+            check_expr(cx, then, bindings);\n+            if let Some(o) = *otherwise {\n                 check_expr(cx, o, bindings);\n             }\n         },\n-        ExprKind::Match(ref init, arms, _) => {\n+        ExprKind::Match(init, arms, _) => {\n             check_expr(cx, init, bindings);\n             let len = bindings.len();\n             for arm in arms {\n-                check_pat(cx, &arm.pat, Some(&**init), arm.pat.span, bindings);\n+                check_pat(cx, arm.pat, Some(init), arm.pat.span, bindings);\n                 // This is ugly, but needed to get the right type\n                 if let Some(ref guard) = arm.guard {\n                     match guard {\n@@ -357,7 +356,7 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n                         },\n                     }\n                 }\n-                check_expr(cx, &arm.body, bindings);\n+                check_expr(cx, arm.body, bindings);\n                 bindings.truncate(len);\n             }\n         },\n@@ -367,14 +366,12 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n \n fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n     match ty.kind {\n-        TyKind::Slice(ref sty) => check_ty(cx, sty, bindings),\n-        TyKind::Array(ref fty, ref anon_const) => {\n+        TyKind::Slice(sty) => check_ty(cx, sty, bindings),\n+        TyKind::Array(fty, ref anon_const) => {\n             check_ty(cx, fty, bindings);\n             check_expr(cx, &cx.tcx.hir().body(anon_const.body).value, bindings);\n         },\n-        TyKind::Ptr(MutTy { ty: ref mty, .. }) | TyKind::Rptr(_, MutTy { ty: ref mty, .. }) => {\n-            check_ty(cx, mty, bindings)\n-        },\n+        TyKind::Ptr(MutTy { ty: mty, .. }) | TyKind::Rptr(_, MutTy { ty: mty, .. }) => check_ty(cx, mty, bindings),\n         TyKind::Tup(tup) => {\n             for t in tup {\n                 check_ty(cx, t, bindings)\n@@ -387,12 +384,12 @@ fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(\n \n fn is_self_shadow(name: Symbol, expr: &Expr<'_>) -> bool {\n     match expr.kind {\n-        ExprKind::Box(ref inner) | ExprKind::AddrOf(_, _, ref inner) => is_self_shadow(name, inner),\n-        ExprKind::Block(ref block, _) => {\n+        ExprKind::Box(inner) | ExprKind::AddrOf(_, _, inner) => is_self_shadow(name, inner),\n+        ExprKind::Block(block, _) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |e| is_self_shadow(name, e))\n         },\n-        ExprKind::Unary(op, ref inner) => (UnOp::Deref == op) && is_self_shadow(name, inner),\n-        ExprKind::Path(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n+        ExprKind::Unary(op, inner) => (UnOp::Deref == op) && is_self_shadow(name, inner),\n+        ExprKind::Path(QPath::Resolved(_, path)) => path_eq_name(name, path),\n         _ => false,\n     }\n }"}, {"sha": "8cf89ae456ee8a3e6ae9da78966749df566b00b6", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -70,14 +70,14 @@ impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Matches initialization on reassignements. For example: `vec = Vec::with_capacity(100)`\n         if_chain! {\n-            if let ExprKind::Assign(ref left, ref right, _) = expr.kind;\n+            if let ExprKind::Assign(left, right, _) = expr.kind;\n \n             // Extract variable name\n-            if let ExprKind::Path(QPath::Resolved(_, ref path)) = left.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = left.kind;\n             if let Some(variable_name) = path.segments.get(0);\n \n             // Extract len argument\n-            if let Some(ref len_arg) = Self::is_vec_with_capacity(right);\n+            if let Some(len_arg) = Self::is_vec_with_capacity(right);\n \n             then {\n                 let vi = VecAllocation {\n@@ -94,10 +94,10 @@ impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         // Matches statements which initializes vectors. For example: `let mut vec = Vec::with_capacity(10)`\n         if_chain! {\n-            if let StmtKind::Local(ref local) = stmt.kind;\n+            if let StmtKind::Local(local) = stmt.kind;\n             if let PatKind::Binding(BindingAnnotation::Mutable, .., variable_name, None) = local.pat.kind;\n-            if let Some(ref init) = local.init;\n-            if let Some(ref len_arg) = Self::is_vec_with_capacity(init);\n+            if let Some(init) = local.init;\n+            if let Some(len_arg) = Self::is_vec_with_capacity(init);\n \n             then {\n                 let vi = VecAllocation {\n@@ -117,7 +117,7 @@ impl SlowVectorInit {\n     /// of the first argument of `with_capacity` call if it matches or `None` if it does not.\n     fn is_vec_with_capacity<'tcx>(expr: &Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n         if_chain! {\n-            if let ExprKind::Call(ref func, ref args) = expr.kind;\n+            if let ExprKind::Call(func, args) = expr.kind;\n             if let ExprKind::Path(ref path) = func.kind;\n             if match_qpath(path, &[\"Vec\", \"with_capacity\"]);\n             if args.len() == 1;\n@@ -208,11 +208,11 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_extend_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n             if let ExprKind::Path(ref qpath_subj) = args[0].kind;\n-            if match_qpath(&qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n+            if match_qpath(qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n             if path.ident.name == sym!(extend);\n-            if let Some(ref extend_arg) = args.get(1);\n+            if let Some(extend_arg) = args.get(1);\n             if self.is_repeat_take(extend_arg);\n \n             then {\n@@ -225,11 +225,11 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_resize_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n             if let ExprKind::Path(ref qpath_subj) = args[0].kind;\n-            if match_qpath(&qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n+            if match_qpath(qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n             if path.ident.name == sym!(resize);\n-            if let (Some(ref len_arg), Some(fill_arg)) = (args.get(1), args.get(2));\n+            if let (Some(len_arg), Some(fill_arg)) = (args.get(1), args.get(2));\n \n             // Check that is filled with 0\n             if let ExprKind::Lit(ref lit) = fill_arg.kind;\n@@ -247,15 +247,15 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Returns `true` if give expression is `repeat(0).take(...)`\n     fn is_repeat_take(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref take_path, _, ref take_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(take_path, _, take_args, _) = expr.kind;\n             if take_path.ident.name == sym!(take);\n \n             // Check that take is applied to `repeat(0)`\n-            if let Some(ref repeat_expr) = take_args.get(0);\n+            if let Some(repeat_expr) = take_args.get(0);\n             if Self::is_repeat_zero(repeat_expr);\n \n             // Check that len expression is equals to `with_capacity` expression\n-            if let Some(ref len_arg) = take_args.get(1);\n+            if let Some(len_arg) = take_args.get(1);\n             if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr);\n \n             then {\n@@ -269,10 +269,10 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Returns `true` if given expression is `repeat(0)`\n     fn is_repeat_zero(expr: &Expr<'_>) -> bool {\n         if_chain! {\n-            if let ExprKind::Call(ref fn_expr, ref repeat_args) = expr.kind;\n+            if let ExprKind::Call(fn_expr, repeat_args) = expr.kind;\n             if let ExprKind::Path(ref qpath_repeat) = fn_expr.kind;\n-            if match_qpath(&qpath_repeat, &[\"repeat\"]);\n-            if let Some(ref repeat_arg) = repeat_args.get(0);\n+            if match_qpath(qpath_repeat, &[\"repeat\"]);\n+            if let Some(repeat_arg) = repeat_args.get(0);\n             if let ExprKind::Lit(ref lit) = repeat_arg.kind;\n             if let LitKind::Int(0, _) = lit.node;\n \n@@ -291,7 +291,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n     fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n         if self.initialization_found {\n             match stmt.kind {\n-                StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n+                StmtKind::Expr(expr) | StmtKind::Semi(expr) => {\n                     self.search_slow_extend_filling(expr);\n                     self.search_slow_resize_filling(expr);\n                 },\n@@ -306,7 +306,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n \n     fn visit_block(&mut self, block: &'tcx Block<'_>) {\n         if self.initialization_found {\n-            if let Some(ref s) = block.stmts.get(0) {\n+            if let Some(s) = block.stmts.get(0) {\n                 self.visit_stmt(s)\n             }\n "}, {"sha": "9d91b53e1bbc1ad4b4827198f2380379e596707a", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -119,15 +119,15 @@ impl<'tcx> LateLintPass<'tcx> for StringAdd {\n             Spanned {\n                 node: BinOpKind::Add, ..\n             },\n-            ref left,\n+            left,\n             _,\n         ) = e.kind\n         {\n             if is_string(cx, left) {\n                 if !is_allowed(cx, STRING_ADD_ASSIGN, e.hir_id) {\n                     let parent = get_parent_expr(cx, e);\n                     if let Some(p) = parent {\n-                        if let ExprKind::Assign(ref target, _, _) = p.kind {\n+                        if let ExprKind::Assign(target, _, _) = p.kind {\n                             // avoid duplicate matches\n                             if SpanlessEq::new(cx).eq_expr(target, left) {\n                                 return;\n@@ -142,7 +142,7 @@ impl<'tcx> LateLintPass<'tcx> for StringAdd {\n                     \"you added something to a string. Consider using `String::push_str()` instead\",\n                 );\n             }\n-        } else if let ExprKind::Assign(ref target, ref src, _) = e.kind {\n+        } else if let ExprKind::Assign(target, src, _) = e.kind {\n             if is_string(cx, target) && is_add(cx, src, target) {\n                 span_lint(\n                     cx,\n@@ -166,10 +166,10 @@ fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {\n             Spanned {\n                 node: BinOpKind::Add, ..\n             },\n-            ref left,\n+            left,\n             _,\n         ) => SpanlessEq::new(cx).eq_expr(target, left),\n-        ExprKind::Block(ref block, _) => {\n+        ExprKind::Block(block, _) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n         },\n         _ => false,\n@@ -210,8 +210,8 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n             if let Some(args) = match_function_call(cx, e, &paths::STR_FROM_UTF8);\n \n             // Find string::as_bytes\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, ref args) = args[0].kind;\n-            if let ExprKind::Index(ref left, ref right) = args.kind;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, args) = args[0].kind;\n+            if let ExprKind::Index(left, right) = args.kind;\n             let (method_names, expressions, _) = method_calls(left, 1);\n             if method_names.len() == 1;\n             if expressions.len() == 1;"}, {"sha": "cb2237e531262fb95d2975e7515782749b383f51", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -225,7 +225,7 @@ fn attempt_to_emit_no_difference_lint(\n                     emit_suggestion(\n                         cx,\n                         binop.span,\n-                        replace_left_sugg(cx, &binop, &sugg, &mut applicability),\n+                        replace_left_sugg(cx, binop, &sugg, &mut applicability),\n                         applicability,\n                     );\n                     return;\n@@ -247,7 +247,7 @@ fn attempt_to_emit_no_difference_lint(\n                     emit_suggestion(\n                         cx,\n                         binop.span,\n-                        replace_right_sugg(cx, &binop, &sugg, &mut applicability),\n+                        replace_right_sugg(cx, binop, &sugg, &mut applicability),\n                         applicability,\n                     );\n                     return;\n@@ -276,8 +276,8 @@ fn ident_swap_sugg(\n     location: IdentLocation,\n     applicability: &mut Applicability,\n ) -> Option<String> {\n-    let left_ident = get_ident(&binop.left, location)?;\n-    let right_ident = get_ident(&binop.right, location)?;\n+    let left_ident = get_ident(binop.left, location)?;\n+    let right_ident = get_ident(binop.right, location)?;\n \n     let sugg = match (\n         paired_identifiers.contains(&left_ident),\n@@ -293,24 +293,22 @@ fn ident_swap_sugg(\n             // ends up duplicating a clause, the `logic_bug` lint\n             // should catch it.\n \n-            let right_suggestion =\n-                suggestion_with_swapped_ident(cx, &binop.right, location, left_ident, applicability)?;\n+            let right_suggestion = suggestion_with_swapped_ident(cx, binop.right, location, left_ident, applicability)?;\n \n             replace_right_sugg(cx, binop, &right_suggestion, applicability)\n         },\n         (false, true) => {\n             // We haven't seen a pair involving the left one, so\n             // it's probably what is wanted.\n \n-            let right_suggestion =\n-                suggestion_with_swapped_ident(cx, &binop.right, location, left_ident, applicability)?;\n+            let right_suggestion = suggestion_with_swapped_ident(cx, binop.right, location, left_ident, applicability)?;\n \n             replace_right_sugg(cx, binop, &right_suggestion, applicability)\n         },\n         (true, false) => {\n             // We haven't seen a pair involving the right one, so\n             // it's probably what is wanted.\n-            let left_suggestion = suggestion_with_swapped_ident(cx, &binop.left, location, right_ident, applicability)?;\n+            let left_suggestion = suggestion_with_swapped_ident(cx, binop.left, location, right_ident, applicability)?;\n \n             replace_left_sugg(cx, binop, &left_suggestion, applicability)\n         },"}, {"sha": "19967e2c9701499dba553101ca583e474f08bd75", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -78,26 +78,26 @@ fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n     for w in block.stmts.windows(3) {\n         if_chain! {\n             // let t = foo();\n-            if let StmtKind::Local(ref tmp) = w[0].kind;\n-            if let Some(ref tmp_init) = tmp.init;\n+            if let StmtKind::Local(tmp) = w[0].kind;\n+            if let Some(tmp_init) = tmp.init;\n             if let PatKind::Binding(.., ident, None) = tmp.pat.kind;\n \n             // foo() = bar();\n-            if let StmtKind::Semi(ref first) = w[1].kind;\n-            if let ExprKind::Assign(ref lhs1, ref rhs1, _) = first.kind;\n+            if let StmtKind::Semi(first) = w[1].kind;\n+            if let ExprKind::Assign(lhs1, rhs1, _) = first.kind;\n \n             // bar() = t;\n-            if let StmtKind::Semi(ref second) = w[2].kind;\n-            if let ExprKind::Assign(ref lhs2, ref rhs2, _) = second.kind;\n-            if let ExprKind::Path(QPath::Resolved(None, ref rhs2)) = rhs2.kind;\n+            if let StmtKind::Semi(second) = w[2].kind;\n+            if let ExprKind::Assign(lhs2, rhs2, _) = second.kind;\n+            if let ExprKind::Path(QPath::Resolved(None, rhs2)) = rhs2.kind;\n             if rhs2.segments.len() == 1;\n \n             if ident.name == rhs2.segments[0].ident.name;\n             if eq_expr_value(cx, tmp_init, lhs1);\n             if eq_expr_value(cx, rhs1, lhs2);\n             then {\n-                if let ExprKind::Field(ref lhs1, _) = lhs1.kind {\n-                    if let ExprKind::Field(ref lhs2, _) = lhs2.kind {\n+                if let ExprKind::Field(lhs1, _) = lhs1.kind {\n+                    if let ExprKind::Field(lhs2, _) = lhs2.kind {\n                         if lhs1.hir_id.owner == lhs2.hir_id.owner {\n                             return;\n                         }\n@@ -192,8 +192,8 @@ enum Slice<'a> {\n \n /// Checks if both expressions are index operations into \"slice-like\" types.\n fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<'_>) -> Slice<'a> {\n-    if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n-        if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n+    if let ExprKind::Index(lhs1, idx1) = lhs1.kind {\n+        if let ExprKind::Index(lhs2, idx2) = lhs2.kind {\n             if eq_expr_value(cx, lhs1, lhs2) {\n                 let ty = cx.typeck_results().expr_ty(lhs1).peel_refs();\n \n@@ -217,11 +217,11 @@ fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<\n fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n     for w in block.stmts.windows(2) {\n         if_chain! {\n-            if let StmtKind::Semi(ref first) = w[0].kind;\n-            if let StmtKind::Semi(ref second) = w[1].kind;\n+            if let StmtKind::Semi(first) = w[0].kind;\n+            if let StmtKind::Semi(second) = w[1].kind;\n             if !differing_macro_contexts(first.span, second.span);\n-            if let ExprKind::Assign(ref lhs0, ref rhs0, _) = first.kind;\n-            if let ExprKind::Assign(ref lhs1, ref rhs1, _) = second.kind;\n+            if let ExprKind::Assign(lhs0, rhs0, _) = first.kind;\n+            if let ExprKind::Assign(lhs1, rhs1, _) = second.kind;\n             if eq_expr_value(cx, lhs0, rhs1);\n             if eq_expr_value(cx, lhs1, rhs0);\n             then {"}, {"sha": "a0492a88f912ad9229560c38fd1a0796b431702c", "filename": "clippy_lints/src/tabs_in_doc_comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -86,7 +86,7 @@ impl TabsInDocComments {\n \n impl EarlyLintPass for TabsInDocComments {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attribute: &ast::Attribute) {\n-        Self::warn_if_tabs_in_doc(cx, &attribute);\n+        Self::warn_if_tabs_in_doc(cx, attribute);\n     }\n }\n "}, {"sha": "ae05a8da37bc93fab9c2e6030ead26bf225340b5", "filename": "clippy_lints/src/to_string_in_display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -92,7 +92,7 @@ impl LateLintPass<'_> for ToStringInDisplay {\n         if_chain! {\n             if self.in_display_impl;\n             if let Some(self_hir_id) = self.self_hir_id;\n-            if let ExprKind::MethodCall(ref path, _, args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n             if path.ident.name == sym!(to_string);\n             if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n             if is_diagnostic_assoc_item(cx, expr_def_id, sym::ToString);"}, {"sha": "b0589b0512ef5cfc002bae4a198ce27770f7abb6", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -107,7 +107,7 @@ impl TraitBounds {\n                 if let WherePredicate::BoundPredicate(ref p) = bound;\n                 if p.bounds.len() as u64 <= self.max_trait_bounds;\n                 if !in_macro(p.span);\n-                let h = hash(&p.bounded_ty);\n+                let h = hash(p.bounded_ty);\n                 if let Some(ref v) = map.insert(h, p.bounds.iter().collect::<Vec<_>>());\n \n                 then {\n@@ -170,7 +170,7 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n         if_chain! {\n             if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n             if !in_macro(bound_predicate.span);\n-            if let TyKind::Path(QPath::Resolved(_, Path { ref segments, .. })) = bound_predicate.bounded_ty.kind;\n+            if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n             if let Some(segment) = segments.first();\n             if let Some(trait_resolutions_direct) = map.get(&segment.ident);\n             then {"}, {"sha": "86ac916df6cba743262ab8b90298e02e8c858233", "filename": "clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -325,7 +325,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref path_expr, ref args) = e.kind;\n+            if let ExprKind::Call(path_expr, args) = e.kind;\n             if let ExprKind::Path(ref qpath) = path_expr.kind;\n             if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::TRANSMUTE);"}, {"sha": "3aa3c393ba57cce3a8d26a402683405ba607f099", "filename": "clippy_lints/src/transmute/transmute_float_to_int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check<'tcx>(\n                     let mut arg = sugg::Sugg::hir(cx, expr, \"..\");\n \n                     if let ExprKind::Unary(UnOp::Neg, inner_expr) = &expr.kind {\n-                        expr = &inner_expr;\n+                        expr = inner_expr;\n                     }\n \n                     if_chain! {"}, {"sha": "f359b606e4548b1736876e4fc3074ed6ace86ff5", "filename": "clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -16,7 +16,7 @@ use rustc_typeck::check::{cast::CastCheck, FnCtxt, Inherited};\n pub(super) fn get_type_snippet(cx: &LateContext<'_>, path: &QPath<'_>, to_ref_ty: Ty<'_>) -> String {\n     let seg = last_path_segment(path);\n     if_chain! {\n-        if let Some(ref params) = seg.args;\n+        if let Some(params) = seg.args;\n         if !params.parenthesized;\n         if let Some(to_ty) = params.args.iter().filter_map(|arg| match arg {\n             GenericArg::Type(ty) => Some(ty),"}, {"sha": "0be05d3e0cf3f2a1304581516a7026e08259a1bb", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n         }\n \n         if_chain! {\n-            if let ExprKind::Call(ref func, ref args) = expr.kind;\n+            if let ExprKind::Call(func, args) = expr.kind;\n             if let ExprKind::Path(ref path) = func.kind;\n             if match_qpath(path, &paths::STD_MEM_TRANSMUTE);\n             if args.len() == 1;\n@@ -58,7 +58,7 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n                 // Catching:\n                 // `std::mem::transmute(0 as *const i32)`\n                 if_chain! {\n-                    if let ExprKind::Cast(ref inner_expr, ref _cast_ty) = args[0].kind;\n+                    if let ExprKind::Cast(inner_expr, _cast_ty) = args[0].kind;\n                     if let ExprKind::Lit(ref lit) = inner_expr.kind;\n                     if let LitKind::Int(0, _) = lit.node;\n                     then {\n@@ -69,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n                 // Catching:\n                 // `std::mem::transmute(std::ptr::null::<i32>())`\n                 if_chain! {\n-                    if let ExprKind::Call(ref func1, ref args1) = args[0].kind;\n+                    if let ExprKind::Call(func1, args1) = args[0].kind;\n                     if let ExprKind::Path(ref path1) = func1.kind;\n                     if match_qpath(path1, &paths::STD_PTR_NULL);\n                     if args1.is_empty();"}, {"sha": "23a1953ffaceb8715200c0ec8d2c2c400e295df6", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -60,13 +60,13 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n         // };\n         if_chain! {\n             if !in_external_macro(cx.tcx.sess, expr.span);\n-            if let ExprKind::Match(ref match_arg, _, MatchSource::TryDesugar) = expr.kind;\n-            if let ExprKind::Call(ref match_fun, ref try_args) = match_arg.kind;\n+            if let ExprKind::Match(match_arg, _, MatchSource::TryDesugar) = expr.kind;\n+            if let ExprKind::Call(match_fun, try_args) = match_arg.kind;\n             if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n             if matches!(match_fun_path, QPath::LangItem(LangItem::TryIntoResult, _));\n-            if let Some(ref try_arg) = try_args.get(0);\n-            if let ExprKind::Call(ref err_fun, ref err_args) = try_arg.kind;\n-            if let Some(ref err_arg) = err_args.get(0);\n+            if let Some(try_arg) = try_args.get(0);\n+            if let ExprKind::Call(err_fun, err_args) = try_arg.kind;\n+            if let Some(err_arg) = err_args.get(0);\n             if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n             if match_qpath(err_fun_path, &paths::RESULT_ERR);\n             if let Some(return_ty) = find_return_type(cx, &expr.kind);\n@@ -123,9 +123,9 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n \n /// Finds function return type by examining return expressions in match arms.\n fn find_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> Option<Ty<'tcx>> {\n-    if let ExprKind::Match(_, ref arms, MatchSource::TryDesugar) = expr {\n+    if let ExprKind::Match(_, arms, MatchSource::TryDesugar) = expr {\n         for arm in arms.iter() {\n-            if let ExprKind::Ret(Some(ref ret)) = arm.body.kind {\n+            if let ExprKind::Ret(Some(ret)) = arm.body.kind {\n                 return Some(cx.typeck_results().expr_ty(ret));\n             }\n         }"}, {"sha": "1425d8f3f37edf1e9a62f66ece489bfbbc8f06fe", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -19,9 +19,9 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, lt: &Lifetime, m\n             if_chain! {\n                 if let Some(def_id) = def.opt_def_id();\n                 if Some(def_id) == cx.tcx.lang_items().owned_box();\n-                if let QPath::Resolved(None, ref path) = *qpath;\n+                if let QPath::Resolved(None, path) = *qpath;\n                 if let [ref bx] = *path.segments;\n-                if let Some(ref params) = bx.args;\n+                if let Some(params) = bx.args;\n                 if !params.parenthesized;\n                 if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n                     GenericArg::Type(ty) => Some(ty),\n@@ -86,11 +86,11 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, lt: &Lifetime, m\n // Returns true if given type is `Any` trait.\n fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n     if_chain! {\n-        if let TyKind::TraitObject(ref traits, ..) = t.kind;\n+        if let TyKind::TraitObject(traits, ..) = t.kind;\n         if !traits.is_empty();\n         // Only Send/Sync can be used as additional traits, so it is enough to\n         // check only the first trait.\n-        if match_path(&traits[0].trait_ref.path, &paths::ANY_TRAIT);\n+        if match_path(traits[0].trait_ref.path, &paths::ANY_TRAIT);\n         then {\n             return true;\n         }"}, {"sha": "d9b47a699dc3cc4150b3bb85eb2e32153527183e", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -278,17 +278,15 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         match item.kind {\n-            ItemKind::Static(ref ty, _, _) | ItemKind::Const(ref ty, _) => {\n-                self.check_ty(cx, ty, CheckTyContext::default())\n-            },\n+            ItemKind::Static(ty, _, _) | ItemKind::Const(ty, _) => self.check_ty(cx, ty, CheckTyContext::default()),\n             // functions, enums, structs, impls and traits are covered\n             _ => (),\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         match item.kind {\n-            ImplItemKind::Const(ref ty, _) | ImplItemKind::TyAlias(ref ty) => self.check_ty(\n+            ImplItemKind::Const(ty, _) | ImplItemKind::TyAlias(ty) => self.check_ty(\n                 cx,\n                 ty,\n                 CheckTyContext {\n@@ -302,21 +300,21 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n-        self.check_ty(cx, &field.ty, CheckTyContext::default());\n+        self.check_ty(cx, field.ty, CheckTyContext::default());\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n         match item.kind {\n-            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => {\n+            TraitItemKind::Const(ty, _) | TraitItemKind::Type(_, Some(ty)) => {\n                 self.check_ty(cx, ty, CheckTyContext::default())\n             },\n-            TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, &sig.decl, CheckTyContext::default()),\n+            TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, sig.decl, CheckTyContext::default()),\n             TraitItemKind::Type(..) => (),\n         }\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'_>, local: &Local<'_>) {\n-        if let Some(ref ty) = local.ty {\n+        if let Some(ty) = local.ty {\n             self.check_ty(\n                 cx,\n                 ty,\n@@ -342,7 +340,7 @@ impl Types {\n             self.check_ty(cx, input, context);\n         }\n \n-        if let FnRetTy::Return(ref ty) = decl.output {\n+        if let FnRetTy::Return(ty) = decl.output {\n             self.check_ty(cx, ty, context);\n         }\n     }\n@@ -383,7 +381,7 @@ impl Types {\n                     }\n                 }\n                 match *qpath {\n-                    QPath::Resolved(Some(ref ty), ref p) => {\n+                    QPath::Resolved(Some(ty), p) => {\n                         context.is_nested_call = true;\n                         self.check_ty(cx, ty, context);\n                         for ty in p.segments.iter().flat_map(|seg| {\n@@ -398,7 +396,7 @@ impl Types {\n                             self.check_ty(cx, ty, context);\n                         }\n                     },\n-                    QPath::Resolved(None, ref p) => {\n+                    QPath::Resolved(None, p) => {\n                         context.is_nested_call = true;\n                         for ty in p.segments.iter().flat_map(|seg| {\n                             seg.args\n@@ -412,10 +410,10 @@ impl Types {\n                             self.check_ty(cx, ty, context);\n                         }\n                     },\n-                    QPath::TypeRelative(ref ty, ref seg) => {\n+                    QPath::TypeRelative(ty, seg) => {\n                         context.is_nested_call = true;\n                         self.check_ty(cx, ty, context);\n-                        if let Some(ref params) = seg.args {\n+                        if let Some(params) = seg.args {\n                             for ty in params.args.iter().filter_map(|arg| match arg {\n                                 GenericArg::Type(ty) => Some(ty),\n                                 _ => None,\n@@ -430,10 +428,10 @@ impl Types {\n             TyKind::Rptr(ref lt, ref mut_ty) => {\n                 context.is_nested_call = true;\n                 if !borrowed_box::check(cx, hir_ty, lt, mut_ty) {\n-                    self.check_ty(cx, &mut_ty.ty, context);\n+                    self.check_ty(cx, mut_ty.ty, context);\n                 }\n             },\n-            TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => {\n+            TyKind::Slice(ty) | TyKind::Array(ty, _) | TyKind::Ptr(MutTy { ty, .. }) => {\n                 context.is_nested_call = true;\n                 self.check_ty(cx, ty, context)\n             },"}, {"sha": "d8c4b67520d116d73eb2cd62e3acee2edce8b402", "filename": "clippy_lints/src/types/type_complexity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftypes%2Ftype_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftypes%2Ftype_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Ftype_complexity.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -48,9 +48,9 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n             TyKind::Path(..) | TyKind::Slice(..) | TyKind::Tup(..) | TyKind::Array(..) => (10 * self.nest, 1),\n \n             // function types bring a lot of overhead\n-            TyKind::BareFn(ref bare) if bare.abi == Abi::Rust => (50 * self.nest, 1),\n+            TyKind::BareFn(bare) if bare.abi == Abi::Rust => (50 * self.nest, 1),\n \n-            TyKind::TraitObject(ref param_bounds, _, _) => {\n+            TyKind::TraitObject(param_bounds, _, _) => {\n                 let has_lifetime_parameters = param_bounds.iter().any(|bound| {\n                     bound\n                         .bound_generic_params"}, {"sha": "0fa75f8f0a9be3e7c06632da3bd8bb0a7988fe37", "filename": "clippy_lints/src/types/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftypes%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftypes%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Futils.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -7,7 +7,7 @@ use rustc_span::source_map::Span;\n pub(super) fn match_borrows_parameter(_cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Span> {\n     let last = last_path_segment(qpath);\n     if_chain! {\n-        if let Some(ref params) = last.args;\n+        if let Some(params) = last.args;\n         if !params.parenthesized;\n         if let Some(ty) = params.args.iter().find_map(|arg| match arg {\n             GenericArg::Type(ty) => Some(ty),"}, {"sha": "7a444174626f47378e020cf6459a90c717c03565", "filename": "clippy_lints/src/types/vec_box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -22,7 +22,7 @@ pub(super) fn check(\n     if cx.tcx.is_diagnostic_item(sym::vec_type, def_id) {\n         if_chain! {\n             // Get the _ part of Vec<_>\n-            if let Some(ref last) = last_path_segment(qpath).args;\n+            if let Some(last) = last_path_segment(qpath).args;\n             if let Some(ty) = last.args.iter().find_map(|arg| match arg {\n                 GenericArg::Type(ty) => Some(ty),\n                 _ => None,\n@@ -33,7 +33,7 @@ pub(super) fn check(\n             if let Some(def_id) = res.opt_def_id();\n             if Some(def_id) == cx.tcx.lang_items().owned_box();\n             // At this point, we know ty is Box<T>, now get T\n-            if let Some(ref last) = last_path_segment(ty_qpath).args;\n+            if let Some(last) = last_path_segment(ty_qpath).args;\n             if let Some(boxed_ty) = last.args.iter().find_map(|arg| match arg {\n                 GenericArg::Type(ty) => Some(ty),\n                 _ => None,"}, {"sha": "f4f5e1233e3512ec62ac53e1cbe489c9cc836708", "filename": "clippy_lints/src/undropped_manually_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundropped_manually_drops.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -35,7 +35,7 @@ declare_lint_pass!(UndroppedManuallyDrops => [UNDROPPED_MANUALLY_DROPS]);\n \n impl LateLintPass<'tcx> for UndroppedManuallyDrops {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(ref args) = match_function_call(cx, expr, &paths::DROP) {\n+        if let Some(args) = match_function_call(cx, expr, &paths::DROP) {\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n             if is_type_lang_item(cx, ty, lang_items::LangItem::ManuallyDrop) {\n                 span_lint_and_help("}, {"sha": "47b95b18ffb763994a2141fc8356339b35e5f861", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -138,7 +138,7 @@ fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Spa\n \n impl<'tcx> LateLintPass<'tcx> for UnitReturnExpectingOrd {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::MethodCall(_, _, ref args, _) = expr.kind {\n+        if let ExprKind::MethodCall(_, _, args, _) = expr.kind {\n             let arg_indices = get_args_to_check(cx, expr);\n             for (i, trait_name) in arg_indices {\n                 if i < args.len() {"}, {"sha": "fad647dfb2662ee4f380670e1c17f38a253d78fb", "filename": "clippy_lints/src/unit_types/let_unit_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -9,8 +9,8 @@ use rustc_middle::lint::in_external_macro;\n use super::LET_UNIT_VALUE;\n \n pub(super) fn check(cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n-    if let StmtKind::Local(ref local) = stmt.kind {\n-        if cx.typeck_results().pat_ty(&local.pat).is_unit() {\n+    if let StmtKind::Local(local) = stmt.kind {\n+        if cx.typeck_results().pat_ty(local.pat).is_unit() {\n             if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n                 return;\n             }"}, {"sha": "57be2d2f674cfdc2fa25bbb0fb826b2173fa2759", "filename": "clippy_lints/src/unit_types/unit_arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -54,7 +54,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n     use rustc_span::hygiene::DesugaringKind;\n-    if let ExprKind::Call(ref callee, _) = expr.kind {\n+    if let ExprKind::Call(callee, _) = expr.kind {\n         callee.span.is_desugaring(DesugaringKind::QuestionMark)\n     } else {\n         false"}, {"sha": "85257f3113cb774adc43f326707c0182b1eac616", "filename": "clippy_lints/src/unit_types/unit_cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -9,7 +9,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if expr.span.from_expansion() {\n         if let Some(callee) = expr.span.source_callee() {\n             if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n-                if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n+                if let ExprKind::Binary(ref cmp, left, _) = expr.kind {\n                     let op = cmp.node;\n                     if op.is_comparison() && cx.typeck_results().expr_ty(left).is_unit() {\n                         let result = match &*symbol.as_str() {\n@@ -34,7 +34,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         return;\n     }\n \n-    if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n+    if let ExprKind::Binary(ref cmp, left, _) = expr.kind {\n         let op = cmp.node;\n         if op.is_comparison() && cx.typeck_results().expr_ty(left).is_unit() {\n             let result = match op {"}, {"sha": "9a3750b2356bcae03de90b93db607621584c947c", "filename": "clippy_lints/src/unit_types/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funit_types%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funit_types%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Futils.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -1,5 +1,5 @@\n use rustc_hir::{Expr, ExprKind};\n \n pub(super) fn is_unit_literal(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Tup(ref slice) if slice.is_empty())\n+    matches!(expr.kind, ExprKind::Tup(slice) if slice.is_empty())\n }"}, {"sha": "9cca05b1f1a650744d698639616abe322f72a187", "filename": "clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnamed_address.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -77,7 +77,7 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         if_chain! {\n-            if let ExprKind::Binary(binop, ref left, ref right) = expr.kind;\n+            if let ExprKind::Binary(binop, left, right) = expr.kind;\n             if is_comparison(binop.node);\n             if is_trait_ptr(cx, left) && is_trait_ptr(cx, right);\n             then {\n@@ -93,7 +93,7 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         if_chain! {\n-            if let ExprKind::Call(ref func, [ref _left, ref _right]) = expr.kind;\n+            if let ExprKind::Call(func, [ref _left, ref _right]) = expr.kind;\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n             if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::PTR_EQ) ||\n@@ -114,7 +114,7 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         if_chain! {\n-            if let ExprKind::Binary(binop, ref left, ref right) = expr.kind;\n+            if let ExprKind::Binary(binop, left, right) = expr.kind;\n             if is_comparison(binop.node);\n             if cx.typeck_results().expr_ty_adjusted(left).is_fn_ptr();\n             if cx.typeck_results().expr_ty_adjusted(right).is_fn_ptr();"}, {"sha": "03711eb5b65e8d9572453cf473eef3c570cac9ac", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -187,15 +187,15 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n         if method_path.ident.name == sym::cmp;\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n-                &cx,\n-                &left_expr,\n-                &left_ident,\n-                &right_expr,\n-                &right_ident\n+                cx,\n+                left_expr,\n+                left_ident,\n+                right_expr,\n+                right_ident\n             ) {\n-                (Sugg::hir(cx, &left_expr, \"..\").to_string(), left_ident.name.to_string(), false)\n-            } else if mirrored_exprs(&cx, &left_expr, &right_ident, &right_expr, &left_ident) {\n-                (Sugg::hir(cx, &left_expr, \"..\").to_string(), right_ident.name.to_string(), true)\n+                (Sugg::hir(cx, left_expr, \"..\").to_string(), left_ident.name.to_string(), false)\n+            } else if mirrored_exprs(cx, left_expr, right_ident, right_expr, left_ident) {\n+                (Sugg::hir(cx, left_expr, \"..\").to_string(), right_ident.name.to_string(), true)\n             } else {\n                 return None;\n             };"}, {"sha": "5bb417cb1be4b4d40a2cc04a3ca58516c442a193", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n             if_chain! {\n                 if !in_macro(ret_expr.span);\n                 // Check if a function call.\n-                if let ExprKind::Call(ref func, ref args) = ret_expr.kind;\n+                if let ExprKind::Call(func, args) = ret_expr.kind;\n                 // Get the Path of the function call.\n                 if let ExprKind::Path(ref qpath) = func.kind;\n                 // Check if OPTION_SOME or RESULT_OK, depending on return type."}, {"sha": "024ab03fd418ed02bcbfb3d4201898122ddad8f7", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -36,13 +36,13 @@ declare_lint_pass!(UnusedIoAmount => [UNUSED_IO_AMOUNT]);\n impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n     fn check_stmt(&mut self, cx: &LateContext<'_>, s: &hir::Stmt<'_>) {\n         let expr = match s.kind {\n-            hir::StmtKind::Semi(ref expr) | hir::StmtKind::Expr(ref expr) => &**expr,\n+            hir::StmtKind::Semi(expr) | hir::StmtKind::Expr(expr) => expr,\n             _ => return,\n         };\n \n         match expr.kind {\n-            hir::ExprKind::Match(ref res, _, _) if is_try(expr).is_some() => {\n-                if let hir::ExprKind::Call(ref func, ref args) = res.kind {\n+            hir::ExprKind::Match(res, _, _) if is_try(expr).is_some() => {\n+                if let hir::ExprKind::Call(func, args) = res.kind {\n                     if matches!(\n                         func.kind,\n                         hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::TryIntoResult, _))\n@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n                 }\n             },\n \n-            hir::ExprKind::MethodCall(ref path, _, ref args, _) => match &*path.ident.as_str() {\n+            hir::ExprKind::MethodCall(path, _, args, _) => match &*path.ident.as_str() {\n                 \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                     check_method_call(cx, &args[0], expr);\n                 },\n@@ -67,7 +67,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n }\n \n fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n-    if let hir::ExprKind::MethodCall(ref path, _, _, _) = call.kind {\n+    if let hir::ExprKind::MethodCall(path, _, _, _) = call.kind {\n         let symbol = &*path.ident.as_str();\n         let read_trait = match_trait_method(cx, call, &paths::IO_READ);\n         let write_trait = match_trait_method(cx, call, &paths::IO_WRITE);"}, {"sha": "ce2d0b3ab2f24962599d2ca957d5564641a2e193", "filename": "clippy_lints/src/unused_unit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_unit.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -45,7 +45,7 @@ impl EarlyLintPass for UnusedUnit {\n \n     fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         if_chain! {\n-            if let Some(ref stmt) = block.stmts.last();\n+            if let Some(stmt) = block.stmts.last();\n             if let ast::StmtKind::Expr(ref expr) = stmt.kind;\n             if is_unit_expr(expr) && !stmt.span.from_expansion();\n             then {"}, {"sha": "d4efee56efff53053a6c17a28db18a35298ca38f", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -166,8 +166,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let ExprKind::MethodCall(ref method_name, _, ref args, _) = expr.kind;\n-                if let ExprKind::Path(QPath::Resolved(None, ref path)) = args[0].kind;\n+                if let ExprKind::MethodCall(method_name, _, args, _) = expr.kind;\n+                if let ExprKind::Path(QPath::Resolved(None, path)) = args[0].kind;\n                 if [sym::unwrap, sym!(unwrap_err)].contains(&method_name.ident.name);\n                 let call_to_unwrap = method_name.ident.name == sym::unwrap;\n                 if let Some(unwrappable) = self.unwrappables.iter()"}, {"sha": "c6a3c58a9a2a45c391f7191e93c1287e55779965", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 of_trait,\n                 ..\n             }) => {\n-                let should_check = if let TyKind::Path(QPath::Resolved(_, ref item_path)) = hir_self_ty.kind {\n+                let should_check = if let TyKind::Path(QPath::Resolved(_, item_path)) = hir_self_ty.kind {\n                     let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n                     parameters.as_ref().map_or(true, |params| {\n                         !params.parenthesized && !params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n@@ -197,7 +197,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 for (impl_hir_ty, trait_sem_ty) in impl_inputs_outputs.zip(trait_method_sig.inputs_and_output) {\n                     if trait_sem_ty.walk().any(|inner| inner == self_ty.into()) {\n                         let mut visitor = SkipTyCollector::default();\n-                        visitor.visit_ty(&impl_hir_ty);\n+                        visitor.visit_ty(impl_hir_ty);\n                         types_to_skip.extend(visitor.types_to_skip);\n                     }\n                 }\n@@ -333,7 +333,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 // unit enum variants (`Enum::A`)\n                 ExprKind::Path(qpath) => {\n                     if expr_ty_matches(cx, expr, self_ty) {\n-                        span_lint_on_qpath_resolved(cx, &qpath, true);\n+                        span_lint_on_qpath_resolved(cx, qpath, true);\n                     }\n                 },\n                 _ => (),"}, {"sha": "7edb280be73eabb6ff0eef97fb3160414d7525e9", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -53,17 +53,17 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n         }\n \n         match e.kind {\n-            ExprKind::Match(_, ref arms, MatchSource::TryDesugar) => {\n+            ExprKind::Match(_, arms, MatchSource::TryDesugar) => {\n                 let e = match arms[0].body.kind {\n-                    ExprKind::Ret(Some(ref e)) | ExprKind::Break(_, Some(ref e)) => e,\n+                    ExprKind::Ret(Some(e)) | ExprKind::Break(_, Some(e)) => e,\n                     _ => return,\n                 };\n-                if let ExprKind::Call(_, ref args) = e.kind {\n+                if let ExprKind::Call(_, args) = e.kind {\n                     self.try_desugar_arm.push(args[0].hir_id);\n                 }\n             },\n \n-            ExprKind::MethodCall(ref name, .., ref args, _) => {\n+            ExprKind::MethodCall(name, .., args, _) => {\n                 if match_trait_method(cx, e, &paths::INTO) && &*name.ident.as_str() == \"into\" {\n                     let a = cx.typeck_results().expr_ty(e);\n                     let b = cx.typeck_results().expr_ty(&args[0]);\n@@ -82,7 +82,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                 }\n                 if match_trait_method(cx, e, &paths::INTO_ITERATOR) && name.ident.name == sym::into_iter {\n                     if let Some(parent_expr) = get_parent_expr(cx, e) {\n-                        if let ExprKind::MethodCall(ref parent_name, ..) = parent_expr.kind {\n+                        if let ExprKind::MethodCall(parent_name, ..) = parent_expr.kind {\n                             if parent_name.ident.name != sym::into_iter {\n                                 return;\n                             }\n@@ -124,7 +124,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                 }\n             },\n \n-            ExprKind::Call(ref path, ref args) => {\n+            ExprKind::Call(path, args) => {\n                 if_chain! {\n                     if args.len() == 1;\n                     if let ExprKind::Path(ref qpath) = path.kind;"}, {"sha": "e70f8a09ebef1dd0aae22daccaab355ed176332b", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -203,13 +203,13 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n         print!(\"    if let ExprKind::\");\n         let current = format!(\"{}.kind\", self.current);\n         match expr.kind {\n-            ExprKind::Box(ref inner) => {\n+            ExprKind::Box(inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Box(ref {}) = {};\", inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            ExprKind::Array(ref elements) => {\n+            ExprKind::Array(elements) => {\n                 let elements_pat = self.next(\"elements\");\n                 println!(\"Array(ref {}) = {};\", elements_pat, current);\n                 println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n@@ -218,7 +218,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(element);\n                 }\n             },\n-            ExprKind::Call(ref func, ref args) => {\n+            ExprKind::Call(func, args) => {\n                 let func_pat = self.next(\"func\");\n                 let args_pat = self.next(\"args\");\n                 println!(\"Call(ref {}, ref {}) = {};\", func_pat, args_pat, current);\n@@ -230,14 +230,14 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(arg);\n                 }\n             },\n-            ExprKind::MethodCall(ref _method_name, ref _generics, ref _args, ref _fn_span) => {\n+            ExprKind::MethodCall(_method_name, ref _generics, _args, ref _fn_span) => {\n                 println!(\n                     \"MethodCall(ref method_name, ref generics, ref args, ref fn_span) = {};\",\n                     current\n                 );\n                 println!(\"    // unimplemented: `ExprKind::MethodCall` is not further destructured at the moment\");\n             },\n-            ExprKind::Tup(ref elements) => {\n+            ExprKind::Tup(elements) => {\n                 let elements_pat = self.next(\"elements\");\n                 println!(\"Tup(ref {}) = {};\", elements_pat, current);\n                 println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n@@ -246,7 +246,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(element);\n                 }\n             },\n-            ExprKind::Binary(ref op, ref left, ref right) => {\n+            ExprKind::Binary(ref op, left, right) => {\n                 let op_pat = self.next(\"op\");\n                 let left_pat = self.next(\"left\");\n                 let right_pat = self.next(\"right\");\n@@ -260,7 +260,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = right_pat;\n                 self.visit_expr(right);\n             },\n-            ExprKind::Unary(ref op, ref inner) => {\n+            ExprKind::Unary(ref op, inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Unary(UnOp::{:?}, ref {}) = {};\", op, inner_pat, current);\n                 self.current = inner_pat;\n@@ -296,7 +296,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     },\n                 }\n             },\n-            ExprKind::Cast(ref expr, ref ty) => {\n+            ExprKind::Cast(expr, ty) => {\n                 let cast_pat = self.next(\"expr\");\n                 let cast_ty = self.next(\"cast_ty\");\n                 let qp_label = self.next(\"qp\");\n@@ -310,24 +310,24 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            ExprKind::Type(ref expr, ref _ty) => {\n+            ExprKind::Type(expr, _ty) => {\n                 let cast_pat = self.next(\"expr\");\n                 println!(\"Type(ref {}, _) = {};\", cast_pat, current);\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            ExprKind::Loop(ref body, _, desugaring, _) => {\n+            ExprKind::Loop(body, _, desugaring, _) => {\n                 let body_pat = self.next(\"body\");\n                 let des = loop_desugaring_name(desugaring);\n                 let label_pat = self.next(\"label\");\n                 println!(\"Loop(ref {}, ref {}, {}) = {};\", body_pat, label_pat, des, current);\n                 self.current = body_pat;\n                 self.visit_block(body);\n             },\n-            ExprKind::If(ref cond, ref then, ref opt_else) => {\n+            ExprKind::If(cond, then, ref opt_else) => {\n                 let cond_pat = self.next(\"cond\");\n                 let then_pat = self.next(\"then\");\n-                if let Some(ref else_) = *opt_else {\n+                if let Some(else_) = *opt_else {\n                     let else_pat = self.next(\"else_\");\n                     println!(\n                         \"If(ref {}, ref {}, Some(ref {})) = {};\",\n@@ -343,7 +343,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = then_pat;\n                 self.visit_expr(then);\n             },\n-            ExprKind::Match(ref expr, ref arms, desugaring) => {\n+            ExprKind::Match(expr, arms, desugaring) => {\n                 let des = desugaring_name(desugaring);\n                 let expr_pat = self.next(\"expr\");\n                 let arms_pat = self.next(\"arms\");\n@@ -353,18 +353,18 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"    if {}.len() == {};\", arms_pat, arms.len());\n                 for (i, arm) in arms.iter().enumerate() {\n                     self.current = format!(\"{}[{}].body\", arms_pat, i);\n-                    self.visit_expr(&arm.body);\n+                    self.visit_expr(arm.body);\n                     if let Some(ref guard) = arm.guard {\n                         let guard_pat = self.next(\"guard\");\n                         println!(\"    if let Some(ref {}) = {}[{}].guard;\", guard_pat, arms_pat, i);\n                         match guard {\n-                            hir::Guard::If(ref if_expr) => {\n+                            hir::Guard::If(if_expr) => {\n                                 let if_expr_pat = self.next(\"expr\");\n                                 println!(\"    if let Guard::If(ref {}) = {};\", if_expr_pat, guard_pat);\n                                 self.current = if_expr_pat;\n                                 self.visit_expr(if_expr);\n                             },\n-                            hir::Guard::IfLet(ref if_let_pat, ref if_let_expr) => {\n+                            hir::Guard::IfLet(if_let_pat, if_let_expr) => {\n                                 let if_let_pat_pat = self.next(\"pat\");\n                                 let if_let_expr_pat = self.next(\"expr\");\n                                 println!(\n@@ -379,26 +379,26 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                         }\n                     }\n                     self.current = format!(\"{}[{}].pat\", arms_pat, i);\n-                    self.visit_pat(&arm.pat);\n+                    self.visit_pat(arm.pat);\n                 }\n             },\n-            ExprKind::Closure(ref _capture_clause, ref _func, _, _, _) => {\n+            ExprKind::Closure(ref _capture_clause, _func, _, _, _) => {\n                 println!(\"Closure(ref capture_clause, ref func, _, _, _) = {};\", current);\n                 println!(\"    // unimplemented: `ExprKind::Closure` is not further destructured at the moment\");\n             },\n-            ExprKind::Yield(ref sub, _) => {\n+            ExprKind::Yield(sub, _) => {\n                 let sub_pat = self.next(\"sub\");\n                 println!(\"Yield(ref sub) = {};\", current);\n                 self.current = sub_pat;\n                 self.visit_expr(sub);\n             },\n-            ExprKind::Block(ref block, _) => {\n+            ExprKind::Block(block, _) => {\n                 let block_pat = self.next(\"block\");\n                 println!(\"Block(ref {}) = {};\", block_pat, current);\n                 self.current = block_pat;\n                 self.visit_block(block);\n             },\n-            ExprKind::Assign(ref target, ref value, _) => {\n+            ExprKind::Assign(target, value, _) => {\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n                 println!(\n@@ -410,7 +410,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             },\n-            ExprKind::AssignOp(ref op, ref target, ref value) => {\n+            ExprKind::AssignOp(ref op, target, value) => {\n                 let op_pat = self.next(\"op\");\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n@@ -424,15 +424,15 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             },\n-            ExprKind::Field(ref object, ref field_ident) => {\n+            ExprKind::Field(object, ref field_ident) => {\n                 let obj_pat = self.next(\"object\");\n                 let field_name_pat = self.next(\"field_name\");\n                 println!(\"Field(ref {}, ref {}) = {};\", obj_pat, field_name_pat, current);\n                 println!(\"    if {}.as_str() == {:?}\", field_name_pat, field_ident.as_str());\n                 self.current = obj_pat;\n                 self.visit_expr(object);\n             },\n-            ExprKind::Index(ref object, ref index) => {\n+            ExprKind::Index(object, index) => {\n                 let object_pat = self.next(\"object\");\n                 let index_pat = self.next(\"index\");\n                 println!(\"Index(ref {}, ref {}) = {};\", object_pat, index_pat, current);\n@@ -447,7 +447,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = path_pat;\n                 self.print_qpath(path);\n             },\n-            ExprKind::AddrOf(kind, mutability, ref inner) => {\n+            ExprKind::AddrOf(kind, mutability, inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\n                     \"AddrOf(BorrowKind::{:?}, Mutability::{:?}, ref {}) = {};\",\n@@ -458,7 +458,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n             },\n             ExprKind::Break(ref _destination, ref opt_value) => {\n                 let destination_pat = self.next(\"destination\");\n-                if let Some(ref value) = *opt_value {\n+                if let Some(value) = *opt_value {\n                     let value_pat = self.next(\"value\");\n                     println!(\"Break(ref {}, Some(ref {})) = {};\", destination_pat, value_pat, current);\n                     self.current = value_pat;\n@@ -474,7 +474,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 // FIXME: implement label printing\n             },\n             ExprKind::Ret(ref opt_value) => {\n-                if let Some(ref value) = *opt_value {\n+                if let Some(value) = *opt_value {\n                     let value_pat = self.next(\"value\");\n                     println!(\"Ret(Some(ref {})) = {};\", value_pat, current);\n                     self.current = value_pat;\n@@ -491,10 +491,10 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"LlvmInlineAsm(_) = {};\", current);\n                 println!(\"    // unimplemented: `ExprKind::LlvmInlineAsm` is not further destructured at the moment\");\n             },\n-            ExprKind::Struct(ref path, ref fields, ref opt_base) => {\n+            ExprKind::Struct(path, fields, ref opt_base) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n-                if let Some(ref base) = *opt_base {\n+                if let Some(base) = *opt_base {\n                     let base_pat = self.next(\"base\");\n                     println!(\n                         \"Struct(ref {}, ref {}, Some(ref {})) = {};\",\n@@ -516,7 +516,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = value_pat;\n             },\n             // FIXME: compute length (needs type info)\n-            ExprKind::Repeat(ref value, _) => {\n+            ExprKind::Repeat(value, _) => {\n                 let value_pat = self.next(\"value\");\n                 println!(\"Repeat(ref {}, _) = {};\", value_pat, current);\n                 println!(\"// unimplemented: repeat count check\");\n@@ -526,7 +526,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n             ExprKind::Err => {\n                 println!(\"Err = {}\", current);\n             },\n-            ExprKind::DropTemps(ref expr) => {\n+            ExprKind::DropTemps(expr) => {\n                 let expr_pat = self.next(\"expr\");\n                 println!(\"DropTemps(ref {}) = {};\", expr_pat, current);\n                 self.current = expr_pat;\n@@ -560,7 +560,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     BindingAnnotation::RefMut => \"BindingAnnotation::RefMut\",\n                 };\n                 let name_pat = self.next(\"name\");\n-                if let Some(ref sub) = *sub {\n+                if let Some(sub) = *sub {\n                     let sub_pat = self.next(\"sub\");\n                     println!(\n                         \"Binding({}, _, {}, Some(ref {})) = {};\",\n@@ -573,7 +573,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 }\n                 println!(\"    if {}.as_str() == \\\"{}\\\";\", name_pat, ident.as_str());\n             },\n-            PatKind::Struct(ref path, ref fields, ignore) => {\n+            PatKind::Struct(ref path, fields, ignore) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n                 println!(\n@@ -585,13 +585,13 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n                 println!(\"    // unimplemented: field checks\");\n             },\n-            PatKind::Or(ref fields) => {\n+            PatKind::Or(fields) => {\n                 let fields_pat = self.next(\"fields\");\n                 println!(\"Or(ref {}) = {};\", fields_pat, current);\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n                 println!(\"    // unimplemented: field checks\");\n             },\n-            PatKind::TupleStruct(ref path, ref fields, skip_pos) => {\n+            PatKind::TupleStruct(ref path, fields, skip_pos) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n                 println!(\n@@ -609,25 +609,25 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = path_pat;\n                 self.print_qpath(path);\n             },\n-            PatKind::Tuple(ref fields, skip_pos) => {\n+            PatKind::Tuple(fields, skip_pos) => {\n                 let fields_pat = self.next(\"fields\");\n                 println!(\"Tuple(ref {}, {:?}) = {};\", fields_pat, skip_pos, current);\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n                 println!(\"    // unimplemented: field checks\");\n             },\n-            PatKind::Box(ref pat) => {\n+            PatKind::Box(pat) => {\n                 let pat_pat = self.next(\"pat\");\n                 println!(\"Box(ref {}) = {};\", pat_pat, current);\n                 self.current = pat_pat;\n                 self.visit_pat(pat);\n             },\n-            PatKind::Ref(ref pat, muta) => {\n+            PatKind::Ref(pat, muta) => {\n                 let pat_pat = self.next(\"pat\");\n                 println!(\"Ref(ref {}, Mutability::{:?}) = {};\", pat_pat, muta, current);\n                 self.current = pat_pat;\n                 self.visit_pat(pat);\n             },\n-            PatKind::Lit(ref lit_expr) => {\n+            PatKind::Lit(lit_expr) => {\n                 let lit_expr_pat = self.next(\"lit_expr\");\n                 println!(\"Lit(ref {}) = {}\", lit_expr_pat, current);\n                 self.current = lit_expr_pat;\n@@ -645,10 +645,10 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = end_pat;\n                 walk_list!(self, visit_expr, end);\n             },\n-            PatKind::Slice(ref start, ref middle, ref end) => {\n+            PatKind::Slice(start, ref middle, end) => {\n                 let start_pat = self.next(\"start\");\n                 let end_pat = self.next(\"end\");\n-                if let Some(ref middle) = middle {\n+                if let Some(middle) = middle {\n                     let middle_pat = self.next(\"middle\");\n                     println!(\n                         \"Slice(ref {}, Some(ref {}), ref {}) = {};\",\n@@ -678,33 +678,33 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n         let current = format!(\"{}.kind\", self.current);\n         match s.kind {\n             // A local (let) binding:\n-            StmtKind::Local(ref local) => {\n+            StmtKind::Local(local) => {\n                 let local_pat = self.next(\"local\");\n                 println!(\"Local(ref {}) = {};\", local_pat, current);\n-                if let Some(ref init) = local.init {\n+                if let Some(init) = local.init {\n                     let init_pat = self.next(\"init\");\n                     println!(\"    if let Some(ref {}) = {}.init;\", init_pat, local_pat);\n                     self.current = init_pat;\n                     self.visit_expr(init);\n                 }\n                 self.current = format!(\"{}.pat\", local_pat);\n-                self.visit_pat(&local.pat);\n+                self.visit_pat(local.pat);\n             },\n             // An item binding:\n             StmtKind::Item(_) => {\n                 println!(\"Item(item_id) = {};\", current);\n             },\n \n             // Expr without trailing semi-colon (must have unit type):\n-            StmtKind::Expr(ref e) => {\n+            StmtKind::Expr(e) => {\n                 let e_pat = self.next(\"e\");\n                 println!(\"Expr(ref {}, _) = {}\", e_pat, current);\n                 self.current = e_pat;\n                 self.visit_expr(e);\n             },\n \n             // Expr with trailing semi-colon (may have any type):\n-            StmtKind::Semi(ref e) => {\n+            StmtKind::Semi(e) => {\n                 let e_pat = self.next(\"e\");\n                 println!(\"Semi(ref {}, _) = {}\", e_pat, current);\n                 self.current = e_pat;\n@@ -752,7 +752,7 @@ fn loop_desugaring_name(des: hir::LoopSource) -> &'static str {\n \n fn print_path(path: &QPath<'_>, first: &mut bool) {\n     match *path {\n-        QPath::Resolved(_, ref path) => {\n+        QPath::Resolved(_, path) => {\n             for segment in path.segments {\n                 if *first {\n                     *first = false;\n@@ -762,7 +762,7 @@ fn print_path(path: &QPath<'_>, first: &mut bool) {\n                 print!(\"{:?}\", segment.ident.as_str());\n             }\n         },\n-        QPath::TypeRelative(ref ty, ref segment) => match ty.kind {\n+        QPath::TypeRelative(ty, segment) => match ty.kind {\n             hir::TyKind::Path(ref inner_path) => {\n                 print_path(inner_path, first);\n                 if *first {"}, {"sha": "32d34e8d31eada4bf93cf702d57d418b5565be25", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n         match item.vis.node {\n             hir::VisibilityKind::Public => println!(\"public\"),\n             hir::VisibilityKind::Crate(_) => println!(\"visible crate wide\"),\n-            hir::VisibilityKind::Restricted { ref path, .. } => println!(\n+            hir::VisibilityKind::Restricted { path, .. } => println!(\n                 \"visible in module `{}`\",\n                 rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(path, false))\n             ),\n@@ -99,31 +99,31 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n         if !has_attr(cx.sess(), cx.tcx.hir().attrs(arm.hir_id)) {\n             return;\n         }\n-        print_pat(cx, &arm.pat, 1);\n+        print_pat(cx, arm.pat, 1);\n         if let Some(ref guard) = arm.guard {\n             println!(\"guard:\");\n             print_guard(cx, guard, 1);\n         }\n         println!(\"body:\");\n-        print_expr(cx, &arm.body, 1);\n+        print_expr(cx, arm.body, 1);\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n         if !has_attr(cx.sess(), cx.tcx.hir().attrs(stmt.hir_id)) {\n             return;\n         }\n         match stmt.kind {\n-            hir::StmtKind::Local(ref local) => {\n+            hir::StmtKind::Local(local) => {\n                 println!(\"local variable of type {}\", cx.typeck_results().node_type(local.hir_id));\n                 println!(\"pattern:\");\n-                print_pat(cx, &local.pat, 0);\n-                if let Some(ref e) = local.init {\n+                print_pat(cx, local.pat, 0);\n+                if let Some(e) = local.init {\n                     println!(\"init expression:\");\n                     print_expr(cx, e, 0);\n                 }\n             },\n             hir::StmtKind::Item(_) => println!(\"item decl\"),\n-            hir::StmtKind::Expr(ref e) | hir::StmtKind::Semi(ref e) => print_expr(cx, e, 0),\n+            hir::StmtKind::Expr(e) | hir::StmtKind::Semi(e) => print_expr(cx, e, 0),\n         }\n     }\n     // fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx\n@@ -151,7 +151,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n         cx.typeck_results().adjustments().get(expr.hir_id)\n     );\n     match expr.kind {\n-        hir::ExprKind::Box(ref e) => {\n+        hir::ExprKind::Box(e) => {\n             println!(\"{}Box\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n@@ -161,7 +161,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprKind::Call(ref func, args) => {\n+        hir::ExprKind::Call(func, args) => {\n             println!(\"{}Call\", ind);\n             println!(\"{}function:\", ind);\n             print_expr(cx, func, indent + 1);\n@@ -170,7 +170,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprKind::MethodCall(ref path, _, args, _) => {\n+        hir::ExprKind::MethodCall(path, _, args, _) => {\n             println!(\"{}MethodCall\", ind);\n             println!(\"{}method name: {}\", ind, path.ident.name);\n             for arg in args {\n@@ -183,15 +183,15 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n+        hir::ExprKind::Binary(op, lhs, rhs) => {\n             println!(\"{}Binary\", ind);\n             println!(\"{}op: {:?}\", ind, op.node);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprKind::Unary(op, ref inner) => {\n+        hir::ExprKind::Unary(op, inner) => {\n             println!(\"{}Unary\", ind);\n             println!(\"{}op: {:?}\", ind, op);\n             print_expr(cx, inner, indent + 1);\n@@ -200,29 +200,29 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n             println!(\"{}Lit\", ind);\n             println!(\"{}{:?}\", ind, lit);\n         },\n-        hir::ExprKind::Cast(ref e, ref target) => {\n+        hir::ExprKind::Cast(e, target) => {\n             println!(\"{}Cast\", ind);\n             print_expr(cx, e, indent + 1);\n             println!(\"{}target type: {:?}\", ind, target);\n         },\n-        hir::ExprKind::Type(ref e, ref target) => {\n+        hir::ExprKind::Type(e, target) => {\n             println!(\"{}Type\", ind);\n             print_expr(cx, e, indent + 1);\n             println!(\"{}target type: {:?}\", ind, target);\n         },\n         hir::ExprKind::Loop(..) => {\n             println!(\"{}Loop\", ind);\n         },\n-        hir::ExprKind::If(ref cond, _, ref else_opt) => {\n+        hir::ExprKind::If(cond, _, ref else_opt) => {\n             println!(\"{}If\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, cond, indent + 1);\n-            if let Some(ref els) = *else_opt {\n+            if let Some(els) = *else_opt {\n                 println!(\"{}else:\", ind);\n                 print_expr(cx, els, indent + 1);\n             }\n         },\n-        hir::ExprKind::Match(ref cond, _, ref source) => {\n+        hir::ExprKind::Match(cond, _, ref source) => {\n             println!(\"{}Match\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, cond, indent + 1);\n@@ -232,72 +232,72 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n             println!(\"{}Closure\", ind);\n             println!(\"{}clause: {:?}\", ind, clause);\n         },\n-        hir::ExprKind::Yield(ref sub, _) => {\n+        hir::ExprKind::Yield(sub, _) => {\n             println!(\"{}Yield\", ind);\n             print_expr(cx, sub, indent + 1);\n         },\n         hir::ExprKind::Block(_, _) => {\n             println!(\"{}Block\", ind);\n         },\n-        hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+        hir::ExprKind::Assign(lhs, rhs, _) => {\n             println!(\"{}Assign\", ind);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprKind::AssignOp(ref binop, ref lhs, ref rhs) => {\n+        hir::ExprKind::AssignOp(ref binop, lhs, rhs) => {\n             println!(\"{}AssignOp\", ind);\n             println!(\"{}op: {:?}\", ind, binop.node);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprKind::Field(ref e, ident) => {\n+        hir::ExprKind::Field(e, ident) => {\n             println!(\"{}Field\", ind);\n             println!(\"{}field name: {}\", ind, ident.name);\n             println!(\"{}struct expr:\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n-        hir::ExprKind::Index(ref arr, ref idx) => {\n+        hir::ExprKind::Index(arr, idx) => {\n             println!(\"{}Index\", ind);\n             println!(\"{}array expr:\", ind);\n             print_expr(cx, arr, indent + 1);\n             println!(\"{}index expr:\", ind);\n             print_expr(cx, idx, indent + 1);\n         },\n-        hir::ExprKind::Path(hir::QPath::Resolved(ref ty, ref path)) => {\n+        hir::ExprKind::Path(hir::QPath::Resolved(ref ty, path)) => {\n             println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n-        hir::ExprKind::Path(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+        hir::ExprKind::Path(hir::QPath::TypeRelative(ty, seg)) => {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n         hir::ExprKind::Path(hir::QPath::LangItem(lang_item, ..)) => {\n             println!(\"{}Lang Item Path, {:?}\", ind, lang_item.name());\n         },\n-        hir::ExprKind::AddrOf(kind, ref muta, ref e) => {\n+        hir::ExprKind::AddrOf(kind, ref muta, e) => {\n             println!(\"{}AddrOf\", ind);\n             println!(\"kind: {:?}\", kind);\n             println!(\"mutability: {:?}\", muta);\n             print_expr(cx, e, indent + 1);\n         },\n         hir::ExprKind::Break(_, ref e) => {\n             println!(\"{}Break\", ind);\n-            if let Some(ref e) = *e {\n+            if let Some(e) = *e {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n         hir::ExprKind::Continue(_) => println!(\"{}Again\", ind),\n         hir::ExprKind::Ret(ref e) => {\n             println!(\"{}Ret\", ind);\n-            if let Some(ref e) = *e {\n+            if let Some(e) = *e {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprKind::InlineAsm(ref asm) => {\n+        hir::ExprKind::InlineAsm(asm) => {\n             println!(\"{}InlineAsm\", ind);\n             println!(\"{}template: {}\", ind, InlineAsmTemplatePiece::to_string(asm.template));\n             println!(\"{}options: {:?}\", ind, asm.options);\n@@ -322,7 +322,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 }\n             }\n         },\n-        hir::ExprKind::LlvmInlineAsm(ref asm) => {\n+        hir::ExprKind::LlvmInlineAsm(asm) => {\n             let inputs = &asm.inputs_exprs;\n             let outputs = &asm.outputs_exprs;\n             println!(\"{}LlvmInlineAsm\", ind);\n@@ -335,14 +335,14 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprKind::Struct(ref path, fields, ref base) => {\n+        hir::ExprKind::Struct(path, fields, ref base) => {\n             println!(\"{}Struct\", ind);\n             println!(\"{}path: {:?}\", ind, path);\n             for field in fields {\n                 println!(\"{}field \\\"{}\\\":\", ind, field.ident.name);\n-                print_expr(cx, &field.expr, indent + 1);\n+                print_expr(cx, field.expr, indent + 1);\n             }\n-            if let Some(ref base) = *base {\n+            if let Some(base) = *base {\n                 println!(\"{}base:\", ind);\n                 print_expr(cx, base, indent + 1);\n             }\n@@ -352,7 +352,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n             println!(\"{}anon_const:\", ind);\n             print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1);\n         },\n-        hir::ExprKind::Repeat(ref val, ref anon_const) => {\n+        hir::ExprKind::Repeat(val, ref anon_const) => {\n             println!(\"{}Repeat\", ind);\n             println!(\"{}value:\", ind);\n             print_expr(cx, val, indent + 1);\n@@ -362,7 +362,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n         hir::ExprKind::Err => {\n             println!(\"{}Err\", ind);\n         },\n-        hir::ExprKind::DropTemps(ref e) => {\n+        hir::ExprKind::DropTemps(e) => {\n             println!(\"{}DropTemps\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n@@ -375,7 +375,7 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n     match item.vis.node {\n         hir::VisibilityKind::Public => println!(\"public\"),\n         hir::VisibilityKind::Crate(_) => println!(\"visible crate wide\"),\n-        hir::VisibilityKind::Restricted { ref path, .. } => println!(\n+        hir::VisibilityKind::Restricted { path, .. } => println!(\n             \"visible in module `{}`\",\n             rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(path, false))\n         ),\n@@ -395,7 +395,7 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n                 println!(\"weird extern crate without a crate id\");\n             }\n         },\n-        hir::ItemKind::Use(ref path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n+        hir::ItemKind::Use(path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n         hir::ItemKind::Static(..) => println!(\"static item of type {:#?}\", cx.tcx.type_of(did)),\n         hir::ItemKind::Const(..) => println!(\"const item of type {:#?}\", cx.tcx.type_of(did)),\n         hir::ItemKind::Fn(..) => {\n@@ -404,7 +404,7 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n         },\n         hir::ItemKind::Mod(..) => println!(\"module\"),\n         hir::ItemKind::ForeignMod { abi, .. } => println!(\"foreign module with abi: {}\", abi),\n-        hir::ItemKind::GlobalAsm(ref asm) => println!(\"global asm: {:?}\", asm),\n+        hir::ItemKind::GlobalAsm(asm) => println!(\"global asm: {:?}\", asm),\n         hir::ItemKind::TyAlias(..) => {\n             println!(\"type alias for {:?}\", cx.tcx.type_of(did));\n         },\n@@ -454,7 +454,7 @@ fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n             println!(\"{}Binding\", ind);\n             println!(\"{}mode: {:?}\", ind, mode);\n             println!(\"{}name: {}\", ind, ident.name);\n-            if let Some(ref inner) = *inner {\n+            if let Some(inner) = *inner {\n                 println!(\"{}inner:\", ind);\n                 print_pat(cx, inner, indent + 1);\n             }\n@@ -479,7 +479,7 @@ fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n                 if field.is_shorthand {\n                     println!(\"{}  in shorthand notation\", ind);\n                 }\n-                print_pat(cx, &field.pat, indent + 1);\n+                print_pat(cx, field.pat, indent + 1);\n             }\n         },\n         hir::PatKind::TupleStruct(ref path, fields, opt_dots_position) => {\n@@ -496,11 +496,11 @@ fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n                 print_pat(cx, field, indent + 1);\n             }\n         },\n-        hir::PatKind::Path(hir::QPath::Resolved(ref ty, ref path)) => {\n+        hir::PatKind::Path(hir::QPath::Resolved(ref ty, path)) => {\n             println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n-        hir::PatKind::Path(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+        hir::PatKind::Path(hir::QPath::TypeRelative(ty, seg)) => {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n@@ -516,16 +516,16 @@ fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n                 print_pat(cx, field, indent + 1);\n             }\n         },\n-        hir::PatKind::Box(ref inner) => {\n+        hir::PatKind::Box(inner) => {\n             println!(\"{}Box\", ind);\n             print_pat(cx, inner, indent + 1);\n         },\n-        hir::PatKind::Ref(ref inner, ref muta) => {\n+        hir::PatKind::Ref(inner, ref muta) => {\n             println!(\"{}Ref\", ind);\n             println!(\"{}mutability: {:?}\", ind, muta);\n             print_pat(cx, inner, indent + 1);\n         },\n-        hir::PatKind::Lit(ref e) => {\n+        hir::PatKind::Lit(e) => {\n             println!(\"{}Lit\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n@@ -549,7 +549,7 @@ fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n                 print_pat(cx, pat, indent + 1);\n             }\n             println!(\"i:\");\n-            if let Some(ref pat) = *range {\n+            if let Some(pat) = *range {\n                 print_pat(cx, pat, indent + 1);\n             }\n             println!(\"[y, z]:\");"}, {"sha": "cf8039d6059b64a287483aedf4c2a2034fc37fc4", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -353,12 +353,12 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n             return;\n         }\n \n-        if let hir::ItemKind::Static(ref ty, Mutability::Not, body_id) = item.kind {\n+        if let hir::ItemKind::Static(ty, Mutability::Not, body_id) = item.kind {\n             if is_lint_ref_type(cx, ty) {\n                 let expr = &cx.tcx.hir().body(body_id).value;\n                 if_chain! {\n-                    if let ExprKind::AddrOf(_, _, ref inner_exp) = expr.kind;\n-                    if let ExprKind::Struct(_, ref fields, _) = inner_exp.kind;\n+                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind;\n+                    if let ExprKind::Struct(_, fields, _) = inner_exp.kind;\n                     let field = fields\n                         .iter()\n                         .find(|f| f.ident.as_str() == \"desc\")\n@@ -385,7 +385,7 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n         {\n             if let hir::ItemKind::Impl(hir::Impl {\n                 of_trait: None,\n-                items: ref impl_item_refs,\n+                items: impl_item_refs,\n                 ..\n             }) = item.kind\n             {\n@@ -437,7 +437,7 @@ fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &Ty<'_>) -> bool {\n     if let TyKind::Rptr(\n         _,\n         MutTy {\n-            ty: ref inner,\n+            ty: inner,\n             mutbl: Mutability::Not,\n         },\n     ) = ty.kind\n@@ -498,7 +498,7 @@ impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n             let fn_name = path.ident;\n             if let Some(sugg) = self.map.get(&*fn_name.as_str());\n             let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n@@ -577,7 +577,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n         }\n \n         if_chain! {\n-            if let ExprKind::Call(ref func, ref and_then_args) = expr.kind;\n+            if let ExprKind::Call(func, and_then_args) = expr.kind;\n             if let ExprKind::Path(ref path) = func.kind;\n             if match_qpath(path, &[\"span_lint_and_then\"]);\n             if and_then_args.len() == 5;\n@@ -587,7 +587,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             let stmts = &block.stmts;\n             if stmts.len() == 1 && block.expr.is_none();\n             if let StmtKind::Semi(only_expr) = &stmts[0].kind;\n-            if let ExprKind::MethodCall(ref ps, _, ref span_call_args, _) = &only_expr.kind;\n+            if let ExprKind::MethodCall(ps, _, span_call_args, _) = &only_expr.kind;\n             then {\n                 let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n                 let mut sle = SpanlessEq::new(cx).deny_side_effects();\n@@ -762,7 +762,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n             // Check if this is a call to utils::match_type()\n             if let ExprKind::Call(fn_path, [context, ty, ty_path]) = expr.kind;\n             if let ExprKind::Path(fn_qpath) = &fn_path.kind;\n-            if match_qpath(&fn_qpath, &[\"utils\", \"match_type\"]);\n+            if match_qpath(fn_qpath, &[\"utils\", \"match_type\"]);\n             // Extract the path to the matched type\n             if let Some(segments) = path_to_matched_type(cx, ty_path);\n             let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();"}, {"sha": "febd4b6ff7b3c1533c302487e5df914ebf5ae96a", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -49,7 +49,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n         if_chain! {\n             if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(expr).kind();\n             if let ty::Slice(..) = ty.kind();\n-            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, ref addressee) = expr.kind;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, addressee) = expr.kind;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n                 self.check_vec_macro(cx, &vec_args, mutability, expr.span);"}, {"sha": "5540e87405ff9d083e742933639bca476c505da9", "filename": "clippy_lints/src/vec_resize_to_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -30,7 +30,7 @@ declare_lint_pass!(VecResizeToZero => [VEC_RESIZE_TO_ZERO]);\n impl<'tcx> LateLintPass<'tcx> for VecResizeToZero {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let hir::ExprKind::MethodCall(path_segment, _, ref args, _) = expr.kind;\n+            if let hir::ExprKind::MethodCall(path_segment, _, args, _) = expr.kind;\n             if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n             if match_def_path(cx, method_def_id, &paths::VEC_RESIZE) && args.len() == 3;\n             if let ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = args[1].kind;"}, {"sha": "350b1cf25ff05723711f4fde5f4a368db19aceb7", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -31,7 +31,7 @@ impl<'tcx> LateLintPass<'tcx> for ZeroDiv {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // check for instances of 0.0/0.0\n         if_chain! {\n-            if let ExprKind::Binary(ref op, ref left, ref right) = expr.kind;\n+            if let ExprKind::Binary(ref op, left, right) = expr.kind;\n             if let BinOpKind::Div = op.node;\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would"}, {"sha": "f93f0047f514f5100536a77500a8a1082c48356b", "filename": "clippy_lints/src/zero_sized_map_values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/clippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_sized_map_values.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -50,7 +50,7 @@ impl LateLintPass<'_> for ZeroSizedMapValues {\n             if !in_trait_impl(cx, hir_ty.hir_id);\n             let ty = ty_from_hir_ty(cx, hir_ty);\n             if is_type_diagnostic_item(cx, ty, sym::hashmap_type) || match_type(cx, ty, &paths::BTREEMAP);\n-            if let Adt(_, ref substs) = ty.kind();\n+            if let Adt(_, substs) = ty.kind();\n             let ty = substs.type_at(1);\n             // Do this to prevent `layout_of` crashing, being unable to fully normalize `ty`.\n             if is_normalizable(cx, cx.param_env, ty);"}, {"sha": "fa0c5f01430b615ce7d2b46e5c713f45bb8992c0", "filename": "src/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -99,17 +99,17 @@ impl rustc_driver::Callbacks for ClippyCallbacks {\n         config.parse_sess_created = Some(Box::new(move |parse_sess| {\n             track_clippy_args(parse_sess, &clippy_args_var);\n         }));\n-        config.register_lints = Some(Box::new(move |sess, mut lint_store| {\n+        config.register_lints = Some(Box::new(move |sess, lint_store| {\n             // technically we're ~guaranteed that this is none but might as well call anything that\n             // is there already. Certainly it can't hurt.\n             if let Some(previous) = &previous {\n                 (previous)(sess, lint_store);\n             }\n \n-            let conf = clippy_lints::read_conf(&[], &sess);\n-            clippy_lints::register_plugins(&mut lint_store, &sess, &conf);\n-            clippy_lints::register_pre_expansion_lints(&mut lint_store);\n-            clippy_lints::register_renamed(&mut lint_store);\n+            let conf = clippy_lints::read_conf(&[], sess);\n+            clippy_lints::register_plugins(lint_store, sess, &conf);\n+            clippy_lints::register_pre_expansion_lints(lint_store);\n+            clippy_lints::register_renamed(lint_store);\n         }));\n \n         // FIXME: #4825; This is required, because Clippy lints that are based on MIR have to be\n@@ -191,7 +191,7 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     ];\n \n     for note in &xs {\n-        handler.note_without_error(&note);\n+        handler.note_without_error(note);\n     }\n \n     // If backtraces are enabled, also print the query stack"}, {"sha": "f4d354f0bf94240a97ab9753c61d82a0614be0b2", "filename": "tests/compile-test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -98,7 +98,7 @@ fn default_config() -> compiletest::Config {\n fn run_mode(cfg: &mut compiletest::Config) {\n     cfg.mode = TestMode::Ui;\n     cfg.src_base = Path::new(\"tests\").join(\"ui\");\n-    compiletest::run_tests(&cfg);\n+    compiletest::run_tests(cfg);\n }\n \n fn run_internal_tests(cfg: &mut compiletest::Config) {\n@@ -108,7 +108,7 @@ fn run_internal_tests(cfg: &mut compiletest::Config) {\n     }\n     cfg.mode = TestMode::Ui;\n     cfg.src_base = Path::new(\"tests\").join(\"ui-internal\");\n-    compiletest::run_tests(&cfg);\n+    compiletest::run_tests(cfg);\n }\n \n fn run_ui_toml(config: &mut compiletest::Config) {\n@@ -136,7 +136,7 @@ fn run_ui_toml(config: &mut compiletest::Config) {\n                     base: config.src_base.clone(),\n                     relative_dir: dir_path.file_name().unwrap().into(),\n                 };\n-                let test_name = compiletest::make_test_name(&config, &paths);\n+                let test_name = compiletest::make_test_name(config, &paths);\n                 let index = tests\n                     .iter()\n                     .position(|test| test.desc.name == test_name)\n@@ -150,10 +150,10 @@ fn run_ui_toml(config: &mut compiletest::Config) {\n     config.mode = TestMode::Ui;\n     config.src_base = Path::new(\"tests\").join(\"ui-toml\").canonicalize().unwrap();\n \n-    let tests = compiletest::make_tests(&config);\n+    let tests = compiletest::make_tests(config);\n \n     let manifest_dir = var(\"CARGO_MANIFEST_DIR\").unwrap_or_default();\n-    let res = run_tests(&config, tests);\n+    let res = run_tests(config, tests);\n     set_var(\"CARGO_MANIFEST_DIR\", &manifest_dir);\n     match res {\n         Ok(true) => {},\n@@ -221,7 +221,7 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n                         base: config.src_base.clone(),\n                         relative_dir: src_path.strip_prefix(&config.src_base).unwrap().into(),\n                     };\n-                    let test_name = compiletest::make_test_name(&config, &paths);\n+                    let test_name = compiletest::make_test_name(config, &paths);\n                     let index = tests\n                         .iter()\n                         .position(|test| test.desc.name == test_name)\n@@ -240,11 +240,11 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n     config.mode = TestMode::Ui;\n     config.src_base = Path::new(\"tests\").join(\"ui-cargo\").canonicalize().unwrap();\n \n-    let tests = compiletest::make_tests(&config);\n+    let tests = compiletest::make_tests(config);\n \n     let current_dir = env::current_dir().unwrap();\n     let conf_dir = var(\"CLIPPY_CONF_DIR\").unwrap_or_default();\n-    let res = run_tests(&config, &config.filters, tests);\n+    let res = run_tests(config, &config.filters, tests);\n     env::set_current_dir(current_dir).unwrap();\n     set_var(\"CLIPPY_CONF_DIR\", conf_dir);\n "}, {"sha": "4327f12c37c8eb82576eaff0d74cdf595194a93e", "filename": "tests/ui/borrow_interior_mutable_const/others.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -1,5 +1,9 @@\n #![warn(clippy::borrow_interior_mutable_const)]\n-#![allow(clippy::declare_interior_mutable_const, clippy::ref_in_deref)]\n+#![allow(\n+    clippy::declare_interior_mutable_const,\n+    clippy::ref_in_deref,\n+    clippy::needless_borrow\n+)]\n #![allow(const_item_mutation)]\n \n use std::borrow::Cow;"}, {"sha": "f146b97cf61161f0c96b320c8bc1c6759d09fa5f", "filename": "tests/ui/borrow_interior_mutable_const/others.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -1,5 +1,5 @@\n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:54:5\n+  --> $DIR/others.rs:58:5\n    |\n LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^\n@@ -8,103 +8,103 @@ LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:55:16\n+  --> $DIR/others.rs:59:16\n    |\n LL |     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n    |                ^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:58:22\n+  --> $DIR/others.rs:62:22\n    |\n LL |     let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n    |                      ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:59:25\n+  --> $DIR/others.rs:63:25\n    |\n LL |     let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n    |                         ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:60:27\n+  --> $DIR/others.rs:64:27\n    |\n LL |     let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n    |                           ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:61:26\n+  --> $DIR/others.rs:65:26\n    |\n LL |     let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n    |                          ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:72:14\n+  --> $DIR/others.rs:76:14\n    |\n LL |     let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:73:14\n+  --> $DIR/others.rs:77:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:74:19\n+  --> $DIR/others.rs:78:19\n    |\n LL |     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n    |                   ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:75:14\n+  --> $DIR/others.rs:79:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:76:13\n+  --> $DIR/others.rs:80:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:82:13\n+  --> $DIR/others.rs:86:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:87:5\n+  --> $DIR/others.rs:91:5\n    |\n LL |     CELL.set(2); //~ ERROR interior mutability\n    |     ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:88:16\n+  --> $DIR/others.rs:92:16\n    |\n LL |     assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n    |                ^^^^"}, {"sha": "542e69484276d47b96cc79c3ad382fd6270147a6", "filename": "tests/ui/collapsible_match2.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fcollapsible_match2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fcollapsible_match2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match2.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -1,5 +1,10 @@\n #![warn(clippy::collapsible_match)]\n-#![allow(clippy::needless_return, clippy::no_effect, clippy::single_match)]\n+#![allow(\n+    clippy::needless_return,\n+    clippy::no_effect,\n+    clippy::single_match,\n+    clippy::needless_borrow\n+)]\n \n fn lint_cases(opt_opt: Option<Option<u32>>, res_opt: Result<Option<u32>, String>) {\n     // if guards on outer match"}, {"sha": "ffef32d1fde9aac110ff74304c5d002d301a63e7", "filename": "tests/ui/collapsible_match2.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fcollapsible_match2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fcollapsible_match2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match2.stderr?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -1,5 +1,5 @@\n error: unnecessary nested match\n-  --> $DIR/collapsible_match2.rs:8:34\n+  --> $DIR/collapsible_match2.rs:13:34\n    |\n LL |               Ok(val) if make() => match val {\n    |  __________________________________^\n@@ -10,15 +10,15 @@ LL | |             },\n    |\n    = note: `-D clippy::collapsible-match` implied by `-D warnings`\n help: the outer pattern can be modified to include the inner pattern\n-  --> $DIR/collapsible_match2.rs:8:16\n+  --> $DIR/collapsible_match2.rs:13:16\n    |\n LL |             Ok(val) if make() => match val {\n    |                ^^^ replace this binding\n LL |                 Some(n) => foo(n),\n    |                 ^^^^^^^ with this pattern\n \n error: unnecessary nested match\n-  --> $DIR/collapsible_match2.rs:15:24\n+  --> $DIR/collapsible_match2.rs:20:24\n    |\n LL |               Ok(val) => match val {\n    |  ________________________^\n@@ -28,15 +28,15 @@ LL | |             },\n    | |_____________^\n    |\n help: the outer pattern can be modified to include the inner pattern\n-  --> $DIR/collapsible_match2.rs:15:16\n+  --> $DIR/collapsible_match2.rs:20:16\n    |\n LL |             Ok(val) => match val {\n    |                ^^^ replace this binding\n LL |                 Some(n) => foo(n),\n    |                 ^^^^^^^ with this pattern\n \n error: unnecessary nested match\n-  --> $DIR/collapsible_match2.rs:29:29\n+  --> $DIR/collapsible_match2.rs:34:29\n    |\n LL |                       $pat => match $e {\n    |  _____________________________^\n@@ -49,7 +49,7 @@ LL |           mac!(res_opt => Ok(val), val => Some(n), foo(n));\n    |           ------------------------------------------------- in this macro invocation\n    |\n help: the outer pattern can be modified to include the inner pattern\n-  --> $DIR/collapsible_match2.rs:41:28\n+  --> $DIR/collapsible_match2.rs:46:28\n    |\n LL |         mac!(res_opt => Ok(val), val => Some(n), foo(n));\n    |                            ^^^          ^^^^^^^ with this pattern\n@@ -58,7 +58,7 @@ LL |         mac!(res_opt => Ok(val), val => Some(n), foo(n));\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: unnecessary nested match\n-  --> $DIR/collapsible_match2.rs:46:20\n+  --> $DIR/collapsible_match2.rs:51:20\n    |\n LL |           Some(s) => match *s {\n    |  ____________________^\n@@ -68,15 +68,15 @@ LL | |         },\n    | |_________^\n    |\n help: the outer pattern can be modified to include the inner pattern\n-  --> $DIR/collapsible_match2.rs:46:14\n+  --> $DIR/collapsible_match2.rs:51:14\n    |\n LL |         Some(s) => match *s {\n    |              ^ replace this binding\n LL |             [n] => foo(n),\n    |             ^^^ with this pattern\n \n error: unnecessary nested match\n-  --> $DIR/collapsible_match2.rs:55:24\n+  --> $DIR/collapsible_match2.rs:60:24\n    |\n LL |           Some(ref s) => match &*s {\n    |  ________________________^\n@@ -86,7 +86,7 @@ LL | |         },\n    | |_________^\n    |\n help: the outer pattern can be modified to include the inner pattern\n-  --> $DIR/collapsible_match2.rs:55:14\n+  --> $DIR/collapsible_match2.rs:60:14\n    |\n LL |         Some(ref s) => match &*s {\n    |              ^^^^^ replace this binding"}, {"sha": "13e2b6c7a2e765a5a3d7269504368b6bc3bf8db0", "filename": "tests/ui/escape_analysis.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fescape_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fescape_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -101,7 +101,7 @@ fn warn_match() {\n     let x = box A;\n     match &x {\n         // not moved\n-        ref y => (),\n+        y => (),\n     }\n }\n \n@@ -111,7 +111,7 @@ fn nowarn_large_array() {\n     let x = box [1; 10000];\n     match &x {\n         // not moved\n-        ref y => (),\n+        y => (),\n     }\n }\n "}, {"sha": "cef71cf79d79721814cce022ec3ef1a736b31439", "filename": "tests/ui/implicit_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_clone.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -66,7 +66,7 @@ fn main() {\n     let _ = vec.to_vec();\n \n     let vec_ref = &vec;\n-    let _ = return_owned_from_slice(&vec_ref);\n+    let _ = return_owned_from_slice(vec_ref);\n     let _ = vec_ref.to_owned();\n     let _ = vec_ref.to_vec();\n "}, {"sha": "b77f17944d89a35a28a21bcf6d100750d98e8da4", "filename": "tests/ui/into_iter_on_ref.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Finto_iter_on_ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Finto_iter_on_ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finto_iter_on_ref.fixed?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(clippy::useless_vec)]\n+#![allow(clippy::useless_vec, clippy::needless_borrow)]\n #![warn(clippy::into_iter_on_ref)]\n \n struct X;"}, {"sha": "3854bb05af8fbfc463d73a5bf47bbb11d331c5e7", "filename": "tests/ui/into_iter_on_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finto_iter_on_ref.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(clippy::useless_vec)]\n+#![allow(clippy::useless_vec, clippy::needless_borrow)]\n #![warn(clippy::into_iter_on_ref)]\n \n struct X;"}, {"sha": "2df45c927d7169bdc987082bcc3e281c4c4f84b2", "filename": "tests/ui/ref_option_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fref_option_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fref_option_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fref_option_ref.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -9,7 +9,7 @@\n static THRESHOLD: i32 = 10;\n static REF_THRESHOLD: &Option<&i32> = &Some(&THRESHOLD);\n const CONST_THRESHOLD: &i32 = &10;\n-const REF_CONST: &Option<&i32> = &Some(&CONST_THRESHOLD);\n+const REF_CONST: &Option<&i32> = &Some(CONST_THRESHOLD);\n \n type RefOptRefU32<'a> = &'a Option<&'a u32>;\n type RefOptRef<'a, T> = &'a Option<&'a T>;"}, {"sha": "b61334758e85431abd23ef6c139913770ef24d67", "filename": "tests/ui/ref_option_ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fref_option_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fref_option_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fref_option_ref.stderr?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -9,7 +9,7 @@ LL | static REF_THRESHOLD: &Option<&i32> = &Some(&THRESHOLD);\n error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`\n   --> $DIR/ref_option_ref.rs:12:18\n    |\n-LL | const REF_CONST: &Option<&i32> = &Some(&CONST_THRESHOLD);\n+LL | const REF_CONST: &Option<&i32> = &Some(CONST_THRESHOLD);\n    |                  ^^^^^^^^^^^^^ help: try: `Option<&i32>`\n \n error: since `&` implements the `Copy` trait, `&Option<&T>` can be simplified to `Option<&T>`"}, {"sha": "f5f18169df2955047af0cfed6c71fdb7172ef9a1", "filename": "tests/ui/stable_sort_primitive.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fstable_sort_primitive.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fstable_sort_primitive.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstable_sort_primitive.fixed?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -20,7 +20,7 @@ fn main() {\n     // Negative examples: behavior changes if made unstable\n     let mut vec = vec![1, 3, 2];\n     vec.sort_by_key(|i| i / 2);\n-    vec.sort_by(|a, b| (a + b).cmp(&b));\n+    vec.sort_by(|&a, &b| (a + b).cmp(&b));\n     // negative examples - Not of a primitive type\n     let mut vec_of_complex = vec![String::from(\"hello\"), String::from(\"world!\")];\n     vec_of_complex.sort();"}, {"sha": "8149c5638e0f73c2c7766d16c3c880739b7f442c", "filename": "tests/ui/stable_sort_primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fce557669a0de230399cf8e6eee4f5307bf87b/tests%2Fui%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstable_sort_primitive.rs?ref=12fce557669a0de230399cf8e6eee4f5307bf87b", "patch": "@@ -20,7 +20,7 @@ fn main() {\n     // Negative examples: behavior changes if made unstable\n     let mut vec = vec![1, 3, 2];\n     vec.sort_by_key(|i| i / 2);\n-    vec.sort_by(|a, b| (a + b).cmp(&b));\n+    vec.sort_by(|&a, &b| (a + b).cmp(&b));\n     // negative examples - Not of a primitive type\n     let mut vec_of_complex = vec![String::from(\"hello\"), String::from(\"world!\")];\n     vec_of_complex.sort();"}]}