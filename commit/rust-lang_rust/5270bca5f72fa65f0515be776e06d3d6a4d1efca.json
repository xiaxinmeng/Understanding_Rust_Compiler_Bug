{"sha": "5270bca5f72fa65f0515be776e06d3d6a4d1efca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNzBiY2E1ZjcyZmE2NWYwNTE1YmU3NzZlMDZkM2Q2YTRkMWVmY2E=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-26T10:09:39Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-26T10:20:54Z"}, "message": "store macro def inside macro id\n\nThis solves the problem of \"macro expansion can't call into name\nresolution, because name resolution calls back into macro expansion\"\n\nBecause we store macro def as a part of call id, macro expansion just\nknows the def!", "tree": {"sha": "fa1b8b8ac66713ba29b676e1c2fdd4c4357f24ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa1b8b8ac66713ba29b676e1c2fdd4c4357f24ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5270bca5f72fa65f0515be776e06d3d6a4d1efca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5270bca5f72fa65f0515be776e06d3d6a4d1efca", "html_url": "https://github.com/rust-lang/rust/commit/5270bca5f72fa65f0515be776e06d3d6a4d1efca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5270bca5f72fa65f0515be776e06d3d6a4d1efca/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc94f3612583c5e960b334761ad0c18d328840ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc94f3612583c5e960b334761ad0c18d328840ea", "html_url": "https://github.com/rust-lang/rust/commit/dc94f3612583c5e960b334761ad0c18d328840ea"}], "stats": {"total": 192, "additions": 73, "deletions": 119}, "files": [{"sha": "790e2b80f7139e135ce3cc4b8eb8cd97b0e83fef", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=5270bca5f72fa65f0515be776e06d3d6a4d1efca", "patch": "@@ -76,7 +76,7 @@ impl Module {\n         import: ImportId,\n     ) -> TreeArc<ast::PathSegment> {\n         let (file_id, source) = self.definition_source(db);\n-        let (_, source_map) = db.raw_items_with_source_map(file_id.original_file(db));\n+        let (_, source_map) = db.raw_items_with_source_map(file_id);\n         source_map.get(&source, import)\n     }\n "}, {"sha": "6eb916149657a531e0d8496e02d8b0f20342ea96", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=5270bca5f72fa65f0515be776e06d3d6a4d1efca", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n-use ra_db::{SourceDatabase, salsa, FileId};\n+use ra_db::{SourceDatabase, salsa};\n \n use crate::{\n     HirFileId, SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n@@ -38,10 +38,13 @@ pub trait DefDatabase: SourceDatabase + AsRef<HirInterner> {\n     fn file_item(&self, source_item_id: SourceItemId) -> TreeArc<SyntaxNode>;\n \n     #[salsa::invoke(RawItems::raw_items_query)]\n-    fn raw_items(&self, file_id: FileId) -> Arc<RawItems>;\n+    fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n \n     #[salsa::invoke(RawItems::raw_items_with_source_map_query)]\n-    fn raw_items_with_source_map(&self, file_id: FileId) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n+    fn raw_items_with_source_map(\n+        &self,\n+        file_id: HirFileId,\n+    ) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n \n     #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n     fn crate_def_map(&self, krate: Crate) -> Arc<CrateDefMap>;"}, {"sha": "cf0566308f7732fbcaf655d0781713c27ee2e5ff", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=5270bca5f72fa65f0515be776e06d3d6a4d1efca", "patch": "@@ -7,6 +7,7 @@ use std::{\n use ra_db::{LocationInterner, FileId};\n use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, SyntaxNodePtr, ast};\n use ra_arena::{Arena, RawId, ArenaId, impl_arena_id};\n+use mbe::MacroRules;\n \n use crate::{\n     Module,\n@@ -100,10 +101,7 @@ fn parse_macro(db: &impl DefDatabase, macro_call_id: MacroCallId) -> Option<Tree\n     let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n     let (macro_arg, _) = macro_call.token_tree().and_then(mbe::ast_to_token_tree)?;\n \n-    let def_map = db.crate_def_map(loc.module.krate);\n-    let (krate, macro_id) = def_map.resolve_macro(macro_call_id)?;\n-    let def_map = db.crate_def_map(krate);\n-    let macro_rules = &def_map[macro_id];\n+    let macro_rules = macro_def_query(db, loc.def)?;\n     let tt = macro_rules.expand(&macro_arg).ok()?;\n     Some(mbe::token_tree_to_ast_item_list(&tt))\n }\n@@ -126,6 +124,22 @@ impl From<MacroCallId> for HirFileId {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) enum MacroDefId {\n+    MacroByExample { source_item_id: SourceItemId },\n+}\n+\n+fn macro_def_query(db: &impl DefDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n+    let syntax_node = match id {\n+        MacroDefId::MacroByExample { source_item_id } => db.file_item(source_item_id),\n+    };\n+    let macro_call = ast::MacroCall::cast(&syntax_node).unwrap();\n+    let arg = macro_call.token_tree()?;\n+    let (tt, _) = mbe::ast_to_token_tree(arg)?;\n+    let rules = MacroRules::parse(&tt).ok()?;\n+    Some(Arc::new(rules))\n+}\n+\n /// `MacroCallId` identifies a particular macro invocation, like\n /// `println!(\"Hello, {}\", world)`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -134,7 +148,7 @@ impl_arena_id!(MacroCallId);\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n-    pub(crate) module: Module,\n+    pub(crate) def: MacroDefId,\n     pub(crate) source_item_id: SourceItemId,\n }\n "}, {"sha": "93c11f271d6a31f988ba8b0150fffc5e6d828445", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=5270bca5f72fa65f0515be776e06d3d6a4d1efca", "patch": "@@ -63,7 +63,7 @@ use test_utils::tested_by;\n use crate::{\n     ModuleDef, Name, Crate, Module,\n     DefDatabase, Path, PathKind, HirFileId, Trait,\n-    ids::{SourceItemId, SourceFileItemId, MacroCallId},\n+    ids::{SourceItemId, SourceFileItemId, MacroCallId, MacroDefId},\n     diagnostics::DiagnosticSink,\n     nameres::diagnostics::DefDiagnostic,\n };\n@@ -85,7 +85,7 @@ pub struct CrateDefMap {\n     root: CrateModuleId,\n     modules: Arena<CrateModuleId, ModuleData>,\n     macros: Arena<CrateMacroId, mbe::MacroRules>,\n-    public_macros: FxHashMap<Name, CrateMacroId>,\n+    public_macros: FxHashMap<Name, MacroDefId>,\n     macro_resolutions: FxHashMap<MacroCallId, (Crate, CrateMacroId)>,\n     diagnostics: Vec<DefDiagnostic>,\n }\n@@ -238,13 +238,6 @@ impl CrateDefMap {\n         self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n     }\n \n-    pub(crate) fn resolve_macro(\n-        &self,\n-        macro_call_id: MacroCallId,\n-    ) -> Option<(Crate, CrateMacroId)> {\n-        self.macro_resolutions.get(&macro_call_id).map(|&it| it)\n-    }\n-\n     pub(crate) fn find_module_by_source(\n         &self,\n         file_id: HirFileId,"}, {"sha": "89300d2eccdb7f0986973a439974166c399c09d3", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 31, "deletions": 62, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=5270bca5f72fa65f0515be776e06d3d6a4d1efca", "patch": "@@ -6,15 +6,15 @@ use ra_db::FileId;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    DefDatabase, HirFileId, Name, Path, Crate,\n+    DefDatabase, HirFileId, Name, Path,\n     KnownName,\n     nameres::{\n         Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode,\n-        CrateDefMap, CrateModuleId, ModuleData, CrateMacroId,\n+        CrateDefMap, CrateModuleId, ModuleData,\n         diagnostics::DefDiagnostic,\n         raw,\n     },\n-    ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId},\n+    ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId, MacroDefId},\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -51,8 +51,8 @@ struct DefCollector<DB> {\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n-    unexpanded_macros: Vec<(CrateModuleId, MacroCallId, Path, tt::Subtree)>,\n-    global_macro_scope: FxHashMap<Name, CrateMacroId>,\n+    unexpanded_macros: Vec<(CrateModuleId, SourceItemId, Path)>,\n+    global_macro_scope: FxHashMap<Name, MacroDefId>,\n }\n \n impl<'a, DB> DefCollector<&'a DB>\n@@ -62,7 +62,7 @@ where\n     fn collect(&mut self) {\n         let crate_graph = self.db.crate_graph();\n         let file_id = crate_graph.crate_root(self.def_map.krate.crate_id());\n-        let raw_items = self.db.raw_items(file_id);\n+        let raw_items = self.db.raw_items(file_id.into());\n         let module_id = self.def_map.root;\n         self.def_map.modules[module_id].definition = Some(file_id);\n         ModCollector {\n@@ -93,14 +93,11 @@ where\n         }\n     }\n \n-    fn define_macro(&mut self, name: Name, tt: &tt::Subtree, export: bool) {\n-        if let Ok(rules) = mbe::MacroRules::parse(tt) {\n-            let macro_id = self.def_map.macros.alloc(rules);\n-            if export {\n-                self.def_map.public_macros.insert(name.clone(), macro_id);\n-            }\n-            self.global_macro_scope.insert(name, macro_id);\n+    fn define_macro(&mut self, name: Name, macro_id: MacroDefId, export: bool) {\n+        if export {\n+            self.def_map.public_macros.insert(name.clone(), macro_id);\n         }\n+        self.global_macro_scope.insert(name, macro_id);\n     }\n \n     fn resolve_imports(&mut self) -> ReachedFixedPoint {\n@@ -296,7 +293,7 @@ where\n         let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n-        macros.retain(|(module_id, call_id, path, tt)| {\n+        macros.retain(|(module_id, source_item_id, path)| {\n             if path.segments.len() != 2 {\n                 return true;\n             }\n@@ -312,47 +309,24 @@ where\n             res = ReachedFixedPoint::No;\n             let def_map = self.db.crate_def_map(krate);\n             if let Some(macro_id) = def_map.public_macros.get(&path.segments[1].name).cloned() {\n-                resolved.push((*module_id, *call_id, (krate, macro_id), tt.clone()));\n+                let call_id =\n+                    MacroCallLoc { def: macro_id, source_item_id: *source_item_id }.id(self.db);\n+                resolved.push((*module_id, call_id));\n             }\n             false\n         });\n \n-        for (module_id, macro_call_id, macro_def_id, arg) in resolved {\n-            self.collect_macro_expansion(module_id, macro_call_id, macro_def_id, arg);\n+        for (module_id, macro_call_id) in resolved {\n+            self.collect_macro_expansion(module_id, macro_call_id);\n         }\n         res\n     }\n \n-    fn collect_macro_expansion(\n-        &mut self,\n-        module_id: CrateModuleId,\n-        macro_call_id: MacroCallId,\n-        macro_def_id: (Crate, CrateMacroId),\n-        macro_arg: tt::Subtree,\n-    ) {\n-        let (macro_krate, macro_id) = macro_def_id;\n-        let dm;\n-        let rules = if macro_krate == self.def_map.krate {\n-            &self.def_map[macro_id]\n-        } else {\n-            dm = self.db.crate_def_map(macro_krate);\n-            &dm[macro_id]\n-        };\n-        if let Ok(expansion) = rules.expand(&macro_arg) {\n-            self.def_map.macro_resolutions.insert(macro_call_id, macro_def_id);\n-            // XXX: this **does not** go through a database, because we can't\n-            // identify macro_call without adding the whole state of name resolution\n-            // as a parameter to the query.\n-            //\n-            // So, we run the queries \"manually\" and we must ensure that\n-            // `db.hir_parse(macro_call_id)` returns the same source_file.\n-            let file_id: HirFileId = macro_call_id.into();\n-            let source_file = mbe::token_tree_to_ast_item_list(&expansion);\n-\n-            let raw_items = raw::RawItems::from_source_file(&source_file, file_id);\n-            ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n-                .collect(raw_items.items())\n-        }\n+    fn collect_macro_expansion(&mut self, module_id: CrateModuleId, macro_call_id: MacroCallId) {\n+        let file_id: HirFileId = macro_call_id.into();\n+        let raw_items = self.db.raw_items(file_id);\n+        ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n+            .collect(raw_items.items())\n     }\n \n     fn finish(self) -> CrateDefMap {\n@@ -412,7 +386,7 @@ where\n                     Ok(file_id) => {\n                         let module_id =\n                             self.push_child_module(name.clone(), source_item_id, Some(file_id));\n-                        let raw_items = self.def_collector.db.raw_items(file_id);\n+                        let raw_items = self.def_collector.db.raw_items(file_id.into());\n                         ModCollector {\n                             def_collector: &mut *self.def_collector,\n                             module_id,\n@@ -484,38 +458,33 @@ where\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                self.def_collector.define_macro(name.clone(), &mac.arg, mac.export)\n+                let macro_id = MacroDefId::MacroByExample {\n+                    source_item_id: mac.source_item_id.with_file_id(self.file_id),\n+                };\n+                self.def_collector.define_macro(name.clone(), macro_id, mac.export)\n             }\n             return;\n         }\n \n         let source_item_id = SourceItemId { file_id: self.file_id, item_id: mac.source_item_id };\n-        let macro_call_id = MacroCallLoc {\n-            module: Module { krate: self.def_collector.def_map.krate, module_id: self.module_id },\n-            source_item_id,\n-        }\n-        .id(self.def_collector.db);\n \n         // Case 2: try to expand macro_rules from this crate, triggering\n         // recursive item collection.\n         if let Some(&macro_id) =\n             mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(name))\n         {\n-            self.def_collector.collect_macro_expansion(\n-                self.module_id,\n-                macro_call_id,\n-                (self.def_collector.def_map.krate, macro_id),\n-                mac.arg.clone(),\n-            );\n+            let macro_call_id =\n+                MacroCallLoc { def: macro_id, source_item_id }.id(self.def_collector.db);\n+\n+            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id);\n             return;\n         }\n \n         // Case 3: path to a macro from another crate, expand during name resolution\n         self.def_collector.unexpanded_macros.push((\n             self.module_id,\n-            macro_call_id,\n+            source_item_id,\n             mac.path.clone(),\n-            mac.arg.clone(),\n         ))\n     }\n }"}, {"sha": "7a516e556fdb0fdb9fce38ba1baae8413223f2ff", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=5270bca5f72fa65f0515be776e06d3d6a4d1efca", "patch": "@@ -4,7 +4,6 @@ use std::{\n };\n \n use test_utils::tested_by;\n-use ra_db::FileId;\n use ra_arena::{Arena, impl_arena_id, RawId, map::ArenaMap};\n use ra_syntax::{\n     AstNode, SourceFile, AstPtr, TreeArc,\n@@ -47,40 +46,27 @@ impl ImportSourceMap {\n }\n \n impl RawItems {\n-    pub(crate) fn raw_items_query(db: &impl DefDatabase, file_id: FileId) -> Arc<RawItems> {\n+    pub(crate) fn raw_items_query(db: &impl DefDatabase, file_id: HirFileId) -> Arc<RawItems> {\n         db.raw_items_with_source_map(file_id).0\n     }\n \n     pub(crate) fn raw_items_with_source_map_query(\n         db: &impl DefDatabase,\n-        file_id: FileId,\n+        file_id: HirFileId,\n     ) -> (Arc<RawItems>, Arc<ImportSourceMap>) {\n         let mut collector = RawItemsCollector {\n             raw_items: RawItems::default(),\n             source_file_items: db.file_items(file_id.into()),\n             source_map: ImportSourceMap::default(),\n         };\n-        let source_file = db.parse(file_id);\n+        let source_file = db.hir_parse(file_id);\n         collector.process_module(None, &*source_file);\n         (Arc::new(collector.raw_items), Arc::new(collector.source_map))\n     }\n \n     pub(crate) fn items(&self) -> &[RawItem] {\n         &self.items\n     }\n-\n-    // We can't use queries during name resolution for fear of cycles, so this\n-    // is a query-less variant of the above function.\n-    pub(crate) fn from_source_file(source_file: &SourceFile, file_id: HirFileId) -> RawItems {\n-        let source_file_items = SourceFileItems::from_source_file(source_file, file_id);\n-        let mut collector = RawItemsCollector {\n-            raw_items: RawItems::default(),\n-            source_file_items: Arc::new(source_file_items),\n-            source_map: ImportSourceMap::default(),\n-        };\n-        collector.process_module(None, &*source_file);\n-        collector.raw_items\n-    }\n }\n \n impl Index<Module> for RawItems {\n@@ -173,7 +159,6 @@ pub(crate) struct MacroData {\n     pub(crate) source_item_id: SourceFileItemId,\n     pub(crate) path: Path,\n     pub(crate) name: Option<Name>,\n-    pub(crate) arg: tt::Subtree,\n     pub(crate) export: bool,\n }\n \n@@ -291,18 +276,15 @@ impl RawItemsCollector {\n     }\n \n     fn add_macro(&mut self, current_module: Option<Module>, m: &ast::MacroCall) {\n-        let (path, arg) = match (\n-            m.path().and_then(Path::from_ast),\n-            m.token_tree().and_then(mbe::ast_to_token_tree),\n-        ) {\n-            (Some(path), Some((token_tree, _token_map))) => (path, token_tree),\n+        let path = match m.path().and_then(Path::from_ast) {\n+            Some(it) => it,\n             _ => return,\n         };\n \n         let name = m.name().map(|it| it.as_name());\n         let source_item_id = self.source_file_items.id_of_unchecked(m.syntax());\n         let export = m.has_atom_attr(\"macro_export\");\n-        let m = self.raw_items.macros.alloc(MacroData { source_item_id, path, arg, name, export });\n+        let m = self.raw_items.macros.alloc(MacroData { source_item_id, path, name, export });\n         self.push_item(current_module, RawItem::Macro(m));\n     }\n "}, {"sha": "a059634e2003a8fa48b21f8238fca43f15202aeb", "filename": "crates/ra_hir/src/nameres/tests/incremental.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5270bca5f72fa65f0515be776e06d3d6a4d1efca/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=5270bca5f72fa65f0515be776e06d3d6a4d1efca", "patch": "@@ -90,34 +90,27 @@ fn adding_inner_items_should_not_invalidate_def_map() {\n     );\n }\n \n-// It would be awesome to make this work, but it's unclear how\n #[test]\n-#[ignore]\n-fn typing_inside_a_function_inside_a_macro_should_not_invalidate_def_map() {\n+fn typing_inside_a_macro_should_not_invalidate_def_map() {\n     check_def_map_is_not_recomputed(\n         \"\n         //- /lib.rs\n+        macro_rules! m {\n+            ($ident:ident) => {\n+                struct Foo;\n+            }\n+        }\n         mod foo;\n \n-        use crate::foo::bar::Baz;\n-\n         //- /foo/mod.rs\n         pub mod bar;\n \n         //- /foo/bar.rs\n         <|>\n-        salsa::query_group! {\n-            trait Baz {\n-                fn foo() -> i32 { 1 + 1 }\n-            }\n-        }\n+        m!(X);\n         \",\n         \"\n-        salsa::query_group! {\n-            trait Baz {\n-                fn foo() -> i32 { 92 }\n-            }\n-        }\n+        m!(Y);\n         \",\n     );\n }"}]}