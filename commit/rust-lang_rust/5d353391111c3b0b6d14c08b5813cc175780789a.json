{"sha": "5d353391111c3b0b6d14c08b5813cc175780789a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMzUzMzkxMTExYzNiMGI2ZDE0YzA4YjU4MTNjYzE3NTc4MDc4OWE=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-01-25T23:36:51Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-23T21:08:44Z"}, "message": "Add shim for readdir64_r", "tree": {"sha": "4dd43de8a47f38e3adc5c77fa91a99ef60d46e6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dd43de8a47f38e3adc5c77fa91a99ef60d46e6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d353391111c3b0b6d14c08b5813cc175780789a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d353391111c3b0b6d14c08b5813cc175780789a", "html_url": "https://github.com/rust-lang/rust/commit/5d353391111c3b0b6d14c08b5813cc175780789a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d353391111c3b0b6d14c08b5813cc175780789a/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7c3f588eb78917952aab237c11a0edaae3c84f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7c3f588eb78917952aab237c11a0edaae3c84f3", "html_url": "https://github.com/rust-lang/rust/commit/d7c3f588eb78917952aab237c11a0edaae3c84f3"}], "stats": {"total": 143, "additions": 141, "deletions": 2}, "files": [{"sha": "2872e92fa1ee11ffc8bba9d05f14e46f04c16359", "filename": "src/shims/foreign_items/posix/linux.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d353391111c3b0b6d14c08b5813cc175780789a/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d353391111c3b0b6d14c08b5813cc175780789a/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs?ref=5d353391111c3b0b6d14c08b5813cc175780789a", "patch": "@@ -34,6 +34,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(result, dest)?;\n             }\n \n+            // The `macos` module has a parallel foreign item, `readdir_r`, which uses a different\n+            // struct layout.\n+            \"readdir64_r\" => {\n+                let result = this.readdir64_r(args[0], args[1], args[2])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n             // Time related shims\n \n             // This is a POSIX function but it has only been tested on linux."}, {"sha": "a5acafdaaaf04a054136f4af9a2a63796b62c629", "filename": "src/shims/fs.rs", "status": "modified", "additions": 115, "deletions": 1, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5d353391111c3b0b6d14c08b5813cc175780789a/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d353391111c3b0b6d14c08b5813cc175780789a/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=5d353391111c3b0b6d14c08b5813cc175780789a", "patch": "@@ -1,7 +1,7 @@\n use std::collections::BTreeMap;\n use std::collections::HashMap;\n use std::convert::{TryFrom, TryInto};\n-use std::fs::{read_dir, remove_dir, remove_file, rename, DirBuilder, File, OpenOptions, ReadDir};\n+use std::fs::{read_dir, remove_dir, remove_file, rename, DirBuilder, File, FileType, OpenOptions, ReadDir};\n use std::io::{Read, Seek, SeekFrom, Write};\n use std::path::PathBuf;\n use std::time::SystemTime;\n@@ -161,6 +161,43 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n         this.set_last_error(ebadf)?;\n         Ok((-1).into())\n     }\n+\n+    fn file_type_to_d_type(&mut self, file_type: std::io::Result<FileType>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+        match file_type {\n+            Ok(file_type) => {\n+                if file_type.is_dir() {\n+                    Ok(this.eval_libc(\"DT_DIR\")?.to_u8()? as i32)\n+                } else if file_type.is_file() {\n+                    Ok(this.eval_libc(\"DT_REG\")?.to_u8()? as i32)\n+                } else if file_type.is_symlink() {\n+                    Ok(this.eval_libc(\"DT_LNK\")?.to_u8()? as i32)\n+                } else {\n+                    #[cfg(unix)]\n+                    {\n+                        use std::os::unix::fs::FileTypeExt;\n+                        if file_type.is_block_device() {\n+                            Ok(this.eval_libc(\"DT_BLK\")?.to_u8()? as i32)\n+                        } else if file_type.is_char_device() {\n+                            Ok(this.eval_libc(\"DT_CHR\")?.to_u8()? as i32)\n+                        } else if file_type.is_fifo() {\n+                            Ok(this.eval_libc(\"DT_FIFO\")?.to_u8()? as i32)\n+                        } else if file_type.is_socket() {\n+                            Ok(this.eval_libc(\"DT_SOCK\")?.to_u8()? as i32)\n+                        } else {\n+                            Ok(this.eval_libc(\"DT_UNKNOWN\")?.to_u8()? as i32)\n+                        }\n+                    }\n+                    #[cfg(not(unix))]\n+                    Ok(this.eval_libc(\"DT_UNKNOWN\")?.to_u8()? as i32)\n+                }\n+            }\n+            Err(e) => return match e.raw_os_error() {\n+                Some(error) => Ok(error),\n+                None => throw_unsup_format!(\"The error {} couldn't be converted to a return value\", e),\n+            }\n+        }\n+    }\n }\n \n #[derive(Debug, Default)]\n@@ -801,6 +838,83 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n+    fn readdir64_r(\n+        &mut self,\n+        dirp_op: OpTy<'tcx, Tag>,\n+        entry_op: OpTy<'tcx, Tag>,\n+        result_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.check_no_isolation(\"readdir64_r\")?;\n+\n+        let dirp = this.force_ptr(this.read_scalar(dirp_op)?.not_undef()?)?;\n+\n+        let entry_ptr = this.force_ptr(this.read_scalar(entry_op)?.not_undef()?)?;\n+        let dirent64_layout = this.libc_ty_layout(\"dirent64\")?;\n+        this.memory.check_ptr_access(\n+            Scalar::Ptr(entry_ptr),\n+            dirent64_layout.size,\n+            dirent64_layout.align.abi,\n+        )?;\n+\n+        if let Some(dir_iter) = this.machine.dir_handler.streams.get_mut(&dirp) {\n+            match dir_iter.next() {\n+                Some(Ok(dir_entry)) => {\n+                    // write into entry, write pointer to result, return 0 on success\n+                    let entry_place = this.deref_operand(entry_op)?;\n+                    let ino64_t_layout = this.libc_ty_layout(\"ino64_t\")?;\n+                    let off64_t_layout = this.libc_ty_layout(\"off64_t\")?;\n+                    let c_ushort_layout = this.libc_ty_layout(\"c_ushort\")?;\n+                    let c_uchar_layout = this.libc_ty_layout(\"c_uchar\")?;\n+\n+                    let name_offset = dirent64_layout.details.fields.offset(4);\n+                    let name_ptr = entry_ptr.offset(name_offset, this)?;\n+\n+                    #[cfg(unix)]\n+                    let ino = std::os::unix::fs::DirEntryExt::ino(&dir_entry);\n+                    #[cfg(not(unix))]\n+                    let ino = 0;\n+\n+                    #[cfg(unix)]\n+                    let file_name = dir_entry.file_name();\n+                    #[cfg(unix)]\n+                    let file_name = std::os::unix::ffi::OsStrExt::as_bytes(file_name.as_os_str());\n+                    #[cfg(not(unix))]\n+                    let file_name = b\"\";\n+\n+                    let file_type = this.file_type_to_d_type(dir_entry.file_type())? as u128;\n+\n+                    let imms = [\n+                        immty_from_uint_checked(ino, ino64_t_layout)?, // d_ino\n+                        immty_from_uint_checked(0u128, off64_t_layout)?, // d_off\n+                        immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n+                        immty_from_uint_checked(file_type, c_uchar_layout)?, // d_type\n+                    ];\n+                    this.write_packed_immediates(entry_place, &imms)?;\n+                    this.memory.write_bytes(Scalar::Ptr(name_ptr), file_name.iter().copied())?;\n+\n+                    let result_place = this.deref_operand(result_op)?;\n+                    this.write_scalar(this.read_scalar(entry_op)?, result_place.into())?;\n+\n+                    Ok(0)\n+                }\n+                None => {\n+                    // end of stream: return 0, assign *result=NULL\n+                    this.write_null(this.deref_operand(result_op)?.into())?;\n+                    Ok(0)\n+                }\n+                Some(Err(e)) => match e.raw_os_error() {\n+                    // return positive error number on error\n+                    Some(error) => Ok(error),\n+                    None => throw_unsup_format!(\"The error {} couldn't be converted to a return value\", e),\n+                }\n+            }\n+        } else {\n+            throw_unsup_format!(\"The DIR pointer passed to readdir64_r did not come from opendir\")\n+        }\n+    }\n+\n     fn closedir(&mut self, dirp_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n "}, {"sha": "cc450e6c014168cd861081f75346be26f846b0bb", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d353391111c3b0b6d14c08b5813cc175780789a/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d353391111c3b0b6d14c08b5813cc175780789a/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=5d353391111c3b0b6d14c08b5813cc175780789a", "patch": "@@ -1,7 +1,7 @@\n // ignore-windows: File handling is not implemented yet\n // compile-flags: -Zmiri-disable-isolation\n \n-use std::fs::{File, create_dir, remove_dir, remove_dir_all, remove_file, rename};\n+use std::fs::{File, create_dir, read_dir, remove_dir, remove_dir_all, remove_file, rename};\n use std::io::{Read, Write, ErrorKind, Result, Seek, SeekFrom};\n use std::path::{PathBuf, Path};\n \n@@ -199,6 +199,24 @@ fn test_directory() {\n     create_dir(&dir_path).unwrap();\n     // Test that the metadata of a directory is correct.\n     assert!(dir_path.metadata().unwrap().is_dir());\n+\n+    // Create some files inside the directory\n+    let f1_path = dir_path.join(\"f1\");\n+    drop(File::create(&f1_path).unwrap());\n+    let f2_path = dir_path.join(\"f2\");\n+    drop(File::create(&f2_path).unwrap());\n+    // Test that the files are present inside the directory\n+    let mut dir_iter = read_dir(&dir_path).unwrap();\n+    let first_dir_entry = dir_iter.next().unwrap().unwrap();\n+    let second_dir_entry = dir_iter.next().unwrap().unwrap();\n+    assert!(first_dir_entry.file_name() == \"f1\" || first_dir_entry.file_name() == \"f2\");\n+    assert!(second_dir_entry.file_name() == \"f1\" || second_dir_entry.file_name() == \"f2\");\n+    assert!(dir_iter.next().is_none());\n+    drop(dir_iter);\n+    // Clean up the files in the directory\n+    remove_file(&f1_path).unwrap();\n+    remove_file(&f2_path).unwrap();\n+\n     // Deleting the directory should succeed.\n     remove_dir(&dir_path).unwrap();\n     // Reading the metadata of a non-existent file should fail with a \"not found\" error."}]}