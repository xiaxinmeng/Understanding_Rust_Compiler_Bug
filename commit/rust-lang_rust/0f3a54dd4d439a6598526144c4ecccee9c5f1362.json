{"sha": "0f3a54dd4d439a6598526144c4ecccee9c5f1362", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmM2E1NGRkNGQ0MzlhNjU5ODUyNjE0NGM0ZWNjY2VlOWM1ZjEzNjI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-14T19:24:18Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-16T17:38:19Z"}, "message": "wip", "tree": {"sha": "c974dab20b25d0403f23222f4438bb3f9f7d8b0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c974dab20b25d0403f23222f4438bb3f9f7d8b0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f3a54dd4d439a6598526144c4ecccee9c5f1362", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f3a54dd4d439a6598526144c4ecccee9c5f1362", "html_url": "https://github.com/rust-lang/rust/commit/0f3a54dd4d439a6598526144c4ecccee9c5f1362", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f3a54dd4d439a6598526144c4ecccee9c5f1362/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6305d094ac61ed6e437537b93f4e587b415678c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6305d094ac61ed6e437537b93f4e587b415678c9", "html_url": "https://github.com/rust-lang/rust/commit/6305d094ac61ed6e437537b93f4e587b415678c9"}], "stats": {"total": 254, "additions": 160, "deletions": 94}, "files": [{"sha": "ad4a0732e0fc3a2c835a10571c11ec7be2aeb362", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f3a54dd4d439a6598526144c4ecccee9c5f1362/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3a54dd4d439a6598526144c4ecccee9c5f1362/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=0f3a54dd4d439a6598526144c4ecccee9c5f1362", "patch": "@@ -31,8 +31,12 @@ impl TokenExpander {\n         match self {\n             TokenExpander::MacroRules(it) => it.expand(tt),\n             // FIXME switch these to ExpandResult as well\n-            TokenExpander::Builtin(it) => it.expand(db, id, tt).map_or_else(|e| (tt::Subtree::default(), Some(e)), |r| (r, None)),\n-            TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt).map_or_else(|e| (tt::Subtree::default(), Some(e)), |r| (r, None)),\n+            TokenExpander::Builtin(it) => it\n+                .expand(db, id, tt)\n+                .map_or_else(|e| (tt::Subtree::default(), Some(e)), |r| (r, None)),\n+            TokenExpander::BuiltinDerive(it) => it\n+                .expand(db, id, tt)\n+                .map_or_else(|e| (tt::Subtree::default(), Some(e)), |r| (r, None)),\n         }\n     }\n \n@@ -182,7 +186,7 @@ fn macro_expand_with_arg(\n             if arg.is_some() {\n                 return (\n                     None,\n-                    Some(\"hypothetical macro expansion not implemented for eager macro\".to_owned())\n+                    Some(\"hypothetical macro expansion not implemented for eager macro\".to_owned()),\n                 );\n             } else {\n                 return (Some(db.lookup_intern_eager_expansion(id).subtree), None);\n@@ -252,9 +256,9 @@ pub fn parse_macro_with_arg(\n                 let parents = std::iter::successors(loc.kind.file_id().call_node(db), |it| {\n                     it.file_id.call_node(db)\n                 })\n-                    .map(|n| format!(\"{:#}\", n.value))\n-                    .collect::<Vec<_>>()\n-                    .join(\"\\n\");\n+                .map(|n| format!(\"{:#}\", n.value))\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\");\n \n                 log::warn!(\n                     \"fail on macro_parse: (reason: {} macro_call: {:#}) parents: {}\","}, {"sha": "22f5077f5b2fd4e0e147e124ac98f84c7e21c880", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f3a54dd4d439a6598526144c4ecccee9c5f1362/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3a54dd4d439a6598526144c4ecccee9c5f1362/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=0f3a54dd4d439a6598526144c4ecccee9c5f1362", "patch": "@@ -777,8 +777,8 @@ mod tests {\n         [\n             CompletionItem {\n                 label: \"the_field\",\n-                source_range: [552; 553),\n-                delete: [552; 553),\n+                source_range: [552; 552),\n+                delete: [552; 552),\n                 insert: \"the_field\",\n                 kind: Field,\n                 detail: \"u32\","}, {"sha": "cb84bb93489d125a5540a635c9c940c8351d851e", "filename": "crates/ra_ide/src/completion/complete_pattern.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f3a54dd4d439a6598526144c4ecccee9c5f1362/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3a54dd4d439a6598526144c4ecccee9c5f1362/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs?ref=0f3a54dd4d439a6598526144c4ecccee9c5f1362", "patch": "@@ -89,7 +89,6 @@ mod tests {\n \n     #[test]\n     fn completes_in_simple_macro_call() {\n-        // FIXME: doesn't work yet because of missing error recovery in macro expansion\n         let completions = complete(\n             r\"\n             macro_rules! m { ($e:expr) => { $e } }\n@@ -102,6 +101,16 @@ mod tests {\n             }\n             \",\n         );\n-        assert_debug_snapshot!(completions, @r###\"[]\"###);\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"E\",\n+                source_range: [151; 151),\n+                delete: [151; 151),\n+                insert: \"E\",\n+                kind: Enum,\n+            },\n+        ]\n+        \"###);\n     }\n }"}, {"sha": "b2faa86d25dfcf052de9693f639635cae36f23fc", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0f3a54dd4d439a6598526144c4ecccee9c5f1362/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3a54dd4d439a6598526144c4ecccee9c5f1362/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=0f3a54dd4d439a6598526144c4ecccee9c5f1362", "patch": "@@ -8,33 +8,44 @@ mod transcriber;\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashMap;\n \n-use crate::{ExpandResult, ExpandError};\n-\n-pub(crate) fn expand(\n-    rules: &crate::MacroRules,\n-    input: &tt::Subtree,\n-) -> ExpandResult<tt::Subtree> {\n-    let (mut result, mut left_over, mut err) = (tt::Subtree::default(), usize::max_value(), Some(ExpandError::NoMatchingRule));\n+use crate::{ExpandError, ExpandResult};\n+\n+pub(crate) fn expand(rules: &crate::MacroRules, input: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n+    let (mut result, mut unmatched_tokens, mut unmatched_patterns, mut err) = (\n+        tt::Subtree::default(),\n+        usize::max_value(),\n+        usize::max_value(),\n+        Some(ExpandError::NoMatchingRule),\n+    );\n     for rule in &rules.rules {\n-        let ((res, left), e) = expand_rule(rule, input);\n+        let ((res, tokens, patterns), e) = expand_rule(rule, input);\n         if e.is_none() {\n             // if we find a rule that applies without errors, we're done\n             return (res, None);\n         }\n-        // use the rule if we matched more tokens\n-        if left < left_over {\n+        // use the rule if we matched more tokens, or had fewer patterns left\n+        if tokens < unmatched_tokens || tokens == unmatched_tokens && patterns < unmatched_patterns\n+        {\n             result = res;\n             err = e;\n-            left_over = left;\n+            unmatched_tokens = tokens;\n+            unmatched_patterns = patterns;\n         }\n     }\n     (result, err)\n }\n \n-fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> ExpandResult<(tt::Subtree, usize)> {\n-    let ((bindings, left_over), bindings_err) = dbg!(matcher::match_(&rule.lhs, input));\n-    let (res, transcribe_err) = dbg!(transcriber::transcribe(&rule.rhs, &bindings));\n-    ((res, left_over), bindings_err.or(transcribe_err))\n+fn expand_rule(\n+    rule: &crate::Rule,\n+    input: &tt::Subtree,\n+) -> ExpandResult<(tt::Subtree, usize, usize)> {\n+    dbg!(&rule.lhs);\n+    let (match_result, bindings_err) = dbg!(matcher::match_(&rule.lhs, input));\n+    let (res, transcribe_err) = dbg!(transcriber::transcribe(&rule.rhs, &match_result.bindings));\n+    (\n+        (res, match_result.unmatched_tokens, match_result.unmatched_patterns),\n+        bindings_err.or(transcribe_err),\n+    )\n }\n \n /// The actual algorithm for expansion is not too hard, but is pretty tricky.\n@@ -149,17 +160,15 @@ mod tests {\n         crate::MacroRules::parse(&definition_tt).unwrap()\n     }\n \n-    fn expand_first(\n-        rules: &crate::MacroRules,\n-        invocation: &str,\n-    ) -> ExpandResult<tt::Subtree> {\n+    fn expand_first(rules: &crate::MacroRules, invocation: &str) -> ExpandResult<tt::Subtree> {\n         let source_file = ast::SourceFile::parse(invocation).ok().unwrap();\n         let macro_invocation =\n             source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n         let (invocation_tt, _) =\n             ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n \n-        expand_rule(&rules.rules[0], &invocation_tt)\n+        let expanded = expand_rule(&rules.rules[0], &invocation_tt);\n+        ((expanded.0).0, expanded.1)\n     }\n }"}, {"sha": "ae65fb69a85011ae79930dd0de0c4ab3213a8fa9", "filename": "crates/ra_mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 108, "deletions": 64, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/0f3a54dd4d439a6598526144c4ecccee9c5f1362/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3a54dd4d439a6598526144c4ecccee9c5f1362/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=0f3a54dd4d439a6598526144c4ecccee9c5f1362", "patch": "@@ -8,10 +8,10 @@ use crate::{\n     ExpandError,\n };\n \n+use super::ExpandResult;\n use ra_parser::{FragmentKind::*, TreeSink};\n use ra_syntax::{SmolStr, SyntaxKind};\n use tt::buffer::{Cursor, TokenBuffer};\n-use super::ExpandResult;\n \n impl Bindings {\n     fn push_optional(&mut self, name: &SmolStr) {\n@@ -59,36 +59,50 @@ macro_rules! err {\n     };\n }\n \n-macro_rules! bail {\n-    ($($tt:tt)*) => {\n-        return Err(err!($($tt)*))\n-    };\n+#[derive(Debug, Default)]\n+pub(super) struct Match {\n+    pub bindings: Bindings,\n+    pub unmatched_tokens: usize,\n+    pub unmatched_patterns: usize,\n }\n \n-pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> ExpandResult<(Bindings, usize)> {\n+pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> ExpandResult<Match> {\n     assert!(pattern.delimiter == None);\n \n-    let mut res = Bindings::default();\n+    let mut res = Match::default();\n     let mut src = TtIter::new(src);\n \n     let mut err = match_subtree(&mut res, pattern, &mut src).err();\n \n+    res.unmatched_tokens += src.len();\n     if src.len() > 0 && err.is_none() {\n         err = Some(err!(\"leftover tokens\"));\n     }\n \n-    ((res, src.len()), err)\n+    (res, err)\n }\n \n fn match_subtree(\n-    bindings: &mut Bindings,\n+    res: &mut Match,\n     pattern: &tt::Subtree,\n     src: &mut TtIter,\n ) -> Result<(), ExpandError> {\n+    let mut result = Ok(());\n     for op in parse_pattern(pattern) {\n+        if result.is_err() {\n+            // We're just going through the patterns to count how many we missed\n+            res.unmatched_patterns += 1;\n+            continue;\n+        }\n         match op? {\n             Op::TokenTree(tt::TokenTree::Leaf(lhs)) => {\n-                let rhs = src.expect_leaf().map_err(|()| err!(\"expected leaf: `{}`\", lhs))?;\n+                let rhs = match src.expect_leaf() {\n+                    Ok(l) => l,\n+                    Err(()) => {\n+                        result = Err(err!(\"expected leaf: `{}`\", lhs));\n+                        continue;\n+                    }\n+                };\n                 match (lhs, rhs) {\n                     (\n                         tt::Leaf::Punct(tt::Punct { char: lhs, .. }),\n@@ -102,35 +116,54 @@ fn match_subtree(\n                         tt::Leaf::Literal(tt::Literal { text: lhs, .. }),\n                         tt::Leaf::Literal(tt::Literal { text: rhs, .. }),\n                     ) if lhs == rhs => (),\n-                    _ => return Err(ExpandError::UnexpectedToken),\n+                    _ => {\n+                        result = Err(ExpandError::UnexpectedToken);\n+                    }\n                 }\n             }\n             Op::TokenTree(tt::TokenTree::Subtree(lhs)) => {\n-                let rhs = src.expect_subtree().map_err(|()| err!(\"expected subtree\"))?;\n+                let rhs = match src.expect_subtree() {\n+                    Ok(s) => s,\n+                    Err(()) => {\n+                        result = Err(err!(\"expected subtree\"));\n+                        continue;\n+                    }\n+                };\n                 if lhs.delimiter_kind() != rhs.delimiter_kind() {\n-                    bail!(\"mismatched delimiter\")\n+                    result = Err(err!(\"mismatched delimiter\"));\n+                    continue;\n                 }\n                 let mut src = TtIter::new(rhs);\n-                match_subtree(bindings, lhs, &mut src)?;\n-                if src.len() > 0 {\n-                    bail!(\"leftover tokens\");\n+                result = match_subtree(res, lhs, &mut src);\n+                res.unmatched_tokens += src.len();\n+                if src.len() > 0 && result.is_ok() {\n+                    result = Err(err!(\"leftover tokens\"));\n                 }\n             }\n             Op::Var { name, kind } => {\n-                let kind = kind.as_ref().ok_or(ExpandError::UnexpectedToken)?;\n-                match match_meta_var(kind.as_str(), src)? {\n+                let kind = match kind {\n+                    Some(k) => k,\n+                    None => {\n+                        result = Err(ExpandError::UnexpectedToken);\n+                        continue;\n+                    }\n+                };\n+                let (matched, match_err) = match_meta_var(kind.as_str(), src);\n+                match matched {\n                     Some(fragment) => {\n-                        bindings.inner.insert(name.clone(), Binding::Fragment(fragment));\n+                        res.bindings.inner.insert(name.clone(), Binding::Fragment(fragment));\n                     }\n-                    None => bindings.push_optional(name),\n+                    None if match_err.is_none() => res.bindings.push_optional(name),\n+                    _ => {}\n                 }\n+                result = match_err.map_or(Ok(()), Err);\n             }\n             Op::Repeat { subtree, kind, separator } => {\n-                match_repeat(bindings, subtree, kind, separator, src)?\n+                result = match_repeat(res, subtree, kind, separator, src);\n             }\n         }\n     }\n-    Ok(())\n+    result\n }\n \n impl<'a> TtIter<'a> {\n@@ -222,7 +255,7 @@ impl<'a> TtIter<'a> {\n     pub(crate) fn expect_fragment(\n         &mut self,\n         fragment_kind: ra_parser::FragmentKind,\n-    ) -> Result<tt::TokenTree, ()> {\n+    ) -> ExpandResult<tt::TokenTree> {\n         pub(crate) struct OffsetTokenSink<'a> {\n             pub(crate) cursor: Cursor<'a>,\n             pub(crate) error: bool,\n@@ -247,45 +280,47 @@ impl<'a> TtIter<'a> {\n \n         ra_parser::parse_fragment(&mut src, &mut sink, fragment_kind);\n \n+        let mut err = None;\n         if !sink.cursor.is_root() || sink.error {\n-            // FIXME better recovery in this case would help completion inside macros immensely\n-            return Err(());\n+            err = Some(err!(\"expected {:?}\", fragment_kind));\n         }\n \n         let mut curr = buffer.begin();\n         let mut res = vec![];\n \n-        while curr != sink.cursor {\n-            if let Some(token) = curr.token_tree() {\n-                res.push(token);\n+        if sink.cursor.is_root() {\n+            while curr != sink.cursor {\n+                if let Some(token) = curr.token_tree() {\n+                    res.push(token);\n+                }\n+                curr = curr.bump();\n             }\n-            curr = curr.bump();\n         }\n         self.inner = self.inner.as_slice()[res.len()..].iter();\n-        match res.len() {\n-            0 => Err(()),\n-            1 => Ok(res[0].clone()),\n-            _ => Ok(tt::TokenTree::Subtree(tt::Subtree {\n+        let res = match res.len() {\n+            1 => res[0].clone(),\n+            _ => tt::TokenTree::Subtree(tt::Subtree {\n                 delimiter: None,\n                 token_trees: res.into_iter().cloned().collect(),\n-            })),\n-        }\n+            }),\n+        };\n+        (res, err)\n     }\n \n     pub(crate) fn eat_vis(&mut self) -> Option<tt::TokenTree> {\n         let mut fork = self.clone();\n         match fork.expect_fragment(Visibility) {\n-            Ok(tt) => {\n+            (tt, None) => {\n                 *self = fork;\n                 Some(tt)\n             }\n-            Err(()) => None,\n+            (_, Some(_)) => None,\n         }\n     }\n }\n \n pub(super) fn match_repeat(\n-    bindings: &mut Bindings,\n+    res: &mut Match,\n     pattern: &tt::Subtree,\n     kind: RepeatKind,\n     separator: Option<Separator>,\n@@ -305,17 +340,23 @@ pub(super) fn match_repeat(\n             }\n         }\n \n-        let mut nested = Bindings::default();\n+        let mut nested = Match::default();\n         match match_subtree(&mut nested, pattern, &mut fork) {\n             Ok(()) => {\n                 limit -= 1;\n                 if limit == 0 {\n-                    log::warn!(\"match_lhs excced in repeat pattern exceed limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\", pattern, src, kind, separator);\n+                    log::warn!(\n+                        \"match_lhs exceeded repeat pattern limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\",\n+                        pattern,\n+                        src,\n+                        kind,\n+                        separator\n+                    );\n                     break;\n                 }\n                 *src = fork;\n \n-                bindings.push_nested(counter, nested)?;\n+                res.bindings.push_nested(counter, nested.bindings)?;\n                 counter += 1;\n                 if counter == 1 {\n                     if let RepeatKind::ZeroOrOne = kind {\n@@ -334,15 +375,15 @@ pub(super) fn match_repeat(\n             let mut vars = Vec::new();\n             collect_vars(&mut vars, pattern)?;\n             for var in vars {\n-                bindings.push_empty(&var)\n+                res.bindings.push_empty(&var)\n             }\n         }\n         _ => (),\n     }\n     Ok(())\n }\n \n-fn match_meta_var(kind: &str, input: &mut TtIter) -> Result<Option<Fragment>, ExpandError> {\n+fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragment>> {\n     let fragment = match kind {\n         \"path\" => Path,\n         \"expr\" => Expr,\n@@ -353,34 +394,33 @@ fn match_meta_var(kind: &str, input: &mut TtIter) -> Result<Option<Fragment>, Ex\n         \"meta\" => MetaItem,\n         \"item\" => Item,\n         _ => {\n-            let tt = match kind {\n-                \"ident\" => {\n-                    let ident = input.expect_ident().map_err(|()| err!(\"expected ident\"))?.clone();\n-                    tt::Leaf::from(ident).into()\n-                }\n-                \"tt\" => input.expect_tt().map_err(|()| err!())?.clone(),\n-                \"lifetime\" => {\n-                    let ident = input.expect_lifetime().map_err(|()| err!())?;\n-                    tt::Leaf::Ident(ident.clone()).into()\n-                }\n-                \"literal\" => {\n-                    let literal = input.expect_literal().map_err(|()| err!())?.clone();\n-                    tt::Leaf::from(literal).into()\n-                }\n+            let tt_result = match kind {\n+                \"ident\" => input\n+                    .expect_ident()\n+                    .map(|ident| Some(tt::Leaf::from(ident.clone()).into()))\n+                    .map_err(|()| err!(\"expected ident\")),\n+                \"tt\" => input.expect_tt().map(Some).map_err(|()| err!()),\n+                \"lifetime\" => input\n+                    .expect_lifetime()\n+                    .map(|ident| Some(tt::Leaf::Ident(ident.clone()).into()))\n+                    .map_err(|()| err!(\"expected lifetime\")),\n+                \"literal\" => input\n+                    .expect_literal()\n+                    .map(|literal| Some(tt::Leaf::from(literal.clone()).into()))\n+                    .map_err(|()| err!()),\n                 // `vis` is optional\n                 \"vis\" => match input.eat_vis() {\n-                    Some(vis) => vis,\n-                    None => return Ok(None),\n+                    Some(vis) => Ok(Some(vis)),\n+                    None => Ok(None),\n                 },\n-                _ => return Err(ExpandError::UnexpectedToken),\n+                _ => Err(ExpandError::UnexpectedToken),\n             };\n-            return Ok(Some(Fragment::Tokens(tt)));\n+            return to_expand_result(tt_result.map(|it| it.map(Fragment::Tokens)));\n         }\n     };\n-    let tt =\n-        input.expect_fragment(fragment).map_err(|()| err!(\"fragment did not parse as {}\", kind))?;\n+    let (tt, err) = input.expect_fragment(fragment);\n     let fragment = if kind == \"expr\" { Fragment::Ast(tt) } else { Fragment::Tokens(tt) };\n-    Ok(Some(fragment))\n+    (Some(fragment), err)\n }\n \n fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &tt::Subtree) -> Result<(), ExpandError> {\n@@ -394,3 +434,7 @@ fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &tt::Subtree) -> Result<(), Exp\n     }\n     Ok(())\n }\n+\n+fn to_expand_result<T: Default>(result: Result<T, ExpandError>) -> ExpandResult<T> {\n+    result.map_or_else(|e| (Default::default(), Some(e)), |it| (it, None))\n+}"}]}