{"sha": "33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYTBmZTdiMmNkNjJhZTYxNTkzYjI1MDRjYjhkZWFhM2ZhYjYxYzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-26T10:57:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-26T10:57:39Z"}, "message": "Auto merge of #3690 - mikerite:fix-3630-expect-fun-call, r=phansch\n\nFix `expect_fun_call` lint suggestions\n\nThis commit corrects some bad suggestions produced by the\n`expect_fun_call` lint and enables `rust-fix` checking on the tests.\n\nAddresses #3630", "tree": {"sha": "0468ade7288916c4bec1f8472373f161e161461e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0468ade7288916c4bec1f8472373f161e161461e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4", "html_url": "https://github.com/rust-lang/rust/commit/33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1b55e8559fc78f25183cd53bcc9692871ab7c21", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1b55e8559fc78f25183cd53bcc9692871ab7c21", "html_url": "https://github.com/rust-lang/rust/commit/b1b55e8559fc78f25183cd53bcc9692871ab7c21"}, {"sha": "18cacbabb43f2fd87e20706be852e62aea282257", "url": "https://api.github.com/repos/rust-lang/rust/commits/18cacbabb43f2fd87e20706be852e62aea282257", "html_url": "https://github.com/rust-lang/rust/commit/18cacbabb43f2fd87e20706be852e62aea282257"}], "stats": {"total": 357, "additions": 244, "deletions": 113}, "files": [{"sha": "4126b78e676b619a839e7987142fb3f9d61b4987", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 99, "deletions": 90, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4", "patch": "@@ -1148,26 +1148,46 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n \n /// Checks for the `EXPECT_FUN_CALL` lint.\n fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n-    fn extract_format_args(arg: &hir::Expr) -> Option<(&hir::Expr, &hir::Expr)> {\n-        let arg = match &arg.node {\n-            hir::ExprKind::AddrOf(_, expr) => expr,\n-            hir::ExprKind::MethodCall(method_name, _, args)\n-                if method_name.ident.name == \"as_str\" || method_name.ident.name == \"as_ref\" =>\n-            {\n-                &args[0]\n-            },\n-            _ => arg,\n-        };\n-\n-        if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg.node {\n-            if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1 {\n-                if let hir::ExprKind::Call(_, format_args) = &inner_args[0].node {\n-                    return Some((&format_args[0], &format_args[1]));\n-                }\n-            }\n+    // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n+    // `&str`\n+    fn get_arg_root<'a>(cx: &LateContext<'_, '_>, arg: &'a hir::Expr) -> &'a hir::Expr {\n+        let mut arg_root = arg;\n+        loop {\n+            arg_root = match &arg_root.node {\n+                hir::ExprKind::AddrOf(_, expr) => expr,\n+                hir::ExprKind::MethodCall(method_name, _, call_args) => {\n+                    if call_args.len() == 1\n+                        && (method_name.ident.name == \"as_str\" || method_name.ident.name == \"as_ref\")\n+                        && {\n+                            let arg_type = cx.tables.expr_ty(&call_args[0]);\n+                            let base_type = walk_ptrs_ty(arg_type);\n+                            base_type.sty == ty::Str || match_type(cx, base_type, &paths::STRING)\n+                        }\n+                    {\n+                        &call_args[0]\n+                    } else {\n+                        break;\n+                    }\n+                },\n+                _ => break,\n+            };\n         }\n+        arg_root\n+    }\n \n-        None\n+    // Only `&'static str` or `String` can be used directly in the `panic!`. Other types should be\n+    // converted to string.\n+    fn requires_to_string(cx: &LateContext<'_, '_>, arg: &hir::Expr) -> bool {\n+        let arg_ty = cx.tables.expr_ty(arg);\n+        if match_type(cx, arg_ty, &paths::STRING) {\n+            return false;\n+        }\n+        if let ty::Ref(ty::ReStatic, ty, ..) = arg_ty.sty {\n+            if ty.sty == ty::Str {\n+                return false;\n+            }\n+        };\n+        true\n     }\n \n     fn generate_format_arg_snippet(\n@@ -1189,93 +1209,82 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         unreachable!()\n     }\n \n-    fn check_general_case(\n-        cx: &LateContext<'_, '_>,\n-        name: &str,\n-        method_span: Span,\n-        self_expr: &hir::Expr,\n-        arg: &hir::Expr,\n-        span: Span,\n-    ) {\n-        fn is_call(node: &hir::ExprKind) -> bool {\n-            match node {\n-                hir::ExprKind::AddrOf(_, expr) => {\n-                    is_call(&expr.node)\n-                },\n-                hir::ExprKind::Call(..)\n-                | hir::ExprKind::MethodCall(..)\n-                // These variants are debatable or require further examination\n-                | hir::ExprKind::If(..)\n-                | hir::ExprKind::Match(..)\n-                | hir::ExprKind::Block{ .. } => true,\n-                _ => false,\n-            }\n-        }\n-\n-        if name != \"expect\" {\n-            return;\n+    fn is_call(node: &hir::ExprKind) -> bool {\n+        match node {\n+            hir::ExprKind::AddrOf(_, expr) => {\n+                is_call(&expr.node)\n+            },\n+            hir::ExprKind::Call(..)\n+            | hir::ExprKind::MethodCall(..)\n+            // These variants are debatable or require further examination\n+            | hir::ExprKind::If(..)\n+            | hir::ExprKind::Match(..)\n+            | hir::ExprKind::Block{ .. } => true,\n+            _ => false,\n         }\n+    }\n \n-        let self_type = cx.tables.expr_ty(self_expr);\n-        let known_types = &[&paths::OPTION, &paths::RESULT];\n+    if args.len() != 2 || name != \"expect\" || !is_call(&args[1].node) {\n+        return;\n+    }\n \n-        // if not a known type, return early\n-        if known_types.iter().all(|&k| !match_type(cx, self_type, k)) {\n-            return;\n-        }\n+    let receiver_type = cx.tables.expr_ty(&args[0]);\n+    let closure_args = if match_type(cx, receiver_type, &paths::OPTION) {\n+        \"||\"\n+    } else if match_type(cx, receiver_type, &paths::RESULT) {\n+        \"|_|\"\n+    } else {\n+        return;\n+    };\n \n-        if !is_call(&arg.node) {\n-            return;\n-        }\n+    let arg_root = get_arg_root(cx, &args[1]);\n \n-        let closure = if match_type(cx, self_type, &paths::OPTION) {\n-            \"||\"\n-        } else {\n-            \"|_|\"\n-        };\n-        let span_replace_word = method_span.with_hi(span.hi());\n+    let span_replace_word = method_span.with_hi(expr.span.hi());\n \n-        if let Some((fmt_spec, fmt_args)) = extract_format_args(arg) {\n-            let mut applicability = Applicability::MachineApplicable;\n-            let mut args = vec![snippet(cx, fmt_spec.span, \"..\").into_owned()];\n+    let mut applicability = Applicability::MachineApplicable;\n \n-            args.extend(generate_format_arg_snippet(cx, fmt_args, &mut applicability));\n+    //Special handling for `format!` as arg_root\n+    if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg_root.node {\n+        if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1 {\n+            if let hir::ExprKind::Call(_, format_args) = &inner_args[0].node {\n+                let fmt_spec = &format_args[0];\n+                let fmt_args = &format_args[1];\n \n-            let sugg = args.join(\", \");\n+                let mut args = vec![snippet(cx, fmt_spec.span, \"..\").into_owned()];\n \n-            span_lint_and_sugg(\n-                cx,\n-                EXPECT_FUN_CALL,\n-                span_replace_word,\n-                &format!(\"use of `{}` followed by a function call\", name),\n-                \"try this\",\n-                format!(\"unwrap_or_else({} panic!({}))\", closure, sugg),\n-                applicability,\n-            );\n+                args.extend(generate_format_arg_snippet(cx, fmt_args, &mut applicability));\n \n-            return;\n-        }\n+                let sugg = args.join(\", \");\n \n-        let mut applicability = Applicability::MachineApplicable;\n-        let sugg: Cow<'_, _> = snippet_with_applicability(cx, arg.span, \"..\", &mut applicability);\n+                span_lint_and_sugg(\n+                    cx,\n+                    EXPECT_FUN_CALL,\n+                    span_replace_word,\n+                    &format!(\"use of `{}` followed by a function call\", name),\n+                    \"try this\",\n+                    format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n+                    applicability,\n+                );\n \n-        span_lint_and_sugg(\n-            cx,\n-            EXPECT_FUN_CALL,\n-            span_replace_word,\n-            &format!(\"use of `{}` followed by a function call\", name),\n-            \"try this\",\n-            format!(\"unwrap_or_else({} {{ let msg = {}; panic!(msg) }}))\", closure, sugg),\n-            applicability,\n-        );\n+                return;\n+            }\n+        }\n     }\n \n-    if args.len() == 2 {\n-        match args[1].node {\n-            hir::ExprKind::Lit(_) => {},\n-            _ => check_general_case(cx, name, method_span, &args[0], &args[1], expr.span),\n-        }\n+    let mut arg_root_snippet: Cow<'_, _> = snippet_with_applicability(cx, arg_root.span, \"..\", &mut applicability);\n+    if requires_to_string(cx, arg_root) {\n+        arg_root_snippet.to_mut().push_str(\".to_string()\");\n     }\n+\n+    span_lint_and_sugg(\n+        cx,\n+        EXPECT_FUN_CALL,\n+        span_replace_word,\n+        &format!(\"use of `{}` followed by a function call\", name),\n+        \"try this\",\n+        format!(\"unwrap_or_else({} {{ panic!({}) }})\", closure_args, arg_root_snippet),\n+        applicability,\n+    );\n }\n \n /// Checks for the `CLONE_ON_COPY` lint."}, {"sha": "1f74f6b8cf14be08ef0b6c2887a8191478552586", "filename": "tests/ui/expect_fun_call.fixed", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4/tests%2Fui%2Fexpect_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4/tests%2Fui%2Fexpect_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_fun_call.fixed?ref=33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4", "patch": "@@ -0,0 +1,84 @@\n+// run-rustfix\n+\n+#![warn(clippy::expect_fun_call)]\n+\n+/// Checks implementation of the `EXPECT_FUN_CALL` lint\n+\n+fn main() {\n+    struct Foo;\n+\n+    impl Foo {\n+        fn new() -> Self {\n+            Foo\n+        }\n+\n+        fn expect(&self, msg: &str) {\n+            panic!(\"{}\", msg)\n+        }\n+    }\n+\n+    let with_some = Some(\"value\");\n+    with_some.expect(\"error\");\n+\n+    let with_none: Option<i32> = None;\n+    with_none.expect(\"error\");\n+\n+    let error_code = 123_i32;\n+    let with_none_and_format: Option<i32> = None;\n+    with_none_and_format.unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code));\n+\n+    let with_none_and_as_str: Option<i32> = None;\n+    with_none_and_as_str.unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code));\n+\n+    let with_ok: Result<(), ()> = Ok(());\n+    with_ok.expect(\"error\");\n+\n+    let with_err: Result<(), ()> = Err(());\n+    with_err.expect(\"error\");\n+\n+    let error_code = 123_i32;\n+    let with_err_and_format: Result<(), ()> = Err(());\n+    with_err_and_format.unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code));\n+\n+    let with_err_and_as_str: Result<(), ()> = Err(());\n+    with_err_and_as_str.unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code));\n+\n+    let with_dummy_type = Foo::new();\n+    with_dummy_type.expect(\"another test string\");\n+\n+    let with_dummy_type_and_format = Foo::new();\n+    with_dummy_type_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+\n+    let with_dummy_type_and_as_str = Foo::new();\n+    with_dummy_type_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+\n+    //Issue #2937\n+    Some(\"foo\").unwrap_or_else(|| panic!(\"{} {}\", 1, 2));\n+\n+    //Issue #2979 - this should not lint\n+    {\n+        let msg = \"bar\";\n+        Some(\"foo\").expect(msg);\n+    }\n+\n+    {\n+        fn get_string() -> String {\n+            \"foo\".to_string()\n+        }\n+\n+        fn get_static_str() -> &'static str {\n+            \"foo\"\n+        }\n+\n+        fn get_non_static_str(_: &u32) -> &str {\n+            \"foo\"\n+        }\n+\n+        Some(\"foo\").unwrap_or_else(|| { panic!(get_string()) });\n+        Some(\"foo\").unwrap_or_else(|| { panic!(get_string()) });\n+        Some(\"foo\").unwrap_or_else(|| { panic!(get_string()) });\n+\n+        Some(\"foo\").unwrap_or_else(|| { panic!(get_static_str()) });\n+        Some(\"foo\").unwrap_or_else(|| { panic!(get_non_static_str(&0).to_string()) });\n+    }\n+}"}, {"sha": "2d8b4925f358a117dfa7d55ec6c0adbd0f819a04", "filename": "tests/ui/expect_fun_call.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4/tests%2Fui%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4/tests%2Fui%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_fun_call.rs?ref=33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4", "patch": "@@ -1,9 +1,10 @@\n+// run-rustfix\n+\n #![warn(clippy::expect_fun_call)]\n-#![allow(clippy::useless_format)]\n \n /// Checks implementation of the `EXPECT_FUN_CALL` lint\n \n-fn expect_fun_call() {\n+fn main() {\n     struct Foo;\n \n     impl Foo {\n@@ -51,14 +52,33 @@ fn expect_fun_call() {\n     let with_dummy_type_and_as_str = Foo::new();\n     with_dummy_type_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n \n+    //Issue #2937\n+    Some(\"foo\").expect(format!(\"{} {}\", 1, 2).as_ref());\n+\n     //Issue #2979 - this should not lint\n-    let msg = \"bar\";\n-    Some(\"foo\").expect(msg);\n+    {\n+        let msg = \"bar\";\n+        Some(\"foo\").expect(msg);\n+    }\n \n-    Some(\"foo\").expect({ &format!(\"error\") });\n-    Some(\"foo\").expect(format!(\"error\").as_ref());\n+    {\n+        fn get_string() -> String {\n+            \"foo\".to_string()\n+        }\n \n-    Some(\"foo\").expect(format!(\"{} {}\", 1, 2).as_ref());\n-}\n+        fn get_static_str() -> &'static str {\n+            \"foo\"\n+        }\n+\n+        fn get_non_static_str(_: &u32) -> &str {\n+            \"foo\"\n+        }\n \n-fn main() {}\n+        Some(\"foo\").expect(&get_string());\n+        Some(\"foo\").expect(get_string().as_ref());\n+        Some(\"foo\").expect(get_string().as_str());\n+\n+        Some(\"foo\").expect(get_static_str());\n+        Some(\"foo\").expect(get_non_static_str(&0));\n+    }\n+}"}, {"sha": "900e251d964c20b2b91da0ee38fa3363c804214b", "filename": "tests/ui/expect_fun_call.stderr", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4/tests%2Fui%2Fexpect_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4/tests%2Fui%2Fexpect_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_fun_call.stderr?ref=33a0fe7b2cd62ae61593b2504cb8deaa3fab61c4", "patch": "@@ -1,46 +1,64 @@\n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:27:26\n+  --> $DIR/expect_fun_call.rs:28:26\n    |\n LL |     with_none_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code))`\n    |\n    = note: `-D clippy::expect-fun-call` implied by `-D warnings`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:30:26\n+  --> $DIR/expect_fun_call.rs:31:26\n    |\n LL |     with_none_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:40:25\n+  --> $DIR/expect_fun_call.rs:41:25\n    |\n LL |     with_err_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:43:25\n+  --> $DIR/expect_fun_call.rs:44:25\n    |\n LL |     with_err_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:58:17\n+  --> $DIR/expect_fun_call.rs:56:17\n    |\n-LL |     Some(\"foo\").expect({ &format!(\"error\") });\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { let msg = { &format!(\"error\") }; panic!(msg) }))`\n+LL |     Some(\"foo\").expect(format!(\"{} {}\", 1, 2).as_ref());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"{} {}\", 1, 2))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:59:17\n+  --> $DIR/expect_fun_call.rs:77:21\n    |\n-LL |     Some(\"foo\").expect(format!(\"error\").as_ref());\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"error\"))`\n+LL |         Some(\"foo\").expect(&get_string());\n+   |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(get_string()) })`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:61:17\n+  --> $DIR/expect_fun_call.rs:78:21\n    |\n-LL |     Some(\"foo\").expect(format!(\"{} {}\", 1, 2).as_ref());\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"{} {}\", 1, 2))`\n+LL |         Some(\"foo\").expect(get_string().as_ref());\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(get_string()) })`\n+\n+error: use of `expect` followed by a function call\n+  --> $DIR/expect_fun_call.rs:79:21\n+   |\n+LL |         Some(\"foo\").expect(get_string().as_str());\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(get_string()) })`\n+\n+error: use of `expect` followed by a function call\n+  --> $DIR/expect_fun_call.rs:81:21\n+   |\n+LL |         Some(\"foo\").expect(get_static_str());\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(get_static_str()) })`\n+\n+error: use of `expect` followed by a function call\n+  --> $DIR/expect_fun_call.rs:82:21\n+   |\n+LL |         Some(\"foo\").expect(get_non_static_str(&0));\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(get_non_static_str(&0).to_string()) })`\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 10 previous errors\n "}]}