{"sha": "4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMTQxZjVlNGM1ZTA5NDA4MzQ1Y2I4ZmE3NGY0YzJmMzBjZGRkNWQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-07-14T17:53:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-14T17:53:35Z"}, "message": "Rollup merge of #87027 - petrochenkov:builderhelp, r=oli-obk\n\nexpand: Support helper attributes for built-in derive macros\n\nThis is needed for https://github.com/rust-lang/rust/pull/86735 (derive macro `Default` should have a helper attribute `default`).\n\nWith this PR we can specify helper attributes for built-in derives using syntax `#[rustc_builtin_macro(MacroName, attributes(attr1, attr2, ...))]` which mirrors equivalent syntax for proc macros `#[proc_macro_derive(MacroName, attributes(attr1, attr2, ...))]`.\nOtherwise expansion infra was already ready for this.\nThe attribute parsing code is shared between proc macro derives and built-in macros (`fn parse_macro_name_and_helper_attrs`).", "tree": {"sha": "94537c35e4ce79caba9da6a83bbd16acda7ec693", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94537c35e4ce79caba9da6a83bbd16acda7ec693"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg7ySfCRBK7hj4Ov3rIwAAjy0IAGk7Gu/ScGC4kpmwdghd9gRr\nH9ZQ/BM+mqw5Egzf/7a8QwaCzU4TzirrJMSQJ+0PVQIjZ2GXCsk+U7SJLzG2qN4x\nl0xDGbr+tVn2tPaAXCJBMpvBqH8C6gNsPD6X/HGJ1ROKB5ypcefDG0JKeZXA1fkl\nxcHe41bGCivK0UWUTZqDUl6GzoKYPfkyXA9lbYLdkwlpxmO0cskM2IEfDvKCok2A\nVdMkIeYNGdMIuDjEWhVOtOK4BuxuzRyoznFB2PFLKtroIgVWuLI7dKWUYfejtdPP\nSu89kC3c4zUPi98lJFX+UfjuZzrCykO5lIqy8wp5fcpENboUIrp6lY6F3ROjLxk=\n=0aOj\n-----END PGP SIGNATURE-----\n", "payload": "tree 94537c35e4ce79caba9da6a83bbd16acda7ec693\nparent ee5ed4a88d6a869cdb152829ed697d6459650db3\nparent 6c9ea1e8a9c899979a8b4dd86b32c4c77f4b6b6a\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1626285215 +0200\ncommitter GitHub <noreply@github.com> 1626285215 +0200\n\nRollup merge of #87027 - petrochenkov:builderhelp, r=oli-obk\n\nexpand: Support helper attributes for built-in derive macros\n\nThis is needed for https://github.com/rust-lang/rust/pull/86735 (derive macro `Default` should have a helper attribute `default`).\n\nWith this PR we can specify helper attributes for built-in derives using syntax `#[rustc_builtin_macro(MacroName, attributes(attr1, attr2, ...))]` which mirrors equivalent syntax for proc macros `#[proc_macro_derive(MacroName, attributes(attr1, attr2, ...))]`.\nOtherwise expansion infra was already ready for this.\nThe attribute parsing code is shared between proc macro derives and built-in macros (`fn parse_macro_name_and_helper_attrs`).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d", "html_url": "https://github.com/rust-lang/rust/commit/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee5ed4a88d6a869cdb152829ed697d6459650db3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee5ed4a88d6a869cdb152829ed697d6459650db3", "html_url": "https://github.com/rust-lang/rust/commit/ee5ed4a88d6a869cdb152829ed697d6459650db3"}, {"sha": "6c9ea1e8a9c899979a8b4dd86b32c4c77f4b6b6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9ea1e8a9c899979a8b4dd86b32c4c77f4b6b6a", "html_url": "https://github.com/rust-lang/rust/commit/6c9ea1e8a9c899979a8b4dd86b32c4c77f4b6b6a"}], "stats": {"total": 225, "additions": 144, "deletions": 81}, "files": [{"sha": "a8c61d53346de279ea68c618d70ad47a5e5b967a", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 7, "deletions": 76, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{self as ast, NodeId};\n use rustc_ast_pretty::pprust;\n-use rustc_expand::base::{ExtCtxt, ResolverExpand};\n+use rustc_expand::base::{parse_macro_name_and_helper_attrs, ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n use rustc_session::Session;\n use rustc_span::hygiene::AstPass;\n@@ -109,86 +109,17 @@ impl<'a> CollectProcMacros<'a> {\n     }\n \n     fn collect_custom_derive(&mut self, item: &'a ast::Item, attr: &'a ast::Attribute) {\n-        // Once we've located the `#[proc_macro_derive]` attribute, verify\n-        // that it's of the form `#[proc_macro_derive(Foo)]` or\n-        // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n-        let list = match attr.meta_item_list() {\n-            Some(list) => list,\n-            None => return,\n-        };\n-        if list.len() != 1 && list.len() != 2 {\n-            self.handler.span_err(attr.span, \"attribute must have either one or two arguments\");\n-            return;\n-        }\n-        let trait_attr = match list[0].meta_item() {\n-            Some(meta_item) => meta_item,\n-            _ => {\n-                self.handler.span_err(list[0].span(), \"not a meta item\");\n-                return;\n-            }\n-        };\n-        let trait_ident = match trait_attr.ident() {\n-            Some(trait_ident) if trait_attr.is_word() => trait_ident,\n-            _ => {\n-                self.handler.span_err(trait_attr.span, \"must only be one word\");\n-                return;\n-            }\n-        };\n-\n-        if !trait_ident.name.can_be_raw() {\n-            self.handler.span_err(\n-                trait_attr.span,\n-                &format!(\"`{}` cannot be a name of derive macro\", trait_ident),\n-            );\n-        }\n-\n-        let attributes_attr = list.get(1);\n-        let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n-            if !attr.has_name(sym::attributes) {\n-                self.handler.span_err(attr.span(), \"second argument must be `attributes`\")\n-            }\n-            attr.meta_item_list()\n-                .unwrap_or_else(|| {\n-                    self.handler\n-                        .span_err(attr.span(), \"attribute must be of form: `attributes(foo, bar)`\");\n-                    &[]\n-                })\n-                .iter()\n-                .filter_map(|attr| {\n-                    let attr = match attr.meta_item() {\n-                        Some(meta_item) => meta_item,\n-                        _ => {\n-                            self.handler.span_err(attr.span(), \"not a meta item\");\n-                            return None;\n-                        }\n-                    };\n-\n-                    let ident = match attr.ident() {\n-                        Some(ident) if attr.is_word() => ident,\n-                        _ => {\n-                            self.handler.span_err(attr.span, \"must only be one word\");\n-                            return None;\n-                        }\n-                    };\n-                    if !ident.name.can_be_raw() {\n-                        self.handler.span_err(\n-                            attr.span,\n-                            &format!(\"`{}` cannot be a name of derive helper attribute\", ident),\n-                        );\n-                    }\n-\n-                    Some(ident.name)\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n+        let (trait_name, proc_attrs) =\n+            match parse_macro_name_and_helper_attrs(self.handler, attr, \"derive\") {\n+                Some(name_and_attrs) => name_and_attrs,\n+                None => return,\n+            };\n \n         if self.in_root && item.vis.kind.is_pub() {\n             self.macros.push(ProcMacro::Derive(ProcMacroDerive {\n                 id: item.id,\n                 span: item.span,\n-                trait_name: trait_ident.name,\n+                trait_name,\n                 function_name: item.ident,\n                 attrs: proc_attrs,\n             }));"}, {"sha": "0183add495777184abf448fc63988f44bd2d5bb9", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 92, "deletions": 2, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d", "patch": "@@ -745,9 +745,17 @@ impl SyntaxExtension {\n             }\n         }\n \n-        let builtin_name = sess\n+        let (builtin_name, helper_attrs) = sess\n             .find_by_name(attrs, sym::rustc_builtin_macro)\n-            .map(|a| a.value_str().unwrap_or(name));\n+            .map(|attr| {\n+                // Override `helper_attrs` passed above if it's a built-in macro,\n+                // marking `proc_macro_derive` macros as built-in is not a realistic use case.\n+                parse_macro_name_and_helper_attrs(sess.diagnostic(), attr, \"built-in\").map_or_else(\n+                    || (Some(name), Vec::new()),\n+                    |(name, helper_attrs)| (Some(name), helper_attrs),\n+                )\n+            })\n+            .unwrap_or_else(|| (None, helper_attrs));\n         let (stability, const_stability) = attr::find_stability(&sess, attrs, span);\n         if let Some((_, sp)) = const_stability {\n             sess.parse_sess\n@@ -1213,6 +1221,88 @@ pub fn get_exprs_from_tts(\n     Some(es)\n }\n \n+pub fn parse_macro_name_and_helper_attrs(\n+    diag: &rustc_errors::Handler,\n+    attr: &Attribute,\n+    descr: &str,\n+) -> Option<(Symbol, Vec<Symbol>)> {\n+    // Once we've located the `#[proc_macro_derive]` attribute, verify\n+    // that it's of the form `#[proc_macro_derive(Foo)]` or\n+    // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n+    let list = match attr.meta_item_list() {\n+        Some(list) => list,\n+        None => return None,\n+    };\n+    if list.len() != 1 && list.len() != 2 {\n+        diag.span_err(attr.span, \"attribute must have either one or two arguments\");\n+        return None;\n+    }\n+    let trait_attr = match list[0].meta_item() {\n+        Some(meta_item) => meta_item,\n+        _ => {\n+            diag.span_err(list[0].span(), \"not a meta item\");\n+            return None;\n+        }\n+    };\n+    let trait_ident = match trait_attr.ident() {\n+        Some(trait_ident) if trait_attr.is_word() => trait_ident,\n+        _ => {\n+            diag.span_err(trait_attr.span, \"must only be one word\");\n+            return None;\n+        }\n+    };\n+\n+    if !trait_ident.name.can_be_raw() {\n+        diag.span_err(\n+            trait_attr.span,\n+            &format!(\"`{}` cannot be a name of {} macro\", trait_ident, descr),\n+        );\n+    }\n+\n+    let attributes_attr = list.get(1);\n+    let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n+        if !attr.has_name(sym::attributes) {\n+            diag.span_err(attr.span(), \"second argument must be `attributes`\")\n+        }\n+        attr.meta_item_list()\n+            .unwrap_or_else(|| {\n+                diag.span_err(attr.span(), \"attribute must be of form: `attributes(foo, bar)`\");\n+                &[]\n+            })\n+            .iter()\n+            .filter_map(|attr| {\n+                let attr = match attr.meta_item() {\n+                    Some(meta_item) => meta_item,\n+                    _ => {\n+                        diag.span_err(attr.span(), \"not a meta item\");\n+                        return None;\n+                    }\n+                };\n+\n+                let ident = match attr.ident() {\n+                    Some(ident) if attr.is_word() => ident,\n+                    _ => {\n+                        diag.span_err(attr.span, \"must only be one word\");\n+                        return None;\n+                    }\n+                };\n+                if !ident.name.can_be_raw() {\n+                    diag.span_err(\n+                        attr.span,\n+                        &format!(\"`{}` cannot be a name of derive helper attribute\", ident),\n+                    );\n+                }\n+\n+                Some(ident.name)\n+            })\n+            .collect()\n+    } else {\n+        Vec::new()\n+    };\n+\n+    Some((trait_ident.name, proc_attrs))\n+}\n+\n /// This nonterminal looks like some specific enums from\n /// `proc-macro-hack` and `procedural-masquerade` crates.\n /// We need to maintain some special pretty-printing behavior for them due to incorrect"}, {"sha": "b1c725ecd85c857db40b883d631ac7b529263add", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d", "patch": "@@ -448,7 +448,11 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Internal attributes, Macro related:\n     // ==========================================================================\n \n-    rustc_attr!(rustc_builtin_macro, AssumedUsed, template!(Word, NameValueStr: \"name\"), IMPL_DETAIL),\n+    rustc_attr!(\n+        rustc_builtin_macro, AssumedUsed,\n+        template!(Word, List: \"name, /*opt*/ attributes(name1, name2, ...)\"),\n+        IMPL_DETAIL,\n+    ),\n     rustc_attr!(rustc_proc_macro_decls, Normal, template!(Word), INTERNAL_UNSTABLE),\n     rustc_attr!(\n         rustc_macro_transparency, AssumedUsed,"}, {"sha": "7d22bfedb93b946234540931169e3d71c9cd04d6", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d", "patch": "@@ -1,6 +1,7 @@\n #[doc = include_str!(\"panic.md\")]\n #[macro_export]\n-#[rustc_builtin_macro = \"core_panic\"]\n+#[cfg_attr(bootstrap, rustc_builtin_macro = \"core_panic\")]\n+#[cfg_attr(not(bootstrap), rustc_builtin_macro(core_panic))]\n #[allow_internal_unstable(edition_panic)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n #[rustc_diagnostic_item = \"core_panic_macro\"]"}, {"sha": "7afe52a3fd693ccf2cec1d69901eb4ba3df56135", "filename": "library/std/src/macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/library%2Fstd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/library%2Fstd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fmacros.rs?ref=4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d", "patch": "@@ -6,7 +6,8 @@\n \n #[doc = include_str!(\"../../core/src/macros/panic.md\")]\n #[macro_export]\n-#[rustc_builtin_macro = \"std_panic\"]\n+#[cfg_attr(bootstrap, rustc_builtin_macro = \"std_panic\")]\n+#[cfg_attr(not(bootstrap), rustc_builtin_macro(std_panic))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable(edition_panic)]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"std_panic_macro\")]"}, {"sha": "ea74a15624c602ce76179dc223913937a3f43668", "filename": "src/test/ui/deriving/deriving-with-helper.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/src%2Ftest%2Fui%2Fderiving%2Fderiving-with-helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d/src%2Ftest%2Fui%2Fderiving%2Fderiving-with-helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-with-helper.rs?ref=4d141f5e4c5e09408345cb8fa74f4c2f30cddd5d", "patch": "@@ -0,0 +1,36 @@\n+// check-pass\n+// compile-flags: --crate-type=lib\n+\n+#![feature(decl_macro)]\n+#![feature(lang_items)]\n+#![feature(no_core)]\n+#![feature(rustc_attrs)]\n+\n+#![no_core]\n+\n+#[rustc_builtin_macro]\n+macro derive() {}\n+\n+#[rustc_builtin_macro(Default, attributes(default))]\n+macro Default() {}\n+\n+mod default {\n+    pub trait Default {\n+        fn default() -> Self;\n+    }\n+\n+    impl Default for u8 {\n+        fn default() -> u8 {\n+            0\n+        }\n+    }\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+#[derive(Default)]\n+struct S {\n+    #[default] // OK\n+    field: u8,\n+}"}]}