{"sha": "14dd33b8c7b380459bd032d1bb4f907efca7dac7", "node_id": "C_kwDOAAsO6NoAKDE0ZGQzM2I4YzdiMzgwNDU5YmQwMzJkMWJiNGY5MDdlZmNhN2RhYzc", "commit": {"author": {"name": "Thom Chiovoloni", "email": "thom@shift.click", "date": "2022-08-30T13:15:34Z"}, "committer": {"name": "Thom Chiovoloni", "email": "thom@shift.click", "date": "2022-08-31T12:16:45Z"}, "message": "Avoid needless buffer zeroing in `std::sys::windows::fs`", "tree": {"sha": "e0afd0f095a79cb218fb66f77613a7010615056e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0afd0f095a79cb218fb66f77613a7010615056e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14dd33b8c7b380459bd032d1bb4f907efca7dac7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQQszICQ1r0Zqrp7OLPXcz0dendfCgUCYw9RMgAKCRDXcz0dendf\nCnSmAP9rJnVv95hfe+0j+L4ZBaDqiiktS8bmBZvVAkUTSplZYQEAknsOidpDhnCn\nagGdW0e714puYjn01l/ItkMgumA2BQA=\n=AoQK\n-----END PGP SIGNATURE-----", "payload": "tree e0afd0f095a79cb218fb66f77613a7010615056e\nparent 12e4fd0755d7d976d4ee0f2004dc938290752ff7\nauthor Thom Chiovoloni <thom@shift.click> 1661865334 -0700\ncommitter Thom Chiovoloni <thom@shift.click> 1661948205 -0700\n\nAvoid needless buffer zeroing in `std::sys::windows::fs`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14dd33b8c7b380459bd032d1bb4f907efca7dac7", "html_url": "https://github.com/rust-lang/rust/commit/14dd33b8c7b380459bd032d1bb4f907efca7dac7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14dd33b8c7b380459bd032d1bb4f907efca7dac7/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12e4fd0755d7d976d4ee0f2004dc938290752ff7", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e4fd0755d7d976d4ee0f2004dc938290752ff7", "html_url": "https://github.com/rust-lang/rust/commit/12e4fd0755d7d976d4ee0f2004dc938290752ff7"}], "stats": {"total": 38, "additions": 24, "deletions": 14}, "files": [{"sha": "98c8834d38403a9ce4dba30cc3c73b666c439c30", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/14dd33b8c7b380459bd032d1bb4f907efca7dac7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dd33b8c7b380459bd032d1bb4f907efca7dac7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=14dd33b8c7b380459bd032d1bb4f907efca7dac7", "patch": "@@ -3,7 +3,7 @@ use crate::os::windows::prelude::*;\n use crate::ffi::OsString;\n use crate::fmt;\n use crate::io::{self, BorrowedCursor, Error, IoSlice, IoSliceMut, SeekFrom};\n-use crate::mem;\n+use crate::mem::{self, MaybeUninit};\n use crate::os::windows::io::{AsHandle, BorrowedHandle};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n@@ -326,7 +326,8 @@ impl File {\n             cvt(c::GetFileInformationByHandle(self.handle.as_raw_handle(), &mut info))?;\n             let mut reparse_tag = 0;\n             if info.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-                let mut b = Align8([0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n+                let mut b =\n+                    Align8([MaybeUninit::<u8>::uninit(); c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n                 if let Ok((_, buf)) = self.reparse_point(&mut b) {\n                     reparse_tag = (*buf).ReparseTag;\n                 }\n@@ -389,7 +390,8 @@ impl File {\n             attr.file_size = info.AllocationSize as u64;\n             attr.number_of_links = Some(info.NumberOfLinks);\n             if attr.file_type().is_reparse_point() {\n-                let mut b = Align8([0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n+                let mut b =\n+                    Align8([MaybeUninit::<u8>::uninit(); c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n                 if let Ok((_, buf)) = self.reparse_point(&mut b) {\n                     attr.reparse_tag = (*buf).ReparseTag;\n                 }\n@@ -463,7 +465,7 @@ impl File {\n     // avoid narrowing provenance to the actual `REPARSE_DATA_BUFFER`.\n     fn reparse_point(\n         &self,\n-        space: &mut Align8<[u8]>,\n+        space: &mut Align8<[MaybeUninit<u8>]>,\n     ) -> io::Result<(c::DWORD, *const c::REPARSE_DATA_BUFFER)> {\n         unsafe {\n             let mut bytes = 0;\n@@ -488,7 +490,7 @@ impl File {\n     }\n \n     fn readlink(&self) -> io::Result<PathBuf> {\n-        let mut space = Align8([0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n+        let mut space = Align8([MaybeUninit::<u8>::uninit(); c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n         let (_bytes, buf) = self.reparse_point(&mut space)?;\n         unsafe {\n             let (path_buffer, subst_off, subst_len, relative) = match (*buf).ReparseTag {\n@@ -658,12 +660,16 @@ impl File {\n \n /// A buffer for holding directory entries.\n struct DirBuff {\n-    buffer: Box<Align8<[u8; Self::BUFFER_SIZE]>>,\n+    buffer: Box<Align8<[MaybeUninit<u8>; Self::BUFFER_SIZE]>>,\n }\n impl DirBuff {\n     const BUFFER_SIZE: usize = 1024;\n     fn new() -> Self {\n-        Self { buffer: Box::new(Align8([0u8; Self::BUFFER_SIZE])) }\n+        Self {\n+            // Safety: `Align8<[MaybeUninit<u8>; N]>` does not need\n+            // initialization.\n+            buffer: unsafe { Box::new_uninit().assume_init() },\n+        }\n     }\n     fn capacity(&self) -> usize {\n         self.buffer.0.len()\n@@ -676,8 +682,8 @@ impl DirBuff {\n         DirBuffIter::new(self)\n     }\n }\n-impl AsRef<[u8]> for DirBuff {\n-    fn as_ref(&self) -> &[u8] {\n+impl AsRef<[MaybeUninit<u8>]> for DirBuff {\n+    fn as_ref(&self) -> &[MaybeUninit<u8>] {\n         &self.buffer.0\n     }\n }\n@@ -686,7 +692,7 @@ impl AsRef<[u8]> for DirBuff {\n ///\n /// Currently only returns file names (UTF-16 encoded).\n struct DirBuffIter<'a> {\n-    buffer: Option<&'a [u8]>,\n+    buffer: Option<&'a [MaybeUninit<u8>]>,\n     cursor: usize,\n }\n impl<'a> DirBuffIter<'a> {\n@@ -701,9 +707,13 @@ impl<'a> Iterator for DirBuffIter<'a> {\n         let buffer = &self.buffer?[self.cursor..];\n \n         // Get the name and next entry from the buffer.\n-        // SAFETY: The buffer contains a `FILE_ID_BOTH_DIR_INFO` struct but the\n-        // last field (the file name) is unsized. So an offset has to be\n-        // used to get the file name slice.\n+        // SAFETY:\n+        // - The buffer contains a `FILE_ID_BOTH_DIR_INFO` struct but the last\n+        //   field (the file name) is unsized. So an offset has to be used to\n+        //   get the file name slice.\n+        // - The OS has guaranteed initialization of the fields of\n+        //   `FILE_ID_BOTH_DIR_INFO` and the trailing filename (for at least\n+        //   `FileNameLength` bytes)\n         let (name, is_directory, next_entry) = unsafe {\n             let info = buffer.as_ptr().cast::<c::FILE_ID_BOTH_DIR_INFO>();\n             // Guaranteed to be aligned in documentation for\n@@ -1349,7 +1359,7 @@ fn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n     let h = f.as_inner().as_raw_handle();\n \n     unsafe {\n-        let mut data = Align8([0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n+        let mut data = Align8([MaybeUninit::<u8>::uninit(); c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n         let data_ptr = data.0.as_mut_ptr();\n         let db = data_ptr.cast::<c::REPARSE_MOUNTPOINT_DATA_BUFFER>();\n         let buf = ptr::addr_of_mut!((*db).ReparseTarget).cast::<c::WCHAR>();"}]}