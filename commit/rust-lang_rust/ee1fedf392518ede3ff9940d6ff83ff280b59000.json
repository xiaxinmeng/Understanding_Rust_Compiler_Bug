{"sha": "ee1fedf392518ede3ff9940d6ff83ff280b59000", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMWZlZGYzOTI1MThlZGUzZmY5OTQwZDZmZjgzZmYyODBiNTkwMDA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-09T18:06:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-09T18:06:53Z"}, "message": "Rollup merge of #78580 - tmiasko:inline-loop, r=oli-obk\n\ninliner: Break inlining cycles\n\nKeep track of all instances inlined so far. When examining a new call\nsites from an inlined body, skip those where callee had been inlined\nalready to avoid potential inlining cycles.\n\nFixes #78573.", "tree": {"sha": "edbd6b034467db8c52f187ec335ceca4a198d8ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edbd6b034467db8c52f187ec335ceca4a198d8ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee1fedf392518ede3ff9940d6ff83ff280b59000", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfqYU9CRBK7hj4Ov3rIwAAdHIIAH7sN4E17SazcLsCtJMh/Mly\nNAyyPEca9BZnRi3gmezcCHondftwlEOXY6SBUPXg3YulGMdYQV3z64yddQQBMgUW\no1Lz6J9vQt46WGqIGckZUxSaqP9M1aw+UQpUXtOv3k6T0p6XelMX25Hiqn7Pwfol\n9S5gUm/4+fTWgSmq5IcHDDSHMOCHpicBz1ZWWlR66gQ+mm5BR3m26GT0slpNDgCW\nhpwiOTlW7zXflBQwpjB0EFGYtYyaI+HLvKNR0RujfNjAoAmKyYBrH24OhCzsg9yD\nTj5y6zvPpwqHNUojoC4mdD76CMFm4O5phdSJWquW2MlpKtJJ9IrExGDsDDpb4hI=\n=kxr1\n-----END PGP SIGNATURE-----\n", "payload": "tree edbd6b034467db8c52f187ec335ceca4a198d8ee\nparent 7ac079f047ad9857a32593bc7607115183d13560\nparent dc4d74d149198c60ca1cf3a8513a7f3d031503eb\nauthor Dylan DPC <dylan.dpc@gmail.com> 1604945213 +0100\ncommitter GitHub <noreply@github.com> 1604945213 +0100\n\nRollup merge of #78580 - tmiasko:inline-loop, r=oli-obk\n\ninliner: Break inlining cycles\n\nKeep track of all instances inlined so far. When examining a new call\nsites from an inlined body, skip those where callee had been inlined\nalready to avoid potential inlining cycles.\n\nFixes #78573.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee1fedf392518ede3ff9940d6ff83ff280b59000", "html_url": "https://github.com/rust-lang/rust/commit/ee1fedf392518ede3ff9940d6ff83ff280b59000", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee1fedf392518ede3ff9940d6ff83ff280b59000/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ac079f047ad9857a32593bc7607115183d13560", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac079f047ad9857a32593bc7607115183d13560", "html_url": "https://github.com/rust-lang/rust/commit/7ac079f047ad9857a32593bc7607115183d13560"}, {"sha": "dc4d74d149198c60ca1cf3a8513a7f3d031503eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4d74d149198c60ca1cf3a8513a7f3d031503eb", "html_url": "https://github.com/rust-lang/rust/commit/dc4d74d149198c60ca1cf3a8513a7f3d031503eb"}], "stats": {"total": 371, "additions": 248, "deletions": 123}, "files": [{"sha": "97b513445264a67c91e887892a919e28d2fddd0a", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 114, "deletions": 123, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/ee1fedf392518ede3ff9940d6ff83ff280b59000/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee1fedf392518ede3ff9940d6ff83ff280b59000/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=ee1fedf392518ede3ff9940d6ff83ff280b59000", "patch": "@@ -1,6 +1,7 @@\n //! Inlining pass for MIR functions\n \n use rustc_attr as attr;\n+use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -12,9 +13,8 @@ use rustc_target::spec::abi::Abi;\n \n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n use crate::transform::MirPass;\n-use std::collections::VecDeque;\n use std::iter;\n-use std::ops::RangeFrom;\n+use std::ops::{Range, RangeFrom};\n \n const DEFAULT_THRESHOLD: usize = 50;\n const HINT_THRESHOLD: usize = 100;\n@@ -37,132 +37,128 @@ struct CallSite<'tcx> {\n \n impl<'tcx> MirPass<'tcx> for Inline {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n-            if tcx.sess.opts.debugging_opts.instrument_coverage {\n-                // The current implementation of source code coverage injects code region counters\n-                // into the MIR, and assumes a 1-to-1 correspondence between MIR and source-code-\n-                // based function.\n-                debug!(\"function inlining is disabled when compiling with `instrument_coverage`\");\n-            } else {\n-                Inliner {\n-                    tcx,\n-                    param_env: tcx.param_env_reveal_all_normalized(body.source.def_id()),\n-                    codegen_fn_attrs: tcx.codegen_fn_attrs(body.source.def_id()),\n-                }\n-                .run_pass(body);\n-            }\n+        if tcx.sess.opts.debugging_opts.mir_opt_level < 2 {\n+            return;\n+        }\n+\n+        if tcx.sess.opts.debugging_opts.instrument_coverage {\n+            // The current implementation of source code coverage injects code region counters\n+            // into the MIR, and assumes a 1-to-1 correspondence between MIR and source-code-\n+            // based function.\n+            debug!(\"function inlining is disabled when compiling with `instrument_coverage`\");\n+            return;\n+        }\n+\n+        if inline(tcx, body) {\n+            debug!(\"running simplify cfg on {:?}\", body.source);\n+            CfgSimplifier::new(body).simplify();\n+            remove_dead_blocks(body);\n         }\n     }\n }\n \n+fn inline(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) -> bool {\n+    let def_id = body.source.def_id();\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+\n+    // Only do inlining into fn bodies.\n+    if !tcx.hir().body_owner_kind(hir_id).is_fn_or_closure() {\n+        return false;\n+    }\n+    if body.source.promoted.is_some() {\n+        return false;\n+    }\n+\n+    let mut this = Inliner {\n+        tcx,\n+        param_env: tcx.param_env_reveal_all_normalized(body.source.def_id()),\n+        codegen_fn_attrs: tcx.codegen_fn_attrs(body.source.def_id()),\n+        hir_id,\n+        history: Vec::new(),\n+        changed: false,\n+    };\n+    let blocks = BasicBlock::new(0)..body.basic_blocks().next_index();\n+    this.process_blocks(body, blocks);\n+    this.changed\n+}\n+\n struct Inliner<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n+    /// Caller codegen attributes.\n     codegen_fn_attrs: &'tcx CodegenFnAttrs,\n+    /// Caller HirID.\n+    hir_id: hir::HirId,\n+    /// Stack of inlined instances.\n+    history: Vec<Instance<'tcx>>,\n+    /// Indicates that the caller body has been modified.\n+    changed: bool,\n }\n \n impl Inliner<'tcx> {\n-    fn run_pass(&self, caller_body: &mut Body<'tcx>) {\n-        // Keep a queue of callsites to try inlining on. We take\n-        // advantage of the fact that queries detect cycles here to\n-        // allow us to try and fetch the fully optimized MIR of a\n-        // call; if it succeeds, we can inline it and we know that\n-        // they do not call us.  Otherwise, we just don't try to\n-        // inline.\n-        //\n-        // We use a queue so that we inline \"broadly\" before we inline\n-        // in depth. It is unclear if this is the best heuristic,\n-        // really, but that's true of all the heuristics in this\n-        // file. =)\n-\n-        let mut callsites = VecDeque::new();\n-\n-        let def_id = caller_body.source.def_id();\n-\n-        // Only do inlining into fn bodies.\n-        let self_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-        if self.tcx.hir().body_owner_kind(self_hir_id).is_fn_or_closure()\n-            && caller_body.source.promoted.is_none()\n-        {\n-            for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n-                if let Some(callsite) = self.get_valid_function_call(bb, bb_data, caller_body) {\n-                    callsites.push_back(callsite);\n-                }\n-            }\n-        } else {\n-            return;\n-        }\n-\n-        let mut changed = false;\n-        while let Some(callsite) = callsites.pop_front() {\n-            debug!(\"checking whether to inline callsite {:?}\", callsite);\n+    fn process_blocks(&mut self, caller_body: &mut Body<'tcx>, blocks: Range<BasicBlock>) {\n+        for bb in blocks {\n+            let callsite = match self.get_valid_function_call(bb, &caller_body[bb], caller_body) {\n+                None => continue,\n+                Some(it) => it,\n+            };\n \n-            if let InstanceDef::Item(_) = callsite.callee.def {\n-                if !self.tcx.is_mir_available(callsite.callee.def_id()) {\n-                    debug!(\"checking whether to inline callsite {:?} - MIR unavailable\", callsite,);\n-                    continue;\n-                }\n+            if !self.is_mir_available(&callsite.callee, caller_body) {\n+                debug!(\"MIR unavailable {}\", callsite.callee);\n+                continue;\n             }\n \n-            let callee_body = if let Some(callee_def_id) = callsite.callee.def_id().as_local() {\n-                let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n-                // Avoid a cycle here by only using `instance_mir` only if we have\n-                // a lower `HirId` than the callee. This ensures that the callee will\n-                // not inline us. This trick only works without incremental compilation.\n-                // So don't do it if that is enabled. Also avoid inlining into generators,\n-                // since their `optimized_mir` is used for layout computation, which can\n-                // create a cycle, even when no attempt is made to inline the function\n-                // in the other direction.\n-                if !self.tcx.dep_graph.is_fully_enabled()\n-                    && self_hir_id < callee_hir_id\n-                    && caller_body.generator_kind.is_none()\n-                {\n-                    self.tcx.instance_mir(callsite.callee.def)\n-                } else {\n-                    continue;\n-                }\n-            } else {\n-                // This cannot result in a cycle since the callee MIR is from another crate\n-                // and is already optimized.\n-                self.tcx.instance_mir(callsite.callee.def)\n-            };\n-\n-            if !self.consider_optimizing(callsite, &callee_body) {\n+            let callee_body = self.tcx.instance_mir(callsite.callee.def);\n+            if !self.should_inline(callsite, callee_body) {\n                 continue;\n             }\n \n+            if !self.tcx.consider_optimizing(|| {\n+                format!(\"Inline {:?} into {}\", callee_body.span, callsite.callee)\n+            }) {\n+                return;\n+            }\n+\n             let callee_body = callsite.callee.subst_mir_and_normalize_erasing_regions(\n                 self.tcx,\n                 self.param_env,\n                 callee_body,\n             );\n \n-            let start = caller_body.basic_blocks().len();\n-            debug!(\"attempting to inline callsite {:?} - body={:?}\", callsite, callee_body);\n-            if !self.inline_call(callsite, caller_body, callee_body) {\n-                debug!(\"attempting to inline callsite {:?} - failure\", callsite);\n-                continue;\n-            }\n-            debug!(\"attempting to inline callsite {:?} - success\", callsite);\n-\n-            // Add callsites from inlined function\n-            for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start) {\n-                if let Some(new_callsite) = self.get_valid_function_call(bb, bb_data, caller_body) {\n-                    // Don't inline the same function multiple times.\n-                    if callsite.callee != new_callsite.callee {\n-                        callsites.push_back(new_callsite);\n-                    }\n-                }\n-            }\n+            let old_blocks = caller_body.basic_blocks().next_index();\n+            self.inline_call(callsite, caller_body, callee_body);\n+            let new_blocks = old_blocks..caller_body.basic_blocks().next_index();\n+            self.changed = true;\n+\n+            self.history.push(callsite.callee);\n+            self.process_blocks(caller_body, new_blocks);\n+            self.history.pop();\n+        }\n+    }\n \n-            changed = true;\n+    fn is_mir_available(&self, callee: &Instance<'tcx>, caller_body: &Body<'tcx>) -> bool {\n+        if let InstanceDef::Item(_) = callee.def {\n+            if !self.tcx.is_mir_available(callee.def_id()) {\n+                return false;\n+            }\n         }\n \n-        // Simplify if we inlined anything.\n-        if changed {\n-            debug!(\"running simplify cfg on {:?}\", caller_body.source);\n-            CfgSimplifier::new(caller_body).simplify();\n-            remove_dead_blocks(caller_body);\n+        if let Some(callee_def_id) = callee.def_id().as_local() {\n+            let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n+            // Avoid a cycle here by only using `instance_mir` only if we have\n+            // a lower `HirId` than the callee. This ensures that the callee will\n+            // not inline us. This trick only works without incremental compilation.\n+            // So don't do it if that is enabled. Also avoid inlining into generators,\n+            // since their `optimized_mir` is used for layout computation, which can\n+            // create a cycle, even when no attempt is made to inline the function\n+            // in the other direction.\n+            !self.tcx.dep_graph.is_fully_enabled()\n+                && self.hir_id < callee_hir_id\n+                && caller_body.generator_kind.is_none()\n+        } else {\n+            // This cannot result in a cycle since the callee MIR is from another crate\n+            // and is already optimized.\n+            true\n         }\n     }\n \n@@ -179,7 +175,8 @@ impl Inliner<'tcx> {\n \n         // Only consider direct calls to functions\n         let terminator = bb_data.terminator();\n-        if let TerminatorKind::Call { func: ref op, .. } = terminator.kind {\n+        // FIXME: Handle inlining of diverging calls\n+        if let TerminatorKind::Call { func: ref op, destination: Some(_), .. } = terminator.kind {\n             if let ty::FnDef(callee_def_id, substs) = *op.ty(caller_body, self.tcx).kind() {\n                 // To resolve an instance its substs have to be fully normalized, so\n                 // we do this here.\n@@ -200,14 +197,6 @@ impl Inliner<'tcx> {\n         None\n     }\n \n-    fn consider_optimizing(&self, callsite: CallSite<'tcx>, callee_body: &Body<'tcx>) -> bool {\n-        debug!(\"consider_optimizing({:?})\", callsite);\n-        self.should_inline(callsite, callee_body)\n-            && self.tcx.consider_optimizing(|| {\n-                format!(\"Inline {:?} into {:?}\", callee_body.span, callsite)\n-            })\n-    }\n-\n     fn should_inline(&self, callsite: CallSite<'tcx>, callee_body: &Body<'tcx>) -> bool {\n         debug!(\"should_inline({:?})\", callsite);\n         let tcx = self.tcx;\n@@ -327,7 +316,18 @@ impl Inliner<'tcx> {\n                 }\n \n                 TerminatorKind::Call { func: Operand::Constant(ref f), cleanup, .. } => {\n-                    if let ty::FnDef(def_id, _) = *f.literal.ty.kind() {\n+                    if let ty::FnDef(def_id, substs) =\n+                        *callsite.callee.subst_mir(self.tcx, &f.literal.ty).kind()\n+                    {\n+                        let substs = self.tcx.normalize_erasing_regions(self.param_env, substs);\n+                        if let Ok(Some(instance)) =\n+                            Instance::resolve(self.tcx, self.param_env, def_id, substs)\n+                        {\n+                            if callsite.callee == instance || self.history.contains(&instance) {\n+                                debug!(\"`callee is recursive - not inlining\");\n+                                return false;\n+                            }\n+                        }\n                         // Don't give intrinsics the extra penalty for calls\n                         let f = tcx.fn_sig(def_id);\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n@@ -397,13 +397,10 @@ impl Inliner<'tcx> {\n         callsite: CallSite<'tcx>,\n         caller_body: &mut Body<'tcx>,\n         mut callee_body: Body<'tcx>,\n-    ) -> bool {\n+    ) {\n         let terminator = caller_body[callsite.bb].terminator.take().unwrap();\n         match terminator.kind {\n-            // FIXME: Handle inlining of diverging calls\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n-                debug!(\"inlined {:?} into {:?}\", callsite.callee, caller_body.source);\n-\n                 // If the call is something like `a[*i] = f(i)`, where\n                 // `i : &mut usize`, then just duplicating the `a[*i]`\n                 // Place could result in two different locations if `f`\n@@ -519,14 +516,8 @@ impl Inliner<'tcx> {\n                         matches!(constant.literal.val, ConstKind::Unevaluated(_, _, _))\n                     }),\n                 );\n-\n-                true\n-            }\n-            kind => {\n-                caller_body[callsite.bb].terminator =\n-                    Some(Terminator { source_info: terminator.source_info, kind });\n-                false\n             }\n+            kind => bug!(\"unexpected terminator kind {:?}\", kind),\n         }\n     }\n "}, {"sha": "63ad57de1d46495147c786fc4f69c73952d6d29b", "filename": "src/test/mir-opt/inline/inline-cycle.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ee1fedf392518ede3ff9940d6ff83ff280b59000/src%2Ftest%2Fmir-opt%2Finline%2Finline-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee1fedf392518ede3ff9940d6ff83ff280b59000/src%2Ftest%2Fmir-opt%2Finline%2Finline-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-cycle.rs?ref=ee1fedf392518ede3ff9940d6ff83ff280b59000", "patch": "@@ -0,0 +1,60 @@\n+// Check that inliner handles various forms of recursion and doesn't fall into\n+// an infinite inlining cycle. The particular outcome of inlining is not\n+// crucial otherwise.\n+//\n+// Regression test for issue #78573.\n+\n+fn main() {\n+    one();\n+    two();\n+}\n+\n+// EMIT_MIR inline_cycle.one.Inline.diff\n+fn one() {\n+    <C as Call>::call();\n+}\n+\n+pub trait Call {\n+    fn call();\n+}\n+\n+pub struct A<T>(T);\n+pub struct B<T>(T);\n+pub struct C;\n+\n+impl<T: Call> Call for A<T> {\n+    #[inline]\n+    fn call() {\n+        <B<T> as Call>::call()\n+    }\n+}\n+\n+\n+impl<T: Call> Call for B<T> {\n+    #[inline]\n+    fn call() {\n+        <T as Call>::call()\n+    }\n+}\n+\n+impl Call for C {\n+    #[inline]\n+    fn call() {\n+        A::<C>::call()\n+    }\n+}\n+\n+// EMIT_MIR inline_cycle.two.Inline.diff\n+fn two() {\n+    call(f);\n+}\n+\n+#[inline]\n+fn call<F: FnOnce()>(f: F) {\n+    f();\n+}\n+\n+#[inline]\n+fn f() {\n+    call(f);\n+}"}, {"sha": "1b53c82788540b1b093b66e57895ad8cb2453930", "filename": "src/test/mir-opt/inline/inline_cycle.one.Inline.diff", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ee1fedf392518ede3ff9940d6ff83ff280b59000/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.one.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/ee1fedf392518ede3ff9940d6ff83ff280b59000/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.one.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.one.Inline.diff?ref=ee1fedf392518ede3ff9940d6ff83ff280b59000", "patch": "@@ -0,0 +1,27 @@\n+- // MIR for `one` before Inline\n++ // MIR for `one` after Inline\n+  \n+  fn one() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-cycle.rs:13:10: 13:10\n+      let _1: ();                          // in scope 0 at $DIR/inline-cycle.rs:14:5: 14:24\n++     scope 1 (inlined <C as Call>::call) { // at $DIR/inline-cycle.rs:14:5: 14:24\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-cycle.rs:14:5: 14:24\n+-         _1 = <C as Call>::call() -> bb1; // scope 0 at $DIR/inline-cycle.rs:14:5: 14:24\n++         _1 = <A<C> as Call>::call() -> bb1; // scope 1 at $DIR/inline-cycle.rs:14:5: 14:24\n+                                           // mir::Constant\n+-                                          // + span: $DIR/inline-cycle.rs:14:5: 14:22\n+-                                          // + literal: Const { ty: fn() {<C as Call>::call}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: $DIR/inline-cycle.rs:14:5: 14:24\n++                                          // + literal: Const { ty: fn() {<A<C> as Call>::call}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-cycle.rs:14:24: 14:25\n+          _0 = const ();                   // scope 0 at $DIR/inline-cycle.rs:13:10: 15:2\n+          return;                          // scope 0 at $DIR/inline-cycle.rs:15:2: 15:2\n+      }\n+  }\n+  "}, {"sha": "b44baca9bf49794ef9268408168fb58dcdb3ecfa", "filename": "src/test/mir-opt/inline/inline_cycle.two.Inline.diff", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ee1fedf392518ede3ff9940d6ff83ff280b59000/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/ee1fedf392518ede3ff9940d6ff83ff280b59000/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff?ref=ee1fedf392518ede3ff9940d6ff83ff280b59000", "patch": "@@ -0,0 +1,47 @@\n+- // MIR for `two` before Inline\n++ // MIR for `two` after Inline\n+  \n+  fn two() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-cycle.rs:48:10: 48:10\n+      let _1: ();                          // in scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n++     let mut _2: fn() {f};                // in scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n++     let mut _5: ();                      // in scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n++     scope 1 (inlined call::<fn() {f}>) { // at $DIR/inline-cycle.rs:49:5: 49:12\n++         debug f => _2;                   // in scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         let _3: ();                      // in scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         let mut _4: fn() {f};            // in scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         scope 2 (inlined <fn() {f} as FnOnce<()>>::call_once - shim(fn() {f})) { // at $DIR/inline-cycle.rs:49:5: 49:12\n++         }\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n+-         _1 = call::<fn() {f}>(f) -> bb1; // scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n++         StorageLive(_2);                 // scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n++         _2 = f;                          // scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n+                                           // mir::Constant\n+-                                          // + span: $DIR/inline-cycle.rs:49:5: 49:9\n+-                                          // + literal: Const { ty: fn(fn() {f}) {call::<fn() {f}>}, val: Value(Scalar(<ZST>)) }\n+-                                          // mir::Constant\n+                                           // + span: $DIR/inline-cycle.rs:49:10: 49:11\n+                                           // + literal: Const { ty: fn() {f}, val: Value(Scalar(<ZST>)) }\n++         StorageLive(_3);                 // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         StorageLive(_4);                 // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         _4 = move _2;                    // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         StorageLive(_5);                 // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         _5 = const ();                   // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         _3 = move _4() -> bb1;           // scope 2 at $DIR/inline-cycle.rs:49:5: 49:12\n+      }\n+  \n+      bb1: {\n++         StorageDead(_5);                 // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         StorageDead(_4);                 // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         StorageDead(_3);                 // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         _1 = const ();                   // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         StorageDead(_2);                 // scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-cycle.rs:49:12: 49:13\n+          _0 = const ();                   // scope 0 at $DIR/inline-cycle.rs:48:10: 50:2\n+          return;                          // scope 0 at $DIR/inline-cycle.rs:50:2: 50:2\n+      }\n+  }\n+  "}]}