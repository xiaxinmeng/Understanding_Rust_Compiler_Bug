{"sha": "8f987956b4d173c9af26fbf2aafcc661abcc14cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmOTg3OTU2YjRkMTczYzlhZjI2ZmJmMmFhZmNjNjYxYWJjYzE0Y2I=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-22T09:52:08Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-24T07:38:55Z"}, "message": "Added new kind of drop-glue that just drops the type's contents,\nwithout invoking the Drop::drop implementation.\n\nThis is necessary for dealing with an enum that switches own `self` to\na different variant while running its destructor.\n\nFix #23611.", "tree": {"sha": "c7997f7c21c7d314d3e53f45bc90116c736bcc85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7997f7c21c7d314d3e53f45bc90116c736bcc85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f987956b4d173c9af26fbf2aafcc661abcc14cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f987956b4d173c9af26fbf2aafcc661abcc14cb", "html_url": "https://github.com/rust-lang/rust/commit/8f987956b4d173c9af26fbf2aafcc661abcc14cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f987956b4d173c9af26fbf2aafcc661abcc14cb/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7d9b439720fed4434a532244f0eb873cf14eb91", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7d9b439720fed4434a532244f0eb873cf14eb91", "html_url": "https://github.com/rust-lang/rust/commit/f7d9b439720fed4434a532244f0eb873cf14eb91"}], "stats": {"total": 226, "additions": 164, "deletions": 62}, "files": [{"sha": "1aa996a05ac6d0fb23a86b7eadf43be6a5216fc7", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f987956b4d173c9af26fbf2aafcc661abcc14cb/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f987956b4d173c9af26fbf2aafcc661abcc14cb/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=8f987956b4d173c9af26fbf2aafcc661abcc14cb", "patch": "@@ -916,7 +916,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n         let datum = Datum::new(llval, binding_info.ty, Lvalue);\n         if let Some(cs) = cs {\n-            bcx.fcx.schedule_drop_and_zero_mem(cs, llval, binding_info.ty);\n+            bcx.fcx.schedule_drop_and_fill_mem(cs, llval, binding_info.ty);\n             bcx.fcx.schedule_lifetime_end(cs, binding_info.llmatch);\n         }\n "}, {"sha": "3ec73ff8eb9de129ffb1b8afe40b9b98556cc570", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 67, "deletions": 17, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8f987956b4d173c9af26fbf2aafcc661abcc14cb/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f987956b4d173c9af26fbf2aafcc661abcc14cb/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=8f987956b4d173c9af26fbf2aafcc661abcc14cb", "patch": "@@ -393,19 +393,22 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n-            zero: false\n+            fill_on_drop: false,\n+            skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n+        debug!(\"schedule_drop_mem({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()));\n+               ty.repr(self.ccx.tcx()),\n+               drop.fill_on_drop,\n+               drop.skip_dtor);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n \n-    /// Schedules a (deep) drop and zero-ing of `val`, which is a pointer to an instance of `ty`\n-    fn schedule_drop_and_zero_mem(&self,\n+    /// Schedules a (deep) drop and filling of `val`, which is a pointer to an instance of `ty`\n+    fn schedule_drop_and_fill_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n                                   ty: Ty<'tcx>) {\n@@ -416,14 +419,48 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n-            zero: true\n+            fill_on_drop: true,\n+            skip_dtor: false,\n+        };\n+\n+        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={}, fill_on_drop={}, skip_dtor={})\",\n+               cleanup_scope,\n+               self.ccx.tn().val_to_string(val),\n+               ty.repr(self.ccx.tcx()),\n+               drop.fill_on_drop,\n+               drop.skip_dtor);\n+\n+        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n+    }\n+\n+    /// Issue #23611: Schedules a (deep) drop of the contents of\n+    /// `val`, which is a pointer to an instance of struct/enum type\n+    /// `ty`. The scheduled code handles extracting the discriminant\n+    /// and dropping the contents associated with that variant\n+    /// *without* executing any associated drop implementation.\n+    fn schedule_drop_enum_contents(&self,\n+                                   cleanup_scope: ScopeId,\n+                                   val: ValueRef,\n+                                   ty: Ty<'tcx>) {\n+        // `if` below could be \"!contents_needs_drop\"; skipping drop\n+        // is just an optimization, so sound to be conservative.\n+        if !self.type_needs_drop(ty) { return; }\n+\n+        let drop = box DropValue {\n+            is_immediate: false,\n+            must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n+            val: val,\n+            ty: ty,\n+            fill_on_drop: false,\n+            skip_dtor: true,\n         };\n \n-        debug!(\"schedule_drop_and_zero_mem({:?}, val={}, ty={}, zero={})\",\n+        debug!(\"schedule_drop_enum_contents({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()),\n-               true);\n+               drop.fill_on_drop,\n+               drop.skip_dtor);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n@@ -440,13 +477,16 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n-            zero: false\n+            fill_on_drop: false,\n+            skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?})\",\n+        debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()));\n+               ty.repr(self.ccx.tcx()),\n+               drop.fill_on_drop,\n+               drop.skip_dtor);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n@@ -987,7 +1027,8 @@ pub struct DropValue<'tcx> {\n     must_unwind: bool,\n     val: ValueRef,\n     ty: Ty<'tcx>,\n-    zero: bool\n+    fill_on_drop: bool,\n+    skip_dtor: bool,\n }\n \n impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n@@ -1007,13 +1048,18 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n                    bcx: Block<'blk, 'tcx>,\n                    debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        let _icx = base::push_ctxt(\"<DropValue as Cleanup>::trans\");\n+        let skip_dtor = self.skip_dtor;\n+        let _icx = if skip_dtor {\n+            base::push_ctxt(\"<DropValue as Cleanup>::trans skip_dtor=true\")\n+        } else {\n+            base::push_ctxt(\"<DropValue as Cleanup>::trans skip_dtor=false\")\n+        };\n         let bcx = if self.is_immediate {\n-            glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc)\n+            glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n         } else {\n-            glue::drop_ty(bcx, self.val, self.ty, debug_loc)\n+            glue::drop_ty_core(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n         };\n-        if self.zero {\n+        if self.fill_on_drop {\n             base::drop_done_fill_mem(bcx, self.val, self.ty);\n         }\n         bcx\n@@ -1190,10 +1236,14 @@ pub trait CleanupMethods<'blk, 'tcx> {\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n                          ty: Ty<'tcx>);\n-    fn schedule_drop_and_zero_mem(&self,\n+    fn schedule_drop_and_fill_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n                                   ty: Ty<'tcx>);\n+    fn schedule_drop_enum_contents(&self,\n+                                   cleanup_scope: ScopeId,\n+                                   val: ValueRef,\n+                                   ty: Ty<'tcx>);\n     fn schedule_drop_immediate(&self,\n                                cleanup_scope: ScopeId,\n                                val: ValueRef,"}, {"sha": "98187d76df89bb39b40c414fffe6ea4c5f41af5b", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f987956b4d173c9af26fbf2aafcc661abcc14cb/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f987956b4d173c9af26fbf2aafcc661abcc14cb/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=8f987956b4d173c9af26fbf2aafcc661abcc14cb", "patch": "@@ -21,6 +21,7 @@ use trans::builder::Builder;\n use trans::common::{ExternMap,BuilderRef_res};\n use trans::debuginfo;\n use trans::declare;\n+use trans::glue::DropGlueKind;\n use trans::monomorphize::MonoId;\n use trans::type_::{Type, TypeNames};\n use middle::subst::Substs;\n@@ -73,7 +74,7 @@ pub struct SharedCrateContext<'tcx> {\n     check_drop_flag_for_sanity: bool,\n \n     available_monomorphizations: RefCell<FnvHashSet<String>>,\n-    available_drop_glues: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n+    available_drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, String>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -89,7 +90,7 @@ pub struct LocalCrateContext<'tcx> {\n     item_vals: RefCell<NodeMap<ValueRef>>,\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n-    drop_glues: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n+    drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>>,\n     /// Track mapping of external ids to local items imported for inlining\n     external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     /// Backwards version of the `external` map (inlined items to where they\n@@ -574,7 +575,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.fn_pointer_shims\n     }\n \n-    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n+    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>> {\n         &self.local.drop_glues\n     }\n \n@@ -660,7 +661,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.available_monomorphizations\n     }\n \n-    pub fn available_drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n+    pub fn available_drop_glues(&self) -> &RefCell<FnvHashMap<DropGlueKind<'tcx>, String>> {\n         &self.shared.available_drop_glues\n     }\n "}, {"sha": "7bda273c2351bfd0c34b6605030bdd10afc6060a", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 91, "deletions": 40, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/8f987956b4d173c9af26fbf2aafcc661abcc14cb/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f987956b4d173c9af26fbf2aafcc661abcc14cb/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=8f987956b4d173c9af26fbf2aafcc661abcc14cb", "patch": "@@ -132,14 +132,26 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            v: ValueRef,\n                            t: Ty<'tcx>,\n-                           debug_loc: DebugLoc)\n-                           -> Block<'blk, 'tcx> {\n+                           debug_loc: DebugLoc) -> Block<'blk, 'tcx> {\n+    drop_ty_core(bcx, v, t, debug_loc, false)\n+}\n+\n+pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                v: ValueRef,\n+                                t: Ty<'tcx>,\n+                                debug_loc: DebugLoc,\n+                                skip_dtor: bool) -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n+    debug!(\"drop_ty_core(t={}, skip_dtor={})\", t.repr(bcx.tcx()), skip_dtor);\n     let _icx = push_ctxt(\"drop_ty\");\n     if bcx.fcx.type_needs_drop(t) {\n         let ccx = bcx.ccx();\n-        let glue = get_drop_glue(ccx, t);\n+        let g = if skip_dtor {\n+            DropGlueKind::TyContents(t)\n+        } else {\n+            DropGlueKind::Ty(t)\n+        };\n+        let glue = get_drop_glue_core(ccx, g);\n         let glue_type = get_drop_glue_type(ccx, t);\n         let ptr = if glue_type != t {\n             PointerCast(bcx, v, type_of(ccx, glue_type).ptr_to())\n@@ -155,22 +167,64 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      v: ValueRef,\n                                      t: Ty<'tcx>,\n-                                     debug_loc: DebugLoc)\n+                                     debug_loc: DebugLoc,\n+                                     skip_dtor: bool)\n                                      -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     store_ty(bcx, v, vp, t);\n-    drop_ty(bcx, vp, t, debug_loc)\n+    drop_ty_core(bcx, vp, t, debug_loc, skip_dtor)\n }\n \n pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {\n-    debug!(\"make drop glue for {}\", ppaux::ty_to_string(ccx.tcx(), t));\n-    let t = get_drop_glue_type(ccx, t);\n-    debug!(\"drop glue type {}\", ppaux::ty_to_string(ccx.tcx(), t));\n-    match ccx.drop_glues().borrow().get(&t) {\n+    get_drop_glue_core(ccx, DropGlueKind::Ty(t))\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum DropGlueKind<'tcx> {\n+    /// The normal path; runs the dtor, and then recurs on the contents\n+    Ty(Ty<'tcx>),\n+    /// Skips the dtor, if any, for ty; drops the contents directly.\n+    /// Note that the dtor is only skipped at the most *shallow*\n+    /// level, namely, an `impl Drop for Ty` itself. So, for example,\n+    /// if Ty is Newtype(S) then only the Drop impl for for Newtype\n+    /// itself will be skipped, while the Drop impl for S, if any,\n+    /// will be invoked.\n+    TyContents(Ty<'tcx>),\n+}\n+\n+impl<'tcx> DropGlueKind<'tcx> {\n+    fn ty(&self) -> Ty<'tcx> {\n+        match *self { DropGlueKind::Ty(t) | DropGlueKind::TyContents(t) => t }\n+    }\n+\n+    fn map_ty<F>(&self, mut f: F) -> DropGlueKind<'tcx> where F: FnMut(Ty<'tcx>) -> Ty<'tcx>\n+    {\n+        match *self {\n+            DropGlueKind::Ty(t) => DropGlueKind::Ty(f(t)),\n+            DropGlueKind::TyContents(t) => DropGlueKind::TyContents(f(t)),\n+        }\n+    }\n+\n+    fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n+        let t_str = ppaux::ty_to_string(ccx.tcx(), self.ty());\n+        match *self {\n+            DropGlueKind::Ty(_) => format!(\"DropGlueKind::Ty({})\", t_str),\n+            DropGlueKind::TyContents(_) => format!(\"DropGlueKind::TyContents({})\", t_str),\n+        }\n+    }\n+}\n+\n+fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                g: DropGlueKind<'tcx>) -> ValueRef {\n+    debug!(\"make drop glue for {}\", g.to_string(ccx));\n+    let g = g.map_ty(|t| get_drop_glue_type(ccx, t));\n+    debug!(\"drop glue type {}\", g.to_string(ccx));\n+    match ccx.drop_glues().borrow().get(&g) {\n         Some(&glue) => return glue,\n         _ => { }\n     }\n+    let t = g.ty();\n \n     let llty = if type_is_sized(ccx.tcx(), t) {\n         type_of(ccx, t).ptr_to()\n@@ -182,17 +236,17 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n \n     // To avoid infinite recursion, don't `make_drop_glue` until after we've\n     // added the entry to the `drop_glues` cache.\n-    if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&t) {\n+    if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&g) {\n         let llfn = declare::declare_cfn(ccx, &old_sym, llfnty, ty::mk_nil(ccx.tcx()));\n-        ccx.drop_glues().borrow_mut().insert(t, llfn);\n+        ccx.drop_glues().borrow_mut().insert(g, llfn);\n         return llfn;\n     };\n \n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, \"drop\");\n     let llfn = declare::define_cfn(ccx, &fn_nm, llfnty, ty::mk_nil(ccx.tcx())).unwrap_or_else(||{\n        ccx.sess().bug(&format!(\"symbol `{}` already defined\", fn_nm));\n     });\n-    ccx.available_drop_glues().borrow_mut().insert(t, fn_nm);\n+    ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n \n     let _s = StatRecorder::new(ccx, format!(\"drop {}\", ty_to_short_str(ccx.tcx(), t)));\n \n@@ -217,7 +271,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n     // type, so we don't need to explicitly cast the function parameter.\n \n     let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n-    let bcx = make_drop_glue(bcx, llrawptr0, t);\n+    let bcx = make_drop_glue(bcx, llrawptr0, g);\n     finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n \n     llfn\n@@ -338,11 +392,16 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         (Load(bcx, data), Some(Load(bcx, info)))\n     };\n \n-    adt::fold_variants(bcx, &*repr, struct_data, |variant_cx, st, value| {\n-        // Be sure to put all of the fields into a scope so we can use an invoke\n+    debug!(\"trans_struct_drop t: {} fty: {} self_ty: {}\",\n+           bcx.ty_to_string(t), bcx.ty_to_string(fty), bcx.ty_to_string(self_ty));\n+    // TODO: surely no reason to keep dispatching on variants here.\n+    adt::fold_variants(bcx, &*repr, struct_data, |variant_cx, struct_info, value| {\n+        debug!(\"trans_struct_drop fold_variant: struct_info: {:?}\", struct_info);\n+        // Be sure to put the enum contents into a scope so we can use an invoke\n         // instruction to call the user destructor but still call the field\n         // destructors if the user destructor panics.\n         let field_scope = variant_cx.fcx.push_custom_cleanup_scope();\n+        variant_cx.fcx.schedule_drop_enum_contents(cleanup::CustomScope(field_scope), v0, t);\n \n         // Class dtors have no explicit args, so the params should\n         // just consist of the environment (self).\n@@ -362,30 +421,12 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         } else {\n             PointerCast(variant_cx, value, params[0])\n         };\n-        let args = vec!(self_arg);\n-\n-        // Add all the fields as a value which needs to be cleaned at the end of\n-        // this scope. Iterate in reverse order so a Drop impl doesn't reverse\n-        // the order in which fields get dropped.\n-        for (i, &ty) in st.fields.iter().enumerate().rev() {\n-            let llfld_a = adt::struct_field_ptr(variant_cx, &*st, value, i, false);\n-\n-            let val = if type_is_sized(bcx.tcx(), ty) {\n-                llfld_a\n-            } else {\n-                let scratch = datum::rvalue_scratch_datum(bcx, ty, \"__fat_ptr_drop_field\");\n-                Store(bcx, llfld_a, GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n-                Store(bcx, info.unwrap(), GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n-                scratch.val\n-            };\n-            variant_cx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope), val, ty);\n-        }\n \n         let dtor_ty = ty::mk_ctor_fn(bcx.tcx(),\n                                      class_did,\n                                      &[get_drop_glue_type(bcx.ccx(), t)],\n                                      ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[..], dtor_ty, DebugLoc::None);\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &[self_arg], dtor_ty, DebugLoc::None);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope)\n     })\n@@ -454,8 +495,10 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n     }\n }\n \n-fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n+fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueKind<'tcx>)\n                               -> Block<'blk, 'tcx> {\n+    let t = g.ty();\n+    let skip_dtor = match g { DropGlueKind::Ty(_) => false, DropGlueKind::TyContents(_) => true };\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n \n@@ -469,6 +512,10 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n \n     match t.sty {\n         ty::ty_uniq(content_ty) => {\n+            // Support for ty_uniq is built-in and its drop glue is\n+            // special. It may move to library and have Drop impl. As\n+            // a safe-guard, assert ty_uniq not used with TyContents.\n+            assert!(!skip_dtor);\n             if !type_is_sized(bcx.tcx(), content_ty) {\n                 let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n                 let llbox = Load(bcx, llval);\n@@ -505,8 +552,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n         }\n         ty::ty_struct(did, substs) | ty::ty_enum(did, substs) => {\n             let tcx = bcx.tcx();\n-            match ty::ty_dtor(tcx, did) {\n-                ty::TraitDtor(dtor, true) => {\n+            match (ty::ty_dtor(tcx, did), skip_dtor) {\n+                (ty::TraitDtor(dtor, true), false) => {\n                     // FIXME(16758) Since the struct is unsized, it is hard to\n                     // find the drop flag (which is at the end of the struct).\n                     // Lets just ignore the flag and pretend everything will be\n@@ -523,16 +570,20 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                     }\n                 }\n-                ty::TraitDtor(dtor, false) => {\n+                (ty::TraitDtor(dtor, false), false) => {\n                     trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                 }\n-                ty::NoDtor => {\n+                (ty::NoDtor, _) | (_, true) => {\n                     // No dtor? Just the default case\n                     iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n                 }\n             }\n         }\n         ty::ty_trait(..) => {\n+            // No support in vtable for distinguishing destroying with\n+            // versus without calling Drop::drop. Assert caller is\n+            // okay with always calling the Drop impl, if any.\n+            assert!(!skip_dtor);\n             let data_ptr = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n             let vtable_ptr = Load(bcx, GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]));\n             let dtor = Load(bcx, vtable_ptr);"}]}