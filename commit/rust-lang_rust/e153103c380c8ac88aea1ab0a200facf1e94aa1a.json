{"sha": "e153103c380c8ac88aea1ab0a200facf1e94aa1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNTMxMDNjMzgwYzhhYzg4YWVhMWFiMGEyMDBmYWNmMWU5NGFhMWE=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-01T13:39:17Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-05T07:00:53Z"}, "message": "rustc/ty: improve allocations", "tree": {"sha": "52db0efef96f5b490d8415d73af0469320cd20a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52db0efef96f5b490d8415d73af0469320cd20a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e153103c380c8ac88aea1ab0a200facf1e94aa1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e153103c380c8ac88aea1ab0a200facf1e94aa1a", "html_url": "https://github.com/rust-lang/rust/commit/e153103c380c8ac88aea1ab0a200facf1e94aa1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e153103c380c8ac88aea1ab0a200facf1e94aa1a/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "029e2618d007e0aebc1a45f8350f9c89df4d18dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/029e2618d007e0aebc1a45f8350f9c89df4d18dc", "html_url": "https://github.com/rust-lang/rust/commit/029e2618d007e0aebc1a45f8350f9c89df4d18dc"}], "stats": {"total": 70, "additions": 32, "deletions": 38}, "files": [{"sha": "7bc77e1b1a14053350f9b25e3bdfde56772840dd", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e153103c380c8ac88aea1ab0a200facf1e94aa1a/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e153103c380c8ac88aea1ab0a200facf1e94aa1a/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=e153103c380c8ac88aea1ab0a200facf1e94aa1a", "patch": "@@ -87,11 +87,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n             }\n             ret.root_ids.extend(old_ret.drain());\n \n-            for id in next_forest.root_ids {\n-                if ret.contains(tcx, id) {\n-                    next_ret.push(id);\n-                }\n-            }\n+            next_ret.extend(next_forest.root_ids.into_iter().filter(|&id| ret.contains(tcx, id)));\n \n             mem::swap(&mut next_ret, &mut ret.root_ids);\n             next_ret.drain();\n@@ -107,11 +103,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n         let mut ret = DefIdForest::empty();\n         let mut next_ret = SmallVec::new();\n         for next_forest in iter {\n-            for id in ret.root_ids.drain() {\n-                if !next_forest.contains(tcx, id) {\n-                    next_ret.push(id);\n-                }\n-            }\n+            next_ret.extend(ret.root_ids.drain().filter(|&id| !next_forest.contains(tcx, id)));\n \n             for id in next_forest.root_ids {\n                 if !next_ret.contains(&id) {"}, {"sha": "a1dc4f16ce999e1c9c022a400d9e728d673c2cc4", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e153103c380c8ac88aea1ab0a200facf1e94aa1a/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e153103c380c8ac88aea1ab0a200facf1e94aa1a/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=e153103c380c8ac88aea1ab0a200facf1e94aa1a", "patch": "@@ -388,7 +388,7 @@ fn remove_cycle<'tcx>(\n \n         // Find the queries in the cycle which are\n         // connected to queries outside the cycle\n-        let entry_points: Vec<Lrc<QueryJob<'tcx>>> = stack.iter().filter_map(|query| {\n+        let entry_points = stack.iter().filter_map(|query| {\n             // Mark all the other queries in the cycle as already visited\n             let mut visited = FxHashSet::from_iter(stack.iter().filter_map(|q| {\n                 if q.1.as_ptr() != query.1.as_ptr() {\n@@ -403,12 +403,12 @@ fn remove_cycle<'tcx>(\n             } else {\n                 None\n             }\n-        }).collect();\n+        });\n \n         // Deterministically pick an entry point\n         // FIXME: Sort this instead\n         let mut hcx = tcx.create_stable_hashing_context();\n-        let entry_point = entry_points.iter().min_by_key(|q| {\n+        let entry_point = entry_points.min_by_key(|q| {\n             let mut stable_hasher = StableHasher::<u64>::new();\n             q.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n             stable_hasher.finish()"}, {"sha": "ce580c7803355ea8e5de3b3baabd1ad4351572bf", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e153103c380c8ac88aea1ab0a200facf1e94aa1a/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e153103c380c8ac88aea1ab0a200facf1e94aa1a/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=e153103c380c8ac88aea1ab0a200facf1e94aa1a", "patch": "@@ -254,23 +254,19 @@ impl<'sess> OnDiskCache<'sess> {\n             })?;\n \n             // Encode diagnostics\n-            let diagnostics_index = {\n-                let mut diagnostics_index = EncodedDiagnosticsIndex::new();\n-\n-                for (dep_node_index, diagnostics) in self.current_diagnostics\n-                                                        .borrow()\n-                                                        .iter() {\n-                    let pos = AbsoluteBytePos::new(encoder.position());\n-                    // Let's make sure we get the expected type here:\n-                    let diagnostics: &EncodedDiagnostics = diagnostics;\n-                    let dep_node_index =\n-                        SerializedDepNodeIndex::new(dep_node_index.index());\n-                    encoder.encode_tagged(dep_node_index, diagnostics)?;\n-                    diagnostics_index.push((dep_node_index, pos));\n-                }\n-\n-                diagnostics_index\n-            };\n+            let diagnostics_index: EncodedDiagnosticsIndex = self.current_diagnostics.borrow()\n+                .iter()\n+                .map(|(dep_node_index, diagnostics)|\n+            {\n+                let pos = AbsoluteBytePos::new(encoder.position());\n+                // Let's make sure we get the expected type here:\n+                let diagnostics: &EncodedDiagnostics = diagnostics;\n+                let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n+                encoder.encode_tagged(dep_node_index, diagnostics)?;\n+\n+                Ok((dep_node_index, pos))\n+            })\n+            .collect::<Result<_, _>>()?;\n \n             let interpret_alloc_index = {\n                 let mut interpret_alloc_index = Vec::new();\n@@ -282,6 +278,7 @@ impl<'sess> OnDiskCache<'sess> {\n                         // otherwise, abort\n                         break;\n                     }\n+                    interpret_alloc_index.reserve(new_n);\n                     for idx in n..new_n {\n                         let id = encoder.interpret_allocs_inverse[idx];\n                         let pos = encoder.position() as u32;"}, {"sha": "39a59cf090ea80b5b99363c616ada5dc16d4a588", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e153103c380c8ac88aea1ab0a200facf1e94aa1a/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e153103c380c8ac88aea1ab0a200facf1e94aa1a/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=e153103c380c8ac88aea1ab0a200facf1e94aa1a", "patch": "@@ -709,14 +709,19 @@ macro_rules! define_queries_inner {\n \n                 // We use try_lock here since we are only called from the\n                 // deadlock handler, and this shouldn't be locked\n-                $(for v in self.$name.try_lock().unwrap().active.values() {\n-                    match *v {\n-                        QueryResult::Started(ref job) => jobs.push(job.clone()),\n-                        _ => (),\n-                    }\n-                })*\n-\n-                return jobs;\n+                $(\n+                    jobs.extend(\n+                        self.$name.try_lock().unwrap().active.values().filter_map(|v|\n+                            if let QueryResult::Started(ref job) = *v {\n+                                Some(job.clone())\n+                            } else {\n+                                None\n+                            }\n+                        )\n+                    );\n+                )*\n+\n+                jobs\n             }\n         }\n "}]}