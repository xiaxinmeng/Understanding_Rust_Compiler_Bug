{"sha": "ce8967a7b3bc314a21fa96bf4ee479f6481f110a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlODk2N2E3YjNiYzMxNGEyMWZhOTZiZjRlZTQ3OWY2NDgxZjExMGE=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2017-11-17T00:09:18Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2017-11-17T00:09:18Z"}, "message": "Modified to output intended error.", "tree": {"sha": "1b1b5052664d6aea8bbb280d620c1b5f5aaced59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b1b5052664d6aea8bbb280d620c1b5f5aaced59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce8967a7b3bc314a21fa96bf4ee479f6481f110a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCgAGBQJaDiivAAoJEAF2C0+fU/FUgIAP/20lOEeYEo6WGSm8Hevcp0/q\ncxRSkeUpO01zGQumkqVM4x88Tp6306z9Fn7W/Gjq1NKYfDCdKjOjJl0W7JXOETxd\nBsC+ZkHfdSNd2/LGY5ylRvNFUjq0W9ltBK8VrEmJQAyNmdXlfXM28w3siCLKD8hG\nOKgFoKmbxK1ueEfl0CKIXzHDoBxh74arfW4nrrj632qpoVPinUUrPm0kEIOv8zGA\n3fAhp3NLsDrOAigw1kU1znHOwW8fDgVSuiZ44t1UGXQILVZbAmJEt5vylXH0VWHG\nfw/SpX8HgrMu75FNpXjG8A330pEZ2ocy7MCaQbGVsFVGRVv3V7l0symTDsgOQFW2\nDpNl6a49RjTCNBg6qVUvRfq1OSyppk8xzQGP8+9eMNcu8C0I01+D0+TEedJAkQ4s\nKG1l4M2slmsUUoWT8wh3AevX2vCuKVfP3SuUUXxSsEXnYqLCPSs41vXSLpyh79rv\nbrt6LLe9djnVWHN9S9DqK4hFKhAxf7AydAJHN3Cp0VphLfV2bGcN1ABVLtxLK2no\nDdkfUznPwfSpbcTzBdI6TIwdgY+gXhLk2NYJAG/z/K5w2uvRel4H5wVG7ZZJO+u5\ndSpRtG8w5px5YCyaU5VF/txDuvTkPBGYysfi6HVugxFHPEgOya99AJKa8ePoX3vt\n0TzJzWie/QLEnYgJzqMJ\n=ncqi\n-----END PGP SIGNATURE-----", "payload": "tree 1b1b5052664d6aea8bbb280d620c1b5f5aaced59\nparent a98aff7a5dc35bd047a5406e9fbd6b6b3ed72a52\nauthor David Wood <david@davidtw.co> 1510877358 +0000\ncommitter David Wood <david@davidtw.co> 1510877358 +0000\n\nModified to output intended error.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce8967a7b3bc314a21fa96bf4ee479f6481f110a", "html_url": "https://github.com/rust-lang/rust/commit/ce8967a7b3bc314a21fa96bf4ee479f6481f110a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce8967a7b3bc314a21fa96bf4ee479f6481f110a/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a98aff7a5dc35bd047a5406e9fbd6b6b3ed72a52", "url": "https://api.github.com/repos/rust-lang/rust/commits/a98aff7a5dc35bd047a5406e9fbd6b6b3ed72a52", "html_url": "https://github.com/rust-lang/rust/commit/a98aff7a5dc35bd047a5406e9fbd6b6b3ed72a52"}], "stats": {"total": 104, "additions": 83, "deletions": 21}, "files": [{"sha": "6ba3f5054797419487e94010698ace5184c03086", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 83, "deletions": 21, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ce8967a7b3bc314a21fa96bf4ee479f6481f110a/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8967a7b3bc314a21fa96bf4ee479f6481f110a/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=ce8967a7b3bc314a21fa96bf4ee479f6481f110a", "patch": "@@ -25,7 +25,7 @@ use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n use rustc_data_structures::indexed_vec::{Idx};\n \n use syntax::ast::{self};\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::{DUMMY_SP, Span, MultiSpan};\n \n use dataflow::{do_dataflow};\n use dataflow::{MoveDataParamEnv};\n@@ -287,11 +287,14 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             }\n \n             StatementKind::StorageDead(local) => {\n-                if self.storage_drop_or_dead_error_reported.insert(local) {\n-                    self.access_lvalue(ContextKind::StorageDead.new(location),\n-                                       (&Lvalue::Local(local), span),\n-                                       (Shallow(None), Write(WriteKind::StorageDead)),\n-                                       flow_state);\n+                if !self.storage_drop_or_dead_error_reported.contains(&local) {\n+                    let error_reported = self.access_lvalue(ContextKind::StorageDead.new(location),\n+                        (&Lvalue::Local(local), span),\n+                        (Shallow(None), Write(WriteKind::StorageDeadOrDrop)), flow_state);\n+\n+                    if error_reported {\n+                        self.storage_drop_or_dead_error_reported.insert(local);\n+                    }\n                 }\n             }\n         }\n@@ -435,24 +438,30 @@ enum ReadKind {\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum WriteKind {\n-    StorageDead,\n+    StorageDeadOrDrop,\n     MutableBorrow(BorrowKind),\n     Mutate,\n     Move,\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    /// Checks an access to the given lvalue to see if it is allowed. Examines the set of borrows\n+    /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n+    /// lvalue is initialized and (b) it is not borrowed in some way that would prevent this\n+    /// access.\n+    ///\n+    /// Returns true if an error is reported, false otherwise.\n     fn access_lvalue(&mut self,\n                      context: Context,\n                      lvalue_span: (&Lvalue<'tcx>, Span),\n                      kind: (ShallowOrDeep, ReadOrWrite),\n-                     flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n-\n+                     flow_state: &InProgress<'cx, 'gcx, 'tcx>) -> bool {\n         let (sd, rw) = kind;\n \n         // Check permissions\n         self.check_access_permissions(lvalue_span, rw);\n \n+        let mut error_reported = false;\n         self.each_borrow_involving_path(\n             context, (sd, lvalue_span.0), flow_state, |this, _index, borrow, common_prefix| {\n                 match (rw, borrow.kind) {\n@@ -462,13 +471,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     (Read(kind), BorrowKind::Unique) |\n                     (Read(kind), BorrowKind::Mut) => {\n                         match kind {\n-                            ReadKind::Copy =>\n+                            ReadKind::Copy => {\n+                                error_reported = true;\n                                 this.report_use_while_mutably_borrowed(\n-                                    context, lvalue_span, borrow),\n+                                    context, lvalue_span, borrow)\n+                            },\n                             ReadKind::Borrow(bk) => {\n                                 let end_issued_loan_span =\n                                     flow_state.borrows.base_results.operator().opt_region_end_span(\n                                         &borrow.region);\n+                                error_reported = true;\n                                 this.report_conflicting_borrow(\n                                     context, common_prefix, lvalue_span, bk,\n                                     &borrow, end_issued_loan_span)\n@@ -482,22 +494,35 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 let end_issued_loan_span =\n                                     flow_state.borrows.base_results.operator().opt_region_end_span(\n                                         &borrow.region);\n+                                error_reported = true;\n                                 this.report_conflicting_borrow(\n                                     context, common_prefix, lvalue_span, bk,\n                                     &borrow, end_issued_loan_span)\n                             }\n-                            WriteKind::StorageDead |\n-                            WriteKind::Mutate =>\n+                             WriteKind::StorageDeadOrDrop => {\n+                                let end_span =\n+                                    flow_state.borrows.base_results.operator().opt_region_end_span(\n+                                        &borrow.region);\n+                                error_reported = true;\n+                                this.report_borrowed_value_does_not_live_long_enough(\n+                                    context, lvalue_span, end_span)\n+                            },\n+                            WriteKind::Mutate => {\n+                                error_reported = true;\n                                 this.report_illegal_mutation_of_borrowed(\n-                                    context, lvalue_span, borrow),\n-                            WriteKind::Move =>\n+                                    context, lvalue_span, borrow)\n+                            },\n+                            WriteKind::Move => {\n+                                error_reported = true;\n                                 this.report_move_out_while_borrowed(\n-                                    context, lvalue_span, &borrow),\n+                                    context, lvalue_span, &borrow)\n+                            },\n                         }\n                         Control::Break\n                     }\n                 }\n             });\n+        error_reported\n     }\n \n     fn mutate_lvalue(&mut self,\n@@ -614,20 +639,34 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // Check if error has already been reported to stop duplicate reporting.\n         let has_storage_drop_or_dead_error_reported = match *lvalue {\n-            Lvalue::Local(local) => self.storage_drop_or_dead_error_reported.insert(local),\n+            Lvalue::Local(local) => self.storage_drop_or_dead_error_reported.contains(&local),\n             _ => false,\n         };\n \n+        // If the error has been reported already, then we don't need the access_lvalue call and we\n+        // can set error_reported to false.\n         if !has_storage_drop_or_dead_error_reported {\n+            let error_reported;\n+\n             if moves_by_default {\n+                let kind = match consume_via_drop {\n+                    ConsumeKind::Drop => WriteKind::StorageDeadOrDrop,\n+                    _ => WriteKind::Move,\n+                };\n                 // move of lvalue: check if this is move of already borrowed path\n-                self.access_lvalue(context, lvalue_span, (Deep, Write(WriteKind::Move)),\n-                                   flow_state);\n+                error_reported = self.access_lvalue(context, lvalue_span,\n+                                                    (Deep, Write(kind)), flow_state);\n             } else {\n                 // copy of lvalue: check if this is \"copy of frozen path\"\n                 // (FIXME: see check_loans.rs)\n-                self.access_lvalue(context, lvalue_span, (Deep, Read(ReadKind::Copy)),\n-                                   flow_state);\n+                error_reported = self.access_lvalue(context, lvalue_span,\n+                                                    (Deep, Read(ReadKind::Copy)), flow_state);\n+            }\n+\n+            if error_reported {\n+                if let Lvalue::Local(local) = *lvalue {\n+                    self.storage_drop_or_dead_error_reported.insert(local);\n+                }\n             }\n         }\n \n@@ -1477,6 +1516,29 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n+    fn report_borrowed_value_does_not_live_long_enough(&mut self,\n+                                                       _: Context,\n+                                                       (lvalue, span): (&Lvalue, Span),\n+                                                       end_span: Option<Span>) {\n+        let proper_span = match *lvalue {\n+            Lvalue::Local(local) => self.mir.local_decls[local].source_info.span,\n+            _ => span\n+        };\n+\n+        let mut err = self.tcx.path_does_not_live_long_enough(proper_span,\n+                                                              \"borrowed value\", Origin::Mir);\n+        err.span = MultiSpan::from_span(proper_span);\n+        err.span_label(proper_span, \"temporary value created here\");\n+        err.span_label(span, \"temporary value dropped here while still borrowed\");\n+        err.note(\"consider using a `let` binding to increase its lifetime\");\n+\n+        if let Some(end) = end_span {\n+            err.span_label(end, \"temporary value needs to live until here\");\n+        }\n+\n+        err.emit();\n+    }\n+\n     fn report_illegal_mutation_of_borrowed(&mut self,\n                                            _: Context,\n                                            (lvalue, span): (&Lvalue<'tcx>, Span),"}]}