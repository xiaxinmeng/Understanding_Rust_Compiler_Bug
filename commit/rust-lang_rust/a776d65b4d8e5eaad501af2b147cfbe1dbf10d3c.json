{"sha": "a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3NzZkNjViNGQ4ZTVlYWFkNTAxYWYyYjE0N2NmYmUxZGJmMTBkM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-24T01:10:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-24T01:10:36Z"}, "message": "auto merge of #6690 : erickt/rust/cleanup-warnings, r=brson\n\nSimple patch series to fix up all the warnings a rustc compile is giving at the moment. It also fixes a NOTE in `to_bytes.rs` to remove the `to_bytes::iter_bytes_<N>` functions.", "tree": {"sha": "1366910aafb8be2d6a9ef3872035e166a6dd8f65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1366910aafb8be2d6a9ef3872035e166a6dd8f65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "html_url": "https://github.com/rust-lang/rust/commit/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bbc13d6db303264cea477972969bf88442a611b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bbc13d6db303264cea477972969bf88442a611b", "html_url": "https://github.com/rust-lang/rust/commit/4bbc13d6db303264cea477972969bf88442a611b"}, {"sha": "cc4fabcb4361d0daada096f5e6ac19eb6ed21d33", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc4fabcb4361d0daada096f5e6ac19eb6ed21d33", "html_url": "https://github.com/rust-lang/rust/commit/cc4fabcb4361d0daada096f5e6ac19eb6ed21d33"}], "stats": {"total": 2648, "additions": 1303, "deletions": 1345}, "files": [{"sha": "91a41cb9b85aefc5bb2532408766c51d29568d4b", "filename": "doc/tutorial.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -1480,7 +1480,6 @@ This code creates a closure that adds a given string to its argument,\n returns it from a function, and then calls it:\n \n ~~~~\n-# extern mod std;\n fn mk_appender(suffix: ~str) -> @fn(~str) -> ~str {\n     // The compiler knows that we intend this closure to be of type @fn\n     return |s| s + suffix;\n@@ -2292,7 +2291,7 @@ let nonsense = mycircle.radius() * mycircle.area();\n \n ## Deriving implementations for traits\n \n-A small number of traits in `std` and `std` can have implementations\n+A small number of traits in `std` and `extra` can have implementations\n that can be automatically derived. These instances are specified by\n placing the `deriving` attribute on a data type declaration. For\n example, the following will mean that `Circle` has an implementation\n@@ -2541,9 +2540,9 @@ as well as an inscrutable string of alphanumerics. These are both\n part of Rust's library versioning scheme. The alphanumerics are\n a hash representing the crate metadata.\n \n-## The std library\n+## The standard library\n \n-The Rust std library provides runtime features required by the language,\n+The Rust standard library provides runtime features required by the language,\n including the task scheduler and memory allocators, as well as library\n support for Rust built-in types, platform abstractions, and other commonly\n used features.\n@@ -2559,7 +2558,7 @@ I/O abstractions ([`io`]), [containers] like [`hashmap`],\n common traits ([`kinds`], [`ops`], [`cmp`], [`num`],\n [`to_str`], [`clone`]), and complete bindings to the C standard library ([`libc`]).\n \n-### Core injection and the Rust prelude\n+### Standard Library injection and the Rust prelude\n \n `std` is imported at the topmost level of every crate by default, as\n if the first line of each crate was\n@@ -2571,7 +2570,7 @@ with the `std::` path prefix, as in `use std::vec`, `use std::task::spawn`,\n etc.\n \n Additionally, `std` contains a `prelude` module that reexports many of the\n-most common std modules, types and traits. The contents of the prelude are\n+most common standard modules, types and traits. The contents of the prelude are\n imported into every *module* by default.  Implicitly, all modules behave as if\n they contained the following prologue:\n "}, {"sha": "8147f8abb93da6ffafe6e3ebc1f24daca031a41d", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -50,20 +50,20 @@ pub fn main() {\n \n pub fn parse_config(args: ~[~str]) -> config {\n     let opts =\n-        ~[getopts::reqopt(~\"compile-lib-path\"),\n-          getopts::reqopt(~\"run-lib-path\"),\n-          getopts::reqopt(~\"rustc-path\"), getopts::reqopt(~\"src-base\"),\n-          getopts::reqopt(~\"build-base\"), getopts::reqopt(~\"aux-base\"),\n-          getopts::reqopt(~\"stage-id\"),\n-          getopts::reqopt(~\"mode\"), getopts::optflag(~\"ignored\"),\n-          getopts::optopt(~\"runtool\"), getopts::optopt(~\"rustcflags\"),\n-          getopts::optflag(~\"verbose\"),\n-          getopts::optopt(~\"logfile\"),\n-          getopts::optflag(~\"jit\"),\n-          getopts::optflag(~\"newrt\"),\n-          getopts::optopt(~\"target\"),\n-          getopts::optopt(~\"adb-path\"),\n-          getopts::optopt(~\"adb-test-dir\")\n+        ~[getopts::reqopt(\"compile-lib-path\"),\n+          getopts::reqopt(\"run-lib-path\"),\n+          getopts::reqopt(\"rustc-path\"), getopts::reqopt(\"src-base\"),\n+          getopts::reqopt(\"build-base\"), getopts::reqopt(\"aux-base\"),\n+          getopts::reqopt(\"stage-id\"),\n+          getopts::reqopt(\"mode\"), getopts::optflag(\"ignored\"),\n+          getopts::optopt(\"runtool\"), getopts::optopt(\"rustcflags\"),\n+          getopts::optflag(\"verbose\"),\n+          getopts::optopt(\"logfile\"),\n+          getopts::optflag(\"jit\"),\n+          getopts::optflag(\"newrt\"),\n+          getopts::optopt(\"target\"),\n+          getopts::optopt(\"adb-path\"),\n+          getopts::optopt(\"adb-test-dir\")\n          ];\n \n     assert!(!args.is_empty());\n@@ -74,43 +74,43 @@ pub fn parse_config(args: ~[~str]) -> config {\n           Err(f) => fail!(getopts::fail_str(f))\n         };\n \n-    fn opt_path(m: &getopts::Matches, nm: ~str) -> Path {\n+    fn opt_path(m: &getopts::Matches, nm: &str) -> Path {\n         Path(getopts::opt_str(m, nm))\n     }\n \n     config {\n-        compile_lib_path: getopts::opt_str(matches, ~\"compile-lib-path\"),\n-        run_lib_path: getopts::opt_str(matches, ~\"run-lib-path\"),\n-        rustc_path: opt_path(matches, ~\"rustc-path\"),\n-        src_base: opt_path(matches, ~\"src-base\"),\n-        build_base: opt_path(matches, ~\"build-base\"),\n-        aux_base: opt_path(matches, ~\"aux-base\"),\n-        stage_id: getopts::opt_str(matches, ~\"stage-id\"),\n-        mode: str_mode(getopts::opt_str(matches, ~\"mode\")),\n-        run_ignored: getopts::opt_present(matches, ~\"ignored\"),\n+        compile_lib_path: getopts::opt_str(matches, \"compile-lib-path\"),\n+        run_lib_path: getopts::opt_str(matches, \"run-lib-path\"),\n+        rustc_path: opt_path(matches, \"rustc-path\"),\n+        src_base: opt_path(matches, \"src-base\"),\n+        build_base: opt_path(matches, \"build-base\"),\n+        aux_base: opt_path(matches, \"aux-base\"),\n+        stage_id: getopts::opt_str(matches, \"stage-id\"),\n+        mode: str_mode(getopts::opt_str(matches, \"mode\")),\n+        run_ignored: getopts::opt_present(matches, \"ignored\"),\n         filter:\n              if vec::len(matches.free) > 0u {\n                  option::Some(copy matches.free[0])\n              } else { option::None },\n-        logfile: getopts::opt_maybe_str(matches, ~\"logfile\").map(|s| Path(*s)),\n-        runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n-        rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n-        jit: getopts::opt_present(matches, ~\"jit\"),\n-        newrt: getopts::opt_present(matches, ~\"newrt\"),\n-        target: opt_str2(getopts::opt_maybe_str(matches, ~\"target\")).to_str(),\n-        adb_path: opt_str2(getopts::opt_maybe_str(matches, ~\"adb-path\")).to_str(),\n+        logfile: getopts::opt_maybe_str(matches, \"logfile\").map(|s| Path(*s)),\n+        runtool: getopts::opt_maybe_str(matches, \"runtool\"),\n+        rustcflags: getopts::opt_maybe_str(matches, \"rustcflags\"),\n+        jit: getopts::opt_present(matches, \"jit\"),\n+        newrt: getopts::opt_present(matches, \"newrt\"),\n+        target: opt_str2(getopts::opt_maybe_str(matches, \"target\")).to_str(),\n+        adb_path: opt_str2(getopts::opt_maybe_str(matches, \"adb-path\")).to_str(),\n         adb_test_dir:\n-            opt_str2(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")).to_str(),\n+            opt_str2(getopts::opt_maybe_str(matches, \"adb-test-dir\")).to_str(),\n         adb_device_status:\n-            if (opt_str2(getopts::opt_maybe_str(matches, ~\"target\")) ==\n+            if (opt_str2(getopts::opt_maybe_str(matches, \"target\")) ==\n                 ~\"arm-linux-androideabi\") {\n-                if (opt_str2(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")) !=\n+                if (opt_str2(getopts::opt_maybe_str(matches, \"adb-test-dir\")) !=\n                     ~\"(none)\" &&\n-                    opt_str2(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")) !=\n+                    opt_str2(getopts::opt_maybe_str(matches, \"adb-test-dir\")) !=\n                     ~\"\") { true }\n                 else { false }\n             } else { false },\n-        verbose: getopts::opt_present(matches, ~\"verbose\")\n+        verbose: getopts::opt_present(matches, \"verbose\")\n     }\n }\n "}, {"sha": "cc4320248cdffa4af1eece10cb00182040d55c06", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -87,10 +87,10 @@ pub fn load_props(testfile: &Path) -> TestProps {\n \n pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n     for iter_header(testfile) |ln| {\n-        if parse_name_directive(ln, ~\"xfail-test\") { return true; }\n+        if parse_name_directive(ln, \"xfail-test\") { return true; }\n         if parse_name_directive(ln, xfail_target()) { return true; }\n         if config.mode == common::mode_pretty &&\n-           parse_name_directive(ln, ~\"xfail-pretty\") { return true; }\n+           parse_name_directive(ln, \"xfail-pretty\") { return true; }\n     };\n     return false;\n \n@@ -107,8 +107,7 @@ fn iter_header(testfile: &Path, it: &fn(~str) -> bool) -> bool {\n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n-        if str::starts_with(ln, ~\"fn\")\n-            || str::starts_with(ln, ~\"mod\") {\n+        if str::starts_with(ln, \"fn\") || str::starts_with(ln, \"mod\") {\n             return false;\n         } else { if !(it(ln)) { return false; } }\n     }"}, {"sha": "c1586a1b350fa6e9bc1799dc1f9eea701af153a5", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -25,7 +25,7 @@ use util::logv;\n pub fn run(config: config, testfile: ~str) {\n     if config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n-        io::stdout().write_str(~\"\\n\\n\");\n+        io::stdout().write_str(\"\\n\\n\");\n     }\n     let testfile = Path(testfile);\n     debug!(\"running %s\", testfile.to_str());\n@@ -231,7 +231,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     // do not optimize debuginfo tests\n     let mut config = match config.rustcflags {\n         Some(ref flags) => config {\n-            rustcflags: Some(str::replace(*flags, ~\"-O\", ~\"\")),\n+            rustcflags: Some(str::replace(*flags, \"-O\", \"\")),\n             .. copy *config\n         },\n         None => copy *config\n@@ -249,19 +249,19 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     // write debugger script\n     let script_str = str::append(cmds, \"\\nquit\\n\");\n     debug!(\"script_str = %s\", script_str);\n-    dump_output_file(config, testfile, script_str, ~\"debugger.script\");\n+    dump_output_file(config, testfile, script_str, \"debugger.script\");\n \n     // run debugger script with gdb\n     #[cfg(windows)]\n     fn debugger() -> ~str { ~\"gdb.exe\" }\n     #[cfg(unix)]\n     fn debugger() -> ~str { ~\"gdb\" }\n-    let debugger_script = make_out_name(config, testfile, ~\"debugger.script\");\n+    let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n     let debugger_opts = ~[~\"-quiet\", ~\"-batch\", ~\"-nx\",\n                           ~\"-command=\" + debugger_script.to_str(),\n                           make_exe_name(config, testfile).to_str()];\n     let ProcArgs = ProcArgs {prog: debugger(), args: debugger_opts};\n-    ProcRes = compose_and_run(config, testfile, ProcArgs, ~[], ~\"\", None);\n+    ProcRes = compose_and_run(config, testfile, ProcArgs, ~[], \"\", None);\n     if ProcRes.status != 0 {\n         fatal(~\"gdb failed to execute\");\n     }\n@@ -368,7 +368,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         }\n \n         // ignore this msg which gets printed at the end\n-        if str::contains(line, ~\"aborting due to\") {\n+        if str::contains(line, \"aborting due to\") {\n             was_expected = true;\n         }\n \n@@ -643,7 +643,7 @@ fn program_output(config: &config, testfile: &Path, lib_path: &str, prog: ~str,\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n fn make_cmdline(_libpath: &str, prog: &str, args: &[~str]) -> ~str {\n-    fmt!(\"%s %s\", prog, str::connect(args, ~\" \"))\n+    fmt!(\"%s %s\", prog, str::connect(args, \" \"))\n }\n \n #[cfg(target_os = \"win32\")]\n@@ -668,7 +668,7 @@ fn dump_output_file(config: &config, testfile: &Path,\n                     out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n     let writer =\n-        io::file_writer(&outfile, ~[io::Create, io::Truncate]).get();\n+        io::file_writer(&outfile, [io::Create, io::Truncate]).get();\n     writer.write_str(out);\n }\n \n@@ -692,8 +692,8 @@ fn output_base_name(config: &config, testfile: &Path) -> Path {\n \n fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n     if config.verbose {\n-        let sep1 = fmt!(\"------%s------------------------------\", ~\"stdout\");\n-        let sep2 = fmt!(\"------%s------------------------------\", ~\"stderr\");\n+        let sep1 = fmt!(\"------%s------------------------------\", \"stdout\");\n+        let sep2 = fmt!(\"------%s------------------------------\", \"stderr\");\n         let sep3 = ~\"------------------------------------------\";\n         io::stdout().write_line(sep1);\n         io::stdout().write_line(out);\n@@ -781,10 +781,10 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     newargs_err.push(newcmd_err);\n \n     let procsrv::Result{ out: out_out, err: _out_err, status: out_status } =\n-            procsrv::run(~\"\", config.adb_path, newargs_out, ~[(~\"\",~\"\")],\n+            procsrv::run(\"\", config.adb_path, newargs_out, ~[(~\"\",~\"\")],\n                          Some(~\"\"));\n     let procsrv::Result{ out: err_out, err: _err_err, status: _err_status } =\n-            procsrv::run(~\"\", config.adb_path, newargs_err, ~[(~\"\",~\"\")],\n+            procsrv::run(\"\", config.adb_path, newargs_err, ~[(~\"\",~\"\")],\n                          Some(~\"\"));\n \n     dump_output(config, testfile, out_out, err_out);\n@@ -818,8 +818,8 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n \n         if (file.filetype() == Some(~\".so\")) {\n \n-            let copy_result = procsrv::run(~\"\", config.adb_path,\n-                ~[~\"push\", file.to_str(), copy config.adb_test_dir],\n+            let copy_result = procsrv::run(\"\", config.adb_path,\n+                [~\"push\", file.to_str(), copy config.adb_test_dir],\n                 ~[(~\"\",~\"\")], Some(~\"\"));\n \n             if config.verbose {"}, {"sha": "41584710a41714b517b6c8e7ab669d29983d2961", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -12,10 +12,6 @@\n \n use core::prelude::*;\n \n-use core::old_iter;\n-use core::str;\n-use core::vec;\n-\n pub trait ToBase64 {\n     fn to_base64(&self) -> ~str;\n }\n@@ -242,12 +238,12 @@ mod tests {\n \n     #[test]\n     fn test_from_base64() {\n-        assert_eq!((~\"\").from_base64(), str::to_bytes(~\"\"));\n-        assert!((~\"Zg==\").from_base64() == str::to_bytes(~\"f\"));\n-        assert_eq!((~\"Zm8=\").from_base64(), str::to_bytes(~\"fo\"));\n-        assert_eq!((~\"Zm9v\").from_base64(), str::to_bytes(~\"foo\"));\n-        assert!((~\"Zm9vYg==\").from_base64() == str::to_bytes(~\"foob\"));\n-        assert_eq!((~\"Zm9vYmE=\").from_base64(), str::to_bytes(~\"fooba\"))\n-        assert_eq!((~\"Zm9vYmFy\").from_base64(), str::to_bytes(~\"foobar\"));\n+        assert_eq!((~\"\").from_base64(), str::to_bytes(\"\"));\n+        assert!((~\"Zg==\").from_base64() == str::to_bytes(\"f\"));\n+        assert_eq!((~\"Zm8=\").from_base64(), str::to_bytes(\"fo\"));\n+        assert_eq!((~\"Zm9v\").from_base64(), str::to_bytes(\"foo\"));\n+        assert!((~\"Zm9vYg==\").from_base64() == str::to_bytes(\"foob\"));\n+        assert_eq!((~\"Zm9vYmE=\").from_base64(), str::to_bytes(\"fooba\"))\n+        assert_eq!((~\"Zm9vYmFy\").from_base64(), str::to_bytes(\"foobar\"));\n     }\n }"}, {"sha": "1262e90518db3f5904f8fd80561c25d3c80e9b03", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -10,8 +10,6 @@\n \n use core::prelude::*;\n \n-use core::vec::from_elem;\n-\n struct SmallBitv {\n     /// only the lowest nbits of this value are used. the rest is undefined.\n     bits: uint\n@@ -257,7 +255,7 @@ pub impl Bitv {\n             let nelems = nbits/uint::bits +\n                          if nbits % uint::bits == 0 {0} else {1};\n             let elem = if init {!0} else {0};\n-            let s = from_elem(nelems, elem);\n+            let s = vec::from_elem(nelems, elem);\n             Big(~BigBitv::new(s))\n         };\n         Bitv {rep: rep, nbits: nbits}\n@@ -502,7 +500,7 @@ impl Clone for Bitv {\n             Bitv{nbits: self.nbits, rep: Small(~SmallBitv{bits: b.bits})}\n           }\n           Big(ref b) => {\n-            let mut st = from_elem(self.nbits / uint::bits + 1, 0);\n+            let mut st = vec::from_elem(self.nbits / uint::bits + 1, 0);\n             let len = st.len();\n             for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n             Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: st})}\n@@ -872,17 +870,14 @@ mod tests {\n \n     #[test]\n     fn test_0_elements() {\n-        let mut act;\n-        let exp;\n-        act = Bitv::new(0u, false);\n-        exp = vec::from_elem::<uint>(0u, 0u);\n+        let act = Bitv::new(0u, false);\n+        let exp = vec::from_elem::<uint>(0u, 0u);\n         assert!(act.eq_vec(exp));\n     }\n \n     #[test]\n     fn test_1_element() {\n-        let mut act;\n-        act = Bitv::new(1u, false);\n+        let mut act = Bitv::new(1u, false);\n         assert!(act.eq_vec(~[0u]));\n         act = Bitv::new(1u, true);\n         assert!(act.eq_vec(~[1u]));\n@@ -1488,7 +1483,7 @@ mod tests {\n     #[bench]\n     fn bench_bitv_big_union(b: &mut BenchHarness) {\n         let mut b1 = Bitv::new(bench_bits, false);\n-        let mut b2 = Bitv::new(bench_bits, false);\n+        let b2 = Bitv::new(bench_bits, false);\n         do b.iter {\n             b1.union(&b2);\n         }"}, {"sha": "d3da13dde987a05aef4e548487a8bf2a69450593", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -540,13 +540,13 @@ mod tests {\n \n     #[test]\n     fn test_dlist_concat() {\n-        let a = from_vec(~[1,2]);\n-        let b = from_vec(~[3,4]);\n-        let c = from_vec(~[5,6]);\n-        let d = from_vec(~[7,8]);\n-        let ab = from_vec(~[a,b]);\n-        let cd = from_vec(~[c,d]);\n-        let abcd = concat(concat(from_vec(~[ab,cd])));\n+        let a = from_vec([1,2]);\n+        let b = from_vec([3,4]);\n+        let c = from_vec([5,6]);\n+        let d = from_vec([7,8]);\n+        let ab = from_vec([a,b]);\n+        let cd = from_vec([c,d]);\n+        let abcd = concat(concat(from_vec([ab,cd])));\n         abcd.assert_consistent(); assert_eq!(abcd.len(), 8);\n         abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 1);\n         abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 2);\n@@ -560,8 +560,8 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_append() {\n-        let a = from_vec(~[1,2,3]);\n-        let b = from_vec(~[4,5,6]);\n+        let a = from_vec([1,2,3]);\n+        let b = from_vec([4,5,6]);\n         a.append(b);\n         assert_eq!(a.len(), 6);\n         assert_eq!(b.len(), 0);\n@@ -576,7 +576,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_append_empty() {\n-        let a = from_vec(~[1,2,3]);\n+        let a = from_vec([1,2,3]);\n         let b = DList::<int>();\n         a.append(b);\n         assert_eq!(a.len(), 3);\n@@ -590,7 +590,7 @@ mod tests {\n     #[test]\n     fn test_dlist_append_to_empty() {\n         let a = DList::<int>();\n-        let b = from_vec(~[4,5,6]);\n+        let b = from_vec([4,5,6]);\n         a.append(b);\n         assert_eq!(a.len(), 3);\n         assert_eq!(b.len(), 0);\n@@ -626,8 +626,8 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_prepend() {\n-        let a = from_vec(~[1,2,3]);\n-        let b = from_vec(~[4,5,6]);\n+        let a = from_vec([1,2,3]);\n+        let b = from_vec([4,5,6]);\n         b.prepend(a);\n         assert_eq!(a.len(), 0);\n         assert_eq!(b.len(), 6);\n@@ -642,7 +642,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_reverse() {\n-        let a = from_vec(~[5,4,3,2,1]);\n+        let a = from_vec([5,4,3,2,1]);\n         a.reverse();\n         assert_eq!(a.len(), 5);\n         a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n@@ -661,7 +661,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_each_node() {\n-        let a = from_vec(~[1,2,4,5]);\n+        let a = from_vec([1,2,4,5]);\n         for a.each_node |nobe| {\n             if nobe.data > 3 {\n                 a.insert_before(3, nobe);\n@@ -678,28 +678,28 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_clear() {\n-        let a = from_vec(~[5,4,3,2,1]);\n+        let a = from_vec([5,4,3,2,1]);\n         a.clear();\n         assert_eq!(a.len(), 0);\n         a.assert_consistent();\n     }\n     #[test]\n     fn test_dlist_is_empty() {\n         let empty = DList::<int>();\n-        let full1 = from_vec(~[1,2,3]);\n+        let full1 = from_vec([1,2,3]);\n         assert!(empty.is_empty());\n         assert!(!full1.is_empty());\n     }\n     #[test]\n     fn test_dlist_head_tail() {\n-        let l = from_vec(~[1,2,3]);\n+        let l = from_vec([1,2,3]);\n         assert_eq!(l.head(), 1);\n         assert_eq!(l.tail(), 3);\n         assert_eq!(l.len(), 3);\n     }\n     #[test]\n     fn test_dlist_pop() {\n-        let l = from_vec(~[1,2,3]);\n+        let l = from_vec([1,2,3]);\n         assert_eq!(l.pop().get(), 1);\n         assert_eq!(l.tail(), 3);\n         assert_eq!(l.head(), 2);\n@@ -712,7 +712,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_pop_tail() {\n-        let l = from_vec(~[1,2,3]);\n+        let l = from_vec([1,2,3]);\n         assert_eq!(l.pop_tail().get(), 3);\n         assert_eq!(l.tail(), 2);\n         assert_eq!(l.head(), 1);\n@@ -758,7 +758,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_break_early() {\n-        let l = from_vec(~[1,2,3,4,5]);\n+        let l = from_vec([1,2,3,4,5]);\n         let mut x = 0;\n         for l.each |i| {\n             x += 1;"}, {"sha": "42dde4ab890c82d54989a24571aafaa00712beb4", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -96,8 +96,6 @@ total line count).\n \n use core::prelude::*;\n \n-use core::io::ReaderUtil;\n-\n /**\n A summary of the internal state of a `FileInput` object. `line_num`\n and `line_num_file` represent the number of lines read in total and in\n@@ -407,7 +405,6 @@ pub fn input_vec_state(files: ~[Option<Path>],\n mod test {\n     use core::prelude::*;\n \n-    use core::io::WriterUtil;\n     use super::{FileInput, pathify, input_vec, input_vec_state};\n \n     fn make_file(path : &Path, contents: &[~str]) {\n@@ -441,7 +438,7 @@ mod test {\n \n         // 3 files containing 0\\n, 1\\n, and 2\\n respectively\n         for filenames.eachi |i, &filename| {\n-            make_file(filename.get_ref(), ~[fmt!(\"%u\", i)]);\n+            make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n         let fi = FileInput::from_vec(copy filenames);\n@@ -471,7 +468,7 @@ mod test {\n \n         // 3 files containing 1\\n, 2\\n, and 3\\n respectively\n         for filenames.eachi |i, &filename| {\n-            make_file(filename.get_ref(), ~[fmt!(\"%u\", i)]);\n+            make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n         let fi = FileInput::from_vec(filenames);\n@@ -533,9 +530,9 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-empty-files-%u.tmp\", i)),true);\n \n-        make_file(filenames[0].get_ref(), ~[~\"1\", ~\"2\"]);\n-        make_file(filenames[1].get_ref(), ~[]);\n-        make_file(filenames[2].get_ref(), ~[~\"3\", ~\"4\"]);\n+        make_file(filenames[0].get_ref(), [~\"1\", ~\"2\"]);\n+        make_file(filenames[1].get_ref(), []);\n+        make_file(filenames[2].get_ref(), [~\"3\", ~\"4\"]);\n \n         let mut count = 0;\n         for input_vec_state(copy filenames) |line, state| {\n@@ -580,7 +577,7 @@ mod test {\n             make_file(&filename.get(), contents);\n         }\n \n-        let mut in = FileInput::from_vec(filenames);\n+        let in = FileInput::from_vec(filenames);\n \n         // read once from 0\n         assert_eq!(in.read_line(), ~\"0 1\");"}, {"sha": "d184e67ab29f8d67ebc00905e87ac4dc8a5de598", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -16,12 +16,8 @@ Simple compression\n \n use core::prelude::*;\n \n-use core::libc::{c_void, size_t, c_int};\n use core::libc;\n-use core::vec;\n-\n-#[cfg(test)] use core::rand;\n-#[cfg(test)] use core::rand::RngUtil;\n+use core::libc::{c_void, size_t, c_int};\n \n pub mod rustrt {\n     use core::libc::{c_int, c_void, size_t};\n@@ -83,27 +79,34 @@ pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n     }\n }\n \n-#[test]\n-#[allow(non_implicitly_copyable_typarams)]\n-fn test_flate_round_trip() {\n-    let mut r = rand::rng();\n-    let mut words = ~[];\n-    for 20.times {\n-        let range = r.gen_uint_range(1, 10);\n-        words.push(r.gen_bytes(range));\n-    }\n-    for 20.times {\n-        let mut in = ~[];\n-        for 2000.times {\n-            in.push_all(r.choose(words));\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use core::rand;\n+    use core::rand::RngUtil;\n+\n+    #[test]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_flate_round_trip() {\n+        let mut r = rand::rng();\n+        let mut words = ~[];\n+        for 20.times {\n+            let range = r.gen_uint_range(1, 10);\n+            words.push(r.gen_bytes(range));\n+        }\n+        for 20.times {\n+            let mut in = ~[];\n+            for 2000.times {\n+                in.push_all(r.choose(words));\n+            }\n+            debug!(\"de/inflate of %u bytes of random word-sequences\",\n+                   in.len());\n+            let cmp = deflate_bytes(in);\n+            let out = inflate_bytes(cmp);\n+            debug!(\"%u bytes deflated to %u (%.1f%% size)\",\n+                   in.len(), cmp.len(),\n+                   100.0 * ((cmp.len() as float) / (in.len() as float)));\n+            assert_eq!(in, out);\n         }\n-        debug!(\"de/inflate of %u bytes of random word-sequences\",\n-               in.len());\n-        let cmp = deflate_bytes(in);\n-        let out = inflate_bytes(cmp);\n-        debug!(\"%u bytes deflated to %u (%.1f%% size)\",\n-               in.len(), cmp.len(),\n-               100.0 * ((cmp.len() as float) / (in.len() as float)));\n-        assert_eq!(in, out);\n     }\n }"}, {"sha": "539d18cb0cd5bcb37ea4588c0b6f4f384eb5eb2a", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 126, "deletions": 129, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -681,12 +681,12 @@ mod tests {\n     #[test]\n     fn test_reqopt_long() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[reqopt(~\"test\")];\n+        let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"test\")));\n-            assert_eq!(opt_str(m, ~\"test\"), ~\"20\");\n+            assert!((opt_present(m, \"test\")));\n+            assert_eq!(opt_str(m, \"test\"), ~\"20\");\n           }\n           _ => { fail!(\"test_reqopt_long failed\"); }\n         }\n@@ -695,7 +695,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_long_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[reqopt(~\"test\")];\n+        let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionMissing_),\n@@ -706,7 +706,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_long_no_arg() {\n         let args = ~[~\"--test\"];\n-        let opts = ~[reqopt(~\"test\")];\n+        let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n@@ -717,7 +717,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n-        let opts = ~[reqopt(~\"test\")];\n+        let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n@@ -728,12 +728,12 @@ mod tests {\n     #[test]\n     fn test_reqopt_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[reqopt(~\"t\")];\n+        let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"t\")));\n-            assert_eq!(opt_str(m, ~\"t\"), ~\"20\");\n+            assert!((opt_present(m, \"t\")));\n+            assert_eq!(opt_str(m, \"t\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -742,7 +742,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_short_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[reqopt(~\"t\")];\n+        let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionMissing_),\n@@ -753,7 +753,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_short_no_arg() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[reqopt(~\"t\")];\n+        let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n@@ -764,7 +764,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[reqopt(~\"t\")];\n+        let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n@@ -777,12 +777,12 @@ mod tests {\n     #[test]\n     fn test_optopt_long() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[optopt(~\"test\")];\n+        let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"test\")));\n-            assert_eq!(opt_str(m, ~\"test\"), ~\"20\");\n+            assert!((opt_present(m, \"test\")));\n+            assert_eq!(opt_str(m, \"test\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -791,18 +791,18 @@ mod tests {\n     #[test]\n     fn test_optopt_long_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optopt(~\"test\")];\n+        let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, ~\"test\")),\n+          Ok(ref m) => assert!(!opt_present(m, \"test\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optopt_long_no_arg() {\n         let args = ~[~\"--test\"];\n-        let opts = ~[optopt(~\"test\")];\n+        let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n@@ -813,7 +813,7 @@ mod tests {\n     #[test]\n     fn test_optopt_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n-        let opts = ~[optopt(~\"test\")];\n+        let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n@@ -824,12 +824,12 @@ mod tests {\n     #[test]\n     fn test_optopt_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optopt(~\"t\")];\n+        let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"t\")));\n-            assert_eq!(opt_str(m, ~\"t\"), ~\"20\");\n+            assert!((opt_present(m, \"t\")));\n+            assert_eq!(opt_str(m, \"t\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -838,18 +838,18 @@ mod tests {\n     #[test]\n     fn test_optopt_short_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optopt(~\"t\")];\n+        let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, ~\"t\")),\n+          Ok(ref m) => assert!(!opt_present(m, \"t\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optopt_short_no_arg() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[optopt(~\"t\")];\n+        let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n@@ -860,7 +860,7 @@ mod tests {\n     #[test]\n     fn test_optopt_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[optopt(~\"t\")];\n+        let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n@@ -873,29 +873,29 @@ mod tests {\n     #[test]\n     fn test_optflag_long() {\n         let args = ~[~\"--test\"];\n-        let opts = ~[optflag(~\"test\")];\n+        let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(opt_present(m, ~\"test\")),\n+          Ok(ref m) => assert!(opt_present(m, \"test\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optflag_long_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optflag(~\"test\")];\n+        let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, ~\"test\")),\n+          Ok(ref m) => assert!(!opt_present(m, \"test\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optflag_long_arg() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[optflag(~\"test\")];\n+        let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => {\n@@ -909,7 +909,7 @@ mod tests {\n     #[test]\n     fn test_optflag_long_multi() {\n         let args = ~[~\"--test\", ~\"--test\"];\n-        let opts = ~[optflag(~\"test\")];\n+        let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n@@ -920,29 +920,29 @@ mod tests {\n     #[test]\n     fn test_optflag_short() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[optflag(~\"t\")];\n+        let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(opt_present(m, ~\"t\")),\n+          Ok(ref m) => assert!(opt_present(m, \"t\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optflag_short_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optflag(~\"t\")];\n+        let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, ~\"t\")),\n+          Ok(ref m) => assert!(!opt_present(m, \"t\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optflag_short_arg() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optflag(~\"t\")];\n+        let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -957,7 +957,7 @@ mod tests {\n     #[test]\n     fn test_optflag_short_multi() {\n         let args = ~[~\"-t\", ~\"-t\"];\n-        let opts = ~[optflag(~\"t\")];\n+        let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n@@ -969,11 +969,11 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_short1() {\n         let args = ~[~\"-v\"];\n-        let opts = ~[optflagmulti(~\"v\")];\n+        let opts = ~[optflagmulti(\"v\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, ~\"v\"), 1);\n+            assert_eq!(opt_count(m, \"v\"), 1);\n           }\n           _ => fail!()\n         }\n@@ -982,11 +982,11 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_short2a() {\n         let args = ~[~\"-v\", ~\"-v\"];\n-        let opts = ~[optflagmulti(~\"v\")];\n+        let opts = ~[optflagmulti(\"v\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, ~\"v\"), 2);\n+            assert_eq!(opt_count(m, \"v\"), 2);\n           }\n           _ => fail!()\n         }\n@@ -995,11 +995,11 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_short2b() {\n         let args = ~[~\"-vv\"];\n-        let opts = ~[optflagmulti(~\"v\")];\n+        let opts = ~[optflagmulti(\"v\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, ~\"v\"), 2);\n+            assert_eq!(opt_count(m, \"v\"), 2);\n           }\n           _ => fail!()\n         }\n@@ -1008,11 +1008,11 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_long1() {\n         let args = ~[~\"--verbose\"];\n-        let opts = ~[optflagmulti(~\"verbose\")];\n+        let opts = ~[optflagmulti(\"verbose\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, ~\"verbose\"), 1);\n+            assert_eq!(opt_count(m, \"verbose\"), 1);\n           }\n           _ => fail!()\n         }\n@@ -1021,11 +1021,11 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_long2() {\n         let args = ~[~\"--verbose\", ~\"--verbose\"];\n-        let opts = ~[optflagmulti(~\"verbose\")];\n+        let opts = ~[optflagmulti(\"verbose\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, ~\"verbose\"), 2);\n+            assert_eq!(opt_count(m, \"verbose\"), 2);\n           }\n           _ => fail!()\n         }\n@@ -1035,12 +1035,12 @@ mod tests {\n     #[test]\n     fn test_optmulti_long() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[optmulti(~\"test\")];\n+        let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"test\")));\n-            assert_eq!(opt_str(m, ~\"test\"), ~\"20\");\n+            assert!((opt_present(m, \"test\")));\n+            assert_eq!(opt_str(m, \"test\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -1049,18 +1049,18 @@ mod tests {\n     #[test]\n     fn test_optmulti_long_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optmulti(~\"test\")];\n+        let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, ~\"test\")),\n+          Ok(ref m) => assert!(!opt_present(m, \"test\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optmulti_long_no_arg() {\n         let args = ~[~\"--test\"];\n-        let opts = ~[optmulti(~\"test\")];\n+        let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n@@ -1071,13 +1071,13 @@ mod tests {\n     #[test]\n     fn test_optmulti_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n-        let opts = ~[optmulti(~\"test\")];\n+        let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-              assert!(opt_present(m, ~\"test\"));\n-              assert_eq!(opt_str(m, ~\"test\"), ~\"20\");\n-              let pair = opt_strs(m, ~\"test\");\n+              assert!(opt_present(m, \"test\"));\n+              assert_eq!(opt_str(m, \"test\"), ~\"20\");\n+              let pair = opt_strs(m, \"test\");\n               assert!(pair[0] == ~\"20\");\n               assert!(pair[1] == ~\"30\");\n           }\n@@ -1088,12 +1088,12 @@ mod tests {\n     #[test]\n     fn test_optmulti_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optmulti(~\"t\")];\n+        let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"t\")));\n-            assert_eq!(opt_str(m, ~\"t\"), ~\"20\");\n+            assert!((opt_present(m, \"t\")));\n+            assert_eq!(opt_str(m, \"t\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -1102,18 +1102,18 @@ mod tests {\n     #[test]\n     fn test_optmulti_short_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optmulti(~\"t\")];\n+        let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, ~\"t\")),\n+          Ok(ref m) => assert!(!opt_present(m, \"t\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optmulti_short_no_arg() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[optmulti(~\"t\")];\n+        let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n@@ -1124,13 +1124,13 @@ mod tests {\n     #[test]\n     fn test_optmulti_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[optmulti(~\"t\")];\n+        let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"t\")));\n-            assert_eq!(opt_str(m, ~\"t\"), ~\"20\");\n-            let pair = opt_strs(m, ~\"t\");\n+            assert!((opt_present(m, \"t\")));\n+            assert_eq!(opt_str(m, \"t\"), ~\"20\");\n+            let pair = opt_strs(m, \"t\");\n             assert!(pair[0] == ~\"20\");\n             assert!(pair[1] == ~\"30\");\n           }\n@@ -1141,7 +1141,7 @@ mod tests {\n     #[test]\n     fn test_unrecognized_option_long() {\n         let args = ~[~\"--untest\"];\n-        let opts = ~[optmulti(~\"t\")];\n+        let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, UnrecognizedOption_),\n@@ -1152,7 +1152,7 @@ mod tests {\n     #[test]\n     fn test_unrecognized_option_short() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[optmulti(~\"test\")];\n+        let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, UnrecognizedOption_),\n@@ -1167,26 +1167,26 @@ mod tests {\n               ~\"--flag\", ~\"--long=30\", ~\"-f\", ~\"-m\", ~\"40\",\n               ~\"-m\", ~\"50\", ~\"-n\", ~\"-A B\", ~\"-n\", ~\"-60 70\"];\n         let opts =\n-            ~[optopt(~\"s\"), optflag(~\"flag\"), reqopt(~\"long\"),\n-             optflag(~\"f\"), optmulti(~\"m\"), optmulti(~\"n\"),\n-             optopt(~\"notpresent\")];\n+            ~[optopt(\"s\"), optflag(\"flag\"), reqopt(\"long\"),\n+             optflag(\"f\"), optmulti(\"m\"), optmulti(\"n\"),\n+             optopt(\"notpresent\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n             assert!(m.free[0] == ~\"prog\");\n             assert!(m.free[1] == ~\"free1\");\n-            assert_eq!(opt_str(m, ~\"s\"), ~\"20\");\n+            assert_eq!(opt_str(m, \"s\"), ~\"20\");\n             assert!(m.free[2] == ~\"free2\");\n-            assert!((opt_present(m, ~\"flag\")));\n-            assert_eq!(opt_str(m, ~\"long\"), ~\"30\");\n-            assert!((opt_present(m, ~\"f\")));\n-            let pair = opt_strs(m, ~\"m\");\n+            assert!((opt_present(m, \"flag\")));\n+            assert_eq!(opt_str(m, \"long\"), ~\"30\");\n+            assert!((opt_present(m, \"f\")));\n+            let pair = opt_strs(m, \"m\");\n             assert!(pair[0] == ~\"40\");\n             assert!(pair[1] == ~\"50\");\n-            let pair = opt_strs(m, ~\"n\");\n+            let pair = opt_strs(m, \"n\");\n             assert!(pair[0] == ~\"-A B\");\n             assert!(pair[1] == ~\"-60 70\");\n-            assert!((!opt_present(m, ~\"notpresent\")));\n+            assert!((!opt_present(m, \"notpresent\")));\n           }\n           _ => fail!()\n         }\n@@ -1195,43 +1195,43 @@ mod tests {\n     #[test]\n     fn test_multi() {\n         let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n-        let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\"), optopt(~\"f\")];\n+        let opts = ~[optopt(\"e\"), optopt(\"encrypt\"), optopt(\"f\")];\n         let matches = &match getopts(args, opts) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(opts_present(matches, ~[~\"e\"]));\n-        assert!(opts_present(matches, ~[~\"encrypt\"]));\n-        assert!(opts_present(matches, ~[~\"encrypt\", ~\"e\"]));\n-        assert!(opts_present(matches, ~[~\"e\", ~\"encrypt\"]));\n-        assert!(!opts_present(matches, ~[~\"f\"]));\n-        assert!(!opts_present(matches, ~[~\"thing\"]));\n-        assert!(!opts_present(matches, ~[]));\n+        assert!(opts_present(matches, [~\"e\"]));\n+        assert!(opts_present(matches, [~\"encrypt\"]));\n+        assert!(opts_present(matches, [~\"encrypt\", ~\"e\"]));\n+        assert!(opts_present(matches, [~\"e\", ~\"encrypt\"]));\n+        assert!(!opts_present(matches, [~\"f\"]));\n+        assert!(!opts_present(matches, [~\"thing\"]));\n+        assert!(!opts_present(matches, []));\n \n-        assert_eq!(opts_str(matches, ~[~\"e\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches, ~[~\"encrypt\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches, ~[~\"e\", ~\"encrypt\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches, ~[~\"encrypt\", ~\"e\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches, [~\"e\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches, [~\"encrypt\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches, [~\"e\", ~\"encrypt\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches, [~\"encrypt\", ~\"e\"]), ~\"foo\");\n     }\n \n     #[test]\n     fn test_nospace() {\n         let args = ~[~\"-Lfoo\", ~\"-M.\"];\n-        let opts = ~[optmulti(~\"L\"), optmulti(~\"M\")];\n+        let opts = ~[optmulti(\"L\"), optmulti(\"M\")];\n         let matches = &match getopts(args, opts) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(opts_present(matches, ~[~\"L\"]));\n-        assert_eq!(opts_str(matches, ~[~\"L\"]), ~\"foo\");\n-        assert!(opts_present(matches, ~[~\"M\"]));\n-        assert_eq!(opts_str(matches, ~[~\"M\"]), ~\".\");\n+        assert!(opts_present(matches, [~\"L\"]));\n+        assert_eq!(opts_str(matches, [~\"L\"]), ~\"foo\");\n+        assert!(opts_present(matches, [~\"M\"]));\n+        assert_eq!(opts_str(matches, [~\"M\"]), ~\".\");\n \n     }\n \n     #[test]\n     fn test_groups_reqopt() {\n-        let opt = groups::reqopt(~\"b\", ~\"banana\", ~\"some bananas\", ~\"VAL\");\n+        let opt = groups::reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"b\",\n                         long_name: ~\"banana\",\n                         hint: ~\"VAL\",\n@@ -1242,7 +1242,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_optopt() {\n-        let opt = groups::optopt(~\"a\", ~\"apple\", ~\"some apples\", ~\"VAL\");\n+        let opt = groups::optopt(\"a\", \"apple\", \"some apples\", \"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"a\",\n                         long_name: ~\"apple\",\n                         hint: ~\"VAL\",\n@@ -1253,7 +1253,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_optflag() {\n-        let opt = groups::optflag(~\"k\", ~\"kiwi\", ~\"some kiwis\");\n+        let opt = groups::optflag(\"k\", \"kiwi\", \"some kiwis\");\n         assert!(opt == OptGroup { short_name: ~\"k\",\n                         long_name: ~\"kiwi\",\n                         hint: ~\"\",\n@@ -1264,8 +1264,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_optflagopt() {\n-        let opt = groups::optflagopt(~\"p\", ~\"pineapple\",\n-                                       ~\"some pineapples\", ~\"VAL\");\n+        let opt = groups::optflagopt(\"p\", \"pineapple\", \"some pineapples\", \"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"p\",\n                         long_name: ~\"pineapple\",\n                         hint: ~\"VAL\",\n@@ -1276,8 +1275,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_optmulti() {\n-        let opt = groups::optmulti(~\"l\", ~\"lime\",\n-                                     ~\"some limes\", ~\"VAL\");\n+        let opt = groups::optmulti(\"l\", \"lime\", \"some limes\", \"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"l\",\n                         long_name: ~\"lime\",\n                         hint: ~\"VAL\",\n@@ -1288,29 +1286,28 @@ mod tests {\n \n     #[test]\n     fn test_groups_long_to_short() {\n-        let short = ~[reqopt(~\"b\"), reqopt(~\"banana\")];\n-        let verbose = groups::reqopt(~\"b\", ~\"banana\",\n-                                       ~\"some bananas\", ~\"VAL\");\n+        let short = ~[reqopt(\"b\"), reqopt(\"banana\")];\n+        let verbose = groups::reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n \n         assert_eq!(groups::long_to_short(&verbose), short);\n     }\n \n     #[test]\n     fn test_groups_getopts() {\n         let short = ~[\n-            reqopt(~\"b\"), reqopt(~\"banana\"),\n-            optopt(~\"a\"), optopt(~\"apple\"),\n-            optflag(~\"k\"), optflagopt(~\"kiwi\"),\n-            optflagopt(~\"p\"),\n-            optmulti(~\"l\")\n+            reqopt(\"b\"), reqopt(\"banana\"),\n+            optopt(\"a\"), optopt(\"apple\"),\n+            optflag(\"k\"), optflagopt(\"kiwi\"),\n+            optflagopt(\"p\"),\n+            optmulti(\"l\")\n         ];\n \n         let verbose = ~[\n-            groups::reqopt(~\"b\", ~\"banana\", ~\"Desc\", ~\"VAL\"),\n-            groups::optopt(~\"a\", ~\"apple\", ~\"Desc\", ~\"VAL\"),\n-            groups::optflag(~\"k\", ~\"kiwi\", ~\"Desc\"),\n-            groups::optflagopt(~\"p\", ~\"\", ~\"Desc\", ~\"VAL\"),\n-            groups::optmulti(~\"l\", ~\"\", ~\"Desc\", ~\"VAL\"),\n+            groups::reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+            groups::optopt(\"a\", \"apple\", \"Desc\", \"VAL\"),\n+            groups::optflag(\"k\", \"kiwi\", \"Desc\"),\n+            groups::optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+            groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n         ];\n \n         let sample_args = ~[~\"-k\", ~\"15\", ~\"--apple\", ~\"1\", ~\"k\",\n@@ -1324,12 +1321,12 @@ mod tests {\n     #[test]\n     fn test_groups_usage() {\n         let optgroups = ~[\n-            groups::reqopt(~\"b\", ~\"banana\", ~\"Desc\", ~\"VAL\"),\n-            groups::optopt(~\"a\", ~\"012345678901234567890123456789\",\n-                             ~\"Desc\", ~\"VAL\"),\n-            groups::optflag(~\"k\", ~\"kiwi\", ~\"Desc\"),\n-            groups::optflagopt(~\"p\", ~\"\", ~\"Desc\", ~\"VAL\"),\n-            groups::optmulti(~\"l\", ~\"\", ~\"Desc\", ~\"VAL\"),\n+            groups::reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+            groups::optopt(\"a\", \"012345678901234567890123456789\",\n+                             \"Desc\", \"VAL\"),\n+            groups::optflag(\"k\", \"kiwi\", \"Desc\"),\n+            groups::optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+            groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n         ];\n \n         let expected =\n@@ -1345,7 +1342,7 @@ Options:\n \n \";\n \n-        let generated_usage = groups::usage(~\"Usage: fruits\", optgroups);\n+        let generated_usage = groups::usage(\"Usage: fruits\", optgroups);\n \n         debug!(\"expected: <<%s>>\", expected);\n         debug!(\"generated: <<%s>>\", generated_usage);\n@@ -1358,10 +1355,10 @@ Options:\n         // lines wrap after 78: or rather descriptions wrap after 54\n \n         let optgroups = ~[\n-           groups::optflag(~\"k\", ~\"kiwi\",\n-           ~\"This is a long description which won't be wrapped..+..\"), // 54\n-           groups::optflag(~\"a\", ~\"apple\",\n-           ~\"This is a long description which _will_ be wrapped..+..\"), // 55\n+            groups::optflag(\"k\", \"kiwi\",\n+                \"This is a long description which won't be wrapped..+..\"), // 54\n+            groups::optflag(\"a\", \"apple\",\n+                \"This is a long description which _will_ be wrapped..+..\"), // 55\n         ];\n \n         let expected =\n@@ -1374,7 +1371,7 @@ Options:\n \n \";\n \n-        let usage = groups::usage(~\"Usage: fruits\", optgroups);\n+        let usage = groups::usage(\"Usage: fruits\", optgroups);\n \n         debug!(\"expected: <<%s>>\", expected);\n         debug!(\"generated: <<%s>>\", usage);"}, {"sha": "5ef0500d53ad54ec937039215a65ba56355ec674", "filename": "src/libextra/json.rs", "status": "modified", "additions": 124, "deletions": 124, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -1444,26 +1444,26 @@ mod tests {\n \n     #[test]\n     fn test_write_object() {\n-        assert_eq!(to_str(&mk_object(~[])), ~\"{}\");\n-        assert_eq!(to_pretty_str(&mk_object(~[])), ~\"{}\");\n+        assert_eq!(to_str(&mk_object([])), ~\"{}\");\n+        assert_eq!(to_pretty_str(&mk_object([])), ~\"{}\");\n \n         assert_eq!(\n-            to_str(&mk_object(~[(~\"a\", Boolean(true))])),\n+            to_str(&mk_object([(~\"a\", Boolean(true))])),\n             ~\"{\\\"a\\\":true}\"\n         );\n         assert_eq!(\n-            to_pretty_str(&mk_object(~[(~\"a\", Boolean(true))])),\n+            to_pretty_str(&mk_object([(~\"a\", Boolean(true))])),\n             ~\"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n             }\"\n         );\n \n         assert_eq!(\n-            to_str(&mk_object(~[\n+            to_str(&mk_object([\n                 (~\"b\", List(~[\n-                    mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n-                    mk_object(~[(~\"d\", String(~\"\"))])\n+                    mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n+                    mk_object([(~\"d\", String(~\"\"))])\n                 ]))\n             ])),\n             ~\"{\\\n@@ -1474,10 +1474,10 @@ mod tests {\n             }\"\n         );\n         assert_eq!(\n-            to_pretty_str(&mk_object(~[\n+            to_pretty_str(&mk_object([\n                 (~\"b\", List(~[\n-                    mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n-                    mk_object(~[(~\"d\", String(~\"\"))])\n+                    mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n+                    mk_object([(~\"d\", String(~\"\"))])\n                 ]))\n             ])),\n             ~\"\\\n@@ -1493,11 +1493,11 @@ mod tests {\n             }\"\n         );\n \n-        let a = mk_object(~[\n+        let a = mk_object([\n             (~\"a\", Boolean(true)),\n             (~\"b\", List(~[\n-                mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n-                mk_object(~[(~\"d\", String(~\"\"))])\n+                mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n+                mk_object([(~\"d\", String(~\"\"))])\n             ]))\n         ]);\n \n@@ -1582,299 +1582,299 @@ mod tests {\n \n     #[test]\n     fn test_trailing_characters() {\n-        assert_eq!(from_str(~\"nulla\"),\n+        assert_eq!(from_str(\"nulla\"),\n             Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"}));\n-        assert_eq!(from_str(~\"truea\"),\n+        assert_eq!(from_str(\"truea\"),\n             Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"}));\n-        assert_eq!(from_str(~\"falsea\"),\n+        assert_eq!(from_str(\"falsea\"),\n             Err(Error {line: 1u, col: 6u, msg: @~\"trailing characters\"}));\n-        assert_eq!(from_str(~\"1a\"),\n+        assert_eq!(from_str(\"1a\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"trailing characters\"}));\n-        assert_eq!(from_str(~\"[]a\"),\n+        assert_eq!(from_str(\"[]a\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"}));\n-        assert_eq!(from_str(~\"{}a\"),\n+        assert_eq!(from_str(\"{}a\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"}));\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n-        assert_eq!(from_str(~\"n\"),\n+        assert_eq!(from_str(\"n\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n-        assert_eq!(from_str(~\"nul\"),\n+        assert_eq!(from_str(\"nul\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n \n-        assert_eq!(from_str(~\"t\"),\n+        assert_eq!(from_str(\"t\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n-        assert_eq!(from_str(~\"truz\"),\n+        assert_eq!(from_str(\"truz\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n \n-        assert_eq!(from_str(~\"f\"),\n+        assert_eq!(from_str(\"f\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n-        assert_eq!(from_str(~\"faz\"),\n+        assert_eq!(from_str(\"faz\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"invalid syntax\"}));\n \n-        assert_eq!(from_str(~\"null\"), Ok(Null));\n-        assert_eq!(from_str(~\"true\"), Ok(Boolean(true)));\n-        assert_eq!(from_str(~\"false\"), Ok(Boolean(false)));\n-        assert_eq!(from_str(~\" null \"), Ok(Null));\n-        assert_eq!(from_str(~\" true \"), Ok(Boolean(true)));\n-        assert_eq!(from_str(~\" false \"), Ok(Boolean(false)));\n+        assert_eq!(from_str(\"null\"), Ok(Null));\n+        assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n+        assert_eq!(from_str(\"false\"), Ok(Boolean(false)));\n+        assert_eq!(from_str(\" null \"), Ok(Null));\n+        assert_eq!(from_str(\" true \"), Ok(Boolean(true)));\n+        assert_eq!(from_str(\" false \"), Ok(Boolean(false)));\n     }\n \n     #[test]\n     fn test_decode_identifiers() {\n-        let mut decoder = Decoder(from_str(~\"null\").unwrap());\n+        let mut decoder = Decoder(from_str(\"null\").unwrap());\n         let v: () = Decodable::decode(&mut decoder);\n         assert_eq!(v, ());\n \n-        let mut decoder = Decoder(from_str(~\"true\").unwrap());\n+        let mut decoder = Decoder(from_str(\"true\").unwrap());\n         let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, true);\n \n-        let mut decoder = Decoder(from_str(~\"false\").unwrap());\n+        let mut decoder = Decoder(from_str(\"false\").unwrap());\n         let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, false);\n     }\n \n     #[test]\n     fn test_read_number() {\n-        assert_eq!(from_str(~\"+\"),\n+        assert_eq!(from_str(\"+\"),\n             Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"}));\n-        assert_eq!(from_str(~\".\"),\n+        assert_eq!(from_str(\".\"),\n             Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"}));\n \n-        assert_eq!(from_str(~\"-\"),\n+        assert_eq!(from_str(\"-\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"}));\n-        assert_eq!(from_str(~\"00\"),\n+        assert_eq!(from_str(\"00\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"}));\n-        assert_eq!(from_str(~\"1.\"),\n+        assert_eq!(from_str(\"1.\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"}));\n-        assert_eq!(from_str(~\"1e\"),\n+        assert_eq!(from_str(\"1e\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"}));\n-        assert_eq!(from_str(~\"1e+\"),\n+        assert_eq!(from_str(\"1e+\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid number\"}));\n \n-        assert_eq!(from_str(~\"3\"), Ok(Number(3f)));\n-        assert_eq!(from_str(~\"3.1\"), Ok(Number(3.1f)));\n-        assert_eq!(from_str(~\"-1.2\"), Ok(Number(-1.2f)));\n-        assert_eq!(from_str(~\"0.4\"), Ok(Number(0.4f)));\n-        assert_eq!(from_str(~\"0.4e5\"), Ok(Number(0.4e5f)));\n-        assert_eq!(from_str(~\"0.4e+15\"), Ok(Number(0.4e15f)));\n-        assert_eq!(from_str(~\"0.4e-01\"), Ok(Number(0.4e-01f)));\n-        assert_eq!(from_str(~\" 3 \"), Ok(Number(3f)));\n+        assert_eq!(from_str(\"3\"), Ok(Number(3f)));\n+        assert_eq!(from_str(\"3.1\"), Ok(Number(3.1f)));\n+        assert_eq!(from_str(\"-1.2\"), Ok(Number(-1.2f)));\n+        assert_eq!(from_str(\"0.4\"), Ok(Number(0.4f)));\n+        assert_eq!(from_str(\"0.4e5\"), Ok(Number(0.4e5f)));\n+        assert_eq!(from_str(\"0.4e+15\"), Ok(Number(0.4e15f)));\n+        assert_eq!(from_str(\"0.4e-01\"), Ok(Number(0.4e-01f)));\n+        assert_eq!(from_str(\" 3 \"), Ok(Number(3f)));\n     }\n \n     #[test]\n     fn test_decode_numbers() {\n-        let mut decoder = Decoder(from_str(~\"3\").unwrap());\n+        let mut decoder = Decoder(from_str(\"3\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3f);\n \n-        let mut decoder = Decoder(from_str(~\"3.1\").unwrap());\n+        let mut decoder = Decoder(from_str(\"3.1\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3.1f);\n \n-        let mut decoder = Decoder(from_str(~\"-1.2\").unwrap());\n+        let mut decoder = Decoder(from_str(\"-1.2\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, -1.2f);\n \n-        let mut decoder = Decoder(from_str(~\"0.4\").unwrap());\n+        let mut decoder = Decoder(from_str(\"0.4\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4f);\n \n-        let mut decoder = Decoder(from_str(~\"0.4e5\").unwrap());\n+        let mut decoder = Decoder(from_str(\"0.4e5\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e5f);\n \n-        let mut decoder = Decoder(from_str(~\"0.4e15\").unwrap());\n+        let mut decoder = Decoder(from_str(\"0.4e15\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e15f);\n \n-        let mut decoder = Decoder(from_str(~\"0.4e-01\").unwrap());\n+        let mut decoder = Decoder(from_str(\"0.4e-01\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e-01f);\n     }\n \n     #[test]\n     fn test_read_str() {\n-        assert_eq!(from_str(~\"\\\"\"),\n+        assert_eq!(from_str(\"\\\"\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing string\"\n         }));\n-        assert_eq!(from_str(~\"\\\"lol\"),\n+        assert_eq!(from_str(\"\\\"lol\"),\n             Err(Error {line: 1u, col: 5u, msg: @~\"EOF while parsing string\"\n         }));\n \n-        assert_eq!(from_str(~\"\\\"\\\"\"), Ok(String(~\"\")));\n-        assert_eq!(from_str(~\"\\\"foo\\\"\"), Ok(String(~\"foo\")));\n-        assert_eq!(from_str(~\"\\\"\\\\\\\"\\\"\"), Ok(String(~\"\\\"\")));\n-        assert_eq!(from_str(~\"\\\"\\\\b\\\"\"), Ok(String(~\"\\x08\")));\n-        assert_eq!(from_str(~\"\\\"\\\\n\\\"\"), Ok(String(~\"\\n\")));\n-        assert_eq!(from_str(~\"\\\"\\\\r\\\"\"), Ok(String(~\"\\r\")));\n-        assert_eq!(from_str(~\"\\\"\\\\t\\\"\"), Ok(String(~\"\\t\")));\n-        assert_eq!(from_str(~\" \\\"foo\\\" \"), Ok(String(~\"foo\")));\n-        assert_eq!(from_str(~\"\\\"\\\\u12ab\\\"\"), Ok(String(~\"\\u12ab\")));\n-        assert_eq!(from_str(~\"\\\"\\\\uAB12\\\"\"), Ok(String(~\"\\uAB12\")));\n+        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(~\"\")));\n+        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(~\"foo\")));\n+        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(~\"\\\"\")));\n+        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(~\"\\x08\")));\n+        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(~\"\\n\")));\n+        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(~\"\\r\")));\n+        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(~\"\\t\")));\n+        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(~\"foo\")));\n+        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(~\"\\u12ab\")));\n+        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(~\"\\uAB12\")));\n     }\n \n     #[test]\n     fn test_decode_str() {\n-        let mut decoder = Decoder(from_str(~\"\\\"\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"foo\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"foo\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"foo\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\\\\"\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\\"\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\b\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\b\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\x08\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\n\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\n\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\n\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\r\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\r\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\r\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\t\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\t\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\t\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\u12ab\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\u12ab\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\uAB12\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\uAB12\");\n     }\n \n     #[test]\n     fn test_read_list() {\n-        assert_eq!(from_str(~\"[\"),\n+        assert_eq!(from_str(\"[\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing value\"}));\n-        assert_eq!(from_str(~\"[1\"),\n+        assert_eq!(from_str(\"[1\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"EOF while parsing list\"}));\n-        assert_eq!(from_str(~\"[1,\"),\n+        assert_eq!(from_str(\"[1,\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"EOF while parsing value\"}));\n-        assert_eq!(from_str(~\"[1,]\"),\n+        assert_eq!(from_str(\"[1,]\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n-        assert_eq!(from_str(~\"[6 7]\"),\n+        assert_eq!(from_str(\"[6 7]\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"}));\n \n-        assert_eq!(from_str(~\"[]\"), Ok(List(~[])));\n-        assert_eq!(from_str(~\"[ ]\"), Ok(List(~[])));\n-        assert_eq!(from_str(~\"[true]\"), Ok(List(~[Boolean(true)])));\n-        assert_eq!(from_str(~\"[ false ]\"), Ok(List(~[Boolean(false)])));\n-        assert_eq!(from_str(~\"[null]\"), Ok(List(~[Null])));\n-        assert_eq!(from_str(~\"[3, 1]\"),\n+        assert_eq!(from_str(\"[]\"), Ok(List(~[])));\n+        assert_eq!(from_str(\"[ ]\"), Ok(List(~[])));\n+        assert_eq!(from_str(\"[true]\"), Ok(List(~[Boolean(true)])));\n+        assert_eq!(from_str(\"[ false ]\"), Ok(List(~[Boolean(false)])));\n+        assert_eq!(from_str(\"[null]\"), Ok(List(~[Null])));\n+        assert_eq!(from_str(\"[3, 1]\"),\n                      Ok(List(~[Number(3f), Number(1f)])));\n-        assert_eq!(from_str(~\"\\n[3, 2]\\n\"),\n+        assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n                      Ok(List(~[Number(3f), Number(2f)])));\n-        assert_eq!(from_str(~\"[2, [4, 1]]\"),\n+        assert_eq!(from_str(\"[2, [4, 1]]\"),\n                Ok(List(~[Number(2f), List(~[Number(4f), Number(1f)])])));\n     }\n \n     #[test]\n     fn test_decode_list() {\n-        let mut decoder = Decoder(from_str(~\"[]\").unwrap());\n+        let mut decoder = Decoder(from_str(\"[]\").unwrap());\n         let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[]);\n \n-        let mut decoder = Decoder(from_str(~\"[null]\").unwrap());\n+        let mut decoder = Decoder(from_str(\"[null]\").unwrap());\n         let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[()]);\n \n-        let mut decoder = Decoder(from_str(~\"[true]\").unwrap());\n+        let mut decoder = Decoder(from_str(\"[true]\").unwrap());\n         let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let mut decoder = Decoder(from_str(~\"[true]\").unwrap());\n+        let mut decoder = Decoder(from_str(\"[true]\").unwrap());\n         let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let mut decoder = Decoder(from_str(~\"[3, 1]\").unwrap());\n+        let mut decoder = Decoder(from_str(\"[3, 1]\").unwrap());\n         let v: ~[int] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[3, 1]);\n \n-        let mut decoder = Decoder(from_str(~\"[[3], [1, 2]]\").unwrap());\n+        let mut decoder = Decoder(from_str(\"[[3], [1, 2]]\").unwrap());\n         let v: ~[~[uint]] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[~[3], ~[1, 2]]);\n     }\n \n     #[test]\n     fn test_read_object() {\n-        assert_eq!(from_str(~\"{\"),\n+        assert_eq!(from_str(\"{\"),\n             Err(Error {\n                 line: 1u,\n                 col: 2u,\n                 msg: @~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(~\"{ \"),\n+        assert_eq!(from_str(\"{ \"),\n             Err(Error {\n                 line: 1u,\n                 col: 3u,\n                 msg: @~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(~\"{1\"),\n+        assert_eq!(from_str(\"{1\"),\n             Err(Error {\n                 line: 1u,\n                 col: 2u,\n                 msg: @~\"key must be a string\"}));\n-        assert_eq!(from_str(~\"{ \\\"a\\\"\"),\n+        assert_eq!(from_str(\"{ \\\"a\\\"\"),\n             Err(Error {\n                 line: 1u,\n                 col: 6u,\n                 msg: @~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(~\"{\\\"a\\\"\"),\n+        assert_eq!(from_str(\"{\\\"a\\\"\"),\n             Err(Error {\n                 line: 1u,\n                 col: 5u,\n                 msg: @~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(~\"{\\\"a\\\" \"),\n+        assert_eq!(from_str(\"{\\\"a\\\" \"),\n             Err(Error {\n                 line: 1u,\n                 col: 6u,\n                 msg: @~\"EOF while parsing object\"}));\n \n-        assert_eq!(from_str(~\"{\\\"a\\\" 1\"),\n+        assert_eq!(from_str(\"{\\\"a\\\" 1\"),\n             Err(Error {line: 1u, col: 6u, msg: @~\"expected `:`\"}));\n-        assert_eq!(from_str(~\"{\\\"a\\\":\"),\n+        assert_eq!(from_str(\"{\\\"a\\\":\"),\n             Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing value\"}));\n-        assert_eq!(from_str(~\"{\\\"a\\\":1\"),\n+        assert_eq!(from_str(\"{\\\"a\\\":1\"),\n             Err(Error {\n                 line: 1u,\n                 col: 7u,\n                 msg: @~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(~\"{\\\"a\\\":1 1\"),\n+        assert_eq!(from_str(\"{\\\"a\\\":1 1\"),\n             Err(Error {line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"}));\n-        assert_eq!(from_str(~\"{\\\"a\\\":1,\"),\n+        assert_eq!(from_str(\"{\\\"a\\\":1,\"),\n             Err(Error {\n                 line: 1u,\n                 col: 8u,\n                 msg: @~\"EOF while parsing object\"}));\n \n-        assert_eq!(result::unwrap(from_str(~\"{}\")), mk_object(~[]));\n-        assert_eq!(result::unwrap(from_str(~\"{\\\"a\\\": 3}\")),\n-                  mk_object(~[(~\"a\", Number(3.0f))]));\n+        assert_eq!(result::unwrap(from_str(\"{}\")), mk_object([]));\n+        assert_eq!(result::unwrap(from_str(\"{\\\"a\\\": 3}\")),\n+                  mk_object([(~\"a\", Number(3.0f))]));\n \n         assert_eq!(result::unwrap(from_str(\n-                ~\"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n-                  mk_object(~[\n+                      \"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n+                  mk_object([\n                       (~\"a\", Null),\n                       (~\"b\", Boolean(true))]));\n         assert_eq!(result::unwrap(\n-                      from_str(~\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n-                  mk_object(~[\n+                      from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n+                  mk_object([\n                       (~\"a\", Null),\n                       (~\"b\", Boolean(true))]));\n         assert_eq!(result::unwrap(from_str(\n-                ~\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n-                  mk_object(~[\n+                      \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n+                  mk_object([\n                       (~\"a\", Number(1.0)),\n                       (~\"b\", List(~[Boolean(true)]))\n                   ]));\n@@ -1887,13 +1887,13 @@ mod tests {\n                               ~\"{ \\\"c\\\": {\\\"d\\\": null} } \" +\n                           ~\"]\" +\n                       ~\"}\")),\n-                  mk_object(~[\n+                  mk_object([\n                       (~\"a\", Number(1.0f)),\n                       (~\"b\", List(~[\n                           Boolean(true),\n                           String(~\"foo\\nbar\"),\n-                          mk_object(~[\n-                              (~\"c\", mk_object(~[(~\"d\", Null)]))\n+                          mk_object([\n+                              (~\"c\", mk_object([(~\"d\", Null)]))\n                           ])\n                       ]))\n                   ]));\n@@ -1920,23 +1920,23 @@ mod tests {\n \n     #[test]\n     fn test_decode_option() {\n-        let mut decoder = Decoder(from_str(~\"null\").unwrap());\n+        let mut decoder = Decoder(from_str(\"null\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, None);\n \n-        let mut decoder = Decoder(from_str(~\"\\\"jodhpurs\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, Some(~\"jodhpurs\"));\n     }\n \n     #[test]\n     fn test_decode_enum() {\n-        let mut decoder = Decoder(from_str(~\"\\\"Dog\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"Dog\\\"\").unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Dog);\n \n         let mut decoder =\n-            Decoder(from_str(~\"[\\\"Frog\\\",\\\"Henry\\\",349]\").unwrap());\n+            Decoder(from_str(\"[\\\"Frog\\\",\\\"Henry\\\",349]\").unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Frog(~\"Henry\", 349));\n     }\n@@ -1953,7 +1953,7 @@ mod tests {\n \n     #[test]\n     fn test_multiline_errors() {\n-        assert_eq!(from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n+        assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n             Err(Error {\n                 line: 3u,\n                 col: 8u,"}, {"sha": "0cde57d5ad762aa6bc46d60170e46115e3a87e98", "filename": "src/libextra/list.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -184,9 +184,9 @@ mod tests {\n \n     #[test]\n     fn test_is_empty() {\n-        let empty : @list::List<int> = from_vec(~[]);\n-        let full1 = from_vec(~[1]);\n-        let full2 = from_vec(~['r', 'u']);\n+        let empty : @list::List<int> = from_vec([]);\n+        let full1 = from_vec([1]);\n+        let full2 = from_vec(['r', 'u']);\n \n         assert!(is_empty(empty));\n         assert!(!is_empty(full1));\n@@ -195,7 +195,7 @@ mod tests {\n \n     #[test]\n     fn test_from_vec() {\n-        let l = from_vec(~[0, 1, 2]);\n+        let l = from_vec([0, 1, 2]);\n \n         assert_eq!(head(l), 0);\n \n@@ -208,14 +208,14 @@ mod tests {\n \n     #[test]\n     fn test_from_vec_empty() {\n-        let empty : @list::List<int> = from_vec(~[]);\n+        let empty : @list::List<int> = from_vec([]);\n         assert_eq!(empty, @list::Nil::<int>);\n     }\n \n     #[test]\n     fn test_foldl() {\n         fn add(a: &uint, b: &int) -> uint { return *a + (*b as uint); }\n-        let l = from_vec(~[0, 1, 2, 3, 4]);\n+        let l = from_vec([0, 1, 2, 3, 4]);\n         let empty = @list::Nil::<int>;\n         assert_eq!(list::foldl(0u, l, add), 10u);\n         assert_eq!(list::foldl(0u, empty, add), 0u);\n@@ -226,29 +226,29 @@ mod tests {\n         fn sub(a: &int, b: &int) -> int {\n             *a - *b\n         }\n-        let l = from_vec(~[1, 2, 3, 4]);\n+        let l = from_vec([1, 2, 3, 4]);\n         assert_eq!(list::foldl(0, l, sub), -10);\n     }\n \n     #[test]\n     fn test_find_success() {\n         fn match_(i: &int) -> bool { return *i == 2; }\n-        let l = from_vec(~[0, 1, 2]);\n+        let l = from_vec([0, 1, 2]);\n         assert_eq!(list::find(l, match_), option::Some(2));\n     }\n \n     #[test]\n     fn test_find_fail() {\n         fn match_(_i: &int) -> bool { return false; }\n-        let l = from_vec(~[0, 1, 2]);\n+        let l = from_vec([0, 1, 2]);\n         let empty = @list::Nil::<int>;\n         assert_eq!(list::find(l, match_), option::None::<int>);\n         assert_eq!(list::find(empty, match_), option::None::<int>);\n     }\n \n     #[test]\n     fn test_has() {\n-        let l = from_vec(~[5, 8, 6]);\n+        let l = from_vec([5, 8, 6]);\n         let empty = @list::Nil::<int>;\n         assert!((list::has(l, 5)));\n         assert!((!list::has(l, 7)));\n@@ -258,15 +258,15 @@ mod tests {\n \n     #[test]\n     fn test_len() {\n-        let l = from_vec(~[0, 1, 2]);\n+        let l = from_vec([0, 1, 2]);\n         let empty = @list::Nil::<int>;\n         assert_eq!(list::len(l), 3u);\n         assert_eq!(list::len(empty), 0u);\n     }\n \n     #[test]\n     fn test_append() {\n-        assert!(from_vec(~[1,2,3,4])\n-            == list::append(list::from_vec(~[1,2]), list::from_vec(~[3,4])));\n+        assert!(from_vec([1,2,3,4])\n+            == list::append(list::from_vec([1,2]), list::from_vec([3,4])));\n     }\n }"}, {"sha": "449774e4cbc16f00cfa79326975bb9f5f5300f01", "filename": "src/libextra/md4.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fmd4.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -127,17 +127,17 @@ pub fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n \n #[test]\n fn test_md4() {\n-    assert_eq!(md4_text(~\"\"), ~\"31d6cfe0d16ae931b73c59d7e0c089c0\");\n-    assert_eq!(md4_text(~\"a\"), ~\"bde52cb31de33e46245e05fbdbd6fb24\");\n-    assert_eq!(md4_text(~\"abc\"), ~\"a448017aaf21d8525fc10ae87aa6729d\");\n-    assert!(md4_text(~\"message digest\") ==\n+    assert_eq!(md4_text(\"\"), ~\"31d6cfe0d16ae931b73c59d7e0c089c0\");\n+    assert_eq!(md4_text(\"a\"), ~\"bde52cb31de33e46245e05fbdbd6fb24\");\n+    assert_eq!(md4_text(\"abc\"), ~\"a448017aaf21d8525fc10ae87aa6729d\");\n+    assert!(md4_text(\"message digest\") ==\n         ~\"d9130a8164549fe818874806e1c7014b\");\n-    assert!(md4_text(~\"abcdefghijklmnopqrstuvwxyz\") ==\n+    assert!(md4_text(\"abcdefghijklmnopqrstuvwxyz\") ==\n         ~\"d79e1c308aa5bbcdeea8ed63df412da9\");\n     assert!(md4_text(\n-        ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n+        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n         0123456789\") == ~\"043f8582f241db351ce627e153e7f0e4\");\n-    assert!(md4_text(~\"1234567890123456789012345678901234567890123456789\\\n+    assert!(md4_text(\"1234567890123456789012345678901234567890123456789\\\n                      0123456789012345678901234567890\") ==\n         ~\"e33b4ddc9c38f2199c3e7b164fcc0536\");\n }"}, {"sha": "70a8c3fb0cb8a1bcb0419bfa728e018557f67477", "filename": "src/libextra/net_ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_ip.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -393,7 +393,7 @@ mod test {\n     }\n     #[test]\n     fn test_ip_ipv4_bad_parse() {\n-        match v4::try_parse_addr(~\"b4df00d\") {\n+        match v4::try_parse_addr(\"b4df00d\") {\n           result::Err(ref err_info) => {\n             debug!(\"got error as expected %?\", err_info);\n             assert!(true);\n@@ -406,7 +406,7 @@ mod test {\n     #[test]\n     #[ignore(target_os=\"win32\")]\n     fn test_ip_ipv6_bad_parse() {\n-        match v6::try_parse_addr(~\"::,~2234k;\") {\n+        match v6::try_parse_addr(\"::,~2234k;\") {\n           result::Err(ref err_info) => {\n             debug!(\"got error as expected %?\", err_info);\n             assert!(true);"}, {"sha": "ae1707c9922b81dcc460fc7065d1ef880852680c", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -1630,7 +1630,7 @@ mod test {\n         assert_eq!(net::ip::get_port(&sock.get_peer_addr()), 8887);\n \n         // Fulfill the protocol the test server expects\n-        let resp_bytes = str::to_bytes(~\"ping\");\n+        let resp_bytes = str::to_bytes(\"ping\");\n         tcp_write_single(&sock, resp_bytes);\n         debug!(\"message sent\");\n         sock.read(0u);"}, {"sha": "3b7c808c596eadb43a5c50713024791543f548c0", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -716,11 +716,11 @@ impl IterBytes for Url {\n \n #[test]\n fn test_split_char_first() {\n-    let (u,v) = split_char_first(~\"hello, sweet world\", ',');\n+    let (u,v) = split_char_first(\"hello, sweet world\", ',');\n     assert_eq!(u, ~\"hello\");\n     assert_eq!(v, ~\" sweet world\");\n \n-    let (u,v) = split_char_first(~\"hello sweet world\", ',');\n+    let (u,v) = split_char_first(\"hello sweet world\", ',');\n     assert_eq!(u, ~\"hello sweet world\");\n     assert_eq!(v, ~\"\");\n }\n@@ -774,9 +774,9 @@ fn test_get_authority() {\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err());\n \n     // these parse as empty, because they don't start with '//'\n-    let (_, h, _, _) = get_authority(~\"user:pass@rust-lang\").unwrap();\n+    let (_, h, _, _) = get_authority(\"user:pass@rust-lang\").unwrap();\n     assert_eq!(h, ~\"\");\n-    let (_, h, _, _) = get_authority(~\"rust-lang.org\").unwrap();\n+    let (_, h, _, _) = get_authority(\"rust-lang.org\").unwrap();\n     assert_eq!(h, ~\"\");\n }\n \n@@ -788,12 +788,12 @@ fn test_get_path() {\n     let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n     assert_eq!(p, ~\"test@email.com\");\n     assert_eq!(r, ~\"#fragment\");\n-    let (p, r) = get_path(~\"/gen/:addr=?q=v\", false).unwrap();\n+    let (p, r) = get_path(\"/gen/:addr=?q=v\", false).unwrap();\n     assert_eq!(p, ~\"/gen/:addr=\");\n     assert_eq!(r, ~\"?q=v\");\n \n     //failure cases\n-    assert!(get_path(~\"something?q\", true).is_err());\n+    assert!(get_path(\"something?q\", true).is_err());\n }\n \n #[cfg(test)]\n@@ -1058,7 +1058,7 @@ mod tests {\n         // FIXME #4449: Commented out because this causes an ICE, but only\n         // on FreeBSD\n         /*\n-        assert_eq!(decode_form_urlencoded(~[]).len(), 0);\n+        assert_eq!(decode_form_urlencoded([]).len(), 0);\n \n         let s = str::to_bytes(\"a=1&foo+bar=abc&foo+bar=12+%3D+34\");\n         let form = decode_form_urlencoded(s);"}, {"sha": "7ff8c25d95ff05eb1361cbba153f77929cb398a8", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -1156,12 +1156,12 @@ mod biguint_tests {\n         fn check(slice: &[BigDigit], data: &[BigDigit]) {\n             assert!(data == BigUint::from_slice(slice).data);\n         }\n-        check(~[1], ~[1]);\n-        check(~[0, 0, 0], ~[]);\n-        check(~[1, 2, 0, 0], ~[1, 2]);\n-        check(~[0, 0, 1, 2], ~[0, 0, 1, 2]);\n-        check(~[0, 0, 1, 2, 0, 0], ~[0, 0, 1, 2]);\n-        check(~[-1], ~[-1]);\n+        check([1], [1]);\n+        check([0, 0, 0], []);\n+        check([1, 2, 0, 0], [1, 2]);\n+        check([0, 0, 1, 2], [0, 0, 1, 2]);\n+        check([0, 0, 1, 2, 0, 0], [0, 0, 1, 2]);\n+        check([-1], [-1]);\n     }\n \n     #[test]\n@@ -1579,9 +1579,9 @@ mod biguint_tests {\n             }\n         }\n \n-        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(~\"Z\", 10), None);\n-        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(~\"_\", 2), None);\n-        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(~\"-1\", 10), None);\n+        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(\"Z\", 10), None);\n+        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(\"_\", 2), None);\n+        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(\"-1\", 10), None);\n     }\n \n     #[test]"}, {"sha": "4b84e2aa8c931f42ba157a8adcd234a2fa2525cc", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -14,7 +14,6 @@ use core::prelude::*;\n \n use core::old_iter::BaseIter;\n use core::unstable::intrinsics::{move_val_init, init};\n-use core::unstable::intrinsics::uninit;\n use core::util::{replace, swap};\n \n pub struct PriorityQueue<T> {"}, {"sha": "7b38c031774d1e252e96e2a4129ff938005e83ff", "filename": "src/libextra/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -295,7 +295,7 @@ mod tests {\n             let mut i = 0;\n             let mut rs = ~\"\";\n             while i < 100000 {\n-                str::push_str(&mut rs, ~\"aaaaaaaaaa\");\n+                rs.push_str(\"aaaaaaaaaa\");\n                 i += 1;\n             }\n             return rs;"}, {"sha": "c56a02e03800a8a1eed26c37bb681fd9f9d31ce1", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -895,7 +895,7 @@ mod tests {\n     #[test]\n     fn test_merge_sort_mutable() {\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n-        let mut v1 = ~[3, 2, 1];\n+        let v1 = ~[3, 2, 1];\n         let v2 = merge_sort(v1, le);\n         assert_eq!(v2, ~[1, 2, 3]);\n     }"}, {"sha": "a23a547634242742da10dc510975147d42cb4721", "filename": "src/libextra/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstd.rc?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -27,7 +27,6 @@ not required in or otherwise suitable for the core library.\n #[crate_type = \"lib\"];\n \n #[deny(non_camel_case_types)];\n-#[allow(unnecessary_allocation)];\n \n #[no_core];\n #[no_std];"}, {"sha": "ba2ee3c352ef5c23a9f2465b9394163f352dc41c", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -394,8 +394,8 @@ fn should_sort_failures_before_printing_them() {\n         print_failures(st);\n     };\n \n-    let apos = str::find_str(s, ~\"a\").get();\n-    let bpos = str::find_str(s, ~\"b\").get();\n+    let apos = str::find_str(s, \"a\").get();\n+    let bpos = str::find_str(s, \"b\").get();\n     assert!(apos < bpos);\n }\n "}, {"sha": "8a0d50ed52c710483cdcaf97d47f736e1208ce0a", "filename": "src/libextra/time.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -899,7 +899,7 @@ mod tests {\n     }\n \n     fn test_at_utc() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n         let time = ::time::Timespec::new(1234567890, 54321);\n@@ -920,7 +920,7 @@ mod tests {\n     }\n \n     fn test_at() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n         let time = ::time::Timespec::new(1234567890, 54321);\n@@ -948,7 +948,7 @@ mod tests {\n     }\n \n     fn test_to_timespec() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n         let time = ::time::Timespec::new(1234567890, 54321);\n@@ -959,7 +959,7 @@ mod tests {\n     }\n \n     fn test_conversions() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n         let time = ::time::Timespec::new(1234567890, 54321);\n@@ -975,10 +975,10 @@ mod tests {\n     }\n \n     fn test_strptime() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n-        match strptime(~\"\", ~\"\") {\n+        match strptime(\"\", \"\") {\n           Ok(ref tm) => {\n             assert!(tm.tm_sec == 0_i32);\n             assert!(tm.tm_min == 0_i32);\n@@ -995,12 +995,12 @@ mod tests {\n           Err(_) => ()\n         }\n \n-        let format = ~\"%a %b %e %T %Y\";\n-        assert_eq!(strptime(~\"\", format), Err(~\"Invalid time\"));\n-        assert!(strptime(~\"Fri Feb 13 15:31:30\", format)\n+        let format = \"%a %b %e %T %Y\";\n+        assert_eq!(strptime(\"\", format), Err(~\"Invalid time\"));\n+        assert!(strptime(\"Fri Feb 13 15:31:30\", format)\n             == Err(~\"Invalid time\"));\n \n-        match strptime(~\"Fri Feb 13 15:31:30 2009\", format) {\n+        match strptime(\"Fri Feb 13 15:31:30 2009\", format) {\n           Err(copy e) => fail!(e),\n           Ok(ref tm) => {\n             assert!(tm.tm_sec == 30_i32);\n@@ -1034,7 +1034,7 @@ mod tests {\n             ~\"Friday\",\n             ~\"Saturday\"\n         ].each |day| {\n-            assert!(test(*day, ~\"%A\"));\n+            assert!(test(*day, \"%A\"));\n         }\n \n         for [\n@@ -1046,7 +1046,7 @@ mod tests {\n             ~\"Fri\",\n             ~\"Sat\"\n         ].each |day| {\n-            assert!(test(*day, ~\"%a\"));\n+            assert!(test(*day, \"%a\"));\n         }\n \n         for [\n@@ -1063,7 +1063,7 @@ mod tests {\n             ~\"November\",\n             ~\"December\"\n         ].each |day| {\n-            assert!(test(*day, ~\"%B\"));\n+            assert!(test(*day, \"%B\"));\n         }\n \n         for [\n@@ -1080,60 +1080,60 @@ mod tests {\n             ~\"Nov\",\n             ~\"Dec\"\n         ].each |day| {\n-            assert!(test(*day, ~\"%b\"));\n+            assert!(test(*day, \"%b\"));\n         }\n \n-        assert!(test(~\"19\", ~\"%C\"));\n-        assert!(test(~\"Fri Feb 13 23:31:30 2009\", ~\"%c\"));\n-        assert!(test(~\"02/13/09\", ~\"%D\"));\n-        assert!(test(~\"03\", ~\"%d\"));\n-        assert!(test(~\"13\", ~\"%d\"));\n-        assert!(test(~\" 3\", ~\"%e\"));\n-        assert!(test(~\"13\", ~\"%e\"));\n-        assert!(test(~\"2009-02-13\", ~\"%F\"));\n-        assert!(test(~\"03\", ~\"%H\"));\n-        assert!(test(~\"13\", ~\"%H\"));\n-        assert!(test(~\"03\", ~\"%I\")); // FIXME (#2350): flesh out\n-        assert!(test(~\"11\", ~\"%I\")); // FIXME (#2350): flesh out\n-        assert!(test(~\"044\", ~\"%j\"));\n-        assert!(test(~\" 3\", ~\"%k\"));\n-        assert!(test(~\"13\", ~\"%k\"));\n-        assert!(test(~\" 1\", ~\"%l\"));\n-        assert!(test(~\"11\", ~\"%l\"));\n-        assert!(test(~\"03\", ~\"%M\"));\n-        assert!(test(~\"13\", ~\"%M\"));\n-        assert!(test(~\"\\n\", ~\"%n\"));\n-        assert!(test(~\"am\", ~\"%P\"));\n-        assert!(test(~\"pm\", ~\"%P\"));\n-        assert!(test(~\"AM\", ~\"%p\"));\n-        assert!(test(~\"PM\", ~\"%p\"));\n-        assert!(test(~\"23:31\", ~\"%R\"));\n-        assert!(test(~\"11:31:30 AM\", ~\"%r\"));\n-        assert!(test(~\"11:31:30 PM\", ~\"%r\"));\n-        assert!(test(~\"03\", ~\"%S\"));\n-        assert!(test(~\"13\", ~\"%S\"));\n-        assert!(test(~\"15:31:30\", ~\"%T\"));\n-        assert!(test(~\"\\t\", ~\"%t\"));\n-        assert!(test(~\"1\", ~\"%u\"));\n-        assert!(test(~\"7\", ~\"%u\"));\n-        assert!(test(~\"13-Feb-2009\", ~\"%v\"));\n-        assert!(test(~\"0\", ~\"%w\"));\n-        assert!(test(~\"6\", ~\"%w\"));\n-        assert!(test(~\"2009\", ~\"%Y\"));\n-        assert!(test(~\"09\", ~\"%y\"));\n-        assert!(result::unwrap(strptime(~\"UTC\", ~\"%Z\")).tm_zone ==\n+        assert!(test(\"19\", \"%C\"));\n+        assert!(test(\"Fri Feb 13 23:31:30 2009\", \"%c\"));\n+        assert!(test(\"02/13/09\", \"%D\"));\n+        assert!(test(\"03\", \"%d\"));\n+        assert!(test(\"13\", \"%d\"));\n+        assert!(test(\" 3\", \"%e\"));\n+        assert!(test(\"13\", \"%e\"));\n+        assert!(test(\"2009-02-13\", \"%F\"));\n+        assert!(test(\"03\", \"%H\"));\n+        assert!(test(\"13\", \"%H\"));\n+        assert!(test(\"03\", \"%I\")); // FIXME (#2350): flesh out\n+        assert!(test(\"11\", \"%I\")); // FIXME (#2350): flesh out\n+        assert!(test(\"044\", \"%j\"));\n+        assert!(test(\" 3\", \"%k\"));\n+        assert!(test(\"13\", \"%k\"));\n+        assert!(test(\" 1\", \"%l\"));\n+        assert!(test(\"11\", \"%l\"));\n+        assert!(test(\"03\", \"%M\"));\n+        assert!(test(\"13\", \"%M\"));\n+        assert!(test(\"\\n\", \"%n\"));\n+        assert!(test(\"am\", \"%P\"));\n+        assert!(test(\"pm\", \"%P\"));\n+        assert!(test(\"AM\", \"%p\"));\n+        assert!(test(\"PM\", \"%p\"));\n+        assert!(test(\"23:31\", \"%R\"));\n+        assert!(test(\"11:31:30 AM\", \"%r\"));\n+        assert!(test(\"11:31:30 PM\", \"%r\"));\n+        assert!(test(\"03\", \"%S\"));\n+        assert!(test(\"13\", \"%S\"));\n+        assert!(test(\"15:31:30\", \"%T\"));\n+        assert!(test(\"\\t\", \"%t\"));\n+        assert!(test(\"1\", \"%u\"));\n+        assert!(test(\"7\", \"%u\"));\n+        assert!(test(\"13-Feb-2009\", \"%v\"));\n+        assert!(test(\"0\", \"%w\"));\n+        assert!(test(\"6\", \"%w\"));\n+        assert!(test(\"2009\", \"%Y\"));\n+        assert!(test(\"09\", \"%y\"));\n+        assert!(result::unwrap(strptime(\"UTC\", \"%Z\")).tm_zone ==\n             ~\"UTC\");\n-        assert!(result::unwrap(strptime(~\"PST\", ~\"%Z\")).tm_zone ==\n+        assert!(result::unwrap(strptime(\"PST\", \"%Z\")).tm_zone ==\n             ~\"\");\n-        assert!(result::unwrap(strptime(~\"-0000\", ~\"%z\")).tm_gmtoff ==\n+        assert!(result::unwrap(strptime(\"-0000\", \"%z\")).tm_gmtoff ==\n             0);\n-        assert!(result::unwrap(strptime(~\"-0800\", ~\"%z\")).tm_gmtoff ==\n+        assert!(result::unwrap(strptime(\"-0800\", \"%z\")).tm_gmtoff ==\n             0);\n-        assert!(test(~\"%\", ~\"%%\"));\n+        assert!(test(\"%\", \"%%\"));\n     }\n \n     fn test_ctime() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n         let time = ::time::Timespec::new(1234567890, 54321);\n@@ -1147,60 +1147,60 @@ mod tests {\n     }\n \n     fn test_strftime() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n         let time = ::time::Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        assert_eq!(local.strftime(~\"\"), ~\"\");\n-        assert_eq!(local.strftime(~\"%A\"), ~\"Friday\");\n-        assert_eq!(local.strftime(~\"%a\"), ~\"Fri\");\n-        assert_eq!(local.strftime(~\"%B\"), ~\"February\");\n-        assert_eq!(local.strftime(~\"%b\"), ~\"Feb\");\n-        assert_eq!(local.strftime(~\"%C\"), ~\"20\");\n-        assert_eq!(local.strftime(~\"%c\"), ~\"Fri Feb 13 15:31:30 2009\");\n-        assert_eq!(local.strftime(~\"%D\"), ~\"02/13/09\");\n-        assert_eq!(local.strftime(~\"%d\"), ~\"13\");\n-        assert_eq!(local.strftime(~\"%e\"), ~\"13\");\n-        assert_eq!(local.strftime(~\"%F\"), ~\"2009-02-13\");\n+        assert_eq!(local.strftime(\"\"), ~\"\");\n+        assert_eq!(local.strftime(\"%A\"), ~\"Friday\");\n+        assert_eq!(local.strftime(\"%a\"), ~\"Fri\");\n+        assert_eq!(local.strftime(\"%B\"), ~\"February\");\n+        assert_eq!(local.strftime(\"%b\"), ~\"Feb\");\n+        assert_eq!(local.strftime(\"%C\"), ~\"20\");\n+        assert_eq!(local.strftime(\"%c\"), ~\"Fri Feb 13 15:31:30 2009\");\n+        assert_eq!(local.strftime(\"%D\"), ~\"02/13/09\");\n+        assert_eq!(local.strftime(\"%d\"), ~\"13\");\n+        assert_eq!(local.strftime(\"%e\"), ~\"13\");\n+        assert_eq!(local.strftime(\"%F\"), ~\"2009-02-13\");\n         // assert!(local.strftime(\"%G\") == \"2009\");\n         // assert!(local.strftime(\"%g\") == \"09\");\n-        assert_eq!(local.strftime(~\"%H\"), ~\"15\");\n-        assert_eq!(local.strftime(~\"%I\"), ~\"03\");\n-        assert_eq!(local.strftime(~\"%j\"), ~\"044\");\n-        assert_eq!(local.strftime(~\"%k\"), ~\"15\");\n-        assert_eq!(local.strftime(~\"%l\"), ~\" 3\");\n-        assert_eq!(local.strftime(~\"%M\"), ~\"31\");\n-        assert_eq!(local.strftime(~\"%m\"), ~\"02\");\n-        assert_eq!(local.strftime(~\"%n\"), ~\"\\n\");\n-        assert_eq!(local.strftime(~\"%P\"), ~\"pm\");\n-        assert_eq!(local.strftime(~\"%p\"), ~\"PM\");\n-        assert_eq!(local.strftime(~\"%R\"), ~\"15:31\");\n-        assert_eq!(local.strftime(~\"%r\"), ~\"03:31:30 PM\");\n-        assert_eq!(local.strftime(~\"%S\"), ~\"30\");\n-        assert_eq!(local.strftime(~\"%s\"), ~\"1234567890\");\n-        assert_eq!(local.strftime(~\"%T\"), ~\"15:31:30\");\n-        assert_eq!(local.strftime(~\"%t\"), ~\"\\t\");\n+        assert_eq!(local.strftime(\"%H\"), ~\"15\");\n+        assert_eq!(local.strftime(\"%I\"), ~\"03\");\n+        assert_eq!(local.strftime(\"%j\"), ~\"044\");\n+        assert_eq!(local.strftime(\"%k\"), ~\"15\");\n+        assert_eq!(local.strftime(\"%l\"), ~\" 3\");\n+        assert_eq!(local.strftime(\"%M\"), ~\"31\");\n+        assert_eq!(local.strftime(\"%m\"), ~\"02\");\n+        assert_eq!(local.strftime(\"%n\"), ~\"\\n\");\n+        assert_eq!(local.strftime(\"%P\"), ~\"pm\");\n+        assert_eq!(local.strftime(\"%p\"), ~\"PM\");\n+        assert_eq!(local.strftime(\"%R\"), ~\"15:31\");\n+        assert_eq!(local.strftime(\"%r\"), ~\"03:31:30 PM\");\n+        assert_eq!(local.strftime(\"%S\"), ~\"30\");\n+        assert_eq!(local.strftime(\"%s\"), ~\"1234567890\");\n+        assert_eq!(local.strftime(\"%T\"), ~\"15:31:30\");\n+        assert_eq!(local.strftime(\"%t\"), ~\"\\t\");\n         // assert!(local.strftime(\"%U\") == \"06\");\n-        assert_eq!(local.strftime(~\"%u\"), ~\"5\");\n+        assert_eq!(local.strftime(\"%u\"), ~\"5\");\n         // assert!(local.strftime(\"%V\") == \"07\");\n-        assert_eq!(local.strftime(~\"%v\"), ~\"13-Feb-2009\");\n+        assert_eq!(local.strftime(\"%v\"), ~\"13-Feb-2009\");\n         // assert!(local.strftime(\"%W\") == \"06\");\n-        assert_eq!(local.strftime(~\"%w\"), ~\"5\");\n+        assert_eq!(local.strftime(\"%w\"), ~\"5\");\n         // handle \"%X\"\n         // handle \"%x\"\n-        assert_eq!(local.strftime(~\"%Y\"), ~\"2009\");\n-        assert_eq!(local.strftime(~\"%y\"), ~\"09\");\n+        assert_eq!(local.strftime(\"%Y\"), ~\"2009\");\n+        assert_eq!(local.strftime(\"%y\"), ~\"09\");\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n-        let zone = local.strftime(~\"%Z\");\n+        let zone = local.strftime(\"%Z\");\n         assert!(zone == ~\"PST\" || zone == ~\"Pacific Standard Time\");\n \n-        assert_eq!(local.strftime(~\"%z\"), ~\"-0800\");\n-        assert_eq!(local.strftime(~\"%%\"), ~\"%\");\n+        assert_eq!(local.strftime(\"%z\"), ~\"-0800\");\n+        assert_eq!(local.strftime(\"%%\"), ~\"%\");\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation."}, {"sha": "5551431b551fc0aa098decc50e93a38e8bbfd4ec", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -759,10 +759,10 @@ mod test_treemap {\n     fn u8_map() {\n         let mut m = TreeMap::new();\n \n-        let k1 = str::to_bytes(~\"foo\");\n-        let k2 = str::to_bytes(~\"bar\");\n-        let v1 = str::to_bytes(~\"baz\");\n-        let v2 = str::to_bytes(~\"foobar\");\n+        let k1 = str::to_bytes(\"foo\");\n+        let k2 = str::to_bytes(\"bar\");\n+        let v1 = str::to_bytes(\"baz\");\n+        let v2 = str::to_bytes(\"foobar\");\n \n         m.insert(copy k1, copy v1);\n         m.insert(copy k2, copy v2);"}, {"sha": "24be917aedc9f101cb617add441859aa5dd133d6", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -211,8 +211,8 @@ mod test {\n \n     #[test]\n     fn test_rpaths_to_flags() {\n-        let flags = rpaths_to_flags(~[Path(\"path1\"),\n-                                      Path(\"path2\")]);\n+        let flags = rpaths_to_flags([Path(\"path1\"),\n+                                     Path(\"path2\")]);\n         assert_eq!(flags, ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"]);\n     }\n \n@@ -243,10 +243,10 @@ mod test {\n \n     #[test]\n     fn test_minimize2() {\n-        let res = minimize_rpaths(~[Path(\"1a\"), Path(\"2\"), Path(\"2\"),\n-                                    Path(\"1a\"), Path(\"4a\"),Path(\"1a\"),\n-                                    Path(\"2\"), Path(\"3\"), Path(\"4a\"),\n-                                    Path(\"3\")]);\n+        let res = minimize_rpaths([Path(\"1a\"), Path(\"2\"), Path(\"2\"),\n+                                   Path(\"1a\"), Path(\"4a\"),Path(\"1a\"),\n+                                   Path(\"2\"), Path(\"3\"), Path(\"4a\"),\n+                                   Path(\"3\")]);\n         assert_eq!(res, ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")]);\n     }\n "}, {"sha": "a7cc90f473d4bd2b5955d4b45f72e72ad125ba43", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -30,7 +30,7 @@ use core::io;\n use core::os;\n use core::str;\n use core::vec;\n-use extra::getopts::groups::{optopt, optmulti, optflag, optflagopt, getopts};\n+use extra::getopts::groups::{optopt, optmulti, optflag, optflagopt};\n use extra::getopts::{opt_present};\n use extra::getopts;\n use syntax::ast;\n@@ -942,15 +942,15 @@ mod test {\n             @~\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, @~\"whatever\", &str_input(~\"\"));\n-        assert!((attr::contains_name(cfg, ~\"test\")));\n+        assert!((attr::contains_name(cfg, \"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n     // another --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n-            &match getopts(~[~\"--test\", ~\"--cfg=test\"], optgroups()) {\n+            &match getopts([~\"--test\", ~\"--cfg=test\"], optgroups()) {\n               Ok(copy m) => m,\n               Err(copy f) => {\n                 fail!(\"test_switch_implies_cfg_test_unless_cfg_test: %s\", getopts::fail_str(f));\n@@ -960,7 +960,7 @@ mod test {\n             @~\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, @~\"whatever\", &str_input(~\"\"));\n-        let test_items = attr::find_meta_items_by_name(cfg, ~\"test\");\n+        let test_items = attr::find_meta_items_by_name(cfg, \"test\");\n         assert_eq!(test_items.len(), 1u);\n     }\n }"}, {"sha": "d156457ca8865dcf249a8a5a2436390f717bf861", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -10,7 +10,6 @@\n \n use core::prelude::*;\n \n-use driver::session::Session;\n use driver::session;\n use middle::ty;\n use middle::pat_util;"}, {"sha": "cda0dfd12a35efecd3fe5be42b882430d8929019", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -535,7 +535,7 @@ pub impl NameBindings {\n                        parent_link: ParentLink,\n                        def_id: Option<def_id>,\n                        kind: ModuleKind,\n-                       sp: span) {\n+                       _sp: span) {\n         match self.type_def {\n             None => {\n                 let module = @mut Module(parent_link, def_id, kind);\n@@ -2586,8 +2586,8 @@ pub impl Resolver {\n                                         (ImportSearch, ImplModuleKind) => {\n                                             self.session.span_err(\n                                                 span,\n-                                                ~\"cannot import from a trait \\\n-                                                  or type implementation\");\n+                                                \"cannot import from a trait \\\n+                                                 or type implementation\");\n                                             return Failed;\n                                         }\n                                         (_, _) => search_module = module_def,"}, {"sha": "d56690f4b6a48ef1c90f81230728e6cd4f1034c8", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -1367,13 +1367,21 @@ pub type mono_id = @mono_id_;\n impl to_bytes::IterBytes for mono_param_id {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n-            mono_precise(t, ref mids) =>\n-                to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), mids, lsb0, f),\n+            mono_precise(t, ref mids) => {\n+                0u8.iter_bytes(lsb0, f) &&\n+                ty::type_id(t).iter_bytes(lsb0, f) &&\n+                mids.iter_bytes(lsb0, f)\n+            }\n \n             mono_any => 1u8.iter_bytes(lsb0, f),\n \n-            mono_repr(ref a, ref b, ref c, ref d) =>\n-                to_bytes::iter_bytes_5(&2u8, a, b, c, d, lsb0, f)\n+            mono_repr(ref a, ref b, ref c, ref d) => {\n+                2u8.iter_bytes(lsb0, f) &&\n+                a.iter_bytes(lsb0, f) &&\n+                b.iter_bytes(lsb0, f) &&\n+                c.iter_bytes(lsb0, f) &&\n+                d.iter_bytes(lsb0, f)\n+            }\n         }\n     }\n }\n@@ -1386,7 +1394,7 @@ impl to_bytes::IterBytes for MonoDataClass {\n \n impl to_bytes::IterBytes for mono_id_ {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f)\n+        self.def.iter_bytes(lsb0, f) && self.params.iter_bytes(lsb0, f)\n     }\n }\n "}, {"sha": "381c257f6511cdd16150799432baabddd8710fcb", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -873,7 +873,7 @@ pub fn trans_trait_cast(bcx: block,\n                         val: @ast::expr,\n                         id: ast::node_id,\n                         dest: expr::Dest,\n-                        store: ty::TraitStore)\n+                        _store: ty::TraitStore)\n                      -> block {\n     let mut bcx = bcx;\n     let _icx = bcx.insn_ctxt(\"impl::trans_cast\");"}, {"sha": "4d9d9f53e4c16147cc45139d3ef8e75a925f7fa3", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -145,7 +145,7 @@ pub impl Reflector {\n     }\n \n     fn leaf(&mut self, name: ~str) {\n-        self.visit(name, ~[]);\n+        self.visit(name, []);\n     }\n \n     // Entrypoint"}, {"sha": "621ce48a4fd08ee6a893351e813c8d1a314abfa0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 84, "deletions": 71, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -137,7 +137,9 @@ type creader_cache = @mut HashMap<creader_cache_key, t>;\n \n impl to_bytes::IterBytes for creader_cache_key {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f)\n+        self.cnum.iter_bytes(lsb0, f) &&\n+        self.pos.iter_bytes(lsb0, f) &&\n+        self.len.iter_bytes(lsb0, f)\n     }\n }\n \n@@ -392,14 +394,19 @@ pub struct FnSig {\n \n impl to_bytes::IterBytes for BareFnTy {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        to_bytes::iter_bytes_3(&self.purity, &self.abis, &self.sig, lsb0, f)\n+        self.purity.iter_bytes(lsb0, f) &&\n+        self.abis.iter_bytes(lsb0, f) &&\n+        self.sig.iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for ClosureTy {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n-                               &self.region, &self.sig, lsb0, f)\n+        self.purity.iter_bytes(lsb0, f) &&\n+        self.sigil.iter_bytes(lsb0, f) &&\n+        self.onceness.iter_bytes(lsb0, f) &&\n+        self.region.iter_bytes(lsb0, f) &&\n+        self.sig.iter_bytes(lsb0, f)\n     }\n }\n \n@@ -717,9 +724,15 @@ pub enum InferTy {\n impl to_bytes::IterBytes for InferTy {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n-          TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n-          IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f),\n-          FloatVar(ref fv) => to_bytes::iter_bytes_2(&2u8, fv, lsb0, f),\n+            TyVar(ref tv) => {\n+                0u8.iter_bytes(lsb0, f) && tv.iter_bytes(lsb0, f)\n+            }\n+            IntVar(ref iv) => {\n+                1u8.iter_bytes(lsb0, f) && iv.iter_bytes(lsb0, f)\n+            }\n+            FloatVar(ref fv) => {\n+                2u8.iter_bytes(lsb0, f) && fv.iter_bytes(lsb0, f)\n+            }\n         }\n     }\n }\n@@ -733,8 +746,12 @@ pub enum InferRegion {\n impl to_bytes::IterBytes for InferRegion {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n-            ReVar(ref rv) => to_bytes::iter_bytes_2(&0u8, rv, lsb0, f),\n-            ReSkolemized(ref v, _) => to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n+            ReVar(ref rv) => {\n+                0u8.iter_bytes(lsb0, f) && rv.iter_bytes(lsb0, f)\n+            }\n+            ReSkolemized(ref v, _) => {\n+                1u8.iter_bytes(lsb0, f) && v.iter_bytes(lsb0, f)\n+            }\n         }\n     }\n }\n@@ -2626,119 +2643,115 @@ impl cmp::TotalEq for bound_region {\n impl to_bytes::IterBytes for vstore {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n-          vstore_fixed(ref u) =>\n-          to_bytes::iter_bytes_2(&0u8, u, lsb0, f),\n-\n-          vstore_uniq => 1u8.iter_bytes(lsb0, f),\n-          vstore_box => 2u8.iter_bytes(lsb0, f),\n+            vstore_fixed(ref u) => {\n+                0u8.iter_bytes(lsb0, f) && u.iter_bytes(lsb0, f)\n+            }\n+            vstore_uniq => 1u8.iter_bytes(lsb0, f),\n+            vstore_box => 2u8.iter_bytes(lsb0, f),\n \n-          vstore_slice(ref r) =>\n-          to_bytes::iter_bytes_2(&3u8, r, lsb0, f),\n+            vstore_slice(ref r) => {\n+                3u8.iter_bytes(lsb0, f) && r.iter_bytes(lsb0, f)\n+            }\n         }\n     }\n }\n \n impl to_bytes::IterBytes for substs {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-          to_bytes::iter_bytes_3(&self.self_r,\n-                                 &self.self_ty,\n-                                 &self.tps, lsb0, f)\n+        self.self_r.iter_bytes(lsb0, f) &&\n+        self.self_ty.iter_bytes(lsb0, f) &&\n+        self.tps.iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for mt {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-          to_bytes::iter_bytes_2(&self.ty,\n-                                 &self.mutbl, lsb0, f)\n+        self.ty.iter_bytes(lsb0, f) && self.mutbl.iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for field {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-          to_bytes::iter_bytes_2(&self.ident,\n-                                 &self.mt, lsb0, f)\n+        self.ident.iter_bytes(lsb0, f) && self.mt.iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for FnSig {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        to_bytes::iter_bytes_2(&self.inputs,\n-                               &self.output,\n-                               lsb0, f)\n+        self.inputs.iter_bytes(lsb0, f) && self.output.iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for sty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n-          ty_nil => 0u8.iter_bytes(lsb0, f),\n-          ty_bool => 1u8.iter_bytes(lsb0, f),\n+            ty_nil => 0u8.iter_bytes(lsb0, f),\n+            ty_bool => 1u8.iter_bytes(lsb0, f),\n \n-          ty_int(ref t) =>\n-          to_bytes::iter_bytes_2(&2u8, t, lsb0, f),\n+            ty_int(ref t) => 2u8.iter_bytes(lsb0, f) && t.iter_bytes(lsb0, f),\n \n-          ty_uint(ref t) =>\n-          to_bytes::iter_bytes_2(&3u8, t, lsb0, f),\n+            ty_uint(ref t) => 3u8.iter_bytes(lsb0, f) && t.iter_bytes(lsb0, f),\n \n-          ty_float(ref t) =>\n-          to_bytes::iter_bytes_2(&4u8, t, lsb0, f),\n+            ty_float(ref t) => 4u8.iter_bytes(lsb0, f) && t.iter_bytes(lsb0, f),\n \n-          ty_estr(ref v) =>\n-          to_bytes::iter_bytes_2(&5u8, v, lsb0, f),\n+            ty_estr(ref v) => 5u8.iter_bytes(lsb0, f) && v.iter_bytes(lsb0, f),\n \n-          ty_enum(ref did, ref substs) =>\n-          to_bytes::iter_bytes_3(&6u8, did, substs, lsb0, f),\n+            ty_enum(ref did, ref substs) => {\n+                6u8.iter_bytes(lsb0, f) &&\n+                did.iter_bytes(lsb0, f) &&\n+                substs.iter_bytes(lsb0, f)\n+            }\n \n-          ty_box(ref mt) =>\n-          to_bytes::iter_bytes_2(&7u8, mt, lsb0, f),\n+            ty_box(ref mt) => 7u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n \n-          ty_evec(ref mt, ref v) =>\n-          to_bytes::iter_bytes_3(&8u8, mt, v, lsb0, f),\n+            ty_evec(ref mt, ref v) => {\n+                8u8.iter_bytes(lsb0, f) &&\n+                mt.iter_bytes(lsb0, f) &&\n+                v.iter_bytes(lsb0, f)\n+            }\n \n-          ty_unboxed_vec(ref mt) =>\n-          to_bytes::iter_bytes_2(&9u8, mt, lsb0, f),\n+            ty_unboxed_vec(ref mt) => 9u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n \n-          ty_tup(ref ts) =>\n-          to_bytes::iter_bytes_2(&10u8, ts, lsb0, f),\n+            ty_tup(ref ts) => 10u8.iter_bytes(lsb0, f) && ts.iter_bytes(lsb0, f),\n \n-          ty_bare_fn(ref ft) =>\n-          to_bytes::iter_bytes_2(&12u8, ft, lsb0, f),\n+            ty_bare_fn(ref ft) => 12u8.iter_bytes(lsb0, f) && ft.iter_bytes(lsb0, f),\n \n-          ty_self(ref did) => to_bytes::iter_bytes_2(&13u8, did, lsb0, f),\n+            ty_self(ref did) => 13u8.iter_bytes(lsb0, f) && did.iter_bytes(lsb0, f),\n \n-          ty_infer(ref v) =>\n-          to_bytes::iter_bytes_2(&14u8, v, lsb0, f),\n+            ty_infer(ref v) => 14u8.iter_bytes(lsb0, f) && v.iter_bytes(lsb0, f),\n \n-          ty_param(ref p) =>\n-          to_bytes::iter_bytes_2(&15u8, p, lsb0, f),\n+            ty_param(ref p) => 15u8.iter_bytes(lsb0, f) && p.iter_bytes(lsb0, f),\n \n-          ty_type => 16u8.iter_bytes(lsb0, f),\n-          ty_bot => 17u8.iter_bytes(lsb0, f),\n+            ty_type => 16u8.iter_bytes(lsb0, f),\n+            ty_bot => 17u8.iter_bytes(lsb0, f),\n \n-          ty_ptr(ref mt) =>\n-          to_bytes::iter_bytes_2(&18u8, mt, lsb0, f),\n+            ty_ptr(ref mt) => 18u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n \n-          ty_uniq(ref mt) =>\n-          to_bytes::iter_bytes_2(&19u8, mt, lsb0, f),\n+            ty_uniq(ref mt) => 19u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n \n-          ty_trait(ref did, ref substs, ref v, ref mutbl) =>\n-          to_bytes::iter_bytes_5(&20u8, did, substs, v, mutbl, lsb0, f),\n+            ty_trait(ref did, ref substs, ref v, ref mutbl) => {\n+                20u8.iter_bytes(lsb0, f) &&\n+                did.iter_bytes(lsb0, f) &&\n+                substs.iter_bytes(lsb0, f) &&\n+                v.iter_bytes(lsb0, f) &&\n+                mutbl.iter_bytes(lsb0, f)\n+            }\n \n-          ty_opaque_closure_ptr(ref ck) =>\n-          to_bytes::iter_bytes_2(&21u8, ck, lsb0, f),\n+            ty_opaque_closure_ptr(ref ck) => 21u8.iter_bytes(lsb0, f) && ck.iter_bytes(lsb0, f),\n \n-          ty_opaque_box => 22u8.iter_bytes(lsb0, f),\n+            ty_opaque_box => 22u8.iter_bytes(lsb0, f),\n \n-          ty_struct(ref did, ref substs) =>\n-          to_bytes::iter_bytes_3(&23u8, did, substs, lsb0, f),\n+            ty_struct(ref did, ref substs) => {\n+                23u8.iter_bytes(lsb0, f) && did.iter_bytes(lsb0, f) && substs.iter_bytes(lsb0, f)\n+            }\n \n-          ty_rptr(ref r, ref mt) =>\n-          to_bytes::iter_bytes_3(&24u8, r, mt, lsb0, f),\n+            ty_rptr(ref r, ref mt) => {\n+                24u8.iter_bytes(lsb0, f) && r.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f)\n+            }\n \n-          ty_err => 25u8.iter_bytes(lsb0, f),\n+            ty_err => 25u8.iter_bytes(lsb0, f),\n \n-          ty_closure(ref ct) =>\n-          to_bytes::iter_bytes_2(&26u8, ct, lsb0, f),\n+            ty_closure(ref ct) => 26u8.iter_bytes(lsb0, f) && ct.iter_bytes(lsb0, f),\n         }\n     }\n }"}, {"sha": "556fcfeac99a5d087ab03cd4e3faadbd6042543c", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -564,14 +564,23 @@ enum Constraint {\n impl to_bytes::IterBytes for Constraint {\n    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n-          ConstrainVarSubVar(ref v0, ref v1) =>\n-          to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n+            ConstrainVarSubVar(ref v0, ref v1) => {\n+                0u8.iter_bytes(lsb0, f) &&\n+                v0.iter_bytes(lsb0, f) &&\n+                v1.iter_bytes(lsb0, f)\n+            }\n \n-          ConstrainRegSubVar(ref ra, ref va) =>\n-          to_bytes::iter_bytes_3(&1u8, ra, va, lsb0, f),\n+            ConstrainRegSubVar(ref ra, ref va) => {\n+                1u8.iter_bytes(lsb0, f) &&\n+                ra.iter_bytes(lsb0, f) &&\n+                va.iter_bytes(lsb0, f)\n+            }\n \n-          ConstrainVarSubReg(ref va, ref ra) =>\n-          to_bytes::iter_bytes_3(&2u8, va, ra, lsb0, f)\n+            ConstrainVarSubReg(ref va, ref ra) => {\n+                2u8.iter_bytes(lsb0, f) &&\n+                va.iter_bytes(lsb0, f) &&\n+                ra.iter_bytes(lsb0, f)\n+            }\n         }\n     }\n }"}, {"sha": "6534a7ba9b0885977052590b527a409936f6a60a", "filename": "src/librustc/util/enum_set.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -10,8 +10,6 @@\n \n use core::prelude::*;\n \n-use core;\n-\n #[deriving(Eq, IterBytes)]\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set"}, {"sha": "7366aca4c4f6f5b9f4230e80f09c9cf611b9f804", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -278,102 +278,102 @@ mod test {\n \n     #[test]\n     fn should_error_with_no_crates() {\n-        let config = parse_config(~[~\"rustdoc\"]);\n+        let config = parse_config([~\"rustdoc\"]);\n         assert!(config.get_err() == ~\"no crates specified\");\n     }\n \n     #[test]\n     fn should_error_with_multiple_crates() {\n         let config =\n-            parse_config(~[~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n+            parse_config([~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n         assert!(config.get_err() == ~\"multiple crates specified\");\n     }\n \n     #[test]\n     fn should_set_output_dir_to_cwd_if_not_provided() {\n-        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n         assert!(config.get().output_dir == Path(\".\"));\n     }\n \n     #[test]\n     fn should_set_output_dir_if_provided() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n         ]);\n         assert!(config.get().output_dir == Path(\"snuggles\"));\n     }\n \n     #[test]\n     fn should_set_output_format_to_pandoc_html_if_not_provided() {\n-        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n         assert!(config.get().output_format == PandocHtml);\n     }\n \n     #[test]\n     fn should_set_output_format_to_markdown_if_requested() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n         ]);\n         assert!(config.get().output_format == Markdown);\n     }\n \n     #[test]\n     fn should_set_output_format_to_pandoc_html_if_requested() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n         ]);\n         assert!(config.get().output_format == PandocHtml);\n     }\n \n     #[test]\n     fn should_error_on_bogus_format() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"bogus\"\n         ]);\n         assert!(config.get_err() == ~\"unknown output format 'bogus'\");\n     }\n \n     #[test]\n     fn should_set_output_style_to_doc_per_mod_by_default() {\n-        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n         assert!(config.get().output_style == DocPerMod);\n     }\n \n     #[test]\n     fn should_set_output_style_to_one_doc_if_requested() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n         ]);\n         assert!(config.get().output_style == DocPerCrate);\n     }\n \n     #[test]\n     fn should_set_output_style_to_doc_per_mod_if_requested() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n         ]);\n         assert!(config.get().output_style == DocPerMod);\n     }\n \n     #[test]\n     fn should_error_on_bogus_output_style() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"bogus\"\n         ]);\n         assert!(config.get_err() == ~\"unknown output style 'bogus'\");\n     }\n \n     #[test]\n     fn should_set_pandoc_command_if_requested() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--pandoc-cmd\", ~\"panda-bear-doc\"\n         ]);\n         assert!(config.get().pandoc_cmd == Some(~\"panda-bear-doc\"));\n     }\n \n     #[test]\n     fn should_set_pandoc_command_when_using_pandoc() {\n-        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n         assert!(config.get().pandoc_cmd == Some(~\"pandoc\"));\n     }\n }"}, {"sha": "130cbb784ee37377aac55c5c7e3ad7b4a4446f2d", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -220,13 +220,13 @@ mod test {\n \n     #[test]\n     fn test_paragraphs_1() {\n-        let paras = paragraphs(~\"1\\n\\n2\");\n+        let paras = paragraphs(\"1\\n\\n2\");\n         assert_eq!(paras, ~[~\"1\", ~\"2\"]);\n     }\n \n     #[test]\n     fn test_paragraphs_2() {\n-        let paras = paragraphs(~\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n+        let paras = paragraphs(\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n         assert_eq!(paras, ~[~\"1\\n1\", ~\"2\"]);\n     }\n "}, {"sha": "3ef907d819d68dc82c21e9b4c2195e0391011919", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -16,9 +16,7 @@ use astsrv;\n use doc::ItemUtils;\n use doc;\n \n-use core::local_data::local_data_get;\n use syntax::ast;\n-use syntax;\n use syntax::parse::token::{ident_interner};\n use syntax::parse::token;\n "}, {"sha": "8ff0aa2314647dd02bcbbd81ba4a60f141bb4c91", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -193,21 +193,21 @@ mod test {\n \n     #[test]\n     fn should_remove_punctuation_from_headers() {\n-        assert!(pandoc_header_id(~\"impl foo of bar<A>\") ==\n+        assert!(pandoc_header_id(\"impl foo of bar<A>\") ==\n                 ~\"impl-foo-of-bara\");\n-        assert!(pandoc_header_id(~\"impl of num::num for int\")\n+        assert!(pandoc_header_id(\"impl of num::num for int\")\n                 == ~\"impl-of-numnum-for-int\");\n-        assert!(pandoc_header_id(~\"impl of num::num for int/&\")\n+        assert!(pandoc_header_id(\"impl of num::num for int/&\")\n                 == ~\"impl-of-numnum-for-int\");\n-        assert!(pandoc_header_id(~\"impl of num::num for ^int\")\n+        assert!(pandoc_header_id(\"impl of num::num for ^int\")\n                 == ~\"impl-of-numnum-for-int\");\n-        assert!(pandoc_header_id(~\"impl for & condvar\")\n+        assert!(pandoc_header_id(\"impl for & condvar\")\n                 == ~\"impl-for-condvar\");\n-        assert!(pandoc_header_id(~\"impl of Select<T, U> for (Left, Right)\")\n+        assert!(pandoc_header_id(\"impl of Select<T, U> for (Left, Right)\")\n                 == ~\"impl-of-selectt-u-for-left-right\");\n-        assert!(pandoc_header_id(~\"impl of Condition<'self, T, U>\")\n+        assert!(pandoc_header_id(\"impl of Condition<'self, T, U>\")\n                 == ~\"impl-of-conditionself-t-u\");\n-        assert!(pandoc_header_id(~\"impl of Condition<T: Copy + Clone>\")\n+        assert!(pandoc_header_id(\"impl of Condition<T: Copy + Clone>\")\n                 == ~\"impl-of-conditiont-copy-clone\");\n     }\n "}, {"sha": "c6f5dbefb6add595a48b6578895ecd30a1f8afe0", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 53, "deletions": 57, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -587,13 +587,13 @@ mod test {\n     #[test]\n     fn write_markdown_should_write_mod_headers() {\n         let markdown = render(~\"mod moo { }\");\n-        assert!(str::contains(markdown, ~\"# Module `moo`\"));\n+        assert!(str::contains(markdown, \"# Module `moo`\"));\n     }\n \n     #[test]\n     fn should_leave_blank_line_after_header() {\n         let markdown = render(~\"mod morp { }\");\n-        assert!(str::contains(markdown, ~\"Module `morp`\\n\\n\"));\n+        assert!(str::contains(markdown, \"Module `morp`\\n\\n\"));\n     }\n \n     #[test]\n@@ -613,10 +613,10 @@ mod test {\n               fn d() { }\"\n         );\n \n-        let idx_a = str::find_str(markdown, ~\"# Module `a`\").get();\n-        let idx_b = str::find_str(markdown, ~\"## Function `b`\").get();\n-        let idx_c = str::find_str(markdown, ~\"# Module `c`\").get();\n-        let idx_d = str::find_str(markdown, ~\"## Function `d`\").get();\n+        let idx_a = str::find_str(markdown, \"# Module `a`\").get();\n+        let idx_b = str::find_str(markdown, \"## Function `b`\").get();\n+        let idx_c = str::find_str(markdown, \"# Module `c`\").get();\n+        let idx_d = str::find_str(markdown, \"## Function `d`\").get();\n \n         assert!(idx_b < idx_d);\n         assert!(idx_d < idx_a);\n@@ -649,7 +649,7 @@ mod test {\n             let (page, markdown) = po.recv();\n             match page {\n                 doc::CratePage(_) => {\n-                    assert!(str::contains(markdown, ~\"% Crate core\"));\n+                    assert!(str::contains(markdown, \"% Crate core\"));\n                 }\n                 doc::ItemPage(_) => {\n                     assert!(str::contains(markdown, ~\"% Module a\"));\n@@ -661,7 +661,7 @@ mod test {\n     #[test]\n     fn should_write_full_path_to_mod() {\n         let markdown = render(~\"mod a { mod b { mod c { } } }\");\n-        assert!(str::contains(markdown, ~\"# Module `a::b::c`\"));\n+        assert!(str::contains(markdown, \"# Module `a::b::c`\"));\n     }\n \n     #[test]\n@@ -672,13 +672,13 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\"));\n+        assert!(str::contains(markdown, \"#### Header\\n\\nBody\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_crate_description() {\n         let markdown = render(~\"#[doc = \\\"this is the crate\\\"];\");\n-        assert!(str::contains(markdown, ~\"this is the crate\"));\n+        assert!(str::contains(markdown, \"this is the crate\"));\n     }\n \n \n@@ -687,62 +687,62 @@ mod test {\n         let markdown = render(~\"mod a { } mod b { }\");\n         assert!(str::contains(\n             markdown,\n-            ~\"\\n\\n* [Module `a`](#module-a)\\n\\\n-              * [Module `b`](#module-b)\\n\\n\"\n+            \"\\n\\n* [Module `a`](#module-a)\\n\\\n+             * [Module `b`](#module-b)\\n\\n\"\n         ));\n     }\n \n     #[test]\n     fn should_write_index_brief() {\n         let markdown = render(~\"#[doc = \\\"test\\\"] mod a { }\");\n-        assert!(str::contains(markdown, ~\"(#module-a) - test\\n\"));\n+        assert!(str::contains(markdown, \"(#module-a) - test\\n\"));\n     }\n \n     #[test]\n     fn should_not_write_index_if_no_entries() {\n         let markdown = render(~\"\");\n-        assert!(!str::contains(markdown, ~\"\\n\\n\\n\"));\n+        assert!(!str::contains(markdown, \"\\n\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_index_for_foreign_mods() {\n         let markdown = render(~\"extern { fn a(); }\");\n         assert!(str::contains(\n             markdown,\n-            ~\"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n+            \"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n         ));\n     }\n \n     #[test]\n     fn should_write_foreign_fns() {\n         let markdown = render(\n             ~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-        assert!(str::contains(markdown, ~\"test\"));\n+        assert!(str::contains(markdown, \"test\"));\n     }\n \n     #[test]\n     fn should_write_foreign_fn_headers() {\n         let markdown = render(\n             ~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-        assert!(str::contains(markdown, ~\"## Function `a`\"));\n+        assert!(str::contains(markdown, \"## Function `a`\"));\n     }\n \n     #[test]\n     fn write_markdown_should_write_function_header() {\n         let markdown = render(~\"fn func() { }\");\n-        assert!(str::contains(markdown, ~\"## Function `func`\"));\n+        assert!(str::contains(markdown, \"## Function `func`\"));\n     }\n \n     #[test]\n     fn should_write_the_function_signature() {\n         let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-        assert!(str::contains(markdown, ~\"\\n    fn a()\\n\"));\n+        assert!(str::contains(markdown, \"\\n    fn a()\\n\"));\n     }\n \n     #[test]\n     fn should_insert_blank_line_after_fn_signature() {\n         let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-        assert!(str::contains(markdown, ~\"fn a()\\n\\n\"));\n+        assert!(str::contains(markdown, \"fn a()\\n\\n\"));\n     }\n \n     #[test]\n@@ -763,40 +763,39 @@ mod test {\n             ]\n         };\n         let markdown = write_markdown_str(doc);\n-        assert!(str::contains(markdown, ~\"    line 1\\n    line 2\"));\n+        assert!(str::contains(markdown, \"    line 1\\n    line 2\"));\n     }\n \n     #[test]\n     fn should_leave_blank_line_between_fn_header_and_sig() {\n         let markdown = render(~\"fn a() { }\");\n-        assert!(str::contains(markdown, ~\"Function `a`\\n\\n    fn a()\"));\n+        assert!(str::contains(markdown, \"Function `a`\\n\\n    fn a()\"));\n     }\n \n     #[test]\n     fn should_write_const_header() {\n         let markdown = render(~\"static a: bool = true;\");\n-        assert!(str::contains(markdown, ~\"## Const `a`\\n\\n\"));\n+        assert!(str::contains(markdown, \"## Const `a`\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_const_description() {\n         let markdown = render(\n             ~\"#[doc = \\\"b\\\"]\\\n               static a: bool = true;\");\n-        assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n+        assert!(str::contains(markdown, \"\\n\\nb\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_enum_header() {\n         let markdown = render(~\"enum a { b }\");\n-        assert!(str::contains(markdown, ~\"## Enum `a`\\n\\n\"));\n+        assert!(str::contains(markdown, \"## Enum `a`\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_enum_description() {\n-        let markdown = render(\n-            ~\"#[doc = \\\"b\\\"] enum a { b }\");\n-        assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n+        let markdown = render(~\"#[doc = \\\"b\\\"] enum a { b }\");\n+        assert!(str::contains(markdown, \"\\n\\nb\\n\\n\"));\n     }\n \n     #[test]\n@@ -807,120 +806,117 @@ mod test {\n               #[doc = \\\"test\\\"] c }\");\n         assert!(str::contains(\n             markdown,\n-            ~\"\\n\\n#### Variants\\n\\\n-              \\n* `b` - test\\\n-              \\n* `c` - test\\n\\n\"));\n+            \"\\n\\n#### Variants\\n\\\n+             \\n* `b` - test\\\n+             \\n* `c` - test\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_variant_list_without_descs() {\n         let markdown = render(~\"enum a { b, c }\");\n         assert!(str::contains(\n             markdown,\n-            ~\"\\n\\n#### Variants\\n\\\n-              \\n* `b`\\\n-              \\n* `c`\\n\\n\"));\n+            \"\\n\\n#### Variants\\n\\\n+             \\n* `b`\\\n+             \\n* `c`\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_variant_list_with_signatures() {\n         let markdown = render(~\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n         assert!(str::contains(\n             markdown,\n-            ~\"\\n\\n#### Variants\\n\\\n-              \\n* `b(int)`\\\n-              \\n* `c(int)` - a\\n\\n\"));\n+            \"\\n\\n#### Variants\\n\\\n+             \\n* `b(int)`\\\n+             \\n* `c(int)` - a\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_trait_header() {\n         let markdown = render(~\"trait i { fn a(); }\");\n-        assert!(str::contains(markdown, ~\"## Trait `i`\"));\n+        assert!(str::contains(markdown, \"## Trait `i`\"));\n     }\n \n     #[test]\n     fn should_write_trait_desc() {\n-        let markdown = render(\n-            ~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n-        assert!(str::contains(markdown, ~\"desc\"));\n+        let markdown = render(~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n+        assert!(str::contains(markdown, \"desc\"));\n     }\n \n     #[test]\n     fn should_write_trait_method_header() {\n-        let markdown = render(\n-            ~\"trait i { fn a(); }\");\n-        assert!(str::contains(markdown, ~\"### Method `a`\"));\n+        let markdown = render(~\"trait i { fn a(); }\");\n+        assert!(str::contains(markdown, \"### Method `a`\"));\n     }\n \n     #[test]\n     fn should_write_trait_method_signature() {\n-        let markdown = render(\n-            ~\"trait i { fn a(&self); }\");\n-        assert!(str::contains(markdown, ~\"\\n    fn a(&self)\"));\n+        let markdown = render(~\"trait i { fn a(&self); }\");\n+        assert!(str::contains(markdown, \"\\n    fn a(&self)\"));\n     }\n \n     #[test]\n     fn should_write_impl_header() {\n         let markdown = render(~\"impl int { fn a() { } }\");\n-        assert!(str::contains(markdown, ~\"## Implementation for `int`\"));\n+        assert!(str::contains(markdown, \"## Implementation for `int`\"));\n     }\n \n     #[test]\n     fn should_write_impl_header_with_bounds() {\n         let markdown = render(~\"impl <T> int<T> { }\");\n-        assert!(str::contains(markdown, ~\"## Implementation for `int<T>` where `<T>`\"));\n+        assert!(str::contains(markdown, \"## Implementation for `int<T>` where `<T>`\"));\n     }\n \n     #[test]\n     fn should_write_impl_header_with_trait() {\n         let markdown = render(~\"impl j for int { fn a() { } }\");\n         assert!(str::contains(markdown,\n-                              ~\"## Implementation of `j` for `int`\"));\n+                              \"## Implementation of `j` for `int`\"));\n     }\n \n     #[test]\n     fn should_write_impl_desc() {\n         let markdown = render(\n             ~\"#[doc = \\\"desc\\\"] impl int { fn a() { } }\");\n-        assert!(str::contains(markdown, ~\"desc\"));\n+        assert!(str::contains(markdown, \"desc\"));\n     }\n \n     #[test]\n     fn should_write_impl_method_header() {\n         let markdown = render(\n             ~\"impl int { fn a() { } }\");\n-        assert!(str::contains(markdown, ~\"### Method `a`\"));\n+        assert!(str::contains(markdown, \"### Method `a`\"));\n     }\n \n     #[test]\n     fn should_write_impl_method_signature() {\n         let markdown = render(\n             ~\"impl int { fn a(&mut self) { } }\");\n-        assert!(str::contains(markdown, ~\"\\n    fn a(&mut self)\"));\n+        assert!(str::contains(markdown, \"\\n    fn a(&mut self)\"));\n     }\n \n     #[test]\n     fn should_write_type_header() {\n         let markdown = render(~\"type t = int;\");\n-        assert!(str::contains(markdown, ~\"## Type `t`\"));\n+        assert!(str::contains(markdown, \"## Type `t`\"));\n     }\n \n     #[test]\n     fn should_write_type_desc() {\n         let markdown = render(\n             ~\"#[doc = \\\"desc\\\"] type t = int;\");\n-        assert!(str::contains(markdown, ~\"\\n\\ndesc\\n\\n\"));\n+        assert!(str::contains(markdown, \"\\n\\ndesc\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_type_signature() {\n         let markdown = render(~\"type t = int;\");\n-        assert!(str::contains(markdown, ~\"\\n\\n    type t = int\\n\\n\"));\n+        assert!(str::contains(markdown, \"\\n\\n    type t = int\\n\\n\"));\n     }\n \n     #[test]\n     fn should_put_struct_header() {\n         let markdown = render(~\"struct S { field: () }\");\n-        assert!(str::contains(markdown, ~\"## Struct `S`\\n\\n\"));\n+        assert!(str::contains(markdown, \"## Struct `S`\\n\\n\"));\n     }\n }"}, {"sha": "1ffdd396da9d54e1f0bc229de463073b5cee3b1b", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -188,7 +188,7 @@ mod test {\n }\");\n         assert!(str::contains(\n             doc.cratemod().mods()[0].item.sections[0].header,\n-            ~\"Header\"));\n+            \"Header\"));\n     }\n \n     #[test]\n@@ -201,7 +201,7 @@ mod test {\n }\");\n         assert!(str::contains(\n             doc.cratemod().mods()[0].item.sections[0].body,\n-            ~\"Body\"));\n+            \"Body\"));\n     }\n \n     #[test]\n@@ -226,10 +226,10 @@ mod test {\n }\");\n         assert!(!str::contains(\n             doc.cratemod().mods()[0].desc().get(),\n-            ~\"Header\"));\n+            \"Header\"));\n         assert!(!str::contains(\n             doc.cratemod().mods()[0].desc().get(),\n-            ~\"Body\"));\n+            \"Body\"));\n     }\n \n     #[test]"}, {"sha": "2097d0b69074341243231965941df664f298d441", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -80,7 +80,7 @@ fn record(mut repl: Repl, blk: &ast::blk, intr: @token::ident_interner) -> Repl\n         let new_view_items = do with_pp(intr) |pp, writer| {\n             for blk.node.view_items.each |view_item| {\n                 pprust::print_view_item(pp, *view_item);\n-                writer.write_line(~\"\");\n+                writer.write_line(\"\");\n             }\n         };\n \n@@ -94,7 +94,7 @@ fn record(mut repl: Repl, blk: &ast::blk, intr: @token::ident_interner) -> Repl\n                 match stmt.node {\n                     ast::stmt_decl(*) | ast::stmt_mac(*) => {\n                         pprust::print_stmt(pp, *stmt);\n-                        writer.write_line(~\"\");\n+                        writer.write_line(\"\");\n                     }\n                     ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n                         match expr.node {\n@@ -415,7 +415,7 @@ pub fn main() {\n             Some(line) => {\n                 if line.is_empty() {\n                     if istty {\n-                        io::println(~\"()\");\n+                        io::println(\"()\");\n                     }\n                     loop;\n                 }"}, {"sha": "1bd1a6bfd77ceda4adb4897a042d7879d56420e3", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -12,7 +12,6 @@\n \n use context::Ctx;\n use core::hashmap::HashMap;\n-use core::path::Path;\n use core::prelude::*;\n use std::tempfile::mkdtemp;\n use util::{PkgId, default_version};"}, {"sha": "cde22afd34a833551ae46a5086d8c386169da902", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -11,7 +11,6 @@\n //! Unsafe casting functions\n \n use sys;\n-use unstable;\n use unstable::intrinsics;\n \n /// Casts the value at `src` to U. The two types must have the same length."}, {"sha": "f46c8ab7ecc6edb35f8456e78415aa4b5f0cf27b", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -488,7 +488,7 @@ mod tests {\n             assert!(f == i && f == v);\n \n             buf += ~[t as u8];\n-            stream_inc.input(~[t as u8]);\n+            stream_inc.input([t as u8]);\n \n             t += 1;\n         }"}, {"sha": "4ce4ea108e58cba08ba18de2af3d8d5282c273b2", "filename": "src/libstd/io.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -1839,7 +1839,7 @@ mod tests {\n         {\n             let out: @io::Writer =\n                 result::get(\n-                    &io::file_writer(tmpfile, ~[io::Create, io::Truncate]));\n+                    &io::file_writer(tmpfile, [io::Create, io::Truncate]));\n             out.write_str(frood);\n         }\n         let inp: @io::Reader = result::get(&io::file_reader(tmpfile));\n@@ -1850,31 +1850,31 @@ mod tests {\n \n     #[test]\n     fn test_readchars_empty() {\n-        do io::with_str_reader(~\"\") |inp| {\n+        do io::with_str_reader(\"\") |inp| {\n             let res : ~[char] = inp.read_chars(128);\n             assert_eq!(res.len(), 0);\n         }\n     }\n \n     #[test]\n     fn test_read_line_utf8() {\n-        do io::with_str_reader(~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\") |inp| {\n+        do io::with_str_reader(\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\") |inp| {\n             let line = inp.read_line();\n             assert_eq!(line, ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\");\n         }\n     }\n \n     #[test]\n     fn test_read_lines() {\n-        do io::with_str_reader(~\"a\\nb\\nc\\n\") |inp| {\n+        do io::with_str_reader(\"a\\nb\\nc\\n\") |inp| {\n             assert_eq!(inp.read_lines(), ~[~\"a\", ~\"b\", ~\"c\"]);\n         }\n \n-        do io::with_str_reader(~\"a\\nb\\nc\") |inp| {\n+        do io::with_str_reader(\"a\\nb\\nc\") |inp| {\n             assert_eq!(inp.read_lines(), ~[~\"a\", ~\"b\", ~\"c\"]);\n         }\n \n-        do io::with_str_reader(~\"\") |inp| {\n+        do io::with_str_reader(\"\") |inp| {\n             assert!(inp.read_lines().is_empty());\n         }\n     }\n@@ -1909,15 +1909,15 @@ mod tests {\n \n     #[test]\n     fn test_readchar() {\n-        do io::with_str_reader(~\"\u751f\") |inp| {\n+        do io::with_str_reader(\"\u751f\") |inp| {\n             let res : char = inp.read_char();\n             assert_eq!(res as int, 29983);\n         }\n     }\n \n     #[test]\n     fn test_readchar_empty() {\n-        do io::with_str_reader(~\"\") |inp| {\n+        do io::with_str_reader(\"\") |inp| {\n             let res : char = inp.read_char();\n             assert_eq!(res as int, -1);\n         }\n@@ -1966,7 +1966,7 @@ mod tests {\n \n     #[test]\n     fn file_writer_bad_name() {\n-        match io::file_writer(&Path(\"?/?\"), ~[]) {\n+        match io::file_writer(&Path(\"?/?\"), []) {\n           result::Err(copy e) => {\n             assert!(str::starts_with(e, \"error opening\"));\n           }\n@@ -1987,15 +1987,15 @@ mod tests {\n     #[test]\n     fn bytes_buffer_overwrite() {\n         let wr = BytesWriter();\n-        wr.write(~[0u8, 1u8, 2u8, 3u8]);\n+        wr.write([0u8, 1u8, 2u8, 3u8]);\n         assert!(*wr.bytes == ~[0u8, 1u8, 2u8, 3u8]);\n         wr.seek(-2, SeekCur);\n-        wr.write(~[4u8, 5u8, 6u8, 7u8]);\n+        wr.write([4u8, 5u8, 6u8, 7u8]);\n         assert!(*wr.bytes == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n         wr.seek(-2, SeekEnd);\n-        wr.write(~[8u8]);\n+        wr.write([8u8]);\n         wr.seek(1, SeekSet);\n-        wr.write(~[9u8]);\n+        wr.write([9u8]);\n         assert!(*wr.bytes == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n     }\n \n@@ -2085,7 +2085,7 @@ mod tests {\n         }\n     }\n \n-#[test]\n+    #[test]\n     fn test_read_write_f32() {\n         let path = Path(\"tmp/lib-io-test-read-write-f32.tmp\");\n         let f:f32 = 8.1250;"}, {"sha": "c6d183c6fb841e6aeab9dffc4b70053bf70e9b3d", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -951,7 +951,6 @@ impl num::FromStrRadix for f32 {\n mod tests {\n     use f32::*;\n     use num::*;\n-    use super::*;\n     use prelude::*;\n \n     #[test]"}, {"sha": "262e4176c911de543700e67a0a8c81298d298bbd", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -993,7 +993,6 @@ impl num::FromStrRadix for f64 {\n mod tests {\n     use f64::*;\n     use num::*;\n-    use super::*;\n     use prelude::*;\n \n     #[test]"}, {"sha": "d04f12f6bd3c6664ea904be0a83bf3ac6f768e7f", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -1251,101 +1251,101 @@ mod tests {\n \n     #[test]\n     pub fn test_from_str() {\n-        assert_eq!(from_str(~\"3\"), Some(3.));\n-        assert_eq!(from_str(~\"3.14\"), Some(3.14));\n-        assert_eq!(from_str(~\"+3.14\"), Some(3.14));\n-        assert_eq!(from_str(~\"-3.14\"), Some(-3.14));\n-        assert_eq!(from_str(~\"2.5E10\"), Some(25000000000.));\n-        assert_eq!(from_str(~\"2.5e10\"), Some(25000000000.));\n-        assert_eq!(from_str(~\"25000000000.E-10\"), Some(2.5));\n-        assert_eq!(from_str(~\".\"), Some(0.));\n-        assert_eq!(from_str(~\".e1\"), Some(0.));\n-        assert_eq!(from_str(~\".e-1\"), Some(0.));\n-        assert_eq!(from_str(~\"5.\"), Some(5.));\n-        assert_eq!(from_str(~\".5\"), Some(0.5));\n-        assert_eq!(from_str(~\"0.5\"), Some(0.5));\n-        assert_eq!(from_str(~\"-.5\"), Some(-0.5));\n-        assert_eq!(from_str(~\"-5\"), Some(-5.));\n-        assert_eq!(from_str(~\"inf\"), Some(infinity));\n-        assert_eq!(from_str(~\"+inf\"), Some(infinity));\n-        assert_eq!(from_str(~\"-inf\"), Some(neg_infinity));\n+        assert_eq!(from_str(\"3\"), Some(3.));\n+        assert_eq!(from_str(\"3.14\"), Some(3.14));\n+        assert_eq!(from_str(\"+3.14\"), Some(3.14));\n+        assert_eq!(from_str(\"-3.14\"), Some(-3.14));\n+        assert_eq!(from_str(\"2.5E10\"), Some(25000000000.));\n+        assert_eq!(from_str(\"2.5e10\"), Some(25000000000.));\n+        assert_eq!(from_str(\"25000000000.E-10\"), Some(2.5));\n+        assert_eq!(from_str(\".\"), Some(0.));\n+        assert_eq!(from_str(\".e1\"), Some(0.));\n+        assert_eq!(from_str(\".e-1\"), Some(0.));\n+        assert_eq!(from_str(\"5.\"), Some(5.));\n+        assert_eq!(from_str(\".5\"), Some(0.5));\n+        assert_eq!(from_str(\"0.5\"), Some(0.5));\n+        assert_eq!(from_str(\"-.5\"), Some(-0.5));\n+        assert_eq!(from_str(\"-5\"), Some(-5.));\n+        assert_eq!(from_str(\"inf\"), Some(infinity));\n+        assert_eq!(from_str(\"+inf\"), Some(infinity));\n+        assert_eq!(from_str(\"-inf\"), Some(neg_infinity));\n         // note: NaN != NaN, hence this slightly complex test\n-        match from_str(~\"NaN\") {\n+        match from_str(\"NaN\") {\n             Some(f) => assert!(f.is_NaN()),\n             None => fail!()\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n-        match from_str(~\"-0\") {\n+        match from_str(\"-0\") {\n             Some(v) if v.is_zero() => assert!(v.is_negative()),\n             _ => fail!()\n         }\n-        match from_str(~\"0\") {\n+        match from_str(\"0\") {\n             Some(v) if v.is_zero() => assert!(v.is_positive()),\n             _ => fail!()\n         }\n \n-        assert!(from_str(~\"\").is_none());\n-        assert!(from_str(~\"x\").is_none());\n-        assert!(from_str(~\" \").is_none());\n-        assert!(from_str(~\"   \").is_none());\n-        assert!(from_str(~\"e\").is_none());\n-        assert!(from_str(~\"E\").is_none());\n-        assert!(from_str(~\"E1\").is_none());\n-        assert!(from_str(~\"1e1e1\").is_none());\n-        assert!(from_str(~\"1e1.1\").is_none());\n-        assert!(from_str(~\"1e1-1\").is_none());\n+        assert!(from_str(\"\").is_none());\n+        assert!(from_str(\"x\").is_none());\n+        assert!(from_str(\" \").is_none());\n+        assert!(from_str(\"   \").is_none());\n+        assert!(from_str(\"e\").is_none());\n+        assert!(from_str(\"E\").is_none());\n+        assert!(from_str(\"E1\").is_none());\n+        assert!(from_str(\"1e1e1\").is_none());\n+        assert!(from_str(\"1e1.1\").is_none());\n+        assert!(from_str(\"1e1-1\").is_none());\n     }\n \n     #[test]\n     pub fn test_from_str_hex() {\n-        assert_eq!(from_str_hex(~\"a4\"), Some(164.));\n-        assert_eq!(from_str_hex(~\"a4.fe\"), Some(164.9921875));\n-        assert_eq!(from_str_hex(~\"-a4.fe\"), Some(-164.9921875));\n-        assert_eq!(from_str_hex(~\"+a4.fe\"), Some(164.9921875));\n-        assert_eq!(from_str_hex(~\"ff0P4\"), Some(0xff00 as float));\n-        assert_eq!(from_str_hex(~\"ff0p4\"), Some(0xff00 as float));\n-        assert_eq!(from_str_hex(~\"ff0p-4\"), Some(0xff as float));\n-        assert_eq!(from_str_hex(~\".\"), Some(0.));\n-        assert_eq!(from_str_hex(~\".p1\"), Some(0.));\n-        assert_eq!(from_str_hex(~\".p-1\"), Some(0.));\n-        assert_eq!(from_str_hex(~\"f.\"), Some(15.));\n-        assert_eq!(from_str_hex(~\".f\"), Some(0.9375));\n-        assert_eq!(from_str_hex(~\"0.f\"), Some(0.9375));\n-        assert_eq!(from_str_hex(~\"-.f\"), Some(-0.9375));\n-        assert_eq!(from_str_hex(~\"-f\"), Some(-15.));\n-        assert_eq!(from_str_hex(~\"inf\"), Some(infinity));\n-        assert_eq!(from_str_hex(~\"+inf\"), Some(infinity));\n-        assert_eq!(from_str_hex(~\"-inf\"), Some(neg_infinity));\n+        assert_eq!(from_str_hex(\"a4\"), Some(164.));\n+        assert_eq!(from_str_hex(\"a4.fe\"), Some(164.9921875));\n+        assert_eq!(from_str_hex(\"-a4.fe\"), Some(-164.9921875));\n+        assert_eq!(from_str_hex(\"+a4.fe\"), Some(164.9921875));\n+        assert_eq!(from_str_hex(\"ff0P4\"), Some(0xff00 as float));\n+        assert_eq!(from_str_hex(\"ff0p4\"), Some(0xff00 as float));\n+        assert_eq!(from_str_hex(\"ff0p-4\"), Some(0xff as float));\n+        assert_eq!(from_str_hex(\".\"), Some(0.));\n+        assert_eq!(from_str_hex(\".p1\"), Some(0.));\n+        assert_eq!(from_str_hex(\".p-1\"), Some(0.));\n+        assert_eq!(from_str_hex(\"f.\"), Some(15.));\n+        assert_eq!(from_str_hex(\".f\"), Some(0.9375));\n+        assert_eq!(from_str_hex(\"0.f\"), Some(0.9375));\n+        assert_eq!(from_str_hex(\"-.f\"), Some(-0.9375));\n+        assert_eq!(from_str_hex(\"-f\"), Some(-15.));\n+        assert_eq!(from_str_hex(\"inf\"), Some(infinity));\n+        assert_eq!(from_str_hex(\"+inf\"), Some(infinity));\n+        assert_eq!(from_str_hex(\"-inf\"), Some(neg_infinity));\n         // note: NaN != NaN, hence this slightly complex test\n-        match from_str_hex(~\"NaN\") {\n+        match from_str_hex(\"NaN\") {\n             Some(f) => assert!(f.is_NaN()),\n             None => fail!()\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n-        match from_str_hex(~\"-0\") {\n+        match from_str_hex(\"-0\") {\n             Some(v) if v.is_zero() => assert!(v.is_negative()),\n             _ => fail!()\n         }\n-        match from_str_hex(~\"0\") {\n+        match from_str_hex(\"0\") {\n             Some(v) if v.is_zero() => assert!(v.is_positive()),\n             _ => fail!()\n         }\n-        assert_eq!(from_str_hex(~\"e\"), Some(14.));\n-        assert_eq!(from_str_hex(~\"E\"), Some(14.));\n-        assert_eq!(from_str_hex(~\"E1\"), Some(225.));\n-        assert_eq!(from_str_hex(~\"1e1e1\"), Some(123361.));\n-        assert_eq!(from_str_hex(~\"1e1.1\"), Some(481.0625));\n-\n-        assert!(from_str_hex(~\"\").is_none());\n-        assert!(from_str_hex(~\"x\").is_none());\n-        assert!(from_str_hex(~\" \").is_none());\n-        assert!(from_str_hex(~\"   \").is_none());\n-        assert!(from_str_hex(~\"p\").is_none());\n-        assert!(from_str_hex(~\"P\").is_none());\n-        assert!(from_str_hex(~\"P1\").is_none());\n-        assert!(from_str_hex(~\"1p1p1\").is_none());\n-        assert!(from_str_hex(~\"1p1.1\").is_none());\n-        assert!(from_str_hex(~\"1p1-1\").is_none());\n+        assert_eq!(from_str_hex(\"e\"), Some(14.));\n+        assert_eq!(from_str_hex(\"E\"), Some(14.));\n+        assert_eq!(from_str_hex(\"E1\"), Some(225.));\n+        assert_eq!(from_str_hex(\"1e1e1\"), Some(123361.));\n+        assert_eq!(from_str_hex(\"1e1.1\"), Some(481.0625));\n+\n+        assert!(from_str_hex(\"\").is_none());\n+        assert!(from_str_hex(\"x\").is_none());\n+        assert!(from_str_hex(\" \").is_none());\n+        assert!(from_str_hex(\"   \").is_none());\n+        assert!(from_str_hex(\"p\").is_none());\n+        assert!(from_str_hex(\"P\").is_none());\n+        assert!(from_str_hex(\"P1\").is_none());\n+        assert!(from_str_hex(\"1p1p1\").is_none());\n+        assert!(from_str_hex(\"1p1.1\").is_none());\n+        assert!(from_str_hex(\"1p1-1\").is_none());\n     }\n \n     #[test]\n@@ -1375,8 +1375,8 @@ mod tests {\n \n     #[test]\n     pub fn test_from_str_radix() {\n-        assert_eq!(from_str_radix(~\"10\", 36u), Some(36.));\n-        assert_eq!(from_str_radix(~\"1000.001\", 2u), Some(8.125));\n+        assert_eq!(from_str_radix(\"10\", 36u), Some(36.));\n+        assert_eq!(from_str_radix(\"1000.001\", 2u), Some(8.125));\n     }\n \n     #[test]"}, {"sha": "068f553ea6b5703c917e7f59e5bdb5a8bdd3312b", "filename": "src/libstd/num/int-template.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint-template.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -755,45 +755,45 @@ mod tests {\n \n     #[test]\n     fn test_from_str() {\n-        assert_eq!(from_str(~\"0\"), Some(0 as T));\n-        assert_eq!(from_str(~\"3\"), Some(3 as T));\n-        assert_eq!(from_str(~\"10\"), Some(10 as T));\n-        assert_eq!(i32::from_str(~\"123456789\"), Some(123456789 as i32));\n-        assert_eq!(from_str(~\"00100\"), Some(100 as T));\n+        assert_eq!(from_str(\"0\"), Some(0 as T));\n+        assert_eq!(from_str(\"3\"), Some(3 as T));\n+        assert_eq!(from_str(\"10\"), Some(10 as T));\n+        assert_eq!(i32::from_str(\"123456789\"), Some(123456789 as i32));\n+        assert_eq!(from_str(\"00100\"), Some(100 as T));\n \n-        assert_eq!(from_str(~\"-1\"), Some(-1 as T));\n-        assert_eq!(from_str(~\"-3\"), Some(-3 as T));\n-        assert_eq!(from_str(~\"-10\"), Some(-10 as T));\n-        assert_eq!(i32::from_str(~\"-123456789\"), Some(-123456789 as i32));\n-        assert_eq!(from_str(~\"-00100\"), Some(-100 as T));\n+        assert_eq!(from_str(\"-1\"), Some(-1 as T));\n+        assert_eq!(from_str(\"-3\"), Some(-3 as T));\n+        assert_eq!(from_str(\"-10\"), Some(-10 as T));\n+        assert_eq!(i32::from_str(\"-123456789\"), Some(-123456789 as i32));\n+        assert_eq!(from_str(\"-00100\"), Some(-100 as T));\n \n-        assert!(from_str(~\" \").is_none());\n-        assert!(from_str(~\"x\").is_none());\n+        assert!(from_str(\" \").is_none());\n+        assert!(from_str(\"x\").is_none());\n     }\n \n     #[test]\n     fn test_parse_bytes() {\n         use str::to_bytes;\n-        assert_eq!(parse_bytes(to_bytes(~\"123\"), 10u), Some(123 as T));\n-        assert_eq!(parse_bytes(to_bytes(~\"1001\"), 2u), Some(9 as T));\n-        assert_eq!(parse_bytes(to_bytes(~\"123\"), 8u), Some(83 as T));\n-        assert_eq!(i32::parse_bytes(to_bytes(~\"123\"), 16u), Some(291 as i32));\n-        assert_eq!(i32::parse_bytes(to_bytes(~\"ffff\"), 16u), Some(65535 as i32));\n-        assert_eq!(i32::parse_bytes(to_bytes(~\"FFFF\"), 16u), Some(65535 as i32));\n-        assert_eq!(parse_bytes(to_bytes(~\"z\"), 36u), Some(35 as T));\n-        assert_eq!(parse_bytes(to_bytes(~\"Z\"), 36u), Some(35 as T));\n-\n-        assert_eq!(parse_bytes(to_bytes(~\"-123\"), 10u), Some(-123 as T));\n-        assert_eq!(parse_bytes(to_bytes(~\"-1001\"), 2u), Some(-9 as T));\n-        assert_eq!(parse_bytes(to_bytes(~\"-123\"), 8u), Some(-83 as T));\n-        assert_eq!(i32::parse_bytes(to_bytes(~\"-123\"), 16u), Some(-291 as i32));\n-        assert_eq!(i32::parse_bytes(to_bytes(~\"-ffff\"), 16u), Some(-65535 as i32));\n-        assert_eq!(i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u), Some(-65535 as i32));\n-        assert_eq!(parse_bytes(to_bytes(~\"-z\"), 36u), Some(-35 as T));\n-        assert_eq!(parse_bytes(to_bytes(~\"-Z\"), 36u), Some(-35 as T));\n-\n-        assert!(parse_bytes(to_bytes(~\"Z\"), 35u).is_none());\n-        assert!(parse_bytes(to_bytes(~\"-9\"), 2u).is_none());\n+        assert_eq!(parse_bytes(to_bytes(\"123\"), 10u), Some(123 as T));\n+        assert_eq!(parse_bytes(to_bytes(\"1001\"), 2u), Some(9 as T));\n+        assert_eq!(parse_bytes(to_bytes(\"123\"), 8u), Some(83 as T));\n+        assert_eq!(i32::parse_bytes(to_bytes(\"123\"), 16u), Some(291 as i32));\n+        assert_eq!(i32::parse_bytes(to_bytes(\"ffff\"), 16u), Some(65535 as i32));\n+        assert_eq!(i32::parse_bytes(to_bytes(\"FFFF\"), 16u), Some(65535 as i32));\n+        assert_eq!(parse_bytes(to_bytes(\"z\"), 36u), Some(35 as T));\n+        assert_eq!(parse_bytes(to_bytes(\"Z\"), 36u), Some(35 as T));\n+\n+        assert_eq!(parse_bytes(to_bytes(\"-123\"), 10u), Some(-123 as T));\n+        assert_eq!(parse_bytes(to_bytes(\"-1001\"), 2u), Some(-9 as T));\n+        assert_eq!(parse_bytes(to_bytes(\"-123\"), 8u), Some(-83 as T));\n+        assert_eq!(i32::parse_bytes(to_bytes(\"-123\"), 16u), Some(-291 as i32));\n+        assert_eq!(i32::parse_bytes(to_bytes(\"-ffff\"), 16u), Some(-65535 as i32));\n+        assert_eq!(i32::parse_bytes(to_bytes(\"-FFFF\"), 16u), Some(-65535 as i32));\n+        assert_eq!(parse_bytes(to_bytes(\"-z\"), 36u), Some(-35 as T));\n+        assert_eq!(parse_bytes(to_bytes(\"-Z\"), 36u), Some(-35 as T));\n+\n+        assert!(parse_bytes(to_bytes(\"Z\"), 35u).is_none());\n+        assert!(parse_bytes(to_bytes(\"-9\"), 2u).is_none());\n     }\n \n     #[test]\n@@ -836,36 +836,36 @@ mod tests {\n     #[test]\n     fn test_int_from_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert_eq!(i8::from_str(~\"127\"), Some(i8_val));\n-        assert!(i8::from_str(~\"128\").is_none());\n+        assert_eq!(i8::from_str(\"127\"), Some(i8_val));\n+        assert!(i8::from_str(\"128\").is_none());\n \n         i8_val += 1 as i8;\n-        assert_eq!(i8::from_str(~\"-128\"), Some(i8_val));\n-        assert!(i8::from_str(~\"-129\").is_none());\n+        assert_eq!(i8::from_str(\"-128\"), Some(i8_val));\n+        assert!(i8::from_str(\"-129\").is_none());\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(i16::from_str(~\"32767\"), Some(i16_val));\n-        assert!(i16::from_str(~\"32768\").is_none());\n+        assert_eq!(i16::from_str(\"32767\"), Some(i16_val));\n+        assert!(i16::from_str(\"32768\").is_none());\n \n         i16_val += 1 as i16;\n-        assert_eq!(i16::from_str(~\"-32768\"), Some(i16_val));\n-        assert!(i16::from_str(~\"-32769\").is_none());\n+        assert_eq!(i16::from_str(\"-32768\"), Some(i16_val));\n+        assert!(i16::from_str(\"-32769\").is_none());\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(i32::from_str(~\"2147483647\"), Some(i32_val));\n-        assert!(i32::from_str(~\"2147483648\").is_none());\n+        assert_eq!(i32::from_str(\"2147483647\"), Some(i32_val));\n+        assert!(i32::from_str(\"2147483648\").is_none());\n \n         i32_val += 1 as i32;\n-        assert_eq!(i32::from_str(~\"-2147483648\"), Some(i32_val));\n-        assert!(i32::from_str(~\"-2147483649\").is_none());\n+        assert_eq!(i32::from_str(\"-2147483648\"), Some(i32_val));\n+        assert!(i32::from_str(\"-2147483649\").is_none());\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(i64::from_str(~\"9223372036854775807\"), Some(i64_val));\n-        assert!(i64::from_str(~\"9223372036854775808\").is_none());\n+        assert_eq!(i64::from_str(\"9223372036854775807\"), Some(i64_val));\n+        assert!(i64::from_str(\"9223372036854775808\").is_none());\n \n         i64_val += 1 as i64;\n-        assert_eq!(i64::from_str(~\"-9223372036854775808\"), Some(i64_val));\n-        assert!(i64::from_str(~\"-9223372036854775809\").is_none());\n+        assert_eq!(i64::from_str(\"-9223372036854775808\"), Some(i64_val));\n+        assert!(i64::from_str(\"-9223372036854775809\").is_none());\n     }\n \n     #[test]"}, {"sha": "9784fe24206c30ca8acc3ea8befe5d9debf9b68e", "filename": "src/libstd/num/uint-template.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint-template.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -472,29 +472,29 @@ mod tests {\n \n     #[test]\n     pub fn test_from_str() {\n-        assert_eq!(from_str(~\"0\"), Some(0u as T));\n-        assert_eq!(from_str(~\"3\"), Some(3u as T));\n-        assert_eq!(from_str(~\"10\"), Some(10u as T));\n-        assert_eq!(u32::from_str(~\"123456789\"), Some(123456789 as u32));\n-        assert_eq!(from_str(~\"00100\"), Some(100u as T));\n+        assert_eq!(from_str(\"0\"), Some(0u as T));\n+        assert_eq!(from_str(\"3\"), Some(3u as T));\n+        assert_eq!(from_str(\"10\"), Some(10u as T));\n+        assert_eq!(u32::from_str(\"123456789\"), Some(123456789 as u32));\n+        assert_eq!(from_str(\"00100\"), Some(100u as T));\n \n-        assert!(from_str(~\"\").is_none());\n-        assert!(from_str(~\" \").is_none());\n-        assert!(from_str(~\"x\").is_none());\n+        assert!(from_str(\"\").is_none());\n+        assert!(from_str(\" \").is_none());\n+        assert!(from_str(\"x\").is_none());\n     }\n \n     #[test]\n     pub fn test_parse_bytes() {\n         use str::to_bytes;\n-        assert_eq!(parse_bytes(to_bytes(~\"123\"), 10u), Some(123u as T));\n-        assert_eq!(parse_bytes(to_bytes(~\"1001\"), 2u), Some(9u as T));\n-        assert_eq!(parse_bytes(to_bytes(~\"123\"), 8u), Some(83u as T));\n-        assert_eq!(u16::parse_bytes(to_bytes(~\"123\"), 16u), Some(291u as u16));\n-        assert_eq!(u16::parse_bytes(to_bytes(~\"ffff\"), 16u), Some(65535u as u16));\n-        assert_eq!(parse_bytes(to_bytes(~\"z\"), 36u), Some(35u as T));\n+        assert_eq!(parse_bytes(to_bytes(\"123\"), 10u), Some(123u as T));\n+        assert_eq!(parse_bytes(to_bytes(\"1001\"), 2u), Some(9u as T));\n+        assert_eq!(parse_bytes(to_bytes(\"123\"), 8u), Some(83u as T));\n+        assert_eq!(u16::parse_bytes(to_bytes(\"123\"), 16u), Some(291u as u16));\n+        assert_eq!(u16::parse_bytes(to_bytes(\"ffff\"), 16u), Some(65535u as u16));\n+        assert_eq!(parse_bytes(to_bytes(\"z\"), 36u), Some(35u as T));\n \n-        assert!(parse_bytes(to_bytes(~\"Z\"), 10u).is_none());\n-        assert!(parse_bytes(to_bytes(~\"_\"), 2u).is_none());\n+        assert!(parse_bytes(to_bytes(\"Z\"), 10u).is_none());\n+        assert!(parse_bytes(to_bytes(\"_\"), 2u).is_none());\n     }\n \n     #[test]\n@@ -527,36 +527,36 @@ mod tests {\n     #[test]\n     fn test_uint_from_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n-        assert_eq!(u8::from_str(~\"255\"), Some(u8_val));\n-        assert!(u8::from_str(~\"256\").is_none());\n+        assert_eq!(u8::from_str(\"255\"), Some(u8_val));\n+        assert!(u8::from_str(\"256\").is_none());\n \n         u8_val += 1 as u8;\n-        assert_eq!(u8::from_str(~\"0\"), Some(u8_val));\n-        assert!(u8::from_str(~\"-1\").is_none());\n+        assert_eq!(u8::from_str(\"0\"), Some(u8_val));\n+        assert!(u8::from_str(\"-1\").is_none());\n \n         let mut u16_val: u16 = 65_535_u16;\n-        assert_eq!(u16::from_str(~\"65535\"), Some(u16_val));\n-        assert!(u16::from_str(~\"65536\").is_none());\n+        assert_eq!(u16::from_str(\"65535\"), Some(u16_val));\n+        assert!(u16::from_str(\"65536\").is_none());\n \n         u16_val += 1 as u16;\n-        assert_eq!(u16::from_str(~\"0\"), Some(u16_val));\n-        assert!(u16::from_str(~\"-1\").is_none());\n+        assert_eq!(u16::from_str(\"0\"), Some(u16_val));\n+        assert!(u16::from_str(\"-1\").is_none());\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert_eq!(u32::from_str(~\"4294967295\"), Some(u32_val));\n-        assert!(u32::from_str(~\"4294967296\").is_none());\n+        assert_eq!(u32::from_str(\"4294967295\"), Some(u32_val));\n+        assert!(u32::from_str(\"4294967296\").is_none());\n \n         u32_val += 1 as u32;\n-        assert_eq!(u32::from_str(~\"0\"), Some(u32_val));\n-        assert!(u32::from_str(~\"-1\").is_none());\n+        assert_eq!(u32::from_str(\"0\"), Some(u32_val));\n+        assert!(u32::from_str(\"-1\").is_none());\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert_eq!(u64::from_str(~\"18446744073709551615\"), Some(u64_val));\n-        assert!(u64::from_str(~\"18446744073709551616\").is_none());\n+        assert_eq!(u64::from_str(\"18446744073709551615\"), Some(u64_val));\n+        assert!(u64::from_str(\"18446744073709551616\").is_none());\n \n         u64_val += 1 as u64;\n-        assert_eq!(u64::from_str(~\"0\"), Some(u64_val));\n-        assert!(u64::from_str(~\"-1\").is_none());\n+        assert_eq!(u64::from_str(\"0\"), Some(u64_val));\n+        assert!(u64::from_str(\"-1\").is_none());\n     }\n \n     #[test]"}, {"sha": "a82f1c9891696c3df23660e423e0d64b0b9bc5ea", "filename": "src/libstd/os.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -1444,14 +1444,14 @@ mod tests {\n     #[test]\n     fn test_setenv() {\n         let n = make_rand_name();\n-        setenv(n, ~\"VALUE\");\n+        setenv(n, \"VALUE\");\n         assert_eq!(getenv(n), option::Some(~\"VALUE\"));\n     }\n \n     #[test]\n     fn test_unsetenv() {\n         let n = make_rand_name();\n-        setenv(n, ~\"VALUE\");\n+        setenv(n, \"VALUE\");\n         unsetenv(n);\n         assert_eq!(getenv(n), option::None);\n     }\n@@ -1461,10 +1461,10 @@ mod tests {\n     #[ignore]\n     fn test_setenv_overwrite() {\n         let n = make_rand_name();\n-        setenv(n, ~\"1\");\n-        setenv(n, ~\"2\");\n+        setenv(n, \"1\");\n+        setenv(n, \"2\");\n         assert_eq!(getenv(n), option::Some(~\"2\"));\n-        setenv(n, ~\"\");\n+        setenv(n, \"\");\n         assert_eq!(getenv(n), option::Some(~\"\"));\n     }\n \n@@ -1515,7 +1515,7 @@ mod tests {\n         let n = make_rand_name();\n \n         let mut e = env();\n-        setenv(n, ~\"VALUE\");\n+        setenv(n, \"VALUE\");\n         assert!(!vec::contains(e, &(copy n, ~\"VALUE\")));\n \n         e = env();\n@@ -1526,7 +1526,7 @@ mod tests {\n     fn test() {\n         assert!((!Path(\"test-path\").is_absolute));\n \n-        debug!(~\"Current working directory: \" + getcwd().to_str());\n+        debug!(\"Current working directory: %s\", getcwd().to_str());\n \n         debug!(make_absolute(&Path(\"test-path\")));\n         debug!(make_absolute(&Path(\"/usr/bin\")));\n@@ -1535,43 +1535,43 @@ mod tests {\n     #[test]\n     #[cfg(unix)]\n     fn homedir() {\n-        let oldhome = getenv(~\"HOME\");\n+        let oldhome = getenv(\"HOME\");\n \n-        setenv(~\"HOME\", ~\"/home/MountainView\");\n+        setenv(\"HOME\", \"/home/MountainView\");\n         assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n \n-        setenv(~\"HOME\", ~\"\");\n+        setenv(\"HOME\", \"\");\n         assert!(os::homedir().is_none());\n \n-        for oldhome.each |s| { setenv(~\"HOME\", *s) }\n+        for oldhome.each |s| { setenv(\"HOME\", *s) }\n     }\n \n     #[test]\n     #[cfg(windows)]\n     fn homedir() {\n \n-        let oldhome = getenv(~\"HOME\");\n-        let olduserprofile = getenv(~\"USERPROFILE\");\n+        let oldhome = getenv(\"HOME\");\n+        let olduserprofile = getenv(\"USERPROFILE\");\n \n-        setenv(~\"HOME\", ~\"\");\n-        setenv(~\"USERPROFILE\", ~\"\");\n+        setenv(\"HOME\", \"\");\n+        setenv(\"USERPROFILE\", \"\");\n \n         assert!(os::homedir().is_none());\n \n-        setenv(~\"HOME\", ~\"/home/MountainView\");\n+        setenv(\"HOME\", \"/home/MountainView\");\n         assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n \n-        setenv(~\"HOME\", ~\"\");\n+        setenv(\"HOME\", \"\");\n \n-        setenv(~\"USERPROFILE\", ~\"/home/MountainView\");\n+        setenv(\"USERPROFILE\", \"/home/MountainView\");\n         assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n \n-        setenv(~\"HOME\", ~\"/home/MountainView\");\n-        setenv(~\"USERPROFILE\", ~\"/home/PaloAlto\");\n+        setenv(\"HOME\", \"/home/MountainView\");\n+        setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n         assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n \n-        oldhome.each(|s| {setenv(~\"HOME\", *s);true});\n-        olduserprofile.each(|s| {setenv(~\"USERPROFILE\", *s);true});\n+        oldhome.each(|s| { setenv(\"HOME\", *s); true });\n+        olduserprofile.each(|s| { setenv(\"USERPROFILE\", *s); true });\n     }\n \n     #[test]\n@@ -1646,7 +1646,7 @@ mod tests {\n             fail!(\"%s doesn't exist\", in.to_str());\n           }\n           assert!((rs));\n-          let rslt = run::run_program(~\"diff\", ~[in.to_str(), out.to_str()]);\n+          let rslt = run::run_program(\"diff\", [in.to_str(), out.to_str()]);\n           assert_eq!(rslt, 0);\n           assert_eq!(out.get_mode(), in_mode);\n           assert!((remove_file(&in)));"}, {"sha": "09d0a38e16d4908996fb1fa7f4ea591cc7b45d74", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -988,10 +988,10 @@ mod tests {\n     #[test]\n     fn test_choose_weighted() {\n         let mut r = rng();\n-        assert!(r.choose_weighted(~[\n+        assert!(r.choose_weighted([\n             Weighted { weight: 1u, item: 42 },\n         ]) == 42);\n-        assert!(r.choose_weighted(~[\n+        assert!(r.choose_weighted([\n             Weighted { weight: 0u, item: 42 },\n             Weighted { weight: 1u, item: 43 },\n         ]) == 43);\n@@ -1000,10 +1000,10 @@ mod tests {\n     #[test]\n     fn test_choose_weighted_option() {\n         let mut r = rng();\n-        assert!(r.choose_weighted_option(~[\n+        assert!(r.choose_weighted_option([\n             Weighted { weight: 1u, item: 42 },\n         ]) == Some(42));\n-        assert!(r.choose_weighted_option(~[\n+        assert!(r.choose_weighted_option([\n             Weighted { weight: 0u, item: 42 },\n             Weighted { weight: 1u, item: 43 },\n         ]) == Some(43));\n@@ -1015,8 +1015,8 @@ mod tests {\n     fn test_weighted_vec() {\n         let mut r = rng();\n         let empty: ~[int] = ~[];\n-        assert_eq!(r.weighted_vec(~[]), empty);\n-        assert!(r.weighted_vec(~[\n+        assert_eq!(r.weighted_vec([]), empty);\n+        assert!(r.weighted_vec([\n             Weighted { weight: 0u, item: 3u },\n             Weighted { weight: 1u, item: 2u },\n             Weighted { weight: 2u, item: 1u },\n@@ -1027,15 +1027,15 @@ mod tests {\n     fn test_shuffle() {\n         let mut r = rng();\n         let empty: ~[int] = ~[];\n-        assert_eq!(r.shuffle(~[]), empty);\n-        assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n+        assert_eq!(r.shuffle([]), empty);\n+        assert_eq!(r.shuffle([1, 1, 1]), ~[1, 1, 1]);\n     }\n \n     #[test]\n     fn test_task_rng() {\n         let mut r = task_rng();\n         r.gen::<int>();\n-        assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n+        assert_eq!(r.shuffle([1, 1, 1]), ~[1, 1, 1]);\n         assert_eq!(r.gen_uint_range(0u, 1u), 0u);\n     }\n "}, {"sha": "54db03b6069c26b573b6ed0ff41fce678b2c22ba", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -474,7 +474,7 @@ mod test {\n     #[test]\n     fn oneshot_single_thread_peek_open() {\n         do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n+            let (port, _) = oneshot::<int>();\n             assert!(!port.peek());\n         }\n     }"}, {"sha": "fcbf31e87f2c02867e3f54577475a36b8ce0b6c4", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -587,12 +587,10 @@ fn extend_sign(val: u64, nbytes: uint) -> i64 {\n \n #[cfg(test)]\n mod test {\n-    use super::{ReaderUtil, ReaderByteConversions, WriterByteConversions};\n-    use u64;\n-    use i32;\n+    use super::ReaderUtil;\n     use option::{Some, None};\n     use cell::Cell;\n-    use rt::io::mem::{MemReader, MemWriter};\n+    use rt::io::mem::MemReader;\n     use rt::io::mock::MockReader;\n     use rt::io::{read_error, placeholder_error};\n "}, {"sha": "313123c38b58d8a10367c45d5403c44a62531d23", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -33,7 +33,7 @@ impl Local for Scheduler {\n }\n \n impl Local for Task {\n-    fn put(value: ~Task) { abort!(\"unimpl\") }\n+    fn put(_value: ~Task) { abort!(\"unimpl\") }\n     fn take() -> ~Task { abort!(\"unimpl\") }\n     fn exists() -> bool { abort!(\"unimpl\") }\n     fn borrow(f: &fn(&mut Task)) {\n@@ -71,10 +71,10 @@ impl Local for Task {\n \n // XXX: This formulation won't work once ~IoFactoryObject is a real trait pointer\n impl Local for IoFactoryObject {\n-    fn put(value: ~IoFactoryObject) { abort!(\"unimpl\") }\n+    fn put(_value: ~IoFactoryObject) { abort!(\"unimpl\") }\n     fn take() -> ~IoFactoryObject { abort!(\"unimpl\") }\n     fn exists() -> bool { abort!(\"unimpl\") }\n-    fn borrow(f: &fn(&mut IoFactoryObject)) { abort!(\"unimpl\") }\n+    fn borrow(_f: &fn(&mut IoFactoryObject)) { abort!(\"unimpl\") }\n     unsafe fn unsafe_borrow() -> *mut IoFactoryObject {\n         let sched = Local::unsafe_borrow::<Scheduler>();\n         let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n@@ -115,4 +115,4 @@ mod test {\n         }\n         let _scheduler: ~Scheduler = Local::take();\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "2d9cdaddc8433db2a48e94b8c27c17630e8497fc", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -20,7 +20,6 @@ use super::context::Context;\n use super::task::Task;\n use rt::local_ptr;\n use rt::local::Local;\n-use rt::rtio::IoFactoryObject;\n \n /// The Scheduler is responsible for coordinating execution of Coroutines\n /// on a single thread. When the scheduler is running it is owned by"}, {"sha": "cf4967b12b304f5f5950d36f8e277a3a8f216307", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -16,7 +16,6 @@\n use prelude::*;\n use libc::{c_void, uintptr_t};\n use cast::transmute;\n-use super::sched::Scheduler;\n use rt::local::Local;\n use super::local_heap::LocalHeap;\n use rt::logging::StdErrLogger;"}, {"sha": "3dae1291e0315022138b4967b52db972a268f828", "filename": "src/libstd/str.rs", "status": "modified", "additions": 269, "deletions": 276, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -2794,31 +2794,31 @@ mod tests {\n \n     #[test]\n     fn test_len() {\n-        assert_eq!(len(~\"\"), 0u);\n-        assert_eq!(len(~\"hello world\"), 11u);\n-        assert_eq!(len(~\"\\x63\"), 1u);\n-        assert_eq!(len(~\"\\xa2\"), 2u);\n-        assert_eq!(len(~\"\\u03c0\"), 2u);\n-        assert_eq!(len(~\"\\u2620\"), 3u);\n-        assert_eq!(len(~\"\\U0001d11e\"), 4u);\n+        assert_eq!(len(\"\"), 0u);\n+        assert_eq!(len(\"hello world\"), 11u);\n+        assert_eq!(len(\"\\x63\"), 1u);\n+        assert_eq!(len(\"\\xa2\"), 2u);\n+        assert_eq!(len(\"\\u03c0\"), 2u);\n+        assert_eq!(len(\"\\u2620\"), 3u);\n+        assert_eq!(len(\"\\U0001d11e\"), 4u);\n \n-        assert_eq!(char_len(~\"\"), 0u);\n-        assert_eq!(char_len(~\"hello world\"), 11u);\n-        assert_eq!(char_len(~\"\\x63\"), 1u);\n-        assert_eq!(char_len(~\"\\xa2\"), 1u);\n-        assert_eq!(char_len(~\"\\u03c0\"), 1u);\n-        assert_eq!(char_len(~\"\\u2620\"), 1u);\n-        assert_eq!(char_len(~\"\\U0001d11e\"), 1u);\n-        assert_eq!(char_len(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"), 19u);\n+        assert_eq!(char_len(\"\"), 0u);\n+        assert_eq!(char_len(\"hello world\"), 11u);\n+        assert_eq!(char_len(\"\\x63\"), 1u);\n+        assert_eq!(char_len(\"\\xa2\"), 1u);\n+        assert_eq!(char_len(\"\\u03c0\"), 1u);\n+        assert_eq!(char_len(\"\\u2620\"), 1u);\n+        assert_eq!(char_len(\"\\U0001d11e\"), 1u);\n+        assert_eq!(char_len(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"), 19u);\n     }\n \n     #[test]\n     fn test_rfind_char() {\n-        assert_eq!(rfind_char(~\"hello\", 'l'), Some(3u));\n-        assert_eq!(rfind_char(~\"hello\", 'o'), Some(4u));\n-        assert_eq!(rfind_char(~\"hello\", 'h'), Some(0u));\n-        assert!(rfind_char(~\"hello\", 'z').is_none());\n-        assert_eq!(rfind_char(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e'), Some(30u));\n+        assert_eq!(rfind_char(\"hello\", 'l'), Some(3u));\n+        assert_eq!(rfind_char(\"hello\", 'o'), Some(4u));\n+        assert_eq!(rfind_char(\"hello\", 'h'), Some(0u));\n+        assert!(rfind_char(\"hello\", 'z').is_none());\n+        assert_eq!(rfind_char(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e'), Some(30u));\n     }\n \n     #[test]\n@@ -2848,127 +2848,126 @@ mod tests {\n     #[test]\n     fn test_split_char() {\n         fn t(s: &str, c: char, u: &[~str]) {\n-            debug!(~\"split_byte: \" + s);\n+            debug!(\"split_byte: %?\", s);\n             let mut v = ~[];\n             for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n-        t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n-        t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n-        t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n+        t(\"abc.hello.there\", '.', [~\"abc\", ~\"hello\", ~\"there\"]);\n+        t(\".hello.there\", '.', [~\"\", ~\"hello\", ~\"there\"]);\n+        t(\"...hello.there.\", '.', [~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n \n-        t(~\"\", 'z', ~[~\"\"]);\n-        t(~\"z\", 'z', ~[~\"\",~\"\"]);\n-        t(~\"ok\", 'z', ~[~\"ok\"]);\n+        t(\"\", 'z', [~\"\"]);\n+        t(\"z\", 'z', [~\"\",~\"\"]);\n+        t(\"ok\", 'z', [~\"ok\"]);\n     }\n \n     #[test]\n     fn test_split_char_2() {\n         fn t(s: &str, c: char, u: &[~str]) {\n-            debug!(~\"split_byte: \" + s);\n+            debug!(\"split_byte: %?\", s);\n             let mut v = ~[];\n             for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        t(data, 'V', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n-        t(data, '\u0e17', ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        t(data, 'V', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n+        t(data, '\u0e17', [~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n     }\n \n     #[test]\n     fn test_splitn_char() {\n         fn t(s: &str, c: char, n: uint, u: &[~str]) {\n-            debug!(~\"splitn_byte: \" + s);\n+            debug!(\"splitn_byte: %?\", s);\n             let mut v = ~[];\n             for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n-        t(~\"abc.hello.there\", '.', 0u, ~[~\"abc.hello.there\"]);\n-        t(~\"abc.hello.there\", '.', 1u, ~[~\"abc\", ~\"hello.there\"]);\n-        t(~\"abc.hello.there\", '.', 2u, ~[~\"abc\", ~\"hello\", ~\"there\"]);\n-        t(~\"abc.hello.there\", '.', 3u, ~[~\"abc\", ~\"hello\", ~\"there\"]);\n-        t(~\".hello.there\", '.', 0u, ~[~\".hello.there\"]);\n-        t(~\".hello.there\", '.', 1u, ~[~\"\", ~\"hello.there\"]);\n-        t(~\"...hello.there.\", '.', 3u, ~[~\"\", ~\"\", ~\"\", ~\"hello.there.\"]);\n-        t(~\"...hello.there.\", '.', 5u, ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n+        t(\"abc.hello.there\", '.', 0u, [~\"abc.hello.there\"]);\n+        t(\"abc.hello.there\", '.', 1u, [~\"abc\", ~\"hello.there\"]);\n+        t(\"abc.hello.there\", '.', 2u, [~\"abc\", ~\"hello\", ~\"there\"]);\n+        t(\"abc.hello.there\", '.', 3u, [~\"abc\", ~\"hello\", ~\"there\"]);\n+        t(\".hello.there\", '.', 0u, [~\".hello.there\"]);\n+        t(\".hello.there\", '.', 1u, [~\"\", ~\"hello.there\"]);\n+        t(\"...hello.there.\", '.', 3u, [~\"\", ~\"\", ~\"\", ~\"hello.there.\"]);\n+        t(\"...hello.there.\", '.', 5u, [~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n \n-        t(~\"\", 'z', 5u, ~[~\"\"]);\n-        t(~\"z\", 'z', 5u, ~[~\"\",~\"\"]);\n-        t(~\"ok\", 'z', 5u, ~[~\"ok\"]);\n-        t(~\"z\", 'z', 0u, ~[~\"z\"]);\n-        t(~\"w.x.y\", '.', 0u, ~[~\"w.x.y\"]);\n-        t(~\"w.x.y\", '.', 1u, ~[~\"w\",~\"x.y\"]);\n+        t(\"\", 'z', 5u, [~\"\"]);\n+        t(\"z\", 'z', 5u, [~\"\",~\"\"]);\n+        t(\"ok\", 'z', 5u, [~\"ok\"]);\n+        t(\"z\", 'z', 0u, [~\"z\"]);\n+        t(\"w.x.y\", '.', 0u, [~\"w.x.y\"]);\n+        t(\"w.x.y\", '.', 1u, [~\"w\",~\"x.y\"]);\n     }\n \n     #[test]\n-    fn test_splitn_char_2 () {\n+    fn test_splitn_char_2() {\n         fn t(s: &str, c: char, n: uint, u: &[~str]) {\n-            debug!(~\"splitn_byte: \" + s);\n+            debug!(\"splitn_byte: %?\", s);\n             let mut v = ~[];\n             for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n \n-        t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e', 1u, ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n-        t(~\"zzXXXzYYYzWWWz\", 'z', 3u, ~[~\"\", ~\"\", ~\"XXX\", ~\"YYYzWWWz\"]);\n-        t(~\"z\", 'z', 5u, ~[~\"\",~\"\"]);\n-        t(~\"\", 'z', 5u, ~[~\"\"]);\n-        t(~\"ok\", 'z', 5u, ~[~\"ok\"]);\n+        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e', 1u, [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n+        t(\"zzXXXzYYYzWWWz\", 'z', 3u, [~\"\", ~\"\", ~\"XXX\", ~\"YYYzWWWz\"]);\n+        t(\"z\", 'z', 5u, [~\"\",~\"\"]);\n+        t(\"\", 'z', 5u, [~\"\"]);\n+        t(\"ok\", 'z', 5u, [~\"ok\"]);\n     }\n \n-\n     #[test]\n     fn test_splitn_char_3() {\n         fn t(s: &str, c: char, n: uint, u: &[~str]) {\n-            debug!(~\"splitn_byte: \" + s);\n+            debug!(\"splitn_byte: %?\", s);\n             let mut v = ~[];\n             for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        t(data, 'V', 1u, ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n-        t(data, '\u0e17', 1u, ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        t(data, 'V', 1u, [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n+        t(data, '\u0e17', 1u, [~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n     }\n \n     #[test]\n     fn test_split_char_no_trailing() {\n         fn t(s: &str, c: char, u: &[~str]) {\n-            debug!(~\"split_byte: \" + s);\n+            debug!(\"split_byte: %?\", s);\n             let mut v = ~[];\n             for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n-        t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n-        t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n-        t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]);\n+        t(\"abc.hello.there\", '.', [~\"abc\", ~\"hello\", ~\"there\"]);\n+        t(\".hello.there\", '.', [~\"\", ~\"hello\", ~\"there\"]);\n+        t(\"...hello.there.\", '.', [~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]);\n \n-        t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]);\n-        t(~\"\", 'z', ~[]);\n-        t(~\"z\", 'z', ~[~\"\"]);\n-        t(~\"ok\", 'z', ~[~\"ok\"]);\n+        t(\"...hello.there.\", '.', [~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]);\n+        t(\"\", 'z', []);\n+        t(\"z\", 'z', [~\"\"]);\n+        t(\"ok\", 'z', [~\"ok\"]);\n     }\n \n     #[test]\n     fn test_split_char_no_trailing_2() {\n         fn t(s: &str, c: char, u: &[~str]) {\n-            debug!(~\"split_byte: \" + s);\n+            debug!(\"split_byte: %?\", s);\n             let mut v = ~[];\n             for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        t(data, 'V', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n-        t(data, '\u0e17', ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        t(data, 'V', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n+        t(data, '\u0e17', [~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n     }\n \n     #[test]\n@@ -2978,20 +2977,20 @@ mod tests {\n             for each_split_str(s, sep) |s| { v.push(s.to_owned()) }\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n-        t(~\"--1233345--\", ~\"12345\", ~[~\"--1233345--\"]);\n-        t(~\"abc::hello::there\", ~\"::\", ~[~\"abc\", ~\"hello\", ~\"there\"]);\n-        t(~\"::hello::there\", ~\"::\", ~[~\"\", ~\"hello\", ~\"there\"]);\n-        t(~\"hello::there::\", ~\"::\", ~[~\"hello\", ~\"there\", ~\"\"]);\n-        t(~\"::hello::there::\", ~\"::\", ~[~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n-        t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", ~\"\u4e2d\u534e\", ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", ~\"Vi\u1ec7t Nam\"]);\n-        t(~\"zzXXXzzYYYzz\", ~\"zz\", ~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n-        t(~\"zzXXXzYYYz\", ~\"XXX\", ~[~\"zz\", ~\"zYYYz\"]);\n-        t(~\".XXX.YYY.\", ~\".\", ~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n-        t(~\"\", ~\".\", ~[~\"\"]);\n-        t(~\"zz\", ~\"zz\", ~[~\"\",~\"\"]);\n-        t(~\"ok\", ~\"z\", ~[~\"ok\"]);\n-        t(~\"zzz\", ~\"zz\", ~[~\"\",~\"z\"]);\n-        t(~\"zzzzz\", ~\"zz\", ~[~\"\",~\"\",~\"z\"]);\n+        t(\"--1233345--\", \"12345\", [~\"--1233345--\"]);\n+        t(\"abc::hello::there\", \"::\", [~\"abc\", ~\"hello\", ~\"there\"]);\n+        t(\"::hello::there\", \"::\", [~\"\", ~\"hello\", ~\"there\"]);\n+        t(\"hello::there::\", \"::\", [~\"hello\", ~\"there\", ~\"\"]);\n+        t(\"::hello::there::\", \"::\", [~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n+        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", ~\"Vi\u1ec7t Nam\"]);\n+        t(\"zzXXXzzYYYzz\", \"zz\", [~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n+        t(\"zzXXXzYYYz\", \"XXX\", [~\"zz\", ~\"zYYYz\"]);\n+        t(\".XXX.YYY.\", \".\", [~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n+        t(\"\", \".\", [~\"\"]);\n+        t(\"zz\", \"zz\", [~\"\",~\"\"]);\n+        t(\"ok\", \"z\", [~\"ok\"]);\n+        t(\"zzz\", \"zz\", [~\"\",~\"z\"]);\n+        t(\"zzzzz\", \"zz\", [~\"\",~\"\",~\"z\"]);\n     }\n \n \n@@ -3003,12 +3002,12 @@ mod tests {\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n \n-        t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n-        t(~\"zzXXXzYYYz\", char::is_lowercase, ~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n-        t(~\"zzXXXzYYYz\", char::is_uppercase, ~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]);\n-        t(~\"z\", |cc| cc == 'z', ~[~\"\",~\"\"]);\n-        t(~\"\", |cc| cc == 'z', ~[~\"\"]);\n-        t(~\"ok\", |cc| cc == 'z', ~[~\"ok\"]);\n+        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n+        t(\"zzXXXzYYYz\", char::is_lowercase, [~\"\", ~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n+        t(\"zzXXXzYYYz\", char::is_uppercase, [~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]);\n+        t(\"z\", |cc| cc == 'z', [~\"\",~\"\"]);\n+        t(\"\", |cc| cc == 'z', [~\"\"]);\n+        t(\"ok\", |cc| cc == 'z', [~\"ok\"]);\n     }\n \n     #[test]\n@@ -3019,49 +3018,49 @@ mod tests {\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n \n-        t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n-        t(~\"zzXXXzYYYz\", char::is_lowercase, ~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\"]);\n-        t(~\"zzXXXzYYYz\", char::is_uppercase, ~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]);\n-        t(~\"z\", |cc| cc == 'z', ~[~\"\"]);\n-        t(~\"\", |cc| cc == 'z', ~[]);\n-        t(~\"ok\", |cc| cc == 'z', ~[~\"ok\"]);\n+        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n+        t(\"zzXXXzYYYz\", char::is_lowercase, [~\"\", ~\"\", ~\"XXX\", ~\"YYY\"]);\n+        t(\"zzXXXzYYYz\", char::is_uppercase, [~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]);\n+        t(\"z\", |cc| cc == 'z', [~\"\"]);\n+        t(\"\", |cc| cc == 'z', []);\n+        t(\"ok\", |cc| cc == 'z', [~\"ok\"]);\n     }\n \n     #[test]\n     fn test_lines() {\n-        let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n-        let crlf = ~\"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n+        let lf = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        let crlf = \"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n \n         fn t(s: &str, f: &fn(&str, &fn(&str) -> bool) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for f(s) |s| { v.push(s.to_owned()) }\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n \n-        t(lf, each_line ,~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n-        t(lf, each_line_any, ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n-        t(crlf, each_line, ~[~\"\\r\", ~\"Mary had a little lamb\\r\", ~\"Little lamb\\r\"]);\n-        t(crlf, each_line_any, ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n-        t(~\"\", each_line, ~[]);\n-        t(~\"\", each_line_any, ~[]);\n-        t(~\"\\n\", each_line, ~[~\"\"]);\n-        t(~\"\\n\", each_line_any, ~[~\"\"]);\n-        t(~\"banana\", each_line, ~[~\"banana\"]);\n-        t(~\"banana\", each_line_any, ~[~\"banana\"]);\n+        t(lf, each_line, [~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n+        t(lf, each_line_any, [~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n+        t(crlf, each_line, [~\"\\r\", ~\"Mary had a little lamb\\r\", ~\"Little lamb\\r\"]);\n+        t(crlf, each_line_any, [~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n+        t(\"\", each_line, []);\n+        t(\"\", each_line_any, []);\n+        t(\"\\n\", each_line, [~\"\"]);\n+        t(\"\\n\", each_line_any, [~\"\"]);\n+        t(\"banana\", each_line, [~\"banana\"]);\n+        t(\"banana\", each_line_any, [~\"banana\"]);\n     }\n \n     #[test]\n-    fn test_words () {\n+    fn test_words() {\n         fn t(s: &str, f: &fn(&str, &fn(&str) -> bool) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for f(s) |s| { v.push(s.to_owned()) }\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n-        let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n-        t(data, each_word, ~[~\"Mary\",~\"had\",~\"a\",~\"little\",~\"lamb\",~\"Little\",~\"lamb\"]);\n-        t(~\"ok\", each_word, ~[~\"ok\"]);\n-        t(~\"\", each_word, ~[]);\n+        t(data, each_word, [~\"Mary\",~\"had\",~\"a\",~\"little\",~\"lamb\",~\"Little\",~\"lamb\"]);\n+        t(\"ok\", each_word, [~\"ok\"]);\n+        t(\"\", each_word, []);\n     }\n \n     #[test]\n@@ -3071,53 +3070,53 @@ mod tests {\n             for each_split_within(s, i) |s| { v.push(s.to_owned()) }\n             assert!(vec::all2(v, u, |a,b| a == b));\n         }\n-        t(~\"\", 0, ~[]);\n-        t(~\"\", 15, ~[]);\n-        t(~\"hello\", 15, ~[~\"hello\"]);\n-        t(~\"\\nMary had a little lamb\\nLittle lamb\\n\", 15,\n-            ~[~\"Mary had a\", ~\"little lamb\", ~\"Little lamb\"]);\n+        t(\"\", 0, []);\n+        t(\"\", 15, []);\n+        t(\"hello\", 15, [~\"hello\"]);\n+        t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15,\n+            [~\"Mary had a\", ~\"little lamb\", ~\"Little lamb\"]);\n     }\n \n     #[test]\n     fn test_find_str() {\n         // byte positions\n-        assert!(find_str(~\"banana\", ~\"apple pie\").is_none());\n-        assert_eq!(find_str(~\"\", ~\"\"), Some(0u));\n+        assert!(find_str(\"banana\", \"apple pie\").is_none());\n+        assert_eq!(find_str(\"\", \"\"), Some(0u));\n \n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert_eq!(find_str(data, ~\"\"), Some(0u));\n-        assert_eq!(find_str(data, ~\"\u0e1b\u0e23\u0e30\u0e40\"), Some( 0u));\n-        assert_eq!(find_str(data, ~\"\u0e30\u0e40\"), Some( 6u));\n-        assert_eq!(find_str(data, ~\"\u4e2d\u534e\"), Some(27u));\n-        assert!(find_str(data, ~\"\u0e44\u0e17\u534e\").is_none());\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert_eq!(find_str(data, \"\"), Some(0u));\n+        assert_eq!(find_str(data, \"\u0e1b\u0e23\u0e30\u0e40\"), Some( 0u));\n+        assert_eq!(find_str(data, \"\u0e30\u0e40\"), Some( 6u));\n+        assert_eq!(find_str(data, \"\u4e2d\u534e\"), Some(27u));\n+        assert!(find_str(data, \"\u0e44\u0e17\u534e\").is_none());\n     }\n \n     #[test]\n     fn test_find_str_between() {\n         // byte positions\n-        assert_eq!(find_str_between(~\"\", ~\"\", 0u, 0u), Some(0u));\n+        assert_eq!(find_str_between(\"\", \"\", 0u, 0u), Some(0u));\n \n-        let data = ~\"abcabc\";\n-        assert_eq!(find_str_between(data, ~\"ab\", 0u, 6u), Some(0u));\n-        assert_eq!(find_str_between(data, ~\"ab\", 2u, 6u), Some(3u));\n-        assert!(find_str_between(data, ~\"ab\", 2u, 4u).is_none());\n+        let data = \"abcabc\";\n+        assert_eq!(find_str_between(data, \"ab\", 0u, 6u), Some(0u));\n+        assert_eq!(find_str_between(data, \"ab\", 2u, 6u), Some(3u));\n+        assert!(find_str_between(data, \"ab\", 2u, 4u).is_none());\n \n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         data = data + data;\n-        assert_eq!(find_str_between(data, ~\"\", 0u, 43u), Some(0u));\n-        assert_eq!(find_str_between(data, ~\"\", 6u, 43u), Some(6u));\n+        assert_eq!(find_str_between(data, \"\", 0u, 43u), Some(0u));\n+        assert_eq!(find_str_between(data, \"\", 6u, 43u), Some(6u));\n \n-        assert_eq!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 0u, 43u), Some( 0u));\n-        assert_eq!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 0u, 43u), Some(12u));\n-        assert_eq!(find_str_between(data, ~\"\u0e22\u4e2d\", 0u, 43u), Some(24u));\n-        assert_eq!(find_str_between(data, ~\"i\u1ec7t\", 0u, 43u), Some(34u));\n-        assert_eq!(find_str_between(data, ~\"Nam\", 0u, 43u), Some(40u));\n+        assert_eq!(find_str_between(data, \"\u0e1b\u0e23\u0e30\", 0u, 43u), Some( 0u));\n+        assert_eq!(find_str_between(data, \"\u0e17\u0e28\u0e44\", 0u, 43u), Some(12u));\n+        assert_eq!(find_str_between(data, \"\u0e22\u4e2d\", 0u, 43u), Some(24u));\n+        assert_eq!(find_str_between(data, \"i\u1ec7t\", 0u, 43u), Some(34u));\n+        assert_eq!(find_str_between(data, \"Nam\", 0u, 43u), Some(40u));\n \n-        assert_eq!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 43u, 86u), Some(43u));\n-        assert_eq!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 43u, 86u), Some(55u));\n-        assert_eq!(find_str_between(data, ~\"\u0e22\u4e2d\", 43u, 86u), Some(67u));\n-        assert_eq!(find_str_between(data, ~\"i\u1ec7t\", 43u, 86u), Some(77u));\n-        assert_eq!(find_str_between(data, ~\"Nam\", 43u, 86u), Some(83u));\n+        assert_eq!(find_str_between(data, \"\u0e1b\u0e23\u0e30\", 43u, 86u), Some(43u));\n+        assert_eq!(find_str_between(data, \"\u0e17\u0e28\u0e44\", 43u, 86u), Some(55u));\n+        assert_eq!(find_str_between(data, \"\u0e22\u4e2d\", 43u, 86u), Some(67u));\n+        assert_eq!(find_str_between(data, \"i\u1ec7t\", 43u, 86u), Some(77u));\n+        assert_eq!(find_str_between(data, \"Nam\", 43u, 86u), Some(83u));\n     }\n \n     #[test]\n@@ -3135,22 +3134,22 @@ mod tests {\n         fn t(v: &[~str], s: &str) {\n             assert_eq!(concat(v), s.to_str());\n         }\n-        t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\"youknowI'mnogood\");\n-        let v: ~[~str] = ~[];\n-        t(v, ~\"\");\n-        t(~[~\"hi\"], ~\"hi\");\n+        t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], \"youknowI'mnogood\");\n+        let v: &[~str] = [];\n+        t(v, \"\");\n+        t([~\"hi\"], \"hi\");\n     }\n \n     #[test]\n     fn test_connect() {\n         fn t(v: &[~str], sep: &str, s: &str) {\n             assert_eq!(connect(v, sep), s.to_str());\n         }\n-        t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"],\n-          ~\" \", ~\"you know I'm no good\");\n-        let v: ~[~str] = ~[];\n-        t(v, ~\" \", ~\"\");\n-        t(~[~\"hi\"], ~\" \", ~\"hi\");\n+        t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"],\n+          \" \", \"you know I'm no good\");\n+        let v: &[~str] = ~[];\n+        t(v, \" \", \"\");\n+        t([~\"hi\"], \" \", \"hi\");\n     }\n \n     #[test]\n@@ -3166,11 +3165,11 @@ mod tests {\n \n     #[test]\n     fn test_repeat() {\n-        assert_eq!(repeat(~\"x\", 4), ~\"xxxx\");\n-        assert_eq!(repeat(~\"hi\", 4), ~\"hihihihi\");\n-        assert_eq!(repeat(~\"\u0e44\u0e17\u534e\", 3), ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\");\n-        assert_eq!(repeat(~\"\", 4), ~\"\");\n-        assert_eq!(repeat(~\"hi\", 0), ~\"\");\n+        assert_eq!(repeat(\"x\", 4), ~\"xxxx\");\n+        assert_eq!(repeat(\"hi\", 4), ~\"hihihihi\");\n+        assert_eq!(repeat(\"\u0e44\u0e17\u534e\", 3), ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\");\n+        assert_eq!(repeat(\"\", 4), ~\"\");\n+        assert_eq!(repeat(\"hi\", 0), ~\"\");\n     }\n \n     #[test]\n@@ -3197,38 +3196,38 @@ mod tests {\n \n     #[test]\n     fn test_starts_with() {\n-        assert!((starts_with(~\"\", ~\"\")));\n-        assert!((starts_with(~\"abc\", ~\"\")));\n-        assert!((starts_with(~\"abc\", ~\"a\")));\n-        assert!((!starts_with(~\"a\", ~\"abc\")));\n-        assert!((!starts_with(~\"\", ~\"abc\")));\n+        assert!((starts_with(\"\", \"\")));\n+        assert!((starts_with(\"abc\", \"\")));\n+        assert!((starts_with(\"abc\", \"a\")));\n+        assert!((!starts_with(\"a\", \"abc\")));\n+        assert!((!starts_with(\"\", \"abc\")));\n     }\n \n     #[test]\n     fn test_ends_with() {\n-        assert!((ends_with(~\"\", ~\"\")));\n-        assert!((ends_with(~\"abc\", ~\"\")));\n-        assert!((ends_with(~\"abc\", ~\"c\")));\n-        assert!((!ends_with(~\"a\", ~\"abc\")));\n-        assert!((!ends_with(~\"\", ~\"abc\")));\n+        assert!((ends_with(\"\", \"\")));\n+        assert!((ends_with(\"abc\", \"\")));\n+        assert!((ends_with(\"abc\", \"c\")));\n+        assert!((!ends_with(\"a\", \"abc\")));\n+        assert!((!ends_with(\"\", \"abc\")));\n     }\n \n     #[test]\n     fn test_is_empty() {\n-        assert!((is_empty(~\"\")));\n-        assert!((!is_empty(~\"a\")));\n+        assert!((is_empty(\"\")));\n+        assert!((!is_empty(\"a\")));\n     }\n \n     #[test]\n     fn test_replace() {\n-        let a = ~\"a\";\n-        assert_eq!(replace(~\"\", a, ~\"b\"), ~\"\");\n-        assert_eq!(replace(~\"a\", a, ~\"b\"), ~\"b\");\n-        assert_eq!(replace(~\"ab\", a, ~\"b\"), ~\"bb\");\n-        let test = ~\"test\";\n-        assert!(replace(~\" test test \", test, ~\"toast\") ==\n+        let a = \"a\";\n+        assert_eq!(replace(\"\", a, \"b\"), ~\"\");\n+        assert_eq!(replace(\"a\", a, \"b\"), ~\"b\");\n+        assert_eq!(replace(\"ab\", a, \"b\"), ~\"bb\");\n+        let test = \"test\";\n+        assert!(replace(\" test test \", test, \"toast\") ==\n             ~\" toast toast \");\n-        assert_eq!(replace(~\" test test \", test, ~\"\"), ~\"   \");\n+        assert_eq!(replace(\" test test \", test, \"\"), ~\"   \");\n     }\n \n     #[test]\n@@ -3338,32 +3337,26 @@ mod tests {\n \n     #[test]\n     fn test_trim_left_chars() {\n-        assert!(trim_left_chars(\" *** foo *** \", ~[]) ==\n-                     \" *** foo *** \");\n-        assert!(trim_left_chars(\" *** foo *** \", ~['*', ' ']) ==\n-                     \"foo *** \");\n-        assert_eq!(trim_left_chars(\" ***  *** \", ~['*', ' ']), \"\");\n-        assert!(trim_left_chars(\"foo *** \", ~['*', ' ']) ==\n-                     \"foo *** \");\n+        assert!(trim_left_chars(\" *** foo *** \", []) == \" *** foo *** \");\n+        assert!(trim_left_chars(\" *** foo *** \", ['*', ' ']) == \"foo *** \");\n+        assert_eq!(trim_left_chars(\" ***  *** \", ['*', ' ']), \"\");\n+        assert!(trim_left_chars(\"foo *** \", ['*', ' ']) == \"foo *** \");\n     }\n \n     #[test]\n     fn test_trim_right_chars() {\n-        assert!(trim_right_chars(\" *** foo *** \", ~[]) ==\n-                     \" *** foo *** \");\n-        assert!(trim_right_chars(\" *** foo *** \", ~['*', ' ']) ==\n-                     \" *** foo\");\n-        assert_eq!(trim_right_chars(\" ***  *** \", ~['*', ' ']), \"\");\n-        assert!(trim_right_chars(\" *** foo\", ~['*', ' ']) ==\n-                     \" *** foo\");\n+        assert!(trim_right_chars(\" *** foo *** \", []) == \" *** foo *** \");\n+        assert!(trim_right_chars(\" *** foo *** \", ['*', ' ']) == \" *** foo\");\n+        assert_eq!(trim_right_chars(\" ***  *** \", ['*', ' ']), \"\");\n+        assert!(trim_right_chars(\" *** foo\", ['*', ' ']) == \" *** foo\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n-        assert_eq!(trim_chars(\" *** foo *** \", ~[]), \" *** foo *** \");\n-        assert_eq!(trim_chars(\" *** foo *** \", ~['*', ' ']), \"foo\");\n-        assert_eq!(trim_chars(\" ***  *** \", ~['*', ' ']), \"\");\n-        assert_eq!(trim_chars(\"foo\", ~['*', ' ']), \"foo\");\n+        assert_eq!(trim_chars(\" *** foo *** \", []), \" *** foo *** \");\n+        assert_eq!(trim_chars(\" *** foo *** \", ['*', ' ']), \"foo\");\n+        assert_eq!(trim_chars(\" ***  *** \", ['*', ' ']), \"\");\n+        assert_eq!(trim_chars(\"foo\", ['*', ' ']), \"foo\");\n     }\n \n     #[test]\n@@ -3398,11 +3391,11 @@ mod tests {\n \n     #[test]\n     fn test_is_whitespace() {\n-        assert!((is_whitespace(~\"\")));\n-        assert!((is_whitespace(~\" \")));\n-        assert!((is_whitespace(~\"\\u2009\"))); // Thin space\n-        assert!((is_whitespace(~\"  \\n\\t   \")));\n-        assert!((!is_whitespace(~\"   _   \")));\n+        assert!(is_whitespace(\"\"));\n+        assert!(is_whitespace(\" \"));\n+        assert!(is_whitespace(\"\\u2009\")); // Thin space\n+        assert!(is_whitespace(\"  \\n\\t   \"));\n+        assert!(!is_whitespace(\"   _   \"));\n     }\n \n     #[test]\n@@ -3543,7 +3536,7 @@ mod tests {\n \n     #[test]\n     fn test_as_buf() {\n-        let a = ~\"Abcdefg\";\n+        let a = \"Abcdefg\";\n         let b = as_buf(a, |buf, _l| {\n             assert_eq!(unsafe { *buf }, 65u8);\n             100\n@@ -3553,7 +3546,7 @@ mod tests {\n \n     #[test]\n     fn test_as_buf_small() {\n-        let a = ~\"A\";\n+        let a = \"A\";\n         let b = as_buf(a, |buf, _l| {\n             assert_eq!(unsafe { *buf }, 65u8);\n             100\n@@ -3631,32 +3624,32 @@ mod tests {\n \n     #[test]\n     fn test_contains() {\n-        assert!(contains(~\"abcde\", ~\"bcd\"));\n-        assert!(contains(~\"abcde\", ~\"abcd\"));\n-        assert!(contains(~\"abcde\", ~\"bcde\"));\n-        assert!(contains(~\"abcde\", ~\"\"));\n-        assert!(contains(~\"\", ~\"\"));\n-        assert!(!contains(~\"abcde\", ~\"def\"));\n-        assert!(!contains(~\"\", ~\"a\"));\n+        assert!(contains(\"abcde\", \"bcd\"));\n+        assert!(contains(\"abcde\", \"abcd\"));\n+        assert!(contains(\"abcde\", \"bcde\"));\n+        assert!(contains(\"abcde\", \"\"));\n+        assert!(contains(\"\", \"\"));\n+        assert!(!contains(\"abcde\", \"def\"));\n+        assert!(!contains(\"\", \"a\"));\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert!(contains(data, ~\"\u0e1b\u0e23\u0e30\u0e40\"));\n-        assert!(contains(data, ~\"\u0e30\u0e40\"));\n-        assert!(contains(data, ~\"\u4e2d\u534e\"));\n-        assert!(!contains(data, ~\"\u0e44\u0e17\u534e\"));\n+        assert!(contains(data, \"\u0e1b\u0e23\u0e30\u0e40\"));\n+        assert!(contains(data, \"\u0e30\u0e40\"));\n+        assert!(contains(data, \"\u4e2d\u534e\"));\n+        assert!(!contains(data, \"\u0e44\u0e17\u534e\"));\n     }\n \n     #[test]\n     fn test_contains_char() {\n-        assert!(contains_char(~\"abc\", 'b'));\n-        assert!(contains_char(~\"a\", 'a'));\n-        assert!(!contains_char(~\"abc\", 'd'));\n-        assert!(!contains_char(~\"\", 'a'));\n+        assert!(contains_char(\"abc\", 'b'));\n+        assert!(contains_char(\"a\", 'a'));\n+        assert!(!contains_char(\"abc\", 'd'));\n+        assert!(!contains_char(\"\", 'a'));\n     }\n \n     #[test]\n     fn test_split_char_each() {\n-        let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n@@ -3674,7 +3667,7 @@ mod tests {\n \n     #[test]\n     fn test_splitn_char_each() {\n-        let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n@@ -3691,7 +3684,7 @@ mod tests {\n \n     #[test]\n     fn test_words_each() {\n-        let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n@@ -3706,12 +3699,12 @@ mod tests {\n             ii += 1;\n         }\n \n-        each_word(~\"\", |_x| fail!()); // should not fail\n+        each_word(\"\", |_x| fail!()); // should not fail\n     }\n \n     #[test]\n     fn test_lines_each () {\n-        let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        let lf = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n@@ -3728,26 +3721,26 @@ mod tests {\n \n     #[test]\n     fn test_map() {\n-        assert_eq!(~\"\", map(~\"\", |c| unsafe {libc::toupper(c as c_char)} as char));\n-        assert_eq!(~\"YMCA\", map(~\"ymca\", |c| unsafe {libc::toupper(c as c_char)} as char));\n+        assert_eq!(~\"\", map(\"\", |c| unsafe {libc::toupper(c as c_char)} as char));\n+        assert_eq!(~\"YMCA\", map(\"ymca\", |c| unsafe {libc::toupper(c as c_char)} as char));\n     }\n \n     #[test]\n     fn test_all() {\n-        assert_eq!(true, all(~\"\", char::is_uppercase));\n-        assert_eq!(false, all(~\"ymca\", char::is_uppercase));\n-        assert_eq!(true, all(~\"YMCA\", char::is_uppercase));\n-        assert_eq!(false, all(~\"yMCA\", char::is_uppercase));\n-        assert_eq!(false, all(~\"YMCy\", char::is_uppercase));\n+        assert_eq!(true, all(\"\", char::is_uppercase));\n+        assert_eq!(false, all(\"ymca\", char::is_uppercase));\n+        assert_eq!(true, all(\"YMCA\", char::is_uppercase));\n+        assert_eq!(false, all(\"yMCA\", char::is_uppercase));\n+        assert_eq!(false, all(\"YMCy\", char::is_uppercase));\n     }\n \n     #[test]\n     fn test_any() {\n-        assert_eq!(false, any(~\"\", char::is_uppercase));\n-        assert_eq!(false, any(~\"ymca\", char::is_uppercase));\n-        assert_eq!(true, any(~\"YMCA\", char::is_uppercase));\n-        assert_eq!(true, any(~\"yMCA\", char::is_uppercase));\n-        assert_eq!(true, any(~\"Ymcy\", char::is_uppercase));\n+        assert_eq!(false, any(\"\", char::is_uppercase));\n+        assert_eq!(false, any(\"ymca\", char::is_uppercase));\n+        assert_eq!(true, any(\"YMCA\", char::is_uppercase));\n+        assert_eq!(true, any(\"yMCA\", char::is_uppercase));\n+        assert_eq!(true, any(\"Ymcy\", char::is_uppercase));\n     }\n \n     #[test]\n@@ -3761,41 +3754,41 @@ mod tests {\n     #[test]\n     fn test_utf16() {\n         let pairs =\n-            ~[(~\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\",\n+            [(~\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\",\n               ~[0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n-               0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n-               0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n-               0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n+                0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n+                0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n+                0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n \n              (~\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\",\n               ~[0xd801_u16, 0xdc12_u16, 0xd801_u16,\n-               0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n-               0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n-               0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n-               0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n-               0x000a_u16]),\n+                0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n+                0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n+                0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n+                0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n+                0x000a_u16]),\n \n              (~\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\",\n               ~[0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n-               0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n-               0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n-               0x00b7_u16, 0xd800_u16, 0xdf0c_u16, 0xd800_u16,\n-               0xdf04_u16, 0xd800_u16, 0xdf15_u16, 0xd800_u16,\n-               0xdf04_u16, 0xd800_u16, 0xdf0b_u16, 0xd800_u16,\n-               0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n+                0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n+                0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n+                0x00b7_u16, 0xd800_u16, 0xdf0c_u16, 0xd800_u16,\n+                0xdf04_u16, 0xd800_u16, 0xdf15_u16, 0xd800_u16,\n+                0xdf04_u16, 0xd800_u16, 0xdf0b_u16, 0xd800_u16,\n+                0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n \n              (~\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\",\n               ~[0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n-               0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n-               0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n-               0x0020_u16, 0xd801_u16, 0xdc95_u16, 0xd801_u16,\n-               0xdc93_u16, 0x0020_u16, 0xd801_u16, 0xdc88_u16,\n-               0xd801_u16, 0xdc9a_u16, 0xd801_u16, 0xdc8d_u16,\n-               0x0020_u16, 0xd801_u16, 0xdc8f_u16, 0xd801_u16,\n-               0xdc9c_u16, 0xd801_u16, 0xdc92_u16, 0xd801_u16,\n-               0xdc96_u16, 0xd801_u16, 0xdc86_u16, 0x0020_u16,\n-               0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n-               0x000a_u16 ]) ];\n+                0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n+                0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n+                0x0020_u16, 0xd801_u16, 0xdc95_u16, 0xd801_u16,\n+                0xdc93_u16, 0x0020_u16, 0xd801_u16, 0xdc88_u16,\n+                0xd801_u16, 0xdc9a_u16, 0xd801_u16, 0xdc8d_u16,\n+                0x0020_u16, 0xd801_u16, 0xdc8f_u16, 0xd801_u16,\n+                0xdc9c_u16, 0xd801_u16, 0xdc92_u16, 0xd801_u16,\n+                0xdc96_u16, 0xd801_u16, 0xdc86_u16, 0x0020_u16,\n+                0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n+                0x000a_u16 ]) ];\n \n         for pairs.each |p| {\n             let (s, u) = copy *p;\n@@ -3972,35 +3965,35 @@ mod tests {\n \n     #[test]\n     fn test_escape_unicode() {\n-        assert_eq!(escape_unicode(~\"abc\"), ~\"\\\\x61\\\\x62\\\\x63\");\n-        assert_eq!(escape_unicode(~\"a c\"), ~\"\\\\x61\\\\x20\\\\x63\");\n-        assert_eq!(escape_unicode(~\"\\r\\n\\t\"), ~\"\\\\x0d\\\\x0a\\\\x09\");\n-        assert_eq!(escape_unicode(~\"'\\\"\\\\\"), ~\"\\\\x27\\\\x22\\\\x5c\");\n-        assert!(escape_unicode(~\"\\x00\\x01\\xfe\\xff\") ==\n+        assert_eq!(escape_unicode(\"abc\"), ~\"\\\\x61\\\\x62\\\\x63\");\n+        assert_eq!(escape_unicode(\"a c\"), ~\"\\\\x61\\\\x20\\\\x63\");\n+        assert_eq!(escape_unicode(\"\\r\\n\\t\"), ~\"\\\\x0d\\\\x0a\\\\x09\");\n+        assert_eq!(escape_unicode(\"'\\\"\\\\\"), ~\"\\\\x27\\\\x22\\\\x5c\");\n+        assert!(escape_unicode(\"\\x00\\x01\\xfe\\xff\") ==\n                      ~\"\\\\x00\\\\x01\\\\xfe\\\\xff\");\n-        assert_eq!(escape_unicode(~\"\\u0100\\uffff\"), ~\"\\\\u0100\\\\uffff\");\n-        assert!(escape_unicode(~\"\\U00010000\\U0010ffff\") ==\n+        assert_eq!(escape_unicode(\"\\u0100\\uffff\"), ~\"\\\\u0100\\\\uffff\");\n+        assert!(escape_unicode(\"\\U00010000\\U0010ffff\") ==\n             ~\"\\\\U00010000\\\\U0010ffff\");\n-        assert_eq!(escape_unicode(~\"ab\\ufb00\"), ~\"\\\\x61\\\\x62\\\\ufb00\");\n-        assert_eq!(escape_unicode(~\"\\U0001d4ea\\r\"), ~\"\\\\U0001d4ea\\\\x0d\");\n+        assert_eq!(escape_unicode(\"ab\\ufb00\"), ~\"\\\\x61\\\\x62\\\\ufb00\");\n+        assert_eq!(escape_unicode(\"\\U0001d4ea\\r\"), ~\"\\\\U0001d4ea\\\\x0d\");\n     }\n \n     #[test]\n     fn test_escape_default() {\n-        assert_eq!(escape_default(~\"abc\"), ~\"abc\");\n-        assert_eq!(escape_default(~\"a c\"), ~\"a c\");\n-        assert_eq!(escape_default(~\"\\r\\n\\t\"), ~\"\\\\r\\\\n\\\\t\");\n-        assert_eq!(escape_default(~\"'\\\"\\\\\"), ~\"\\\\'\\\\\\\"\\\\\\\\\");\n-        assert_eq!(escape_default(~\"\\u0100\\uffff\"), ~\"\\\\u0100\\\\uffff\");\n-        assert!(escape_default(~\"\\U00010000\\U0010ffff\") ==\n+        assert_eq!(escape_default(\"abc\"), ~\"abc\");\n+        assert_eq!(escape_default(\"a c\"), ~\"a c\");\n+        assert_eq!(escape_default(\"\\r\\n\\t\"), ~\"\\\\r\\\\n\\\\t\");\n+        assert_eq!(escape_default(\"'\\\"\\\\\"), ~\"\\\\'\\\\\\\"\\\\\\\\\");\n+        assert_eq!(escape_default(\"\\u0100\\uffff\"), ~\"\\\\u0100\\\\uffff\");\n+        assert!(escape_default(\"\\U00010000\\U0010ffff\") ==\n             ~\"\\\\U00010000\\\\U0010ffff\");\n-        assert_eq!(escape_default(~\"ab\\ufb00\"), ~\"ab\\\\ufb00\");\n-        assert_eq!(escape_default(~\"\\U0001d4ea\\r\"), ~\"\\\\U0001d4ea\\\\r\");\n+        assert_eq!(escape_default(\"ab\\ufb00\"), ~\"ab\\\\ufb00\");\n+        assert_eq!(escape_default(\"\\U0001d4ea\\r\"), ~\"\\\\U0001d4ea\\\\r\");\n     }\n \n     #[test]\n     fn test_to_managed() {\n-        assert_eq!((~\"abc\").to_managed(), @\"abc\");\n+        assert_eq!(\"abc\".to_managed(), @\"abc\");\n         assert_eq!(slice(\"abcdef\", 1, 5).to_managed(), @\"bcde\");\n     }\n "}, {"sha": "e48fef01df941bd75e491f36d326f7646cbc748a", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -228,8 +228,8 @@ mod tests {\n         assert_eq!('`'.to_ascii().to_upper().to_char(), '`');\n         assert_eq!('{'.to_ascii().to_upper().to_char(), '{');\n \n-        assert!(str::all(~\"banana\", |c| c.is_ascii()));\n-        assert!(! str::all(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |c| c.is_ascii()));\n+        assert!(str::all(\"banana\", |c| c.is_ascii()));\n+        assert!(! str::all(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |c| c.is_ascii()));\n     }\n \n     #[test]"}, {"sha": "20b45dfb2cc6aa6f433e24d1fc532c9bf4434de3", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -236,42 +236,6 @@ impl<A:IterBytes> IterBytes for @[A] {\n     }\n }\n \n-// NOTE: remove all of these after a snapshot, the new for-loop iteration\n-//       protocol makes these unnecessary.\n-\n-#[inline(always)]\n-pub fn iter_bytes_2<A:IterBytes,B:IterBytes>(a: &A, b: &B,\n-                                             lsb0: bool, z: Cb) -> bool {\n-    a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z)\n-}\n-\n-pub fn iter_bytes_3<A: IterBytes,\n-                    B: IterBytes,\n-                    C: IterBytes>(a: &A, b: &B, c: &C, lsb0: bool, z: Cb) -> bool {\n-    a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z) && c.iter_bytes(lsb0, z)\n-}\n-\n-pub fn iter_bytes_4<A: IterBytes,\n-                B: IterBytes,\n-                C: IterBytes,\n-                D: IterBytes>(a: &A, b: &B, c: &C,\n-                              d: &D,\n-                              lsb0: bool, z: Cb) -> bool {\n-    a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z) && c.iter_bytes(lsb0, z) &&\n-        d.iter_bytes(lsb0, z)\n-}\n-\n-pub fn iter_bytes_5<A: IterBytes,\n-                B: IterBytes,\n-                C: IterBytes,\n-                D: IterBytes,\n-                E: IterBytes>(a: &A, b: &B, c: &C,\n-                              d: &D, e: &E,\n-                              lsb0: bool, z: Cb) -> bool {\n-    a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z) && c.iter_bytes(lsb0, z) &&\n-        d.iter_bytes(lsb0, z) && e.iter_bytes(lsb0, z)\n-}\n-\n impl<'self> IterBytes for &'self str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {"}, {"sha": "103489988a3e88f371cd430ea35062d40d4f2284", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 70, "deletions": 77, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -2962,8 +2962,8 @@ mod tests {\n \n     #[test]\n     fn test_is_empty() {\n-        assert!(is_empty::<int>(~[]));\n-        assert!(!is_empty(~[0]));\n+        assert!(is_empty::<int>([]));\n+        assert!(!is_empty([0]));\n     }\n \n     #[test]\n@@ -3445,15 +3445,15 @@ mod tests {\n \n     #[test]\n     fn test_each_empty() {\n-        for each::<int>(~[]) |_v| {\n+        for each::<int>([]) |_v| {\n             fail!(); // should never be executed\n         }\n     }\n \n     #[test]\n     fn test_each_nonempty() {\n         let mut i = 0;\n-        for each(~[1, 2, 3]) |v| {\n+        for each([1, 2, 3]) |v| {\n             i += *v;\n         }\n         assert_eq!(i, 6);\n@@ -3462,7 +3462,7 @@ mod tests {\n     #[test]\n     fn test_eachi() {\n         let mut i = 0;\n-        for eachi(~[1, 2, 3]) |j, v| {\n+        for eachi([1, 2, 3]) |j, v| {\n             if i == 0 { assert!(*v == 1); }\n             assert_eq!(j + 1u, *v as uint);\n             i += *v;\n@@ -3481,7 +3481,7 @@ mod tests {\n     #[test]\n     fn test_each_reverse_nonempty() {\n         let mut i = 0;\n-        for each_reverse(~[1, 2, 3]) |v| {\n+        for each_reverse([1, 2, 3]) |v| {\n             if i == 0 { assert!(*v == 3); }\n             i += *v\n         }\n@@ -3491,7 +3491,7 @@ mod tests {\n     #[test]\n     fn test_eachi_reverse() {\n         let mut i = 0;\n-        for eachi_reverse(~[0, 1, 2]) |j, v| {\n+        for eachi_reverse([0, 1, 2]) |j, v| {\n             if i == 0 { assert!(*v == 2); }\n             assert_eq!(j, *v as uint);\n             i += *v;\n@@ -3512,48 +3512,48 @@ mod tests {\n         let mut results: ~[~[int]];\n \n         results = ~[];\n-        for each_permutation(~[]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([]) |v| { results.push(to_owned(v)); }\n         assert_eq!(results, ~[~[]]);\n \n         results = ~[];\n-        for each_permutation(~[7]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([7]) |v| { results.push(to_owned(v)); }\n         assert_eq!(results, ~[~[7]]);\n \n         results = ~[];\n-        for each_permutation(~[1,1]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([1,1]) |v| { results.push(to_owned(v)); }\n         assert_eq!(results, ~[~[1,1],~[1,1]]);\n \n         results = ~[];\n-        for each_permutation(~[5,2,0]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([5,2,0]) |v| { results.push(to_owned(v)); }\n         assert!(results ==\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n     }\n \n     #[test]\n     fn test_any_and_all() {\n-        assert!(any(~[1u, 2u, 3u], is_three));\n-        assert!(!any(~[0u, 1u, 2u], is_three));\n-        assert!(any(~[1u, 2u, 3u, 4u, 5u], is_three));\n-        assert!(!any(~[1u, 2u, 4u, 5u, 6u], is_three));\n+        assert!(any([1u, 2u, 3u], is_three));\n+        assert!(!any([0u, 1u, 2u], is_three));\n+        assert!(any([1u, 2u, 3u, 4u, 5u], is_three));\n+        assert!(!any([1u, 2u, 4u, 5u, 6u], is_three));\n \n-        assert!(all(~[3u, 3u, 3u], is_three));\n-        assert!(!all(~[3u, 3u, 2u], is_three));\n-        assert!(all(~[3u, 3u, 3u, 3u, 3u], is_three));\n-        assert!(!all(~[3u, 3u, 0u, 1u, 2u], is_three));\n+        assert!(all([3u, 3u, 3u], is_three));\n+        assert!(!all([3u, 3u, 2u], is_three));\n+        assert!(all([3u, 3u, 3u, 3u, 3u], is_three));\n+        assert!(!all([3u, 3u, 0u, 1u, 2u], is_three));\n     }\n \n     #[test]\n     fn test_any2_and_all2() {\n \n-        assert!(any2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal));\n-        assert!(any2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal));\n-        assert!(!any2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal));\n-        assert!(any2(~[2u, 4u, 6u], ~[2u, 4u], is_equal));\n+        assert!(any2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n+        assert!(any2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n+        assert!(!any2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n+        assert!(any2([2u, 4u, 6u], [2u, 4u], is_equal));\n \n-        assert!(all2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal));\n-        assert!(!all2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal));\n-        assert!(!all2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal));\n-        assert!(!all2(~[2u, 4u, 6u], ~[2u, 4u], is_equal));\n+        assert!(all2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n+        assert!(!all2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n+        assert!(!all2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n+        assert!(!all2([2u, 4u, 6u], [2u, 4u], is_equal));\n     }\n \n     #[test]\n@@ -3576,7 +3576,7 @@ mod tests {\n \n     #[test]\n     fn test_position_elem() {\n-        assert!(position_elem(~[], &1).is_none());\n+        assert!(position_elem([], &1).is_none());\n \n         let v1 = ~[1, 2, 3, 3, 2, 5];\n         assert_eq!(position_elem(v1, &1), Some(0u));\n@@ -3590,7 +3590,7 @@ mod tests {\n         fn less_than_three(i: &int) -> bool { *i < 3 }\n         fn is_eighteen(i: &int) -> bool { *i == 18 }\n \n-        assert!(position(~[], less_than_three).is_none());\n+        assert!(position([], less_than_three).is_none());\n \n         let v1 = ~[5, 4, 3, 2, 1];\n         assert_eq!(position(v1, less_than_three), Some(3u));\n@@ -3599,7 +3599,7 @@ mod tests {\n \n     #[test]\n     fn test_position_between() {\n-        assert!(position_between(~[], 0u, 0u, f).is_none());\n+        assert!(position_between([], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n@@ -3627,7 +3627,7 @@ mod tests {\n \n     #[test]\n     fn test_find() {\n-        assert!(find(~[], f).is_none());\n+        assert!(find([], f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n@@ -3639,7 +3639,7 @@ mod tests {\n \n     #[test]\n     fn test_find_between() {\n-        assert!(find_between(~[], 0u, 0u, f).is_none());\n+        assert!(find_between([], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n@@ -3667,7 +3667,7 @@ mod tests {\n \n     #[test]\n     fn test_rposition() {\n-        assert!(find(~[], f).is_none());\n+        assert!(find([], f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n@@ -3679,7 +3679,7 @@ mod tests {\n \n     #[test]\n     fn test_rposition_between() {\n-        assert!(rposition_between(~[], 0u, 0u, f).is_none());\n+        assert!(rposition_between([], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n@@ -3707,7 +3707,7 @@ mod tests {\n \n     #[test]\n     fn test_rfind() {\n-        assert!(rfind(~[], f).is_none());\n+        assert!(rfind([], f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n@@ -3719,7 +3719,7 @@ mod tests {\n \n     #[test]\n     fn test_rfind_between() {\n-        assert!(rfind_between(~[], 0u, 0u, f).is_none());\n+        assert!(rfind_between([], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n@@ -3798,22 +3798,22 @@ mod tests {\n         reverse(v);\n         assert_eq!(v[0], 20);\n         assert_eq!(v[1], 10);\n-        let v2 = reversed::<int>(~[10, 20]);\n+        let v2 = reversed::<int>([10, 20]);\n         assert_eq!(v2[0], 20);\n         assert_eq!(v2[1], 10);\n         v[0] = 30;\n         assert_eq!(v2[0], 20);\n         // Make sure they work with 0-length vectors too.\n \n-        let v4 = reversed::<int>(~[]);\n+        let v4 = reversed::<int>([]);\n         assert_eq!(v4, ~[]);\n         let mut v3: ~[int] = ~[];\n         reverse::<int>(v3);\n     }\n \n     #[test]\n     fn reversed_mut() {\n-        let v2 = reversed::<int>(~[10, 20]);\n+        let v2 = reversed::<int>([10, 20]);\n         assert_eq!(v2[0], 20);\n         assert_eq!(v2[1], 10);\n     }\n@@ -3822,87 +3822,80 @@ mod tests {\n     fn test_split() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert_eq!(split(~[], f), ~[]);\n-        assert_eq!(split(~[1, 2], f), ~[~[1, 2]]);\n-        assert_eq!(split(~[3, 1, 2], f), ~[~[], ~[1, 2]]);\n-        assert_eq!(split(~[1, 2, 3], f), ~[~[1, 2], ~[]]);\n-        assert_eq!(split(~[1, 2, 3, 4, 3, 5], f), ~[~[1, 2], ~[4], ~[5]]);\n+        assert_eq!(split([], f), ~[]);\n+        assert_eq!(split([1, 2], f), ~[~[1, 2]]);\n+        assert_eq!(split([3, 1, 2], f), ~[~[], ~[1, 2]]);\n+        assert_eq!(split([1, 2, 3], f), ~[~[1, 2], ~[]]);\n+        assert_eq!(split([1, 2, 3, 4, 3, 5], f), ~[~[1, 2], ~[4], ~[5]]);\n     }\n \n     #[test]\n     fn test_splitn() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert_eq!(splitn(~[], 1u, f), ~[]);\n-        assert_eq!(splitn(~[1, 2], 1u, f), ~[~[1, 2]]);\n-        assert_eq!(splitn(~[3, 1, 2], 1u, f), ~[~[], ~[1, 2]]);\n-        assert_eq!(splitn(~[1, 2, 3], 1u, f), ~[~[1, 2], ~[]]);\n-        assert!(splitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n+        assert_eq!(splitn([], 1u, f), ~[]);\n+        assert_eq!(splitn([1, 2], 1u, f), ~[~[1, 2]]);\n+        assert_eq!(splitn([3, 1, 2], 1u, f), ~[~[], ~[1, 2]]);\n+        assert_eq!(splitn([1, 2, 3], 1u, f), ~[~[1, 2], ~[]]);\n+        assert!(splitn([1, 2, 3, 4, 3, 5], 1u, f) ==\n                       ~[~[1, 2], ~[4, 3, 5]]);\n     }\n \n     #[test]\n     fn test_rsplit() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert_eq!(rsplit(~[], f), ~[]);\n-        assert_eq!(rsplit(~[1, 2], f), ~[~[1, 2]]);\n-        assert_eq!(rsplit(~[1, 2, 3], f), ~[~[1, 2], ~[]]);\n-        assert!(rsplit(~[1, 2, 3, 4, 3, 5], f) ==\n+        assert_eq!(rsplit([], f), ~[]);\n+        assert_eq!(rsplit([1, 2], f), ~[~[1, 2]]);\n+        assert_eq!(rsplit([1, 2, 3], f), ~[~[1, 2], ~[]]);\n+        assert!(rsplit([1, 2, 3, 4, 3, 5], f) ==\n             ~[~[1, 2], ~[4], ~[5]]);\n     }\n \n     #[test]\n     fn test_rsplitn() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert_eq!(rsplitn(~[], 1u, f), ~[]);\n-        assert_eq!(rsplitn(~[1, 2], 1u, f), ~[~[1, 2]]);\n-        assert_eq!(rsplitn(~[1, 2, 3], 1u, f), ~[~[1, 2], ~[]]);\n-        assert!(rsplitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n-                       ~[~[1, 2, 3, 4], ~[5]]);\n+        assert_eq!(rsplitn([], 1u, f), ~[]);\n+        assert_eq!(rsplitn([1, 2], 1u, f), ~[~[1, 2]]);\n+        assert_eq!(rsplitn([1, 2, 3], 1u, f), ~[~[1, 2], ~[]]);\n+        assert_eq!(rsplitn([1, 2, 3, 4, 3, 5], 1u, f), ~[~[1, 2, 3, 4], ~[5]]);\n     }\n \n     #[test]\n     fn test_partition() {\n         // FIXME (#4355 maybe): using v.partition here crashes\n         assert_eq!(partition(~[], |x: &int| *x < 3), (~[], ~[]));\n-        assert!(partition(~[1, 2, 3], |x: &int| *x < 4) ==\n-            (~[1, 2, 3], ~[]));\n-        assert!(partition(~[1, 2, 3], |x: &int| *x < 2) ==\n-            (~[1], ~[2, 3]));\n-        assert!(partition(~[1, 2, 3], |x: &int| *x < 0) ==\n-            (~[], ~[1, 2, 3]));\n+        assert_eq!(partition(~[1, 2, 3], |x: &int| *x < 4), (~[1, 2, 3], ~[]));\n+        assert_eq!(partition(~[1, 2, 3], |x: &int| *x < 2), (~[1], ~[2, 3]));\n+        assert_eq!(partition(~[1, 2, 3], |x: &int| *x < 0), (~[], ~[1, 2, 3]));\n     }\n \n     #[test]\n     fn test_partitioned() {\n-        assert_eq!((~[]).partitioned(|x: &int| *x < 3), (~[], ~[]))\n-        assert!((~[1, 2, 3]).partitioned(|x: &int| *x < 4) ==\n-                     (~[1, 2, 3], ~[]));\n-        assert!((~[1, 2, 3]).partitioned(|x: &int| *x < 2) ==\n-                     (~[1], ~[2, 3]));\n-        assert!((~[1, 2, 3]).partitioned(|x: &int| *x < 0) ==\n-                     (~[], ~[1, 2, 3]));\n+        assert_eq!(([]).partitioned(|x: &int| *x < 3), (~[], ~[]))\n+        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 4), (~[1, 2, 3], ~[]));\n+        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 2), (~[1], ~[2, 3]));\n+        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 0), (~[], ~[1, 2, 3]));\n     }\n \n     #[test]\n     fn test_concat() {\n-        assert_eq!(concat(~[~[1], ~[2,3]]), ~[1, 2, 3]);\n+        assert_eq!(concat([~[1], ~[2,3]]), ~[1, 2, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n-        assert_eq!(connect(~[], &0), ~[]);\n-        assert_eq!(connect(~[~[1], ~[2, 3]], &0), ~[1, 0, 2, 3]);\n-        assert_eq!(connect(~[~[1], ~[2], ~[3]], &0), ~[1, 0, 2, 0, 3]);\n+        assert_eq!(connect([], &0), ~[]);\n+        assert_eq!(connect([~[1], ~[2, 3]], &0), ~[1, 0, 2, 3]);\n+        assert_eq!(connect([~[1], ~[2], ~[3]], &0), ~[1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n     fn test_windowed () {\n         fn t(n: uint, expected: &[&[int]]) {\n             let mut i = 0;\n-            for windowed(n, ~[1,2,3,4,5,6]) |v| {\n+            for windowed(n, [1,2,3,4,5,6]) |v| {\n                 assert_eq!(v, expected[i]);\n                 i += 1;\n             }\n@@ -3920,7 +3913,7 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_windowed_() {\n-        for windowed (0u, ~[1u,2u,3u,4u,5u,6u]) |_v| {}\n+        for windowed (0u, [1u,2u,3u,4u,5u,6u]) |_v| {}\n     }\n \n     #[test]"}, {"sha": "a71f0ef20647fb7638f19dd70f6418780b53e3bc", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -17,9 +17,8 @@ use abi::AbiSet;\n use opt_vec::OptVec;\n use parse::token::get_ident_interner;\n \n-use core::cast;\n use core::hashmap::HashMap;\n-use core::option::{Option};\n+use core::option::Option;\n use core::to_bytes::IterBytes;\n use core::to_bytes;\n use core::to_str::ToStr;\n@@ -112,7 +111,9 @@ pub struct Lifetime {\n \n impl to_bytes::IterBytes for Lifetime {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        to_bytes::iter_bytes_3(&self.id, &self.span, &self.ident, lsb0, f)\n+        self.id.iter_bytes(lsb0, f) &&\n+        self.span.iter_bytes(lsb0, f) &&\n+        self.ident.iter_bytes(lsb0, f)\n     }\n }\n \n@@ -266,7 +267,9 @@ impl to_bytes::IterBytes for binding_mode {\n         match *self {\n           bind_by_copy => 0u8.iter_bytes(lsb0, f),\n \n-          bind_by_ref(ref m) => to_bytes::iter_bytes_2(&1u8, m, lsb0, f),\n+          bind_by_ref(ref m) => {\n+              1u8.iter_bytes(lsb0, f) && m.iter_bytes(lsb0, f)\n+          }\n \n           bind_infer => 2u8.iter_bytes(lsb0, f),\n         }\n@@ -788,7 +791,7 @@ pub enum ty_ {\n \n impl to_bytes::IterBytes for Ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f)\n+        self.span.lo.iter_bytes(lsb0, f) && self.span.hi.iter_bytes(lsb0, f)\n     }\n }\n \n@@ -876,9 +879,15 @@ impl to_bytes::IterBytes for explicit_self_ {\n         match *self {\n             sty_static => 0u8.iter_bytes(lsb0, f),\n             sty_value => 1u8.iter_bytes(lsb0, f),\n-            sty_region(ref lft, ref mutbl) => to_bytes::iter_bytes_3(&2u8, &lft, mutbl, lsb0, f),\n-            sty_box(ref mutbl) => to_bytes::iter_bytes_2(&3u8, mutbl, lsb0, f),\n-            sty_uniq(ref mutbl) => to_bytes::iter_bytes_2(&4u8, mutbl, lsb0, f),\n+            sty_region(ref lft, ref mutbl) => {\n+                2u8.iter_bytes(lsb0, f) && lft.iter_bytes(lsb0, f) && mutbl.iter_bytes(lsb0, f)\n+            }\n+            sty_box(ref mutbl) => {\n+                3u8.iter_bytes(lsb0, f) && mutbl.iter_bytes(lsb0, f)\n+            }\n+            sty_uniq(ref mutbl) => {\n+                4u8.iter_bytes(lsb0, f) && mutbl.iter_bytes(lsb0, f)\n+            }\n         }\n     }\n }"}, {"sha": "59743b6e8927f1e231208368a35c596ac155cd6a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -197,7 +197,7 @@ pub fn is_call_expr(e: @expr) -> bool {\n impl to_bytes::IterBytes for def_id {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f)\n+        self.crate.iter_bytes(lsb0, f) && self.node.iter_bytes(lsb0, f)\n     }\n }\n "}, {"sha": "42117e3b73cf349864af6c7e1441f1ec9f583c78", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -140,7 +140,9 @@ impl<D:Decoder> Decodable<D> for span {\n \n impl to_bytes::IterBytes for span {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        to_bytes::iter_bytes_3(&self.lo, &self.hi, &self.expn_info, lsb0, f)\n+        self.lo.iter_bytes(lsb0, f) &&\n+        self.hi.iter_bytes(lsb0, f) &&\n+        self.expn_info.iter_bytes(lsb0, f)\n     }\n }\n \n@@ -193,7 +195,7 @@ pub struct NameAndSpan {name: ~str, span: Option<span>}\n \n impl to_bytes::IterBytes for NameAndSpan {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        to_bytes::iter_bytes_2(&self.name, &self.span, lsb0, f)\n+        self.name.iter_bytes(lsb0, f) && self.span.iter_bytes(lsb0, f)\n     }\n }\n \n@@ -204,7 +206,7 @@ pub struct CallInfo {\n \n impl to_bytes::IterBytes for CallInfo {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        to_bytes::iter_bytes_2(&self.call_site, &self.callee, lsb0, f)\n+        self.call_site.iter_bytes(lsb0, f) && self.callee.iter_bytes(lsb0, f)\n     }\n }\n \n@@ -216,7 +218,9 @@ pub enum ExpnInfo {\n impl to_bytes::IterBytes for ExpnInfo {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n-            ExpandedFrom(ref call_info) => to_bytes::iter_bytes_2(&0u8, call_info, lsb0, f)\n+            ExpandedFrom(ref call_info) => {\n+                0u8.iter_bytes(lsb0, f) && call_info.iter_bytes(lsb0, f)\n+            }\n         }\n     }\n }"}, {"sha": "da59059a0cc4104b45c1bd51cad63eb4901a6613", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -15,11 +15,9 @@\n \n use core::prelude::*;\n \n-use abi::AbiSet;\n use ast::ident;\n use ast;\n use codemap::span;\n-// use ext::quote::rt::*;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {"}, {"sha": "b8993520ae4cca15b774dc66bfba44071d10fb8b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a776d65b4d8e5eaad501af2b147cfbe1dbf10d3c", "patch": "@@ -2752,7 +2752,7 @@ pub impl Parser {\n             match *self.token {\n                 token::SEMI => {\n                     if !vec::is_empty(attributes_box) {\n-                        self.span_err(*self.last_span,~\"expected item after attributes\");\n+                        self.span_err(*self.last_span, \"expected item after attributes\");\n                         attributes_box = ~[];\n                     }\n                     self.bump(); // empty\n@@ -2823,7 +2823,7 @@ pub impl Parser {\n         }\n \n         if !vec::is_empty(attributes_box) {\n-            self.span_err(*self.last_span,~\"expected item after attributes\");\n+            self.span_err(*self.last_span, \"expected item after attributes\");\n         }\n \n         let hi = self.span.hi;\n@@ -3742,7 +3742,7 @@ pub impl Parser {\n         } = self.parse_foreign_items(first_item_attrs, true);\n         if (! attrs_remaining.is_empty()) {\n             self.span_err(*self.last_span,\n-                          ~\"expected item after attributes\");\n+                          \"expected item after attributes\");\n         }\n         assert!(*self.token == token::RBRACE);\n         ast::foreign_mod {"}]}