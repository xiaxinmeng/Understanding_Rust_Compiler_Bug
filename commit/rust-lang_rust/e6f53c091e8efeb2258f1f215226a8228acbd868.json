{"sha": "e6f53c091e8efeb2258f1f215226a8228acbd868", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZjUzYzA5MWU4ZWZlYjIyNThmMWYyMTUyMjZhODIyOGFjYmQ4Njg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-20T01:00:18Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-20T01:00:18Z"}, "message": "libsyntax: Forbid `use` (and most other things) within `extern { ... }` blocks", "tree": {"sha": "d5a533c375401fa888b307b6b6f5ec0a0c6ef783", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5a533c375401fa888b307b6b6f5ec0a0c6ef783"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6f53c091e8efeb2258f1f215226a8228acbd868", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6f53c091e8efeb2258f1f215226a8228acbd868", "html_url": "https://github.com/rust-lang/rust/commit/e6f53c091e8efeb2258f1f215226a8228acbd868", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6f53c091e8efeb2258f1f215226a8228acbd868/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0bea108983446aaa33ecabdd44954e03d5c65e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0bea108983446aaa33ecabdd44954e03d5c65e0", "html_url": "https://github.com/rust-lang/rust/commit/b0bea108983446aaa33ecabdd44954e03d5c65e0"}], "stats": {"total": 127, "additions": 58, "deletions": 69}, "files": [{"sha": "6a3ed22cea9b92493896a41c134cde1589a925d1", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6f53c091e8efeb2258f1f215226a8228acbd868/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6f53c091e8efeb2258f1f215226a8228acbd868/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=e6f53c091e8efeb2258f1f215226a8228acbd868", "patch": "@@ -1221,9 +1221,8 @@ pub mod funcs {\n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub mod fcntl {\n+            use libc::types::os::arch::c95::{c_int, c_char};\n             pub extern {\n-                use libc::types::os::arch::c95::{c_int, c_char};\n-\n                 #[link_name = \"_open\"]\n                 unsafe fn open(path: *c_char, oflag: c_int, mode: c_int)\n                             -> c_int;\n@@ -1562,11 +1561,11 @@ pub mod funcs {\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod bsd44 {\n+        use libc::types::common::c95::{c_void};\n+        use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n+\n         #[abi = \"cdecl\"]\n         pub extern {\n-            use libc::types::common::c95::{c_void};\n-            use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n-\n             unsafe fn sysctl(name: *c_int, namelen: c_uint,\n                       oldp: *mut c_void, oldlenp: *mut size_t,\n                       newp: *c_void, newlen: size_t) -> c_int;"}, {"sha": "8e4115855dbdb7fe23c9a3e4b38fb2bb69102bd9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 54, "deletions": 32, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e6f53c091e8efeb2258f1f215226a8228acbd868/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6f53c091e8efeb2258f1f215226a8228acbd868/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e6f53c091e8efeb2258f1f215226a8228acbd868", "patch": "@@ -120,7 +120,7 @@ pub enum item_or_view_item {\n \n enum view_item_parse_mode {\n     VIEW_ITEMS_AND_ITEMS_ALLOWED,\n-    VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED,\n+    FOREIGN_ITEMS_ALLOWED,\n     IMPORTS_AND_ITEMS_ALLOWED\n }\n \n@@ -3535,7 +3535,7 @@ pub impl Parser {\n             items: _,\n             foreign_items: foreign_items\n         } = self.parse_items_and_view_items(first_item_attrs,\n-                                         VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED,\n+                                            FOREIGN_ITEMS_ALLOWED,\n                                             true);\n \n         let mut items: ~[@foreign_item] = foreign_items;\n@@ -3885,12 +3885,14 @@ pub impl Parser {\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if foreign_items_allowed &&\n+        }\n+        if foreign_items_allowed &&\n                 (self.is_keyword(&~\"const\") || self.is_keyword(&~\"static\")) {\n             // FOREIGN CONST ITEM\n             let item = self.parse_item_foreign_const(visibility, attrs);\n             return iovi_foreign_item(item);\n-        } else if items_allowed &&\n+        }\n+        if items_allowed &&\n             // FUNCTION ITEM (not sure about lookahead condition...)\n             self.is_keyword(&~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n@@ -3899,21 +3901,24 @@ pub impl Parser {\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(&~\"pure\") {\n+        }\n+        if items_allowed && self.eat_keyword(&~\"pure\") {\n             // PURE FUNCTION ITEM\n             // NB: We parse this as impure for bootstrapping purposes.\n             self.expect_keyword(&~\"fn\");\n             let (ident, item_, extra_attrs) = self.parse_item_fn(impure_fn);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if foreign_items_allowed &&\n+        }\n+        if foreign_items_allowed &&\n             (self.is_keyword(&~\"fn\") || self.is_keyword(&~\"pure\") ||\n              self.is_keyword(&~\"unsafe\")) {\n             // FOREIGN FUNCTION ITEM (no items allowed)\n                 let item = self.parse_item_foreign_fn(attrs);\n                 return iovi_foreign_item(item);\n-        } else if items_allowed && self.is_keyword(&~\"unsafe\")\n+        }\n+        if items_allowed && self.is_keyword(&~\"unsafe\")\n             && self.look_ahead(1u) != token::LBRACE {\n             // UNSAFE FUNCTION ITEM (where items are allowed)\n             self.bump();\n@@ -3922,7 +3927,8 @@ pub impl Parser {\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(&~\"extern\") {\n+        }\n+        if self.eat_keyword(&~\"extern\") {\n             if items_allowed && self.eat_keyword(&~\"fn\") {\n                 // EXTERN FUNCTION ITEM\n                 let (ident, item_, extra_attrs) =\n@@ -3932,47 +3938,62 @@ pub impl Parser {\n                                               maybe_append(attrs,\n                                                            extra_attrs)));\n             }\n-            // EXTERN MODULE ITEM\n-            return self.parse_item_foreign_mod(lo, visibility, attrs,\n-                                               items_allowed);\n-        } else if items_allowed && self.eat_keyword(&~\"mod\") {\n+            if !foreign_items_allowed {\n+                // EXTERN MODULE ITEM\n+                return self.parse_item_foreign_mod(lo, visibility, attrs,\n+                                                   items_allowed);\n+            }\n+        }\n+        if items_allowed && !foreign_items_allowed &&\n+                self.eat_keyword(&~\"mod\") {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_mod(attrs);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(&~\"type\") {\n+        }\n+        if items_allowed && !foreign_items_allowed &&\n+                self.eat_keyword(&~\"type\") {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(&~\"enum\") {\n+        }\n+        if items_allowed && !foreign_items_allowed &&\n+                self.eat_keyword(&~\"enum\") {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(&~\"trait\") {\n+        }\n+        if items_allowed && !foreign_items_allowed &&\n+                self.eat_keyword(&~\"trait\") {\n             // TRAIT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(&~\"impl\") {\n+        }\n+        if items_allowed && !foreign_items_allowed &&\n+                self.eat_keyword(&~\"impl\") {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_impl(visibility);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(&~\"struct\") {\n+        }\n+        if items_allowed && !foreign_items_allowed &&\n+                self.eat_keyword(&~\"struct\") {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(&~\"use\") {\n+        }\n+        if !foreign_items_allowed && self.eat_keyword(&~\"use\") {\n             // USE ITEM\n             let view_item = self.parse_use();\n             self.expect(&token::SEMI);\n@@ -3982,7 +4003,8 @@ pub impl Parser {\n                 vis: visibility,\n                 span: mk_sp(lo, self.last_span.hi)\n             });\n-        } else if macros_allowed && !self.is_any_keyword(&copy *self.token)\n+        }\n+        if macros_allowed && !self.is_any_keyword(&copy *self.token)\n                 && self.look_ahead(1) == token::NOT\n                 && (is_plain_ident(&self.look_ahead(2))\n                     || self.look_ahead(2) == token::LPAREN\n@@ -4025,16 +4047,16 @@ pub impl Parser {\n             let item_ = item_mac(m);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, id, item_,\n                                           visibility, attrs));\n-        } else {\n-            // FAILURE TO PARSE ITEM\n-            if visibility != inherited {\n-                let mut s = ~\"unmatched visibility `\";\n-                s += if visibility == public { ~\"pub\" } else { ~\"priv\" };\n-                s += ~\"`\";\n-                self.span_fatal(*self.last_span, s);\n-            }\n-            return iovi_none;\n-        };\n+        }\n+\n+        // FAILURE TO PARSE ITEM\n+        if visibility != inherited {\n+            let mut s = ~\"unmatched visibility `\";\n+            s += if visibility == public { ~\"pub\" } else { ~\"priv\" };\n+            s += ~\"`\";\n+            self.span_fatal(*self.last_span, s);\n+        }\n+        return iovi_none;\n     }\n \n     fn parse_item(&self, +attrs: ~[attribute]) -> Option<@ast::item> {\n@@ -4201,17 +4223,17 @@ pub impl Parser {\n \n         let items_allowed = match mode {\n             VIEW_ITEMS_AND_ITEMS_ALLOWED | IMPORTS_AND_ITEMS_ALLOWED => true,\n-            VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED => false\n+            FOREIGN_ITEMS_ALLOWED => false\n         };\n \n         let restricted_to_imports = match mode {\n             IMPORTS_AND_ITEMS_ALLOWED => true,\n             VIEW_ITEMS_AND_ITEMS_ALLOWED |\n-            VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED => false\n+            FOREIGN_ITEMS_ALLOWED => false\n         };\n \n         let foreign_items_allowed = match mode {\n-            VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED => true,\n+            FOREIGN_ITEMS_ALLOWED => true,\n             VIEW_ITEMS_AND_ITEMS_ALLOWED | IMPORTS_AND_ITEMS_ALLOWED => false\n         };\n "}, {"sha": "223825f60a7493adae68e5fb686dded4f6477f14", "filename": "src/test/run-pass/conditional-compile.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e6f53c091e8efeb2258f1f215226a8228acbd868/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6f53c091e8efeb2258f1f215226a8228acbd868/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile.rs?ref=e6f53c091e8efeb2258f1f215226a8228acbd868", "patch": "@@ -121,13 +121,6 @@ mod test_foreign_items {\n mod test_use_statements {\n     #[cfg(bogus)]\n     use flippity_foo;\n-\n-    pub mod rustrt {\n-        pub extern {\n-            #[cfg(bogus)]\n-            use flippity_foo;\n-        }\n-    }\n }\n \n mod test_methods {"}, {"sha": "feebcdff921613dad66f2d01b83e803cc8cc315f", "filename": "src/test/run-pass/import-from-foreign.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b0bea108983446aaa33ecabdd44954e03d5c65e0/src%2Ftest%2Frun-pass%2Fimport-from-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bea108983446aaa33ecabdd44954e03d5c65e0/src%2Ftest%2Frun-pass%2Fimport-from-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-from-foreign.rs?ref=b0bea108983446aaa33ecabdd44954e03d5c65e0", "patch": "@@ -1,25 +0,0 @@\n-// xfail-fast\n-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-mod spam {\n-    pub fn ham() { }\n-    pub fn eggs() { }\n-}\n-\n-mod rustrt {\n-    #[abi = \"cdecl\"]\n-    pub extern {\n-        pub use spam::{ham, eggs};\n-    }\n-}\n-\n-pub fn main() { rustrt::ham(); rustrt::eggs(); }"}]}