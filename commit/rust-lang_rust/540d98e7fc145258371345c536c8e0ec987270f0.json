{"sha": "540d98e7fc145258371345c536c8e0ec987270f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MGQ5OGU3ZmMxNDUyNTgzNzEzNDVjNTM2YzhlMGVjOTg3MjcwZjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-26T12:06:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-26T12:06:16Z"}, "message": "auto merge of #8737 : blake2-ppc/rust/std-str-rsplit, r=huonw\n\nMake CharSplitIterator double-ended which is simple given that the operation is symmetric, once the split-N feature is factored out into its own adaptor.\r\n\r\n`.rsplitn_iter()` allows splitting `N` times from the back of a string, so it is a completely new feature. With the double-ended impl, `.split_iter()`, `.line_iter()`, `.word_iter()` all allow picking off elements from either end.\r\n\r\n`split_options_iter` is removed with the factoring of the split- and split-N- iterators, instead there is `split_terminator_iter`.\r\n\r\n---\r\n\r\nAdd benchmarks using `#[bench]` and tune CharSplitIterator a bit after Huon Wilson's suggestions\r\n\r\nBenchmarks 1-5 do the same split using different implementations of `CharEq`, all splitting an ascii string on ascii space. Benchmarks 6-7 split a unicode string on an ascii char.\r\n\r\nBefore this PR\r\ntest str::bench::split_iter_ascii ... bench: 166 ns/iter (+/- 2)\r\ntest str::bench::split_iter_closure ... bench: 113 ns/iter (+/- 1)\r\ntest str::bench::split_iter_extern_fn ... bench: 286 ns/iter (+/- 7)\r\ntest str::bench::split_iter_not_ascii ... bench: 114 ns/iter (+/- 4)\r\ntest str::bench::split_iter_slice ... bench: 220 ns/iter (+/- 12)\r\ntest str::bench::split_iter_unicode_ascii ... bench: 217 ns/iter (+/- 3)\r\ntest str::bench::split_iter_unicode_not_ascii ... bench: 248 ns/iter (+/- 3)\r\n\r\nPR, first commit\r\ntest str::bench::split_iter_ascii ... bench: 331 ns/iter (+/- 9)\r\ntest str::bench::split_iter_closure ... bench: 114 ns/iter (+/- 2)\r\ntest str::bench::split_iter_extern_fn ... bench: 314 ns/iter (+/- 6)\r\ntest str::bench::split_iter_not_ascii ... bench: 132 ns/iter (+/- 1)\r\ntest str::bench::split_iter_slice ... bench: 157 ns/iter (+/- 3)\r\ntest str::bench::split_iter_unicode_ascii ... bench: 502 ns/iter (+/- 64)\r\ntest str::bench::split_iter_unicode_not_ascii ... bench: 250 ns/iter (+/- 3)\r\n\r\nPR, final version\r\ntest str::bench::split_iter_ascii ... bench: 106 ns/iter (+/- 4)\r\ntest str::bench::split_iter_closure ... bench: 107 ns/iter (+/- 1)\r\ntest str::bench::split_iter_extern_fn ... bench: 267 ns/iter (+/- 6)\r\ntest str::bench::split_iter_not_ascii ... bench: 108 ns/iter (+/- 1)\r\ntest str::bench::split_iter_slice ... bench: 170 ns/iter (+/- 8)\r\ntest str::bench::split_iter_unicode_ascii ... bench: 128 ns/iter (+/- 5)\r\ntest str::bench::split_iter_unicode_not_ascii ... bench: 252 ns/iter (+/- 3)\r\n\r\n---\r\n\r\nThere are several ways to deal with `CharEq::only_ascii`. It is a performance optimization, so with that in mind, we allow passing bogus char (outside ascii) as long as they don't match. We use a byte value check to make sure we don't split on these (would split substrings in the middle of encoded char).  (A more principled way would be to only pass the ascii codepoints to the CharEq when it indicates only_ascii, but that undoes some of the performance optimization.)", "tree": {"sha": "45cc1001f10e6dca8267e92d4f2f3bdb1ca4985a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45cc1001f10e6dca8267e92d4f2f3bdb1ca4985a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/540d98e7fc145258371345c536c8e0ec987270f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/540d98e7fc145258371345c536c8e0ec987270f0", "html_url": "https://github.com/rust-lang/rust/commit/540d98e7fc145258371345c536c8e0ec987270f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/540d98e7fc145258371345c536c8e0ec987270f0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "501eea0842b71f3530c4178e7b50973a728280b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/501eea0842b71f3530c4178e7b50973a728280b6", "html_url": "https://github.com/rust-lang/rust/commit/501eea0842b71f3530c4178e7b50973a728280b6"}, {"sha": "4de9bca4d813b88f06f7c5f64d2c452c80611f6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4de9bca4d813b88f06f7c5f64d2c452c80611f6b", "html_url": "https://github.com/rust-lang/rust/commit/4de9bca4d813b88f06f7c5f64d2c452c80611f6b"}], "stats": {"total": 378, "additions": 305, "deletions": 73}, "files": [{"sha": "1a2a00022f4fdbd59a5ad688e94fcbe41d8c2231", "filename": "src/libstd/str.rs", "status": "modified", "additions": 305, "deletions": 73, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/540d98e7fc145258371345c536c8e0ec987270f0/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540d98e7fc145258371345c536c8e0ec987270f0/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=540d98e7fc145258371345c536c8e0ec987270f0", "patch": "@@ -23,7 +23,7 @@ use clone::{Clone, DeepClone};\n use container::{Container, Mutable};\n use iter::Times;\n use iterator::{Iterator, FromIterator, Extendable};\n-use iterator::{Filter, AdditiveIterator, Map, Enumerate};\n+use iterator::{Filter, AdditiveIterator, Map};\n use iterator::{Invert, DoubleEndedIterator};\n use libc;\n use num::{Saturating, Zero};\n@@ -388,28 +388,32 @@ pub type ByteIterator<'self> =\n /// Use with the `std::iterator` module.\n pub type ByteRevIterator<'self> = Invert<ByteIterator<'self>>;\n \n-/// An iterator over byte index and either &u8 or char\n-#[deriving(Clone)]\n-enum OffsetIterator<'self> {\n-    // use ByteIterator here when it can be cloned\n-    ByteOffset(Enumerate<vec::VecIterator<'self, u8>>),\n-    CharOffset(CharOffsetIterator<'self>),\n-}\n-\n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n-pub struct CharSplitIterator<'self,Sep> {\n-    priv iter: OffsetIterator<'self>,\n+pub struct CharSplitIterator<'self, Sep> {\n+    /// The slice remaining to be iterated\n     priv string: &'self str,\n-    priv position: uint,\n     priv sep: Sep,\n-    /// The number of splits remaining\n-    priv count: uint,\n     /// Whether an empty string at the end is allowed\n     priv allow_trailing_empty: bool,\n+    priv only_ascii: bool,\n     priv finished: bool,\n }\n \n+/// An iterator over the substrings of a string, separated by `sep`,\n+/// starting from the back of the string.\n+pub type CharRSplitIterator<'self, Sep> = Invert<CharSplitIterator<'self, Sep>>;\n+\n+/// An iterator over the substrings of a string, separated by `sep`,\n+/// splitting at most `count` times.\n+#[deriving(Clone)]\n+pub struct CharSplitNIterator<'self, Sep> {\n+    priv iter: CharSplitIterator<'self, Sep>,\n+    /// The number of splits remaining\n+    priv count: uint,\n+    priv invert: bool,\n+}\n+\n /// An iterator over the words of a string, separated by an sequence of whitespace\n pub type WordIterator<'self> =\n     Filter<'self, &'self str, CharSplitIterator<'self, extern \"Rust\" fn(char) -> bool>>;\n@@ -418,46 +422,101 @@ pub type WordIterator<'self> =\n pub type AnyLineIterator<'self> =\n     Map<'self, &'self str, &'self str, CharSplitIterator<'self, char>>;\n \n+impl<'self, Sep> CharSplitIterator<'self, Sep> {\n+    #[inline]\n+    fn get_end(&mut self) -> Option<&'self str> {\n+        if !self.finished && (self.allow_trailing_empty || self.string.len() > 0) {\n+            self.finished = true;\n+            Some(self.string)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitIterator<'self, Sep> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self str> {\n         if self.finished { return None }\n \n-        let start = self.position;\n-        let len = self.string.len();\n+        let mut next_split = None;\n+        if self.only_ascii {\n+            for (idx, byte) in self.string.byte_iter().enumerate() {\n+                if self.sep.matches(byte as char) && byte < 128u8 {\n+                    next_split = Some((idx, idx + 1));\n+                    break;\n+                }\n+            }\n+        } else {\n+            for (idx, ch) in self.string.char_offset_iter() {\n+                if self.sep.matches(ch) {\n+                    next_split = Some((idx, self.string.char_range_at(idx).next));\n+                    break;\n+                }\n+            }\n+        }\n+        match next_split {\n+            Some((a, b)) => unsafe {\n+                let elt = raw::slice_unchecked(self.string, 0, a);\n+                self.string = raw::slice_unchecked(self.string, b, self.string.len());\n+                Some(elt)\n+            },\n+            None => self.get_end(),\n+        }\n+    }\n+}\n \n-        if self.count > 0 {\n-            match self.iter {\n-                // this gives a *huge* speed up for splitting on ASCII\n-                // characters (e.g. '\\n' or ' ')\n-                ByteOffset(ref mut iter) =>\n-                    for (idx, &byte) in *iter {\n-                        if self.sep.matches(byte as char) {\n-                            self.position = idx + 1;\n-                            self.count -= 1;\n-                            return Some(unsafe {\n-                                raw::slice_bytes(self.string, start, idx)\n-                            })\n-                        }\n-                    },\n-                CharOffset(ref mut iter) =>\n-                    for (idx, ch) in *iter {\n-                        if self.sep.matches(ch) {\n-                            // skip over the separator\n-                            self.position = self.string.char_range_at(idx).next;\n-                            self.count -= 1;\n-                            return Some(unsafe {\n-                                raw::slice_bytes(self.string, start, idx)\n-                            })\n-                        }\n-                    },\n+impl<'self, Sep: CharEq> DoubleEndedIterator<&'self str>\n+for CharSplitIterator<'self, Sep> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'self str> {\n+        if self.finished { return None }\n+\n+        if !self.allow_trailing_empty {\n+            self.allow_trailing_empty = true;\n+            match self.next_back() {\n+                Some(elt) if !elt.is_empty() => return Some(elt),\n+                _ => if self.finished { return None }\n+            }\n+        }\n+        let len = self.string.len();\n+        let mut next_split = None;\n+\n+        if self.only_ascii {\n+            for (j, byte) in self.string.byte_rev_iter().enumerate() {\n+                if self.sep.matches(byte as char) && byte < 128u8 {\n+                    let idx = len - j - 1;\n+                    next_split = Some((idx, idx + 1));\n+                    break;\n+                }\n             }\n+        } else {\n+            for (idx, ch) in self.string.char_offset_rev_iter() {\n+                if self.sep.matches(ch) {\n+                    next_split = Some((idx, self.string.char_range_at(idx).next));\n+                    break;\n+                }\n+            }\n+        }\n+        match next_split {\n+            Some((a, b)) => unsafe {\n+                let elt = raw::slice_unchecked(self.string, b, len);\n+                self.string = raw::slice_unchecked(self.string, 0, a);\n+                Some(elt)\n+            },\n+            None => { self.finished = true; Some(self.string) }\n         }\n-        self.finished = true;\n-        if self.allow_trailing_empty || start < len {\n-            Some(unsafe { raw::slice_bytes(self.string, start, len) })\n+    }\n+}\n+\n+impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitNIterator<'self, Sep> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self str> {\n+        if self.count != 0 {\n+            self.count -= 1;\n+            if self.invert { self.iter.next_back() } else { self.iter.next() }\n         } else {\n-            None\n+            self.iter.get_end()\n         }\n     }\n }\n@@ -1300,9 +1359,10 @@ pub trait StrSlice<'self> {\n     fn char_offset_iter(&self) -> CharOffsetIterator<'self>;\n     fn char_offset_rev_iter(&self) -> CharOffsetRevIterator<'self>;\n     fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n-    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitIterator<'self, Sep>;\n-    fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n-        -> CharSplitIterator<'self, Sep>;\n+    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n+    fn split_terminator_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n+    fn rsplit_iter<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep>;\n+    fn rsplitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n     fn matches_index_iter(&self, sep: &'self str) -> MatchesIndexIterator<'self>;\n     fn split_str_iter(&self, &'self str) -> StrSplitIterator<'self>;\n     fn line_iter(&self) -> CharSplitIterator<'self, char>;\n@@ -1439,40 +1499,78 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// ~~~\n     #[inline]\n     fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep> {\n-        self.split_options_iter(sep, self.len(), true)\n+        CharSplitIterator {\n+            string: *self,\n+            only_ascii: sep.only_ascii(),\n+            sep: sep,\n+            allow_trailing_empty: true,\n+            finished: false,\n+        }\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, restricted to splitting at most `count`\n     /// times.\n     #[inline]\n-    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitIterator<'self, Sep> {\n-        self.split_options_iter(sep, count, true)\n+    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint)\n+        -> CharSplitNIterator<'self, Sep> {\n+        CharSplitNIterator {\n+            iter: self.split_iter(sep),\n+            count: count,\n+            invert: false,\n+        }\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, splitting at most `count` times, and\n-    /// possibly not including the trailing empty substring, if it\n-    /// exists.\n+    /// matched by `sep`.\n+    ///\n+    /// Equivalent to `split_iter`, except that the trailing substring\n+    /// is skipped if empty (terminator semantics).\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let v: ~[&str] = \"A.B.\".split_terminator_iter('.').collect();\n+    /// assert_eq!(v, ~[\"A\", \"B\"]);\n+    /// ~~~\n     #[inline]\n-    fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n+    fn split_terminator_iter<Sep: CharEq>(&self, sep: Sep)\n         -> CharSplitIterator<'self, Sep> {\n-        let iter = if sep.only_ascii() {\n-            ByteOffset(self.as_bytes().iter().enumerate())\n-        } else {\n-            CharOffset(self.char_offset_iter())\n-        };\n         CharSplitIterator {\n-            iter: iter,\n-            string: *self,\n-            position: 0,\n-            sep: sep,\n+            allow_trailing_empty: false,\n+            ..self.split_iter(sep)\n+        }\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, in reverse order\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let v: ~[&str] = \"Mary had a little lamb\".rsplit_iter(' ').collect();\n+    /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    /// ~~~\n+    #[inline]\n+    fn rsplit_iter<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep> {\n+        self.split_iter(sep).invert()\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, starting from the end of the string.\n+    /// Restricted to splitting at most `count` times.\n+    #[inline]\n+    fn rsplitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint)\n+        -> CharSplitNIterator<'self, Sep> {\n+        CharSplitNIterator {\n+            iter: self.split_iter(sep),\n             count: count,\n-            allow_trailing_empty: allow_trailing_empty,\n-            finished: false,\n+            invert: true,\n         }\n     }\n \n+\n+\n     /// An iterator over the start and end indices of each match of\n     /// `sep` within `self`.\n     #[inline]\n@@ -1506,7 +1604,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// by `\\n`).\n     #[inline]\n     fn line_iter(&self) -> CharSplitIterator<'self, char> {\n-        self.split_options_iter('\\n', self.len(), false)\n+        self.split_terminator_iter('\\n')\n     }\n \n     /// An iterator over the lines of a string, separated by either\n@@ -3400,17 +3498,33 @@ mod tests {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n         let split: ~[&str] = data.split_iter(' ').collect();\n-        assert_eq!(split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!( split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+        let mut rsplit: ~[&str] = data.rsplit_iter(' ').collect();\n+        rsplit.reverse();\n+        assert_eq!(rsplit, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         let split: ~[&str] = data.split_iter(|c: char| c == ' ').collect();\n-        assert_eq!(split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!( split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+        let mut rsplit: ~[&str] = data.rsplit_iter(|c: char| c == ' ').collect();\n+        rsplit.reverse();\n+        assert_eq!(rsplit, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n         let split: ~[&str] = data.split_iter('\u00e4').collect();\n-        assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!( split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+        let mut rsplit: ~[&str] = data.rsplit_iter('\u00e4').collect();\n+        rsplit.reverse();\n+        assert_eq!(rsplit, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n         let split: ~[&str] = data.split_iter(|c: char| c == '\u00e4').collect();\n-        assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!( split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+        let mut rsplit: ~[&str] = data.rsplit_iter(|c: char| c == '\u00e4').collect();\n+        rsplit.reverse();\n+        assert_eq!(rsplit, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n \n     #[test]\n@@ -3431,14 +3545,49 @@ mod tests {\n         assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n     }\n \n+    #[test]\n+    fn test_rsplitn_char_iterator() {\n+        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+        let mut split: ~[&str] = data.rsplitn_iter(' ', 3).collect();\n+        split.reverse();\n+        assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+        let mut split: ~[&str] = data.rsplitn_iter(|c: char| c == ' ', 3).collect();\n+        split.reverse();\n+        assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+        // Unicode\n+        let mut split: ~[&str] = data.rsplitn_iter('\u00e4', 3).collect();\n+        split.reverse();\n+        assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+        let mut split: ~[&str] = data.rsplitn_iter(|c: char| c == '\u00e4', 3).collect();\n+        split.reverse();\n+        assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    }\n+\n     #[test]\n     fn test_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let split: ~[&str] = data.split_options_iter('\\n', 1000, true).collect();\n+        let split: ~[&str] = data.split_iter('\\n').collect();\n+        assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+\n+        let split: ~[&str] = data.split_terminator_iter('\\n').collect();\n+        assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+    }\n+\n+    #[test]\n+    fn test_rev_split_char_iterator_no_trailing() {\n+        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+        let mut split: ~[&str] = data.split_iter('\\n').invert().collect();\n+        split.reverse();\n         assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n-        let split: ~[&str] = data.split_options_iter('\\n', 1000, false).collect();\n+        let mut split: ~[&str] = data.split_terminator_iter('\\n').invert().collect();\n+        split.reverse();\n         assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n@@ -3701,6 +3850,89 @@ mod bench {\n         }\n     }\n \n+    #[bench]\n+    fn split_iter_unicode_ascii(bh: &mut BenchHarness) {\n+        let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+\n+        do bh.iter {\n+            assert_eq!(s.split_iter('V').len(), 3);\n+        }\n+    }\n+\n+    #[bench]\n+    fn split_iter_unicode_not_ascii(bh: &mut BenchHarness) {\n+        struct NotAscii(char);\n+        impl CharEq for NotAscii {\n+            fn matches(&self, c: char) -> bool {\n+                **self == c\n+            }\n+            fn only_ascii(&self) -> bool { false }\n+        }\n+        let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+\n+        do bh.iter {\n+            assert_eq!(s.split_iter(NotAscii('V')).len(), 3);\n+        }\n+    }\n+\n+\n+    #[bench]\n+    fn split_iter_ascii(bh: &mut BenchHarness) {\n+        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+        let len = s.split_iter(' ').len();\n+\n+        do bh.iter {\n+            assert_eq!(s.split_iter(' ').len(), len);\n+        }\n+    }\n+\n+    #[bench]\n+    fn split_iter_not_ascii(bh: &mut BenchHarness) {\n+        struct NotAscii(char);\n+        impl CharEq for NotAscii {\n+            #[inline]\n+            fn matches(&self, c: char) -> bool { **self == c }\n+            fn only_ascii(&self) -> bool { false }\n+        }\n+        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+        let len = s.split_iter(' ').len();\n+\n+        do bh.iter {\n+            assert_eq!(s.split_iter(NotAscii(' ')).len(), len);\n+        }\n+    }\n+\n+    #[bench]\n+    fn split_iter_extern_fn(bh: &mut BenchHarness) {\n+        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+        let len = s.split_iter(' ').len();\n+        fn pred(c: char) -> bool { c == ' ' }\n+\n+        do bh.iter {\n+            assert_eq!(s.split_iter(pred).len(), len);\n+        }\n+    }\n+\n+    #[bench]\n+    fn split_iter_closure(bh: &mut BenchHarness) {\n+        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+        let len = s.split_iter(' ').len();\n+\n+        do bh.iter {\n+            assert_eq!(s.split_iter(|c: char| c == ' ').len(), len);\n+        }\n+    }\n+\n+    #[bench]\n+    fn split_iter_slice(bh: &mut BenchHarness) {\n+        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+        let len = s.split_iter(' ').len();\n+\n+        do bh.iter {\n+            assert_eq!(s.split_iter(&[' ']).len(), len);\n+        }\n+    }\n+\n     #[bench]\n     fn is_utf8_100_ascii(bh: &mut BenchHarness) {\n "}]}