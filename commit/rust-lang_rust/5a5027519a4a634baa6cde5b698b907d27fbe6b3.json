{"sha": "5a5027519a4a634baa6cde5b698b907d27fbe6b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNTAyNzUxOWE0YTYzNGJhYTZjZGU1YjY5OGI5MDdkMjdmYmU2YjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-09T09:33:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-09T09:33:13Z"}, "message": "Auto merge of #66242 - Centril:rollup-h73ztr1, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #65949 (Move promotion into its own pass)\n - #65994 (Point at where clauses where the associated item was restricted)\n - #66050 (Fix C aggregate-passing ABI on powerpc)\n - #66134 (Point at formatting descriptor string when it is invalid)\n - #66172 (Stabilize @file command line arguments)\n - #66226 (add link to unstable book for asm! macro)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "b8c1f92861f2ad6b15cf5a5eb4c51a8832fac64e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8c1f92861f2ad6b15cf5a5eb4c51a8832fac64e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a5027519a4a634baa6cde5b698b907d27fbe6b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a5027519a4a634baa6cde5b698b907d27fbe6b3", "html_url": "https://github.com/rust-lang/rust/commit/5a5027519a4a634baa6cde5b698b907d27fbe6b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a5027519a4a634baa6cde5b698b907d27fbe6b3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98c173afe4b7019d0b739151b7d4d4343a85ea2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/98c173afe4b7019d0b739151b7d4d4343a85ea2b", "html_url": "https://github.com/rust-lang/rust/commit/98c173afe4b7019d0b739151b7d4d4343a85ea2b"}, {"sha": "3ef975d4be7a144ea98ebe105264a466d6bd2b92", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ef975d4be7a144ea98ebe105264a466d6bd2b92", "html_url": "https://github.com/rust-lang/rust/commit/3ef975d4be7a144ea98ebe105264a466d6bd2b92"}], "stats": {"total": 776, "additions": 453, "deletions": 323}, "files": [{"sha": "726d187d2e98130bbed1df5ab3fc5019e24a8844", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -1274,6 +1274,10 @@ pub(crate) mod builtin {\n     }\n \n     /// Inline assembly.\n+    ///\n+    /// Read the [unstable book] for the usage.\n+    ///\n+    /// [unstable book]: ../unstable-book/library-features/asm.html\n     #[unstable(feature = \"asm\", issue = \"29722\",\n                reason = \"inline assembly is not stable enough for use and is subject to change\")]\n     #[rustc_builtin_macro]"}, {"sha": "24b19028ac1179e65cff77613606a4eb8666fd03", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -35,7 +35,7 @@ impl InnerOffset {\n \n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Piece<'a> {\n     /// A literal string which should directly be emitted\n     String(&'a str),\n@@ -45,7 +45,7 @@ pub enum Piece<'a> {\n }\n \n /// Representation of an argument specification.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub struct Argument<'a> {\n     /// Where to find this argument\n     pub position: Position,\n@@ -54,7 +54,7 @@ pub struct Argument<'a> {\n }\n \n /// Specification for the formatting of an argument in the format string.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub struct FormatSpec<'a> {\n     /// Optionally specified character to fill alignment with.\n     pub fill: Option<char>,\n@@ -74,10 +74,12 @@ pub struct FormatSpec<'a> {\n     /// this argument, this can be empty or any number of characters, although\n     /// it is required to be one word.\n     pub ty: &'a str,\n+    /// The span of the descriptor string (for diagnostics).\n+    pub ty_span: Option<InnerSpan>,\n }\n \n /// Enum describing where an argument for a format can be located.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Position {\n     /// The argument is implied to be located at an index\n     ArgumentImplicitlyIs(usize),\n@@ -97,7 +99,7 @@ impl Position {\n }\n \n /// Enum of alignments which are supported.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Alignment {\n     /// The value will be aligned to the left.\n     AlignLeft,\n@@ -111,7 +113,7 @@ pub enum Alignment {\n \n /// Various flags which can be applied to format strings. The meaning of these\n /// flags is defined by the formatters themselves.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Flag {\n     /// A `+` will be used to denote positive numbers.\n     FlagSignPlus,\n@@ -131,7 +133,7 @@ pub enum Flag {\n \n /// A count is used for the precision and width parameters of an integer, and\n /// can reference either an argument or a literal integer.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Count {\n     /// The count is specified explicitly.\n     CountIs(usize),\n@@ -475,6 +477,7 @@ impl<'a> Parser<'a> {\n             width: CountImplied,\n             width_span: None,\n             ty: &self.input[..0],\n+            ty_span: None,\n         };\n         if !self.consume(':') {\n             return spec;\n@@ -548,6 +551,7 @@ impl<'a> Parser<'a> {\n                 spec.precision_span = sp;\n             }\n         }\n+        let ty_span_start = self.cur.peek().map(|(pos, _)| *pos);\n         // Optional radix followed by the actual format specifier\n         if self.consume('x') {\n             if self.consume('?') {\n@@ -567,6 +571,12 @@ impl<'a> Parser<'a> {\n             spec.ty = \"?\";\n         } else {\n             spec.ty = self.word();\n+            let ty_span_end = self.cur.peek().map(|(pos, _)| *pos);\n+            if !spec.ty.is_empty() {\n+                spec.ty_span = ty_span_start\n+                    .and_then(|s| ty_span_end.map(|e| (s, e)))\n+                    .map(|(start, end)| self.to_span_index(start).to(self.to_span_index(end)));\n+            }\n         }\n         spec\n     }"}, {"sha": "81359033eda29f7aa64ab5dee11e28d125468cb4", "filename": "src/libfmt_macros/tests.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibfmt_macros%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibfmt_macros%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Ftests.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n fn same(fmt: &'static str, p: &[Piece<'static>]) {\n     let parser = Parser::new(fmt, None, vec![], false);\n-    assert!(parser.collect::<Vec<Piece<'static>>>() == p);\n+    assert_eq!(parser.collect::<Vec<Piece<'static>>>(), p);\n }\n \n fn fmtdflt() -> FormatSpec<'static> {\n@@ -15,6 +15,7 @@ fn fmtdflt() -> FormatSpec<'static> {\n         precision_span: None,\n         width_span: None,\n         ty: \"\",\n+        ty_span: None,\n     };\n }\n \n@@ -82,7 +83,7 @@ fn format_position_nothing_else() {\n #[test]\n fn format_type() {\n     same(\n-        \"{3:a}\",\n+        \"{3:x}\",\n         &[NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n@@ -93,7 +94,8 @@ fn format_type() {\n                 width: CountImplied,\n                 precision_span: None,\n                 width_span: None,\n-                ty: \"a\",\n+                ty: \"x\",\n+                ty_span: None,\n             },\n         })]);\n }\n@@ -112,6 +114,7 @@ fn format_align_fill() {\n                 precision_span: None,\n                 width_span: None,\n                 ty: \"\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n@@ -127,6 +130,7 @@ fn format_align_fill() {\n                 precision_span: None,\n                 width_span: None,\n                 ty: \"\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n@@ -142,6 +146,7 @@ fn format_align_fill() {\n                 precision_span: None,\n                 width_span: None,\n                 ty: \"abcd\",\n+                ty_span: Some(InnerSpan::new(6, 10)),\n             },\n         })]);\n }\n@@ -150,7 +155,7 @@ fn format_counts() {\n     use syntax_pos::{GLOBALS, Globals, edition};\n     GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n     same(\n-        \"{:10s}\",\n+        \"{:10x}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n             format: FormatSpec {\n@@ -161,11 +166,12 @@ fn format_counts() {\n                 width: CountIs(10),\n                 precision_span: None,\n                 width_span: None,\n-                ty: \"s\",\n+                ty: \"x\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n-        \"{:10$.10s}\",\n+        \"{:10$.10x}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n             format: FormatSpec {\n@@ -176,11 +182,12 @@ fn format_counts() {\n                 width: CountIsParam(10),\n                 precision_span: None,\n                 width_span: Some(InnerSpan::new(3, 6)),\n-                ty: \"s\",\n+                ty: \"x\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n-        \"{:.*s}\",\n+        \"{:.*x}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(1),\n             format: FormatSpec {\n@@ -191,11 +198,12 @@ fn format_counts() {\n                 width: CountImplied,\n                 precision_span: Some(InnerSpan::new(3, 5)),\n                 width_span: None,\n-                ty: \"s\",\n+                ty: \"x\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n-        \"{:.10$s}\",\n+        \"{:.10$x}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n             format: FormatSpec {\n@@ -206,11 +214,12 @@ fn format_counts() {\n                 width: CountImplied,\n                 precision_span: Some(InnerSpan::new(3, 7)),\n                 width_span: None,\n-                ty: \"s\",\n+                ty: \"x\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n-        \"{:a$.b$s}\",\n+        \"{:a$.b$?}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n             format: FormatSpec {\n@@ -221,7 +230,8 @@ fn format_counts() {\n                 width: CountIsName(Symbol::intern(\"a\")),\n                 precision_span: None,\n                 width_span: None,\n-                ty: \"s\",\n+                ty: \"?\",\n+                ty_span: None,\n             },\n         })]);\n     });\n@@ -241,6 +251,7 @@ fn format_flags() {\n                 precision_span: None,\n                 width_span: None,\n                 ty: \"\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n@@ -256,13 +267,14 @@ fn format_flags() {\n                 precision_span: None,\n                 width_span: None,\n                 ty: \"\",\n+                ty_span: None,\n             },\n         })]);\n }\n #[test]\n fn format_mixture() {\n     same(\n-        \"abcd {3:a} efg\",\n+        \"abcd {3:x} efg\",\n         &[\n             String(\"abcd \"),\n             NextArgument(Argument {\n@@ -275,7 +287,8 @@ fn format_mixture() {\n                     width: CountImplied,\n                     precision_span: None,\n                     width_span: None,\n-                    ty: \"a\",\n+                    ty: \"x\",\n+                    ty_span: None,\n                 },\n             }),\n             String(\" efg\"),"}, {"sha": "bd7b77b0abb17dd7ef69cbc9b3a8a7df59eee307", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -93,7 +93,7 @@ rustc_queries! {\n         /// Maps DefId's that have an associated `mir::Body` to the result\n         /// of the MIR qualify_consts pass. The actual meaning of\n         /// the value isn't known except to the pass itself.\n-        query mir_const_qualif(key: DefId) -> (u8, &'tcx BitSet<mir::Local>) {\n+        query mir_const_qualif(key: DefId) -> u8 {\n             desc { |tcx| \"const checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }"}, {"sha": "23c4ec062ea3f766980e588dee83d0a1e92661ca", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -2287,11 +2287,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     );\n                 }\n             }\n-            ObligationCauseCode::AssocTypeBound(impl_span, orig) => {\n-                err.span_label(orig, \"associated type defined here\");\n-                if let Some(sp) = impl_span {\n+            ObligationCauseCode::AssocTypeBound(ref data) => {\n+                err.span_label(data.original, \"associated type defined here\");\n+                if let Some(sp) = data.impl_span {\n                     err.span_label(sp, \"in this `impl` item\");\n                 }\n+                for sp in &data.bounds {\n+                    err.span_label(*sp, \"restricted in this bound\");\n+                }\n             }\n         }\n     }"}, {"sha": "a29d8c66d811d73842dda9872b740da5ba082c6c", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -276,7 +276,14 @@ pub enum ObligationCauseCode<'tcx> {\n     /// #[feature(trivial_bounds)] is not enabled\n     TrivialBound,\n \n-    AssocTypeBound(/*impl*/ Option<Span>, /*original*/ Span),\n+    AssocTypeBound(Box<AssocTypeBoundData>),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct AssocTypeBoundData {\n+    pub impl_span: Option<Span>,\n+    pub original: Span,\n+    pub bounds: Vec<Span>,\n }\n \n // `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger."}, {"sha": "59f2bb3754803e4690d68ddb3726cf008cac75eb", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -549,7 +549,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::MethodReceiver => Some(super::MethodReceiver),\n             super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n             super::TrivialBound => Some(super::TrivialBound),\n-            super::AssocTypeBound(impl_sp, sp) => Some(super::AssocTypeBound(impl_sp, sp)),\n+            super::AssocTypeBound(ref data) => Some(super::AssocTypeBound(data.clone())),\n         }\n     }\n }"}, {"sha": "0615004125b3ca94df1720fb94ca0241b1f96eb9", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -42,7 +42,6 @@ use crate::util::common::ErrorReported;\n use crate::util::profiling::ProfileCategory::*;\n \n use rustc_data_structures::svh::Svh;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_data_structures::fx::{FxIndexMap, FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::StableVec;"}, {"sha": "f9e7a8030a6fc6a50418c53c007fa58cb73df6dc", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 89, "deletions": 12, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -2,9 +2,10 @@ use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::InferCtxt;\n use crate::ty::subst::SubstsRef;\n-use crate::traits;\n+use crate::traits::{self, AssocTypeBoundData};\n use crate::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use std::iter::once;\n+use syntax::symbol::{kw, Ident};\n use syntax_pos::Span;\n use crate::middle::lang_items;\n use crate::mir::interpret::ConstValue;\n@@ -176,6 +177,23 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             pred: &ty::Predicate<'_>,\n             trait_assoc_items: ty::AssocItemsIterator<'_>,\n         | {\n+            let trait_item = tcx.hir().as_local_hir_id(trait_ref.def_id).and_then(|trait_id| {\n+                tcx.hir().find(trait_id)\n+            });\n+            let (trait_name, trait_generics) = match trait_item {\n+                Some(hir::Node::Item(hir::Item {\n+                    ident,\n+                    kind: hir::ItemKind::Trait(.., generics, _, _),\n+                    ..\n+                })) |\n+                Some(hir::Node::Item(hir::Item {\n+                    ident,\n+                    kind: hir::ItemKind::TraitAlias(generics, _),\n+                    ..\n+                })) => (Some(ident), Some(generics)),\n+                _ => (None, None),\n+            };\n+\n             let item_span = item.map(|i| tcx.sess.source_map().def_span(i.span));\n             match pred {\n                 ty::Predicate::Projection(proj) => {\n@@ -226,10 +244,11 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             item.ident == trait_assoc_item.ident\n                         }).next() {\n                             cause.span = impl_item.span;\n-                            cause.code = traits::AssocTypeBound(\n-                                item_span,\n-                                trait_assoc_item.ident.span,\n-                            );\n+                            cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n+                                impl_span: item_span,\n+                                original: trait_assoc_item.ident.span,\n+                                bounds: vec![],\n+                            }));\n                         }\n                     }\n                 }\n@@ -251,14 +270,13 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     //   LL |     type Assoc = bool;\n                     //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n                     //\n-                    // FIXME: if the obligation comes from the where clause in the `trait`, we\n-                    // should point at it:\n+                    // If the obligation comes from the where clause in the `trait`, we point at it:\n                     //\n                     //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n                     //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n                     //      |\n                     //      | trait Foo where <Self as Foo>>::Assoc: Bar {\n-                    //      |                 -------------------------- obligation set here\n+                    //      |                 -------------------------- restricted in this bound\n                     //   LL |     type Assoc;\n                     //      |          ----- associated type defined here\n                     //   ...\n@@ -278,11 +296,17 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                 .next()\n                                 .map(|impl_item| (impl_item, trait_assoc_item)))\n                         {\n+                            let bounds = trait_generics.map(|generics| get_generic_bound_spans(\n+                                &generics,\n+                                trait_name,\n+                                trait_assoc_item.ident,\n+                            )).unwrap_or_else(Vec::new);\n                             cause.span = impl_item.span;\n-                            cause.code = traits::AssocTypeBound(\n-                                item_span,\n-                                trait_assoc_item.ident.span,\n-                            );\n+                            cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n+                                impl_span: item_span,\n+                                original: trait_assoc_item.ident.span,\n+                                bounds,\n+                            }));\n                         }\n                     }\n                 }\n@@ -666,3 +690,56 @@ pub fn object_region_bounds<'tcx>(\n \n     tcx.required_region_bounds(open_ty, predicates)\n }\n+\n+/// Find the span of a generic bound affecting an associated type.\n+fn get_generic_bound_spans(\n+    generics: &hir::Generics,\n+    trait_name: Option<&Ident>,\n+    assoc_item_name: Ident,\n+) -> Vec<Span> {\n+    let mut bounds = vec![];\n+    for clause in generics.where_clause.predicates.iter() {\n+        if let hir::WherePredicate::BoundPredicate(pred) = clause {\n+            match &pred.bounded_ty.kind {\n+                hir::TyKind::Path(hir::QPath::Resolved(Some(ty), path)) => {\n+                    let mut s = path.segments.iter();\n+                    if let (a, Some(b), None) = (s.next(), s.next(), s.next()) {\n+                        if a.map(|s| &s.ident) == trait_name\n+                            && b.ident == assoc_item_name\n+                            && is_self_path(&ty.kind)\n+                        {\n+                            // `<Self as Foo>::Bar`\n+                            bounds.push(pred.span);\n+                        }\n+                    }\n+                }\n+                hir::TyKind::Path(hir::QPath::TypeRelative(ty, segment)) => {\n+                    if segment.ident == assoc_item_name {\n+                        if is_self_path(&ty.kind) {\n+                            // `Self::Bar`\n+                            bounds.push(pred.span);\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+    bounds\n+}\n+\n+fn is_self_path(kind: &hir::TyKind) -> bool {\n+    match kind {\n+        hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n+            let mut s = path.segments.iter();\n+            if let (Some(segment), None) = (s.next(), s.next()) {\n+                if segment.ident.name == kw::SelfUpper {\n+                    // `type(Self)`\n+                    return true;\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+    false\n+}"}, {"sha": "339a10f9140446f9b5ab7db9aa91c236c2a68831", "filename": "src/librustc_driver/args.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_driver%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_driver%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fargs.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -3,22 +3,12 @@ use std::fmt;\n use std::fs;\n use std::io;\n use std::str;\n-use std::sync::atomic::{AtomicBool, Ordering};\n-\n-static USED_ARGSFILE_FEATURE: AtomicBool = AtomicBool::new(false);\n-\n-pub fn used_unstable_argsfile() -> bool {\n-    USED_ARGSFILE_FEATURE.load(Ordering::Relaxed)\n-}\n \n pub fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n     if arg.starts_with(\"@\") {\n         let path = &arg[1..];\n         let file = match fs::read_to_string(path) {\n-            Ok(file) => {\n-                USED_ARGSFILE_FEATURE.store(true, Ordering::Relaxed);\n-                file\n-            }\n+            Ok(file) => file,\n             Err(ref err) if err.kind() == io::ErrorKind::InvalidData => {\n                 return Err(Error::Utf8Error(Some(path.to_string())));\n             }"}, {"sha": "47acf387f35c7447b601be7f106314462d822d29", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -1044,12 +1044,6 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     //   (unstable option being used on stable)\n     nightly_options::check_nightly_options(&matches, &config::rustc_optgroups());\n \n-    // Late check to see if @file was used without unstable options enabled\n-    if crate::args::used_unstable_argsfile() && !nightly_options::is_unstable_enabled(&matches) {\n-        early_error(ErrorOutputType::default(),\n-            \"@path is unstable - use -Z unstable-options to enable its use\");\n-    }\n-\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         // Only show unstable options in --help if we accept unstable options.\n         usage(matches.opt_present(\"verbose\"), nightly_options::is_unstable_enabled(&matches));"}, {"sha": "1118162bdeb021940ca6a3200ba312ace7e06640", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -32,7 +32,6 @@ use syntax::parse::parser::emit_unclosed_delims;\n use syntax::source_map::Spanned;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, FileName};\n-use rustc_index::bit_set::BitSet;\n \n macro_rules! provide {\n     (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident,\n@@ -122,9 +121,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n     promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n-    mir_const_qualif => {\n-        (cdata.mir_const_qualif(def_id.index), tcx.arena.alloc(BitSet::new_empty(0)))\n-    }\n+    mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n     is_const_fn_raw => { cdata.is_const_fn_raw(def_id.index) }"}, {"sha": "ad1ab16a410744d9477fa85f07853c6e394e0a27", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -955,7 +955,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.kind[def_id] <- match impl_item.kind {\n             ty::AssocKind::Const => {\n                 if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n-                    let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id).0;\n+                    let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id);\n \n                     EntryKind::AssocConst(container,\n                         ConstQualif { mir },\n@@ -1089,7 +1089,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n-                let mir = self.tcx.at(item.span).mir_const_qualif(def_id).0;\n+                let mir = self.tcx.at(item.span).mir_const_qualif(def_id);\n                 EntryKind::Const(\n                     ConstQualif { mir },\n                     self.encode_rendered_const_for_body(body_id)\n@@ -1368,7 +1368,7 @@ impl EncodeContext<'tcx> {\n         let id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n         let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n-        let mir = self.tcx.mir_const_qualif(def_id).0;\n+        let mir = self.tcx.mir_const_qualif(def_id);\n \n         record!(self.per_def.kind[def_id] <- EntryKind::Const(ConstQualif { mir }, const_data));\n         record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);"}, {"sha": "496a56790679b41d922570682f157f1e6b91bb01", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -123,7 +123,7 @@ pub trait Qualif {\n                     if cx.tcx.trait_of_item(def_id).is_some() {\n                         Self::in_any_value_of_ty(cx, constant.literal.ty)\n                     } else {\n-                        let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        let bits = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n \n                         let qualif = QualifSet(bits).contains::<Self>();\n "}, {"sha": "6d6d6bea2a0eabb868939975477a6ae6a32b4d09", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -210,13 +210,14 @@ fn mir_validated(\n     }\n \n     let mut body = tcx.mir_const(def_id).steal();\n-    let qualify_and_promote_pass = qualify_consts::QualifyAndPromoteConstants::default();\n+    let promote_pass = promote_consts::PromoteTemps::default();\n     run_passes(tcx, &mut body, InstanceDef::Item(def_id), None, MirPhase::Validated, &[\n         // What we need to run borrowck etc.\n-        &qualify_and_promote_pass,\n+        &qualify_consts::QualifyAndPromoteConstants::default(),\n+        &promote_pass,\n         &simplify::SimplifyCfg::new(\"qualify-consts\"),\n     ]);\n-    let promoted = qualify_and_promote_pass.promoted.into_inner();\n+    let promoted = promote_pass.promoted_fragments.into_inner();\n     (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n }\n "}, {"sha": "48a58f1d0ee57a9adcfa37ebfdcc248fde334084", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 138, "deletions": 2, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -17,20 +17,76 @@ use rustc::mir::*;\n use rustc::mir::interpret::ConstValue;\n use rustc::mir::visit::{PlaceContext, MutatingUseContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::ty::{self, List, TyCtxt};\n+use rustc::ty::{self, List, TyCtxt, TypeFoldable};\n use rustc::ty::subst::InternalSubsts;\n use rustc::ty::cast::CastTy;\n use syntax::ast::LitKind;\n use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc_index::vec::{IndexVec, Idx};\n+use rustc_index::bit_set::HybridBitSet;\n use rustc_target::spec::abi::Abi;\n \n+use std::cell::Cell;\n use std::{iter, mem, usize};\n \n+use crate::transform::{MirPass, MirSource};\n use crate::transform::check_consts::{qualifs, Item, ConstKind, is_lang_panic_fn};\n \n+/// A `MirPass` for promotion.\n+///\n+/// In this case, \"promotion\" entails the following:\n+/// - Extract promotable temps in `fn` and `const fn` into their own MIR bodies.\n+/// - Extend lifetimes in `const` and `static` by removing `Drop` and `StorageDead`.\n+/// - Emit errors if the requirements of `#[rustc_args_required_const]` are not met.\n+///\n+/// After this pass is run, `promoted_fragments` will hold the MIR body corresponding to each\n+/// newly created `StaticKind::Promoted`.\n+#[derive(Default)]\n+pub struct PromoteTemps<'tcx> {\n+    pub promoted_fragments: Cell<IndexVec<Promoted, Body<'tcx>>>,\n+}\n+\n+impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        // There's not really any point in promoting errorful MIR.\n+        //\n+        // This does not include MIR that failed const-checking, which we still try to promote.\n+        if body.return_ty().references_error() {\n+            tcx.sess.delay_span_bug(body.span, \"PromoteTemps: MIR had errors\");\n+            return;\n+        }\n+\n+        if src.promoted.is_some() {\n+            return;\n+        }\n+\n+        let def_id = src.def_id();\n+\n+        let item = Item::new(tcx, def_id, body);\n+        let mut rpo = traversal::reverse_postorder(body);\n+        let (temps, all_candidates) = collect_temps_and_candidates(tcx, body, &mut rpo);\n+\n+        let promotable_candidates = validate_candidates(tcx, body, def_id, &temps, &all_candidates);\n+\n+        // For now, lifetime extension is done in `const` and `static`s without creating promoted\n+        // MIR fragments by removing `Drop` and `StorageDead` for each referent. However, this will\n+        // not work inside loops when they are allowed in `const`s.\n+        //\n+        // FIXME: use promoted MIR fragments everywhere?\n+        let promoted_fragments = if should_create_promoted_mir_fragments(item.const_kind) {\n+            promote_candidates(def_id, body, tcx, temps, promotable_candidates)\n+        } else {\n+            // FIXME: promote const array initializers in consts.\n+            remove_drop_and_storage_dead_on_promoted_locals(tcx, body, &promotable_candidates);\n+            IndexVec::new()\n+        };\n+\n+        self.promoted_fragments.set(promoted_fragments);\n+    }\n+}\n+\n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TempState {\n@@ -538,7 +594,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         // is gone - we can always promote constants even if they\n                         // fail to pass const-checking, as compilation would've\n                         // errored independently and promotion can't change that.\n-                        let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        let bits = self.tcx.at(constant.span).mir_const_qualif(def_id);\n                         if bits == super::qualify_consts::QUALIF_ERROR_BIT {\n                             self.tcx.sess.delay_span_bug(\n                                 constant.span,\n@@ -1154,3 +1210,83 @@ crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n             should_promote={:?} feature_flag={:?}\", mir_def_id, should_promote, feature_flag);\n     should_promote && !feature_flag\n }\n+\n+fn should_create_promoted_mir_fragments(const_kind: Option<ConstKind>) -> bool {\n+    match const_kind {\n+        Some(ConstKind::ConstFn) | None => true,\n+        Some(ConstKind::Const) | Some(ConstKind::Static) | Some(ConstKind::StaticMut) => false,\n+    }\n+}\n+\n+/// In `const` and `static` everything without `StorageDead`\n+/// is `'static`, we don't have to create promoted MIR fragments,\n+/// just remove `Drop` and `StorageDead` on \"promoted\" locals.\n+fn remove_drop_and_storage_dead_on_promoted_locals(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    promotable_candidates: &[Candidate],\n+) {\n+    debug!(\"run_pass: promotable_candidates={:?}\", promotable_candidates);\n+\n+    // Removing `StorageDead` will cause errors for temps declared inside a loop body. For now we\n+    // simply skip promotion if a loop exists, since loops are not yet allowed in a `const`.\n+    //\n+    // FIXME: Just create MIR fragments for `const`s instead of using this hackish approach?\n+    if body.is_cfg_cyclic() {\n+        tcx.sess.delay_span_bug(body.span, \"Control-flow cycle detected in `const`\");\n+        return;\n+    }\n+\n+    // The underlying local for promotion contexts like `&temp` and `&(temp.proj)`.\n+    let mut requires_lifetime_extension = HybridBitSet::new_empty(body.local_decls.len());\n+\n+    promotable_candidates\n+        .iter()\n+        .filter_map(|c| {\n+            match c {\n+                Candidate::Ref(loc) => Some(loc),\n+                Candidate::Repeat(_) | Candidate::Argument { .. } => None,\n+            }\n+        })\n+        .map(|&Location { block, statement_index }| {\n+            // FIXME: store the `Local` for each `Candidate` when it is created.\n+            let place = match &body[block].statements[statement_index].kind {\n+                StatementKind::Assign(box ( _, Rvalue::Ref(_, _, place))) => place,\n+                _ => bug!(\"`Candidate::Ref` without corresponding assignment\"),\n+            };\n+\n+            match place.base {\n+                PlaceBase::Local(local) => local,\n+                PlaceBase::Static(_) => bug!(\"`Candidate::Ref` for a non-local\"),\n+            }\n+        })\n+        .for_each(|local| {\n+            requires_lifetime_extension.insert(local);\n+        });\n+\n+    // Remove `Drop` terminators and `StorageDead` statements for all promotable temps that require\n+    // lifetime extension.\n+    for block in body.basic_blocks_mut() {\n+        block.statements.retain(|statement| {\n+            match statement.kind {\n+                StatementKind::StorageDead(index) => !requires_lifetime_extension.contains(index),\n+                _ => true\n+            }\n+        });\n+        let terminator = block.terminator_mut();\n+        match &terminator.kind {\n+            TerminatorKind::Drop {\n+                location,\n+                target,\n+                ..\n+            } => {\n+                if let Some(index) = location.as_local() {\n+                    if requires_lifetime_extension.contains(index) {\n+                        terminator.kind = TerminatorKind::Goto { target: *target };\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "5ad5363768d34a3142480b24f514020470b14e97", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 25, "deletions": 148, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -15,7 +15,6 @@ use rustc::ty::cast::CastTy;\n use rustc::ty::query::Providers;\n use rustc::mir::*;\n use rustc::mir::interpret::ConstValue;\n-use rustc::mir::traversal::ReversePostorder;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::middle::lang_items;\n use rustc::session::config::nightly_options;\n@@ -31,7 +30,6 @@ use std::usize;\n \n use rustc::hir::HirId;\n use crate::transform::{MirPass, MirSource};\n-use super::promote_consts::{self, Candidate, TempState};\n use crate::transform::check_consts::ops::{self, NonConstOp};\n \n /// What kind of item we are in.\n@@ -258,7 +256,7 @@ trait Qualif {\n                     if cx.tcx.trait_of_item(def_id).is_some() {\n                         Self::in_any_value_of_ty(cx, constant.literal.ty).unwrap_or(false)\n                     } else {\n-                        let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        let bits = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n \n                         let qualif = PerQualif::decode_from_bits(bits).0[Self::IDX];\n \n@@ -477,10 +475,6 @@ struct Checker<'a, 'tcx> {\n \n     span: Span,\n     def_id: DefId,\n-    rpo: ReversePostorder<'a, 'tcx>,\n-\n-    temp_promotion_state: IndexVec<Local, TempState>,\n-    unchecked_promotion_candidates: Vec<Candidate>,\n \n     /// If `true`, do not emit errors to the user, merely collect them in `errors`.\n     suppress_errors: bool,\n@@ -509,10 +503,6 @@ impl Deref for Checker<'a, 'tcx> {\n impl<'a, 'tcx> Checker<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>, mode: Mode) -> Self {\n         assert!(def_id.is_local());\n-        let mut rpo = traversal::reverse_postorder(body);\n-        let (temps, unchecked_promotion_candidates) =\n-            promote_consts::collect_temps_and_candidates(tcx, body, &mut rpo);\n-        rpo.reset();\n \n         let param_env = tcx.param_env(def_id);\n \n@@ -539,9 +529,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             cx,\n             span: body.span,\n             def_id,\n-            rpo,\n-            temp_promotion_state: temps,\n-            unchecked_promotion_candidates,\n             errors: vec![],\n             suppress_errors: false,\n         }\n@@ -662,14 +649,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         let kind = self.body.local_kind(index);\n         debug!(\"store to {:?} {:?}\", kind, index);\n \n-        // Only handle promotable temps in non-const functions.\n-        if self.mode == Mode::NonConstFn {\n-            if kind != LocalKind::Temp ||\n-               !self.temp_promotion_state[index].is_promotable() {\n-                return;\n-            }\n-        }\n-\n         // this is overly restrictive, because even full assignments do not clear the qualif\n         // While we could special case full assignments, this would be inconsistent with\n         // aggregates where we overwrite all fields via assignments, which would not get\n@@ -682,7 +661,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     }\n \n     /// Check a whole const, static initializer or const fn.\n-    fn check_const(&mut self) -> (u8, &'tcx BitSet<Local>) {\n+    fn check_const(&mut self) -> u8 {\n         use crate::transform::check_consts as new_checker;\n \n         debug!(\"const-checking {} {:?}\", self.mode, self.def_id);\n@@ -704,7 +683,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         let mut seen_blocks = BitSet::new_empty(body.basic_blocks().len());\n         let mut bb = START_BLOCK;\n-        let mut has_controlflow_error = false;\n         loop {\n             seen_blocks.insert(bb.index());\n \n@@ -745,7 +723,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     bb = target;\n                 }\n                 _ => {\n-                    has_controlflow_error = true;\n                     self.not_const(ops::Loop);\n                     validator.check_op(ops::Loop);\n                     break;\n@@ -772,51 +749,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             }\n         }\n \n-        // Collect all the temps we need to promote.\n-        let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n-\n-        // HACK: if parts of the control-flow graph were skipped due to an error, don't try to\n-        // promote anything, since that can cause errors in a `const` if e.g. rvalue static\n-        // promotion is attempted within a loop body.\n-        let unleash_miri = self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n-        let promotion_candidates = if has_controlflow_error && !unleash_miri {\n-            self.tcx.sess.delay_span_bug(\n-                body.span,\n-                \"check_const: expected control-flow error(s)\",\n-            );\n-\n-            vec![]\n-        } else {\n-            promote_consts::validate_candidates(\n-                self.tcx,\n-                self.body,\n-                self.def_id,\n-                &self.temp_promotion_state,\n-                &self.unchecked_promotion_candidates,\n-            )\n-        };\n-\n-        debug!(\"qualify_const: promotion_candidates={:?}\", promotion_candidates);\n-        for candidate in promotion_candidates {\n-            match candidate {\n-                Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n-                    if let StatementKind::Assign(box( _, Rvalue::Ref(_, _, place)))\n-                        = &self.body[bb].statements[stmt_idx].kind\n-                    {\n-                        if let PlaceBase::Local(local) = place.base {\n-                            promoted_temps.insert(local);\n-                        }\n-                    }\n-                }\n-\n-                // Only rvalue-static promotion requires extending the lifetime of the promoted\n-                // local.\n-                Candidate::Argument { .. } | Candidate::Repeat(_) => {}\n-            }\n-        }\n-\n-        let qualifs = self.qualifs_in_local(RETURN_PLACE);\n-        (qualifs.encode_to_bits(), self.tcx.arena.alloc(promoted_temps))\n+        self.qualifs_in_local(RETURN_PLACE).encode_to_bits()\n     }\n }\n \n@@ -1346,7 +1279,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n // in `promote_consts`, see the comment in `validate_operand`.\n pub(super) const QUALIF_ERROR_BIT: u8 = 1 << 2;\n \n-fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n+fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> u8 {\n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n@@ -1355,7 +1288,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n \n     if body.return_ty().references_error() {\n         tcx.sess.delay_span_bug(body.span, \"mir_const_qualif: MIR had errors\");\n-        return (QUALIF_ERROR_BIT, tcx.arena.alloc(BitSet::new_empty(0)));\n+        return QUALIF_ERROR_BIT;\n     }\n \n     Checker::new(tcx, def_id, body, Mode::Const).check_const()\n@@ -1391,56 +1324,34 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants<'tcx> {\n         let mode = determine_mode(tcx, hir_id, def_id);\n \n         debug!(\"run_pass: mode={:?}\", mode);\n-        if let Mode::NonConstFn | Mode::ConstFn = mode {\n+        if let Mode::NonConstFn = mode {\n+            // No need to const-check a non-const `fn` now that we don't do promotion here.\n+            return;\n+        } else if let Mode::ConstFn = mode {\n             let mut checker = Checker::new(tcx, def_id, body, mode);\n-            if let Mode::ConstFn = mode {\n-                let use_min_const_fn_checks =\n-                    !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n-                    tcx.is_min_const_fn(def_id);\n-                if use_min_const_fn_checks {\n-                    // Enforce `min_const_fn` for stable `const fn`s.\n-                    use super::qualify_min_const_fn::is_min_const_fn;\n-                    if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n-                        error_min_const_fn_violation(tcx, span, err);\n-                        return;\n-                    }\n-\n-                    // `check_const` should not produce any errors, but better safe than sorry\n-                    // FIXME(#53819)\n-                    // NOTE(eddyb) `check_const` is actually needed for promotion inside\n-                    // `min_const_fn` functions.\n-                }\n-\n-                // Enforce a constant-like CFG for `const fn`.\n-                checker.check_const();\n-            } else {\n-                while let Some((bb, data)) = checker.rpo.next() {\n-                    checker.visit_basic_block_data(bb, data);\n+            let use_min_const_fn_checks =\n+                !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n+                tcx.is_min_const_fn(def_id);\n+            if use_min_const_fn_checks {\n+                // Enforce `min_const_fn` for stable `const fn`s.\n+                use super::qualify_min_const_fn::is_min_const_fn;\n+                if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n+                    error_min_const_fn_violation(tcx, span, err);\n+                    return;\n                 }\n             }\n \n-            // Promote only the promotable candidates.\n-            let temps = checker.temp_promotion_state;\n-            let candidates = promote_consts::validate_candidates(\n-                tcx,\n-                body,\n-                def_id,\n-                &temps,\n-                &checker.unchecked_promotion_candidates,\n-            );\n-\n-            // Do the actual promotion, now that we know what's viable.\n-            self.promoted.set(\n-                promote_consts::promote_candidates(def_id, body, tcx, temps, candidates)\n-            );\n+            // `check_const` should not produce any errors, but better safe than sorry\n+            // FIXME(#53819)\n+            // Enforce a constant-like CFG for `const fn`.\n+            checker.check_const();\n         } else {\n             check_short_circuiting_in_const_local(tcx, body, mode);\n \n-            let promoted_temps = match mode {\n-                Mode::Const => tcx.mir_const_qualif(def_id).1,\n-                _ => Checker::new(tcx, def_id, body, mode).check_const().1,\n+            match mode {\n+                Mode::Const => tcx.mir_const_qualif(def_id),\n+                _ => Checker::new(tcx, def_id, body, mode).check_const(),\n             };\n-            remove_drop_and_storage_dead_on_promoted_locals(body, promoted_temps);\n         }\n \n         if mode == Mode::Static && !tcx.has_attr(def_id, sym::thread_local) {\n@@ -1501,40 +1412,6 @@ fn check_short_circuiting_in_const_local(tcx: TyCtxt<'_>, body: &mut Body<'tcx>,\n     }\n }\n \n-/// In `const` and `static` everything without `StorageDead`\n-/// is `'static`, we don't have to create promoted MIR fragments,\n-/// just remove `Drop` and `StorageDead` on \"promoted\" locals.\n-fn remove_drop_and_storage_dead_on_promoted_locals(\n-    body: &mut Body<'tcx>,\n-    promoted_temps: &BitSet<Local>,\n-) {\n-    debug!(\"run_pass: promoted_temps={:?}\", promoted_temps);\n-\n-    for block in body.basic_blocks_mut() {\n-        block.statements.retain(|statement| {\n-            match statement.kind {\n-                StatementKind::StorageDead(index) => !promoted_temps.contains(index),\n-                _ => true\n-            }\n-        });\n-        let terminator = block.terminator_mut();\n-        match &terminator.kind {\n-            TerminatorKind::Drop {\n-                location,\n-                target,\n-                ..\n-            } => {\n-                if let Some(index) = location.as_local() {\n-                    if promoted_temps.contains(index) {\n-                        terminator.kind = TerminatorKind::Goto { target: *target };\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n fn check_static_is_sync(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, hir_id: HirId) {\n     let ty = body.return_ty();\n     tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "aced12aa32acba0c266d785e920907e38be0a9a8", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -554,7 +554,7 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             \"arm\" => arm::compute_abi_info(cx, self),\n             \"mips\" => mips::compute_abi_info(cx, self),\n             \"mips64\" => mips64::compute_abi_info(cx, self),\n-            \"powerpc\" => powerpc::compute_abi_info(cx, self),\n+            \"powerpc\" => powerpc::compute_abi_info(self),\n             \"powerpc64\" => powerpc64::compute_abi_info(cx, self),\n             \"s390x\" => s390x::compute_abi_info(cx, self),\n             \"msp430\" => msp430::compute_abi_info(self),"}, {"sha": "740bd7222f237034bbcc7a6d6dbbd430a71b6980", "filename": "src/librustc_target/abi/call/powerpc.rs", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -1,49 +1,28 @@\n-use crate::abi::call::{ArgAbi, FnAbi, Reg, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n+use crate::abi::call::{ArgAbi, FnAbi};\n \n-fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n-    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n-{\n-    if !ret.layout.is_aggregate() {\n-        ret.extend_integer_width_to(32);\n-    } else {\n+fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n+    if ret.layout.is_aggregate() {\n         ret.make_indirect();\n-        *offset += cx.data_layout().pointer_size;\n+    } else {\n+        ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n-    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n-{\n-    let dl = cx.data_layout();\n-    let size = arg.layout.size;\n-    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align).abi;\n-\n+fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n     if arg.layout.is_aggregate() {\n-        arg.cast_to(Uniform {\n-            unit: Reg::i32(),\n-            total: size\n-        });\n-        if !offset.is_aligned(align) {\n-            arg.pad_with(Reg::i32());\n-        }\n+        arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n-\n-    *offset = offset.align_to(align) + size.align_to(align);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'_, Ty>)\n-    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n-{\n-    let mut offset = Size::ZERO;\n+pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n     if !fn_abi.ret.is_ignore() {\n-        classify_ret(cx, &mut fn_abi.ret, &mut offset);\n+        classify_ret(&mut fn_abi.ret);\n     }\n \n     for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg(cx, arg, &mut offset);\n+        classify_arg(arg);\n     }\n }"}, {"sha": "25daca9237fd6aa6466d66d352643778e6d68b81", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 55, "deletions": 33, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -21,7 +21,7 @@ use std::collections::hash_map::Entry;\n \n #[derive(PartialEq)]\n enum ArgumentType {\n-    Placeholder(String),\n+    Placeholder(&'static str),\n     Count,\n }\n \n@@ -244,7 +244,57 @@ impl<'a, 'b> Context<'a, 'b> {\n                     parse::ArgumentNamed(s) => Named(s),\n                 };\n \n-                let ty = Placeholder(arg.format.ty.to_string());\n+                let ty = Placeholder(match &arg.format.ty[..] {\n+                    \"\" => \"Display\",\n+                    \"?\" => \"Debug\",\n+                    \"e\" => \"LowerExp\",\n+                    \"E\" => \"UpperExp\",\n+                    \"o\" => \"Octal\",\n+                    \"p\" => \"Pointer\",\n+                    \"b\" => \"Binary\",\n+                    \"x\" => \"LowerHex\",\n+                    \"X\" => \"UpperHex\",\n+                    _ => {\n+                        let fmtsp = self.fmtsp;\n+                        let sp = arg.format.ty_span.map(|sp| fmtsp.from_inner(sp));\n+                        let mut err = self.ecx.struct_span_err(\n+                            sp.unwrap_or(fmtsp),\n+                            &format!(\"unknown format trait `{}`\", arg.format.ty),\n+                        );\n+                        err.note(\"the only appropriate formatting traits are:\\n\\\n+                                - ``, which uses the `Display` trait\\n\\\n+                                - `?`, which uses the `Debug` trait\\n\\\n+                                - `e`, which uses the `LowerExp` trait\\n\\\n+                                - `E`, which uses the `UpperExp` trait\\n\\\n+                                - `o`, which uses the `Octal` trait\\n\\\n+                                - `p`, which uses the `Pointer` trait\\n\\\n+                                - `b`, which uses the `Binary` trait\\n\\\n+                                - `x`, which uses the `LowerHex` trait\\n\\\n+                                - `X`, which uses the `UpperHex` trait\");\n+                        if let Some(sp) = sp {\n+                            for (fmt, name) in &[\n+                                (\"\", \"Display\"),\n+                                (\"?\", \"Debug\"),\n+                                (\"e\", \"LowerExp\"),\n+                                (\"E\", \"UpperExp\"),\n+                                (\"o\", \"Octal\"),\n+                                (\"p\", \"Pointer\"),\n+                                (\"b\", \"Binary\"),\n+                                (\"x\", \"LowerHex\"),\n+                                (\"X\", \"UpperHex\"),\n+                            ] {\n+                                err.tool_only_span_suggestion(\n+                                    sp,\n+                                    &format!(\"use the `{}` trait\", name),\n+                                    fmt.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                        }\n+                        err.emit();\n+                        \"<invalid>\"\n+                    }\n+                });\n                 self.verify_arg_type(pos, ty);\n                 self.curpiece += 1;\n             }\n@@ -590,6 +640,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                         width: parse::CountImplied,\n                         width_span: None,\n                         ty: arg.format.ty,\n+                        ty_span: arg.format.ty_span,\n                     },\n                 };\n \n@@ -761,37 +812,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         sp = ecx.with_def_site_ctxt(sp);\n         let arg = ecx.expr_ident(sp, arg);\n         let trait_ = match *ty {\n-            Placeholder(ref tyname) => {\n-                match &tyname[..] {\n-                    \"\" => \"Display\",\n-                    \"?\" => \"Debug\",\n-                    \"e\" => \"LowerExp\",\n-                    \"E\" => \"UpperExp\",\n-                    \"o\" => \"Octal\",\n-                    \"p\" => \"Pointer\",\n-                    \"b\" => \"Binary\",\n-                    \"x\" => \"LowerHex\",\n-                    \"X\" => \"UpperHex\",\n-                    _ => {\n-                        let mut err = ecx.struct_span_err(\n-                            sp,\n-                            &format!(\"unknown format trait `{}`\", *tyname),\n-                        );\n-                        err.note(\"the only appropriate formatting traits are:\\n\\\n-                                  - ``, which uses the `Display` trait\\n\\\n-                                  - `?`, which uses the `Debug` trait\\n\\\n-                                  - `e`, which uses the `LowerExp` trait\\n\\\n-                                  - `E`, which uses the `UpperExp` trait\\n\\\n-                                  - `o`, which uses the `Octal` trait\\n\\\n-                                  - `p`, which uses the `Pointer` trait\\n\\\n-                                  - `b`, which uses the `Binary` trait\\n\\\n-                                  - `x`, which uses the `LowerHex` trait\\n\\\n-                                  - `X`, which uses the `UpperHex` trait\");\n-                        err.emit();\n-                        return DummyResult::raw_expr(sp, true);\n-                    }\n-                }\n-            }\n+            Placeholder(trait_) if trait_ == \"<invalid>\" => return DummyResult::raw_expr(sp, true),\n+            Placeholder(trait_) => trait_,\n             Count => {\n                 let path = ecx.std_path(&[sym::fmt, sym::ArgumentV1, sym::from_usize]);\n                 return ecx.expr_call_global(macsp, path, vec![arg]);"}, {"sha": "648856b5523d318df57e3db964064eaef656306c", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -39,7 +39,7 @@ fn main() {\n \n // END RUST SOURCE\n //\n-// START rustc.full_tested_match.QualifyAndPromoteConstants.after.mir\n+// START rustc.full_tested_match.PromoteTemps.after.mir\n //  bb0: {\n //      ...\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n@@ -108,9 +108,9 @@ fn main() {\n //      _0 = ();\n //      return;\n //  }\n-// END rustc.full_tested_match.QualifyAndPromoteConstants.after.mir\n+// END rustc.full_tested_match.PromoteTemps.after.mir\n //\n-// START rustc.full_tested_match2.QualifyAndPromoteConstants.before.mir\n+// START rustc.full_tested_match2.PromoteTemps.before.mir\n //  bb0: {\n //      ...\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n@@ -179,9 +179,9 @@ fn main() {\n //      _0 = ();\n //      return;\n //  }\n-// END rustc.full_tested_match2.QualifyAndPromoteConstants.before.mir\n+// END rustc.full_tested_match2.PromoteTemps.before.mir\n //\n-// START rustc.main.QualifyAndPromoteConstants.before.mir\n+// START rustc.main.PromoteTemps.before.mir\n //  bb0: {\n //     ...\n //      _2 = std::option::Option::<i32>::Some(const 1i32,);\n@@ -276,4 +276,4 @@ fn main() {\n //      _0 = ();\n //      return;\n //  }\n-// END rustc.main.QualifyAndPromoteConstants.before.mir\n+// END rustc.main.PromoteTemps.before.mir"}, {"sha": "67b7c78071c378af04253c203f6e6b2fe652878e", "filename": "src/test/ui/associated-types/point-at-type-on-obligation-failure-2.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -8,4 +8,20 @@ impl Foo for () {\n     type Assoc = bool; //~ ERROR the trait bound `bool: Bar` is not satisfied\n }\n \n+trait Baz where Self::Assoc: Bar {\n+    type Assoc;\n+}\n+\n+impl Baz for () {\n+    type Assoc = bool; //~ ERROR the trait bound `bool: Bar` is not satisfied\n+}\n+\n+trait Bat where <Self as Bat>::Assoc: Bar {\n+    type Assoc;\n+}\n+\n+impl Bat for () {\n+    type Assoc = bool; //~ ERROR the trait bound `bool: Bar` is not satisfied\n+}\n+\n fn main() {}"}, {"sha": "072e9dad062e069868e3e0df47735efc1c0509ed", "filename": "src/test/ui/associated-types/point-at-type-on-obligation-failure-2.stderr", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.stderr?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -9,6 +9,32 @@ LL | impl Foo for () {\n LL |     type Assoc = bool;\n    |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n \n-error: aborting due to previous error\n+error[E0277]: the trait bound `bool: Bar` is not satisfied\n+  --> $DIR/point-at-type-on-obligation-failure-2.rs:16:5\n+   |\n+LL | trait Baz where Self::Assoc: Bar {\n+   |                 ---------------- restricted in this bound\n+LL |     type Assoc;\n+   |          ----- associated type defined here\n+...\n+LL | impl Baz for () {\n+   | --------------- in this `impl` item\n+LL |     type Assoc = bool;\n+   |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n+\n+error[E0277]: the trait bound `bool: Bar` is not satisfied\n+  --> $DIR/point-at-type-on-obligation-failure-2.rs:24:5\n+   |\n+LL | trait Bat where <Self as Bat>::Assoc: Bar {\n+   |                 ------------------------- restricted in this bound\n+LL |     type Assoc;\n+   |          ----- associated type defined here\n+...\n+LL | impl Bat for () {\n+   | --------------- in this `impl` item\n+LL |     type Assoc = bool;\n+   |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "db68a05905a144ba8da92d365e6591521a368fcc", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -136,7 +136,6 @@ const fn no_rpit() -> impl std::fmt::Debug {} //~ ERROR `impl Trait` in const fn\n const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n //~^ ERROR trait bounds other than `Sized`\n-//~| ERROR cannot return reference to temporary value\n \n const fn no_unsafe() { unsafe {} }\n "}, {"sha": "64b2ce83da2f84a2208b0a50f9dd87363a5c392f", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -286,17 +286,8 @@ LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0515]: cannot return reference to temporary value\n-  --> $DIR/min_const_fn.rs:137:63\n-   |\n-LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n-   |                                                               ^--\n-   |                                                               ||\n-   |                                                               |temporary value created here\n-   |                                                               returns a reference to data owned by the current function\n-\n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:143:41\n+  --> $DIR/min_const_fn.rs:142:41\n    |\n LL | const fn really_no_traits_i_mean_it() { (&() as &dyn std::fmt::Debug, ()).1 }\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -305,7 +296,7 @@ LL | const fn really_no_traits_i_mean_it() { (&() as &dyn std::fmt::Debug, ()).1\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n-  --> $DIR/min_const_fn.rs:146:21\n+  --> $DIR/min_const_fn.rs:145:21\n    |\n LL | const fn no_fn_ptrs(_x: fn()) {}\n    |                     ^^\n@@ -314,15 +305,15 @@ LL | const fn no_fn_ptrs(_x: fn()) {}\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n-  --> $DIR/min_const_fn.rs:148:27\n+  --> $DIR/min_const_fn.rs:147:27\n    |\n LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n    |                           ^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error: aborting due to 37 previous errors\n+error: aborting due to 36 previous errors\n \n-Some errors have detailed explanations: E0493, E0515, E0723.\n+Some errors have detailed explanations: E0493, E0723.\n For more information about an error, try `rustc --explain E0493`."}, {"sha": "6ca1e59b3af106815ab316f2ceb094b9a3e6084a", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_dyn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.rs?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -11,6 +11,5 @@ const fn no_inner_dyn_trait2(x: Hide) {\n }\n const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n //~^ ERROR trait bounds other than `Sized`\n-//~| ERROR temporary value dropped while borrowed\n \n fn main() {}"}, {"sha": "e20b4f9dcb47137bdb2ffb393a9aad69743ea25c", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_dyn.stderr", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -16,16 +16,6 @@ LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/min_const_fn_dyn.rs:12:67\n-   |\n-LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n-   |                                                                  -^    - temporary value is freed at the end of this statement\n-   |                                                                  ||\n-   |                                                                  |creates a temporary which is freed while still in use\n-   |                                                                  cast requires that borrow lasts for `'static`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0716, E0723.\n-For more information about an error, try `rustc --explain E0716`.\n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "d65ffd85060343ba85fcb4b8a10e64f4d58acbb1", "filename": "src/test/ui/if/ifmt-bad-arg.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -257,10 +257,10 @@ LL |     println!(\"{} {:07$} {}\", 1, 3.2, 4);\n    = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n \n error: unknown format trait `foo`\n-  --> $DIR/ifmt-bad-arg.rs:86:24\n+  --> $DIR/ifmt-bad-arg.rs:86:17\n    |\n LL |     println!(\"{:foo}\", 1);\n-   |                        ^\n+   |                 ^^^\n    |\n    = note: the only appropriate formatting traits are:\n            - ``, which uses the `Display` trait"}, {"sha": "459432bf4e4266391843e40de84d7d586d36f399", "filename": "src/test/ui/if/ifmt-unknown-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fif%2Fifmt-unknown-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a5027519a4a634baa6cde5b698b907d27fbe6b3/src%2Ftest%2Fui%2Fif%2Fifmt-unknown-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fifmt-unknown-trait.stderr?ref=5a5027519a4a634baa6cde5b698b907d27fbe6b3", "patch": "@@ -1,8 +1,8 @@\n error: unknown format trait `notimplemented`\n-  --> $DIR/ifmt-unknown-trait.rs:2:34\n+  --> $DIR/ifmt-unknown-trait.rs:2:16\n    |\n LL |     format!(\"{:notimplemented}\", \"3\");\n-   |                                  ^^^\n+   |                ^^^^^^^^^^^^^^\n    |\n    = note: the only appropriate formatting traits are:\n            - ``, which uses the `Display` trait"}]}