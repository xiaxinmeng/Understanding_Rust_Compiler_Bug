{"sha": "a1e5c65aa451473d1614fc04cf3c0e67247a17f1", "node_id": "C_kwDOAAsO6NoAKGExZTVjNjVhYTQ1MTQ3M2QxNjE0ZmMwNGNmM2MwZTY3MjQ3YTE3ZjE", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-05-03T00:23:54Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-05-05T11:22:51Z"}, "message": "`assume` the runtime range of `align_offset`\n\nFound when I saw code with `align_to` having extraneous checks.", "tree": {"sha": "a0327a114d2226eca7648276e16d116c771056e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0327a114d2226eca7648276e16d116c771056e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1e5c65aa451473d1614fc04cf3c0e67247a17f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e5c65aa451473d1614fc04cf3c0e67247a17f1", "html_url": "https://github.com/rust-lang/rust/commit/a1e5c65aa451473d1614fc04cf3c0e67247a17f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1e5c65aa451473d1614fc04cf3c0e67247a17f1/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d", "html_url": "https://github.com/rust-lang/rust/commit/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d"}], "stats": {"total": 93, "additions": 89, "deletions": 4}, "files": [{"sha": "ed0c05a68631945770f2c13b86194e36e11ced0c", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e5c65aa451473d1614fc04cf3c0e67247a17f1/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e5c65aa451473d1614fc04cf3c0e67247a17f1/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=a1e5c65aa451473d1614fc04cf3c0e67247a17f1", "patch": "@@ -107,6 +107,7 @@\n #![feature(const_arguments_as_str)]\n #![feature(const_array_from_ref)]\n #![feature(const_array_into_iter_constructors)]\n+#![feature(const_assume)]\n #![feature(const_bigint_helper_methods)]\n #![feature(const_black_box)]\n #![feature(const_caller_location)]"}, {"sha": "4737ff5d756d1bb0aa91e3dc0862be33db347b13", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1e5c65aa451473d1614fc04cf3c0e67247a17f1/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e5c65aa451473d1614fc04cf3c0e67247a17f1/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=a1e5c65aa451473d1614fc04cf3c0e67247a17f1", "patch": "@@ -1632,8 +1632,8 @@ pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usiz\n     // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n     // 1, where the method versions of these operations are not inlined.\n     use intrinsics::{\n-        cttz_nonzero, exact_div, mul_with_overflow, unchecked_rem, unchecked_shl, unchecked_shr,\n-        unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n+        assume, cttz_nonzero, exact_div, mul_with_overflow, unchecked_rem, unchecked_shl,\n+        unchecked_shr, unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n     };\n \n     /// Calculate multiplicative modular inverse of `x` modulo `m`.\n@@ -1724,12 +1724,18 @@ pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usiz\n         // in a branch-free way and then bitwise-OR it with whatever result the `-p mod a`\n         // computation produces.\n \n+        let aligned_address = wrapping_add(addr, a_minus_one) & wrapping_sub(0, a);\n+        let byte_offset = wrapping_sub(aligned_address, addr);\n+        // FIXME: Remove the assume after <https://github.com/llvm/llvm-project/issues/62502>\n+        // SAFETY: Masking by `-a` can only affect the low bits, and thus cannot have reduced\n+        // the value by more than `a-1`, so even though the intermediate values might have\n+        // wrapped, the byte_offset is always in `[0, a)`.\n+        unsafe { assume(byte_offset < a) };\n+\n         // SAFETY: `stride == 0` case has been handled by the special case above.\n         let addr_mod_stride = unsafe { unchecked_rem(addr, stride) };\n \n         return if addr_mod_stride == 0 {\n-            let aligned_address = wrapping_add(addr, a_minus_one) & wrapping_sub(0, a);\n-            let byte_offset = wrapping_sub(aligned_address, addr);\n             // SAFETY: `stride` is non-zero. This is guaranteed to divide exactly as well, because\n             // addr has been verified to be aligned to the original type\u2019s alignment requirements.\n             unsafe { exact_div(byte_offset, stride) }"}, {"sha": "7c7660c5a55ab759153e420aca30d1eefc706600", "filename": "tests/codegen/align-offset.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a1e5c65aa451473d1614fc04cf3c0e67247a17f1/tests%2Fcodegen%2Falign-offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e5c65aa451473d1614fc04cf3c0e67247a17f1/tests%2Fcodegen%2Falign-offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Falign-offset.rs?ref=a1e5c65aa451473d1614fc04cf3c0e67247a17f1", "patch": "@@ -0,0 +1,78 @@\n+// compile-flags: -O\n+// min-llvm-version: 15.0 (because we're using opaque pointers)\n+// ignore-debug (debug assertions in `slice::from_raw_parts` block optimizations)\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @align8\n+#[no_mangle]\n+pub fn align8(p: *const u8) -> bool {\n+    // CHECK: ret i1 true\n+    p.align_offset(8) < 8\n+}\n+\n+#[repr(align(4))]\n+pub struct Align4([u8; 4]);\n+\n+// CHECK-LABEL: @align_to4\n+#[no_mangle]\n+pub fn align_to4(x: &[u8]) -> bool {\n+    // CHECK: ret i1 true\n+    let (prefix, _middle, suffix) = unsafe { x.align_to::<Align4>() };\n+    prefix.len() < 4 && suffix.len() < 4\n+}\n+\n+// CHECK-LABEL: @align_offset_byte_ptr(ptr{{.+}}%ptr)\n+#[no_mangle]\n+pub fn align_offset_byte_ptr(ptr: *const u8) -> usize {\n+    // CHECK: %[[ADDR:.+]] = ptrtoint ptr %ptr to [[USIZE:i[0-9]+]]\n+    // CHECK: %[[UP:.+]] = add [[USIZE]] %[[ADDR]], 31\n+    // CHECK: %[[ALIGNED:.+]] = and [[USIZE]] %[[UP]], -32\n+    // CHECK: %[[OFFSET:.+]] = sub [[USIZE]] %[[ALIGNED]], %[[ADDR]]\n+\n+    // Since we're offsetting a byte pointer, there's no further fixups\n+    // CHECK-NOT: shr\n+    // CHECK-NOT: div\n+    // CHECK-NOT: select\n+\n+    // CHECK: ret [[USIZE]] %[[OFFSET]]\n+    ptr.align_offset(32)\n+}\n+\n+// CHECK-LABEL: @align_offset_word_slice(ptr{{.+}}align 4{{.+}}%slice.0\n+#[no_mangle]\n+pub fn align_offset_word_slice(slice: &[Align4]) -> usize {\n+    // CHECK: %[[ADDR:.+]] = ptrtoint ptr %slice.0 to [[USIZE]]\n+    // CHECK: %[[UP:.+]] = add [[USIZE]] %[[ADDR]], 31\n+    // CHECK: %[[ALIGNED:.+]] = and [[USIZE]] %[[UP]], -32\n+    // CHECK: %[[BOFFSET:.+]] = sub [[USIZE]] %[[ALIGNED]], %[[ADDR]]\n+    // CHECK: %[[OFFSET:.+]] = lshr exact [[USIZE]] %[[BOFFSET]], 2\n+\n+    // Slices are known to be aligned, so we don't need the \"maybe -1\" path\n+    // CHECK-NOT: select\n+\n+    // CHECK: ret [[USIZE]] %[[OFFSET]]\n+    slice.as_ptr().align_offset(32)\n+}\n+\n+\n+// CHECK-LABEL: @align_offset_word_ptr(ptr{{.+}}%ptr\n+#[no_mangle]\n+pub fn align_offset_word_ptr(ptr: *const Align4) -> usize {\n+    // CHECK: %[[ADDR:.+]] = ptrtoint ptr %ptr to [[USIZE]]\n+    // CHECK: %[[UP:.+]] = add [[USIZE]] %[[ADDR]], 31\n+    // CHECK: %[[ALIGNED:.+]] = and [[USIZE]] %[[UP]], -32\n+    // CHECK: %[[BOFFSET:.+]] = sub [[USIZE]] %[[ALIGNED]], %[[ADDR]]\n+\n+    // While we can always get a *byte* offset that will work, if the original\n+    // pointer is unaligned it might be impossible to return an *element* offset\n+    // that will make it aligned. We want it to be a `select`, not a `br`, so\n+    // that the assembly will be branchless.\n+    // CHECK: %[[LOW:.+]] = and [[USIZE]] %[[ADDR]], 3\n+    // CHECK: %[[ORIGINAL_ALIGNED:.+]] = icmp eq [[USIZE]] %[[LOW]], 0\n+    // CHECK: %[[OFFSET:.+]] = lshr exact [[USIZE]] %[[BOFFSET]], 2\n+    // CHECK: %[[R:.+]] = select i1 %[[ORIGINAL_ALIGNED]], [[USIZE]] %[[OFFSET]], [[USIZE]] -1\n+\n+    // CHECK: ret [[USIZE]] %[[R]]\n+    ptr.align_offset(32)\n+}"}]}