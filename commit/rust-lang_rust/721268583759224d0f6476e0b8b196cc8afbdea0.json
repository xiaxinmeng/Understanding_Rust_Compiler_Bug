{"sha": "721268583759224d0f6476e0b8b196cc8afbdea0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMTI2ODU4Mzc1OTIyNGQwZjY0NzZlMGI4YjE5NmNjOGFmYmRlYTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-28T17:38:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-28T17:38:01Z"}, "message": "Auto merge of #61274 - Centril:rollup-23dekk4, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #61123 (Allow to specify profiling data output directory as -Zself-profile argument.)\n - #61159 (split core::ptr module into multiple files)\n - #61164 (rename Scalar::Bits to Scalar::Raw and bits field to data)\n - #61250 (Remove special case for *ios* builds in run-make-fulldeps/print-target-list Makefile)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "0a5675a306b09a5e80f121006f409095f97305dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a5675a306b09a5e80f121006f409095f97305dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/721268583759224d0f6476e0b8b196cc8afbdea0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/721268583759224d0f6476e0b8b196cc8afbdea0", "html_url": "https://github.com/rust-lang/rust/commit/721268583759224d0f6476e0b8b196cc8afbdea0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/721268583759224d0f6476e0b8b196cc8afbdea0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6ce9b312354cadb046be40398b7e28b616bad28", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6ce9b312354cadb046be40398b7e28b616bad28", "html_url": "https://github.com/rust-lang/rust/commit/a6ce9b312354cadb046be40398b7e28b616bad28"}, {"sha": "e06547fe8db5e9596de780197c7bcba09b3c9039", "url": "https://api.github.com/repos/rust-lang/rust/commits/e06547fe8db5e9596de780197c7bcba09b3c9039", "html_url": "https://github.com/rust-lang/rust/commit/e06547fe8db5e9596de780197c7bcba09b3c9039"}], "stats": {"total": 1263, "additions": 645, "deletions": 618}, "files": [{"sha": "80ac67d8eb57c6bd88612c5516bf554b6630a15d", "filename": "src/libcore/ptr/mod.rs", "status": "renamed", "additions": 8, "deletions": 387, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! Manually manage memory through raw pointers.\n //!\n //! *[See also the pointer primitive types](../../std/primitive.pointer.html).*\n@@ -65,14 +63,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::convert::From;\n use crate::intrinsics;\n-use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::fmt;\n use crate::hash;\n-use crate::marker::{PhantomData, Unsize};\n use crate::mem::{self, MaybeUninit};\n-\n use crate::cmp::Ordering::{self, Less, Equal, Greater};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -84,6 +78,14 @@ pub use crate::intrinsics::copy;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::intrinsics::write_bytes;\n \n+mod non_null;\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+pub use non_null::NonNull;\n+\n+mod unique;\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+pub use unique::Unique;\n+\n /// Executes the destructor (if any) of the pointed-to value.\n ///\n /// This is semantically equivalent to calling [`ptr::read`] and discarding\n@@ -2742,384 +2744,3 @@ impl<T: ?Sized> PartialOrd for *mut T {\n     #[inline]\n     fn ge(&self, other: &*mut T) -> bool { *self >= *other }\n }\n-\n-/// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n-/// of this wrapper owns the referent. Useful for building abstractions like\n-/// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n-///\n-/// Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n-/// It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n-/// the kind of strong aliasing guarantees an instance of `T` can expect:\n-/// the referent of the pointer should not be modified without a unique path to\n-/// its owning Unique.\n-///\n-/// If you're uncertain of whether it's correct to use `Unique` for your purposes,\n-/// consider using `NonNull`, which has weaker semantics.\n-///\n-/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n-/// is never dereferenced. This is so that enums may use this forbidden value\n-/// as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n-/// However the pointer may still dangle if it isn't dereferenced.\n-///\n-/// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n-/// for any type which upholds Unique's aliasing requirements.\n-#[unstable(feature = \"ptr_internals\", issue = \"0\",\n-           reason = \"use NonNull instead and consider PhantomData<T> \\\n-                     (if you also use #[may_dangle]), Send, and/or Sync\")]\n-#[doc(hidden)]\n-#[repr(transparent)]\n-#[rustc_layout_scalar_valid_range_start(1)]\n-pub struct Unique<T: ?Sized> {\n-    pointer: *const T,\n-    // NOTE: this marker has no consequences for variance, but is necessary\n-    // for dropck to understand that we logically own a `T`.\n-    //\n-    // For details, see:\n-    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data\n-    _marker: PhantomData<T>,\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> fmt::Debug for Unique<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Pointer::fmt(&self.as_ptr(), f)\n-    }\n-}\n-\n-/// `Unique` pointers are `Send` if `T` is `Send` because the data they\n-/// reference is unaliased. Note that this aliasing invariant is\n-/// unenforced by the type system; the abstraction using the\n-/// `Unique` must enforce it.\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n-\n-/// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n-/// reference is unaliased. Note that this aliasing invariant is\n-/// unenforced by the type system; the abstraction using the\n-/// `Unique` must enforce it.\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: Sized> Unique<T> {\n-    /// Creates a new `Unique` that is dangling, but well-aligned.\n-    ///\n-    /// This is useful for initializing types which lazily allocate, like\n-    /// `Vec::new` does.\n-    ///\n-    /// Note that the pointer value may potentially represent a valid pointer to\n-    /// a `T`, which means this must not be used as a \"not yet initialized\"\n-    /// sentinel value. Types that lazily allocate must track initialization by\n-    /// some other means.\n-    // FIXME: rename to dangling() to match NonNull?\n-    pub const fn empty() -> Self {\n-        unsafe {\n-            Unique::new_unchecked(mem::align_of::<T>() as *mut T)\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> Unique<T> {\n-    /// Creates a new `Unique`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// `ptr` must be non-null.\n-    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        Unique { pointer: ptr as _, _marker: PhantomData }\n-    }\n-\n-    /// Creates a new `Unique` if `ptr` is non-null.\n-    pub fn new(ptr: *mut T) -> Option<Self> {\n-        if !ptr.is_null() {\n-            Some(unsafe { Unique { pointer: ptr as _, _marker: PhantomData } })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Acquires the underlying `*mut` pointer.\n-    pub const fn as_ptr(self) -> *mut T {\n-        self.pointer as *mut T\n-    }\n-\n-    /// Dereferences the content.\n-    ///\n-    /// The resulting lifetime is bound to self so this behaves \"as if\"\n-    /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n-    pub unsafe fn as_ref(&self) -> &T {\n-        &*self.as_ptr()\n-    }\n-\n-    /// Mutably dereferences the content.\n-    ///\n-    /// The resulting lifetime is bound to self so this behaves \"as if\"\n-    /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n-    pub unsafe fn as_mut(&mut self) -> &mut T {\n-        &mut *self.as_ptr()\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> Clone for Unique<T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> Copy for Unique<T> { }\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> { }\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> fmt::Pointer for Unique<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Pointer::fmt(&self.as_ptr(), f)\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> From<&mut T> for Unique<T> {\n-    fn from(reference: &mut T) -> Self {\n-        unsafe { Unique { pointer: reference as *mut T, _marker: PhantomData } }\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> From<&T> for Unique<T> {\n-    fn from(reference: &T) -> Self {\n-        unsafe { Unique { pointer: reference as *const T, _marker: PhantomData } }\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n-    fn from(p: NonNull<T>) -> Self {\n-        unsafe { Unique { pointer: p.pointer, _marker: PhantomData } }\n-    }\n-}\n-\n-/// `*mut T` but non-zero and covariant.\n-///\n-/// This is often the correct thing to use when building data structures using\n-/// raw pointers, but is ultimately more dangerous to use because of its additional\n-/// properties. If you're not sure if you should use `NonNull<T>`, just use `*mut T`!\n-///\n-/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n-/// is never dereferenced. This is so that enums may use this forbidden value\n-/// as a discriminant -- `Option<NonNull<T>>` has the same size as `*mut T`.\n-/// However the pointer may still dangle if it isn't dereferenced.\n-///\n-/// Unlike `*mut T`, `NonNull<T>` is covariant over `T`. If this is incorrect\n-/// for your use case, you should include some [`PhantomData`] in your type to\n-/// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n-/// Usually this won't be necessary; covariance is correct for most safe abstractions,\n-/// such as `Box`, `Rc`, `Arc`, `Vec`, and `LinkedList`. This is the case because they\n-/// provide a public API that follows the normal shared XOR mutable rules of Rust.\n-///\n-/// Notice that `NonNull<T>` has a `From` instance for `&T`. However, this does\n-/// not change the fact that mutating through a (pointer derived from a) shared\n-/// reference is undefined behavior unless the mutation happens inside an\n-/// [`UnsafeCell<T>`]. The same goes for creating a mutable reference from a shared\n-/// reference. When using this `From` instance without an `UnsafeCell<T>`,\n-/// it is your responsibility to ensure that `as_mut` is never called, and `as_ptr`\n-/// is never used for mutation.\n-///\n-/// [`PhantomData`]: ../marker/struct.PhantomData.html\n-/// [`UnsafeCell<T>`]: ../cell/struct.UnsafeCell.html\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-#[repr(transparent)]\n-#[rustc_layout_scalar_valid_range_start(1)]\n-#[cfg_attr(not(stage0), rustc_nonnull_optimization_guaranteed)]\n-pub struct NonNull<T: ?Sized> {\n-    pointer: *const T,\n-}\n-\n-/// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n-// N.B., this impl is unnecessary, but should provide better error messages.\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> !Send for NonNull<T> { }\n-\n-/// `NonNull` pointers are not `Sync` because the data they reference may be aliased.\n-// N.B., this impl is unnecessary, but should provide better error messages.\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> !Sync for NonNull<T> { }\n-\n-impl<T: Sized> NonNull<T> {\n-    /// Creates a new `NonNull` that is dangling, but well-aligned.\n-    ///\n-    /// This is useful for initializing types which lazily allocate, like\n-    /// `Vec::new` does.\n-    ///\n-    /// Note that the pointer value may potentially represent a valid pointer to\n-    /// a `T`, which means this must not be used as a \"not yet initialized\"\n-    /// sentinel value. Types that lazily allocate must track initialization by\n-    /// some other means.\n-    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-    #[inline]\n-    pub const fn dangling() -> Self {\n-        unsafe {\n-            let ptr = mem::align_of::<T>() as *mut T;\n-            NonNull::new_unchecked(ptr)\n-        }\n-    }\n-}\n-\n-impl<T: ?Sized> NonNull<T> {\n-    /// Creates a new `NonNull`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// `ptr` must be non-null.\n-    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-    #[inline]\n-    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        NonNull { pointer: ptr as _ }\n-    }\n-\n-    /// Creates a new `NonNull` if `ptr` is non-null.\n-    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-    #[inline]\n-    pub fn new(ptr: *mut T) -> Option<Self> {\n-        if !ptr.is_null() {\n-            Some(unsafe { Self::new_unchecked(ptr) })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Acquires the underlying `*mut` pointer.\n-    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-    #[inline]\n-    pub const fn as_ptr(self) -> *mut T {\n-        self.pointer as *mut T\n-    }\n-\n-    /// Dereferences the content.\n-    ///\n-    /// The resulting lifetime is bound to self so this behaves \"as if\"\n-    /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n-    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-    #[inline]\n-    pub unsafe fn as_ref(&self) -> &T {\n-        &*self.as_ptr()\n-    }\n-\n-    /// Mutably dereferences the content.\n-    ///\n-    /// The resulting lifetime is bound to self so this behaves \"as if\"\n-    /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n-    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-    #[inline]\n-    pub unsafe fn as_mut(&mut self) -> &mut T {\n-        &mut *self.as_ptr()\n-    }\n-\n-    /// Cast to a pointer of another type\n-    #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n-    #[inline]\n-    pub const fn cast<U>(self) -> NonNull<U> {\n-        unsafe {\n-            NonNull::new_unchecked(self.as_ptr() as *mut U)\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> Clone for NonNull<T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> Copy for NonNull<T> { }\n-\n-#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n-\n-#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> fmt::Debug for NonNull<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Pointer::fmt(&self.as_ptr(), f)\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> fmt::Pointer for NonNull<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Pointer::fmt(&self.as_ptr(), f)\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> Eq for NonNull<T> {}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> PartialEq for NonNull<T> {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.as_ptr() == other.as_ptr()\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> Ord for NonNull<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.as_ptr().cmp(&other.as_ptr())\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> PartialOrd for NonNull<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.as_ptr().partial_cmp(&other.as_ptr())\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> hash::Hash for NonNull<T> {\n-    #[inline]\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        self.as_ptr().hash(state)\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n-    #[inline]\n-    fn from(unique: Unique<T>) -> Self {\n-        unsafe { NonNull { pointer: unique.pointer } }\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> From<&mut T> for NonNull<T> {\n-    #[inline]\n-    fn from(reference: &mut T) -> Self {\n-        unsafe { NonNull { pointer: reference as *mut T } }\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> From<&T> for NonNull<T> {\n-    #[inline]\n-    fn from(reference: &T) -> Self {\n-        unsafe { NonNull { pointer: reference as *const T } }\n-    }\n-}", "previous_filename": "src/libcore/ptr.rs"}, {"sha": "0a6985e334cd05b9adf783ed6f3b4390061e21c7", "filename": "src/libcore/ptr/non_null.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -0,0 +1,226 @@\n+use crate::convert::From;\n+use crate::ops::{CoerceUnsized, DispatchFromDyn};\n+use crate::fmt;\n+use crate::hash;\n+use crate::marker::Unsize;\n+use crate::mem;\n+use crate::ptr::Unique;\n+use crate::cmp::Ordering;\n+\n+/// `*mut T` but non-zero and covariant.\n+///\n+/// This is often the correct thing to use when building data structures using\n+/// raw pointers, but is ultimately more dangerous to use because of its additional\n+/// properties. If you're not sure if you should use `NonNull<T>`, just use `*mut T`!\n+///\n+/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n+/// is never dereferenced. This is so that enums may use this forbidden value\n+/// as a discriminant -- `Option<NonNull<T>>` has the same size as `*mut T`.\n+/// However the pointer may still dangle if it isn't dereferenced.\n+///\n+/// Unlike `*mut T`, `NonNull<T>` is covariant over `T`. If this is incorrect\n+/// for your use case, you should include some [`PhantomData`] in your type to\n+/// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n+/// Usually this won't be necessary; covariance is correct for most safe abstractions,\n+/// such as `Box`, `Rc`, `Arc`, `Vec`, and `LinkedList`. This is the case because they\n+/// provide a public API that follows the normal shared XOR mutable rules of Rust.\n+///\n+/// Notice that `NonNull<T>` has a `From` instance for `&T`. However, this does\n+/// not change the fact that mutating through a (pointer derived from a) shared\n+/// reference is undefined behavior unless the mutation happens inside an\n+/// [`UnsafeCell<T>`]. The same goes for creating a mutable reference from a shared\n+/// reference. When using this `From` instance without an `UnsafeCell<T>`,\n+/// it is your responsibility to ensure that `as_mut` is never called, and `as_ptr`\n+/// is never used for mutation.\n+///\n+/// [`PhantomData`]: ../marker/struct.PhantomData.html\n+/// [`UnsafeCell<T>`]: ../cell/struct.UnsafeCell.html\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[cfg_attr(not(stage0), rustc_nonnull_optimization_guaranteed)]\n+pub struct NonNull<T: ?Sized> {\n+    pointer: *const T,\n+}\n+\n+/// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n+// N.B., this impl is unnecessary, but should provide better error messages.\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> !Send for NonNull<T> { }\n+\n+/// `NonNull` pointers are not `Sync` because the data they reference may be aliased.\n+// N.B., this impl is unnecessary, but should provide better error messages.\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> !Sync for NonNull<T> { }\n+\n+impl<T: Sized> NonNull<T> {\n+    /// Creates a new `NonNull` that is dangling, but well-aligned.\n+    ///\n+    /// This is useful for initializing types which lazily allocate, like\n+    /// `Vec::new` does.\n+    ///\n+    /// Note that the pointer value may potentially represent a valid pointer to\n+    /// a `T`, which means this must not be used as a \"not yet initialized\"\n+    /// sentinel value. Types that lazily allocate must track initialization by\n+    /// some other means.\n+    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[inline]\n+    pub const fn dangling() -> Self {\n+        unsafe {\n+            let ptr = mem::align_of::<T>() as *mut T;\n+            NonNull::new_unchecked(ptr)\n+        }\n+    }\n+}\n+\n+impl<T: ?Sized> NonNull<T> {\n+    /// Creates a new `NonNull`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `ptr` must be non-null.\n+    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[inline]\n+    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n+        NonNull { pointer: ptr as _ }\n+    }\n+\n+    /// Creates a new `NonNull` if `ptr` is non-null.\n+    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[inline]\n+    pub fn new(ptr: *mut T) -> Option<Self> {\n+        if !ptr.is_null() {\n+            Some(unsafe { Self::new_unchecked(ptr) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Acquires the underlying `*mut` pointer.\n+    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[inline]\n+    pub const fn as_ptr(self) -> *mut T {\n+        self.pointer as *mut T\n+    }\n+\n+    /// Dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n+    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[inline]\n+    pub unsafe fn as_ref(&self) -> &T {\n+        &*self.as_ptr()\n+    }\n+\n+    /// Mutably dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n+    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[inline]\n+    pub unsafe fn as_mut(&mut self) -> &mut T {\n+        &mut *self.as_ptr()\n+    }\n+\n+    /// Cast to a pointer of another type\n+    #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n+    #[inline]\n+    pub const fn cast<U>(self) -> NonNull<U> {\n+        unsafe {\n+            NonNull::new_unchecked(self.as_ptr() as *mut U)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> Clone for NonNull<T> {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> Copy for NonNull<T> { }\n+\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n+\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> fmt::Debug for NonNull<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> fmt::Pointer for NonNull<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> Eq for NonNull<T> {}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> PartialEq for NonNull<T> {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.as_ptr() == other.as_ptr()\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> Ord for NonNull<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.as_ptr().cmp(&other.as_ptr())\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> PartialOrd for NonNull<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.as_ptr().partial_cmp(&other.as_ptr())\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> hash::Hash for NonNull<T> {\n+    #[inline]\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        self.as_ptr().hash(state)\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n+    #[inline]\n+    fn from(unique: Unique<T>) -> Self {\n+        unsafe { NonNull::new_unchecked(unique.as_ptr()) }\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> From<&mut T> for NonNull<T> {\n+    #[inline]\n+    fn from(reference: &mut T) -> Self {\n+        unsafe { NonNull { pointer: reference as *mut T } }\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> From<&T> for NonNull<T> {\n+    #[inline]\n+    fn from(reference: &T) -> Self {\n+        unsafe { NonNull { pointer: reference as *const T } }\n+    }\n+}"}, {"sha": "5911518919e6da4ade3b029651849abcf3a00b62", "filename": "src/libcore/ptr/unique.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -0,0 +1,180 @@\n+use crate::convert::From;\n+use crate::ops::{CoerceUnsized, DispatchFromDyn};\n+use crate::fmt;\n+use crate::marker::{PhantomData, Unsize};\n+use crate::mem;\n+use crate::ptr::NonNull;\n+\n+/// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n+/// of this wrapper owns the referent. Useful for building abstractions like\n+/// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n+///\n+/// Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n+/// It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n+/// the kind of strong aliasing guarantees an instance of `T` can expect:\n+/// the referent of the pointer should not be modified without a unique path to\n+/// its owning Unique.\n+///\n+/// If you're uncertain of whether it's correct to use `Unique` for your purposes,\n+/// consider using `NonNull`, which has weaker semantics.\n+///\n+/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n+/// is never dereferenced. This is so that enums may use this forbidden value\n+/// as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n+/// However the pointer may still dangle if it isn't dereferenced.\n+///\n+/// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n+/// for any type which upholds Unique's aliasing requirements.\n+#[unstable(feature = \"ptr_internals\", issue = \"0\",\n+           reason = \"use NonNull instead and consider PhantomData<T> \\\n+                     (if you also use #[may_dangle]), Send, and/or Sync\")]\n+#[doc(hidden)]\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(1)]\n+pub struct Unique<T: ?Sized> {\n+    pointer: *const T,\n+    // NOTE: this marker has no consequences for variance, but is necessary\n+    // for dropck to understand that we logically own a `T`.\n+    //\n+    // For details, see:\n+    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data\n+    _marker: PhantomData<T>,\n+}\n+\n+/// `Unique` pointers are `Send` if `T` is `Send` because the data they\n+/// reference is unaliased. Note that this aliasing invariant is\n+/// unenforced by the type system; the abstraction using the\n+/// `Unique` must enforce it.\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n+\n+/// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n+/// reference is unaliased. Note that this aliasing invariant is\n+/// unenforced by the type system; the abstraction using the\n+/// `Unique` must enforce it.\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: Sized> Unique<T> {\n+    /// Creates a new `Unique` that is dangling, but well-aligned.\n+    ///\n+    /// This is useful for initializing types which lazily allocate, like\n+    /// `Vec::new` does.\n+    ///\n+    /// Note that the pointer value may potentially represent a valid pointer to\n+    /// a `T`, which means this must not be used as a \"not yet initialized\"\n+    /// sentinel value. Types that lazily allocate must track initialization by\n+    /// some other means.\n+    // FIXME: rename to dangling() to match NonNull?\n+    #[inline]\n+    pub const fn empty() -> Self {\n+        unsafe {\n+            Unique::new_unchecked(mem::align_of::<T>() as *mut T)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> Unique<T> {\n+    /// Creates a new `Unique`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `ptr` must be non-null.\n+    #[inline]\n+    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n+        Unique { pointer: ptr as _, _marker: PhantomData }\n+    }\n+\n+    /// Creates a new `Unique` if `ptr` is non-null.\n+    #[inline]\n+    pub fn new(ptr: *mut T) -> Option<Self> {\n+        if !ptr.is_null() {\n+            Some(unsafe { Unique { pointer: ptr as _, _marker: PhantomData } })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Acquires the underlying `*mut` pointer.\n+    #[inline]\n+    pub const fn as_ptr(self) -> *mut T {\n+        self.pointer as *mut T\n+    }\n+\n+    /// Dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n+    #[inline]\n+    pub unsafe fn as_ref(&self) -> &T {\n+        &*self.as_ptr()\n+    }\n+\n+    /// Mutably dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n+    #[inline]\n+    pub unsafe fn as_mut(&mut self) -> &mut T {\n+        &mut *self.as_ptr()\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> Clone for Unique<T> {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> Copy for Unique<T> { }\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> fmt::Debug for Unique<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> fmt::Pointer for Unique<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> From<&mut T> for Unique<T> {\n+    #[inline]\n+    fn from(reference: &mut T) -> Self {\n+        unsafe { Unique { pointer: reference as *mut T, _marker: PhantomData } }\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> From<&T> for Unique<T> {\n+    #[inline]\n+    fn from(reference: &T) -> Self {\n+        unsafe { Unique { pointer: reference as *const T, _marker: PhantomData } }\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n+    #[inline]\n+    fn from(p: NonNull<T>) -> Self {\n+        unsafe { Unique::new_unchecked(p.as_ptr()) }\n+    }\n+}"}, {"sha": "9549a5af5af5c7c64c62e0ab45852abf24e28e29", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -2,7 +2,6 @@\n \n use super::{\n     Pointer, EvalResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n-    truncate,\n };\n \n use crate::ty::layout::{Size, Align};\n@@ -407,18 +406,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n             ScalarMaybeUndef::Undef => return self.mark_definedness(ptr, type_size, false),\n         };\n \n-        let bytes = match val {\n-            Scalar::Ptr(val) => {\n-                assert_eq!(type_size, cx.data_layout().pointer_size);\n-                val.offset.bytes() as u128\n-            }\n-\n-            Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, type_size.bytes());\n-                debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n-                    \"Unexpected value of size {} when writing to memory\", size);\n-                bits\n-            },\n+        let bytes = match val.to_bits_or_ptr(type_size, cx) {\n+            Err(val) => val.offset.bytes() as u128,\n+            Ok(data) => data,\n         };\n \n         let endian = cx.data_layout().endian;"}, {"sha": "07d22cf991c6bab23b857be57b942b55b0d4fd62", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -349,6 +349,7 @@ impl<'tcx> AllocMap<'tcx> {\n     /// illegal and will likely ICE.\n     /// This function exists to allow const eval to detect the difference between evaluation-\n     /// local dangling pointers and allocations in constants/statics.\n+    #[inline]\n     pub fn get(&self, id: AllocId) -> Option<AllocKind<'tcx>> {\n         self.id_to_kind.get(&id).cloned()\n     }\n@@ -397,6 +398,7 @@ impl<'tcx> AllocMap<'tcx> {\n // Methods to access integers in the target endianness\n ////////////////////////////////////////////////////////////////////////////////\n \n+#[inline]\n pub fn write_target_uint(\n     endianness: layout::Endian,\n     mut target: &mut [u8],\n@@ -409,6 +411,7 @@ pub fn write_target_uint(\n     }\n }\n \n+#[inline]\n pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n     match endianness {\n         layout::Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n@@ -420,17 +423,30 @@ pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result\n // Methods to facilitate working with signed integers stored in a u128\n ////////////////////////////////////////////////////////////////////////////////\n \n+/// Truncate `value` to `size` bits and then sign-extend it to 128 bits\n+/// (i.e., if it is negative, fill with 1's on the left).\n+#[inline]\n pub fn sign_extend(value: u128, size: Size) -> u128 {\n     let size = size.bits();\n+    if size == 0 {\n+        // Truncated until nothing is left.\n+        return 0;\n+    }\n     // sign extend\n     let shift = 128 - size;\n     // shift the unsigned value to the left\n     // and back to the right as signed (essentially fills with FF on the left)\n     (((value << shift) as i128) >> shift) as u128\n }\n \n+/// Truncate `value` to `size` bits.\n+#[inline]\n pub fn truncate(value: u128, size: Size) -> u128 {\n     let size = size.bits();\n+    if size == 0 {\n+        // Truncated until nothing is left.\n+        return 0;\n+    }\n     let shift = 128 - size;\n     // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n     (value << shift) >> shift"}, {"sha": "9e71399d4fdf7eacd9d02e4e12d1932e35b7ae74", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -20,45 +20,48 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n         self.data_layout().pointer_size\n     }\n \n-    //// Trunace the given value to the pointer size; also return whether there was an overflow\n+    /// Helper function: truncate given value-\"overflowed flag\" pair to pointer size and\n+    /// update \"overflowed flag\" if there was an overflow.\n+    /// This should be called by all the other methods before returning!\n     #[inline]\n-    fn truncate_to_ptr(&self, val: u128) -> (u64, bool) {\n+    fn truncate_to_ptr(&self, (val, over): (u64, bool)) -> (u64, bool) {\n+        let val = val as u128;\n         let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n-        ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n-    }\n-\n-    #[inline]\n-    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_offset(val, i);\n-        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+        ((val % max_ptr_plus_1) as u64, over || val >= max_ptr_plus_1)\n     }\n \n     #[inline]\n     fn overflowing_offset(&self, val: u64, i: u64) -> (u64, bool) {\n-        let (res, over1) = val.overflowing_add(i);\n-        let (res, over2) = self.truncate_to_ptr(u128::from(res));\n-        (res, over1 || over2)\n-    }\n-\n-    #[inline]\n-    fn signed_offset<'tcx>(&self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n-        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+        let res = val.overflowing_add(i);\n+        self.truncate_to_ptr(res)\n     }\n \n     // Overflow checking only works properly on the range from -u64 to +u64.\n     #[inline]\n     fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n         // FIXME: is it possible to over/underflow here?\n         if i < 0 {\n-            // trickery to ensure that i64::min_value() works fine\n-            // this formula only works for true negative values, it panics for zero!\n+            // Trickery to ensure that i64::min_value() works fine: compute n = -i.\n+            // This formula only works for true negative values, it overflows for zero!\n             let n = u64::max_value() - (i as u64) + 1;\n-            val.overflowing_sub(n)\n+            let res = val.overflowing_sub(n);\n+            self.truncate_to_ptr(res)\n         } else {\n             self.overflowing_offset(val, i as u64)\n         }\n     }\n+\n+    #[inline]\n+    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_offset(val, i);\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+    }\n+\n+    #[inline]\n+    fn signed_offset<'tcx>(&self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+    }\n }\n \n impl<T: layout::HasDataLayout> PointerArithmetic for T {}"}, {"sha": "21792b847db77e2e6fb0319436a0f61868a09d5f", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 82, "deletions": 60, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -87,11 +87,11 @@ impl<'tcx> ConstValue<'tcx> {\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub enum Scalar<Tag=(), Id=AllocId> {\n     /// The raw bytes of a simple value.\n-    Bits {\n-        /// The first `size` bytes are the value.\n+    Raw {\n+        /// The first `size` bytes of `data` are the value.\n         /// Do not try to read less or more bytes than that. The remaining bytes must be 0.\n+        data: u128,\n         size: u8,\n-        bits: u128,\n     },\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n@@ -108,16 +108,14 @@ impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for Scalar<Tag, Id> {\n         match self {\n             Scalar::Ptr(ptr) =>\n                 write!(f, \"{:?}\", ptr),\n-            &Scalar::Bits { bits, size } => {\n+            &Scalar::Raw { data, size } => {\n+                Scalar::check_data(data, size);\n                 if size == 0 {\n-                    assert_eq!(bits, 0, \"ZST value must be 0\");\n                     write!(f, \"<ZST>\")\n                 } else {\n-                    assert_eq!(truncate(bits, Size::from_bytes(size as u64)), bits,\n-                            \"Scalar value {:#x} exceeds size of {} bytes\", bits, size);\n                     // Format as hex number wide enough to fit any value of the given `size`.\n-                    // So bits=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n-                    write!(f, \"0x{:>0width$x}\", bits, width=(size*2) as usize)\n+                    // So data=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n+                    write!(f, \"0x{:>0width$x}\", data, width=(size*2) as usize)\n                 }\n             }\n         }\n@@ -128,17 +126,23 @@ impl<Tag> fmt::Display for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(_) => write!(f, \"a pointer\"),\n-            Scalar::Bits { bits, .. } => write!(f, \"{}\", bits),\n+            Scalar::Raw { data, .. } => write!(f, \"{}\", data),\n         }\n     }\n }\n \n impl<'tcx> Scalar<()> {\n+    #[inline(always)]\n+    fn check_data(data: u128, size: u8) {\n+        debug_assert_eq!(truncate(data, Size::from_bytes(size as u64)), data,\n+                         \"Scalar value {:#x} exceeds size of {} bytes\", data, size);\n+    }\n+\n     #[inline]\n     pub fn with_tag<Tag>(self, new_tag: Tag) -> Scalar<Tag> {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_tag(new_tag)),\n-            Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n+            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n         }\n     }\n \n@@ -155,31 +159,31 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn erase_tag(self) -> Scalar {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.erase_tag()),\n-            Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n+            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n         }\n     }\n \n     #[inline]\n     pub fn ptr_null(cx: &impl HasDataLayout) -> Self {\n-        Scalar::Bits {\n-            bits: 0,\n+        Scalar::Raw {\n+            data: 0,\n             size: cx.data_layout().pointer_size.bytes() as u8,\n         }\n     }\n \n     #[inline]\n     pub fn zst() -> Self {\n-        Scalar::Bits { bits: 0, size: 0 }\n+        Scalar::Raw { data: 0, size: 0 }\n     }\n \n     #[inline]\n     pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let dl = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Ok(Scalar::Bits {\n-                    bits: dl.offset(bits as u64, i.bytes())? as u128,\n+                Ok(Scalar::Raw {\n+                    data: dl.offset(data as u64, i.bytes())? as u128,\n                     size,\n                 })\n             }\n@@ -191,10 +195,10 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn ptr_wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n         let dl = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Scalar::Bits {\n-                    bits: dl.overflowing_offset(bits as u64, i.bytes()).0 as u128,\n+                Scalar::Raw {\n+                    data: dl.overflowing_offset(data as u64, i.bytes()).0 as u128,\n                     size,\n                 }\n             }\n@@ -206,10 +210,10 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let dl = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, dl.pointer_size().bytes());\n-                Ok(Scalar::Bits {\n-                    bits: dl.signed_offset(bits as u64, i)? as u128,\n+                Ok(Scalar::Raw {\n+                    data: dl.signed_offset(data as u64, i)? as u128,\n                     size,\n                 })\n             }\n@@ -221,25 +225,25 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn ptr_wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n         let dl = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Scalar::Bits {\n-                    bits: dl.overflowing_signed_offset(bits as u64, i128::from(i)).0 as u128,\n+                Scalar::Raw {\n+                    data: dl.overflowing_signed_offset(data as u64, i128::from(i)).0 as u128,\n                     size,\n                 }\n             }\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_signed_offset(i, dl)),\n         }\n     }\n \n-    /// Returns this pointers offset from the allocation base, or from NULL (for\n+    /// Returns this pointer's offset from the allocation base, or from NULL (for\n     /// integer pointers).\n     #[inline]\n     pub fn get_ptr_offset(self, cx: &impl HasDataLayout) -> Size {\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, cx.pointer_size().bytes());\n-                Size::from_bytes(bits as u64)\n+                Size::from_bytes(data as u64)\n             }\n             Scalar::Ptr(ptr) => ptr.offset,\n         }\n@@ -248,59 +252,84 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn is_null_ptr(self, cx: &impl HasDataLayout) -> bool {\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, cx.data_layout().pointer_size.bytes());\n-                bits == 0\n+                data == 0\n             },\n             Scalar::Ptr(_) => false,\n         }\n     }\n \n     #[inline]\n     pub fn from_bool(b: bool) -> Self {\n-        Scalar::Bits { bits: b as u128, size: 1 }\n+        Scalar::Raw { data: b as u128, size: 1 }\n     }\n \n     #[inline]\n     pub fn from_char(c: char) -> Self {\n-        Scalar::Bits { bits: c as u128, size: 4 }\n+        Scalar::Raw { data: c as u128, size: 4 }\n     }\n \n     #[inline]\n     pub fn from_uint(i: impl Into<u128>, size: Size) -> Self {\n         let i = i.into();\n-        debug_assert_eq!(truncate(i, size), i,\n-                         \"Unsigned value {} does not fit in {} bits\", i, size.bits());\n-        Scalar::Bits { bits: i, size: size.bytes() as u8 }\n+        assert_eq!(\n+            truncate(i, size), i,\n+            \"Unsigned value {:#x} does not fit in {} bits\", i, size.bits()\n+        );\n+        Scalar::Raw { data: i, size: size.bytes() as u8 }\n     }\n \n     #[inline]\n     pub fn from_int(i: impl Into<i128>, size: Size) -> Self {\n         let i = i.into();\n         // `into` performed sign extension, we have to truncate\n         let truncated = truncate(i as u128, size);\n-        debug_assert_eq!(sign_extend(truncated, size) as i128, i,\n-                         \"Signed value {} does not fit in {} bits\", i, size.bits());\n-        Scalar::Bits { bits: truncated, size: size.bytes() as u8 }\n+        assert_eq!(\n+            sign_extend(truncated, size) as i128, i,\n+            \"Signed value {:#x} does not fit in {} bits\", i, size.bits()\n+        );\n+        Scalar::Raw { data: truncated, size: size.bytes() as u8 }\n     }\n \n     #[inline]\n     pub fn from_f32(f: f32) -> Self {\n-        Scalar::Bits { bits: f.to_bits() as u128, size: 4 }\n+        Scalar::Raw { data: f.to_bits() as u128, size: 4 }\n     }\n \n     #[inline]\n     pub fn from_f64(f: f64) -> Self {\n-        Scalar::Bits { bits: f.to_bits() as u128, size: 8 }\n+        Scalar::Raw { data: f.to_bits() as u128, size: 8 }\n+    }\n+\n+    #[inline]\n+    pub fn to_bits_or_ptr(\n+        self,\n+        target_size: Size,\n+        cx: &impl HasDataLayout,\n+    ) -> Result<u128, Pointer<Tag>> {\n+        match self {\n+            Scalar::Raw { data, size } => {\n+                assert_eq!(target_size.bytes(), size as u64);\n+                assert_ne!(size, 0, \"you should never look at the bits of a ZST\");\n+                Scalar::check_data(data, size);\n+                Ok(data)\n+            }\n+            Scalar::Ptr(ptr) => {\n+                assert_eq!(target_size, cx.data_layout().pointer_size);\n+                Err(ptr)\n+            }\n+        }\n     }\n \n     #[inline]\n     pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(target_size.bytes(), size as u64);\n-                assert_ne!(size, 0, \"to_bits cannot be used with zsts\");\n-                Ok(bits)\n+                assert_ne!(size, 0, \"you should never look at the bits of a ZST\");\n+                Scalar::check_data(data, size);\n+                Ok(data)\n             }\n             Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n         }\n@@ -309,16 +338,16 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer<Tag>> {\n         match self {\n-            Scalar::Bits { bits: 0, .. } => err!(InvalidNullPointerUsage),\n-            Scalar::Bits { .. } => err!(ReadBytesAsPointer),\n+            Scalar::Raw { data: 0, .. } => err!(InvalidNullPointerUsage),\n+            Scalar::Raw { .. } => err!(ReadBytesAsPointer),\n             Scalar::Ptr(p) => Ok(p),\n         }\n     }\n \n     #[inline]\n     pub fn is_bits(self) -> bool {\n         match self {\n-            Scalar::Bits { .. } => true,\n+            Scalar::Raw { .. } => true,\n             _ => false,\n         }\n     }\n@@ -333,8 +362,8 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n         match self {\n-            Scalar::Bits { bits: 0, size: 1 } => Ok(false),\n-            Scalar::Bits { bits: 1, size: 1 } => Ok(true),\n+            Scalar::Raw { data: 0, size: 1 } => Ok(false),\n+            Scalar::Raw { data: 1, size: 1 } => Ok(true),\n             _ => err!(InvalidBool),\n         }\n     }\n@@ -350,58 +379,51 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn to_u8(self) -> EvalResult<'static, u8> {\n         let sz = Size::from_bits(8);\n         let b = self.to_bits(sz)?;\n-        assert_eq!(b as u8 as u128, b);\n         Ok(b as u8)\n     }\n \n     pub fn to_u32(self) -> EvalResult<'static, u32> {\n         let sz = Size::from_bits(32);\n         let b = self.to_bits(sz)?;\n-        assert_eq!(b as u32 as u128, b);\n         Ok(b as u32)\n     }\n \n     pub fn to_u64(self) -> EvalResult<'static, u64> {\n         let sz = Size::from_bits(64);\n         let b = self.to_bits(sz)?;\n-        assert_eq!(b as u64 as u128, b);\n         Ok(b as u64)\n     }\n \n     pub fn to_usize(self, cx: &impl HasDataLayout) -> EvalResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n-        assert_eq!(b as u64 as u128, b);\n         Ok(b as u64)\n     }\n \n     pub fn to_i8(self) -> EvalResult<'static, i8> {\n         let sz = Size::from_bits(8);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n-        assert_eq!(b as i8 as i128, b);\n         Ok(b as i8)\n     }\n \n     pub fn to_i32(self) -> EvalResult<'static, i32> {\n         let sz = Size::from_bits(32);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n-        assert_eq!(b as i32 as i128, b);\n         Ok(b as i32)\n     }\n \n     pub fn to_i64(self) -> EvalResult<'static, i64> {\n         let sz = Size::from_bits(64);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n-        assert_eq!(b as i64 as i128, b);\n         Ok(b as i64)\n     }\n \n     pub fn to_isize(self, cx: &impl HasDataLayout) -> EvalResult<'static, i64> {\n-        let b = self.to_bits(cx.data_layout().pointer_size)?;\n-        let b = sign_extend(b, cx.data_layout().pointer_size) as i128;\n-        assert_eq!(b as i64 as i128, b);\n+        let sz = cx.data_layout().pointer_size;\n+        let b = self.to_bits(sz)?;\n+        let b = sign_extend(b, sz) as i128;\n         Ok(b as i64)\n     }\n "}, {"sha": "e2a8cd6b17df62c0ba3b38295f3adf5d5a2a0beb", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1669,10 +1669,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                         .map(|&u| {\n                             tcx.mk_const(ty::Const {\n                                 val: ConstValue::Scalar(\n-                                    Scalar::Bits {\n-                                        bits: u,\n-                                        size: size.bytes() as u8,\n-                                    }.into(),\n+                                    Scalar::from_uint(u, size).into(),\n                                 ),\n                                 ty: switch_ty,\n                             }).to_string().into()"}, {"sha": "f4ee39d69883c5d933eb7926930d123bcf2c21aa", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -117,16 +117,16 @@ impl LinkerPluginLto {\n }\n \n #[derive(Clone, PartialEq, Hash)]\n-pub enum PgoGenerate {\n+pub enum SwitchWithOptPath {\n     Enabled(Option<PathBuf>),\n     Disabled,\n }\n \n-impl PgoGenerate {\n+impl SwitchWithOptPath {\n     pub fn enabled(&self) -> bool {\n         match *self {\n-            PgoGenerate::Enabled(_) => true,\n-            PgoGenerate::Disabled => false,\n+            SwitchWithOptPath::Enabled(_) => true,\n+            SwitchWithOptPath::Disabled => false,\n         }\n     }\n }\n@@ -834,15 +834,15 @@ macro_rules! options {\n         pub const parse_linker_plugin_lto: Option<&str> =\n             Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), \\\n                   or the path to the linker plugin\");\n-        pub const parse_pgo_generate: Option<&str> =\n+        pub const parse_switch_with_opt_path: Option<&str> =\n             Some(\"an optional path to the profiling data output directory\");\n         pub const parse_merge_functions: Option<&str> =\n             Some(\"one of: `disabled`, `trampolines`, or `aliases`\");\n     }\n \n     #[allow(dead_code)]\n     mod $mod_set {\n-        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto, PgoGenerate};\n+        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath};\n         use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n         use std::path::PathBuf;\n         use std::str::FromStr;\n@@ -1097,10 +1097,10 @@ macro_rules! options {\n             true\n         }\n \n-        fn parse_pgo_generate(slot: &mut PgoGenerate, v: Option<&str>) -> bool {\n+        fn parse_switch_with_opt_path(slot: &mut SwitchWithOptPath, v: Option<&str>) -> bool {\n             *slot = match v {\n-                None => PgoGenerate::Enabled(None),\n-                Some(path) => PgoGenerate::Enabled(Some(PathBuf::from(path))),\n+                None => SwitchWithOptPath::Enabled(None),\n+                Some(path) => SwitchWithOptPath::Enabled(Some(PathBuf::from(path))),\n             };\n             true\n         }\n@@ -1379,7 +1379,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"extra arguments to prepend to the linker invocation (space separated)\"),\n     profile: bool = (false, parse_bool, [TRACKED],\n                      \"insert profiling code\"),\n-    pgo_gen: PgoGenerate = (PgoGenerate::Disabled, parse_pgo_generate, [TRACKED],\n+    pgo_gen: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n+        parse_switch_with_opt_path, [TRACKED],\n         \"Generate PGO profile data, to a given file, or to the default location if it's empty.\"),\n     pgo_use: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n         \"Use PGO profile data from the given profile file.\"),\n@@ -1447,7 +1448,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"don't interleave execution of lints; allows benchmarking individual lints\"),\n     crate_attr: Vec<String> = (Vec::new(), parse_string_push, [TRACKED],\n         \"inject the given attribute in the crate\"),\n-    self_profile: bool = (false, parse_bool, [UNTRACKED],\n+    self_profile: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n+        parse_switch_with_opt_path, [UNTRACKED],\n         \"run the self profiler and output the raw event data\"),\n     self_profile_events: Option<Vec<String>> = (None, parse_opt_comma_list, [UNTRACKED],\n         \"specifies which kinds of events get recorded by the self profiler\"),\n@@ -2558,7 +2560,7 @@ mod dep_tracking {\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n     use super::{CrateType, DebugInfo, ErrorOutputType, OptLevel, OutputTypes,\n-                Passes, Sanitizer, LtoCli, LinkerPluginLto, PgoGenerate};\n+                Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel, TargetTriple};\n     use syntax::edition::Edition;\n@@ -2626,7 +2628,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(TargetTriple);\n     impl_dep_tracking_hash_via_hash!(Edition);\n     impl_dep_tracking_hash_via_hash!(LinkerPluginLto);\n-    impl_dep_tracking_hash_via_hash!(PgoGenerate);\n+    impl_dep_tracking_hash_via_hash!(SwitchWithOptPath);\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);\n@@ -2694,7 +2696,7 @@ mod tests {\n         build_session_options_and_crate_config,\n         to_crate_config\n     };\n-    use crate::session::config::{LtoCli, LinkerPluginLto, PgoGenerate, ExternEntry};\n+    use crate::session::config::{LtoCli, LinkerPluginLto, SwitchWithOptPath, ExternEntry};\n     use crate::session::build_session;\n     use crate::session::search_paths::SearchPath;\n     use std::collections::{BTreeMap, BTreeSet};\n@@ -3207,7 +3209,7 @@ mod tests {\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n         opts = reference.clone();\n-        opts.debugging_opts.pgo_gen = PgoGenerate::Enabled(None);\n+        opts.debugging_opts.pgo_gen = SwitchWithOptPath::Enabled(None);\n         assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n         opts = reference.clone();"}, {"sha": "974a5bb70e65300ba298b939e1eddbd6f9ae5793", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -9,7 +9,7 @@ use crate::lint;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::middle::allocator::AllocatorKind;\n use crate::middle::dependency_format;\n-use crate::session::config::OutputType;\n+use crate::session::config::{OutputType, SwitchWithOptPath};\n use crate::session::search_paths::{PathKind, SearchPath};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use crate::util::common::{duration_to_secs_str, ErrorReported};\n@@ -1137,8 +1137,18 @@ fn build_session_(\n     driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n ) -> Session {\n     let self_profiler =\n-        if sopts.debugging_opts.self_profile {\n-            let profiler = SelfProfiler::new(&sopts.debugging_opts.self_profile_events);\n+        if let SwitchWithOptPath::Enabled(ref d) = sopts.debugging_opts.self_profile {\n+            let directory = if let Some(ref directory) = d {\n+                directory\n+            } else {\n+                std::path::Path::new(\".\")\n+            };\n+\n+            let profiler = SelfProfiler::new(\n+                directory,\n+                sopts.crate_name.as_ref().map(|s| &s[..]),\n+                &sopts.debugging_opts.self_profile_events\n+            );\n             match profiler {\n                 Ok(profiler) => {\n                     crate::ty::query::QueryName::register_with_profiler(&profiler);"}, {"sha": "92de3e28d19035467e858af53fbba8d1837dd3ae", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1001,7 +1001,7 @@ impl<'tcx> CommonConsts<'tcx> {\n \n         CommonConsts {\n             err: mk_const(ty::Const {\n-                val: ConstValue::Scalar(Scalar::Bits { bits: 0, size: 0 }),\n+                val: ConstValue::Scalar(Scalar::zst()),\n                 ty: types.err,\n             }),\n         }"}, {"sha": "a246d9652f2f045ef3b1c9667b736c191e0d2d62", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -845,34 +845,34 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n             p!(write(\"{}\", name));\n             return Ok(self);\n         }\n-        if let ConstValue::Scalar(Scalar::Bits { bits, .. }) = ct.val {\n+        if let ConstValue::Scalar(Scalar::Raw { data, .. }) = ct.val {\n             match ct.ty.sty {\n                 ty::Bool => {\n-                    p!(write(\"{}\", if bits == 0 { \"false\" } else { \"true\" }));\n+                    p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" }));\n                     return Ok(self);\n                 },\n                 ty::Float(ast::FloatTy::F32) => {\n-                    p!(write(\"{}f32\", Single::from_bits(bits)));\n+                    p!(write(\"{}f32\", Single::from_bits(data)));\n                     return Ok(self);\n                 },\n                 ty::Float(ast::FloatTy::F64) => {\n-                    p!(write(\"{}f64\", Double::from_bits(bits)));\n+                    p!(write(\"{}f64\", Double::from_bits(data)));\n                     return Ok(self);\n                 },\n                 ty::Uint(ui) => {\n-                    p!(write(\"{}{}\", bits, ui));\n+                    p!(write(\"{}{}\", data, ui));\n                     return Ok(self);\n                 },\n                 ty::Int(i) =>{\n                     let ty = self.tcx().lift_to_global(&ct.ty).unwrap();\n                     let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n                         .unwrap()\n                         .size;\n-                    p!(write(\"{}{}\", sign_extend(bits, size) as i128, i));\n+                    p!(write(\"{}{}\", sign_extend(data, size) as i128, i));\n                     return Ok(self);\n                 },\n                 ty::Char => {\n-                    p!(write(\"{:?}\", ::std::char::from_u32(bits as u32).unwrap()));\n+                    p!(write(\"{:?}\", ::std::char::from_u32(data as u32).unwrap()));\n                     return Ok(self);\n                 }\n                 _ => {},"}, {"sha": "75d227d8067c3c088348f5a54ea98702b9a9bdce", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -613,7 +613,7 @@ where\n         (ConstValue::Placeholder(p1), ConstValue::Placeholder(p2)) if p1 == p2 => {\n             Ok(a)\n         }\n-        (ConstValue::Scalar(Scalar::Bits { .. }), _) if a == b => {\n+        (ConstValue::Scalar(Scalar::Raw { .. }), _) if a == b => {\n             Ok(a)\n         }\n         (ConstValue::ByRef(..), _) => {"}, {"sha": "0a673dd380b5254416da4ea452c86d6f1e7dbc60", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -3,7 +3,7 @@\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::canonical::Canonical;\n-use crate::mir::interpret::{ConstValue, truncate};\n+use crate::mir::interpret::ConstValue;\n use crate::middle::region;\n use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -2232,14 +2232,12 @@ impl<'tcx> Const<'tcx> {\n         let size = tcx.layout_of(ty).unwrap_or_else(|e| {\n             panic!(\"could not compute layout for {:?}: {:?}\", ty, e)\n         }).size;\n-        let truncated = truncate(bits, size);\n-        assert_eq!(truncated, bits, \"from_bits called with untruncated value\");\n-        Self::from_scalar(tcx, Scalar::Bits { bits, size: size.bytes() as u8 }, ty.value)\n+        Self::from_scalar(tcx, Scalar::from_uint(bits, size), ty.value)\n     }\n \n     #[inline]\n     pub fn zero_sized(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n-        Self::from_scalar(tcx, Scalar::Bits { bits: 0, size: 0 }, ty)\n+        Self::from_scalar(tcx, Scalar::zst(), ty)\n     }\n \n     #[inline]"}, {"sha": "8624856a4f55ca96fd0da56bc62403445bd47f07", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,6 +1,8 @@\n use std::borrow::Cow;\n use std::error::Error;\n+use std::fs;\n use std::mem::{self, Discriminant};\n+use std::path::Path;\n use std::process;\n use std::thread::ThreadId;\n use std::u32;\n@@ -71,10 +73,17 @@ pub struct SelfProfiler {\n }\n \n impl SelfProfiler {\n-    pub fn new(event_filters: &Option<Vec<String>>) -> Result<SelfProfiler, Box<dyn Error>> {\n-        let filename = format!(\"pid-{}.rustc_profile\", process::id());\n-        let path = std::path::Path::new(&filename);\n-        let profiler = Profiler::new(path)?;\n+    pub fn new(\n+        output_directory: &Path,\n+        crate_name: Option<&str>,\n+        event_filters: &Option<Vec<String>>\n+    ) -> Result<SelfProfiler, Box<dyn Error>> {\n+        fs::create_dir_all(output_directory)?;\n+\n+        let crate_name = crate_name.unwrap_or(\"unknown-crate\");\n+        let filename = format!(\"{}-{}.rustc_profile\", crate_name, process::id());\n+        let path = output_directory.join(&filename);\n+        let profiler = Profiler::new(&path)?;\n \n         let query_event_kind = profiler.alloc_string(\"Query\");\n         let generic_activity_event_kind = profiler.alloc_string(\"GenericActivity\");"}, {"sha": "d8a9f681639a049d28063c7d9cb348c1c81c57a7", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -13,7 +13,7 @@ use crate::LlvmCodegenBackend;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig, run_assembler};\n use rustc_codegen_ssa::traits::*;\n-use rustc::session::config::{self, OutputType, Passes, Lto, PgoGenerate};\n+use rustc::session::config::{self, OutputType, Passes, Lto, SwitchWithOptPath};\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_codegen_ssa::{RLIB_BYTECODE_EXTENSION, ModuleCodegen, CompiledModule};\n@@ -707,7 +707,7 @@ pub unsafe fn with_llvm_pmb(llmod: &llvm::Module,\n     let inline_threshold = config.inline_threshold;\n \n     let pgo_gen_path = match config.pgo_gen {\n-        PgoGenerate::Enabled(ref opt_dir_path) => {\n+        SwitchWithOptPath::Enabled(ref opt_dir_path) => {\n             let path = if let Some(dir_path) = opt_dir_path {\n                 dir_path.join(\"default_%m.profraw\")\n             } else {\n@@ -716,7 +716,7 @@ pub unsafe fn with_llvm_pmb(llmod: &llvm::Module,\n \n             Some(CString::new(format!(\"{}\", path.display())).unwrap())\n         }\n-        PgoGenerate::Disabled => {\n+        SwitchWithOptPath::Disabled => {\n             None\n         }\n     };"}, {"sha": "c713362440d97140b8d185fe00c76049d2942ed4", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -294,13 +294,13 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     ) -> &'ll Value {\n         let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n         match cv {\n-            Scalar::Bits { size: 0, .. } => {\n+            Scalar::Raw { size: 0, .. } => {\n                 assert_eq!(0, layout.value.size(self).bytes());\n                 self.const_undef(self.type_ix(0))\n             },\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, layout.value.size(self).bytes());\n-                let llval = self.const_uint_big(self.type_ix(bitsize), bits);\n+                let llval = self.const_uint_big(self.type_ix(bitsize), data);\n                 if layout.value == layout::Pointer {\n                     unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n                 } else {"}, {"sha": "5abff2d8ec35042a08f4cae7a56dbddf8cb4df15", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -13,7 +13,7 @@ use rustc::dep_graph::{WorkProduct, WorkProductId, WorkProductFileKind};\n use rustc::dep_graph::cgu_reuse_tracker::CguReuseTracker;\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::session::config::{self, OutputFilenames, OutputType, Passes, Lto,\n-                             Sanitizer, PgoGenerate};\n+                             Sanitizer, SwitchWithOptPath};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n@@ -56,7 +56,7 @@ pub struct ModuleConfig {\n     /// Some(level) to optimize binary size, or None to not affect program size.\n     pub opt_size: Option<config::OptLevel>,\n \n-    pub pgo_gen: PgoGenerate,\n+    pub pgo_gen: SwitchWithOptPath,\n     pub pgo_use: Option<PathBuf>,\n \n     // Flags indicating which outputs to produce.\n@@ -94,7 +94,7 @@ impl ModuleConfig {\n             opt_level: None,\n             opt_size: None,\n \n-            pgo_gen: PgoGenerate::Disabled,\n+            pgo_gen: SwitchWithOptPath::Disabled,\n             pgo_use: None,\n \n             emit_no_opt_bc: false,"}, {"sha": "bf81b7f0da5258fee7c8bff4374072bb0ce4ff63", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -443,7 +443,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n         ct: &'tcx ty::Const<'tcx>,\n     ) -> Result<Self::Const, Self::Error> {\n         // only print integers\n-        if let ConstValue::Scalar(Scalar::Bits { .. }) = ct.val {\n+        if let ConstValue::Scalar(Scalar::Raw { .. }) = ct.val {\n             if ct.ty.is_integral() {\n                 return self.pretty_print_const(ct);\n             }"}, {"sha": "7b3d0bceb6896c475f979ff91b91d2887a5c925d", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -115,7 +115,7 @@ fn op_to_const<'tcx>(\n                     ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n                     ptr.offset.bytes(),\n                 ),\n-                Scalar::Bits { .. } => (\n+                Scalar::Raw { .. } => (\n                     ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\", ())),\n                     0,\n                 ),"}, {"sha": "69df36348a69e6ffbe47801b1d71cabda1f14a0f", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,5 +1,5 @@\n use syntax::ast;\n-use rustc::ty::{self, Ty, TyCtxt, ParamEnv};\n+use rustc::ty::{self, Ty, TyCtxt, ParamEnv, layout::Size};\n use syntax_pos::symbol::Symbol;\n use rustc::mir::interpret::{ConstValue, Scalar};\n \n@@ -23,10 +23,7 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n         let result = truncate(n, width);\n         trace!(\"trunc result: {}\", result);\n-        Ok(ConstValue::Scalar(Scalar::Bits {\n-            bits: result,\n-            size: width.bytes() as u8,\n-        }))\n+        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n     };\n \n     use rustc::mir::interpret::*;\n@@ -50,10 +47,7 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::Ptr(id.into()))\n         },\n-        LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n-            bits: n as u128,\n-            size: 1,\n-        }),\n+        LitKind::Byte(n) => ConstValue::Scalar(Scalar::from_uint(n, Size::from_bytes(1))),\n         LitKind::Int(n, _) if neg => {\n             let n = n as i128;\n             let n = n.overflowing_neg().0;\n@@ -84,7 +78,7 @@ fn parse_float<'tcx>(\n     let num = num.as_str();\n     use rustc_apfloat::ieee::{Single, Double};\n     use rustc_apfloat::Float;\n-    let (bits, size) = match fty {\n+    let (data, size) = match fty {\n         ast::FloatTy::F32 => {\n             num.parse::<f32>().map_err(|_| ())?;\n             let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n@@ -107,5 +101,5 @@ fn parse_float<'tcx>(\n         }\n     };\n \n-    Ok(ConstValue::Scalar(Scalar::Bits { bits, size }))\n+    Ok(ConstValue::Scalar(Scalar::from_uint(data, Size::from_bytes(size))))\n }"}, {"sha": "76b11ac2fe6463a4515782d743e1a2b30dc018ee", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -6,7 +6,7 @@ use syntax::symbol::sym;\n \n use rustc_apfloat::ieee::{Single, Double};\n use rustc::mir::interpret::{\n-    Scalar, EvalResult, Pointer, PointerArithmetic, InterpError, truncate\n+    Scalar, EvalResult, Pointer, PointerArithmetic, InterpError,\n };\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n@@ -135,29 +135,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         use rustc::ty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_layout.ty, dest_layout.ty);\n \n-        match val {\n-            Scalar::Ptr(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n-            Scalar::Bits { bits, size } => {\n-                debug_assert_eq!(size as u64, src_layout.size.bytes());\n-                debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n-                    \"Unexpected value of size {} before casting\", size);\n-\n-                let res = match src_layout.ty.sty {\n-                    Float(fty) => self.cast_from_float(bits, fty, dest_layout.ty)?,\n-                    _ => self.cast_from_int(bits, src_layout, dest_layout)?,\n-                };\n-\n-                // Sanity check\n-                match res {\n-                    Scalar::Ptr(_) => bug!(\"Fabricated a ptr value from an int...?\"),\n-                    Scalar::Bits { bits, size } => {\n-                        debug_assert_eq!(size as u64, dest_layout.size.bytes());\n-                        debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n-                            \"Unexpected value of size {} after casting\", size);\n-                    }\n+        match val.to_bits_or_ptr(src_layout.size, self) {\n+            Err(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n+            Ok(data) => {\n+                match src_layout.ty.sty {\n+                    Float(fty) => self.cast_from_float(data, fty, dest_layout.ty),\n+                    _ => self.cast_from_int(data, src_layout, dest_layout),\n                 }\n-                // Done\n-                Ok(res)\n             }\n         }\n     }\n@@ -177,7 +161,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         trace!(\"cast_from_int: {}, {}, {}\", v, src_layout.ty, dest_layout.ty);\n         use rustc::ty::TyKind::*;\n         match dest_layout.ty.sty {\n-            Int(_) | Uint(_) => {\n+            Int(_) | Uint(_) | RawPtr(_) => {\n                 let v = self.truncate(v, dest_layout);\n                 Ok(Scalar::from_uint(v, dest_layout.size))\n             }\n@@ -205,15 +189,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 Ok(Scalar::from_uint(v, Size::from_bytes(4)))\n             },\n \n-            // No alignment check needed for raw pointers.\n-            // But we have to truncate to target ptr size.\n-            RawPtr(_) => {\n-                Ok(Scalar::from_uint(\n-                    self.truncate_to_ptr(v).0,\n-                    self.pointer_size(),\n-                ))\n-            },\n-\n             // Casts to bool are not permitted by rustc, no need to handle them here.\n             _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n         }"}, {"sha": "65a3b04c8b152f1c26eb0762e92eb7dd58a61152", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -12,7 +12,6 @@ use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n use rustc::ty::layout::{Align, TargetDataLayout, Size, HasDataLayout};\n-pub use rustc::mir::interpret::{truncate, write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use syntax::ast::Mutability;\n@@ -248,23 +247,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         required_align: Align\n     ) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n-        let (offset, alloc_align) = match ptr {\n-            Scalar::Ptr(ptr) => {\n+        let (offset, alloc_align) = match ptr.to_bits_or_ptr(self.pointer_size(), self) {\n+            Err(ptr) => {\n                 // check this is not NULL -- which we can ensure only if this is in-bounds\n                 // of some (potentially dead) allocation.\n                 let align = self.check_bounds_ptr(ptr, InboundsCheck::MaybeDead,\n                                                   CheckInAllocMsg::NullPointerTest)?;\n                 (ptr.offset.bytes(), align)\n             }\n-            Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, self.pointer_size().bytes());\n-                assert!(bits < (1u128 << self.pointer_size().bits()));\n+            Ok(data) => {\n                 // check this is not NULL\n-                if bits == 0 {\n+                if data == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n                 // the \"base address\" is 0 and hence always aligned\n-                (bits as u64, required_align)\n+                (data as u64, required_align)\n             }\n         };\n         // Check alignment"}, {"sha": "289379f34a9a3bb8771d4dfe0253f7e97689fde4", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -641,19 +641,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             } => {\n                 let variants_start = niche_variants.start().as_u32() as u128;\n                 let variants_end = niche_variants.end().as_u32() as u128;\n-                match raw_discr {\n-                    ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) => {\n+                let raw_discr = raw_discr.not_undef()\n+                    .map_err(|_| InterpError::InvalidDiscriminant(ScalarMaybeUndef::Undef))?;\n+                match raw_discr.to_bits_or_ptr(discr_val.layout.size, self) {\n+                    Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n                             self.memory.check_bounds_ptr(ptr, InboundsCheck::MaybeDead,\n                                                          CheckInAllocMsg::NullPointerTest).is_ok();\n                         if !ptr_valid {\n-                            return err!(InvalidDiscriminant(raw_discr.erase_tag()));\n+                            return err!(InvalidDiscriminant(raw_discr.erase_tag().into()));\n                         }\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },\n-                    ScalarMaybeUndef::Scalar(Scalar::Bits { bits: raw_discr, size }) => {\n-                        assert_eq!(size as u64, discr_val.layout.size.bytes());\n+                    Ok(raw_discr) => {\n                         let adjusted_discr = raw_discr.wrapping_sub(niche_start)\n                             .wrapping_add(variants_start);\n                         if variants_start <= adjusted_discr && adjusted_discr <= variants_end {\n@@ -668,8 +669,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                             (dataful_variant.as_u32() as u128, dataful_variant)\n                         }\n                     },\n-                    ScalarMaybeUndef::Undef =>\n-                        return err!(InvalidDiscriminant(ScalarMaybeUndef::Undef)),\n                 }\n             }\n         })"}, {"sha": "0ae4e90b7c24d57afb72319874960c5893f79c6e", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -686,7 +686,7 @@ where\n                 Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Ptr(_))) =>\n                     assert_eq!(self.pointer_size(), dest.layout.size,\n                         \"Size mismatch when writing pointer\"),\n-                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { size, .. })) =>\n+                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Raw { size, .. })) =>\n                     assert_eq!(Size::from_bytes(size.into()), dest.layout.size,\n                         \"Size mismatch when writing bits\"),\n                 Immediate::Scalar(ScalarMaybeUndef::Undef) => {}, // undef can have any size"}, {"sha": "c0bc7ce6b39ad09af7c5d7e790fef386c4f68a78", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -186,9 +186,9 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for Scalar\n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n         match self {\n             Scalar::Ptr(p) => Scalar::Ptr(p.snapshot(ctx)),\n-            Scalar::Bits{ size, bits } => Scalar::Bits {\n+            Scalar::Raw{ size, data } => Scalar::Raw {\n+                data: *data,\n                 size: *size,\n-                bits: *bits,\n             },\n         }\n     }"}, {"sha": "072c6f4fd90e8e9641bcf2264246bc025050f2ab", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -480,8 +480,8 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 wrapping_range_format(&layout.valid_range, max_hi),\n             )\n         );\n-        let bits = match value {\n-            Scalar::Ptr(ptr) => {\n+        let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n+            Err(ptr) => {\n                 if lo == 1 && hi == max_hi {\n                     // only NULL is not allowed.\n                     // We can call `check_align` to check non-NULL-ness, but have to also look\n@@ -509,10 +509,8 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     );\n                 }\n             }\n-            Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, op.layout.size.bytes());\n-                bits\n-            }\n+            Ok(data) =>\n+                data\n         };\n         // Now compare. This is slightly subtle because this is a special \"wrap-around\" range.\n         if wrapping_range_contains(&layout.valid_range, bits) {"}, {"sha": "c46b439f4d34e1105ebe9834ed118e9e5cebebb3", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -382,10 +382,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some(\n                     ImmTy {\n                         imm: Immediate::Scalar(\n-                            Scalar::Bits {\n-                                bits: n as u128,\n-                                size: self.tcx.data_layout.pointer_size.bytes() as u8,\n-                            }.into()\n+                            Scalar::from_uint(n, self.tcx.data_layout.pointer_size).into()\n                         ),\n                         layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n                     }.into()\n@@ -713,18 +710,18 @@ impl<'b, 'a, 'tcx> MutVisitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                                     .eval_operand(len, source_info)\n                                     .expect(\"len must be const\");\n                                 let len = match self.ecx.read_scalar(len) {\n-                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-                                        bits, ..\n-                                    })) => bits,\n+                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Raw {\n+                                        data, ..\n+                                    })) => data,\n                                     other => bug!(\"const len not primitive: {:?}\", other),\n                                 };\n                                 let index = self\n                                     .eval_operand(index, source_info)\n                                     .expect(\"index must be const\");\n                                 let index = match self.ecx.read_scalar(index) {\n-                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-                                        bits, ..\n-                                    })) => bits,\n+                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Raw {\n+                                        data, ..\n+                                    })) => data,\n                                     other => bug!(\"const index not primitive: {:?}\", other),\n                                 };\n                                 format!("}, {"sha": "5f10f2aa3b0f419836efb67d7a4f23bbdc5c5def", "filename": "src/test/run-make-fulldeps/print-target-list/Makefile", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Frun-make-fulldeps%2Fprint-target-list%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Frun-make-fulldeps%2Fprint-target-list%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fprint-target-list%2FMakefile?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -2,14 +2,7 @@\n \n # Checks that all the targets returned by `rustc --print target-list` are valid\n # target specifications\n-# TODO remove the '*ios*' case when rust-lang/rust#29812 is fixed\n all:\n \tfor target in $(shell $(BARE_RUSTC) --print target-list); do \\\n-\t\tcase $$target in \\\n-\t\t\t*ios*) \\\n-\t\t\t\t;; \\\n-\t\t\t*) \\\n-\t\t\t\t$(BARE_RUSTC) --target $$target --print sysroot \\\n-\t\t\t\t;; \\\n-\t\t\tesac \\\n+\t\t$(BARE_RUSTC) --target $$target --print sysroot; \\\n \tdone"}]}