{"sha": "cfee49593d756bb97018d1d2ac194e0821d2dfca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZWU0OTU5M2Q3NTZiYjk3MDE4ZDFkMmFjMTk0ZTA4MjFkMmRmY2E=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-07-23T20:59:20Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:19:31Z"}, "message": "Handle multiple applicable projection candidates", "tree": {"sha": "6b93b9dc025cbf3275b384cc52fcd39d250ad3dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b93b9dc025cbf3275b384cc52fcd39d250ad3dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfee49593d756bb97018d1d2ac194e0821d2dfca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfee49593d756bb97018d1d2ac194e0821d2dfca", "html_url": "https://github.com/rust-lang/rust/commit/cfee49593d756bb97018d1d2ac194e0821d2dfca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfee49593d756bb97018d1d2ac194e0821d2dfca/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc08b791bce1c5b31052da5dfda74302b6f61a99", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc08b791bce1c5b31052da5dfda74302b6f61a99", "html_url": "https://github.com/rust-lang/rust/commit/bc08b791bce1c5b31052da5dfda74302b6f61a99"}], "stats": {"total": 119, "additions": 82, "deletions": 37}, "files": [{"sha": "fc4c343372a425d980d065e660f3db5a2459aa72", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfee49593d756bb97018d1d2ac194e0821d2dfca/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfee49593d756bb97018d1d2ac194e0821d2dfca/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=cfee49593d756bb97018d1d2ac194e0821d2dfca", "patch": "@@ -157,7 +157,7 @@ rustc_queries! {\n         }\n \n         /// Returns the list of bounds that can be used for\n-        /// `SelectionCandidate::ProjectionCandidate` and\n+        /// `SelectionCandidate::ProjectionCandidate(_)` and\n         /// `ProjectionTyCandidate::TraitDef`.\n         /// Specifically this is the bounds written on the trait's type\n         /// definition, or those after the `impl` keyword"}, {"sha": "358ead507b4d0465f590081913acb6e517569f54", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfee49593d756bb97018d1d2ac194e0821d2dfca/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfee49593d756bb97018d1d2ac194e0821d2dfca/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=cfee49593d756bb97018d1d2ac194e0821d2dfca", "patch": "@@ -105,9 +105,10 @@ pub enum SelectionCandidate<'tcx> {\n     ImplCandidate(DefId),\n     AutoImplCandidate(DefId),\n \n-    /// This is a trait matching with a projected type as `Self`, and\n-    /// we found an applicable bound in the trait definition.\n-    ProjectionCandidate,\n+    /// This is a trait matching with a projected type as `Self`, and we found\n+    /// an applicable bound in the trait definition. The `usize` is an index\n+    /// into the list returned by `tcx.item_bounds`.\n+    ProjectionCandidate(usize),\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous types\n     /// generated for a `||` expression."}, {"sha": "1ac9be64f1f1f32d8536a0ac618c54abe0b096d5", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfee49593d756bb97018d1d2ac194e0821d2dfca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfee49593d756bb97018d1d2ac194e0821d2dfca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=cfee49593d756bb97018d1d2ac194e0821d2dfca", "patch": "@@ -323,12 +323,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => return,\n         }\n \n-        let result = self.infcx.probe(|_| {\n-            self.match_projection_obligation_against_definition_bounds(obligation).is_some()\n-        });\n+        let result = self\n+            .infcx\n+            .probe(|_| self.match_projection_obligation_against_definition_bounds(obligation));\n \n-        if result {\n-            candidates.vec.push(ProjectionCandidate);\n+        for predicate_index in result {\n+            candidates.vec.push(ProjectionCandidate(predicate_index));\n         }\n     }\n "}, {"sha": "d0b4bec1b1a0a1208afc79c65d44166ad1820097", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cfee49593d756bb97018d1d2ac194e0821d2dfca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfee49593d756bb97018d1d2ac194e0821d2dfca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=cfee49593d756bb97018d1d2ac194e0821d2dfca", "patch": "@@ -70,8 +70,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(ImplSource::AutoImpl(data))\n             }\n \n-            ProjectionCandidate => {\n-                let obligations = self.confirm_projection_candidate(obligation);\n+            ProjectionCandidate(idx) => {\n+                let obligations = self.confirm_projection_candidate(obligation, idx);\n                 Ok(ImplSource::Param(obligations))\n             }\n \n@@ -121,11 +121,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_projection_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n+        idx: usize,\n     ) -> Vec<PredicateObligation<'tcx>> {\n         self.infcx.commit_unconditionally(|_| {\n-            let candidate = self\n-                .match_projection_obligation_against_definition_bounds(obligation)\n-                .unwrap_or_else(|| bug!(\"Can't find selected projection candidate\"));\n+            let tcx = self.tcx();\n+\n+            let bound_self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+            let (def_id, substs) = match bound_self_ty.skip_binder().kind {\n+                ty::Projection(proj) => (proj.item_def_id, proj.substs),\n+                ty::Opaque(def_id, substs) => (def_id, substs),\n+                _ => bug!(\"projection candidate for unexpected type: {:?}\", bound_self_ty),\n+            };\n+\n+            let candidate_predicate = tcx.item_bounds(def_id)[idx].subst(tcx, substs);\n+            let candidate = candidate_predicate\n+                .to_opt_poly_trait_ref()\n+                .expect(\"projection candidate is not a trait predicate\");\n             let mut obligations = self\n                 .infcx\n                 .at(&obligation.cause, obligation.param_env)\n@@ -139,7 +150,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     );\n                 });\n             // Require that the projection is well-formed.\n-            let self_ty = self.infcx.replace_bound_vars_with_placeholders(&obligation.self_ty());\n+            let self_ty = self.infcx.replace_bound_vars_with_placeholders(&bound_self_ty);\n             let self_ty = normalize_with_depth_to(\n                 self,\n                 obligation.param_env,\n@@ -152,7 +163,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 obligation.cause.clone(),\n                 obligation.recursion_depth + 1,\n                 obligation.param_env,\n-                ty::PredicateKind::WellFormed(self_ty.into()).to_predicate(self.tcx()),\n+                ty::PredicateKind::WellFormed(self_ty.into()).to_predicate(tcx),\n             ));\n             obligations\n         })"}, {"sha": "e1dd3f215ca8c026c152e5a350d3dc924fafb7d4", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cfee49593d756bb97018d1d2ac194e0821d2dfca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfee49593d756bb97018d1d2ac194e0821d2dfca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=cfee49593d756bb97018d1d2ac194e0821d2dfca", "patch": "@@ -1163,11 +1163,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///\n     /// Given an obligation like `<T as Foo>::Bar: Baz` where the self type is\n     /// a projection, look at the bounds of `T::Bar`, see if we can find a\n-    /// `Baz` bound and it there is one it returns it.\n+    /// `Baz` bound. We return indexes into the list returned by\n+    /// `tcx.item_bounds` for any applicable bounds.\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Option<ty::PolyTraitRef<'tcx>> {\n+    ) -> smallvec::SmallVec<[usize; 2]> {\n         let poly_trait_predicate = self.infcx().resolve_vars_if_possible(&obligation.predicate);\n         let placeholder_trait_predicate =\n             self.infcx().replace_bound_vars_with_placeholders(&poly_trait_predicate);\n@@ -1192,25 +1193,33 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n         let bounds = tcx.item_bounds(def_id).subst(tcx, substs);\n \n-        let matching_bound = bounds.iter().find_map(|bound| {\n-            if let ty::PredicateAtom::Trait(pred, _) = bound.skip_binders() {\n-                let bound = ty::Binder::bind(pred.trait_ref);\n-                if self.infcx.probe(|_| {\n-                    self.match_projection(obligation, bound, placeholder_trait_predicate.trait_ref)\n+        let matching_bounds = bounds\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(idx, bound)| {\n+                if let ty::PredicateAtom::Trait(pred, _) = bound.skip_binders() {\n+                    let bound = ty::Binder::bind(pred.trait_ref);\n+                    if self.infcx.probe(|_| {\n+                        self.match_projection(\n+                            obligation,\n+                            bound,\n+                            placeholder_trait_predicate.trait_ref,\n+                        )\n                         .is_ok()\n-                }) {\n-                    return Some(bound);\n+                    }) {\n+                        return Some(idx);\n+                    }\n                 }\n-            }\n-            None\n-        });\n+                None\n+            })\n+            .collect();\n \n         debug!(\n             \"match_projection_obligation_against_definition_bounds: \\\n-             matching_bound={:?}\",\n-            matching_bound\n+             matching_bounds={:?}\",\n+            matching_bounds\n         );\n-        matching_bound\n+        matching_bounds\n     }\n \n     fn match_projection(\n@@ -1299,14 +1308,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // clause so don't go around looking for impls.\n                     !is_global(cand)\n                 }\n-                ObjectCandidate | ProjectionCandidate => {\n+                ObjectCandidate | ProjectionCandidate(_) => {\n                     // Arbitrarily give param candidates priority\n                     // over projection and object candidates.\n                     !is_global(cand)\n                 }\n                 ParamCandidate(..) => false,\n             },\n-            ObjectCandidate | ProjectionCandidate => match victim.candidate {\n+            ObjectCandidate | ProjectionCandidate(_) => match victim.candidate {\n                 AutoImplCandidate(..) => {\n                     bug!(\n                         \"default implementations shouldn't be recorded \\\n@@ -1323,10 +1332,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | BuiltinUnsizeCandidate\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..) => true,\n-                ObjectCandidate | ProjectionCandidate => {\n-                    // Arbitrarily give param candidates priority\n-                    // over projection and object candidates.\n-                    true\n+                ObjectCandidate | ProjectionCandidate(_) => {\n+                    // Shouldn't have both an object and projection candidate,\n+                    // nor multiple object candidates. Multiple projection\n+                    // candidates are ambiguous.\n+                    false\n                 }\n                 ParamCandidate(ref cand) => is_global(cand),\n             },"}, {"sha": "9f179b6454e5292dfa4345461a969685594f7d57", "filename": "src/test/ui/associated-types/associated-types-bound-ambiguity.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cfee49593d756bb97018d1d2ac194e0821d2dfca/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfee49593d756bb97018d1d2ac194e0821d2dfca/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-ambiguity.rs?ref=cfee49593d756bb97018d1d2ac194e0821d2dfca", "patch": "@@ -0,0 +1,23 @@\n+// Make sure that if there are multiple applicable bounds on a projection, we\n+// consider them ambiguous. In this test we are initially trying to solve\n+// `Self::Repr: From<_>`, which is ambiguous until we later infer `_` to\n+// `{integer}`.\n+\n+// check-pass\n+\n+trait PrimeField: Sized {\n+    type Repr: From<u64> + From<Self>;\n+    type Repr2: From<Self> + From<u64>;\n+\n+    fn method() {\n+        Self::Repr::from(10);\n+        Self::Repr2::from(10);\n+    }\n+}\n+\n+fn function<T: PrimeField>() {\n+    T::Repr::from(10);\n+    T::Repr2::from(10);\n+}\n+\n+fn main() {}"}]}