{"sha": "56aaa532781e8591c1c5b50aafa2e64634a2de80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2YWFhNTMyNzgxZTg1OTFjMWM1YjUwYWFmYTJlNjQ2MzRhMmRlODA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-04-22T00:05:02Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-07-19T21:15:11Z"}, "message": "proc_macro: clean up the implementation of quasi-quoting.", "tree": {"sha": "9a2b6629b086f4a531be41c26135e1f89cd9a842", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a2b6629b086f4a531be41c26135e1f89cd9a842"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56aaa532781e8591c1c5b50aafa2e64634a2de80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56aaa532781e8591c1c5b50aafa2e64634a2de80", "html_url": "https://github.com/rust-lang/rust/commit/56aaa532781e8591c1c5b50aafa2e64634a2de80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56aaa532781e8591c1c5b50aafa2e64634a2de80/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d10d0b3e9eb5c72b651c52b6fd38f1db20589b47", "url": "https://api.github.com/repos/rust-lang/rust/commits/d10d0b3e9eb5c72b651c52b6fd38f1db20589b47", "html_url": "https://github.com/rust-lang/rust/commit/d10d0b3e9eb5c72b651c52b6fd38f1db20589b47"}], "stats": {"total": 286, "additions": 101, "deletions": 185}, "files": [{"sha": "c88a245d3b376872c5d4945de5cdb5909af2cd07", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56aaa532781e8591c1c5b50aafa2e64634a2de80/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56aaa532781e8591c1c5b50aafa2e64634a2de80/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=56aaa532781e8591c1c5b50aafa2e64634a2de80", "patch": "@@ -145,6 +145,9 @@ impl fmt::Debug for TokenStream {\n     }\n }\n \n+#[unstable(feature = \"proc_macro_quote\", issue = \"38356\")]\n+pub use quote::{quote, quote_span};\n+\n /// Creates a token stream containing a single token tree.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl From<TokenTree> for TokenStream {\n@@ -237,7 +240,7 @@ pub mod token_stream {\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n /// To quote `$` itself, use `$$`.\n ///\n-/// This is a dummy macro, the actual implementation is in quote::Quoter\n+/// This is a dummy macro, the actual implementation is in `quote::quote`.`\n #[unstable(feature = \"proc_macro_quote\", issue = \"38356\")]\n #[macro_export]\n macro_rules! quote { () => {} }\n@@ -246,13 +249,6 @@ macro_rules! quote { () => {} }\n #[doc(hidden)]\n mod quote;\n \n-/// Quote a `Span` into a `TokenStream`.\n-/// This is needed to implement a custom quoter.\n-#[unstable(feature = \"proc_macro_quote\", issue = \"38356\")]\n-pub fn quote_span(span: Span) -> TokenStream {\n-    quote::Quote::quote(span)\n-}\n-\n /// A region of source code, along with macro expansion information.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n #[derive(Copy, Clone)]\n@@ -1364,8 +1360,6 @@ impl TokenTree {\n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n #[doc(hidden)]\n pub mod __internal {\n-    pub use quote::{Quoter, unquote};\n-\n     use std::cell::Cell;\n     use std::ptr;\n "}, {"sha": "7ae7b13a15217b2026cd3adfde27e88c598620c7", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 92, "deletions": 173, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/56aaa532781e8591c1c5b50aafa2e64634a2de80/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56aaa532781e8591c1c5b50aafa2e64634a2de80/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=56aaa532781e8591c1c5b50aafa2e64634a2de80", "patch": "@@ -14,34 +14,26 @@\n //! This quasiquoter uses macros 2.0 hygiene to reliably access\n //! items from `proc_macro`, to build a `proc_macro::TokenStream`.\n \n-use {Delimiter, Literal, Spacing, Span, Ident, Punct, Group, TokenStream, TokenTree};\n-\n-use syntax::ext::base::{ExtCtxt, ProcMacro};\n-use syntax::tokenstream;\n-\n-/// This is the actual quote!() proc macro\n-///\n-/// It is manually loaded in CStore::load_macro_untracked\n-pub struct Quoter;\n-\n-pub fn unquote<T: Into<TokenStream> + Clone>(tokens: &T) -> TokenStream {\n-    tokens.clone().into()\n-}\n-\n-pub trait Quote {\n-    fn quote(self) -> TokenStream;\n-}\n-\n-macro_rules! tt2ts {\n-    ($e:expr) => (TokenStream::from(TokenTree::from($e)))\n-}\n-\n-macro_rules! quote_tok {\n-    (,) => { tt2ts!(Punct::new(',', Spacing::Alone)) };\n-    (.) => { tt2ts!(Punct::new('.', Spacing::Alone)) };\n-    (:) => { tt2ts!(Punct::new(':', Spacing::Alone)) };\n-    (;) => { tt2ts!(Punct::new(';', Spacing::Alone)) };\n-    (|) => { tt2ts!(Punct::new('|', Spacing::Alone)) };\n+use {Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};\n+\n+macro_rules! quote_tt {\n+    (($($t:tt)*)) => { Group::new(Delimiter::Parenthesis, quote!($($t)*)) };\n+    ([$($t:tt)*]) => { Group::new(Delimiter::Bracket, quote!($($t)*)) };\n+    ({$($t:tt)*}) => { Group::new(Delimiter::Brace, quote!($($t)*)) };\n+    (,) => { Punct::new(',', Spacing::Alone) };\n+    (.) => { Punct::new('.', Spacing::Alone) };\n+    (:) => { Punct::new(':', Spacing::Alone) };\n+    (;) => { Punct::new(';', Spacing::Alone) };\n+    (!) => { Punct::new('!', Spacing::Alone) };\n+    (<) => { Punct::new('<', Spacing::Alone) };\n+    (>) => { Punct::new('>', Spacing::Alone) };\n+    (&) => { Punct::new('&', Spacing::Alone) };\n+    (=) => { Punct::new('=', Spacing::Alone) };\n+    ($i:ident) => { Ident::new(stringify!($i), Span::def_site()) };\n+}\n+\n+macro_rules! quote_ts {\n+    ((@ $($t:tt)*)) => { $($t)* };\n     (::) => {\n         [\n             TokenTree::from(Punct::new(':', Spacing::Joint)),\n@@ -54,57 +46,45 @@ macro_rules! quote_tok {\n             })\n             .collect::<TokenStream>()\n     };\n-    (!) => { tt2ts!(Punct::new('!', Spacing::Alone)) };\n-    (<) => { tt2ts!(Punct::new('<', Spacing::Alone)) };\n-    (>) => { tt2ts!(Punct::new('>', Spacing::Alone)) };\n-    (_) => { tt2ts!(Punct::new('_', Spacing::Alone)) };\n-    (0) => { tt2ts!(Literal::i8_unsuffixed(0)) };\n-    (&) => { tt2ts!(Punct::new('&', Spacing::Alone)) };\n-    (=) => { tt2ts!(Punct::new('=', Spacing::Alone)) };\n-    ($i:ident) => { tt2ts!(Ident::new(stringify!($i), Span::def_site())) };\n-}\n-\n-macro_rules! quote_tree {\n-    ((unquote $($t:tt)*)) => { $($t)* };\n-    ((quote $($t:tt)*)) => { ($($t)*).quote() };\n-    (($($t:tt)*)) => { tt2ts!(Group::new(Delimiter::Parenthesis, quote!($($t)*))) };\n-    ([$($t:tt)*]) => { tt2ts!(Group::new(Delimiter::Bracket, quote!($($t)*))) };\n-    ({$($t:tt)*}) => { tt2ts!(Group::new(Delimiter::Brace, quote!($($t)*))) };\n-    ($t:tt) => { quote_tok!($t) };\n+    ($t:tt) => { TokenTree::from(quote_tt!($t)) };\n }\n \n+/// Simpler version of the real `quote!` macro, implemented solely\n+/// through `macro_rules`, for bootstrapping the real implementation\n+/// (see the `quote` function), which does not have access to the\n+/// real `quote!` macro due to the `proc_macro` crate not being\n+/// able to depend on itself.\n+///\n+/// Note: supported tokens are a subset of the real `quote!`, but\n+/// unquoting is different: instead of `$x`, this uses `(@ expr)`.\n macro_rules! quote {\n     () => { TokenStream::new() };\n     ($($t:tt)*) => {\n-        [$(quote_tree!($t),)*].iter()\n-            .cloned()\n-            .flat_map(|x| x.into_iter())\n-            .collect::<TokenStream>()\n+        [\n+            $(TokenStream::from(quote_ts!($t)),)*\n+        ].iter().cloned().collect::<TokenStream>()\n     };\n }\n \n-impl ProcMacro for Quoter {\n-    fn expand<'cx>(&self, cx: &'cx mut ExtCtxt,\n-                   _: ::syntax_pos::Span,\n-                   stream: tokenstream::TokenStream)\n-                   -> tokenstream::TokenStream {\n-        ::__internal::set_sess(cx, || TokenStream(stream).quote().0)\n+/// Quote a `TokenStream` into a `TokenStream`.\n+/// This is the actual `quote!()` proc macro.\n+///\n+/// It is manually loaded in `CStore::load_macro_untracked`.\n+#[unstable(feature = \"proc_macro_quote\", issue = \"38356\")]\n+pub fn quote(stream: TokenStream) -> TokenStream {\n+    if stream.is_empty() {\n+        return quote!(::TokenStream::new());\n     }\n-}\n-\n-impl Quote for TokenStream {\n-    fn quote(self) -> TokenStream {\n-        if self.is_empty() {\n-            return quote!(::TokenStream::new());\n-        }\n-        let mut after_dollar = false;\n-        let tokens = self.into_iter().filter_map(|tree| {\n+    let mut after_dollar = false;\n+    let tokens = stream\n+        .into_iter()\n+        .filter_map(|tree| {\n             if after_dollar {\n                 after_dollar = false;\n                 match tree {\n                     TokenTree::Ident(_) => {\n-                        let tree = TokenStream::from(tree);\n-                        return Some(quote!(::__internal::unquote(&(unquote tree)),));\n+                        return Some(quote!(Into::<::TokenStream>::into(\n+                        Clone::clone(&(@ tree))),));\n                     }\n                     TokenTree::Punct(ref tt) if tt.as_char() == '$' => {}\n                     _ => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n@@ -116,116 +96,55 @@ impl Quote for TokenStream {\n                 }\n             }\n \n-            Some(quote!(::TokenStream::from((quote tree)),))\n-        }).flat_map(|t| t.into_iter()).collect::<TokenStream>();\n-\n-        if after_dollar {\n-            panic!(\"unexpected trailing `$` in `quote!`\");\n-        }\n-\n-        quote!(\n-            [(unquote tokens)].iter()\n-                .cloned()\n-                .flat_map(|x| x.into_iter())\n-                .collect::<::TokenStream>()\n-        )\n-    }\n-}\n-\n-impl Quote for TokenTree {\n-    fn quote(self) -> TokenStream {\n-        match self {\n-            TokenTree::Punct(tt) => quote!(::TokenTree::Punct( (quote tt) )),\n-            TokenTree::Group(tt) => quote!(::TokenTree::Group( (quote tt) )),\n-            TokenTree::Ident(tt) => quote!(::TokenTree::Ident( (quote tt) )),\n-            TokenTree::Literal(tt) => quote!(::TokenTree::Literal( (quote tt) )),\n-        }\n-    }\n-}\n-\n-impl Quote for char {\n-    fn quote(self) -> TokenStream {\n-        TokenTree::from(Literal::character(self)).into()\n-    }\n-}\n-\n-impl<'a> Quote for &'a str {\n-    fn quote(self) -> TokenStream {\n-        TokenTree::from(Literal::string(self)).into()\n-    }\n-}\n-\n-impl Quote for u16 {\n-    fn quote(self) -> TokenStream {\n-        TokenTree::from(Literal::u16_unsuffixed(self)).into()\n-    }\n-}\n-\n-impl Quote for Group {\n-    fn quote(self) -> TokenStream {\n-        quote!(::Group::new((quote self.delimiter()), (quote self.stream())))\n-    }\n-}\n-\n-impl Quote for Punct {\n-    fn quote(self) -> TokenStream {\n-        quote!(::Punct::new((quote self.as_char()), (quote self.spacing())))\n-    }\n-}\n-\n-impl Quote for Ident {\n-    fn quote(self) -> TokenStream {\n-        quote!(::Ident::new((quote self.sym.as_str()), (quote self.span())))\n-    }\n-}\n+            Some(quote!(::TokenStream::from((@ match tree {\n+                TokenTree::Punct(tt) => quote!(::TokenTree::Punct(::Punct::new(\n+                    (@ TokenTree::from(Literal::character(tt.as_char()))),\n+                    (@ match tt.spacing() {\n+                        Spacing::Alone => quote!(::Spacing::Alone),\n+                        Spacing::Joint => quote!(::Spacing::Joint),\n+                    }),\n+                ))),\n+                TokenTree::Group(tt) => quote!(::TokenTree::Group(::Group::new(\n+                    (@ match tt.delimiter() {\n+                        Delimiter::Parenthesis => quote!(::Delimiter::Parenthesis),\n+                        Delimiter::Brace => quote!(::Delimiter::Brace),\n+                        Delimiter::Bracket => quote!(::Delimiter::Bracket),\n+                        Delimiter::None => quote!(::Delimiter::None),\n+                    }),\n+                    (@ quote(tt.stream())),\n+                ))),\n+                TokenTree::Ident(tt) => quote!(::TokenTree::Ident(::Ident::new(\n+                    (@ TokenTree::from(Literal::string(&tt.to_string()))),\n+                    (@ quote_span(tt.span())),\n+                ))),\n+                TokenTree::Literal(tt) => quote!(::TokenTree::Literal({\n+                    let mut iter = (@ TokenTree::from(Literal::string(&tt.to_string())))\n+                        .parse::<::TokenStream>()\n+                        .unwrap()\n+                        .into_iter();\n+                    if let (Some(::TokenTree::Literal(mut lit)), None) =\n+                        (iter.next(), iter.next())\n+                    {\n+                        lit.set_span((@ quote_span(tt.span())));\n+                        lit\n+                    } else {\n+                        unreachable!()\n+                    }\n+                }))\n+            })),))\n+        })\n+        .collect::<TokenStream>();\n \n-impl Quote for Span {\n-    fn quote(self) -> TokenStream {\n-        quote!(::Span::def_site())\n+    if after_dollar {\n+        panic!(\"unexpected trailing `$` in `quote!`\");\n     }\n-}\n-\n-impl Quote for Literal {\n-    fn quote(self) -> TokenStream {\n-        quote! {{\n-            let mut iter = (quote self.to_string())\n-                .parse::<::TokenStream>()\n-                .unwrap()\n-                .into_iter();\n-            if let (Some(::TokenTree::Literal(mut lit)), None) = (iter.next(), iter.next()) {\n-                lit.set_span((quote self.span));\n-                lit\n-            } else {\n-                unreachable!()\n-            }\n-        }}\n-    }\n-}\n-\n-impl Quote for Delimiter {\n-    fn quote(self) -> TokenStream {\n-        macro_rules! gen_match {\n-            ($($i:ident),*) => {\n-                match self {\n-                    $(Delimiter::$i => { quote!(::Delimiter::$i) })*\n-                }\n-            }\n-        }\n \n-        gen_match!(Parenthesis, Brace, Bracket, None)\n-    }\n+    quote!([(@ tokens)].iter().cloned().collect::<::TokenStream>())\n }\n \n-impl Quote for Spacing {\n-    fn quote(self) -> TokenStream {\n-        macro_rules! gen_match {\n-            ($($i:ident),*) => {\n-                match self {\n-                    $(Spacing::$i => { quote!(::Spacing::$i) })*\n-                }\n-            }\n-        }\n-\n-        gen_match!(Alone, Joint)\n-    }\n+/// Quote a `Span` into a `TokenStream`.\n+/// This is needed to implement a custom quoter.\n+#[unstable(feature = \"proc_macro_quote\", issue = \"38356\")]\n+pub fn quote_span(_: Span) -> TokenStream {\n+    quote!(::Span::def_site())\n }"}, {"sha": "e3a7918f8c5897df13ba8790fca77ce962daa3a9", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56aaa532781e8591c1c5b50aafa2e64634a2de80/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56aaa532781e8591c1c5b50aafa2e64634a2de80/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=56aaa532781e8591c1c5b50aafa2e64634a2de80", "patch": "@@ -39,7 +39,6 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap;\n use syntax::edition::Edition;\n-use syntax::ext::base::SyntaxExtension;\n use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n@@ -517,8 +516,11 @@ impl CrateStore for cstore::CStore {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n         } else if data.name == \"proc_macro\" &&\n                   self.get_crate_data(id.krate).item_name(id.index) == \"quote\" {\n+            use syntax::ext::base::SyntaxExtension;\n+            use syntax_ext::proc_macro_impl::BangProcMacro;\n+\n             let ext = SyntaxExtension::ProcMacro {\n-                expander: Box::new(::proc_macro::__internal::Quoter),\n+                expander: Box::new(BangProcMacro { inner: ::proc_macro::quote }),\n                 allow_internal_unstable: true,\n                 edition: data.root.edition,\n             };"}, {"sha": "d535c1ef90357d0c83da785a571ec9dbb3bee160", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56aaa532781e8591c1c5b50aafa2e64634a2de80/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56aaa532781e8591c1c5b50aafa2e64634a2de80/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=56aaa532781e8591c1c5b50aafa2e64634a2de80", "patch": "@@ -19,6 +19,7 @@\n #![feature(libc)]\n #![feature(macro_at_most_once_rep)]\n #![feature(proc_macro_internals)]\n+#![feature(proc_macro_quote)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]"}]}