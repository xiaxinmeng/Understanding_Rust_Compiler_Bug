{"sha": "696b703b5a58816bb0e549ac332a98fa7e635949", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NmI3MDNiNWE1ODgxNmJiMGU1NDlhYzMzMmE5OGZhN2U2MzU5NDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-03T21:33:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-03T21:33:55Z"}, "message": "Auto merge of #34530 - alexcrichton:stabilize-1.11, r=aturon\n\nstd: Stabilize APIs for the 1.11.0 release\n\nAlthough the set of APIs being stabilized this release is relatively small, the\ntrains keep going! Listed below are the APIs in the standard library which have\neither transitioned from unstable to stable or those from unstable to\ndeprecated.\n\nStable\n\n* `BTreeMap::{append, split_off}`\n* `BTreeSet::{append, split_off}`\n* `Cell::get_mut`\n* `RefCell::get_mut`\n* `BinaryHeap::append`\n* `{f32, f64}::{to_degrees, to_radians}` - libcore stabilizations mirroring past\n  libstd stabilizations\n* `Iterator::sum`\n* `Iterator::product`\n\nDeprecated\n\n* `{f32, f64}::next_after`\n* `{f32, f64}::integer_decode`\n* `{f32, f64}::ldexp`\n* `{f32, f64}::frexp`\n* `num::One`\n* `num::Zero`\n\nAdded APIs (all unstable)\n\n* `iter::Sum`\n* `iter::Product`\n* `iter::Step` - a few methods were added to accomodate deprecation of One/Zero\n\nRemoved APIs\n\n* `From<Range<T>> for RangeInclusive<T>` - everything about `RangeInclusive` is\n  unstable\n\nCloses #27739\nCloses #27752\nCloses #32526\nCloses #33444\nCloses #34152\ncc #34529 (new tracking issue)", "tree": {"sha": "48518dc8a017b2d66d68fa742972779c28641ade", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48518dc8a017b2d66d68fa742972779c28641ade"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/696b703b5a58816bb0e549ac332a98fa7e635949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/696b703b5a58816bb0e549ac332a98fa7e635949", "html_url": "https://github.com/rust-lang/rust/commit/696b703b5a58816bb0e549ac332a98fa7e635949", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/696b703b5a58816bb0e549ac332a98fa7e635949/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eebfcb8bf48351f13b19c2faf0b9aa2f152234e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/eebfcb8bf48351f13b19c2faf0b9aa2f152234e4", "html_url": "https://github.com/rust-lang/rust/commit/eebfcb8bf48351f13b19c2faf0b9aa2f152234e4"}, {"sha": "3016626c3aa4bc44807e54a8ba8b9e367ff566f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3016626c3aa4bc44807e54a8ba8b9e367ff566f5", "html_url": "https://github.com/rust-lang/rust/commit/3016626c3aa4bc44807e54a8ba8b9e367ff566f5"}], "stats": {"total": 701, "additions": 507, "deletions": 194}, "files": [{"sha": "b9f5c6fcab9092a3d4565c5980a82f65888ff664", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -825,8 +825,6 @@ impl<T: Ord> BinaryHeap<T> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(binary_heap_append)]\n-    ///\n     /// use std::collections::BinaryHeap;\n     ///\n     /// let v = vec![-10, 1, 2, 3, 3];\n@@ -840,9 +838,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n     /// assert!(b.is_empty());\n     /// ```\n-    #[unstable(feature = \"binary_heap_append\",\n-           reason = \"needs to be audited\",\n-           issue = \"32526\")]\n+    #[stable(feature = \"binary_heap_append\", since = \"1.11.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n         if self.len() < other.len() {\n             swap(self, other);"}, {"sha": "aea7a1c13a28171778b427920c78c8cd89d3a1d0", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -559,7 +559,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(btree_append)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n@@ -583,8 +582,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(a[&4], \"e\");\n     /// assert_eq!(a[&5], \"f\");\n     /// ```\n-    #[unstable(feature = \"btree_append\", reason = \"recently added as part of collections reform 2\",\n-               issue = \"34152\")]\n+    #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n         // Do we have to append anything at all?\n         if other.len() == 0 {\n@@ -914,7 +912,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(btree_split_off)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n@@ -936,9 +933,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(b[&17], \"d\");\n     /// assert_eq!(b[&41], \"e\");\n     /// ```\n-    #[unstable(feature = \"btree_split_off\",\n-               reason = \"recently added as part of collections reform 2\",\n-               issue = \"34152\")]\n+    #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n         where K: Borrow<Q>\n     {"}, {"sha": "0f885bc2950a6b3426778e7508445b286c76e47e", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -551,7 +551,6 @@ impl<T: Ord> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(btree_append)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n@@ -575,8 +574,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(a.contains(&4));\n     /// assert!(a.contains(&5));\n     /// ```\n-    #[unstable(feature = \"btree_append\", reason = \"recently added as part of collections reform 2\",\n-               issue = \"34152\")]\n+    #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n         self.map.append(&mut other.map);\n     }\n@@ -589,7 +587,6 @@ impl<T: Ord> BTreeSet<T> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(btree_split_off)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n@@ -611,9 +608,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(b[&17], \"d\");\n     /// assert_eq!(b[&41], \"e\");\n     /// ```\n-    #[unstable(feature = \"btree_split_off\",\n-               reason = \"recently added as part of collections reform 2\",\n-               issue = \"34152\")]\n+    #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self where T: Borrow<Q> {\n         BTreeSet { map: self.map.split_off(key) }\n     }"}, {"sha": "f027d074cb6f0bc8175db50364576b4311b35122", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -38,7 +38,6 @@\n #![feature(fmt_internals)]\n #![feature(heap_api)]\n #![feature(inclusive_range)]\n-#![feature(iter_arith)]\n #![feature(lang_items)]\n #![feature(nonzero)]\n #![feature(pattern)]"}, {"sha": "8ae63808f27404b9abdc4406b6eab7ef40b251f6", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -11,18 +11,14 @@\n #![deny(warnings)]\n \n #![feature(binary_heap_extras)]\n-#![feature(binary_heap_append)]\n #![feature(binary_heap_peek_mut)]\n #![feature(box_syntax)]\n-#![feature(btree_append)]\n-#![feature(btree_split_off)]\n #![feature(btree_range)]\n #![feature(collections)]\n #![feature(collections_bound)]\n #![feature(const_fn)]\n #![feature(fn_traits)]\n #![feature(enumset)]\n-#![feature(iter_arith)]\n #![feature(linked_list_contains)]\n #![feature(pattern)]\n #![feature(rand)]"}, {"sha": "9435be3b0124b60bfb1fd36be9842558548ba449", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -238,7 +238,7 @@ impl<T:Copy> Cell<T> {\n     /// This call borrows `Cell` mutably (at compile-time) which guarantees\n     /// that we possess the only reference.\n     #[inline]\n-    #[unstable(feature = \"cell_get_mut\", issue = \"33444\")]\n+    #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n         unsafe {\n             &mut *self.value.get()\n@@ -509,7 +509,7 @@ impl<T: ?Sized> RefCell<T> {\n     /// This call borrows `RefCell` mutably (at compile-time) so there is no\n     /// need for dynamic checks.\n     #[inline]\n-    #[unstable(feature = \"cell_get_mut\", issue=\"33444\")]\n+    #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n         unsafe {\n             &mut *self.value.get()"}, {"sha": "6b01ccaceea2f31c3726597244a23ccefdda2fc1", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -11,18 +11,16 @@\n use clone::Clone;\n use cmp::{Ord, PartialOrd, PartialEq, Ordering};\n use default::Default;\n-use num::{Zero, One};\n-use ops::{Add, FnMut, Mul};\n+use ops::FnMut;\n use option::Option::{self, Some, None};\n use marker::Sized;\n \n-use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse,\n-            Inspect, Map, Peekable, Scan, Skip, SkipWhile, Take, TakeWhile, Rev,\n-            Zip};\n+use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse};\n+use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, Take, TakeWhile, Rev};\n+use super::{Zip, Sum, Product};\n use super::ChainState;\n-use super::{DoubleEndedIterator, ExactSizeIterator, Extend, FromIterator,\n-            IntoIterator};\n-use super::ZipImpl;\n+use super::{DoubleEndedIterator, ExactSizeIterator, Extend, FromIterator};\n+use super::{IntoIterator, ZipImpl};\n \n fn _assert_is_object_safe(_: &Iterator<Item=()>) {}\n \n@@ -1820,50 +1818,54 @@ pub trait Iterator {\n     ///\n     /// An empty iterator returns the zero value of the type.\n     ///\n+    /// # Panics\n+    ///\n+    /// When calling `sum` and a primitive integer type is being returned, this\n+    /// method will panic if the computation overflows.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(iter_arith)]\n-    ///\n     /// let a = [1, 2, 3];\n     /// let sum: i32 = a.iter().sum();\n     ///\n     /// assert_eq!(sum, 6);\n     /// ```\n-    #[unstable(feature = \"iter_arith\", reason = \"bounds recently changed\",\n-               issue = \"27739\")]\n-    fn sum<S>(self) -> S where\n-        S: Add<Self::Item, Output=S> + Zero,\n-        Self: Sized,\n+    #[stable(feature = \"iter_arith\", since = \"1.11.0\")]\n+    fn sum<S>(self) -> S\n+        where Self: Sized,\n+              S: Sum<Self::Item>,\n     {\n-        self.fold(Zero::zero(), |s, e| s + e)\n+        Sum::sum(self)\n     }\n \n     /// Iterates over the entire iterator, multiplying all the elements\n     ///\n     /// An empty iterator returns the one value of the type.\n     ///\n+    /// # Panics\n+    ///\n+    /// When calling `product` and a primitive integer type is being returned,\n+    /// this method will panic if the computation overflows.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(iter_arith)]\n-    ///\n     /// fn factorial(n: u32) -> u32 {\n     ///     (1..).take_while(|&i| i <= n).product()\n     /// }\n     /// assert_eq!(factorial(0), 1);\n     /// assert_eq!(factorial(1), 1);\n     /// assert_eq!(factorial(5), 120);\n     /// ```\n-    #[unstable(feature=\"iter_arith\", reason = \"bounds recently changed\",\n-               issue = \"27739\")]\n-    fn product<P>(self) -> P where\n-        P: Mul<Self::Item, Output=P> + One,\n-        Self: Sized,\n+    #[stable(feature = \"iter_arith\", since = \"1.11.0\")]\n+    fn product<P>(self) -> P\n+        where Self: Sized,\n+              P: Product<Self::Item>,\n     {\n-        self.fold(One::one(), |p, e| p * e)\n+        Product::product(self)\n     }\n \n     /// Lexicographically compares the elements of this `Iterator` with those"}, {"sha": "3ebab266e2ffed5494cc069a90172e64833f9b83", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -327,8 +327,9 @@ pub use self::sources::{Empty, empty};\n pub use self::sources::{Once, once};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend,\n-                       ExactSizeIterator};\n+pub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::traits::{ExactSizeIterator, Sum, Product};\n \n mod iterator;\n mod range;"}, {"sha": "c234ef21db6d12878e09e722ed507d058948a42a", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 137, "deletions": 32, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -11,7 +11,6 @@\n use clone::Clone;\n use cmp::PartialOrd;\n use mem;\n-use num::{Zero, One};\n use ops::{self, Add, Sub};\n use option::Option::{self, Some, None};\n use marker::Sized;\n@@ -36,6 +35,24 @@ pub trait Step: PartialOrd + Sized {\n     /// Returns `None` if it is not possible to calculate `steps_between`\n     /// without overflow.\n     fn steps_between(start: &Self, end: &Self, by: &Self) -> Option<usize>;\n+\n+    /// Same as `steps_between`, but with a `by` of 1\n+    fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize>;\n+\n+    /// Tests whether this step is negative or not (going backwards)\n+    fn is_negative(&self) -> bool;\n+\n+    /// Replaces this step with `1`, returning itself\n+    fn replace_one(&mut self) -> Self;\n+\n+    /// Replaces this step with `0`, returning itself\n+    fn replace_zero(&mut self) -> Self;\n+\n+    /// Adds one to this step, returning the result\n+    fn add_one(&self) -> Self;\n+\n+    /// Subtracts one to this step, returning the result\n+    fn sub_one(&self) -> Self;\n }\n \n macro_rules! step_impl_unsigned {\n@@ -65,6 +82,36 @@ macro_rules! step_impl_unsigned {\n                     Some(0)\n                 }\n             }\n+\n+            #[inline]\n+            fn is_negative(&self) -> bool {\n+                false\n+            }\n+\n+            #[inline]\n+            fn replace_one(&mut self) -> Self {\n+                mem::replace(self, 0)\n+            }\n+\n+            #[inline]\n+            fn replace_zero(&mut self) -> Self {\n+                mem::replace(self, 1)\n+            }\n+\n+            #[inline]\n+            fn add_one(&self) -> Self {\n+                *self + 1\n+            }\n+\n+            #[inline]\n+            fn sub_one(&self) -> Self {\n+                *self - 1\n+            }\n+\n+            #[inline]\n+            fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize> {\n+                Self::steps_between(start, end, &1)\n+            }\n         }\n     )*)\n }\n@@ -106,6 +153,36 @@ macro_rules! step_impl_signed {\n                     Some(diff / by_u)\n                 }\n             }\n+\n+            #[inline]\n+            fn is_negative(&self) -> bool {\n+                *self < 0\n+            }\n+\n+            #[inline]\n+            fn replace_one(&mut self) -> Self {\n+                mem::replace(self, 0)\n+            }\n+\n+            #[inline]\n+            fn replace_zero(&mut self) -> Self {\n+                mem::replace(self, 1)\n+            }\n+\n+            #[inline]\n+            fn add_one(&self) -> Self {\n+                *self + 1\n+            }\n+\n+            #[inline]\n+            fn sub_one(&self) -> Self {\n+                *self - 1\n+            }\n+\n+            #[inline]\n+            fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize> {\n+                Self::steps_between(start, end, &1)\n+            }\n         }\n     )*)\n }\n@@ -124,6 +201,37 @@ macro_rules! step_impl_no_between {\n             fn steps_between(_a: &$t, _b: &$t, _by: &$t) -> Option<usize> {\n                 None\n             }\n+\n+            #[inline]\n+            #[allow(unused_comparisons)]\n+            fn is_negative(&self) -> bool {\n+                *self < 0\n+            }\n+\n+            #[inline]\n+            fn replace_one(&mut self) -> Self {\n+                mem::replace(self, 0)\n+            }\n+\n+            #[inline]\n+            fn replace_zero(&mut self) -> Self {\n+                mem::replace(self, 1)\n+            }\n+\n+            #[inline]\n+            fn add_one(&self) -> Self {\n+                *self + 1\n+            }\n+\n+            #[inline]\n+            fn sub_one(&self) -> Self {\n+                *self - 1\n+            }\n+\n+            #[inline]\n+            fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize> {\n+                Self::steps_between(start, end, &1)\n+            }\n         }\n     )*)\n }\n@@ -269,12 +377,12 @@ impl<A> Iterator for StepBy<A, ops::RangeFrom<A>> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n+impl<A: Step + Clone> Iterator for StepBy<A, ops::Range<A>> {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let rev = self.step_by < A::zero();\n+        let rev = self.step_by.is_negative();\n         if (rev && self.range.start > self.range.end) ||\n            (!rev && self.range.start < self.range.end)\n         {\n@@ -308,7 +416,7 @@ impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n #[unstable(feature = \"inclusive_range\",\n            reason = \"recently added, follows RFC\",\n            issue = \"28237\")]\n-impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n+impl<A: Step + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n     type Item = A;\n \n     #[inline]\n@@ -322,8 +430,7 @@ impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n             Empty { .. } => return None, // empty iterators yield no values\n \n             NonEmpty { ref mut start, ref mut end } => {\n-                let zero = A::zero();\n-                let rev = self.step_by < zero;\n+                let rev = self.step_by.is_negative();\n \n                 // march start towards (maybe past!) end and yield the old value\n                 if (rev && start >= end) ||\n@@ -342,7 +449,7 @@ impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n                     }\n                 } else {\n                     // found range in inconsistent state (start at or past end), so become empty\n-                    (Some(mem::replace(end, zero)), None)\n+                    (Some(end.replace_zero()), None)\n                 }\n             }\n         };\n@@ -386,15 +493,15 @@ macro_rules! range_exact_iter_impl {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step + One> Iterator for ops::Range<A> where\n+impl<A: Step> Iterator for ops::Range<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>\n {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            let mut n = &self.start + &A::one();\n+            let mut n = self.start.add_one();\n             mem::swap(&mut n, &mut self.start);\n             Some(n)\n         } else {\n@@ -404,7 +511,7 @@ impl<A: Step + One> Iterator for ops::Range<A> where\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        match Step::steps_between(&self.start, &self.end, &A::one()) {\n+        match Step::steps_between_by_one(&self.start, &self.end) {\n             Some(hint) => (hint, Some(hint)),\n             None => (0, None)\n         }\n@@ -416,14 +523,14 @@ impl<A: Step + One> Iterator for ops::Range<A> where\n range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step + One + Clone> DoubleEndedIterator for ops::Range<A> where\n+impl<A: Step + Clone> DoubleEndedIterator for ops::Range<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>,\n     for<'a> &'a A: Sub<&'a A, Output = A>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            self.end = &self.end - &A::one();\n+            self.end = self.end.sub_one();\n             Some(self.end.clone())\n         } else {\n             None\n@@ -432,21 +539,21 @@ impl<A: Step + One + Clone> DoubleEndedIterator for ops::Range<A> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step + One> Iterator for ops::RangeFrom<A> where\n+impl<A: Step> Iterator for ops::RangeFrom<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>\n {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let mut n = &self.start + &A::one();\n+        let mut n = self.start.add_one();\n         mem::swap(&mut n, &mut self.start);\n         Some(n)\n     }\n }\n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<A: Step + One> Iterator for ops::RangeInclusive<A> where\n+impl<A: Step> Iterator for ops::RangeInclusive<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>\n {\n     type Item = A;\n@@ -463,23 +570,22 @@ impl<A: Step + One> Iterator for ops::RangeInclusive<A> where\n \n             NonEmpty { ref mut start, ref mut end } => {\n                 if start == end {\n-                    (Some(mem::replace(end, A::one())), Some(mem::replace(start, A::one())))\n+                    (Some(end.replace_one()), Some(start.replace_one()))\n                 } else if start < end {\n-                    let one = A::one();\n-                    let mut n = &*start + &one;\n+                    let mut n = start.add_one();\n                     mem::swap(&mut n, start);\n \n-                    // if the iterator is done iterating, it will change from NonEmpty to Empty\n-                    // to avoid unnecessary drops or clones, we'll reuse either start or end\n-                    // (they are equal now, so it doesn't matter which)\n-                    // to pull out end, we need to swap something back in -- use the previously\n-                    // created A::one() as a dummy value\n+                    // if the iterator is done iterating, it will change from\n+                    // NonEmpty to Empty to avoid unnecessary drops or clones,\n+                    // we'll reuse either start or end (they are equal now, so\n+                    // it doesn't matter which) to pull out end, we need to swap\n+                    // something back in\n \n-                    (if n == *end { Some(mem::replace(end, one)) } else { None },\n+                    (if n == *end { Some(end.replace_one()) } else { None },\n                     // ^ are we done yet?\n                     Some(n)) // < the value to output\n                 } else {\n-                    (Some(mem::replace(start, A::one())), None)\n+                    (Some(start.replace_one()), None)\n                 }\n             }\n         };\n@@ -500,7 +606,7 @@ impl<A: Step + One> Iterator for ops::RangeInclusive<A> where\n             Empty { .. } => (0, Some(0)),\n \n             NonEmpty { ref start, ref end } =>\n-                match Step::steps_between(start, end, &A::one()) {\n+                match Step::steps_between_by_one(start, end) {\n                     Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n                     None => (0, None),\n                 }\n@@ -509,7 +615,7 @@ impl<A: Step + One> Iterator for ops::RangeInclusive<A> where\n }\n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<A: Step + One> DoubleEndedIterator for ops::RangeInclusive<A> where\n+impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>,\n     for<'a> &'a A: Sub<&'a A, Output = A>\n {\n@@ -524,16 +630,15 @@ impl<A: Step + One> DoubleEndedIterator for ops::RangeInclusive<A> where\n \n             NonEmpty { ref mut start, ref mut end } => {\n                 if start == end {\n-                    (Some(mem::replace(start, A::one())), Some(mem::replace(end, A::one())))\n+                    (Some(start.replace_one()), Some(end.replace_one()))\n                 } else if start < end {\n-                    let one = A::one();\n-                    let mut n = &*end - &one;\n+                    let mut n = end.sub_one();\n                     mem::swap(&mut n, end);\n \n-                    (if n == *start { Some(mem::replace(start, one)) } else { None },\n+                    (if n == *start { Some(start.replace_one()) } else { None },\n                      Some(n))\n                 } else {\n-                    (Some(mem::replace(end, A::one())), None)\n+                    (Some(end.replace_one()), None)\n                 }\n             }\n         };"}, {"sha": "3549bd6a3bc68f4fcfa52cab27ed36a9817b5378", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -524,3 +524,104 @@ pub trait ExactSizeIterator: Iterator {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I: ExactSizeIterator + ?Sized> ExactSizeIterator for &'a mut I {}\n \n+/// Trait to represent types that can be created by summing up an iterator.\n+///\n+/// This trait is used to implement the `sum` method on iterators. Types which\n+/// implement the trait can be generated by the `sum` method. Like\n+/// `FromIterator` this trait should rarely be called directly and instead\n+/// interacted with through `Iterator::sum`.\n+#[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+pub trait Sum<A = Self>: Sized {\n+    /// Method which takes an iterator and generates `Self` from the elements by\n+    /// \"summing up\" the items.\n+    fn sum<I: Iterator<Item=A>>(iter: I) -> Self;\n+}\n+\n+/// Trait to represent types that can be created by multiplying elements of an\n+/// iterator.\n+///\n+/// This trait is used to implement the `product` method on iterators. Types\n+/// which implement the trait can be generated by the `product` method. Like\n+/// `FromIterator` this trait should rarely be called directly and instead\n+/// interacted with through `Iterator::product`.\n+#[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+pub trait Product<A = Self>: Sized {\n+    /// Method which takes an iterator and generates `Self` from the elements by\n+    /// multiplying the items.\n+    fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n+}\n+\n+macro_rules! integer_sum_product {\n+    ($($a:ident)*) => ($(\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl Sum for $a {\n+            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold(0, |a, b| {\n+                    a.checked_add(b).expect(\"overflow in sum\")\n+                })\n+            }\n+        }\n+\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl Product for $a {\n+            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold(1, |a, b| {\n+                    a.checked_mul(b).expect(\"overflow in product\")\n+                })\n+            }\n+        }\n+\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl<'a> Sum<&'a $a> for $a {\n+            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold(0, |a, b| {\n+                    a.checked_add(*b).expect(\"overflow in sum\")\n+                })\n+            }\n+        }\n+\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl<'a> Product<&'a $a> for $a {\n+            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold(1, |a, b| {\n+                    a.checked_mul(*b).expect(\"overflow in product\")\n+                })\n+            }\n+        }\n+    )*)\n+}\n+\n+macro_rules! float_sum_product {\n+    ($($a:ident)*) => ($(\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl Sum for $a {\n+            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold(0.0, |a, b| a + b)\n+            }\n+        }\n+\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl Product for $a {\n+            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold(1.0, |a, b| a * b)\n+            }\n+        }\n+\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl<'a> Sum<&'a $a> for $a {\n+            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold(0.0, |a, b| a + *b)\n+            }\n+        }\n+\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl<'a> Product<&'a $a> for $a {\n+            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold(1.0, |a, b| a * *b)\n+            }\n+        }\n+    )*)\n+}\n+\n+integer_sum_product! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+float_sum_product! { f32 f64 }"}, {"sha": "e849369d647c4754967d63f3d7cd627ae0fc8929", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -59,6 +59,8 @@\n #![deny(missing_debug_implementations)]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+#![cfg_attr(stage0, allow(unused_attributes))]\n+\n #![feature(allow_internal_unstable)]\n #![feature(asm)]\n #![feature(associated_type_defaults)]"}, {"sha": "4761727cec03ff93594b2fb4d706c960ba99479a", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -321,7 +321,7 @@ pub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n             return underflow(x, v, rem);\n         }\n         if k > T::max_exp_int() {\n-            return T::infinity();\n+            return T::infinity2();\n         }\n         if x < min_sig {\n             u.mul_pow2(1);"}, {"sha": "ff2d85307b1060ef6cb2c5a2bcc619a80fe2b7f5", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -215,11 +215,11 @@ fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n     let (sign, s) = extract_sign(s);\n     let flt = match parse_decimal(s) {\n         ParseResult::Valid(decimal) => convert(decimal)?,\n-        ParseResult::ShortcutToInf => T::infinity(),\n-        ParseResult::ShortcutToZero => T::zero(),\n+        ParseResult::ShortcutToInf => T::infinity2(),\n+        ParseResult::ShortcutToZero => T::zero2(),\n         ParseResult::Invalid => match s {\n-            \"inf\" => T::infinity(),\n-            \"NaN\" => T::nan(),\n+            \"inf\" => T::infinity2(),\n+            \"NaN\" => T::nan2(),\n             _ => { return Err(pfe_invalid()); }\n         }\n     };\n@@ -316,17 +316,17 @@ fn bound_intermediate_digits(decimal: &Decimal, e: i64) -> u64 {\n fn trivial_cases<T: RawFloat>(decimal: &Decimal) -> Option<T> {\n     // There were zeros but they were stripped by simplify()\n     if decimal.integral.is_empty() && decimal.fractional.is_empty() {\n-        return Some(T::zero());\n+        return Some(T::zero2());\n     }\n     // This is a crude approximation of ceil(log10(the real value)). We don't need to worry too\n     // much about overflow here because the input length is tiny (at least compared to 2^64) and\n     // the parser already handles exponents whose absolute value is greater than 10^18\n     // (which is still 10^19 short of 2^64).\n     let max_place = decimal.exp + decimal.integral.len() as i64;\n     if max_place > T::inf_cutoff() {\n-        return Some(T::infinity());\n+        return Some(T::infinity2());\n     } else if max_place < T::zero_cutoff() {\n-        return Some(T::zero());\n+        return Some(T::zero2());\n     }\n     None\n }"}, {"sha": "68e4dc4b359efa73fb3ee5373004d569f756fcd9", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -61,6 +61,27 @@ impl Unpacked {\n pub trait RawFloat : Float + Copy + Debug + LowerExp\n                     + Mul<Output=Self> + Div<Output=Self> + Neg<Output=Self>\n {\n+    // suffix of \"2\" because Float::infinity is deprecated\n+    #[allow(deprecated)]\n+    fn infinity2() -> Self {\n+        Float::infinity()\n+    }\n+\n+    // suffix of \"2\" because Float::nan is deprecated\n+    #[allow(deprecated)]\n+    fn nan2() -> Self {\n+        Float::nan()\n+    }\n+\n+    // suffix of \"2\" because Float::zero is deprecated\n+    fn zero2() -> Self;\n+\n+    // suffix of \"2\" because Float::integer_decode is deprecated\n+    #[allow(deprecated)]\n+    fn integer_decode2(self) -> (u64, i16, i8) {\n+        Float::integer_decode(self)\n+    }\n+\n     /// Get the raw binary representation of the float.\n     fn transmute(self) -> u64;\n \n@@ -146,6 +167,10 @@ pub trait RawFloat : Float + Copy + Debug + LowerExp\n }\n \n impl RawFloat for f32 {\n+    fn zero2() -> Self {\n+        0.0\n+    }\n+\n     fn sig_bits() -> u8 {\n         24\n     }\n@@ -169,7 +194,7 @@ impl RawFloat for f32 {\n     }\n \n     fn unpack(self) -> Unpacked {\n-        let (sig, exp, _sig) = self.integer_decode();\n+        let (sig, exp, _sig) = self.integer_decode2();\n         Unpacked::new(sig, exp)\n     }\n \n@@ -198,6 +223,10 @@ impl RawFloat for f32 {\n \n \n impl RawFloat for f64 {\n+    fn zero2() -> Self {\n+        0.0\n+    }\n+\n     fn sig_bits() -> u8 {\n         53\n     }\n@@ -220,7 +249,7 @@ impl RawFloat for f64 {\n     }\n \n     fn unpack(self) -> Unpacked {\n-        let (sig, exp, _sig) = self.integer_decode();\n+        let (sig, exp, _sig) = self.integer_decode2();\n         Unpacked::new(sig, exp)\n     }\n \n@@ -351,7 +380,7 @@ pub fn prev_float<T: RawFloat>(x: T) -> T {\n pub fn next_float<T: RawFloat>(x: T) -> T {\n     match x.classify() {\n         Nan => panic!(\"next_float: argument is NaN\"),\n-        Infinite => T::infinity(),\n+        Infinite => T::infinity2(),\n         // This seems too good to be true, but it works.\n         // 0.0 is encoded as the all-zero word. Subnormals are 0x000m...m where m is the mantissa.\n         // In particular, the smallest subnormal is 0x0...01 and the largest is 0x000F...F."}, {"sha": "79e1462eaa135eb58013a157fb584f6823b5485f", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -168,7 +168,7 @@ impl Float for f32 {\n     /// Returns `true` if the number is infinite.\n     #[inline]\n     fn is_infinite(self) -> bool {\n-        self == Float::infinity() || self == Float::neg_infinity()\n+        self == INFINITY || self == NEG_INFINITY\n     }\n \n     /// Returns `true` if the number is neither infinite or NaN.\n@@ -230,7 +230,7 @@ impl Float for f32 {\n     #[inline]\n     fn signum(self) -> f32 {\n         if self.is_nan() {\n-            Float::nan()\n+            NAN\n         } else {\n             unsafe { intrinsics::copysignf32(1.0, self) }\n         }\n@@ -240,14 +240,14 @@ impl Float for f32 {\n     /// `Float::infinity()`.\n     #[inline]\n     fn is_sign_positive(self) -> bool {\n-        self > 0.0 || (1.0 / self) == Float::infinity()\n+        self > 0.0 || (1.0 / self) == INFINITY\n     }\n \n     /// Returns `true` if `self` is negative, including `-0.0` and\n     /// `Float::neg_infinity()`.\n     #[inline]\n     fn is_sign_negative(self) -> bool {\n-        self < 0.0 || (1.0 / self) == Float::neg_infinity()\n+        self < 0.0 || (1.0 / self) == NEG_INFINITY\n     }\n \n     /// Returns the reciprocal (multiplicative inverse) of the number."}, {"sha": "35557f61c45420b5ff291aa369876a63e94be7aa", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -168,7 +168,7 @@ impl Float for f64 {\n     /// Returns `true` if the number is infinite.\n     #[inline]\n     fn is_infinite(self) -> bool {\n-        self == Float::infinity() || self == Float::neg_infinity()\n+        self == INFINITY || self == NEG_INFINITY\n     }\n \n     /// Returns `true` if the number is neither infinite or NaN.\n@@ -230,7 +230,7 @@ impl Float for f64 {\n     #[inline]\n     fn signum(self) -> f64 {\n         if self.is_nan() {\n-            Float::nan()\n+            NAN\n         } else {\n             unsafe { intrinsics::copysignf64(1.0, self) }\n         }\n@@ -240,14 +240,14 @@ impl Float for f64 {\n     /// `Float::infinity()`.\n     #[inline]\n     fn is_sign_positive(self) -> bool {\n-        self > 0.0 || (1.0 / self) == Float::infinity()\n+        self > 0.0 || (1.0 / self) == INFINITY\n     }\n \n     /// Returns `true` if `self` is negative, including `-0.0` and\n     /// `Float::neg_infinity()`.\n     #[inline]\n     fn is_sign_negative(self) -> bool {\n-        self < 0.0 || (1.0 / self) == Float::neg_infinity()\n+        self < 0.0 || (1.0 / self) == NEG_INFINITY\n     }\n \n     /// Returns the reciprocal (multiplicative inverse) of the number."}, {"sha": "5420e7bdd2a5a064092b398387c89ec884c97c6b", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -13,7 +13,8 @@\n use prelude::v1::*;\n \n use {f32, f64};\n-use num::{Float, FpCategory};\n+use num::FpCategory;\n+use num::dec2flt::rawfp::RawFloat;\n \n /// Decoded unsigned finite value, such that:\n ///\n@@ -52,7 +53,7 @@ pub enum FullDecoded {\n }\n \n /// A floating point type which can be `decode`d.\n-pub trait DecodableFloat: Float + Copy {\n+pub trait DecodableFloat: RawFloat + Copy {\n     /// The minimum positive normalized value.\n     fn min_pos_norm_value() -> Self;\n }\n@@ -68,7 +69,7 @@ impl DecodableFloat for f64 {\n /// Returns a sign (true when negative) and `FullDecoded` value\n /// from given floating point number.\n pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n-    let (mant, exp, sign) = v.integer_decode();\n+    let (mant, exp, sign) = v.integer_decode2();\n     let even = (mant & 1) == 0;\n     let decoded = match v.classify() {\n         FpCategory::Nan => FullDecoded::Nan,\n@@ -82,7 +83,7 @@ pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n                                           exp: exp, inclusive: even })\n         }\n         FpCategory::Normal => {\n-            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();\n+            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode2();\n             if mant == minnorm.0 {\n                 // neighbors: (maxmant, exp - 1) -- (minnormmant, exp) -- (minnormmant + 1, exp)\n                 // where maxmant = minnormmant * 2 - 1"}, {"sha": "0d79398a8f1d51bd26e975a0a45fe16fe5b58aab", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -109,6 +109,8 @@ pub mod diy_float;\n #[unstable(feature = \"zero_one\",\n            reason = \"unsure of placement, wants to use associated constants\",\n            issue = \"27739\")]\n+#[rustc_deprecated(since = \"1.11.0\", reason = \"no longer used for \\\n+                                               Iterator::sum\")]\n pub trait Zero: Sized {\n     /// The \"zero\" (usually, additive identity) for this type.\n     fn zero() -> Self;\n@@ -121,6 +123,8 @@ pub trait Zero: Sized {\n #[unstable(feature = \"zero_one\",\n            reason = \"unsure of placement, wants to use associated constants\",\n            issue = \"27739\")]\n+#[rustc_deprecated(since = \"1.11.0\", reason = \"no longer used for \\\n+                                               Iterator::product\")]\n pub trait One: Sized {\n     /// The \"one\" (usually, multiplicative identity) for this type.\n     fn one() -> Self;\n@@ -131,13 +135,15 @@ macro_rules! zero_one_impl {\n         #[unstable(feature = \"zero_one\",\n                    reason = \"unsure of placement, wants to use associated constants\",\n                    issue = \"27739\")]\n+        #[allow(deprecated)]\n         impl Zero for $t {\n             #[inline]\n             fn zero() -> Self { 0 }\n         }\n         #[unstable(feature = \"zero_one\",\n                    reason = \"unsure of placement, wants to use associated constants\",\n                    issue = \"27739\")]\n+        #[allow(deprecated)]\n         impl One for $t {\n             #[inline]\n             fn one() -> Self { 1 }\n@@ -151,13 +157,15 @@ macro_rules! zero_one_impl_float {\n         #[unstable(feature = \"zero_one\",\n                    reason = \"unsure of placement, wants to use associated constants\",\n                    issue = \"27739\")]\n+        #[allow(deprecated)]\n         impl Zero for $t {\n             #[inline]\n             fn zero() -> Self { 0.0 }\n         }\n         #[unstable(feature = \"zero_one\",\n                    reason = \"unsure of placement, wants to use associated constants\",\n                    issue = \"27739\")]\n+        #[allow(deprecated)]\n         impl One for $t {\n             #[inline]\n             fn one() -> Self { 1.0 }\n@@ -604,7 +612,7 @@ macro_rules! int_impl {\n         pub fn saturating_add(self, other: Self) -> Self {\n             match self.checked_add(other) {\n                 Some(x) => x,\n-                None if other >= Self::zero() => Self::max_value(),\n+                None if other >= 0 => Self::max_value(),\n                 None => Self::min_value(),\n             }\n         }\n@@ -625,7 +633,7 @@ macro_rules! int_impl {\n         pub fn saturating_sub(self, other: Self) -> Self {\n             match self.checked_sub(other) {\n                 Some(x) => x,\n-                None if other >= Self::zero() => Self::min_value(),\n+                None if other >= 0 => Self::min_value(),\n                 None => Self::max_value(),\n             }\n         }\n@@ -1064,7 +1072,7 @@ macro_rules! int_impl {\n         #[rustc_inherit_overflow_checks]\n         pub fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n-            let mut acc = Self::one();\n+            let mut acc = 1;\n \n             while exp > 1 {\n                 if (exp & 1) == 1 {\n@@ -2092,7 +2100,7 @@ macro_rules! uint_impl {\n         #[rustc_inherit_overflow_checks]\n         pub fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n-            let mut acc = Self::one();\n+            let mut acc = 1;\n \n             let mut prev_base = self;\n             let mut base_oflo = false;\n@@ -2129,8 +2137,7 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn is_power_of_two(self) -> bool {\n-            (self.wrapping_sub(Self::one())) & self == Self::zero() &&\n-                !(self == Self::zero())\n+            (self.wrapping_sub(1)) & self == 0 && !(self == 0)\n         }\n \n         /// Returns the smallest power of two greater than or equal to `self`.\n@@ -2148,7 +2155,7 @@ macro_rules! uint_impl {\n         #[inline]\n         pub fn next_power_of_two(self) -> Self {\n             let bits = size_of::<Self>() * 8;\n-            let one: Self = Self::one();\n+            let one: Self = 1;\n             one << ((bits - self.wrapping_sub(one).leading_zeros() as usize) % bits)\n         }\n \n@@ -2303,26 +2310,44 @@ pub trait Float: Sized {\n     /// Returns the NaN value.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn nan() -> Self;\n     /// Returns the infinite value.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn infinity() -> Self;\n     /// Returns the negative infinite value.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn neg_infinity() -> Self;\n     /// Returns -0.0.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn neg_zero() -> Self;\n     /// Returns 0.0.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn zero() -> Self;\n     /// Returns 1.0.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn one() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n@@ -2345,6 +2370,9 @@ pub trait Float: Sized {\n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn integer_decode(self) -> (u64, i16, i8);\n \n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n@@ -2379,12 +2407,10 @@ pub trait Float: Sized {\n     fn powi(self, n: i32) -> Self;\n \n     /// Convert radians to degrees.\n-    #[unstable(feature = \"float_extras\", reason = \"desirability is unclear\",\n-               issue = \"27752\")]\n+    #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n     fn to_degrees(self) -> Self;\n     /// Convert degrees to radians.\n-    #[unstable(feature = \"float_extras\", reason = \"desirability is unclear\",\n-               issue = \"27752\")]\n+    #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n     fn to_radians(self) -> Self;\n }\n "}, {"sha": "7753aae147a88d722d532d7198e1d52bf7b3e9cd", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -69,9 +69,7 @@\n \n use cmp::PartialOrd;\n use fmt;\n-use convert::From;\n use marker::{Sized, Unsize};\n-use num::One;\n \n /// The `Drop` trait is used to run some code when a value goes out of scope.\n /// This is sometimes called a 'destructor'.\n@@ -1494,7 +1492,6 @@ impl fmt::Debug for RangeFull {\n /// # Examples\n ///\n /// ```\n-/// #![feature(iter_arith)]\n /// fn main() {\n ///     assert_eq!((3..5), std::ops::Range{ start: 3, end: 5 });\n ///     assert_eq!(3+4+5, (3..6).sum());\n@@ -1558,7 +1555,6 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n /// # Examples\n ///\n /// ```\n-/// #![feature(iter_arith)]\n /// fn main() {\n ///     assert_eq!((2..), std::ops::RangeFrom{ start: 2 });\n ///     assert_eq!(2+3+4, (2..).take(3).sum());\n@@ -1660,7 +1656,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// # Examples\n ///\n /// ```\n-/// #![feature(inclusive_range,inclusive_range_syntax,iter_arith)]\n+/// #![feature(inclusive_range,inclusive_range_syntax)]\n /// fn main() {\n ///     assert_eq!((3...5), std::ops::RangeInclusive::NonEmpty{ start: 3, end: 5 });\n ///     assert_eq!(3+4+5, (3...5).sum());\n@@ -1714,24 +1710,6 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     }\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<Idx: PartialOrd + One + Sub<Output=Idx>> From<Range<Idx>> for RangeInclusive<Idx> {\n-    fn from(range: Range<Idx>) -> RangeInclusive<Idx> {\n-        use self::RangeInclusive::*;\n-\n-        if range.start < range.end {\n-            NonEmpty {\n-                start: range.start,\n-                end: range.end - Idx::one() // can't underflow because end > start >= MIN\n-            }\n-        } else {\n-            Empty {\n-                at: range.start\n-            }\n-        }\n-    }\n-}\n-\n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// # Examples"}, {"sha": "053158c14bf20ffb5ac4f6618cc23a5685a78796", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -19,9 +19,7 @@\n #![feature(core_private_diy_float)]\n #![feature(dec2flt)]\n #![feature(fixed_size_array)]\n-#![feature(float_extras)]\n #![feature(flt2dec)]\n-#![feature(iter_arith)]\n #![feature(libc)]\n #![feature(nonzero)]\n #![feature(rand)]"}, {"sha": "1a3533317dae68c57aed2528469ed575e738e58d", "filename": "src/libcoretest/num/dec2flt/rawfp.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcoretest%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcoretest%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fdec2flt%2Frawfp.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -9,9 +9,24 @@\n // except according to those terms.\n \n use std::f64;\n+use std::mem;\n use core::num::diy_float::Fp;\n use core::num::dec2flt::rawfp::{fp_to_float, prev_float, next_float, round_normal};\n \n+fn integer_decode(f: f64) -> (u64, i16, i8) {\n+    let bits: u64 = unsafe { mem::transmute(f) };\n+    let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n+    let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n+    let mantissa = if exponent == 0 {\n+        (bits & 0xfffffffffffff) << 1\n+    } else {\n+        (bits & 0xfffffffffffff) | 0x10000000000000\n+    };\n+    // Exponent bias + mantissa shift\n+    exponent -= 1023 + 52;\n+    (mantissa, exponent, sign)\n+}\n+\n #[test]\n fn fp_to_float_half_to_even() {\n     fn is_normalized(sig: u64) -> bool {\n@@ -21,12 +36,12 @@ fn fp_to_float_half_to_even() {\n \n     fn conv(sig: u64) -> u64 {\n         // The significands are perfectly in range, so the exponent should not matter\n-        let (m1, e1, _) = fp_to_float::<f64>(Fp { f: sig, e: 0 }).integer_decode();\n+        let (m1, e1, _) = integer_decode(fp_to_float::<f64>(Fp { f: sig, e: 0 }));\n         assert_eq!(e1, 0 + 64 - 53);\n-        let (m2, e2, _) = fp_to_float::<f64>(Fp { f: sig, e: 55 }).integer_decode();\n+        let (m2, e2, _) = integer_decode(fp_to_float::<f64>(Fp { f: sig, e: 55 }));\n         assert_eq!(e2, 55 + 64 - 53);\n         assert_eq!(m2, m1);\n-        let (m3, e3, _) = fp_to_float::<f64>(Fp { f: sig, e: -78 }).integer_decode();\n+        let (m3, e3, _) = integer_decode(fp_to_float::<f64>(Fp { f: sig, e: -78 }));\n         assert_eq!(e3, -78 + 64 - 53);\n         assert_eq!(m3, m2);\n         m3\n@@ -65,7 +80,7 @@ const SOME_FLOATS: [f64; 9] =\n #[test]\n fn human_f64_roundtrip() {\n     for &x in &SOME_FLOATS {\n-        let (f, e, _) = x.integer_decode();\n+        let (f, e, _) = integer_decode(x);\n         let fp = Fp { f: f, e: e};\n         assert_eq!(fp_to_float::<f64>(fp), x);\n     }"}, {"sha": "857aae72c8a5bd5d92a0088a36bbe3c37fc58b37", "filename": "src/libcoretest/num/flt2dec/estimator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::f64;\n use core::num::flt2dec::estimator::*;\n \n #[test]\n@@ -54,7 +53,7 @@ fn test_estimate_scaling_factor() {\n     assert_almost_eq!(estimate_scaling_factor(0x1fffffffffffff, 971), 309);\n \n     for i in -1074..972 {\n-        let expected = f64::ldexp(1.0, i).log10().ceil();\n+        let expected = super::ldexp_f64(1.0, i).log10().ceil();\n         assert_almost_eq!(estimate_scaling_factor(1, i as i16), expected as i16);\n     }\n }"}, {"sha": "0f4d19e7092571495405338fb31ef9f3a1f5fd9b", "filename": "src/libcoretest/num/flt2dec/mod.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -89,6 +89,17 @@ macro_rules! try_fixed {\n     })\n }\n \n+fn ldexp_f32(a: f32, b: i32) -> f32 {\n+    ldexp_f64(a as f64, b) as f32\n+}\n+\n+fn ldexp_f64(a: f64, b: i32) -> f64 {\n+    extern {\n+        fn ldexp(x: f64, n: i32) -> f64;\n+    }\n+    unsafe { ldexp(a, b) }\n+}\n+\n fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16)\n         where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n     // use a large enough buffer\n@@ -237,7 +248,7 @@ pub fn f32_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     // 10^8 * 0.3355443\n     // 10^8 * 0.33554432\n     // 10^8 * 0.33554436\n-    check_shortest!(f(f32::ldexp(1.0, 25)) => b\"33554432\", 8);\n+    check_shortest!(f(ldexp_f32(1.0, 25)) => b\"33554432\", 8);\n \n     // 10^39 * 0.340282326356119256160033759537265639424\n     // 10^39 * 0.34028234663852885981170418348451692544\n@@ -252,13 +263,13 @@ pub fn f32_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     // 10^-44 * 0\n     // 10^-44 * 0.1401298464324817070923729583289916131280...\n     // 10^-44 * 0.2802596928649634141847459166579832262560...\n-    let minf32 = f32::ldexp(1.0, -149);\n+    let minf32 = ldexp_f32(1.0, -149);\n     check_shortest!(f(minf32) => b\"1\", -44);\n }\n \n pub fn f32_exact_sanity_test<F>(mut f: F)\n         where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n-    let minf32 = f32::ldexp(1.0, -149);\n+    let minf32 = ldexp_f32(1.0, -149);\n \n     check_exact!(f(0.1f32)            => b\"100000001490116119384765625             \", 0);\n     check_exact!(f(0.5f32)            => b\"5                                       \", 0);\n@@ -336,7 +347,7 @@ pub fn f64_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     // 10^20 * 0.18446744073709549568\n     // 10^20 * 0.18446744073709551616\n     // 10^20 * 0.18446744073709555712\n-    check_shortest!(f(f64::ldexp(1.0, 64)) => b\"18446744073709552\", 20);\n+    check_shortest!(f(ldexp_f64(1.0, 64)) => b\"18446744073709552\", 20);\n \n     // pathological case: high = 10^23 (exact). tie breaking should always prefer that.\n     // 10^24 * 0.099999999999999974834176\n@@ -357,13 +368,13 @@ pub fn f64_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     // 10^-323 * 0\n     // 10^-323 * 0.4940656458412465441765687928682213723650...\n     // 10^-323 * 0.9881312916824930883531375857364427447301...\n-    let minf64 = f64::ldexp(1.0, -1074);\n+    let minf64 = ldexp_f64(1.0, -1074);\n     check_shortest!(f(minf64) => b\"5\", -323);\n }\n \n pub fn f64_exact_sanity_test<F>(mut f: F)\n         where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n-    let minf64 = f64::ldexp(1.0, -1074);\n+    let minf64 = ldexp_f64(1.0, -1074);\n \n     check_exact!(f(0.1f64)            => b\"1000000000000000055511151231257827021181\", 0);\n     check_exact!(f(0.45f64)           => b\"4500000000000000111022302462515654042363\", 0);\n@@ -616,7 +627,7 @@ pub fn to_shortest_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, 1, false), format!(\"34028235{:0>31}.0\", \"\"));\n     assert_eq!(to_string(f, f32::MAX, Minus, 8, false), format!(\"34028235{:0>31}.00000000\", \"\"));\n \n-    let minf32 = f32::ldexp(1.0, -149);\n+    let minf32 = ldexp_f32(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus,  0, false), format!(\"0.{:0>44}1\", \"\"));\n     assert_eq!(to_string(f, minf32, Minus, 45, false), format!(\"0.{:0>44}1\", \"\"));\n     assert_eq!(to_string(f, minf32, Minus, 46, false), format!(\"0.{:0>44}10\", \"\"));\n@@ -628,7 +639,7 @@ pub fn to_shortest_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f64::MAX, Minus, 8, false),\n                format!(\"17976931348623157{:0>292}.00000000\", \"\"));\n \n-    let minf64 = f64::ldexp(1.0, -1074);\n+    let minf64 = ldexp_f64(1.0, -1074);\n     assert_eq!(to_string(f, minf64, Minus,   0, false), format!(\"0.{:0>323}5\", \"\"));\n     assert_eq!(to_string(f, minf64, Minus, 324, false), format!(\"0.{:0>323}5\", \"\"));\n     assert_eq!(to_string(f, minf64, Minus, 325, false), format!(\"0.{:0>323}50\", \"\"));\n@@ -730,7 +741,7 @@ pub fn to_shortest_exp_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, (-39, 38), false), \"3.4028235e38\");\n     assert_eq!(to_string(f, f32::MAX, Minus, (-38, 39), false), format!(\"34028235{:0>31}\", \"\"));\n \n-    let minf32 = f32::ldexp(1.0, -149);\n+    let minf32 = ldexp_f32(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus, ( -4, 16), false), \"1e-45\");\n     assert_eq!(to_string(f, minf32, Minus, (-44, 45), false), \"1e-45\");\n     assert_eq!(to_string(f, minf32, Minus, (-45, 44), false), format!(\"0.{:0>44}1\", \"\"));\n@@ -742,7 +753,7 @@ pub fn to_shortest_exp_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f64::MAX, Minus, (-309, 308), false),\n                \"1.7976931348623157e308\");\n \n-    let minf64 = f64::ldexp(1.0, -1074);\n+    let minf64 = ldexp_f64(1.0, -1074);\n     assert_eq!(to_string(f, minf64, Minus, (  -4,  16), false), \"5e-324\");\n     assert_eq!(to_string(f, minf64, Minus, (-324, 323), false), format!(\"0.{:0>323}5\", \"\"));\n     assert_eq!(to_string(f, minf64, Minus, (-323, 324), false), \"5e-324\");\n@@ -874,7 +885,7 @@ pub fn to_exact_exp_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, 64, false),\n                \"3.402823466385288598117041834845169254400000000000000000000000000e38\");\n \n-    let minf32 = f32::ldexp(1.0, -149);\n+    let minf32 = ldexp_f32(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus,   1, false), \"1e-45\");\n     assert_eq!(to_string(f, minf32, Minus,   2, false), \"1.4e-45\");\n     assert_eq!(to_string(f, minf32, Minus,   4, false), \"1.401e-45\");\n@@ -914,7 +925,7 @@ pub fn to_exact_exp_str_test<F>(mut f_: F)\n                  0000000000000000000000000000000000000000000000000000000000000000e308\");\n \n     // okay, this is becoming tough. fortunately for us, this is almost the worst case.\n-    let minf64 = f64::ldexp(1.0, -1074);\n+    let minf64 = ldexp_f64(1.0, -1074);\n     assert_eq!(to_string(f, minf64, Minus,    1, false), \"5e-324\");\n     assert_eq!(to_string(f, minf64, Minus,    2, false), \"4.9e-324\");\n     assert_eq!(to_string(f, minf64, Minus,    4, false), \"4.941e-324\");\n@@ -1120,7 +1131,7 @@ pub fn to_exact_fixed_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, 2, false),\n                \"340282346638528859811704183484516925440.00\");\n \n-    let minf32 = f32::ldexp(1.0, -149);\n+    let minf32 = ldexp_f32(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus,   0, false), \"0\");\n     assert_eq!(to_string(f, minf32, Minus,   1, false), \"0.0\");\n     assert_eq!(to_string(f, minf32, Minus,   2, false), \"0.00\");\n@@ -1152,7 +1163,7 @@ pub fn to_exact_fixed_str_test<F>(mut f_: F)\n                 9440758685084551339423045832369032229481658085593321233482747978\\\n                 26204144723168738177180919299881250404026184124858368.0000000000\");\n \n-    let minf64 = f64::ldexp(1.0, -1074);\n+    let minf64 = ldexp_f64(1.0, -1074);\n     assert_eq!(to_string(f, minf64, Minus, 0, false), \"0\");\n     assert_eq!(to_string(f, minf64, Minus, 1, false), \"0.0\");\n     assert_eq!(to_string(f, minf64, Minus, 10, false), \"0.0000000000\");"}, {"sha": "48ea953cc1e8b05a137d32659ab11caa20bde3a8", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -30,7 +30,6 @@\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(enumset)]\n-#![feature(iter_arith)]\n #![feature(libc)]\n #![feature(nonzero)]\n #![feature(quote)]"}, {"sha": "726ba4fc1924fd48f3b3fc25b7c0d38df381c0f3", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -27,7 +27,6 @@\n #![feature(staged_api)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n-#![feature(iter_arith)]\n #![feature(question_mark)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "9cb5d8b6ad62a2e43781bb64b3b7806f5fabe425", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -28,7 +28,6 @@\n #![feature(const_fn)]\n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n-#![feature(iter_arith)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "6239506c2d7800fac75b9415b14cbc850481864c", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -76,7 +76,6 @@ This API is completely unstable and subject to change.\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(iter_arith)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "7a676c041ad89084e72b2ea5325923f0e0fabf4b", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -110,13 +110,15 @@ mod cmath {\n         }\n \n         #[inline]\n+        #[allow(deprecated)]\n         pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float {\n             let (a, b) = f64::frexp(x as f64);\n             *value = b as c_int;\n             a as c_float\n         }\n \n         #[inline]\n+        #[allow(deprecated)]\n         pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float {\n             f64::ldexp(x as f64, n as isize) as c_float\n         }\n@@ -265,7 +267,11 @@ impl f32 {\n     /// [floating-point]: ../reference.html#machine-types\n     #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n+    #[allow(deprecated)]\n     pub fn integer_decode(self) -> (u64, i16, i8) {\n         num::Float::integer_decode(self)\n     }\n@@ -718,6 +724,9 @@ impl f32 {\n     #[unstable(feature = \"float_extras\",\n                reason = \"pending integer conventions\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n     pub fn ldexp(x: f32, exp: isize) -> f32 {\n         unsafe { cmath::ldexpf(x, exp as c_int) }\n@@ -747,6 +756,9 @@ impl f32 {\n     #[unstable(feature = \"float_extras\",\n                reason = \"pending integer conventions\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n     pub fn frexp(self) -> (f32, isize) {\n         unsafe {\n@@ -773,6 +785,9 @@ impl f32 {\n     #[unstable(feature = \"float_extras\",\n                reason = \"unsure about its place in the world\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n     pub fn next_after(self, other: f32) -> f32 {\n         unsafe { cmath::nextafterf(self, other) }\n@@ -1384,6 +1399,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_integer_decode() {\n         assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n         assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n@@ -1711,6 +1727,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_ldexp() {\n         let f1 = 2.0f32.powi(-123);\n         let f2 = 2.0f32.powi(-111);\n@@ -1731,6 +1748,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_frexp() {\n         let f1 = 2.0f32.powi(-123);\n         let f2 = 2.0f32.powi(-111);\n@@ -1750,6 +1768,7 @@ mod tests {\n     }\n \n     #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n+    #[allow(deprecated)]\n     fn test_frexp_nowin() {\n         let inf: f32 = f32::INFINITY;\n         let neg_inf: f32 = f32::NEG_INFINITY;"}, {"sha": "67a1c302483d20644bdd157def4bed445c47e6fa", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -209,7 +209,11 @@ impl f64 {\n     /// [floating-point]: ../reference.html#machine-types\n     #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n+    #[allow(deprecated)]\n     pub fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n \n     /// Returns the largest integer less than or equal to a number.\n@@ -613,6 +617,9 @@ impl f64 {\n     #[unstable(feature = \"float_extras\",\n                reason = \"pending integer conventions\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n     pub fn ldexp(x: f64, exp: isize) -> f64 {\n         unsafe { cmath::ldexp(x, exp as c_int) }\n@@ -640,6 +647,9 @@ impl f64 {\n     #[unstable(feature = \"float_extras\",\n                reason = \"pending integer conventions\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n     pub fn frexp(self) -> (f64, isize) {\n         unsafe {\n@@ -664,6 +674,9 @@ impl f64 {\n     #[unstable(feature = \"float_extras\",\n                reason = \"unsure about its place in the world\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n     pub fn next_after(self, other: f64) -> f64 {\n         unsafe { cmath::nextafter(self, other) }\n@@ -1277,6 +1290,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_integer_decode() {\n         assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n         assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n@@ -1604,6 +1618,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_ldexp() {\n         let f1 = 2.0f64.powi(-123);\n         let f2 = 2.0f64.powi(-111);\n@@ -1624,6 +1639,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_frexp() {\n         let f1 = 2.0f64.powi(-123);\n         let f2 = 2.0f64.powi(-111);\n@@ -1643,6 +1659,7 @@ mod tests {\n     }\n \n     #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n+    #[allow(deprecated)]\n     fn test_frexp_nowin() {\n         let inf: f64 = INFINITY;\n         let neg_inf: f64 = NEG_INFINITY;"}, {"sha": "20804d62dfab663401f07293496b3c4d1066973d", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -17,6 +17,7 @@\n #![allow(missing_docs)]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub use core::num::{Zero, One};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::{FpCategory, ParseIntError, ParseFloatError, TryFromIntError};\n@@ -46,7 +47,6 @@ pub fn test_num<T>(ten: T, two: T) where\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use u8;\n     use u16;\n     use u32;\n@@ -198,15 +198,14 @@ mod tests {\n \n     #[test]\n     fn test_pow() {\n-        fn naive_pow<T: Mul<Output=T> + One + Copy>(base: T, exp: usize) -> T {\n-            let one: T = T::one();\n+        fn naive_pow<T: Mul<Output=T> + Copy>(one: T, base: T, exp: usize) -> T {\n             (0..exp).fold(one, |acc, _| acc * base)\n         }\n         macro_rules! assert_pow {\n             (($num:expr, $exp:expr) => $expected:expr) => {{\n                 let result = $num.pow($exp);\n                 assert_eq!(result, $expected);\n-                assert_eq!(result, naive_pow($num, $exp));\n+                assert_eq!(result, naive_pow(1, $num, $exp));\n             }}\n         }\n         assert_pow!((3u32,     0 ) => 1);"}, {"sha": "f0fd42fc99b806eadba0b261ddefe2ca61872980", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -12,8 +12,6 @@\n \n use io::{self, ErrorKind};\n use libc;\n-use num::One;\n-use ops::Neg;\n \n #[cfg(target_os = \"android\")]   pub use os::android as platform;\n #[cfg(target_os = \"bitrig\")]    pub use os::bitrig as platform;\n@@ -123,17 +121,32 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     }\n }\n \n-pub fn cvt<T: One + PartialEq + Neg<Output=T>>(t: T) -> io::Result<T> {\n-    let one: T = T::one();\n-    if t == -one {\n+#[doc(hidden)]\n+pub trait IsMinusOne {\n+    fn is_minus_one(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_minus_one {\n+    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n+        fn is_minus_one(&self) -> bool {\n+            *self == -1\n+        }\n+    })*)\n+}\n+\n+impl_is_minus_one! { i8 i16 i32 i64 isize }\n+\n+pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n+    if t.is_minus_one() {\n         Err(io::Error::last_os_error())\n     } else {\n         Ok(t)\n     }\n }\n \n pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n-    where T: One + PartialEq + Neg<Output=T>, F: FnMut() -> T\n+    where T: IsMinusOne,\n+          F: FnMut() -> T\n {\n     loop {\n         match cvt(f()) {"}, {"sha": "12219c1e9d42bf750717bdb1c8f16b169c17d1e7", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -14,7 +14,6 @@ use prelude::v1::*;\n \n use ffi::{OsStr, OsString};\n use io::{self, ErrorKind};\n-use num::Zero;\n use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n use time::Duration;\n@@ -178,8 +177,22 @@ pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     }\n }\n \n-fn cvt<I: PartialEq + Zero>(i: I) -> io::Result<I> {\n-    if i == I::zero() {\n+trait IsZero {\n+    fn is_zero(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_zero {\n+    ($($t:ident)*) => ($(impl IsZero for $t {\n+        fn is_zero(&self) -> bool {\n+            *self == 0\n+        }\n+    })*)\n+}\n+\n+impl_is_zero! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n+fn cvt<I: IsZero>(i: I) -> io::Result<I> {\n+    if i.is_zero() {\n         Err(io::Error::last_os_error())\n     } else {\n         Ok(i)"}, {"sha": "71e164f012f1f7c4dfe9cba2ef212660414da296", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -17,8 +17,6 @@ use io::{self, Read};\n use libc::{c_int, c_void, c_ulong};\n use mem;\n use net::{SocketAddr, Shutdown};\n-use num::One;\n-use ops::Neg;\n use ptr;\n use sync::Once;\n use sys::c;\n@@ -60,11 +58,26 @@ fn last_error() -> io::Error {\n     io::Error::from_raw_os_error(unsafe { c::WSAGetLastError() })\n }\n \n+#[doc(hidden)]\n+pub trait IsMinusOne {\n+    fn is_minus_one(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_minus_one {\n+    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n+        fn is_minus_one(&self) -> bool {\n+            *self == -1\n+        }\n+    })*)\n+}\n+\n+impl_is_minus_one! { i8 i16 i32 i64 isize }\n+\n /// Checks if the signed integer is the Windows constant `SOCKET_ERROR` (-1)\n /// and if so, returns the last error from the Windows socket interface. This\n /// function must be called before another call to the socket API is made.\n-pub fn cvt<T: One + PartialEq + Neg<Output=T>>(t: T) -> io::Result<T> {\n-    if t == -T::one() {\n+pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n+    if t.is_minus_one() {\n         Err(last_error())\n     } else {\n         Ok(t)\n@@ -82,7 +95,8 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n \n /// Just to provide the same interface as sys/unix/net.rs\n pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n-    where T: One + PartialEq + Neg<Output=T>, F: FnMut() -> T\n+    where T: IsMinusOne,\n+          F: FnMut() -> T\n {\n     cvt(f())\n }"}, {"sha": "c00be91a2d74daf067a0d99abb6251d0652239c9", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -17,9 +17,8 @@ pub fn main() {\n \n     // Bool => does not implement iterator.\n     for i in false..true {}\n-    //~^ ERROR `bool: std::num::One` is not satisfied\n-    //~^^ ERROR `bool: std::iter::Step` is not satisfied\n-    //~^^^ ERROR `for<'a> &'a bool: std::ops::Add` is not satisfied\n+    //~^ ERROR `bool: std::iter::Step` is not satisfied\n+    //~^^ ERROR `for<'a> &'a bool: std::ops::Add` is not satisfied\n \n     // Unsized type.\n     let arr: &[_] = &[1, 2, 3];"}, {"sha": "aaf129e7b8e4abf413e65847100a8dcf03f95ab8", "filename": "src/test/run-pass/range_inclusive.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange_inclusive.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -117,11 +117,6 @@ pub fn main() {\n     assert_eq!(nonsense.next(), None);\n     assert_eq!(nonsense, RangeInclusive::Empty { at: 10 });\n \n-    // conversion\n-    assert_eq!(0...9, (0..10).into());\n-    assert_eq!(0...0, (0..1).into());\n-    assert_eq!(RangeInclusive::Empty { at: 1 }, (1..0).into());\n-\n     // output\n     assert_eq!(format!(\"{:?}\", 0...10), \"0...10\");\n     assert_eq!(format!(\"{:?}\", ...10), \"...10\");"}, {"sha": "436dc1197533638504fb8c6e808f1e8d51137b1c", "filename": "src/tools/rustbook/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Ftools%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696b703b5a58816bb0e549ac332a98fa7e635949/src%2Ftools%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fmain.rs?ref=696b703b5a58816bb0e549ac332a98fa7e635949", "patch": "@@ -10,7 +10,6 @@\n \n #![deny(warnings)]\n \n-#![feature(iter_arith)]\n #![feature(rustc_private)]\n #![feature(rustdoc)]\n #![feature(question_mark)]"}]}