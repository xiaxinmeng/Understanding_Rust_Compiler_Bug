{"sha": "4d32de6fcbb2ab05e9aaa94477caa30d816f8f66", "node_id": "C_kwDOAAsO6NoAKDRkMzJkZTZmY2JiMmFiMDVlOWFhYTk0NDc3Y2FhMzBkODE2ZjhmNjY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-04T16:27:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-04T16:27:44Z"}, "message": "Rollup merge of #109838 - clubby789:non-exhaustive-span, r=Nilstrieb\n\nFix `non_exhaustive_omitted_patterns` lint span\n\nFixes #109837\n\n`DUMMY_SP` was being passed as the span in many cases where we have a span available to use. This meant that the location of the violating pattern wasn't shown, or the list of un-covered variants\n\nr? `@Nilstrieb`", "tree": {"sha": "184d6154f384bbeb1d67224345bfbf1b2a6ded1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/184d6154f384bbeb1d67224345bfbf1b2a6ded1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d32de6fcbb2ab05e9aaa94477caa30d816f8f66", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkLFAACRBK7hj4Ov3rIwAAxc0IAEnfpN1A8YXh+fBpMKENQqGV\nVx9vKjp1iGNbwDAiZ6nUzxT4ErIibmD4LUcWWa8gBpDmi5bUeOYJvT/7ygBKm3QP\ng6fBHzOrDXofdWPIm6QLY1dW4tBnhEzPNCW/WoLwzXdmU/2CRZlJOjoyxMXM/ldt\nwZGIAv3M3CmCPWzp+ha1kbJkMCWvzNbqDVW5XoN+5UpU4qCzygBwI6/8YULSwLmB\nRCXh+b8feMGzfFdsTjWFjYykhj2kCEFdgIZUKhQBswHJREGeCN6UUeyMDLNasQ14\n7541JTC18Ps1tRW25qIPw0ibaG2PLJgYhTYnMKADLc7yrBb5pXeQVBLlWX+O7jA=\n=Cx/p\n-----END PGP SIGNATURE-----\n", "payload": "tree 184d6154f384bbeb1d67224345bfbf1b2a6ded1c\nparent ec22850c2c580689eaf7a33679c82f50a72010b7\nparent 696f182191eae8ac8da951edb1206c97ad5da384\nauthor Michael Goulet <michael@errs.io> 1680625664 -0700\ncommitter GitHub <noreply@github.com> 1680625664 -0700\n\nRollup merge of #109838 - clubby789:non-exhaustive-span, r=Nilstrieb\n\nFix `non_exhaustive_omitted_patterns` lint span\n\nFixes #109837\n\n`DUMMY_SP` was being passed as the span in many cases where we have a span available to use. This meant that the location of the violating pattern wasn't shown, or the list of un-covered variants\n\nr? `@Nilstrieb`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d32de6fcbb2ab05e9aaa94477caa30d816f8f66", "html_url": "https://github.com/rust-lang/rust/commit/4d32de6fcbb2ab05e9aaa94477caa30d816f8f66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d32de6fcbb2ab05e9aaa94477caa30d816f8f66/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec22850c2c580689eaf7a33679c82f50a72010b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec22850c2c580689eaf7a33679c82f50a72010b7", "html_url": "https://github.com/rust-lang/rust/commit/ec22850c2c580689eaf7a33679c82f50a72010b7"}, {"sha": "696f182191eae8ac8da951edb1206c97ad5da384", "url": "https://api.github.com/repos/rust-lang/rust/commits/696f182191eae8ac8da951edb1206c97ad5da384", "html_url": "https://github.com/rust-lang/rust/commit/696f182191eae8ac8da951edb1206c97ad5da384"}], "stats": {"total": 67, "additions": 46, "deletions": 21}, "files": [{"sha": "29f7cae3d3fec17f88d228d2f21296e1a1891e31", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4d32de6fcbb2ab05e9aaa94477caa30d816f8f66/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d32de6fcbb2ab05e9aaa94477caa30d816f8f66/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=4d32de6fcbb2ab05e9aaa94477caa30d816f8f66", "patch": "@@ -1154,8 +1154,9 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     fn wildcards_from_tys(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         tys: impl IntoIterator<Item = Ty<'tcx>>,\n+        span: Span,\n     ) -> Self {\n-        Fields::from_iter(cx, tys.into_iter().map(DeconstructedPat::wildcard))\n+        Fields::from_iter(cx, tys.into_iter().map(|ty| DeconstructedPat::wildcard(ty, span)))\n     }\n \n     // In the cases of either a `#[non_exhaustive]` field list or a non-public field, we hide\n@@ -1191,26 +1192,26 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     pub(super) fn wildcards(pcx: &PatCtxt<'_, 'p, 'tcx>, constructor: &Constructor<'tcx>) -> Self {\n         let ret = match constructor {\n             Single | Variant(_) => match pcx.ty.kind() {\n-                ty::Tuple(fs) => Fields::wildcards_from_tys(pcx.cx, fs.iter()),\n-                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(pcx.cx, once(*rty)),\n+                ty::Tuple(fs) => Fields::wildcards_from_tys(pcx.cx, fs.iter(), pcx.span),\n+                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(pcx.cx, once(*rty), pcx.span),\n                 ty::Adt(adt, substs) => {\n                     if adt.is_box() {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n-                        Fields::wildcards_from_tys(pcx.cx, once(substs.type_at(0)))\n+                        Fields::wildcards_from_tys(pcx.cx, once(substs.type_at(0)), pcx.span)\n                     } else {\n                         let variant = &adt.variant(constructor.variant_index_for_adt(*adt));\n                         let tys = Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant)\n                             .map(|(_, ty)| ty);\n-                        Fields::wildcards_from_tys(pcx.cx, tys)\n+                        Fields::wildcards_from_tys(pcx.cx, tys, pcx.span)\n                     }\n                 }\n                 _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", pcx),\n             },\n             Slice(slice) => match *pcx.ty.kind() {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = slice.arity();\n-                    Fields::wildcards_from_tys(pcx.cx, (0..arity).map(|_| ty))\n+                    Fields::wildcards_from_tys(pcx.cx, (0..arity).map(|_| ty), pcx.span)\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, pcx),\n             },\n@@ -1251,8 +1252,8 @@ pub(crate) struct DeconstructedPat<'p, 'tcx> {\n }\n \n impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n-    pub(super) fn wildcard(ty: Ty<'tcx>) -> Self {\n-        Self::new(Wildcard, Fields::empty(), ty, DUMMY_SP)\n+    pub(super) fn wildcard(ty: Ty<'tcx>, span: Span) -> Self {\n+        Self::new(Wildcard, Fields::empty(), ty, span)\n     }\n \n     pub(super) fn new(\n@@ -1269,7 +1270,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// `Some(_)`.\n     pub(super) fn wild_from_ctor(pcx: &PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n         let fields = Fields::wildcards(pcx, &ctor);\n-        DeconstructedPat::new(ctor, fields, pcx.ty, DUMMY_SP)\n+        DeconstructedPat::new(ctor, fields, pcx.ty, pcx.span)\n     }\n \n     /// Clone this value. This method emphasizes that cloning loses reachability information and\n@@ -1298,7 +1299,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                     ty::Tuple(fs) => {\n                         ctor = Single;\n                         let mut wilds: SmallVec<[_; 2]> =\n-                            fs.iter().map(DeconstructedPat::wildcard).collect();\n+                            fs.iter().map(|ty| DeconstructedPat::wildcard(ty, pat.span)).collect();\n                         for pat in subpatterns {\n                             wilds[pat.field.index()] = mkpat(&pat.pattern);\n                         }\n@@ -1317,11 +1318,11 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                         // normally or through box-patterns. We'll have to figure out a proper\n                         // solution when we introduce generalized deref patterns. Also need to\n                         // prevent mixing of those two options.\n-                        let pat = subpatterns.into_iter().find(|pat| pat.field.index() == 0);\n-                        let pat = if let Some(pat) = pat {\n+                        let pattern = subpatterns.into_iter().find(|pat| pat.field.index() == 0);\n+                        let pat = if let Some(pat) = pattern {\n                             mkpat(&pat.pattern)\n                         } else {\n-                            DeconstructedPat::wildcard(substs.type_at(0))\n+                            DeconstructedPat::wildcard(substs.type_at(0), pat.span)\n                         };\n                         ctor = Single;\n                         fields = Fields::singleton(cx, pat);\n@@ -1343,7 +1344,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                                 ty\n                             });\n                         let mut wilds: SmallVec<[_; 2]> =\n-                            tys.map(DeconstructedPat::wildcard).collect();\n+                            tys.map(|ty| DeconstructedPat::wildcard(ty, pat.span)).collect();\n                         for pat in subpatterns {\n                             if let Some(i) = field_id_to_id[pat.field.index()] {\n                                 wilds[i] = mkpat(&pat.pattern);\n@@ -1566,8 +1567,10 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                         };\n                         let prefix = &self.fields.fields[..prefix];\n                         let suffix = &self.fields.fields[self_slice.arity() - suffix..];\n-                        let wildcard: &_ =\n-                            pcx.cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n+                        let wildcard: &_ = pcx\n+                            .cx\n+                            .pattern_arena\n+                            .alloc(DeconstructedPat::wildcard(inner_ty, pcx.span));\n                         let extra_wildcards = other_slice.arity() - self_slice.arity();\n                         let extra_wildcards = (0..extra_wildcards).map(|_| wildcard);\n                         prefix.iter().chain(extra_wildcards).chain(suffix).collect()"}, {"sha": "a324c3a6228064c8021adf326f4bee5107d93355", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d32de6fcbb2ab05e9aaa94477caa30d816f8f66/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d32de6fcbb2ab05e9aaa94477caa30d816f8f66/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=4d32de6fcbb2ab05e9aaa94477caa30d816f8f66", "patch": "@@ -604,7 +604,7 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n                     let new_patterns = if pcx.is_non_exhaustive {\n                         // Here we don't want the user to try to list all variants, we want them to add\n                         // a wildcard, so we only suggest that.\n-                        vec![DeconstructedPat::wildcard(pcx.ty)]\n+                        vec![DeconstructedPat::wildcard(pcx.ty, pcx.span)]\n                     } else {\n                         let mut split_wildcard = SplitWildcard::new(pcx);\n                         split_wildcard.split(pcx, matrix.heads().map(DeconstructedPat::ctor));\n@@ -631,7 +631,7 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n                             .collect();\n \n                         if hide_variant_show_wild {\n-                            new.push(DeconstructedPat::wildcard(pcx.ty));\n+                            new.push(DeconstructedPat::wildcard(pcx.ty, pcx.span));\n                         }\n \n                         new\n@@ -734,7 +734,7 @@ impl<'p, 'tcx> Witness<'p, 'tcx> {\n             let arity = ctor.arity(pcx);\n             let pats = self.0.drain((len - arity)..).rev();\n             let fields = Fields::from_iter(pcx.cx, pats);\n-            DeconstructedPat::new(ctor.clone(), fields, pcx.ty, DUMMY_SP)\n+            DeconstructedPat::new(ctor.clone(), fields, pcx.ty, pcx.span)\n         };\n \n         self.0.push(pat);\n@@ -977,7 +977,7 @@ pub(crate) fn compute_match_usefulness<'p, 'tcx>(\n         })\n         .collect();\n \n-    let wild_pattern = cx.pattern_arena.alloc(DeconstructedPat::wildcard(scrut_ty));\n+    let wild_pattern = cx.pattern_arena.alloc(DeconstructedPat::wildcard(scrut_ty, DUMMY_SP));\n     let v = PatStack::from_pattern(wild_pattern);\n     let usefulness = is_useful(cx, &matrix, &v, FakeExtraWildcard, scrut_hir_id, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {"}, {"sha": "3482af74752f821982f0aad2973d91a791079beb", "filename": "tests/ui/rfc-2008-non-exhaustive/omitted-patterns.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d32de6fcbb2ab05e9aaa94477caa30d816f8f66/tests%2Fui%2Frfc-2008-non-exhaustive%2Fomitted-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d32de6fcbb2ab05e9aaa94477caa30d816f8f66/tests%2Fui%2Frfc-2008-non-exhaustive%2Fomitted-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2008-non-exhaustive%2Fomitted-patterns.rs?ref=4d32de6fcbb2ab05e9aaa94477caa30d816f8f66", "patch": "@@ -194,6 +194,14 @@ fn main() {\n     let local_refutable @ NonExhaustiveEnum::Unit = NonExhaustiveEnum::Unit;\n     //~^ refutable pattern in local binding\n \n+    // Check that matching on a reference results in a correctly spanned diagnostic\n+    #[deny(non_exhaustive_omitted_patterns)]\n+    match &non_enum {\n+        NonExhaustiveEnum::Unit => {}\n+        NonExhaustiveEnum::Tuple(_) => {}\n+        _ => {}\n+    }\n+    //~^^ some variants are not matched explicitly\n }\n \n #[deny(non_exhaustive_omitted_patterns)]"}, {"sha": "520a90322c1ca8dd2263ce7dbeb956c0c4fb27dc", "filename": "tests/ui/rfc-2008-non-exhaustive/omitted-patterns.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4d32de6fcbb2ab05e9aaa94477caa30d816f8f66/tests%2Fui%2Frfc-2008-non-exhaustive%2Fomitted-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d32de6fcbb2ab05e9aaa94477caa30d816f8f66/tests%2Fui%2Frfc-2008-non-exhaustive%2Fomitted-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2008-non-exhaustive%2Fomitted-patterns.stderr?ref=4d32de6fcbb2ab05e9aaa94477caa30d816f8f66", "patch": "@@ -198,6 +198,20 @@ help: you might want to use `let else` to handle the variant that isn't matched\n LL |     let local_refutable @ NonExhaustiveEnum::Unit = NonExhaustiveEnum::Unit else { todo!() };\n    |                                                                             ++++++++++++++++\n \n-error: aborting due to 9 previous errors; 6 warnings emitted\n+error: some variants are not matched explicitly\n+  --> $DIR/omitted-patterns.rs:202:9\n+   |\n+LL |         _ => {}\n+   |         ^ pattern `NonExhaustiveEnum::Struct { .. }` not covered\n+   |\n+   = help: ensure that all variants are matched explicitly by adding the suggested match arms\n+   = note: the matched value is of type `NonExhaustiveEnum` and the `non_exhaustive_omitted_patterns` attribute was found\n+note: the lint level is defined here\n+  --> $DIR/omitted-patterns.rs:198:12\n+   |\n+LL |     #[deny(non_exhaustive_omitted_patterns)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 10 previous errors; 6 warnings emitted\n \n For more information about this error, try `rustc --explain E0005`."}]}