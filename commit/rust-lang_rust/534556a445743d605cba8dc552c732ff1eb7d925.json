{"sha": "534556a445743d605cba8dc552c732ff1eb7d925", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNDU1NmE0NDU3NDNkNjA1Y2JhOGRjNTUyYzczMmZmMWViN2Q5MjU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-11-10T02:57:30Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-11-20T18:10:12Z"}, "message": "Read in rmeta crates", "tree": {"sha": "26ee88e4409f47463aa87f96d2adbb1d8fc9f2ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26ee88e4409f47463aa87f96d2adbb1d8fc9f2ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/534556a445743d605cba8dc552c732ff1eb7d925", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/534556a445743d605cba8dc552c732ff1eb7d925", "html_url": "https://github.com/rust-lang/rust/commit/534556a445743d605cba8dc552c732ff1eb7d925", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/534556a445743d605cba8dc552c732ff1eb7d925/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b286a2f0817dbe33de95c3746b6289a1e5bd6a81", "url": "https://api.github.com/repos/rust-lang/rust/commits/b286a2f0817dbe33de95c3746b6289a1e5bd6a81", "html_url": "https://github.com/rust-lang/rust/commit/b286a2f0817dbe33de95c3746b6289a1e5bd6a81"}], "stats": {"total": 143, "additions": 93, "deletions": 50}, "files": [{"sha": "1468e94459e63f2bec8df9b46761adbeea6a4ded", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=534556a445743d605cba8dc552c732ff1eb7d925", "patch": "@@ -56,24 +56,37 @@ pub struct LinkMeta {\n     pub crate_hash: Svh,\n }\n \n-// Where a crate came from on the local filesystem. One of these two options\n+// Where a crate came from on the local filesystem. One of these three options\n // must be non-None.\n #[derive(PartialEq, Clone, Debug)]\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n+    pub rmeta: Option<(PathBuf, PathKind)>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n-pub enum DepKind {\n-    /// A dependency that is only used for its macros.\n-    MacrosOnly,\n-    /// A dependency that is always injected into the dependency list and so\n-    /// doesn't need to be linked to an rlib, e.g. the injected allocator.\n-    Implicit,\n-    /// A dependency that is required by an rlib version of this crate.\n-    /// Ordinary `extern crate`s result in `Explicit` dependencies.\n-    Explicit,\n+#[derive(PartialEq, Clone, Debug)]\n+pub enum LibSource {\n+    Some(PathBuf),\n+    MetadataOnly,\n+    None,\n+}\n+\n+impl LibSource {\n+    pub fn is_some(&self) -> bool {\n+        if let LibSource::Some(_) = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub fn option(&self) -> Option<PathBuf> {\n+        match *self {\n+            LibSource::Some(ref p) => Some(p.clone()),\n+            LibSource::MetadataOnly | LibSource::None => None,\n+        }\n+    }\n }\n \n #[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable)]\n@@ -244,7 +257,7 @@ pub trait CrateStore<'tcx> {\n     // utility functions\n     fn metadata_filename(&self) -> &str;\n     fn metadata_section_name(&self, target: &Target) -> &str;\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>;\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -427,7 +440,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // utility functions\n     fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n     fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n         { vec![] }\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }"}, {"sha": "ee7f13f9e6e2266ddfafe6e0aa8b4dc629e6b560", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=534556a445743d605cba8dc552c732ff1eb7d925", "patch": "@@ -192,7 +192,7 @@ fn calculate_type(sess: &session::Session,\n         if src.dylib.is_none() &&\n            !formats.contains_key(&cnum) &&\n            sess.cstore.dep_kind(cnum) == DepKind::Explicit {\n-            assert!(src.rlib.is_some());\n+            assert!(src.rlib.is_some() || src.rmeta.is_some());\n             info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n             add_library(sess, cnum, RequireStatic, &mut formats);\n             ret[cnum.as_usize() - 1] = Linkage::Static;"}, {"sha": "6a3a1bbb55ca2bea035f80100b11d81736d281fa", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=534556a445743d605cba8dc552c732ff1eb7d925", "patch": "@@ -1093,7 +1093,6 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n          \"serialize work products\",\n          move || rustc_incremental::save_work_products(sess));\n \n-    println!(\"finish phase 5: {}\", sess.err_count());\n     if sess.err_count() > 0 {\n         Err(sess.err_count())\n     } else {"}, {"sha": "693b04ae661cd02b75fbad5e3b966e0c3e43c630", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=534556a445743d605cba8dc552c732ff1eb7d925", "patch": "@@ -44,6 +44,7 @@ use log;\n pub struct Library {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n+    pub rmeta: Option<(PathBuf, PathKind)>,\n     pub metadata: MetadataBlob,\n }\n \n@@ -62,9 +63,11 @@ fn dump_crates(cstore: &CStore) {\n         info!(\"  cnum: {}\", data.cnum);\n         info!(\"  hash: {}\", data.hash());\n         info!(\"  reqd: {:?}\", data.dep_kind.get());\n-        let CrateSource { dylib, rlib } = data.source.clone();\n+        let CrateSource { dylib, rlib, rmeta } = data.source.clone();\n         dylib.map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n         rlib.map(|rl|  info!(\"   rlib: {}\", rl.0.display()));\n+        rmeta.map(|rl| info!(\"   rmeta: {}\", rl.0.display()));\n+        });\n     })\n }\n \n@@ -278,14 +281,15 @@ impl<'a> CrateLoader<'a> {\n                 ident: ident.to_string(),\n                 dylib: lib.dylib.clone().map(|p| p.0),\n                 rlib:  lib.rlib.clone().map(|p| p.0),\n+                rmeta: lib.rmeta.clone().map(|p| p.0),\n             })\n         } else {\n             None\n         };\n         // Maintain a reference to the top most crate.\n         let root = if root.is_some() { root } else { &crate_paths };\n \n-        let Library { dylib, rlib, metadata } = lib;\n+        let Library { dylib, rlib, rmeta, metadata } = lib;\n \n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n@@ -305,6 +309,7 @@ impl<'a> CrateLoader<'a> {\n             source: cstore::CrateSource {\n                 dylib: dylib,\n                 rlib: rlib,\n+                rmeta: rmeta,\n             },\n         });\n "}, {"sha": "e5f7964d7eb9ccd6ca27b80e0f05dfe7568ccaca", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=534556a445743d605cba8dc552c732ff1eb7d925", "patch": "@@ -25,15 +25,14 @@ use rustc::util::nodemap::{FxHashMap, NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n-use std::path::PathBuf;\n use flate::Bytes;\n use syntax::{ast, attr};\n use syntax::ext::base::SyntaxExtension;\n use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibrary, LinkagePreference};\n pub use rustc::middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n-pub use rustc::middle::cstore::{CrateSource, LinkMeta};\n+pub use rustc::middle::cstore::{CrateSource, LinkMeta, LibSource};\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -185,7 +184,7 @@ impl CStore {\n     // positions.\n     pub fn do_get_used_crates(&self,\n                               prefer: LinkagePreference)\n-                              -> Vec<(CrateNum, Option<PathBuf>)> {\n+                              -> Vec<(CrateNum, LibSource)> {\n         let mut ordering = Vec::new();\n         for (&num, _) in self.metas.borrow().iter() {\n             self.push_dependencies_in_postorder(&mut ordering, num);\n@@ -201,6 +200,16 @@ impl CStore {\n                     LinkagePreference::RequireDynamic => data.source.dylib.clone().map(|p| p.0),\n                     LinkagePreference::RequireStatic => data.source.rlib.clone().map(|p| p.0),\n                 };\n+                let path = match path {\n+                    Some(p) => LibSource::Some(p),\n+                    None => {\n+                        if data.rmeta.is_some() {\n+                            LibSource::MetadataOnly\n+                        } else {\n+                            LibSource::None\n+                        }\n+                    }\n+                };\n                 Some((cnum, path))\n             })\n             .collect::<Vec<_>>();"}, {"sha": "cf8240db1958a2936d382cc457a8ce32d944c8dc", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=534556a445743d605cba8dc552c732ff1eb7d925", "patch": "@@ -13,7 +13,7 @@ use encoder;\n use locator;\n use schema;\n \n-use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, DepKind, ExternCrate};\n+use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, LibSource, DepKind, ExternCrate};\n use rustc::middle::cstore::{NativeLibrary, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n@@ -28,7 +28,6 @@ use rustc::mir::Mir;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n \n-use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n use syntax::parse::{token, new_parser_from_source_str};\n@@ -544,7 +543,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         locator::meta_section_name(target)\n     }\n \n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n     {\n         self.do_get_used_crates(prefer)\n     }"}, {"sha": "6cdd8b46464058aa0c3ed98c66067754414b1458", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=534556a445743d605cba8dc552c732ff1eb7d925", "patch": "@@ -53,6 +53,13 @@\n //! is a platform-defined dynamic library. Each library has a metadata somewhere\n //! inside of it.\n //!\n+//! A third kind of dependency is an rmeta file. These are rlibs, which contain\n+//! metadata, but no code. To a first approximation, these are treated in the\n+//! same way as rlibs. Where there is both an rlib and an rmeta file, the rlib\n+//! gets priority (even if the rmeta file is newer). An rmeta file is only\n+//! useful for checking a downstream crate, attempting to link one will cause an\n+//! error.\n+//!\n //! When translating a crate name to a crate on the filesystem, we all of a\n //! sudden need to take into account both rlibs and dylibs! Linkage later on may\n //! use either one of these files, as each has their pros/cons. The job of crate\n@@ -275,33 +282,31 @@ pub struct CratePaths {\n     pub ident: String,\n     pub dylib: Option<PathBuf>,\n     pub rlib: Option<PathBuf>,\n+    pub rmeta: Option<PathBuf>,\n }\n \n pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n \n #[derive(Copy, Clone, PartialEq)]\n enum CrateFlavor {\n     Rlib,\n+    Rmeta,\n     Dylib,\n }\n \n impl fmt::Display for CrateFlavor {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(match *self {\n             CrateFlavor::Rlib => \"rlib\",\n+            CrateFlavor::Rmeta => \"rmeta\",\n             CrateFlavor::Dylib => \"dylib\",\n         })\n     }\n }\n \n impl CratePaths {\n     fn paths(&self) -> Vec<PathBuf> {\n-        match (&self.dylib, &self.rlib) {\n-            (&None, &None) => vec![],\n-            (&Some(ref p), &None) |\n-            (&None, &Some(ref p)) => vec![p.clone()],\n-            (&Some(ref p1), &Some(ref p2)) => vec![p1.clone(), p2.clone()],\n-        }\n+        self.dylib.iter().chain(self.rlib.iter()).chain(self.rmeta.iter()).cloned().collect()\n     }\n }\n \n@@ -457,11 +462,13 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rlib\") {\n-                (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], true)\n+            let (hash, found_kind) = if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rlib\") {\n+                (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], CrateFlavor::Rlib)\n+            } else if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rmeta\") {\n+                (&file[(rlib_prefix.len())..(file.len() - \".rmeta\".len())], CrateFlavor::Rmeta)\n             } else if file.starts_with(&dylib_prefix) &&\n                                          file.ends_with(&dypair.1) {\n-                (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], false)\n+                (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], CrateFlavor::Dylib)\n             } else {\n                 if file.starts_with(&staticlib_prefix[..]) && file.ends_with(&staticpair.1) {\n                     staticlibs.push(CrateMismatch {\n@@ -475,14 +482,14 @@ impl<'a> Context<'a> {\n \n             let hash_str = hash.to_string();\n             let slot = candidates.entry(hash_str)\n-                .or_insert_with(|| (FxHashMap(), FxHashMap()));\n-            let (ref mut rlibs, ref mut dylibs) = *slot;\n+                .or_insert_with(|| (FxHashMap(), FxHashMap(), FxHashMap()));\n+            let (ref mut rlibs, ref mut rmetas, ref mut dylibs) = *slot;\n             fs::canonicalize(path)\n                 .map(|p| {\n-                    if rlib {\n-                        rlibs.insert(p, kind);\n-                    } else {\n-                        dylibs.insert(p, kind);\n+                    match found_kind {\n+                        CrateFlavor::Rlib => { rlibs.insert(p, kind); }\n+                        CrateFlavor::Rmeta => { rmetas.insert(p, kind); }\n+                        CrateFlavor::Dylib => { dylibs.insert(p, kind); }\n                     }\n                     FileMatches\n                 })\n@@ -499,15 +506,17 @@ impl<'a> Context<'a> {\n         // libraries corresponds to the crate id and hash criteria that this\n         // search is being performed for.\n         let mut libraries = FxHashMap();\n-        for (_hash, (rlibs, dylibs)) in candidates {\n+        for (_hash, (rlibs, rmetas, dylibs)) in candidates {\n             let mut slot = None;\n             let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n+            let rmeta = self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot);\n             let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n             if let Some((h, m)) = slot {\n                 libraries.insert(h,\n                                  Library {\n                                      dylib: dylib,\n                                      rlib: rlib,\n+                                     rmeta: rmeta,\n                                      metadata: m,\n                                  });\n             }\n@@ -703,6 +712,7 @@ impl<'a> Context<'a> {\n         let sess = self.sess;\n         let dylibname = self.dylibname();\n         let mut rlibs = FxHashMap();\n+        let mut rmetas = FxHashMap();\n         let mut dylibs = FxHashMap();\n         {\n             let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n@@ -744,6 +754,8 @@ impl<'a> Context<'a> {\n             for loc in locs {\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n                     rlibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n+                } else if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rmeta\") {\n+                    rmetas.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 } else {\n                     dylibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 }\n@@ -753,16 +765,18 @@ impl<'a> Context<'a> {\n         // Extract the rlib/dylib pair.\n         let mut slot = None;\n         let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n+        let rmeta = self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot);\n         let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n \n-        if rlib.is_none() && dylib.is_none() {\n+        if rlib.is_none() && rmeta.is_none() && dylib.is_none() {\n             return None;\n         }\n         match slot {\n             Some((_, metadata)) => {\n                 Some(Library {\n                     dylib: dylib,\n                     rlib: rlib,\n+                    rmeta: rmeta,\n                     metadata: metadata,\n                 })\n             }\n@@ -832,7 +846,7 @@ fn get_metadata_section_imp(target: &Target,\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n     }\n-    if flavor == CrateFlavor::Rlib {\n+    if flavor == CrateFlavor::Rlib || flavor == CrateFlavor::Rmeta {\n         // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n         // internally to read the file. We also avoid even using a memcpy by\n         // just keeping the archive along while the metadata is in use.\n@@ -933,6 +947,8 @@ pub fn list_file_metadata(target: &Target, path: &Path, out: &mut io::Write) ->\n     let filename = path.file_name().unwrap().to_str().unwrap();\n     let flavor = if filename.ends_with(\".rlib\") {\n         CrateFlavor::Rlib\n+    } else if filename.ends_with(\".rmeta\") {\n+        CrateFlavor::Rmeta\n     } else {\n         CrateFlavor::Dylib\n     };"}, {"sha": "7938ddde4cec733ad4926785e37246a04a0df998", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=534556a445743d605cba8dc552c732ff1eb7d925", "patch": "@@ -19,7 +19,7 @@ use session::config::{OutputFilenames, Input, OutputType};\n use session::filesearch;\n use session::search_paths::PathKind;\n use session::Session;\n-use middle::cstore::{self, LinkMeta, NativeLibrary};\n+use middle::cstore::{self, LinkMeta, NativeLibrary, LibSource};\n use middle::cstore::{LinkagePreference, NativeLibraryKind};\n use middle::dependency_format::Linkage;\n use CrateTranslation;\n@@ -123,7 +123,6 @@ pub fn find_crate_name(sess: Option<&Session>,\n     }\n \n     \"rust_out\".to_string()\n-\n }\n \n pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap,\n@@ -302,7 +301,7 @@ pub fn each_linked_rlib(sess: &Session,\n                    .or_else(|| fmts.get(&config::CrateTypeCdylib))\n                    .or_else(|| fmts.get(&config::CrateTypeProcMacro));\n     let fmts = fmts.unwrap_or_else(|| {\n-        bug!(\"could not find formats for rlibs\")\n+        bug!(\"could not find formats for rlibs\");\n     });\n     for (cnum, path) in crates {\n         match fmts[cnum.as_usize() - 1] {\n@@ -311,8 +310,11 @@ pub fn each_linked_rlib(sess: &Session,\n         }\n         let name = sess.cstore.crate_name(cnum).clone();\n         let path = match path {\n-            Some(p) => p,\n-            None => {\n+            LibSource::Some(p) => p,\n+            LibSource::MetadataOnly => {\n+                sess.fatal(&format!(\"could not find rlib for: `{}`, found rmeta (metadata) file\", name));\n+            }\n+            LibSource::None => {\n                 sess.fatal(&format!(\"could not find rlib for: `{}`\", name));\n             }\n         };\n@@ -326,7 +328,6 @@ fn link_binary_output(sess: &Session,\n                       outputs: &OutputFilenames,\n                       crate_name: &str) -> PathBuf {\n     let objects = object_filenames(trans, outputs);\n-    println!(\"objects: {:?}\", objects);\n     let default_filename = filename_for_input(sess, crate_type, crate_name,\n                                               outputs);\n     let out_filename = outputs.outputs.get(&OutputType::Exe)"}, {"sha": "ccaa0d4e1b1b059de8214d48454ea049d7897eac", "filename": "src/librustc_trans/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_trans%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_trans%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Frpath.rs?ref=534556a445743d605cba8dc552c732ff1eb7d925", "patch": "@@ -14,9 +14,10 @@ use std::path::{Path, PathBuf};\n use std::fs;\n \n use rustc::hir::def_id::CrateNum;\n+use rustc::middle::cstore::LibSource;\n \n pub struct RPathConfig<'a> {\n-    pub used_crates: Vec<(CrateNum, Option<PathBuf>)>,\n+    pub used_crates: Vec<(CrateNum, LibSource)>,\n     pub out_filename: PathBuf,\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n@@ -35,7 +36,7 @@ pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n     debug!(\"preparing the RPATH!\");\n \n     let libs = config.used_crates.clone();\n-    let libs = libs.into_iter().filter_map(|(_, l)| l).collect::<Vec<_>>();\n+    let libs = libs.into_iter().filter_map(|(_, l)| l.option()).collect::<Vec<_>>();\n     let rpaths = get_rpaths(config, &libs[..]);\n     flags.extend_from_slice(&rpaths_to_flags(&rpaths[..]));\n "}, {"sha": "c006eb9156b6cc03f63e9752cbd2f28d3709c077", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534556a445743d605cba8dc552c732ff1eb7d925/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=534556a445743d605cba8dc552c732ff1eb7d925", "patch": "@@ -45,7 +45,7 @@ use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::dep_graph::{DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n-use session::config::{self, NoDebugInfo, OutputType};\n+use session::config::{self, NoDebugInfo};\n use rustc_incremental::IncrementalHashesMap;\n use session::Session;\n use abi::{self, Abi, FnType};"}]}