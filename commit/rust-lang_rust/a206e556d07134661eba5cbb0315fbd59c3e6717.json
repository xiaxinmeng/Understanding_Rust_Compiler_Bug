{"sha": "a206e556d07134661eba5cbb0315fbd59c3e6717", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMDZlNTU2ZDA3MTM0NjYxZWJhNWNiYjAzMTVmYmQ1OWMzZTY3MTc=", "commit": {"author": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2015-12-17T23:36:38Z"}, "committer": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2015-12-18T20:49:20Z"}, "message": "Use memrchr bindings provided by libc", "tree": {"sha": "f52e5cc4b9d2f62e082ae847191285d6b3eaf9a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f52e5cc4b9d2f62e082ae847191285d6b3eaf9a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a206e556d07134661eba5cbb0315fbd59c3e6717", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a206e556d07134661eba5cbb0315fbd59c3e6717", "html_url": "https://github.com/rust-lang/rust/commit/a206e556d07134661eba5cbb0315fbd59c3e6717", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a206e556d07134661eba5cbb0315fbd59c3e6717/comments", "author": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa1f8fd3fb6b4e5334130eb5570cea18d2c13761", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1f8fd3fb6b4e5334130eb5570cea18d2c13761", "html_url": "https://github.com/rust-lang/rust/commit/aa1f8fd3fb6b4e5334130eb5570cea18d2c13761"}], "stats": {"total": 44, "additions": 15, "deletions": 29}, "files": [{"sha": "c654efd499b6410f7d9b9679b9471392bbe18f85", "filename": "src/libstd/memchr.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a206e556d07134661eba5cbb0315fbd59c3e6717/src%2Flibstd%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a206e556d07134661eba5cbb0315fbd59c3e6717/src%2Flibstd%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmemchr.rs?ref=a206e556d07134661eba5cbb0315fbd59c3e6717", "patch": "@@ -11,7 +11,6 @@\n // Original implementation taken from rust-memchr\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n-use libc::{c_void, c_int, size_t};\n \n \n /// A safe interface to `memchr`.\n@@ -27,25 +26,23 @@ use libc::{c_void, c_int, size_t};\n ///\n /// This shows how to find the first position of a byte in a byte string.\n ///\n-/// ```rust\n+/// ```rust,ignore\n /// use memchr::memchr;\n ///\n /// let haystack = b\"the quick brown fox\";\n /// assert_eq!(memchr(b'k', haystack), Some(8));\n /// ```\n pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n     // libc memchr\n-    #[cfg(any(not(target_os = \"windows\"),\n-              not(any(target_pointer_width = \"32\",\n-                      target_pointer_width = \"64\"))))]\n+    #[cfg(not(target_os = \"windows\"))]\n     fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        use libc::memchr as libc_memchr;\n+        use libc;\n \n         let p = unsafe {\n-            libc_memchr(\n-                haystack.as_ptr() as *const c_void,\n-                needle as c_int,\n-                haystack.len() as size_t)\n+            libc::memchr(\n+                haystack.as_ptr() as *const libc::c_void,\n+                needle as libc::c_int,\n+                haystack.len() as libc::size_t)\n         };\n         if p.is_null() {\n             None\n@@ -55,9 +52,7 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n     }\n \n     // use fallback on windows, since it's faster\n-    #[cfg(all(target_os = \"windows\",\n-              any(target_pointer_width = \"32\",\n-                  target_pointer_width = \"64\")))]\n+    #[cfg(target_os = \"windows\")]\n     fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n         fallback::memchr(needle, haystack)\n     }\n@@ -74,7 +69,7 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n ///\n /// This shows how to find the last position of a byte in a byte string.\n ///\n-/// ```rust\n+/// ```rust,ignore\n /// use memchr::memrchr;\n ///\n /// let haystack = b\"the quick brown fox\";\n@@ -84,15 +79,15 @@ pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n \n     #[cfg(target_os = \"linux\")]\n     fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        use libc::memrchr as libc_memrchr;\n+        use libc;\n \n         // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n         if haystack.is_empty() {return None}\n         let p = unsafe {\n-            libc_memrchr(\n-                haystack.as_ptr() as *const c_void,\n-                needle as c_int,\n-                haystack.len() as size_t)\n+            libc::memrchr(\n+                haystack.as_ptr() as *const libc::c_void,\n+                needle as libc::c_int,\n+                haystack.len() as libc::size_t)\n         };\n         if p.is_null() {\n             None\n@@ -101,16 +96,7 @@ pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n         }\n     }\n \n-    #[cfg(all(not(target_os = \"linux\"),\n-              any(target_pointer_width = \"32\", target_pointer_width = \"64\")))]\n-    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        fallback::memrchr(needle, haystack)\n-    }\n-\n-    // For the rare case of neither 32 bit nor 64-bit platform.\n-    #[cfg(all(not(target_os = \"linux\"),\n-              not(target_pointer_width = \"32\"),\n-              not(target_pointer_width = \"64\")))]\n+    #[cfg(not(target_os = \"linux\"))]\n     fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n         haystack.iter().rposition(|&b| b == needle)\n     }"}]}