{"sha": "aa0189170057a6b56f445f05b9840caf6f260212", "node_id": "C_kwDOAAsO6NoAKGFhMDE4OTE3MDA1N2E2YjU2ZjQ0NWYwNWI5ODQwY2FmNmYyNjAyMTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-22T01:33:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-22T01:33:49Z"}, "message": "Auto merge of #99420 - RalfJung:vtable, r=oli-obk\n\nmake vtable pointers entirely opaque\n\nThis implements the scheme discussed in https://github.com/rust-lang/unsafe-code-guidelines/issues/338: vtable pointers should be considered entirely opaque and not even readable by Rust code, similar to function pointers.\n\n- We have a new kind of `GlobalAlloc` that symbolically refers to a vtable.\n- Miri uses that kind of allocation when generating a vtable.\n- The codegen backends, upon encountering such an allocation, call `vtable_allocation` to obtain an actually dataful allocation for this vtable.\n- We need new intrinsics to obtain the size and align from a vtable (for some `ptr::metadata` APIs), since direct accesses are UB now.\n\nI had to touch quite a bit of code that I am not very familiar with, so some of this might not make much sense...\nr? `@oli-obk`", "tree": {"sha": "44b90133d775da8a57ad4a5d8a5464e1329125c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44b90133d775da8a57ad4a5d8a5464e1329125c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa0189170057a6b56f445f05b9840caf6f260212", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa0189170057a6b56f445f05b9840caf6f260212", "html_url": "https://github.com/rust-lang/rust/commit/aa0189170057a6b56f445f05b9840caf6f260212", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa0189170057a6b56f445f05b9840caf6f260212/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31b9b012bbced0c47a0ff5e4453cdc2e91e668b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/31b9b012bbced0c47a0ff5e4453cdc2e91e668b2", "html_url": "https://github.com/rust-lang/rust/commit/31b9b012bbced0c47a0ff5e4453cdc2e91e668b2"}, {"sha": "d46dfa25d46be353a0cda39373e0319eb4f3ec69", "url": "https://api.github.com/repos/rust-lang/rust/commits/d46dfa25d46be353a0cda39373e0319eb4f3ec69", "html_url": "https://github.com/rust-lang/rust/commit/d46dfa25d46be353a0cda39373e0319eb4f3ec69"}], "stats": {"total": 1200, "additions": 673, "deletions": 527}, "files": [{"sha": "94a2fb2fbddc298da7efde1311b555785bcda11a", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -195,9 +195,8 @@ pub(crate) fn codegen_const_value<'tcx>(\n             }\n             Scalar::Ptr(ptr, _size) => {\n                 let (alloc_id, offset) = ptr.into_parts(); // we know the `offset` is relative\n-                let alloc_kind = fx.tcx.get_global_alloc(alloc_id);\n-                let base_addr = match alloc_kind {\n-                    Some(GlobalAlloc::Memory(alloc)) => {\n+                let base_addr = match fx.tcx.global_alloc(alloc_id) {\n+                    GlobalAlloc::Memory(alloc) => {\n                         let data_id = data_id_for_alloc_id(\n                             &mut fx.constants_cx,\n                             fx.module,\n@@ -211,13 +210,27 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         }\n                         fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                     }\n-                    Some(GlobalAlloc::Function(instance)) => {\n+                    GlobalAlloc::Function(instance) => {\n                         let func_id = crate::abi::import_function(fx.tcx, fx.module, instance);\n                         let local_func_id =\n                             fx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                         fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                     }\n-                    Some(GlobalAlloc::Static(def_id)) => {\n+                    GlobalAlloc::VTable(ty, trait_ref) => {\n+                        let alloc_id = fx.tcx.vtable_allocation((ty, trait_ref));\n+                        let alloc = fx.tcx.global_alloc(alloc_id).unwrap_memory();\n+                        // FIXME: factor this common code with the `Memory` arm into a function?\n+                        let data_id = data_id_for_alloc_id(\n+                            &mut fx.constants_cx,\n+                            fx.module,\n+                            alloc_id,\n+                            alloc.inner().mutability,\n+                        );\n+                        let local_data_id =\n+                            fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                        fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n+                    }\n+                    GlobalAlloc::Static(def_id) => {\n                         assert!(fx.tcx.is_static(def_id));\n                         let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n                         let local_data_id =\n@@ -227,7 +240,6 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         }\n                         fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                     }\n-                    None => bug!(\"missing allocation {:?}\", alloc_id),\n                 };\n                 let val = if offset.bytes() != 0 {\n                     fx.bcx.ins().iadd_imm(base_addr, i64::try_from(offset.bytes()).unwrap())\n@@ -357,10 +369,11 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n     while let Some(todo_item) = cx.todo.pop() {\n         let (data_id, alloc, section_name) = match todo_item {\n             TodoItem::Alloc(alloc_id) => {\n-                //println!(\"alloc_id {}\", alloc_id);\n-                let alloc = match tcx.get_global_alloc(alloc_id).unwrap() {\n+                let alloc = match tcx.global_alloc(alloc_id) {\n                     GlobalAlloc::Memory(alloc) => alloc,\n-                    GlobalAlloc::Function(_) | GlobalAlloc::Static(_) => unreachable!(),\n+                    GlobalAlloc::Function(_) | GlobalAlloc::Static(_) | GlobalAlloc::VTable(..) => {\n+                        unreachable!()\n+                    }\n                 };\n                 let data_id = *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n                     module\n@@ -424,7 +437,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 read_target_uint(endianness, bytes).unwrap()\n             };\n \n-            let reloc_target_alloc = tcx.get_global_alloc(alloc_id).unwrap();\n+            let reloc_target_alloc = tcx.global_alloc(alloc_id);\n             let data_id = match reloc_target_alloc {\n                 GlobalAlloc::Function(instance) => {\n                     assert_eq!(addend, 0);\n@@ -436,6 +449,10 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 GlobalAlloc::Memory(target_alloc) => {\n                     data_id_for_alloc_id(cx, module, alloc_id, target_alloc.inner().mutability)\n                 }\n+                GlobalAlloc::VTable(ty, trait_ref) => {\n+                    let alloc_id = tcx.vtable_allocation((ty, trait_ref));\n+                    data_id_for_alloc_id(cx, module, alloc_id, Mutability::Not)\n+                }\n                 GlobalAlloc::Static(def_id) => {\n                     if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n                     {"}, {"sha": "d5a79e254a891eb90d141d5635ee4281678ca3ba", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -431,6 +431,16 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, CValue::by_val(align, usize_layout));\n         };\n \n+        vtable_size, (v vtable) {\n+            let size = crate::vtable::size_of_obj(fx, vtable);\n+            ret.write_cvalue(fx, CValue::by_val(size, usize_layout));\n+        };\n+\n+        vtable_align, (v vtable) {\n+            let align = crate::vtable::min_align_of_obj(fx, vtable);\n+            ret.write_cvalue(fx, CValue::by_val(align, usize_layout));\n+        };\n+\n         unchecked_add | unchecked_sub | unchecked_mul | unchecked_div | exact_div | unchecked_rem\n         | unchecked_shl | unchecked_shr, (c x, c y) {\n             // FIXME trap on overflow"}, {"sha": "ccb6cbbc2c8a74bb98ab5a977c8698dea5b7c769", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -201,6 +201,11 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                         GlobalAlloc::Function(fn_instance) => {\n                             self.get_fn_addr(fn_instance)\n                         },\n+                        GlobalAlloc::VTable(ty, trait_ref) => {\n+                            let alloc = self.tcx.global_alloc(self.tcx.vtable_allocation((ty, trait_ref))).unwrap_memory();\n+                            let init = const_alloc_to_gcc(self, alloc);\n+                            self.static_addr_of(init, alloc.inner().align, None)\n+                        }\n                         GlobalAlloc::Static(def_id) => {\n                             assert!(self.tcx.is_static(def_id));\n                             self.get_static(def_id).get_address(None)"}, {"sha": "fb4da9a5f33705bacfba08fbb3b2a968e77ac903", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -257,6 +257,15 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         self.get_fn_addr(fn_instance.polymorphize(self.tcx)),\n                         self.data_layout().instruction_address_space,\n                     ),\n+                    GlobalAlloc::VTable(ty, trait_ref) => {\n+                        let alloc = self\n+                            .tcx\n+                            .global_alloc(self.tcx.vtable_allocation((ty, trait_ref)))\n+                            .unwrap_memory();\n+                        let init = const_alloc_to_llvm(self, alloc);\n+                        let value = self.static_addr_of(init, alloc.inner().align, None);\n+                        (value, AddressSpace::DATA)\n+                    }\n                     GlobalAlloc::Static(def_id) => {\n                         assert!(self.tcx.is_static(def_id));\n                         assert!(!self.tcx.is_thread_local_static(def_id));"}, {"sha": "18467e37082d696f0c46a894937dcb49c5f065cd", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -101,7 +101,9 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n \n         let address_space = match cx.tcx.global_alloc(alloc_id) {\n             GlobalAlloc::Function(..) => cx.data_layout().instruction_address_space,\n-            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) => AddressSpace::DATA,\n+            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) | GlobalAlloc::VTable(..) => {\n+                AddressSpace::DATA\n+            }\n         };\n \n         llvals.push(cx.scalar_to_backend("}, {"sha": "bd84100e0e883797d0ccaf4594c1d17a66260401", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -1420,7 +1420,7 @@ fn build_vtable_type_di_node<'ll, 'tcx>(\n         cx,\n         type_map::stub(\n             cx,\n-            Stub::VtableTy { vtable_holder },\n+            Stub::VTableTy { vtable_holder },\n             unique_type_id,\n             &vtable_type_name,\n             (size, pointer_align),"}, {"sha": "ce2f419c4acdc64bf963a8a3796d4cf9929a1c07", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/type_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -146,7 +146,7 @@ impl<'ll> DINodeCreationResult<'ll> {\n pub enum Stub<'ll> {\n     Struct,\n     Union,\n-    VtableTy { vtable_holder: &'ll DIType },\n+    VTableTy { vtable_holder: &'ll DIType },\n }\n \n pub struct StubInfo<'ll, 'tcx> {\n@@ -180,9 +180,9 @@ pub(super) fn stub<'ll, 'tcx>(\n     let unique_type_id_str = unique_type_id.generate_unique_id_string(cx.tcx);\n \n     let metadata = match kind {\n-        Stub::Struct | Stub::VtableTy { .. } => {\n+        Stub::Struct | Stub::VTableTy { .. } => {\n             let vtable_holder = match kind {\n-                Stub::VtableTy { vtable_holder } => Some(vtable_holder),\n+                Stub::VTableTy { vtable_holder } => Some(vtable_holder),\n                 _ => None,\n             };\n             unsafe {"}, {"sha": "d95194e320be1c18ba9da65138163539ab0d21dd", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -171,7 +171,7 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 );\n                 let new_vptr = bx.load(ptr_ty, gep, ptr_align);\n                 bx.nonnull_metadata(new_vptr);\n-                // Vtable loads are invariant.\n+                // VTable loads are invariant.\n                 bx.set_invariant_load(new_vptr);\n                 new_vptr\n             } else {"}, {"sha": "27d791d90a51aed975810fb20486f932fa068179", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> VirtualIndex {\n             let gep = bx.inbounds_gep(llty, llvtable, &[bx.const_usize(self.0)]);\n             let ptr = bx.load(llty, gep, ptr_align);\n             bx.nonnull_metadata(ptr);\n-            // Vtable loads are invariant.\n+            // VTable loads are invariant.\n             bx.set_invariant_load(ptr);\n             ptr\n         }\n@@ -58,7 +58,7 @@ impl<'a, 'tcx> VirtualIndex {\n         let usize_align = bx.tcx().data_layout.pointer_align.abi;\n         let gep = bx.inbounds_gep(llty, llvtable, &[bx.const_usize(self.0)]);\n         let ptr = bx.load(llty, gep, usize_align);\n-        // Vtable loads are invariant.\n+        // VTable loads are invariant.\n         bx.set_invariant_load(ptr);\n         ptr\n     }"}, {"sha": "94ac71a4dd26366df67b981c1c6d7589fe9c982e", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -3,12 +3,16 @@ use super::place::PlaceRef;\n use super::FunctionCx;\n use crate::common::{span_invalid_monomorphization_error, IntPredicate};\n use crate::glue;\n+use crate::meth;\n use crate::traits::*;\n use crate::MemFlags;\n \n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::{sym, Span};\n-use rustc_target::abi::call::{FnAbi, PassMode};\n+use rustc_target::abi::{\n+    call::{FnAbi, PassMode},\n+    WrappingRange,\n+};\n \n fn copy_intrinsic<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n@@ -102,6 +106,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     bx.const_usize(bx.layout_of(tp_ty).align.abi.bytes())\n                 }\n             }\n+            sym::vtable_size | sym::vtable_align => {\n+                let vtable = args[0].immediate();\n+                let idx = match name {\n+                    sym::vtable_size => ty::COMMON_VTABLE_ENTRIES_SIZE,\n+                    sym::vtable_align => ty::COMMON_VTABLE_ENTRIES_ALIGN,\n+                    _ => bug!(),\n+                };\n+                let value = meth::VirtualIndex::from_index(idx).get_usize(bx, vtable);\n+                if name == sym::vtable_align {\n+                    // Alignment is always nonzero.\n+                    bx.range_metadata(value, WrappingRange { start: 1, end: !0 });\n+                };\n+                value\n+            }\n             sym::pref_align_of\n             | sym::needs_drop\n             | sym::type_id"}, {"sha": "fc2e6652a3d72267811bf589cec5aa9fd18df404", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -369,7 +369,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 // we don't deallocate it.\n                 let (alloc_id, _, _) = ecx.ptr_get_alloc_id(ptr)?;\n                 let is_allocated_in_another_const = matches!(\n-                    ecx.tcx.get_global_alloc(alloc_id),\n+                    ecx.tcx.try_get_global_alloc(alloc_id),\n                     Some(interpret::GlobalAlloc::Memory(_))\n                 );\n "}, {"sha": "948c33494982612b87deff77f037e21879caabdd", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -138,7 +138,7 @@ pub(crate) fn deref_mir_constant<'tcx>(\n     let mplace = ecx.deref_operand(&op).unwrap();\n     if let Some(alloc_id) = mplace.ptr.provenance {\n         assert_eq!(\n-            tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().0.0.mutability,\n+            tcx.global_alloc(alloc_id).unwrap_memory().0.0.mutability,\n             Mutability::Not,\n             \"deref_mir_constant cannot be used with mutable allocations as \\\n             that could allow pattern matching to observe mutable statics\","}, {"sha": "883387851eaf0234db6ec5abfc736b89d67b39a5", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -298,30 +298,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_immediate(val, dest)\n             }\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n-                let val = self.read_immediate(src)?;\n-                if data_a.principal_def_id() == data_b.principal_def_id() {\n-                    return self.write_immediate(*val, dest);\n-                }\n-                // trait upcasting coercion\n-                let vptr_entry_idx = self.tcx.vtable_trait_upcasting_coercion_new_vptr_slot((\n-                    src_pointee_ty,\n-                    dest_pointee_ty,\n-                ));\n-\n-                if let Some(entry_idx) = vptr_entry_idx {\n-                    let entry_idx = u64::try_from(entry_idx).unwrap();\n-                    let (old_data, old_vptr) = val.to_scalar_pair()?;\n-                    let old_vptr = self.scalar_to_ptr(old_vptr)?;\n-                    let new_vptr = self\n-                        .read_new_vtable_after_trait_upcasting_from_vtable(old_vptr, entry_idx)?;\n-                    self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)\n-                } else {\n-                    self.write_immediate(*val, dest)\n+                let (old_data, old_vptr) = self.read_immediate(src)?.to_scalar_pair()?;\n+                let old_vptr = self.scalar_to_ptr(old_vptr)?;\n+                let (ty, old_trait) = self.get_ptr_vtable(old_vptr)?;\n+                if old_trait != data_a.principal() {\n+                    throw_ub_format!(\"upcast on a pointer whose vtable does not match its type\");\n                 }\n+                let new_vptr = self.get_vtable_ptr(ty, data_b.principal())?;\n+                self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)\n             }\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n-                let vtable = self.get_vtable(src_pointee_ty, data.principal())?;\n+                let vtable = self.get_vtable_ptr(src_pointee_ty, data.principal())?;\n                 let ptr = self.read_immediate(src)?.to_scalar()?;\n                 let val = Immediate::new_dyn_trait(ptr, vtable, &*self.tcx);\n                 self.write_immediate(val, dest)"}, {"sha": "fdf243c4108d31bb4afa0329428a27444bff8e37", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -631,7 +631,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::Dynamic(..) => {\n                 let vtable = self.scalar_to_ptr(metadata.unwrap_meta())?;\n                 // Read size and align from vtable (already checks size).\n-                Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n+                Ok(Some(self.get_vtable_size_and_align(vtable)?))\n             }\n \n             ty::Slice(_) | ty::Str => {"}, {"sha": "23526edcc343aa92bf2138743066f45225a84aa2", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -94,7 +94,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n         // to validation to error -- it has the much better error messages, pointing out where\n         // in the value the dangling reference lies.\n         // The `delay_span_bug` ensures that we don't forget such a check in validation.\n-        if tcx.get_global_alloc(alloc_id).is_none() {\n+        if tcx.try_get_global_alloc(alloc_id).is_none() {\n             tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n         }\n         // treat dangling pointers like other statics\n@@ -454,7 +454,7 @@ pub fn intern_const_alloc_recursive<\n                 .sess\n                 .span_err(ecx.tcx.span, \"encountered dangling pointer in final constant\");\n             return Err(reported);\n-        } else if ecx.tcx.get_global_alloc(alloc_id).is_none() {\n+        } else if ecx.tcx.try_get_global_alloc(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't\n             // marked as dangling by local memory.  That should be impossible.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);"}, {"sha": "025f8647c95b554438155445e7b9fd55cb63ef05", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -492,6 +492,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let result = self.raw_eq_intrinsic(&args[0], &args[1])?;\n                 self.write_scalar(result, dest)?;\n             }\n+\n+            sym::vtable_size => {\n+                let ptr = self.read_pointer(&args[0])?;\n+                let (size, _align) = self.get_vtable_size_and_align(ptr)?;\n+                self.write_scalar(Scalar::from_machine_usize(size.bytes(), self), dest)?;\n+            }\n+            sym::vtable_align => {\n+                let ptr = self.read_pointer(&args[0])?;\n+                let (_size, align) = self.get_vtable_size_and_align(ptr)?;\n+                self.write_scalar(Scalar::from_machine_usize(align.bytes(), self), dest)?;\n+            }\n+\n             _ => return Ok(false),\n         }\n "}, {"sha": "86914f50383e800f5c38aaddcac7149849f11ffd", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -16,7 +16,7 @@ use std::ptr;\n use rustc_ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::mir::display_allocation;\n-use rustc_middle::ty::{Instance, ParamEnv, TyCtxt};\n+use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n@@ -62,6 +62,8 @@ pub enum AllocKind {\n     LiveData,\n     /// A function allocation (that fn ptrs point to).\n     Function,\n+    /// A (symbolic) vtable allocation.\n+    VTable,\n     /// A dead allocation.\n     Dead,\n }\n@@ -159,7 +161,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let alloc_id = ptr.provenance;\n         // We need to handle `extern static`.\n-        match self.tcx.get_global_alloc(alloc_id) {\n+        match self.tcx.try_get_global_alloc(alloc_id) {\n             Some(GlobalAlloc::Static(def_id)) if self.tcx.is_thread_local_static(def_id) => {\n                 bug!(\"global memory cannot point to thread-local static\")\n             }\n@@ -287,10 +289,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let Some((alloc_kind, mut alloc)) = self.memory.alloc_map.remove(&alloc_id) else {\n             // Deallocating global memory -- always an error\n-            return Err(match self.tcx.get_global_alloc(alloc_id) {\n+            return Err(match self.tcx.try_get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Function(..)) => {\n                     err_ub_format!(\"deallocating {alloc_id:?}, which is a function\")\n                 }\n+                Some(GlobalAlloc::VTable(..)) => {\n+                    err_ub_format!(\"deallocating {alloc_id:?}, which is a vtable\")\n+                }\n                 Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n                     err_ub_format!(\"deallocating {alloc_id:?}, which is static memory\")\n                 }\n@@ -473,12 +478,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::Provenance, M::AllocExtra>>> {\n-        let (alloc, def_id) = match self.tcx.get_global_alloc(id) {\n+        let (alloc, def_id) = match self.tcx.try_get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n                 (mem, None)\n             }\n             Some(GlobalAlloc::Function(..)) => throw_ub!(DerefFunctionPointer(id)),\n+            Some(GlobalAlloc::VTable(..)) => throw_ub!(DerefVTablePointer(id)),\n             None => throw_ub!(PointerUseAfterFree(id)),\n             Some(GlobalAlloc::Static(def_id)) => {\n                 assert!(self.tcx.is_static(def_id));\n@@ -494,6 +500,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // contains a reference to memory that was created during its evaluation (i.e., not\n                 // to another static), those inner references only exist in \"resolved\" form.\n                 if self.tcx.is_foreign_item(def_id) {\n+                    // This is unreachable in Miri, but can happen in CTFE where we actually *do* support\n+                    // referencing arbitrary (declared) extern statics.\n                     throw_unsup!(ReadExternStatic(def_id));\n                 }\n \n@@ -663,12 +671,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // # Statics\n         // Can't do this in the match argument, we may get cycle errors since the lock would\n         // be held throughout the match.\n-        match self.tcx.get_global_alloc(id) {\n-            Some(GlobalAlloc::Static(did)) => {\n-                assert!(!self.tcx.is_thread_local_static(did));\n+        match self.tcx.try_get_global_alloc(id) {\n+            Some(GlobalAlloc::Static(def_id)) => {\n+                assert!(self.tcx.is_static(def_id));\n+                assert!(!self.tcx.is_thread_local_static(def_id));\n                 // Use size and align of the type.\n-                let ty = self.tcx.type_of(did);\n+                let ty = self.tcx.type_of(def_id);\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+                assert!(!layout.is_unsized());\n                 (layout.size, layout.align.abi, AllocKind::LiveData)\n             }\n             Some(GlobalAlloc::Memory(alloc)) => {\n@@ -678,6 +688,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 (alloc.size(), alloc.align, AllocKind::LiveData)\n             }\n             Some(GlobalAlloc::Function(_)) => bug!(\"We already checked function pointers above\"),\n+            Some(GlobalAlloc::VTable(..)) => {\n+                // No data to be accessed here. But vtables are pointer-aligned.\n+                return (Size::ZERO, self.tcx.data_layout.pointer_align.abi, AllocKind::VTable);\n+            }\n             // The rest must be dead.\n             None => {\n                 // Deallocated pointers are allowed, we should be able to find\n@@ -705,7 +719,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         if let Some(extra) = self.memory.extra_fn_ptr_map.get(&id) {\n             Some(FnVal::Other(*extra))\n         } else {\n-            match self.tcx.get_global_alloc(id) {\n+            match self.tcx.try_get_global_alloc(id) {\n                 Some(GlobalAlloc::Function(instance)) => Some(FnVal::Instance(instance)),\n                 _ => None,\n             }\n@@ -716,7 +730,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<Option<M::Provenance>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n-        trace!(\"get_fn({:?})\", ptr);\n+        trace!(\"get_ptr_fn({:?})\", ptr);\n         let (alloc_id, offset, _prov) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset)))\n@@ -725,6 +739,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .ok_or_else(|| err_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset))).into())\n     }\n \n+    pub fn get_ptr_vtable(\n+        &self,\n+        ptr: Pointer<Option<M::Provenance>>,\n+    ) -> InterpResult<'tcx, (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>)> {\n+        trace!(\"get_ptr_vtable({:?})\", ptr);\n+        let (alloc_id, offset, _tag) = self.ptr_get_alloc_id(ptr)?;\n+        if offset.bytes() != 0 {\n+            throw_ub!(InvalidVTablePointer(Pointer::new(alloc_id, offset)))\n+        }\n+        match self.tcx.try_get_global_alloc(alloc_id) {\n+            Some(GlobalAlloc::VTable(ty, trait_ref)) => Ok((ty, trait_ref)),\n+            _ => throw_ub!(InvalidVTablePointer(Pointer::new(alloc_id, offset))),\n+        }\n+    }\n+\n     pub fn alloc_mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n         self.get_alloc_raw_mut(id)?.0.mutability = Mutability::Not;\n         Ok(())\n@@ -829,7 +858,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n                 }\n                 None => {\n                     // global alloc\n-                    match self.ecx.tcx.get_global_alloc(id) {\n+                    match self.ecx.tcx.try_get_global_alloc(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             write!(fmt, \" (unchanged global, \")?;\n                             write_allocation_track_relocs(\n@@ -840,7 +869,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n                             )?;\n                         }\n                         Some(GlobalAlloc::Function(func)) => {\n-                            write!(fmt, \" (fn: {})\", func)?;\n+                            write!(fmt, \" (fn: {func})\")?;\n+                        }\n+                        Some(GlobalAlloc::VTable(ty, Some(trait_ref))) => {\n+                            write!(fmt, \" (vtable: impl {trait_ref} for {ty})\")?;\n+                        }\n+                        Some(GlobalAlloc::VTable(ty, None)) => {\n+                            write!(fmt, \" (vtable: impl <auto trait> for {ty})\")?;\n                         }\n                         Some(GlobalAlloc::Static(did)) => {\n                             write!(fmt, \" (static: {})\", self.ecx.tcx.def_path_str(did))?;"}, {"sha": "c7d8a744f7c09878c158e254a9a25d777ee25582", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -885,28 +885,19 @@ where\n     }\n \n     /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type.\n-    /// Also return some more information so drop doesn't have to run the same code twice.\n     pub(super) fn unpack_dyn_trait(\n         &self,\n         mplace: &MPlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::Provenance>)> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         let vtable = self.scalar_to_ptr(mplace.vtable())?; // also sanity checks the type\n-        let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n+        let (ty, _) = self.get_ptr_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n \n-        // More sanity checks\n-        if cfg!(debug_assertions) {\n-            let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n-            assert_eq!(size, layout.size);\n-            // only ABI alignment is preserved\n-            assert_eq!(align, layout.align.abi);\n-        }\n-\n         let mplace = MPlaceTy {\n             mplace: MemPlace { meta: MemPlaceMeta::None, ..**mplace },\n             layout,\n             align: layout.align.abi,\n         };\n-        Ok((instance, mplace))\n+        Ok(mplace)\n     }\n }"}, {"sha": "e7e60b5fa236220cb47d9293efe8a38e5cf37fbf", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -1,5 +1,4 @@\n use std::borrow::Cow;\n-use std::convert::TryFrom;\n \n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n use rustc_middle::ty::Instance;\n@@ -365,7 +364,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // caller_fn_abi is not relevant here, we interpret the arguments directly for each intrinsic.\n                 M::call_intrinsic(self, instance, args, destination, target, unwind)\n             }\n-            ty::InstanceDef::VtableShim(..)\n+            ty::InstanceDef::VTableShim(..)\n             | ty::InstanceDef::ReifyShim(..)\n             | ty::InstanceDef::ClosureOnceShim { .. }\n             | ty::InstanceDef::FnPtrShim(..)\n@@ -520,7 +519,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n             // cannot use the shim here, because that will only result in infinite recursion\n-            ty::InstanceDef::Virtual(_, idx) => {\n+            ty::InstanceDef::Virtual(def_id, idx) => {\n                 let mut args = args.to_vec();\n                 // We have to implement all \"object safe receivers\". So we have to go search for a\n                 // pointer or `dyn Trait` type, but it could be wrapped in newtypes. So recursively\n@@ -553,17 +552,53 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         }\n                     }\n                 };\n-                // Find and consult vtable. The type now could be something like RcBox<dyn Trait>,\n-                // i.e., it is still not necessarily `ty::Dynamic` (so we cannot use\n-                // `place.vtable()`), but it should have a `dyn Trait` tail.\n-                assert!(matches!(\n-                    self.tcx\n-                        .struct_tail_erasing_lifetimes(receiver_place.layout.ty, self.param_env)\n-                        .kind(),\n-                    ty::Dynamic(..)\n-                ));\n-                let vtable = self.scalar_to_ptr(receiver_place.meta.unwrap_meta())?;\n-                let fn_val = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n+                // Obtain the underlying trait we are working on.\n+                let receiver_tail = self\n+                    .tcx\n+                    .struct_tail_erasing_lifetimes(receiver_place.layout.ty, self.param_env);\n+                let ty::Dynamic(data, ..) = receiver_tail.kind() else {\n+                    span_bug!(self.cur_span(), \"dyanmic call on non-`dyn` type {}\", receiver_tail)\n+                };\n+\n+                // Get the required information from the vtable.\n+                let vptr = self.scalar_to_ptr(receiver_place.meta.unwrap_meta())?;\n+                let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n+                if dyn_trait != data.principal() {\n+                    throw_ub_format!(\n+                        \"`dyn` call on a pointer whose vtable does not match its type\"\n+                    );\n+                }\n+\n+                // Now determine the actual method to call. We can do that in two different ways and\n+                // compare them to ensure everything fits.\n+                let ty::VtblEntry::Method(fn_inst) = self.get_vtable_entries(vptr)?[idx] else {\n+                    span_bug!(self.cur_span(), \"dyn call index points at something that is not a method\")\n+                };\n+                if cfg!(debug_assertions) {\n+                    let tcx = *self.tcx;\n+\n+                    let trait_def_id = tcx.trait_of_item(def_id).unwrap();\n+                    let virtual_trait_ref =\n+                        ty::TraitRef::from_method(tcx, trait_def_id, instance.substs);\n+                    assert_eq!(\n+                        receiver_tail,\n+                        virtual_trait_ref.self_ty(),\n+                        \"mismatch in underlying dyn trait computation within Miri and MIR building\",\n+                    );\n+                    let existential_trait_ref =\n+                        ty::ExistentialTraitRef::erase_self_ty(tcx, virtual_trait_ref);\n+                    let concrete_trait_ref = existential_trait_ref.with_self_ty(tcx, dyn_ty);\n+\n+                    let concrete_method = Instance::resolve(\n+                        tcx,\n+                        self.param_env,\n+                        def_id,\n+                        instance.substs.rebase_onto(tcx, trait_def_id, concrete_trait_ref.substs),\n+                    )\n+                    .unwrap()\n+                    .unwrap();\n+                    assert_eq!(fn_inst, concrete_method);\n+                }\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want\n@@ -579,7 +614,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 trace!(\"Patched receiver operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(\n-                    fn_val,\n+                    FnVal::Instance(fn_inst),\n                     (caller_abi, caller_fn_abi),\n                     &args,\n                     with_caller_location,\n@@ -606,8 +641,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let (instance, place) = match place.layout.ty.kind() {\n             ty::Dynamic(..) => {\n-                // Dropping a trait object.\n-                self.unpack_dyn_trait(&place)?\n+                // Dropping a trait object. Need to find actual drop fn.\n+                let place = self.unpack_dyn_trait(&place)?;\n+                let instance = ty::Instance::resolve_drop_in_place(*self.tcx, place.layout.ty);\n+                (instance, place)\n             }\n             _ => (instance, place),\n         };"}, {"sha": "b3a511d5a492bdd146f3e36cda800d14a3fd032e", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 28, "deletions": 112, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -1,24 +1,21 @@\n-use std::convert::TryFrom;\n-\n-use rustc_middle::mir::interpret::{alloc_range, InterpResult, Pointer, PointerArithmetic};\n-use rustc_middle::ty::{\n-    self, Ty, TyCtxt, COMMON_VTABLE_ENTRIES_ALIGN, COMMON_VTABLE_ENTRIES_DROPINPLACE,\n-    COMMON_VTABLE_ENTRIES_SIZE,\n-};\n+use rustc_middle::mir::interpret::{InterpResult, Pointer};\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_target::abi::{Align, Size};\n \n use super::util::ensure_monomorphic_enough;\n-use super::{FnVal, InterpCx, Machine};\n+use super::{InterpCx, Machine};\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///\n-    /// The `trait_ref` encodes the erased self type. Hence, if we are\n-    /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n-    /// `trait_ref` would map `T: Trait`.\n-    pub fn get_vtable(\n-        &mut self,\n+    /// The `trait_ref` encodes the erased self type. Hence, if we are making an object `Foo<Trait>`\n+    /// from a value of type `Foo<T>`, then `trait_ref` would map `T: Trait`. `None` here means that\n+    /// this is an auto trait without any methods, so we only need the basic vtable (drop, size,\n+    /// align).\n+    pub fn get_vtable_ptr(\n+        &self,\n         ty: Ty<'tcx>,\n         poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n     ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n@@ -30,114 +27,33 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ensure_monomorphic_enough(*self.tcx, ty)?;\n         ensure_monomorphic_enough(*self.tcx, poly_trait_ref)?;\n \n-        let vtable_allocation = self.tcx.vtable_allocation((ty, poly_trait_ref));\n-\n-        let vtable_ptr = self.global_base_pointer(Pointer::from(vtable_allocation))?;\n-\n+        let vtable_symbolic_allocation = self.tcx.create_vtable_alloc(ty, poly_trait_ref);\n+        let vtable_ptr = self.global_base_pointer(Pointer::from(vtable_symbolic_allocation))?;\n         Ok(vtable_ptr.into())\n     }\n \n-    /// Resolves the function at the specified slot in the provided\n-    /// vtable. Currently an index of '3' (`TyCtxt::COMMON_VTABLE_ENTRIES.len()`)\n-    /// corresponds to the first method declared in the trait of the provided vtable.\n-    pub fn get_vtable_slot(\n+    /// Returns a high-level representation of the entires of the given vtable.\n+    pub fn get_vtable_entries(\n         &self,\n         vtable: Pointer<Option<M::Provenance>>,\n-        idx: u64,\n-    ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n-        let ptr_size = self.pointer_size();\n-        let vtable_slot = vtable.offset(ptr_size * idx, self)?;\n-        let vtable_slot = self\n-            .get_ptr_alloc(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n-            .expect(\"cannot be a ZST\");\n-        let fn_ptr = self.scalar_to_ptr(vtable_slot.read_pointer(Size::ZERO)?.check_init()?)?;\n-        self.get_ptr_fn(fn_ptr)\n+    ) -> InterpResult<'tcx, &'tcx [ty::VtblEntry<'tcx>]> {\n+        let (ty, poly_trait_ref) = self.get_ptr_vtable(vtable)?;\n+        Ok(if let Some(poly_trait_ref) = poly_trait_ref {\n+            let trait_ref = poly_trait_ref.with_self_ty(*self.tcx, ty);\n+            let trait_ref = self.tcx.erase_regions(trait_ref);\n+            self.tcx.vtable_entries(trait_ref)\n+        } else {\n+            TyCtxt::COMMON_VTABLE_ENTRIES\n+        })\n     }\n \n-    /// Returns the drop fn instance as well as the actual dynamic type.\n-    pub fn read_drop_type_from_vtable(\n-        &self,\n-        vtable: Pointer<Option<M::Provenance>>,\n-    ) -> InterpResult<'tcx, (ty::Instance<'tcx>, Ty<'tcx>)> {\n-        let pointer_size = self.pointer_size();\n-        // We don't care about the pointee type; we just want a pointer.\n-        let vtable = self\n-            .get_ptr_alloc(\n-                vtable,\n-                pointer_size * u64::try_from(TyCtxt::COMMON_VTABLE_ENTRIES.len()).unwrap(),\n-                self.tcx.data_layout.pointer_align.abi,\n-            )?\n-            .expect(\"cannot be a ZST\");\n-        let drop_fn = vtable\n-            .read_pointer(pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_DROPINPLACE).unwrap())?\n-            .check_init()?;\n-        // We *need* an instance here, no other kind of function value, to be able\n-        // to determine the type.\n-        let drop_instance = self.get_ptr_fn(self.scalar_to_ptr(drop_fn)?)?.as_instance()?;\n-        trace!(\"Found drop fn: {:?}\", drop_instance);\n-        let fn_sig = drop_instance.ty(*self.tcx, self.param_env).fn_sig(*self.tcx);\n-        let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig);\n-        // The drop function takes `*mut T` where `T` is the type being dropped, so get that.\n-        let args = fn_sig.inputs();\n-        if args.len() != 1 {\n-            throw_ub!(InvalidVtableDropFn(fn_sig));\n-        }\n-        let ty =\n-            args[0].builtin_deref(true).ok_or_else(|| err_ub!(InvalidVtableDropFn(fn_sig)))?.ty;\n-        Ok((drop_instance, ty))\n-    }\n-\n-    pub fn read_size_and_align_from_vtable(\n+    pub fn get_vtable_size_and_align(\n         &self,\n         vtable: Pointer<Option<M::Provenance>>,\n     ) -> InterpResult<'tcx, (Size, Align)> {\n-        let pointer_size = self.pointer_size();\n-        // We check for `size = 3 * ptr_size`, which covers the drop fn (unused here),\n-        // the size, and the align (which we read below).\n-        let vtable = self\n-            .get_ptr_alloc(\n-                vtable,\n-                pointer_size * u64::try_from(TyCtxt::COMMON_VTABLE_ENTRIES.len()).unwrap(),\n-                self.tcx.data_layout.pointer_align.abi,\n-            )?\n-            .expect(\"cannot be a ZST\");\n-        let size = vtable\n-            .read_integer(alloc_range(\n-                pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_SIZE).unwrap(),\n-                pointer_size,\n-            ))?\n-            .check_init()?;\n-        let size = size.to_machine_usize(self)?;\n-        let size = Size::from_bytes(size);\n-        let align = vtable\n-            .read_integer(alloc_range(\n-                pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_ALIGN).unwrap(),\n-                pointer_size,\n-            ))?\n-            .check_init()?;\n-        let align = align.to_machine_usize(self)?;\n-        let align = Align::from_bytes(align).map_err(|e| err_ub!(InvalidVtableAlignment(e)))?;\n-\n-        if size > self.max_size_of_val() {\n-            throw_ub!(InvalidVtableSize);\n-        }\n-        Ok((size, align))\n-    }\n-\n-    pub fn read_new_vtable_after_trait_upcasting_from_vtable(\n-        &self,\n-        vtable: Pointer<Option<M::Provenance>>,\n-        idx: u64,\n-    ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n-        let pointer_size = self.pointer_size();\n-\n-        let vtable_slot = vtable.offset(pointer_size * idx, self)?;\n-        let new_vtable = self\n-            .get_ptr_alloc(vtable_slot, pointer_size, self.tcx.data_layout.pointer_align.abi)?\n-            .expect(\"cannot be a ZST\");\n-\n-        let new_vtable = self.scalar_to_ptr(new_vtable.read_pointer(Size::ZERO)?.check_init()?)?;\n-\n-        Ok(new_vtable)\n+        let (ty, _trait_ref) = self.get_ptr_vtable(vtable)?;\n+        let layout = self.layout_of(ty)?;\n+        assert!(!layout.is_unsized(), \"there are no vtables for unsized types\");\n+        Ok((layout.size, layout.align.abi))\n     }\n }"}, {"sha": "f2e104da04a418965c78b76b2183696fded344d4", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 8, "deletions": 45, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -313,50 +313,15 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         match tail.kind() {\n             ty::Dynamic(..) => {\n                 let vtable = self.ecx.scalar_to_ptr(meta.unwrap_meta())?;\n-                // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n-                try_validation!(\n-                    self.ecx.check_ptr_access_align(\n-                        vtable,\n-                        3 * self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n-                        self.ecx.tcx.data_layout.pointer_align.abi,\n-                        CheckInAllocMsg::InboundsTest, // will anyway be replaced by validity message\n-                    ),\n-                    self.path,\n-                    err_ub!(DanglingIntPointer(..)) |\n-                    err_ub!(PointerUseAfterFree(..)) =>\n-                        { \"dangling vtable pointer in wide pointer\" },\n-                    err_ub!(AlignmentCheckFailed { .. }) =>\n-                        { \"unaligned vtable pointer in wide pointer\" },\n-                    err_ub!(PointerOutOfBounds { .. }) =>\n-                        { \"too small vtable\" },\n-                );\n-                try_validation!(\n-                    self.ecx.read_drop_type_from_vtable(vtable),\n+                // Make sure it is a genuine vtable pointer.\n+                let (_ty, _trait) = try_validation!(\n+                    self.ecx.get_ptr_vtable(vtable),\n                     self.path,\n                     err_ub!(DanglingIntPointer(..)) |\n-                    err_ub!(InvalidFunctionPointer(..)) =>\n-                        { \"invalid drop function pointer in vtable (not pointing to a function)\" },\n-                    err_ub!(InvalidVtableDropFn(..)) =>\n-                        { \"invalid drop function pointer in vtable (function has incompatible signature)\" },\n-                    // Stacked Borrows errors can happen here, see https://github.com/rust-lang/miri/issues/2123.\n-                    // (We assume there are no other MachineStop errors possible here.)\n-                    InterpError::MachineStop(_) =>\n-                        { \"vtable pointer does not have permission to read drop function pointer\" },\n-                );\n-                try_validation!(\n-                    self.ecx.read_size_and_align_from_vtable(vtable),\n-                    self.path,\n-                    err_ub!(InvalidVtableSize) =>\n-                        { \"invalid vtable: size is bigger than largest supported object\" },\n-                    err_ub!(InvalidVtableAlignment(msg)) =>\n-                        { \"invalid vtable: alignment {}\", msg },\n-                    err_unsup!(ReadPointerAsBytes) => { \"invalid size or align in vtable\" },\n-                    // Stacked Borrows errors can happen here, see https://github.com/rust-lang/miri/issues/2123.\n-                    // (We assume there are no other MachineStop errors possible here.)\n-                    InterpError::MachineStop(_) =>\n-                        { \"vtable pointer does not have permission to read size and alignment\" },\n+                    err_ub!(InvalidVTablePointer(..)) =>\n+                        { \"{vtable}\" } expected { \"a vtable pointer\" },\n                 );\n-                // FIXME: More checks for the vtable.\n+                // FIXME: check if the type/trait match what ty::Dynamic says?\n             }\n             ty::Slice(..) | ty::Str => {\n                 let _len = try_validation!(\n@@ -447,7 +412,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             // `!` is a ZST and we want to validate it.\n             if let Ok((alloc_id, _offset, _prov)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n                 // Special handling for pointers to statics (irrespective of their type).\n-                let alloc_kind = self.ecx.tcx.get_global_alloc(alloc_id);\n+                let alloc_kind = self.ecx.tcx.try_get_global_alloc(alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                     assert!(!self.ecx.tcx.is_thread_local_static(did));\n                     assert!(self.ecx.tcx.is_static(did));\n@@ -607,11 +572,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     let _fn = try_validation!(\n                         self.ecx.get_ptr_fn(ptr),\n                         self.path,\n-                        err_ub!(DanglingIntPointer(0, _)) =>\n-                            { \"a null function pointer\" },\n                         err_ub!(DanglingIntPointer(..)) |\n                         err_ub!(InvalidFunctionPointer(..)) =>\n-                            { \"{:x}\", value } expected { \"a function pointer\" },\n+                            { \"{ptr}\" } expected { \"a function pointer\" },\n                     );\n                     // FIXME: Check if the signature matches\n                 } else {"}, {"sha": "aee1f93b1a39cc65e2eef83fde163d0650ac3827", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -425,7 +425,7 @@ macro_rules! make_value_visitor {\n                         // unsized values are never immediate, so we can assert_mem_place\n                         let op = v.to_op_for_read(self.ecx())?;\n                         let dest = op.assert_mem_place();\n-                        let inner_mplace = self.ecx().unpack_dyn_trait(&dest)?.1;\n+                        let inner_mplace = self.ecx().unpack_dyn_trait(&dest)?;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner_mplace.layout);\n                         // recurse with the inner type\n                         return self.visit_field(&v, 0, &$value_trait::from_op(&inner_mplace.into()));"}, {"sha": "cecb55578d332b02224e4af05065f3a1b261465c", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -1,7 +1,7 @@\n use super::{AllocId, AllocRange, ConstAlloc, Pointer, Scalar};\n \n use crate::mir::interpret::ConstValue;\n-use crate::ty::{layout, query::TyCtxtAt, tls, FnSig, Ty, ValTree};\n+use crate::ty::{layout, query::TyCtxtAt, tls, Ty, ValTree};\n \n use rustc_data_structures::sync::Lock;\n use rustc_errors::{pluralize, struct_span_err, DiagnosticBuilder, ErrorGuaranteed};\n@@ -219,7 +219,7 @@ pub struct ScalarSizeMismatch {\n }\n \n /// Error information for when the program caused Undefined Behavior.\n-pub enum UndefinedBehaviorInfo<'tcx> {\n+pub enum UndefinedBehaviorInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Ub(String),\n     /// Unreachable code was executed.\n@@ -241,12 +241,6 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     PointerArithOverflow,\n     /// Invalid metadata in a wide pointer (using `str` to avoid allocations).\n     InvalidMeta(&'static str),\n-    /// Invalid drop function in vtable.\n-    InvalidVtableDropFn(FnSig<'tcx>),\n-    /// Invalid size in a vtable: too large.\n-    InvalidVtableSize,\n-    /// Invalid alignment in a vtable: too large, or not a power of 2.\n-    InvalidVtableAlignment(String),\n     /// Reading a C string that does not end within its allocation.\n     UnterminatedCString(Pointer),\n     /// Dereferencing a dangling pointer after it got freed.\n@@ -271,6 +265,8 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     WriteToReadOnly(AllocId),\n     // Trying to access the data behind a function pointer.\n     DerefFunctionPointer(AllocId),\n+    // Trying to access the data behind a vtable pointer.\n+    DerefVTablePointer(AllocId),\n     /// The value validity check found a problem.\n     /// Should only be thrown by `validity.rs` and always point out which part of the value\n     /// is the problem.\n@@ -288,6 +284,8 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     InvalidTag(Scalar),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n+    /// Using a pointer-not-to-a-vtable as vtable pointer.\n+    InvalidVTablePointer(Pointer),\n     /// Using a string that is not valid UTF-8,\n     InvalidStr(std::str::Utf8Error),\n     /// Using uninitialized data where it is not allowed.\n@@ -300,7 +298,7 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     UninhabitedEnumVariantWritten,\n }\n \n-impl fmt::Display for UndefinedBehaviorInfo<'_> {\n+impl fmt::Display for UndefinedBehaviorInfo {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use UndefinedBehaviorInfo::*;\n         match self {\n@@ -315,14 +313,6 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             RemainderOverflow => write!(f, \"overflow in signed remainder (dividing MIN by -1)\"),\n             PointerArithOverflow => write!(f, \"overflowing in-bounds pointer arithmetic\"),\n             InvalidMeta(msg) => write!(f, \"invalid metadata in wide pointer: {msg}\"),\n-            InvalidVtableDropFn(sig) => write!(\n-                f,\n-                \"invalid drop function signature: got {sig}, expected exactly one argument which must be a pointer type\",\n-            ),\n-            InvalidVtableSize => {\n-                write!(f, \"invalid vtable: size is bigger than largest supported object\")\n-            }\n-            InvalidVtableAlignment(msg) => write!(f, \"invalid vtable: alignment {msg}\"),\n             UnterminatedCString(p) => write!(\n                 f,\n                 \"reading a null-terminated string starting at {p:?} with no null found before end of allocation\",\n@@ -359,6 +349,7 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             ),\n             WriteToReadOnly(a) => write!(f, \"writing to {a:?} which is read-only\"),\n             DerefFunctionPointer(a) => write!(f, \"accessing {a:?} which contains a function\"),\n+            DerefVTablePointer(a) => write!(f, \"accessing {a:?} which contains a vtable\"),\n             ValidationFailure { path: None, msg } => {\n                 write!(f, \"constructing invalid value: {msg}\")\n             }\n@@ -375,6 +366,9 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             InvalidFunctionPointer(p) => {\n                 write!(f, \"using {p:?} as function pointer but it does not point to a function\")\n             }\n+            InvalidVTablePointer(p) => {\n+                write!(f, \"using {p:?} as vtable pointer but it does not point to a vtable\")\n+            }\n             InvalidStr(err) => write!(f, \"this string is not valid UTF-8: {err}\"),\n             InvalidUninitBytes(Some((alloc, info))) => write!(\n                 f,\n@@ -494,7 +488,7 @@ impl dyn MachineStopType {\n \n pub enum InterpError<'tcx> {\n     /// The program caused undefined behavior.\n-    UndefinedBehavior(UndefinedBehaviorInfo<'tcx>),\n+    UndefinedBehavior(UndefinedBehaviorInfo),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n     /// but the interpreter is not sure).\n     Unsupported(UnsupportedOpInfo),"}, {"sha": "967f8ece16cf9ff3554ae9d670e929577e299ca8", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -196,6 +196,7 @@ impl fmt::Debug for AllocId {\n enum AllocDiscriminant {\n     Alloc,\n     Fn,\n+    VTable,\n     Static,\n }\n \n@@ -215,6 +216,12 @@ pub fn specialized_encode_alloc_id<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>>(\n             AllocDiscriminant::Fn.encode(encoder);\n             fn_instance.encode(encoder);\n         }\n+        GlobalAlloc::VTable(ty, poly_trait_ref) => {\n+            trace!(\"encoding {:?} with {ty:#?}, {poly_trait_ref:#?}\", alloc_id);\n+            AllocDiscriminant::VTable.encode(encoder);\n+            ty.encode(encoder);\n+            poly_trait_ref.encode(encoder);\n+        }\n         GlobalAlloc::Static(did) => {\n             assert!(!tcx.is_thread_local_static(did));\n             // References to statics doesn't need to know about their allocations,\n@@ -305,7 +312,9 @@ impl<'s> AllocDecodingSession<'s> {\n                                 State::InProgress(TinyList::new_single(self.session_id), alloc_id);\n                             Some(alloc_id)\n                         }\n-                        AllocDiscriminant::Fn | AllocDiscriminant::Static => {\n+                        AllocDiscriminant::Fn\n+                        | AllocDiscriminant::Static\n+                        | AllocDiscriminant::VTable => {\n                             // Fns and statics cannot be cyclic, and their `AllocId`\n                             // is determined later by interning.\n                             *entry =\n@@ -355,6 +364,16 @@ impl<'s> AllocDecodingSession<'s> {\n                     let alloc_id = decoder.interner().create_fn_alloc(instance);\n                     alloc_id\n                 }\n+                AllocDiscriminant::VTable => {\n+                    assert!(alloc_id.is_none());\n+                    trace!(\"creating vtable alloc ID\");\n+                    let ty = <Ty<'_> as Decodable<D>>::decode(decoder);\n+                    let poly_trait_ref =\n+                        <Option<ty::PolyExistentialTraitRef<'_>> as Decodable<D>>::decode(decoder);\n+                    trace!(\"decoded vtable alloc instance: {ty:?}, {poly_trait_ref:?}\");\n+                    let alloc_id = decoder.interner().create_vtable_alloc(ty, poly_trait_ref);\n+                    alloc_id\n+                }\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc ID\");\n@@ -380,6 +399,8 @@ impl<'s> AllocDecodingSession<'s> {\n pub enum GlobalAlloc<'tcx> {\n     /// The alloc ID is used as a function pointer.\n     Function(Instance<'tcx>),\n+    /// This alloc ID points to a symbolic (not-reified) vtable.\n+    VTable(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>),\n     /// The alloc ID points to a \"lazy\" static variable that did not get computed (yet).\n     /// This is also used to break the cycle in recursive statics.\n     Static(DefId),\n@@ -407,6 +428,16 @@ impl<'tcx> GlobalAlloc<'tcx> {\n             _ => bug!(\"expected function, got {:?}\", self),\n         }\n     }\n+\n+    /// Panics if the `GlobalAlloc` is not `GlobalAlloc::VTable`\n+    #[track_caller]\n+    #[inline]\n+    pub fn unwrap_vtable(&self) -> (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>) {\n+        match *self {\n+            GlobalAlloc::VTable(ty, poly_trait_ref) => (ty, poly_trait_ref),\n+            _ => bug!(\"expected vtable, got {:?}\", self),\n+        }\n+    }\n }\n \n pub(crate) struct AllocMap<'tcx> {\n@@ -454,12 +485,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Reserves a new ID *if* this allocation has not been dedup-reserved before.\n-    /// Should only be used for function pointers and statics, we don't want\n-    /// to dedup IDs for \"real\" memory!\n+    /// Should only be used for \"symbolic\" allocations (function pointers, vtables, statics), we\n+    /// don't want to dedup IDs for \"real\" memory!\n     fn reserve_and_set_dedup(self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n         let mut alloc_map = self.alloc_map.lock();\n         match alloc {\n-            GlobalAlloc::Function(..) | GlobalAlloc::Static(..) => {}\n+            GlobalAlloc::Function(..) | GlobalAlloc::Static(..) | GlobalAlloc::VTable(..) => {}\n             GlobalAlloc::Memory(..) => bug!(\"Trying to dedup-reserve memory with real data!\"),\n         }\n         if let Some(&alloc_id) = alloc_map.dedup.get(&alloc) {\n@@ -504,6 +535,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Generates an `AllocId` for a (symbolic, not-reified) vtable.  Will get deduplicated.\n+    pub fn create_vtable_alloc(\n+        self,\n+        ty: Ty<'tcx>,\n+        poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+    ) -> AllocId {\n+        self.reserve_and_set_dedup(GlobalAlloc::VTable(ty, poly_trait_ref))\n+    }\n+\n     /// Interns the `Allocation` and return a new `AllocId`, even if there's already an identical\n     /// `Allocation` with a different `AllocId`.\n     /// Statics with identical content will still point to the same `Allocation`, i.e.,\n@@ -521,7 +561,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// This function exists to allow const eval to detect the difference between evaluation-\n     /// local dangling pointers and allocations in constants/statics.\n     #[inline]\n-    pub fn get_global_alloc(self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n+    pub fn try_get_global_alloc(self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n         self.alloc_map.lock().alloc_map.get(&id).cloned()\n     }\n \n@@ -532,7 +572,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// ids), this function is frequently used throughout rustc, but should not be used within\n     /// the miri engine.\n     pub fn global_alloc(self, id: AllocId) -> GlobalAlloc<'tcx> {\n-        match self.get_global_alloc(id) {\n+        match self.try_get_global_alloc(id) {\n             Some(alloc) => alloc,\n             None => bug!(\"could not find allocation for {id:?}\"),\n         }"}, {"sha": "21ae121e1ce69b5626abb6a643dd5ccb376b7c32", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -362,7 +362,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             // the codegen tests and can even make item order\n                             // unstable.\n                             InstanceDef::Item(def) => def.did.as_local().map(Idx::index),\n-                            InstanceDef::VtableShim(..)\n+                            InstanceDef::VTableShim(..)\n                             | InstanceDef::ReifyShim(..)\n                             | InstanceDef::Intrinsic(..)\n                             | InstanceDef::FnPtrShim(..)"}, {"sha": "78b5131bac65e0f205c744e561ca5a966bd63046", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -720,11 +720,17 @@ pub fn write_allocations<'tcx>(\n                 write!(w, \"{}\", display_allocation(tcx, alloc.inner()))\n             };\n         write!(w, \"\\n{id:?}\")?;\n-        match tcx.get_global_alloc(id) {\n+        match tcx.try_get_global_alloc(id) {\n             // This can't really happen unless there are bugs, but it doesn't cost us anything to\n             // gracefully handle it and allow buggy rustc to be debugged via allocation printing.\n             None => write!(w, \" (deallocated)\")?,\n             Some(GlobalAlloc::Function(inst)) => write!(w, \" (fn: {inst})\")?,\n+            Some(GlobalAlloc::VTable(ty, Some(trait_ref))) => {\n+                write!(w, \" (vtable: impl {trait_ref} for {ty})\")?\n+            }\n+            Some(GlobalAlloc::VTable(ty, None)) => {\n+                write!(w, \" (vtable: impl <auto trait> for {ty})\")?\n+            }\n             Some(GlobalAlloc::Static(did)) if !tcx.is_foreign_item(did) => {\n                 match tcx.eval_static_initializer(did) {\n                     Ok(alloc) => {"}, {"sha": "891608764017c57ba720b703b529920e6141ced0", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -394,7 +394,7 @@ macro_rules! make_mir_visitor {\n                         ty::InstanceDef::Item(_def_id) => {}\n \n                         ty::InstanceDef::Intrinsic(_def_id) |\n-                        ty::InstanceDef::VtableShim(_def_id) |\n+                        ty::InstanceDef::VTableShim(_def_id) |\n                         ty::InstanceDef::ReifyShim(_def_id) |\n                         ty::InstanceDef::Virtual(_def_id, _) |\n                         ty::InstanceDef::ClosureOnceShim { call_once: _def_id, track_caller: _ } |"}, {"sha": "51137c52659db493ec2979c0d81728765d4796a3", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -523,4 +523,5 @@ impl_binder_encode_decode! {\n     ty::ExistentialPredicate<'tcx>,\n     ty::TraitRef<'tcx>,\n     Vec<ty::GeneratorInteriorTypeCause<'tcx>>,\n+    ty::ExistentialTraitRef<'tcx>,\n }"}, {"sha": "263d64a57776affd1575c165a450ee65a88d188a", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -147,7 +147,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n         ty::tls::with_opt(|tcx| {\n             trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            tcx.get_global_alloc(*self).hash_stable(hcx, hasher);\n+            tcx.try_get_global_alloc(*self).hash_stable(hcx, hasher);\n         });\n     }\n }"}, {"sha": "33a46f809b0d34c55f867f2d827900366f70c14f", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -49,7 +49,7 @@ pub enum InstanceDef<'tcx> {\n     ///\n     /// The generated shim will take `Self` via `*mut Self` - conceptually this is `&owned Self` -\n     /// and dereference the argument to call the original function.\n-    VtableShim(DefId),\n+    VTableShim(DefId),\n \n     /// `fn()` pointer where the function itself cannot be turned into a pointer.\n     ///\n@@ -145,7 +145,7 @@ impl<'tcx> InstanceDef<'tcx> {\n     pub fn def_id(self) -> DefId {\n         match self {\n             InstanceDef::Item(def) => def.did,\n-            InstanceDef::VtableShim(def_id)\n+            InstanceDef::VTableShim(def_id)\n             | InstanceDef::ReifyShim(def_id)\n             | InstanceDef::FnPtrShim(def_id, _)\n             | InstanceDef::Virtual(def_id, _)\n@@ -161,7 +161,7 @@ impl<'tcx> InstanceDef<'tcx> {\n         match self {\n             ty::InstanceDef::Item(def) => Some(def.did),\n             ty::InstanceDef::DropGlue(def_id, Some(_)) => Some(def_id),\n-            InstanceDef::VtableShim(..)\n+            InstanceDef::VTableShim(..)\n             | InstanceDef::ReifyShim(..)\n             | InstanceDef::FnPtrShim(..)\n             | InstanceDef::Virtual(..)\n@@ -176,7 +176,7 @@ impl<'tcx> InstanceDef<'tcx> {\n     pub fn with_opt_param(self) -> ty::WithOptConstParam<DefId> {\n         match self {\n             InstanceDef::Item(def) => def,\n-            InstanceDef::VtableShim(def_id)\n+            InstanceDef::VTableShim(def_id)\n             | InstanceDef::ReifyShim(def_id)\n             | InstanceDef::FnPtrShim(def_id, _)\n             | InstanceDef::Virtual(def_id, _)\n@@ -273,7 +273,7 @@ impl<'tcx> InstanceDef<'tcx> {\n             | InstanceDef::Intrinsic(..)\n             | InstanceDef::ReifyShim(..)\n             | InstanceDef::Virtual(..)\n-            | InstanceDef::VtableShim(..) => true,\n+            | InstanceDef::VTableShim(..) => true,\n         }\n     }\n }\n@@ -290,7 +290,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n \n         match self.def {\n             InstanceDef::Item(_) => Ok(()),\n-            InstanceDef::VtableShim(_) => write!(f, \" - shim(vtable)\"),\n+            InstanceDef::VTableShim(_) => write!(f, \" - shim(vtable)\"),\n             InstanceDef::ReifyShim(_) => write!(f, \" - shim(reify)\"),\n             InstanceDef::Intrinsic(_) => write!(f, \" - intrinsic\"),\n             InstanceDef::Virtual(_, num) => write!(f, \" - virtual#{}\", num),\n@@ -434,7 +434,7 @@ impl<'tcx> Instance<'tcx> {\n             && tcx.generics_of(def_id).has_self;\n         if is_vtable_shim {\n             debug!(\" => associated item with unsizeable self: Self\");\n-            Some(Instance { def: InstanceDef::VtableShim(def_id), substs })\n+            Some(Instance { def: InstanceDef::VTableShim(def_id), substs })\n         } else {\n             Instance::resolve(tcx, param_env, def_id, substs).ok().flatten().map(|mut resolved| {\n                 match resolved.def {"}, {"sha": "ab76ad5098413bdc63aca405fb540c39d7eb06e1", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -2771,7 +2771,7 @@ impl<'tcx> ty::Instance<'tcx> {\n                     _ => unreachable!(),\n                 };\n \n-                if let ty::InstanceDef::VtableShim(..) = self.def {\n+                if let ty::InstanceDef::VTableShim(..) = self.def {\n                     // Modify `fn(self, ...)` to `fn(self: *mut Self, ...)`.\n                     sig = sig.map_bound(|mut sig| {\n                         let mut inputs_and_output = sig.inputs_and_output.to_vec();"}, {"sha": "4346dbdb16b33582b43c12821db954fda131ec8b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -2128,7 +2128,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                 }\n             }\n-            ty::InstanceDef::VtableShim(..)\n+            ty::InstanceDef::VTableShim(..)\n             | ty::InstanceDef::ReifyShim(..)\n             | ty::InstanceDef::Intrinsic(..)\n             | ty::InstanceDef::FnPtrShim(..)"}, {"sha": "09b9c806691285c67db9811d6931205649828719", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -1269,7 +1269,7 @@ pub trait PrettyPrinter<'tcx>:\n                 if let ty::Array(elem, len) = inner.kind() {\n                     if let ty::Uint(ty::UintTy::U8) = elem.kind() {\n                         if let ty::ConstKind::Value(ty::ValTree::Leaf(int)) = len.kind() {\n-                            match self.tcx().get_global_alloc(alloc_id) {\n+                            match self.tcx().try_get_global_alloc(alloc_id) {\n                                 Some(GlobalAlloc::Memory(alloc)) => {\n                                     let len = int.assert_bits(self.tcx().data_layout.pointer_size);\n                                     let range =\n@@ -1282,11 +1282,12 @@ pub trait PrettyPrinter<'tcx>:\n                                         p!(\"<too short allocation>\")\n                                     }\n                                 }\n-                                // FIXME: for statics and functions, we could in principle print more detail.\n+                                // FIXME: for statics, vtables, and functions, we could in principle print more detail.\n                                 Some(GlobalAlloc::Static(def_id)) => {\n                                     p!(write(\"<static({:?})>\", def_id))\n                                 }\n                                 Some(GlobalAlloc::Function(_)) => p!(\"<function>\"),\n+                                Some(GlobalAlloc::VTable(..)) => p!(\"<vtable>\"),\n                                 None => p!(\"<dangling pointer>\"),\n                             }\n                             return Ok(self);\n@@ -1297,7 +1298,8 @@ pub trait PrettyPrinter<'tcx>:\n             ty::FnPtr(_) => {\n                 // FIXME: We should probably have a helper method to share code with the \"Byte strings\"\n                 // printing above (which also has to handle pointers to all sorts of things).\n-                if let Some(GlobalAlloc::Function(instance)) = self.tcx().get_global_alloc(alloc_id)\n+                if let Some(GlobalAlloc::Function(instance)) =\n+                    self.tcx().try_get_global_alloc(alloc_id)\n                 {\n                     self = self.typed_value(\n                         |this| this.print_value_path(instance.def_id(), instance.substs),"}, {"sha": "a4be3d02d19359e1d9cb908d0589654e81ff9054", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -624,7 +624,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self {\n             ty::InstanceDef::Item(def_id) => Some(ty::InstanceDef::Item(def_id)),\n-            ty::InstanceDef::VtableShim(def_id) => Some(ty::InstanceDef::VtableShim(def_id)),\n+            ty::InstanceDef::VTableShim(def_id) => Some(ty::InstanceDef::VTableShim(def_id)),\n             ty::InstanceDef::ReifyShim(def_id) => Some(ty::InstanceDef::ReifyShim(def_id)),\n             ty::InstanceDef::Intrinsic(def_id) => Some(ty::InstanceDef::Intrinsic(def_id)),\n             ty::InstanceDef::FnPtrShim(def_id, ty) => {\n@@ -927,7 +927,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n             substs: self.substs.try_fold_with(folder)?,\n             def: match self.def {\n                 Item(def) => Item(def.try_fold_with(folder)?),\n-                VtableShim(did) => VtableShim(did.try_fold_with(folder)?),\n+                VTableShim(did) => VTableShim(did.try_fold_with(folder)?),\n                 ReifyShim(did) => ReifyShim(did.try_fold_with(folder)?),\n                 Intrinsic(did) => Intrinsic(did.try_fold_with(folder)?),\n                 FnPtrShim(did, ty) => {\n@@ -954,7 +954,7 @@ impl<'tcx> TypeVisitable<'tcx> for ty::instance::Instance<'tcx> {\n         self.substs.visit_with(visitor)?;\n         match self.def {\n             Item(def) => def.visit_with(visitor),\n-            VtableShim(did) | ReifyShim(did) | Intrinsic(did) | Virtual(did, _) => {\n+            VTableShim(did) | ReifyShim(did) | Intrinsic(did) | Virtual(did, _) => {\n                 did.visit_with(visitor)\n             }\n             FnPtrShim(did, ty) | CloneShim(did, ty) => {"}, {"sha": "1e46b0a0e8164d21f92aca83153d1ed6b87f7225", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -246,7 +246,7 @@ impl<'tcx> Inliner<'tcx> {\n             // not get any optimizations run on it. Any subsequent inlining may cause cycles, but we\n             // do not need to catch this here, we can wait until the inliner decides to continue\n             // inlining a second time.\n-            InstanceDef::VtableShim(_)\n+            InstanceDef::VTableShim(_)\n             | InstanceDef::ReifyShim(_)\n             | InstanceDef::FnPtrShim(..)\n             | InstanceDef::ClosureOnceShim { .. }"}, {"sha": "7810218fd6744edf09c9309fc9b507fc0e9e00c6", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -79,7 +79,7 @@ pub(crate) fn mir_callgraph_reachable<'tcx>(\n                 // These have MIR and if that MIR is inlined, substituted and then inlining is run\n                 // again, a function item can end up getting inlined. Thus we'll be able to cause\n                 // a cycle that way\n-                InstanceDef::VtableShim(_)\n+                InstanceDef::VTableShim(_)\n                 | InstanceDef::ReifyShim(_)\n                 | InstanceDef::FnPtrShim(..)\n                 | InstanceDef::ClosureOnceShim { .. }"}, {"sha": "3620e94bec7d750cc79fc02dddd63bd3ba94e612", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -32,7 +32,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n \n     let mut result = match instance {\n         ty::InstanceDef::Item(..) => bug!(\"item {:?} passed to make_shim\", instance),\n-        ty::InstanceDef::VtableShim(def_id) => {\n+        ty::InstanceDef::VTableShim(def_id) => {\n             build_call_shim(tcx, instance, Some(Adjustment::Deref), CallKind::Direct(def_id))\n         }\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n@@ -113,7 +113,7 @@ enum Adjustment {\n     /// We get passed `&[mut] self` and call the target with `*self`.\n     ///\n     /// This either copies `self` (if `Self: Copy`, eg. for function items), or moves out of it\n-    /// (for `VtableShim`, which effectively is passed `&own Self`).\n+    /// (for `VTableShim`, which effectively is passed `&own Self`).\n     Deref,\n \n     /// We get passed `self: Self` and call the target with `&mut self`.\n@@ -569,7 +569,7 @@ fn build_call_shim<'tcx>(\n \n     // FIXME(eddyb) avoid having this snippet both here and in\n     // `Instance::fn_sig` (introduce `InstanceDef::fn_sig`?).\n-    if let ty::InstanceDef::VtableShim(..) = instance {\n+    if let ty::InstanceDef::VTableShim(..) = instance {\n         // Modify fn(self, ...) to fn(self: *mut Self, ...)\n         let mut inputs_and_output = sig.inputs_and_output.to_vec();\n         let self_arg = &mut inputs_and_output[0];"}, {"sha": "68b65658c72b50503c3bc78635c84f30c771f62d", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -25,7 +25,7 @@\n //! codegen unit:\n //!\n //! - Constants\n-//! - Vtables\n+//! - VTables\n //! - Object Shims\n //!\n //!\n@@ -992,7 +992,7 @@ fn visit_instance_use<'tcx>(\n             }\n         }\n         ty::InstanceDef::DropGlue(_, Some(_))\n-        | ty::InstanceDef::VtableShim(..)\n+        | ty::InstanceDef::VTableShim(..)\n         | ty::InstanceDef::ReifyShim(..)\n         | ty::InstanceDef::ClosureOnceShim { .. }\n         | ty::InstanceDef::Item(..)\n@@ -1427,6 +1427,10 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut MonoIte\n                 output.push(create_fn_mono_item(tcx, fn_instance, DUMMY_SP));\n             }\n         }\n+        GlobalAlloc::VTable(ty, trait_ref) => {\n+            let alloc_id = tcx.vtable_allocation((ty, trait_ref));\n+            collect_miri(tcx, alloc_id, output)\n+        }\n     }\n }\n "}, {"sha": "15276569c32f5accec4b07611bb4f2263ee26641", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -271,7 +271,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n         MonoItem::Fn(instance) => {\n             let def_id = match instance.def {\n                 ty::InstanceDef::Item(def) => def.did,\n-                ty::InstanceDef::VtableShim(..)\n+                ty::InstanceDef::VTableShim(..)\n                 | ty::InstanceDef::ReifyShim(..)\n                 | ty::InstanceDef::FnPtrShim(..)\n                 | ty::InstanceDef::ClosureOnceShim { .. }\n@@ -425,7 +425,7 @@ fn mono_item_visibility<'tcx>(\n         InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n \n         // These are all compiler glue and such, never exported, always hidden.\n-        InstanceDef::VtableShim(..)\n+        InstanceDef::VTableShim(..)\n         | InstanceDef::ReifyShim(..)\n         | InstanceDef::FnPtrShim(..)\n         | InstanceDef::Virtual(..)"}, {"sha": "eda61df7700d7a064e15f1d6210bc6be2a271442", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -37,7 +37,7 @@ mod values;\n use self::values::Value;\n \n pub use rustc_query_system::query::QueryConfig;\n-pub(crate) use rustc_query_system::query::{QueryDescription, QueryVtable};\n+pub(crate) use rustc_query_system::query::{QueryDescription, QueryVTable};\n \n mod on_disk_cache;\n pub use on_disk_cache::OnDiskCache;"}, {"sha": "eda4401c81d01bc7b1a3239e1c8c2aa26d02f9ce", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -340,11 +340,11 @@ macro_rules! define_queries {\n \n             #[inline]\n             fn make_vtable(tcx: QueryCtxt<'tcx>, key: &Self::Key) ->\n-                QueryVtable<QueryCtxt<$tcx>, Self::Key, Self::Value>\n+                QueryVTable<QueryCtxt<$tcx>, Self::Key, Self::Value>\n             {\n                 let compute = get_provider!([$($modifiers)*][tcx, $name, key]);\n                 let cache_on_disk = Self::cache_on_disk(tcx.tcx, key);\n-                QueryVtable {\n+                QueryVTable {\n                     anon: is_anon!([$($modifiers)*]),\n                     eval_always: is_eval_always!([$($modifiers)*]),\n                     dep_kind: dep_graph::DepKind::$name,"}, {"sha": "964914a1326bda7156d948cba563b0842fd6247d", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -19,7 +19,7 @@ pub trait QueryConfig {\n     type Stored: Clone;\n }\n \n-pub struct QueryVtable<CTX: QueryContext, K, V> {\n+pub struct QueryVTable<CTX: QueryContext, K, V> {\n     pub anon: bool,\n     pub dep_kind: CTX::DepKind,\n     pub eval_always: bool,\n@@ -31,7 +31,7 @@ pub struct QueryVtable<CTX: QueryContext, K, V> {\n     pub try_load_from_disk: Option<fn(CTX, SerializedDepNodeIndex) -> Option<V>>,\n }\n \n-impl<CTX: QueryContext, K, V> QueryVtable<CTX, K, V> {\n+impl<CTX: QueryContext, K, V> QueryVTable<CTX, K, V> {\n     pub(crate) fn to_dep_node(&self, tcx: CTX::DepContext, key: &K) -> DepNode<CTX::DepKind>\n     where\n         K: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n@@ -69,7 +69,7 @@ pub trait QueryDescription<CTX: QueryContext>: QueryConfig {\n         CTX: 'a;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn make_vtable(tcx: CTX, key: &Self::Key) -> QueryVtable<CTX, Self::Key, Self::Value>;\n+    fn make_vtable(tcx: CTX, key: &Self::Key) -> QueryVTable<CTX, Self::Key, Self::Value>;\n \n     fn cache_on_disk(tcx: CTX::DepContext, key: &Self::Key) -> bool;\n }"}, {"sha": "fb2258434f4d3ef6475934f78a137ea2c20392c9", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -12,7 +12,7 @@ pub use self::caches::{\n };\n \n mod config;\n-pub use self::config::{QueryConfig, QueryDescription, QueryVtable};\n+pub use self::config::{QueryConfig, QueryDescription, QueryVTable};\n \n use crate::dep_graph::{DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n "}, {"sha": "5e8ea07d00f99de86820522afa5665e5ea08a43b", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -4,7 +4,7 @@\n \n use crate::dep_graph::{DepContext, DepNode, DepNodeIndex, DepNodeParams};\n use crate::query::caches::QueryCache;\n-use crate::query::config::{QueryDescription, QueryVtable};\n+use crate::query::config::{QueryDescription, QueryVTable};\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n use crate::query::{QueryContext, QueryMap, QuerySideEffects, QueryStackFrame};\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -331,7 +331,7 @@ fn try_execute_query<CTX, C>(\n     span: Span,\n     key: C::Key,\n     dep_node: Option<DepNode<CTX::DepKind>>,\n-    query: &QueryVtable<CTX, C::Key, C::Value>,\n+    query: &QueryVTable<CTX, C::Key, C::Value>,\n ) -> (C::Stored, Option<DepNodeIndex>)\n where\n     C: QueryCache,\n@@ -368,7 +368,7 @@ fn execute_job<CTX, K, V>(\n     tcx: CTX,\n     key: K,\n     mut dep_node_opt: Option<DepNode<CTX::DepKind>>,\n-    query: &QueryVtable<CTX, K, V>,\n+    query: &QueryVTable<CTX, K, V>,\n     job_id: QueryJobId,\n ) -> (V, DepNodeIndex)\n where\n@@ -437,7 +437,7 @@ fn try_load_from_disk_and_cache_in_memory<CTX, K, V>(\n     tcx: CTX,\n     key: &K,\n     dep_node: &DepNode<CTX::DepKind>,\n-    query: &QueryVtable<CTX, K, V>,\n+    query: &QueryVTable<CTX, K, V>,\n ) -> Option<(V, DepNodeIndex)>\n where\n     K: Clone,\n@@ -530,7 +530,7 @@ fn incremental_verify_ich<CTX, K, V: Debug>(\n     tcx: CTX::DepContext,\n     result: &V,\n     dep_node: &DepNode<CTX::DepKind>,\n-    query: &QueryVtable<CTX, K, V>,\n+    query: &QueryVTable<CTX, K, V>,\n ) where\n     CTX: QueryContext,\n {\n@@ -642,7 +642,7 @@ fn incremental_verify_ich_cold(sess: &Session, dep_node: DebugArg<'_>, result: D\n fn ensure_must_run<CTX, K, V>(\n     tcx: CTX,\n     key: &K,\n-    query: &QueryVtable<CTX, K, V>,\n+    query: &QueryVTable<CTX, K, V>,\n ) -> (bool, Option<DepNode<CTX::DepKind>>)\n where\n     K: crate::dep_graph::DepNodeParams<CTX::DepContext>,"}, {"sha": "d15b15f75dd098b63c58078ee4c95206050cef0d", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -1565,6 +1565,8 @@ symbols! {\n         volatile_store,\n         vreg,\n         vreg_low16,\n+        vtable_align,\n+        vtable_size,\n         warn,\n         wasm_abi,\n         wasm_import_module,"}, {"sha": "9241fd82c745fde4a857c5598faaba111c2edd34", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -67,7 +67,7 @@ pub(super) fn mangle<'tcx>(\n         )\n         .unwrap();\n \n-    if let ty::InstanceDef::VtableShim(..) = instance.def {\n+    if let ty::InstanceDef::VTableShim(..) = instance.def {\n         let _ = printer.write_str(\"{{vtable-shim}}\");\n     }\n \n@@ -129,7 +129,7 @@ fn get_symbol_hash<'tcx>(\n                 }\n \n                 // We want to avoid accidental collision between different types of instances.\n-                // Especially, `VtableShim`s and `ReifyShim`s may overlap with their original\n+                // Especially, `VTableShim`s and `ReifyShim`s may overlap with their original\n                 // instances without this.\n                 discriminant(&instance.def).hash_stable(hcx, &mut hasher);\n             });"}, {"sha": "79e3f10526c99e2ee686a941ce8c736a18f53313", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -42,7 +42,7 @@ pub(super) fn mangle<'tcx>(\n \n     // Append `::{shim:...#0}` to shims that can coexist with a non-shim instance.\n     let shim_kind = match instance.def {\n-        ty::InstanceDef::VtableShim(_) => Some(\"vtable\"),\n+        ty::InstanceDef::VTableShim(_) => Some(\"vtable\"),\n         ty::InstanceDef::ReifyShim(_) => Some(\"reify\"),\n \n         _ => None,"}, {"sha": "7aaddc2bd7aab545fbdd576f558e998ae500f1eb", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -69,7 +69,7 @@ enum PointerKind<'tcx> {\n     /// No metadata attached, ie pointer to sized type or foreign type\n     Thin,\n     /// A trait object\n-    Vtable(Option<DefId>),\n+    VTable(Option<DefId>),\n     /// Slice\n     Length,\n     /// The unsize info of this projection\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         Ok(match *t.kind() {\n             ty::Slice(_) | ty::Str => Some(PointerKind::Length),\n-            ty::Dynamic(ref tty, ..) => Some(PointerKind::Vtable(tty.principal_def_id())),\n+            ty::Dynamic(ref tty, ..) => Some(PointerKind::VTable(tty.principal_def_id())),\n             ty::Adt(def, substs) if def.is_struct() => match def.non_enum_variant().fields.last() {\n                 None => Some(PointerKind::Thin),\n                 Some(f) => {\n@@ -951,7 +951,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         match fcx.pointer_kind(m_cast.ty, self.span)? {\n             None => Err(CastError::UnknownCastPtrKind),\n             Some(PointerKind::Thin) => Ok(CastKind::AddrPtrCast),\n-            Some(PointerKind::Vtable(_)) => Err(CastError::IntToFatCast(Some(\"a vtable\"))),\n+            Some(PointerKind::VTable(_)) => Err(CastError::IntToFatCast(Some(\"a vtable\"))),\n             Some(PointerKind::Length) => Err(CastError::IntToFatCast(Some(\"a length\"))),\n             Some(\n                 PointerKind::OfProjection(_)"}, {"sha": "3f2a0da8d65156b2f20f3ad24b1b1944de54b30b", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -400,6 +400,10 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             sym::const_eval_select => (4, vec![param(0), param(1), param(2)], param(3)),\n \n+            sym::vtable_size | sym::vtable_align => {\n+                (0, vec![tcx.mk_imm_ptr(tcx.mk_unit())], tcx.types.usize)\n+            }\n+\n             other => {\n                 tcx.sess.emit_err(UnrecognizedIntrinsicFunction { span: it.span, name: other });\n                 return;"}, {"sha": "dc82b32214c37d05b7fa4ea728a31768c42ed3da", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -2291,6 +2291,16 @@ extern \"rust-intrinsic\" {\n     /// [`std::hint::black_box`]: crate::hint::black_box\n     #[rustc_const_unstable(feature = \"const_black_box\", issue = \"none\")]\n     pub fn black_box<T>(dummy: T) -> T;\n+\n+    /// `ptr` must point to a vtable.\n+    /// The intrinsic will return the size stored in that vtable.\n+    #[cfg(not(bootstrap))]\n+    pub fn vtable_size(ptr: *const ()) -> usize;\n+\n+    /// `ptr` must point to a vtable.\n+    /// The intrinsic will return the alignment stored in that vtable.\n+    #[cfg(not(bootstrap))]\n+    pub fn vtable_align(ptr: *const ()) -> usize;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "cd5edee0460ad4a19b41f99ec55d56d31fa712fc", "filename": "library/core/src/ptr/metadata.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -180,10 +180,20 @@ pub struct DynMetadata<Dyn: ?Sized> {\n     phantom: crate::marker::PhantomData<Dyn>,\n }\n \n+#[cfg(not(bootstrap))]\n+extern \"C\" {\n+    /// Opaque type for accessing vtables.\n+    ///\n+    /// Private implementation detail of `DynMetadata::size_of` etc.\n+    /// There is conceptually not actually any Abstract Machine memory behind this pointer.\n+    type VTable;\n+}\n+\n /// The common prefix of all vtables. It is followed by function pointers for trait methods.\n ///\n /// Private implementation detail of `DynMetadata::size_of` etc.\n #[repr(C)]\n+#[cfg(bootstrap)]\n struct VTable {\n     drop_in_place: fn(*mut ()),\n     size_of: usize,\n@@ -194,13 +204,28 @@ impl<Dyn: ?Sized> DynMetadata<Dyn> {\n     /// Returns the size of the type associated with this vtable.\n     #[inline]\n     pub fn size_of(self) -> usize {\n-        self.vtable_ptr.size_of\n+        // Note that \"size stored in vtable\" is *not* the same as \"result of size_of_val_raw\".\n+        // Consider a reference like `&(i32, dyn Send)`: the vtable will only store the size of the\n+        // `Send` part!\n+        #[cfg(bootstrap)]\n+        return self.vtable_ptr.size_of;\n+        #[cfg(not(bootstrap))]\n+        // SAFETY: DynMetadata always contains a valid vtable pointer\n+        return unsafe {\n+            crate::intrinsics::vtable_size(self.vtable_ptr as *const VTable as *const ())\n+        };\n     }\n \n     /// Returns the alignment of the type associated with this vtable.\n     #[inline]\n     pub fn align_of(self) -> usize {\n-        self.vtable_ptr.align_of\n+        #[cfg(bootstrap)]\n+        return self.vtable_ptr.align_of;\n+        #[cfg(not(bootstrap))]\n+        // SAFETY: DynMetadata always contains a valid vtable pointer\n+        return unsafe {\n+            crate::intrinsics::vtable_align(self.vtable_ptr as *const VTable as *const ())\n+        };\n     }\n \n     /// Returns the size and alignment together as a `Layout`"}, {"sha": "90a454c75a1cecf2823060c5db65492f05c71b80", "filename": "src/test/ui/consts/const-eval/const_transmute.rs", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/31b9b012bbced0c47a0ff5e4453cdc2e91e668b2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31b9b012bbced0c47a0ff5e4453cdc2e91e668b2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_transmute.rs?ref=31b9b012bbced0c47a0ff5e4453cdc2e91e668b2", "patch": "@@ -1,54 +0,0 @@\n-// run-pass\n-\n-#![allow(dead_code)]\n-\n-#[repr(C)]\n-union Transmute<T: Copy, U: Copy> {\n-    t: T,\n-    u: U,\n-}\n-\n-trait Bar {\n-    fn bar(&self) -> u32;\n-}\n-\n-struct Foo {\n-    foo: u32,\n-    bar: bool,\n-}\n-\n-impl Bar for Foo {\n-    fn bar(&self) -> u32 {\n-        self.foo\n-    }\n-}\n-\n-impl Drop for Foo {\n-    fn drop(&mut self) {\n-        assert!(!self.bar);\n-        self.bar = true;\n-        println!(\"dropping Foo\");\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-struct Fat<'a>(&'a Foo, &'static VTable);\n-\n-struct VTable {\n-    drop: Option<for<'a> fn(&'a mut Foo)>,\n-    size: usize,\n-    align: usize,\n-    bar: for<'a> fn(&'a Foo) -> u32,\n-}\n-\n-const FOO: &dyn Bar = &Foo { foo: 128, bar: false };\n-const G: Fat = unsafe { Transmute { t: FOO }.u };\n-const F: Option<for<'a> fn(&'a mut Foo)> = G.1.drop;\n-const H: for<'a> fn(&'a Foo) -> u32 = G.1.bar;\n-\n-fn main() {\n-    let mut foo = Foo { foo: 99, bar: false };\n-    (F.unwrap())(&mut foo);\n-    std::mem::forget(foo); // already ran the drop impl\n-    assert_eq!(H(&Foo { foo: 42, bar: false }), 42);\n-}"}, {"sha": "965256de21a0f4159ef66dd00635e42630d74fea", "filename": "src/test/ui/consts/const-eval/ub-incorrect-vtable.32bit.stderr", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.32bit.stderr?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -2,36 +2,58 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-incorrect-vtable.rs:19:14\n    |\n LL |     unsafe { std::mem::transmute((&92u8, &[0usize, 1usize, 1000usize])) };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid vtable: alignment `1000` is not a power of 2\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-incorrect-vtable.rs:24:14\n    |\n LL |     unsafe { std::mem::transmute((&92u8, &[1usize, usize::MAX, 1usize])) };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid vtable: size is bigger than largest supported object\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-incorrect-vtable.rs:34:1\n+  --> $DIR/ub-incorrect-vtable.rs:33:1\n    |\n LL | const INVALID_VTABLE_ALIGNMENT_UB: W<&dyn Trait> =\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid vtable: alignment `1000` is not a power of 2\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257e\u2500allocN\u2500\u257c \u257e\u2500allocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-incorrect-vtable.rs:39:1\n+  --> $DIR/ub-incorrect-vtable.rs:38:1\n    |\n LL | const INVALID_VTABLE_SIZE_UB: W<&dyn Trait> =\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid vtable: size is bigger than largest supported object\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257e\u2500allocN\u2500\u257c \u257e\u2500allocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n-error: aborting due to 4 previous errors\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-incorrect-vtable.rs:44:1\n+   |\n+LL | const INVALID_VTABLE_UB: W<&dyn Trait> =\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257e\u2500allocN\u2500\u257c \u257e\u2500allocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-incorrect-vtable.rs:91:1\n+   |\n+LL | const G: Wide = unsafe { Transmute { t: FOO }.u };\n+   | ^^^^^^^^^^^^^ constructing invalid value at .1: encountered a dangling reference (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257e\u2500allocN\u2500\u257c \u257e\u2500allocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "bd542a7a5f2933351c4c45ee9f6dca7550402ff9", "filename": "src/test/ui/consts/const-eval/ub-incorrect-vtable.64bit.stderr", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.64bit.stderr?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -2,36 +2,58 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-incorrect-vtable.rs:19:14\n    |\n LL |     unsafe { std::mem::transmute((&92u8, &[0usize, 1usize, 1000usize])) };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid vtable: alignment `1000` is not a power of 2\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-incorrect-vtable.rs:24:14\n    |\n LL |     unsafe { std::mem::transmute((&92u8, &[1usize, usize::MAX, 1usize])) };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid vtable: size is bigger than largest supported object\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-incorrect-vtable.rs:34:1\n+  --> $DIR/ub-incorrect-vtable.rs:33:1\n    |\n LL | const INVALID_VTABLE_ALIGNMENT_UB: W<&dyn Trait> =\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid vtable: alignment `1000` is not a power of 2\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-incorrect-vtable.rs:39:1\n+  --> $DIR/ub-incorrect-vtable.rs:38:1\n    |\n LL | const INVALID_VTABLE_SIZE_UB: W<&dyn Trait> =\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid vtable: size is bigger than largest supported object\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n-error: aborting due to 4 previous errors\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-incorrect-vtable.rs:44:1\n+   |\n+LL | const INVALID_VTABLE_UB: W<&dyn Trait> =\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-incorrect-vtable.rs:91:1\n+   |\n+LL | const G: Wide = unsafe { Transmute { t: FOO }.u };\n+   | ^^^^^^^^^^^^^ constructing invalid value at .1: encountered a dangling reference (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "4bb30b75bc8eb657fb6b0f21e093dbda598ed750", "filename": "src/test/ui/consts/const-eval/ub-incorrect-vtable.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -18,27 +18,79 @@ trait Trait {}\n const INVALID_VTABLE_ALIGNMENT: &dyn Trait =\n     unsafe { std::mem::transmute((&92u8, &[0usize, 1usize, 1000usize])) };\n //~^ ERROR evaluation of constant value failed\n-//~| invalid vtable: alignment `1000` is not a power of 2\n+//~| does not point to a vtable\n \n const INVALID_VTABLE_SIZE: &dyn Trait =\n     unsafe { std::mem::transmute((&92u8, &[1usize, usize::MAX, 1usize])) };\n //~^ ERROR evaluation of constant value failed\n-//~| invalid vtable: size is bigger than largest supported object\n+//~| does not point to a vtable\n \n #[repr(transparent)]\n struct W<T>(T);\n \n-// The drop fn is checked before size/align are, so get ourselves a \"sufficiently valid\" drop fn\n fn drop_me(_: *mut usize) {}\n \n const INVALID_VTABLE_ALIGNMENT_UB: W<&dyn Trait> =\n     unsafe { std::mem::transmute((&92u8, &(drop_me as fn(*mut usize), 1usize, 1000usize))) };\n //~^^ ERROR it is undefined behavior to use this value\n-//~| invalid vtable: alignment `1000` is not a power of 2\n+//~| expected a vtable pointer\n \n const INVALID_VTABLE_SIZE_UB: W<&dyn Trait> =\n     unsafe { std::mem::transmute((&92u8, &(drop_me as fn(*mut usize), usize::MAX, 1usize))) };\n //~^^ ERROR it is undefined behavior to use this value\n-//~| invalid vtable: size is bigger than largest supported object\n+//~| expected a vtable pointer\n+\n+// Even if the vtable has a fn ptr and a reasonable size+align, it still does not work.\n+const INVALID_VTABLE_UB: W<&dyn Trait> =\n+    unsafe { std::mem::transmute((&92u8, &(drop_me as fn(*mut usize), 1usize, 1usize))) };\n+//~^^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable pointer\n+\n+// Trying to access the data in a vtable does not work, either.\n+\n+#[derive(Copy, Clone)]\n+struct Wide<'a>(&'a Foo, &'static VTable);\n+\n+struct VTable {\n+    drop: Option<for<'a> fn(&'a mut Foo)>,\n+    size: usize,\n+    align: usize,\n+    bar: for<'a> fn(&'a Foo) -> u32,\n+}\n+\n+trait Bar {\n+    fn bar(&self) -> u32;\n+}\n+\n+struct Foo {\n+    foo: u32,\n+    bar: bool,\n+}\n+\n+impl Bar for Foo {\n+    fn bar(&self) -> u32 {\n+        self.foo\n+    }\n+}\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        assert!(!self.bar);\n+        self.bar = true;\n+        println!(\"dropping Foo\");\n+    }\n+}\n+\n+#[repr(C)]\n+union Transmute<T: Copy, U: Copy> {\n+    t: T,\n+    u: U,\n+}\n+\n+const FOO: &dyn Bar = &Foo { foo: 128, bar: false };\n+const G: Wide = unsafe { Transmute { t: FOO }.u };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| encountered a dangling reference\n+// (it is dangling because vtables do not contain memory that can be dereferenced)\n \n fn main() {}"}, {"sha": "ae114233c0f72a5fb4c7f5a19760dc4270edc07b", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -125,7 +125,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:56:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n@@ -147,7 +147,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:60:1\n    |\n LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0x0000000d, but expected a function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n@@ -158,7 +158,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:62:1\n    |\n LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered pointer to alloc41, but expected a function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered alloc41, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "1b93a869c0dd90d64e8cf8d14960789395e3565e", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -125,7 +125,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:56:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n@@ -147,7 +147,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:60:1\n    |\n LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0x000000000000000d, but expected a function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n@@ -158,7 +158,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:62:1\n    |\n LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered pointer to alloc41, but expected a function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered alloc41, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {"}, {"sha": "f7898e55ee2c53b894dbc44b164499b0ce6a8ffc", "filename": "src/test/ui/consts/const-eval/ub-upvars.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -6,7 +6,7 @@ LL | const BAD_UPVAR: &dyn FnOnce() = &{\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc3\u2500\u2500\u257c \u257e\u2500alloc6\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc3\u2500\u2500\u257c \u257e\u2500alloc4\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "60432380e134701aa483008725815e35a1302148", "filename": "src/test/ui/consts/const-eval/ub-upvars.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -6,7 +6,7 @@ LL | const BAD_UPVAR: &dyn FnOnce() = &{\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "345ead48151df10b481e67857bf63a0fc52b5230", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.32bit.stderr", "status": "modified", "additions": 27, "deletions": 52, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -209,81 +209,66 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:117:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:120:1\n+  --> $DIR/ub-wide-ptr.rs:121:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:123:1\n+  --> $DIR/ub-wide-ptr.rs:125:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered dangling vtable pointer in wide pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eallocN\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:125:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:128:57\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered unaligned vtable pointer in wide pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n-           }\n+   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:127:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:131:57\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid drop function pointer in vtable (not pointing to a function)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n-           }\n+   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:129:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:134:56\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid drop function pointer in vtable (not pointing to a function)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n-           }\n+   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:131:1\n+  --> $DIR/ub-wide-ptr.rs:137:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid drop function pointer in vtable (not pointing to a function)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:135:1\n+  --> $DIR/ub-wide-ptr.rs:142:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n@@ -293,39 +278,29 @@ LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_,\n                \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:139:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:147:62\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered dangling vtable pointer in wide pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c 00 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n-           }\n+   |                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:141:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:150:65\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered too small vtable\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n-           }\n+   |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:147:5\n+  --> $DIR/ub-wide-ptr.rs:157:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: null pointer is a dangling pointer (it has no provenance)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:151:5\n+  --> $DIR/ub-wide-ptr.rs:161:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: allocN has size N, so pointer to 12 bytes starting at offset N is out-of-bounds\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error: aborting due to 32 previous errors\n "}, {"sha": "501932cb95c6323a34b8d90614b87868b55dc757", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.64bit.stderr", "status": "modified", "additions": 27, "deletions": 52, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -209,81 +209,66 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:117:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:120:1\n+  --> $DIR/ub-wide-ptr.rs:121:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:123:1\n+  --> $DIR/ub-wide-ptr.rs:125:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered dangling vtable pointer in wide pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:125:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:128:57\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered unaligned vtable pointer in wide pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n+   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:127:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:131:57\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid drop function pointer in vtable (not pointing to a function)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n+   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:129:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:134:56\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid drop function pointer in vtable (not pointing to a function)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n+   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:131:1\n+  --> $DIR/ub-wide-ptr.rs:137:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid drop function pointer in vtable (not pointing to a function)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:135:1\n+  --> $DIR/ub-wide-ptr.rs:142:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n@@ -293,39 +278,29 @@ LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_,\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:139:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:147:62\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered dangling vtable pointer in wide pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n+   |                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:141:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:150:65\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered too small vtable\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n+   |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:147:5\n+  --> $DIR/ub-wide-ptr.rs:157:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: null pointer is a dangling pointer (it has no provenance)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:151:5\n+  --> $DIR/ub-wide-ptr.rs:161:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: allocN has size N, so pointer to 24 bytes starting at offset N is out-of-bounds\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error: aborting due to 32 previous errors\n "}, {"sha": "a0377ab1efd23b8c40d3e50c3439170613588934", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -116,30 +116,40 @@ const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n // bad trait object\n const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n //~^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable\n // bad trait object\n const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n //~^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable\n // bad trait object\n const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n //~^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable\n const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| does not point to a vtable\n const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| does not point to a vtable\n const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| does not point to a vtable\n const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n //~^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable\n \n // bad data *inside* the trait object\n const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n //~^ ERROR it is undefined behavior to use this value\n+//~| expected a boolean\n \n // # raw trait object\n const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| null pointer\n const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| does not point to a vtable\n const RAW_TRAIT_OBJ_CONTENT_INVALID: *const dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) } as *const dyn Trait; // ok because raw\n \n // Const eval fails for these, so they need to be statics to error."}, {"sha": "b8798a9755fe2b1b0055568a83e52f838857d37e", "filename": "src/test/ui/consts/issue-79690.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fissue-79690.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fissue-79690.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-79690.64bit.stderr?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -2,11 +2,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/issue-79690.rs:30:1\n    |\n LL | const G: Fat = unsafe { Transmute { t: FOO }.u };\n-   | ^^^^^^^^^^^^ constructing invalid value at .1.<deref>.size.foo: encountered (potentially part of) a pointer, but expected plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^ constructing invalid value at .1: encountered a dangling reference (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "7ea35f70d108eb35b8eee6f3909987557b8f721b", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.32bit.stderr?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -17,7 +17,7 @@ LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc7\u2500\u2500\u257c \u257e\u2500alloc9\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc7\u2500\u2500\u257c \u257e\u2500alloc8\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -28,7 +28,7 @@ LL | const BLUNT: &mut i32 = &mut 42;\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc11\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc10\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n warning: skipping const checks"}, {"sha": "5ad39893089090c4f4b1f1d6c5226fa1bd00db51", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.64bit.stderr?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -17,7 +17,7 @@ LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -28,7 +28,7 @@ LL | const BLUNT: &mut i32 = &mut 42;\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc11\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n warning: skipping const checks"}, {"sha": "dc3c17ac3144b5910525546e202766542fd4e174", "filename": "src/test/ui/traits/vtable/vtable-diamond.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-diamond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-diamond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-diamond.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -34,6 +34,11 @@ fn foo(d: &dyn D) {\n     d.foo_d();\n }\n \n+fn bar(d: &dyn C) {\n+    d.foo_c();\n+}\n+\n fn main() {\n     foo(&S);\n+    bar(&S);\n }"}, {"sha": "ebd55bcf39b176b66911d5d494a4087e2a33c785", "filename": "src/test/ui/traits/vtable/vtable-multi-level.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multi-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multi-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multi-level.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -12,6 +12,7 @@\n \n #[rustc_dump_vtable]\n trait A {\n+    //~^ error vtable\n     fn foo_a(&self) {}\n }\n \n@@ -23,6 +24,7 @@ trait B {\n \n #[rustc_dump_vtable]\n trait C: A + B {\n+    //~^ error vtable\n     fn foo_c(&self) {}\n }\n \n@@ -115,8 +117,27 @@ impl M for S {}\n impl N for S {}\n impl O for S {}\n \n-fn foo(_: &dyn O) {}\n+macro_rules! monomorphize_vtable {\n+    ($trait:ident) => {{\n+        fn foo(_ : &dyn $trait) {}\n+        foo(&S);\n+    }}\n+}\n \n fn main() {\n-    foo(&S);\n+    monomorphize_vtable!(O);\n+\n+    monomorphize_vtable!(A);\n+    monomorphize_vtable!(B);\n+    monomorphize_vtable!(C);\n+    monomorphize_vtable!(D);\n+    monomorphize_vtable!(E);\n+    monomorphize_vtable!(F);\n+    monomorphize_vtable!(H);\n+    monomorphize_vtable!(I);\n+    monomorphize_vtable!(J);\n+    monomorphize_vtable!(K);\n+    monomorphize_vtable!(L);\n+    monomorphize_vtable!(M);\n+    monomorphize_vtable!(N);\n }"}, {"sha": "c4389e23fc10fbc51fa60423cd76878e648a257a", "filename": "src/test/ui/traits/vtable/vtable-multi-level.stderr", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multi-level.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multi-level.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multi-level.stderr?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -29,29 +29,54 @@ error: vtable entries for `<S as O>`: [\n            TraitVPtr(<S as N>),\n            Method(<S as O>::foo_o),\n        ]\n-  --> $DIR/vtable-multi-level.rs:95:1\n+  --> $DIR/vtable-multi-level.rs:97:1\n    |\n LL | trait O: G + N {\n    | ^^^^^^^^^^^^^^\n \n+error: vtable entries for `<S as A>`: [\n+           MetadataDropInPlace,\n+           MetadataSize,\n+           MetadataAlign,\n+           Method(<S as A>::foo_a),\n+       ]\n+  --> $DIR/vtable-multi-level.rs:14:1\n+   |\n+LL | trait A {\n+   | ^^^^^^^\n+\n error: vtable entries for `<S as B>`: [\n            MetadataDropInPlace,\n            MetadataSize,\n            MetadataAlign,\n            Method(<S as B>::foo_b),\n        ]\n-  --> $DIR/vtable-multi-level.rs:19:1\n+  --> $DIR/vtable-multi-level.rs:20:1\n    |\n LL | trait B {\n    | ^^^^^^^\n \n+error: vtable entries for `<S as C>`: [\n+           MetadataDropInPlace,\n+           MetadataSize,\n+           MetadataAlign,\n+           Method(<S as A>::foo_a),\n+           Method(<S as B>::foo_b),\n+           TraitVPtr(<S as B>),\n+           Method(<S as C>::foo_c),\n+       ]\n+  --> $DIR/vtable-multi-level.rs:26:1\n+   |\n+LL | trait C: A + B {\n+   | ^^^^^^^^^^^^^^\n+\n error: vtable entries for `<S as D>`: [\n            MetadataDropInPlace,\n            MetadataSize,\n            MetadataAlign,\n            Method(<S as D>::foo_d),\n        ]\n-  --> $DIR/vtable-multi-level.rs:30:1\n+  --> $DIR/vtable-multi-level.rs:32:1\n    |\n LL | trait D {\n    | ^^^^^^^\n@@ -62,7 +87,7 @@ error: vtable entries for `<S as E>`: [\n            MetadataAlign,\n            Method(<S as E>::foo_e),\n        ]\n-  --> $DIR/vtable-multi-level.rs:36:1\n+  --> $DIR/vtable-multi-level.rs:38:1\n    |\n LL | trait E {\n    | ^^^^^^^\n@@ -76,7 +101,7 @@ error: vtable entries for `<S as F>`: [\n            TraitVPtr(<S as E>),\n            Method(<S as F>::foo_f),\n        ]\n-  --> $DIR/vtable-multi-level.rs:42:1\n+  --> $DIR/vtable-multi-level.rs:44:1\n    |\n LL | trait F: D + E {\n    | ^^^^^^^^^^^^^^\n@@ -87,7 +112,7 @@ error: vtable entries for `<S as H>`: [\n            MetadataAlign,\n            Method(<S as H>::foo_h),\n        ]\n-  --> $DIR/vtable-multi-level.rs:53:1\n+  --> $DIR/vtable-multi-level.rs:55:1\n    |\n LL | trait H {\n    | ^^^^^^^\n@@ -98,7 +123,7 @@ error: vtable entries for `<S as I>`: [\n            MetadataAlign,\n            Method(<S as I>::foo_i),\n        ]\n-  --> $DIR/vtable-multi-level.rs:59:1\n+  --> $DIR/vtable-multi-level.rs:61:1\n    |\n LL | trait I {\n    | ^^^^^^^\n@@ -112,7 +137,7 @@ error: vtable entries for `<S as J>`: [\n            TraitVPtr(<S as I>),\n            Method(<S as J>::foo_j),\n        ]\n-  --> $DIR/vtable-multi-level.rs:65:1\n+  --> $DIR/vtable-multi-level.rs:67:1\n    |\n LL | trait J: H + I {\n    | ^^^^^^^^^^^^^^\n@@ -123,7 +148,7 @@ error: vtable entries for `<S as K>`: [\n            MetadataAlign,\n            Method(<S as K>::foo_k),\n        ]\n-  --> $DIR/vtable-multi-level.rs:71:1\n+  --> $DIR/vtable-multi-level.rs:73:1\n    |\n LL | trait K {\n    | ^^^^^^^\n@@ -134,7 +159,7 @@ error: vtable entries for `<S as L>`: [\n            MetadataAlign,\n            Method(<S as L>::foo_l),\n        ]\n-  --> $DIR/vtable-multi-level.rs:77:1\n+  --> $DIR/vtable-multi-level.rs:79:1\n    |\n LL | trait L {\n    | ^^^^^^^\n@@ -148,7 +173,7 @@ error: vtable entries for `<S as M>`: [\n            TraitVPtr(<S as L>),\n            Method(<S as M>::foo_m),\n        ]\n-  --> $DIR/vtable-multi-level.rs:83:1\n+  --> $DIR/vtable-multi-level.rs:85:1\n    |\n LL | trait M: K + L {\n    | ^^^^^^^^^^^^^^\n@@ -169,10 +194,10 @@ error: vtable entries for `<S as N>`: [\n            TraitVPtr(<S as M>),\n            Method(<S as N>::foo_n),\n        ]\n-  --> $DIR/vtable-multi-level.rs:89:1\n+  --> $DIR/vtable-multi-level.rs:91:1\n    |\n LL | trait N: J + M {\n    | ^^^^^^^^^^^^^^\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 14 previous errors\n "}, {"sha": "7a0111c5ef2515c88215d1957a8456a91a45aa0e", "filename": "src/test/ui/traits/vtable/vtable-multiple.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fvtable-multiple.rs?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -25,7 +25,9 @@ impl B for S {}\n impl C for S {}\n \n fn foo(c: &dyn C) {}\n+fn bar(c: &dyn B) {}\n \n fn main() {\n     foo(&S);\n+    bar(&S);\n }"}]}