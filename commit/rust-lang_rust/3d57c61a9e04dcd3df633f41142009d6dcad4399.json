{"sha": "3d57c61a9e04dcd3df633f41142009d6dcad4399", "node_id": "C_kwDOAAsO6NoAKDNkNTdjNjFhOWUwNGRjZDNkZjYzM2Y0MTE0MjAwOWQ2ZGNhZDQzOTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-21T09:01:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-21T09:01:25Z"}, "message": "Auto merge of #92152 - matthiaskrgr:rollup-nmskpw6, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #90345 (Stabilise entry_insert)\n - #91412 (Improve suggestions for importing out-of-scope traits reexported as `_`)\n - #91770 (Suggest adding a `#[cfg(test)]` to to a test module)\n - #91823 (Make `PTR::as_ref` and similar methods `const`.)\n - #92127 (Move duplicates removal when generating results instead of when displaying them)\n - #92129 (JoinHandle docs: add missing 'the')\n - #92131 (Sync rustc_codegen_cranelift)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "cb2777e279adb1b6b1f6d38baa1e4b4782e142e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb2777e279adb1b6b1f6d38baa1e4b4782e142e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d57c61a9e04dcd3df633f41142009d6dcad4399", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d57c61a9e04dcd3df633f41142009d6dcad4399", "html_url": "https://github.com/rust-lang/rust/commit/3d57c61a9e04dcd3df633f41142009d6dcad4399", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d57c61a9e04dcd3df633f41142009d6dcad4399/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87e8639d8dd900ebdd79e9f0491ca4ae40944f02", "url": "https://api.github.com/repos/rust-lang/rust/commits/87e8639d8dd900ebdd79e9f0491ca4ae40944f02", "html_url": "https://github.com/rust-lang/rust/commit/87e8639d8dd900ebdd79e9f0491ca4ae40944f02"}, {"sha": "ee45a532f30dc8d6f373b952f09a265d979a2083", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee45a532f30dc8d6f373b952f09a265d979a2083", "html_url": "https://github.com/rust-lang/rust/commit/ee45a532f30dc8d6f373b952f09a265d979a2083"}], "stats": {"total": 2123, "additions": 1535, "deletions": 588}, "files": [{"sha": "7b73d3c00e60ef6ccdc68b053f8b92f20312ee29", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -65,6 +65,12 @@ jobs:\n         git config --global user.name \"User\"\n         ./y.rs prepare\n \n+    - name: Build without unstable features\n+      env:\n+        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n+      # This is the config rust-lang/rust uses for builds\n+      run: ./y.rs build --no-unstable-features\n+\n     - name: Build\n       run: ./y.rs build --sysroot none\n \n@@ -152,11 +158,12 @@ jobs:\n \n         ./y.exe build\n \n-    #- name: Package prebuilt cg_clif\n-    #  run: tar cvfJ cg_clif.tar.xz build\n+    - name: Package prebuilt cg_clif\n+      # don't use compression as xzip isn't supported by tar on windows and bzip2 hangs\n+      run: tar cvf cg_clif.tar build\n \n-    #- name: Upload prebuilt cg_clif\n-    #  uses: actions/upload-artifact@v2\n-    #  with:\n-    #    name: cg_clif-${{ runner.os }}\n-    #    path: cg_clif.tar.xz\n+    - name: Upload prebuilt cg_clif\n+      uses: actions/upload-artifact@v2\n+      with:\n+        name: cg_clif-${{ runner.os }}\n+        path: cg_clif.tar"}, {"sha": "c5b96a47828040ecb1b2d4f88590ac6eca009ed8", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/nightly-cranelift.yml", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -0,0 +1,59 @@\n+name: Test nightly Cranelift\n+\n+on:\n+  push:\n+  schedule:\n+    - cron: '1 17 * * *' # At 01:17 UTC every day.\n+\n+jobs:\n+  build:\n+    runs-on: ubuntu-latest\n+    timeout-minutes: 60\n+\n+    steps:\n+    - uses: actions/checkout@v2\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v2\n+      with:\n+        path: ~/.cargo/bin\n+        key: ubuntu-latest-cargo-installed-crates\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./y.rs prepare\n+\n+    - name: Patch Cranelift\n+      run: |\n+        sed -i 's/cranelift-codegen = { version = \"\\w*.\\w*.\\w*\", features = \\[\"unwind\", \"all-arch\"\\] }/cranelift-codegen = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\", features = [\"unwind\", \"all-arch\"] }/' Cargo.toml\n+        sed -i 's/cranelift-frontend = \"\\w*.\\w*.\\w*\"/cranelift-frontend = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\" }/' Cargo.toml\n+        sed -i 's/cranelift-module = \"\\w*.\\w*.\\w*\"/cranelift-module = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\" }/' Cargo.toml\n+        sed -i 's/cranelift-native = \"\\w*.\\w*.\\w*\"/cranelift-native = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\" }/' Cargo.toml\n+        sed -i 's/cranelift-jit = { version = \"\\w*.\\w*.\\w*\", optional = true }/cranelift-jit = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\", optional = true }/' Cargo.toml\n+        sed -i 's/cranelift-object = \"\\w*.\\w*.\\w*\"/cranelift-object = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\" }/' Cargo.toml\n+\n+        sed -i 's/gimli = { version = \"0.25.0\", default-features = false, features = \\[\"write\"\\]}/gimli = { version = \"0.26.1\", default-features = false, features = [\"write\"] }/' Cargo.toml\n+\n+        cat Cargo.toml\n+\n+    - name: Build without unstable features\n+      # This is the config rust-lang/rust uses for builds\n+      run: ./y.rs build --no-unstable-features\n+\n+    - name: Build\n+      run: ./y.rs build --sysroot none\n+    - name: Test\n+      run: |\n+        # Enable backtraces for easier debugging\n+        export RUST_BACKTRACE=1\n+\n+        # Reduce amount of benchmark runs as they are slow\n+        export COMPILE_RUNS=2\n+        export RUN_RUNS=2\n+\n+        # Enable extra checks\n+        export CG_CLIF_ENABLE_VERIFIER=1\n+\n+        ./test.sh"}, {"sha": "74fde9c27c0e47475e96f95fed6dd695fce4986f", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -5,6 +5,7 @@\n     \"rust-analyzer.assist.importEnforceGranularity\": true,\n     \"rust-analyzer.assist.importPrefix\": \"crate\",\n     \"rust-analyzer.cargo.runBuildScripts\": true,\n+    \"rust-analyzer.cargo.features\": [\"unstable-features\"]\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\",\n         //\"./build_sysroot/sysroot_src/src/libstd/Cargo.toml\","}, {"sha": "65e142a00f88ed0d127bddc675817da2d3cc2a68", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 48, "deletions": 38, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -4,9 +4,9 @@ version = 3\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.42\"\n+version = \"1.0.51\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"595d3cfa7a60d4555cb5067b99f07142a08ea778de5cf993f7b75c7d8fabc486\"\n+checksum = \"8b26702f315f53b6071259e15dd9d64528213b44d61de1ec926eca7715d62203\"\n \n [[package]]\n name = \"ar\"\n@@ -21,9 +21,9 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"bitflags\"\n-version = \"1.2.1\"\n+version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n+checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -33,16 +33,18 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.76.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n+version = \"0.78.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cc0cb7df82c8cf8f2e6a8dd394a0932a71369c160cc9b027dca414fced242513\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.76.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n+version = \"0.78.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fe4463c15fa42eee909e61e5eac4866b7c6d22d0d8c621e57a0c5380753bfa8c\"\n dependencies = [\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n@@ -57,27 +59,31 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.76.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n+version = \"0.78.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"793f6a94a053a55404ea16e1700202a88101672b8cd6b4df63e13cde950852bf\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.76.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n+version = \"0.78.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"44aa1846df275bce5eb30379d65964c7afc63c05a117076e62a119c25fe174be\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.76.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n+version = \"0.78.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a3a45d8d6318bf8fc518154d9298eab2a8154ec068a8885ff113f6db8d69bb3a\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.76.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n+version = \"0.78.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e07339bd461766deb7605169de039e01954768ff730fa1254e149001884a8525\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -87,8 +93,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.76.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n+version = \"0.78.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0e8f0d60fb5d67f7a1e5c49db38ba96d1c846921faef02085fc5590b74781747\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -104,8 +111,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.76.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n+version = \"0.78.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"825ac7e0959cbe7ddc9cc21209f0319e611a57f9fcb2b723861fe7ef2017e651\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -115,8 +123,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.76.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n+version = \"0.78.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"03e2fca76ff57e0532936a71e3fc267eae6a19a86656716479c66e7f912e3d7b\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -125,8 +134,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.76.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n+version = \"0.78.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"55500d0fc9bb05c0944fc4506649249d28f55bd4fe95b87f0e55bf41058f0e6d\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -138,9 +148,9 @@ dependencies = [\n \n [[package]]\n name = \"crc32fast\"\n-version = \"1.2.1\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"81156fece84ab6a9f2afdb109ce3ae577e42b1228441eded99bd77f627953b1a\"\n+checksum = \"738c290dfaea84fc1ca15ad9c168d083b05a714e1efddd8edaab678dc28d2836\"\n dependencies = [\n  \"cfg-if\",\n ]\n@@ -172,9 +182,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.98\"\n+version = \"0.2.112\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"320cfe77175da3a483efed4bc0adc1968ca050b098ce4f2f1c13a56626128790\"\n+checksum = \"1b03d17f364a3a042d5e5d46b053bbbf82c92c9430c592dd4c064dc6ee997125\"\n \n [[package]]\n name = \"libloading\"\n@@ -206,15 +216,15 @@ dependencies = [\n \n [[package]]\n name = \"memchr\"\n-version = \"2.4.0\"\n+version = \"2.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b16bd47d9e329435e309c58469fe0791c2d0d1ba96ec0954152a5ae2b04387dc\"\n+checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n \n [[package]]\n name = \"object\"\n-version = \"0.26.0\"\n+version = \"0.27.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c55827317fb4c08822499848a14237d2874d6f139828893017237e7ab93eb386\"\n+checksum = \"67ac1d3f9a1d3616fd9a60c8d74296f22406a238b6a72f5cc1e6f314df4ffbf9\"\n dependencies = [\n  \"crc32fast\",\n  \"indexmap\",\n@@ -223,9 +233,9 @@ dependencies = [\n \n [[package]]\n name = \"regalloc\"\n-version = \"0.0.31\"\n+version = \"0.0.32\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"571f7f397d61c4755285cd37853fe8e03271c243424a907415909379659381c5\"\n+checksum = \"a6304468554ed921da3d32c355ea107b8d13d7b8996c3adfb7aab48d3bc321f4\"\n dependencies = [\n  \"log\",\n  \"rustc-hash\",\n@@ -271,15 +281,15 @@ dependencies = [\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.6.1\"\n+version = \"1.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fe0f37c9e8f3c5a4a66ad655a93c74daac4ad00c441533bf5c6e7990bb42604e\"\n+checksum = \"1ecab6c735a6bb4139c0caafd0cc3635748bbb3acf4550e8138122099251f309\"\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.12.1\"\n+version = \"0.12.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b0652da4c4121005e9ed22b79f6c5f2d9e2752906b53a33e9490489ba421a6fb\"\n+checksum = \"d9bffcddbc2458fa3e6058414599e3c838a022abae82e5c67b4f7f80298d5bff\"\n \n [[package]]\n name = \"winapi\""}, {"sha": "900411286b52ec0855a599fb45ed588e61d6aec1", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -8,31 +8,30 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime.git\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime.git\" }\n-cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime.git\" }\n-cranelift-native = { git = \"https://github.com/bytecodealliance/wasmtime.git\" }\n-cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime.git\", optional = true }\n-cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime.git\" }\n+cranelift-codegen = { version = \"0.78.0\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = \"0.78.0\"\n+cranelift-module = \"0.78.0\"\n+cranelift-native = \"0.78.0\"\n+cranelift-jit = { version = \"0.78.0\", optional = true }\n+cranelift-object = \"0.78.0\"\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.25.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.26.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.27.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.0.2\"\n libloading = { version = \"0.6.0\", optional = true }\n smallvec = \"1.6.1\"\n \n+[patch.crates-io]\n # Uncomment to use local checkout of cranelift\n-#[patch.\"https://github.com/bytecodealliance/wasmtime.git\"]\n #cranelift-codegen = { path = \"../wasmtime/cranelift/codegen\" }\n #cranelift-frontend = { path = \"../wasmtime/cranelift/frontend\" }\n #cranelift-module = { path = \"../wasmtime/cranelift/module\" }\n #cranelift-native = { path = \"../wasmtime/cranelift/native\" }\n #cranelift-jit = { path = \"../wasmtime/cranelift/jit\" }\n #cranelift-object = { path = \"../wasmtime/cranelift/object\" }\n \n-#[patch.crates-io]\n #gimli = { path = \"../\" }\n \n [features]"}, {"sha": "dd09656248022bf40e868c4f9c8800776bb460b6", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -40,9 +40,9 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.70\"\n+version = \"1.0.72\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d26a6ce4b6a484fa3edb70f7efa6fc430fd2b87285fe8b84304fd0936faa0dc0\"\n+checksum = \"22a9137b95ea06864e018375b72adfb7db6e6f68cfc8df5a04d00288050485ee\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -56,7 +56,7 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.50\"\n+version = \"0.1.66\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -67,9 +67,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"dlmalloc\"\n-version = \"0.2.1\"\n+version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"332570860c2edf2d57914987bf9e24835425f75825086b6ba7d1e6a3e4f1f254\"\n+checksum = \"a6fe28e0bf9357092740362502f5cc7955d8dc125ebda71dec72336c2e15c62e\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -132,9 +132,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.102\"\n+version = \"0.2.112\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2a5ac8f984bfcf3a823267e5fde638acc3325f6496633a5da6bb6eb2171e103\"\n+checksum = \"1b03d17f364a3a042d5e5d46b053bbbf82c92c9430c592dd4c064dc6ee997125\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "ccc50ee4a59bf57544459befa117c5acf5048121", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -2,9 +2,17 @@ use std::env;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n-pub(crate) fn build_backend(channel: &str, host_triple: &str) -> PathBuf {\n+pub(crate) fn build_backend(\n+    channel: &str,\n+    host_triple: &str,\n+    use_unstable_features: bool,\n+) -> PathBuf {\n     let mut cmd = Command::new(\"cargo\");\n-    cmd.arg(\"build\").arg(\"--target\").arg(host_triple).arg(\"--features\").arg(\"unstable-features\");\n+    cmd.arg(\"build\").arg(\"--target\").arg(host_triple);\n+\n+    if use_unstable_features {\n+        cmd.arg(\"--features\").arg(\"unstable-features\");\n+    }\n \n     match channel {\n         \"debug\" => {}"}, {"sha": "1c78e7b5171ee228f7d6463686ae5d085fb54e44", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -193,8 +193,7 @@ fn build_clif_sysroot_for_triple(\n         \"RUSTC\",\n         env::current_dir().unwrap().join(target_dir).join(\"bin\").join(\"cg_clif_build_sysroot\"),\n     );\n-    // FIXME Enable incremental again once rust-lang/rust#74946 is fixed\n-    build_cmd.env(\"CARGO_INCREMENTAL\", \"0\").env(\"__CARGO_DEFAULT_LIB_METADATA\", \"cg_clif\");\n+    build_cmd.env(\"__CARGO_DEFAULT_LIB_METADATA\", \"cg_clif\");\n     spawn_and_wait(build_cmd);\n \n     // Copy all relevant files to the sysroot"}, {"sha": "561e2ed7b001732fa634f03b4f45d52f5922353c", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn prepare() {\n     clone_repo(\n         \"portable-simd\",\n         \"https://github.com/rust-lang/portable-simd\",\n-        \"8cf7a62e5d2552961df51e5200aaa5b7c890a4bf\",\n+        \"b8d6b6844602f80af79cd96401339ec594d472d8\",\n     );\n     apply_patches(\"portable-simd\", Path::new(\"portable-simd\"));\n \n@@ -92,7 +92,7 @@ fn prepare_sysroot() {\n     clone_repo(\n         \"build_sysroot/compiler-builtins\",\n         \"https://github.com/rust-lang/compiler-builtins.git\",\n-        \"0.1.50\",\n+        \"0.1.66\",\n     );\n     apply_patches(\"compiler-builtins\", Path::new(\"build_sysroot/compiler-builtins\"));\n }"}, {"sha": "cf8fada5320f96ab654a8468125639ed98c1eb55", "filename": "compiler/rustc_codegen_cranelift/example/issue-91827-extern-types.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -0,0 +1,60 @@\n+// Copied from rustc ui test suite\n+\n+// run-pass\n+//\n+// Test that we can handle unsized types with an extern type tail part.\n+// Regression test for issue #91827.\n+\n+#![feature(const_ptr_offset_from)]\n+#![feature(const_slice_from_raw_parts)]\n+#![feature(extern_types)]\n+\n+use std::ptr::addr_of;\n+\n+extern \"C\" {\n+    type Opaque;\n+}\n+\n+unsafe impl Sync for Opaque {}\n+\n+#[repr(C)]\n+pub struct List<T> {\n+    len: usize,\n+    data: [T; 0],\n+    tail: Opaque,\n+}\n+\n+#[repr(C)]\n+pub struct ListImpl<T, const N: usize> {\n+    len: usize,\n+    data: [T; N],\n+}\n+\n+impl<T> List<T> {\n+    const fn as_slice(&self) -> &[T] {\n+        unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len) }\n+    }\n+}\n+\n+impl<T, const N: usize> ListImpl<T, N> {\n+    const fn as_list(&self) -> &List<T> {\n+        unsafe { std::mem::transmute(self) }\n+    }\n+}\n+\n+pub static A: ListImpl<u128, 3> = ListImpl {\n+    len: 3,\n+    data: [5, 6, 7],\n+};\n+pub static A_REF: &'static List<u128> = A.as_list();\n+pub static A_TAIL_OFFSET: isize = tail_offset(A.as_list());\n+\n+const fn tail_offset<T>(list: &List<T>) -> isize {\n+    unsafe { (addr_of!(list.tail) as *const u8).offset_from(list as *const List<T> as *const u8) }\n+}\n+\n+fn main() {\n+    assert_eq!(A_REF.as_slice(), &[5, 6, 7]);\n+    // Check that interpreter and code generation agree about the position of the tail field.\n+    assert_eq!(A_TAIL_OFFSET, tail_offset(A_REF));\n+}"}, {"sha": "c13259086917b9c8e996dd8b88d7a142137a0bc5", "filename": "compiler/rustc_codegen_cranelift/patches/0001-portable-simd-Disable-unsupported-tests.patch", "status": "modified", "additions": 78, "deletions": 87, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -1,152 +1,143 @@\n-From 6bfce5dc2cbf834c74dbccb7538adc08c6eb57e7 Mon Sep 17 00:00:00 2001\n+From 97c473937382a5b5858d9cce3c947855d23b2dc5 Mon Sep 17 00:00:00 2001\n From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Sun, 25 Jul 2021 18:39:31 +0200\n+Date: Thu, 18 Nov 2021 19:28:40 +0100\n Subject: [PATCH] Disable unsupported tests\n \n ---\n- crates/core_simd/src/vector.rs        |  2 ++\n- crates/core_simd/src/math.rs         |  4 ++++\n- crates/core_simd/tests/masks.rs      | 12 ------------\n- crates/core_simd/tests/ops_macros.rs |  6 ++++++\n- crates/core_simd/tests/round.rs      |  2 ++\n- 6 files changed, 15 insertions(+), 13 deletions(-)\n+ crates/core_simd/src/math.rs         | 6 ++++++\n+ crates/core_simd/src/vector.rs       | 2 ++\n+ crates/core_simd/tests/masks.rs      | 2 ++\n+ crates/core_simd/tests/ops_macros.rs | 4 ++++\n+ 4 files changed, 14 insertions(+)\n \n-diff --git a/crates/core_simd/src/vector.rs b/crates/core_simd/src/vector.rs\n-index 25c5309..2b3d819 100644\n---- a/crates/core_simd/src/vector.rs\n-+++ b/crates/core_simd/src/vector.rs\n-@@ -22,6 +22,7 @@ where\n-         self.0\n-     }\n- \n-+    /*\n-     /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-     /// If an index is out of bounds, that lane instead selects the value from the \"or\" vector.\n-     /// ```\n-@@ -150,6 +151,7 @@ where\n-             // Cleared \u2622\ufe0f *mut T Zone\n-         }\n-     }\n-+    */\n- }\n- \n- impl<T, const LANES: usize> Copy for Simd<T, LANES>\n diff --git a/crates/core_simd/src/math.rs b/crates/core_simd/src/math.rs\n-index 7290a28..e394730 100644\n+index 2bae414..2f87499 100644\n --- a/crates/core_simd/src/math.rs\n +++ b/crates/core_simd/src/math.rs\n-@@ -2,6 +2,7 @@ macro_rules! impl_uint_arith {\n+@@ -5,6 +5,7 @@ macro_rules! impl_uint_arith {\n      ($($ty:ty),+) => {\n          $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n  \n +            /*\n              /// Lanewise saturating add.\n              ///\n              /// # Examples\n-@@ -38,6 +39,7 @@ macro_rules! impl_uint_arith {\n+@@ -43,6 +44,7 @@ macro_rules! impl_uint_arith {\n              pub fn saturating_sub(self, second: Self) -> Self {\n-                 unsafe { crate::intrinsics::simd_saturating_sub(self, second) }\n+                 unsafe { simd_saturating_sub(self, second) }\n              }\n +            */\n          })+\n      }\n  }\n-@@ -46,6 +48,7 @@ macro_rules! impl_int_arith {\n+@@ -51,6 +53,7 @@ macro_rules! impl_int_arith {\n      ($($ty:ty),+) => {\n          $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n  \n +            /*\n              /// Lanewise saturating add.\n              ///\n              /// # Examples\n-@@ -141,6 +144,7 @@ macro_rules! impl_int_arith {\n+@@ -89,6 +92,7 @@ macro_rules! impl_int_arith {\n+             pub fn saturating_sub(self, second: Self) -> Self {\n+                 unsafe { simd_saturating_sub(self, second) }\n+             }\n++            */\n+ \n+             /// Lanewise absolute value, implemented in Rust.\n+             /// Every lane becomes its absolute value.\n+@@ -109,6 +113,7 @@ macro_rules! impl_int_arith {\n+                 (self^m) - m\n+             }\n+ \n++            /*\n+             /// Lanewise saturating absolute value, implemented in Rust.\n+             /// As abs(), except the MIN value becomes MAX instead of itself.\n+             ///\n+@@ -151,6 +156,7 @@ macro_rules! impl_int_arith {\n              pub fn saturating_neg(self) -> Self {\n                  Self::splat(0).saturating_sub(self)\n              }\n +            */\n          })+\n      }\n  }\n+diff --git a/crates/core_simd/src/vector.rs b/crates/core_simd/src/vector.rs\n+index 7c5ec2b..c8631e8 100644\n+--- a/crates/core_simd/src/vector.rs\n++++ b/crates/core_simd/src/vector.rs\n+@@ -75,6 +75,7 @@ where\n+         Self(array)\n+     }\n+ \n++    /*\n+     /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n+     /// If an index is out-of-bounds, the lane is instead selected from the `or` vector.\n+     ///\n+@@ -297,6 +298,7 @@ where\n+             // Cleared \u2622\ufe0f *mut T Zone\n+         }\n+     }\n++    */\n+ }\n+ \n+ impl<T, const LANES: usize> Copy for Simd<T, LANES>\n diff --git a/crates/core_simd/tests/masks.rs b/crates/core_simd/tests/masks.rs\n-index 61d8e44..2bccae2 100644\n+index 6a8ecd3..68fcb49 100644\n --- a/crates/core_simd/tests/masks.rs\n +++ b/crates/core_simd/tests/masks.rs\n-@@ -67,19 +67,6 @@ macro_rules! test_mask_api {\n-                 assert_eq!(int.to_array(), [-1, 0, 0, -1, 0, 0, -1, 0]);\n+@@ -68,6 +68,7 @@ macro_rules! test_mask_api {\n                  assert_eq!(core_simd::Mask::<$type, 8>::from_int(int), mask);\n              }\n--\n--            #[cfg(feature = \"generic_const_exprs\")]\n--            #[test]\n--            fn roundtrip_bitmask_conversion() {\n--                let values = [\n--                    true, false, false, true, false, false, true, false,\n--                    true, true, false, false, false, false, false, true,\n--                ];\n--                let mask = core_simd::Mask::<$type, 16>::from_array(values);\n--                let bitmask = mask.to_bitmask();\n--                assert_eq!(bitmask, [0b01001001, 0b10000011]);\n--                assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n--            }\n+ \n++            /*\n+             #[cfg(feature = \"generic_const_exprs\")]\n+             #[test]\n+             fn roundtrip_bitmask_conversion() {\n+@@ -80,6 +81,7 @@ macro_rules! test_mask_api {\n+                 assert_eq!(bitmask, [0b01001001, 0b10000011]);\n+                 assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n+             }\n++            */\n          }\n      }\n  }\n diff --git a/crates/core_simd/tests/ops_macros.rs b/crates/core_simd/tests/ops_macros.rs\n-index cb39e73..fc0ebe1 100644\n+index 31b7ee2..bd04b3c 100644\n --- a/crates/core_simd/tests/ops_macros.rs\n +++ b/crates/core_simd/tests/ops_macros.rs\n-@@ -435,6 +435,7 @@ macro_rules! impl_float_tests {\n-                     )\n-                 }\n- \n-+                /*\n-                 fn mul_add<const LANES: usize>() {\n-                     test_helpers::test_ternary_elementwise(\n-                         &Vector::<LANES>::mul_add,\n-@@ -442,6 +443,7 @@ macro_rules! impl_float_tests {\n-                         &|_, _, _| true,\n-                     )\n-                 }\n-+                */\n- \n-                 fn recip<const LANES: usize>() {\n-                     test_helpers::test_unary_elementwise(\n-@@ -581,6 +585,7 @@ macro_rules! impl_float_tests {\n+@@ -567,6 +567,7 @@ macro_rules! impl_float_tests {\n                      });\n                  }\n  \n +                /*\n                  fn horizontal_max<const LANES: usize>() {\n                      test_helpers::test_1(&|x| {\n                          let vmax = Vector::<LANES>::from_array(x).horizontal_max();\n-@@ -604,6 +609,7 @@ macro_rules! impl_float_tests {\n+@@ -590,6 +591,7 @@ macro_rules! impl_float_tests {\n                          Ok(())\n                      });\n                  }\n +                */\n              }\n  \n              #[cfg(feature = \"std\")]\n-diff --git a/crates/core_simd/tests/round.rs b/crates/core_simd/tests/round.rs\n-index 37044a7..4cdc6b7 100644\n---- a/crates/core_simd/tests/round.rs\n-+++ b/crates/core_simd/tests/round.rs\n-@@ -25,6 +25,7 @@ macro_rules! float_rounding_test {\n-                     )\n-                 }\n+@@ -604,6 +606,7 @@ macro_rules! impl_float_tests {\n+                         )\n+                     }\n  \n-+                /*\n-                 fn round<const LANES: usize>() {\n-                     test_helpers::test_unary_elementwise(\n-                         &Vector::<LANES>::round,\n-@@ -32,6 +33,7 @@ macro_rules! float_rounding_test {\n-                         &|_| true,\n-                     )\n++                    /*\n+                     fn mul_add<const LANES: usize>() {\n+                         test_helpers::test_ternary_elementwise(\n+                             &Vector::<LANES>::mul_add,\n+@@ -611,6 +614,7 @@ macro_rules! impl_float_tests {\n+                             &|_, _, _| true,\n+                         )\n+                     }\n++                    */\n                  }\n-+                */\n- \n-                 fn trunc<const LANES: usize>() {\n-                     test_helpers::test_unary_elementwise(\n+             }\n+         }\n -- \n 2.26.2.7.g19db9cfb68\n "}, {"sha": "ffee641457ab2a35b655cd9653a0b8b1d27dd54f", "filename": "compiler/rustc_codegen_cranelift/patches/0027-sysroot-128bit-atomic-operations.patch", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -107,7 +107,7 @@ index fa96b7a..2854f9c 100644\n      inner::monotonize(raw)\n  }\n  \n--#[cfg(all(target_has_atomic = \"64\", not(target_has_atomic = \"128\")))]\n+-#[cfg(any(all(target_has_atomic = \"64\", not(target_has_atomic = \"128\")), target_arch = \"aarch64\"))]\n +#[cfg(target_has_atomic = \"64\")]\n  pub mod inner {\n      use crate::sync::atomic::AtomicU64;\n@@ -117,7 +117,7 @@ index fa96b7a..2854f9c 100644\n  }\n  \n +/*\n- #[cfg(target_has_atomic = \"128\")]\n+ #[cfg(all(target_has_atomic = \"128\", not(target_arch = \"aarch64\")))]\n  pub mod inner {\n      use crate::sync::atomic::AtomicU128;\n @@ -94,8 +95,9 @@ pub mod inner {"}, {"sha": "bf74a74c7c4b8dd44ede03324d707a3bd89acfa2", "filename": "compiler/rustc_codegen_cranelift/patches/0028-sysroot-Disable-long-running-tests.patch", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-sysroot-Disable-long-running-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-sysroot-Disable-long-running-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-sysroot-Disable-long-running-tests.patch?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -0,0 +1,30 @@\n+From 0ffdd8eda8df364391c8ac6e1ce92c73ba9254d4 Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Fri, 3 Dec 2021 12:16:30 +0100\n+Subject: [PATCH] Disable long running tests\n+\n+---\n+ library/core/tests/slice.rs | 3 +++\n+ 1 file changed, 3 insertions(+)\n+\n+diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n+index 2c8f00a..44847ee 100644\n+--- a/library/core/tests/slice.rs\n++++ b/library/core/tests/slice.rs\n+@@ -2332,7 +2332,8 @@ macro_rules! empty_max_mut {\n+     };\n+ }\n+ \n++/*\n+ #[cfg(not(miri))] // Comparing usize::MAX many elements takes forever in Miri (and in rustc without optimizations)\n+ take_tests! {\n+     slice: &[(); usize::MAX], method: take,\n+     (take_in_bounds_max_range_to, (..usize::MAX), Some(EMPTY_MAX), &[(); 0]),\n+@@ -2345,3 +2347,4 @@ take_tests! {\n+     (take_mut_oob_max_range_to_inclusive, (..=usize::MAX), None, empty_max_mut!()),\n+     (take_mut_in_bounds_max_range_from, (usize::MAX..), Some(&mut [] as _), empty_max_mut!()),\n+ }\n++*/\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "7b5db307a2dc26c1ea5e6e56c02431640b98e6c1", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-09-19\"\n+channel = \"nightly-2021-12-20\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "46c3b5b7f11adf890e5b4b27e321762ca792a096", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -33,7 +33,7 @@ index d95b5b7f17f..00b6f0e3635 100644\n  [dependencies]\n  core = { path = \"../core\" }\n -compiler_builtins = { version = \"0.1.40\", features = ['rustc-dep-of-std'] }\n-+compiler_builtins = { version = \"0.1.46\", features = ['rustc-dep-of-std', 'no-asm'] }\n++compiler_builtins = { version = \"0.1.66\", features = ['rustc-dep-of-std', 'no-asm'] }\n \n  [dev-dependencies]\n  rand = \"0.7\"\n@@ -53,5 +53,6 @@ local-rebuild = true\n [rust]\n codegen-backends = [\"cranelift\"]\n deny-warnings = false\n+verbose-tests = false\n EOF\n popd"}, {"sha": "99fddf5361e43e3928e248013a460bf254a43fd5", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -10,7 +10,7 @@ pushd rust\n \n cargo install ripgrep\n \n-rm -r src/test/ui/{extern/,panics/,unsized-locals/,thinlto/,simd*,*lto*.rs,linkage*,unwind-*.rs} || true\n+rm -r src/test/ui/{extern/,panics/,unsized-locals/,lto/,simd*,linkage*,unwind-*.rs} || true\n for test in $(rg --files-with-matches \"asm!|catch_unwind|should_panic|lto|// needs-asm-support\" src/test/ui); do\n   rm $test\n done\n@@ -30,19 +30,20 @@ rm src/test/ui/cleanup-rvalue-temp-during-incomplete-alloc.rs\n rm src/test/ui/issues/issue-26655.rs\n rm src/test/ui/issues/issue-29485.rs\n rm src/test/ui/issues/issue-30018-panic.rs\n-rm src/test/ui/multi-panic.rs\n+rm src/test/ui/process/multi-panic.rs\n rm src/test/ui/sepcomp/sepcomp-unwind.rs\n rm src/test/ui/structs-enums/unit-like-struct-drop-run.rs\n-rm src/test/ui/terminate-in-initializer.rs\n+rm src/test/ui/drop/terminate-in-initializer.rs\n rm src/test/ui/threads-sendsync/task-stderr.rs\n rm src/test/ui/numbers-arithmetic/int-abs-overflow.rs\n rm src/test/ui/drop/drop-trait-enum.rs\n rm src/test/ui/numbers-arithmetic/issue-8460.rs\n-rm src/test/ui/rt-explody-panic-payloads.rs\n+rm src/test/ui/runtime/rt-explody-panic-payloads.rs\n rm src/test/incremental/change_crate_dep_kind.rs\n+rm src/test/ui/threads-sendsync/unwind-resource.rs\n \n rm src/test/ui/issues/issue-28950.rs # depends on stack size optimizations\n-rm src/test/ui/init-large-type.rs # same\n+rm src/test/ui/codegen/init-large-type.rs # same\n rm src/test/ui/sse2.rs # cpuid not supported, so sse2 not detected\n rm src/test/ui/issues/issue-33992.rs # unsupported linkages\n rm src/test/ui/issues/issue-51947.rs # same\n@@ -65,6 +66,7 @@ rm src/test/incremental/lto.rs # requires lto\n \n rm -r src/test/run-make/emit-shared-files # requires the rustdoc executable in build/bin/\n rm -r src/test/run-make/unstable-flag-required # same\n+rm -r src/test/run-make/rustdoc-* # same\n rm -r src/test/run-make/emit-named-files # requires full --emit support\n \n rm src/test/pretty/asm.rs # inline asm\n@@ -74,7 +76,10 @@ rm -r src/test/run-pass-valgrind/unsized-locals\n \n rm src/test/ui/json-bom-plus-crlf-multifile.rs # differing warning\n rm src/test/ui/json-bom-plus-crlf.rs # same\n+rm src/test/ui/intrinsics/const-eval-select-x86_64.rs # same\n rm src/test/ui/match/issue-82392.rs # differing error\n+rm src/test/ui/consts/min_const_fn/address_of_const.rs # same\n+rm src/test/ui/consts/issue-miri-1910.rs # same\n rm src/test/ui/type-alias-impl-trait/cross_crate_ice*.rs # requires removed aux dep\n \n rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition\n@@ -88,6 +93,10 @@ rm -r src/test/run-make/fmt-write-bloat/ # tests an optimization\n rm src/test/ui/abi/mir/mir_codegen_calls_variadic.rs # requires float varargs\n rm src/test/ui/abi/variadic-ffi.rs # requires callee side vararg support\n \n+rm src/test/ui/command/command-current-dir.rs # can't find libstd.so\n+\n+rm src/test/ui/abi/stack-protector.rs # requires stack protector support\n+\n echo \"[TEST] rustc test suite\"\n RUST_TEST_NOCAPTURE=1 COMPILETEST_FORCE_STAGE0=1 ./x.py test --stage 0 src/test/{codegen-units,run-make,run-pass-valgrind,ui}\n popd"}, {"sha": "fd2b3761ff0364da4aeb6ceca1c607a0d6015c61", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -35,6 +35,10 @@ function base_sysroot_tests() {\n     $MY_RUSTC example/arbitrary_self_types_pointers_and_wrappers.rs --crate-name arbitrary_self_types_pointers_and_wrappers --crate-type bin --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/arbitrary_self_types_pointers_and_wrappers\n \n+    echo \"[AOT] issue_91827_extern_types\"\n+    $MY_RUSTC example/issue-91827-extern-types.rs --crate-name issue_91827_extern_types --crate-type bin --target \"$TARGET_TRIPLE\"\n+    $RUN_WRAPPER ./target/out/issue_91827_extern_types\n+\n     echo \"[AOT] alloc_system\"\n     $MY_RUSTC example/alloc_system.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n "}, {"sha": "72ebc84c1a3443d56f5a8c0a5d27658ac2bc6411", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -18,11 +18,11 @@ pub(crate) use self::returning::codegen_return;\n \n fn clif_sig_from_fn_abi<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    triple: &target_lexicon::Triple,\n+    default_call_conv: CallConv,\n     fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n ) -> Signature {\n     let call_conv = match fn_abi.conv {\n-        Conv::Rust | Conv::C => CallConv::triple_default(triple),\n+        Conv::Rust | Conv::C => default_call_conv,\n         Conv::X86_64SysV => CallConv::SystemV,\n         Conv::X86_64Win64 => CallConv::WindowsFastcall,\n         Conv::ArmAapcs\n@@ -55,7 +55,7 @@ pub(crate) fn get_function_sig<'tcx>(\n     assert!(!inst.substs.needs_infer());\n     clif_sig_from_fn_abi(\n         tcx,\n-        triple,\n+        CallConv::triple_default(triple),\n         &RevealAllLayoutCx(tcx).fn_abi_of_instance(inst, ty::List::empty()),\n     )\n }\n@@ -91,7 +91,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         returns: Vec<AbiParam>,\n         args: &[Value],\n     ) -> &[Value] {\n-        let sig = Signature { params, returns, call_conv: CallConv::triple_default(self.triple()) };\n+        let sig = Signature { params, returns, call_conv: self.target_config.default_call_conv };\n         let func_id = self.module.declare_function(name, Linkage::Import, &sig).unwrap();\n         let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n@@ -420,7 +420,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             }\n \n             let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0].value, idx);\n-            let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n+            let sig = clif_sig_from_fn_abi(fx.tcx, fx.target_config.default_call_conv, &fn_abi);\n             let sig = fx.bcx.import_signature(sig);\n \n             (CallTarget::Indirect(sig, method), Some(ptr))\n@@ -440,7 +440,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             }\n \n             let func = codegen_operand(fx, func).load_scalar(fx);\n-            let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n+            let sig = clif_sig_from_fn_abi(fx.tcx, fx.target_config.default_call_conv, &fn_abi);\n             let sig = fx.bcx.import_signature(sig);\n \n             (CallTarget::Indirect(sig, func), None)\n@@ -531,7 +531,7 @@ pub(crate) fn codegen_drop<'tcx>(\n                 let fn_abi =\n                     RevealAllLayoutCx(fx.tcx).fn_abi_of_instance(virtual_drop, ty::List::empty());\n \n-                let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n+                let sig = clif_sig_from_fn_abi(fx.tcx, fx.target_config.default_call_conv, &fn_abi);\n                 let sig = fx.bcx.import_signature(sig);\n                 fx.bcx.ins().call_indirect(sig, drop_fn, &[ptr]);\n             }"}, {"sha": "9f0bd31e95fcc47a162066fd13c4127f61137305", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -117,7 +117,9 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n             PassMode::Indirect { attrs, extra_attrs: None, on_stack } => {\n                 if on_stack {\n-                    let size = u32::try_from(self.layout.size.bytes()).unwrap();\n+                    // Abi requires aligning struct size to pointer size\n+                    let size = self.layout.size.align_to(tcx.data_layout.pointer_align.abi);\n+                    let size = u32::try_from(size.bytes()).unwrap();\n                     smallvec![apply_arg_attrs_to_abi_param(\n                         AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructArgument(size),),\n                         attrs\n@@ -204,7 +206,6 @@ pub(super) fn from_casted_value<'tcx>(\n         // It may also be smaller for example when the type is a wrapper around an integer with a\n         // larger alignment than the integer.\n         size: (std::cmp::max(abi_param_size, layout_size) + 15) / 16 * 16,\n-        offset: None,\n     });\n     let ptr = Pointer::new(fx.bcx.ins().stack_addr(pointer_ty(fx.tcx), stack_slot, 0));\n     let mut offset = 0;"}, {"sha": "b0eb3864d80c82e5c44e4c749746447bcd678447", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -1,7 +1,6 @@\n //! Creation of ar archives like for the lib and staticlib crate type\n \n use std::collections::BTreeMap;\n-use std::convert::TryFrom;\n use std::fs::File;\n use std::io::{self, Read, Seek};\n use std::path::{Path, PathBuf};\n@@ -10,7 +9,7 @@ use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n use rustc_session::Session;\n \n use object::read::archive::ArchiveFile;\n-use object::{Object, ObjectSymbol, ReadCache, SymbolKind};\n+use object::{Object, ObjectSymbol, ReadCache};\n \n #[derive(Debug)]\n enum ArchiveEntry {\n@@ -150,12 +149,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                             object\n                                 .symbols()\n                                 .filter_map(|symbol| {\n-                                    if symbol.is_undefined()\n-                                        || symbol.is_local()\n-                                        || symbol.kind() != SymbolKind::Data\n-                                            && symbol.kind() != SymbolKind::Text\n-                                            && symbol.kind() != SymbolKind::Tls\n-                                    {\n+                                    if symbol.is_undefined() || symbol.is_local() {\n                                         None\n                                     } else {\n                                         symbol.name().map(|name| name.as_bytes().to_vec()).ok()"}, {"sha": "fc2f04f146e9d3d52deec4049c41d85807c30604", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -49,13 +49,15 @@ pub(crate) fn codegen_fn<'tcx>(\n         (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n-    let pointer_type = module.target_config().pointer_type();\n+    let target_config = module.target_config();\n+    let pointer_type = target_config.pointer_type();\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n     let mut fx = FunctionCx {\n         cx,\n         module,\n         tcx,\n+        target_config,\n         pointer_type,\n         constants_cx: ConstantCx::new(),\n \n@@ -72,8 +74,6 @@ pub(crate) fn codegen_fn<'tcx>(\n         clif_comments,\n         source_info_set: indexmap::IndexSet::new(),\n         next_ssa_var: 0,\n-\n-        inline_asm_index: 0,\n     };\n \n     let arg_uninhabited = fx\n@@ -204,7 +204,6 @@ pub(crate) fn verify_func(\n                 tcx.sess.err(&format!(\"{:?}\", err));\n                 let pretty_error = cranelift_codegen::print_errors::pretty_verifier_error(\n                     &func,\n-                    None,\n                     Some(Box::new(writer)),\n                     err,\n                 );\n@@ -296,9 +295,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                     AssertKind::BoundsCheck { ref len, ref index } => {\n                         let len = codegen_operand(fx, len).load_scalar(fx);\n                         let index = codegen_operand(fx, index).load_scalar(fx);\n-                        let location = fx\n-                            .get_caller_location(source_info.span)\n-                            .load_scalar(fx);\n+                        let location = fx.get_caller_location(source_info.span).load_scalar(fx);\n \n                         codegen_panic_inner(\n                             fx,\n@@ -681,7 +678,7 @@ fn codegen_stmt<'tcx>(\n                         // FIXME use emit_small_memset where possible\n                         let addr = lval.to_ptr().get_addr(fx);\n                         let val = operand.load_scalar(fx);\n-                        fx.bcx.call_memset(fx.module.target_config(), addr, val, times);\n+                        fx.bcx.call_memset(fx.target_config, addr, val, times);\n                     } else {\n                         let loop_block = fx.bcx.create_block();\n                         let loop_block2 = fx.bcx.create_block();\n@@ -754,8 +751,7 @@ fn codegen_stmt<'tcx>(\n                         NullOp::AlignOf => layout.align.abi.bytes(),\n                         NullOp::Box => unreachable!(),\n                     };\n-                    let val =\n-                        CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), val.into());\n+                    let val = CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), val.into());\n                     lval.write_cvalue(fx, val);\n                 }\n                 Rvalue::Aggregate(ref kind, ref operands) => match kind.as_ref() {\n@@ -803,7 +799,7 @@ fn codegen_stmt<'tcx>(\n             let elem_size: u64 = pointee.size.bytes();\n             let bytes =\n                 if elem_size != 1 { fx.bcx.ins().imul_imm(count, elem_size as i64) } else { count };\n-            fx.bcx.call_memcpy(fx.module.target_config(), dst, src, bytes);\n+            fx.bcx.call_memcpy(fx.target_config, dst, src, bytes);\n         }\n     }\n }"}, {"sha": "644204d10b8ed3a748754c88f8ffa6653616284b", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -1,3 +1,4 @@\n+use cranelift_codegen::isa::TargetFrontendConfig;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::layout::{\n     FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers,\n@@ -235,6 +236,7 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) cx: &'clif mut crate::CodegenCx<'tcx>,\n     pub(crate) module: &'m mut dyn Module,\n     pub(crate) tcx: TyCtxt<'tcx>,\n+    pub(crate) target_config: TargetFrontendConfig, // Cached from module\n     pub(crate) pointer_type: Type, // Cached from module\n     pub(crate) constants_cx: ConstantCx,\n \n@@ -255,8 +257,6 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n \n     /// This should only be accessed by `CPlace::new_var`.\n     pub(crate) next_ssa_var: u32,\n-\n-    pub(crate) inline_asm_index: u32,\n }\n \n impl<'tcx> LayoutOfHelpers<'tcx> for FunctionCx<'_, '_, 'tcx> {\n@@ -359,10 +359,6 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         crate::constant::codegen_const_value(self, const_loc, self.tcx.caller_location_ty())\n     }\n \n-    pub(crate) fn triple(&self) -> &target_lexicon::Triple {\n-        self.module.isa().triple()\n-    }\n-\n     pub(crate) fn anonymous_str(&mut self, msg: &str) -> Value {\n         let mut data_ctx = DataContext::new();\n         data_ctx.define(msg.as_bytes().to_vec().into_boxed_slice());"}, {"sha": "4120ba6e53352099d14217c3cc5a15748b298602", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -69,8 +69,6 @@ impl WriterRelocate {\n     /// Perform the collected relocations to be usable for JIT usage.\n     #[cfg(feature = \"jit\")]\n     pub(super) fn relocate_for_jit(mut self, jit_module: &cranelift_jit::JITModule) -> Vec<u8> {\n-        use std::convert::TryInto;\n-\n         for reloc in self.relocs.drain(..) {\n             match reloc.name {\n                 super::DebugRelocName::Section(_) => unreachable!(),"}, {"sha": "dd19dd5d2b91c02c84a7684ab0a10c64e1252ea0", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -10,7 +10,7 @@ use crate::prelude::*;\n use rustc_index::vec::IndexVec;\n \n use cranelift_codegen::entity::EntityRef;\n-use cranelift_codegen::ir::{LabelValueLoc, StackSlots, ValueLabel, ValueLoc};\n+use cranelift_codegen::ir::{LabelValueLoc, ValueLabel};\n use cranelift_codegen::isa::TargetIsa;\n use cranelift_codegen::ValueLocRange;\n \n@@ -67,7 +67,12 @@ impl<'tcx> DebugContext<'tcx> {\n             rustc_interface::util::version_str().unwrap_or(\"unknown version\"),\n             cranelift_codegen::VERSION,\n         );\n-        let comp_dir = tcx.sess.opts.working_dir.to_string_lossy(FileNameDisplayPreference::Remapped).into_owned();\n+        let comp_dir = tcx\n+            .sess\n+            .opts\n+            .working_dir\n+            .to_string_lossy(FileNameDisplayPreference::Remapped)\n+            .into_owned();\n         let (name, file_info) = match tcx.sess.local_crate_source_file.clone() {\n             Some(path) => {\n                 let name = path.to_string_lossy().into_owned();\n@@ -250,7 +255,7 @@ impl<'tcx> DebugContext<'tcx> {\n \n         // FIXME make it more reliable and implement scopes before re-enabling this.\n         if false {\n-            let value_labels_ranges = context.build_value_labels_ranges(isa).unwrap();\n+            let value_labels_ranges = std::collections::HashMap::new(); // FIXME\n \n             for (local, _local_decl) in mir.local_decls.iter_enumerated() {\n                 let ty = self.tcx.subst_and_normalize_erasing_regions(\n@@ -264,7 +269,6 @@ impl<'tcx> DebugContext<'tcx> {\n                     self,\n                     isa,\n                     symbol,\n-                    context,\n                     &local_map,\n                     &value_labels_ranges,\n                     Place { local, projection: ty::List::empty() },\n@@ -283,7 +287,6 @@ fn place_location<'tcx>(\n     debug_context: &mut DebugContext<'tcx>,\n     isa: &dyn TargetIsa,\n     symbol: usize,\n-    context: &Context,\n     local_map: &IndexVec<mir::Local, CPlace<'tcx>>,\n     #[allow(rustc::default_hash_types)] value_labels_ranges: &std::collections::HashMap<\n         ValueLabel,\n@@ -306,12 +309,7 @@ fn place_location<'tcx>(\n                                 addend: i64::from(value_loc_range.start),\n                             },\n                             end: Address::Symbol { symbol, addend: i64::from(value_loc_range.end) },\n-                            data: translate_loc(\n-                                isa,\n-                                value_loc_range.loc,\n-                                &context.func.stack_slots,\n-                            )\n-                            .unwrap(),\n+                            data: translate_loc(isa, value_loc_range.loc).unwrap(),\n                         })\n                         .collect(),\n                 );\n@@ -340,34 +338,14 @@ fn place_location<'tcx>(\n             AttributeValue::Exprloc(Expression::new())\n \n             // For PointerBase::Stack:\n-            //AttributeValue::Exprloc(translate_loc(ValueLoc::Stack(*stack_slot), &context.func.stack_slots).unwrap())\n+            //AttributeValue::Exprloc(translate_loc(ValueLoc::Stack(*stack_slot)).unwrap())\n         }\n     }\n }\n \n // Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n-fn translate_loc(\n-    isa: &dyn TargetIsa,\n-    loc: LabelValueLoc,\n-    stack_slots: &StackSlots,\n-) -> Option<Expression> {\n+fn translate_loc(isa: &dyn TargetIsa, loc: LabelValueLoc) -> Option<Expression> {\n     match loc {\n-        LabelValueLoc::ValueLoc(ValueLoc::Reg(reg)) => {\n-            let machine_reg = isa.map_dwarf_register(reg).unwrap();\n-            let mut expr = Expression::new();\n-            expr.op_reg(gimli::Register(machine_reg));\n-            Some(expr)\n-        }\n-        LabelValueLoc::ValueLoc(ValueLoc::Stack(ss)) => {\n-            if let Some(ss_offset) = stack_slots[ss].offset {\n-                let mut expr = Expression::new();\n-                expr.op_breg(X86_64::RBP, i64::from(ss_offset) + 16);\n-                Some(expr)\n-            } else {\n-                None\n-            }\n-        }\n-        LabelValueLoc::ValueLoc(ValueLoc::Unassigned) => unreachable!(),\n         LabelValueLoc::Reg(reg) => {\n             let machine_reg = isa.map_regalloc_reg_to_dwarf(reg).unwrap();\n             let mut expr = Expression::new();"}, {"sha": "9dc9b2cf9f8adef6aaab6285dbc6c2832cfed453", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/object.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fobject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fobject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fobject.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -1,5 +1,3 @@\n-use std::convert::{TryFrom, TryInto};\n-\n use rustc_data_structures::fx::FxHashMap;\n \n use cranelift_module::FuncId;"}, {"sha": "7f888c80464d41fcc0502dd7d41b5e83dd353d1b", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -4,6 +4,7 @@\n use std::path::PathBuf;\n \n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_codegen_ssa::back::metadata::create_compressed_metadata_file;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_metadata::EncodedMetadata;\n@@ -123,6 +124,7 @@ fn module_codegen(\n         backend_config.clone(),\n         module.isa(),\n         tcx.sess.opts.debuginfo != DebugInfo::None,\n+        cgu_name,\n     );\n     super::predefine_mono_items(tcx, &mut module, &mono_items);\n     for (mono_item, _) in mono_items {\n@@ -277,7 +279,8 @@ pub(crate) fn run_aot(\n             let tmp_file =\n                 tcx.output_filenames(()).temp_path(OutputType::Metadata, Some(&metadata_cgu_name));\n \n-            let obj = crate::metadata::new_metadata_object(tcx, &metadata_cgu_name, &metadata);\n+            let symbol_name = rustc_middle::middle::exported_symbols::metadata_symbol_name(tcx);\n+            let obj = create_compressed_metadata_file(tcx.sess, &metadata, &symbol_name);\n \n             if let Err(err) = std::fs::write(&tmp_file, obj) {\n                 tcx.sess.fatal(&format!(\"error writing metadata object file: {}\", err));"}, {"sha": "309d27090b5cb0dc728386b227f7533438f0ed2a", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -3,14 +3,15 @@\n \n use std::cell::RefCell;\n use std::ffi::CString;\n-use std::lazy::{Lazy, SyncOnceCell};\n+use std::lazy::SyncOnceCell;\n use std::os::raw::{c_char, c_int};\n use std::sync::{mpsc, Mutex};\n \n use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_codegen_ssa::CrateInfo;\n use rustc_middle::mir::mono::MonoItem;\n use rustc_session::Session;\n+use rustc_span::Symbol;\n \n use cranelift_jit::{JITBuilder, JITModule};\n \n@@ -23,7 +24,7 @@ struct JitState {\n }\n \n thread_local! {\n-    static LAZY_JIT_STATE: RefCell<Option<JitState>> = RefCell::new(None);\n+    static LAZY_JIT_STATE: RefCell<Option<JitState>> = const { RefCell::new(None) };\n }\n \n /// The Sender owned by the rustc thread\n@@ -50,12 +51,11 @@ impl UnsafeMessage {\n     fn send(self) -> Result<(), mpsc::SendError<UnsafeMessage>> {\n         thread_local! {\n             /// The Sender owned by the local thread\n-            static LOCAL_MESSAGE_SENDER: Lazy<mpsc::Sender<UnsafeMessage>> = Lazy::new(||\n+            static LOCAL_MESSAGE_SENDER: mpsc::Sender<UnsafeMessage> =\n                 GLOBAL_MESSAGE_SENDER\n                     .get().unwrap()\n                     .lock().unwrap()\n-                    .clone()\n-            );\n+                    .clone();\n         }\n         LOCAL_MESSAGE_SENDER.with(|sender| sender.send(self))\n     }\n@@ -76,7 +76,13 @@ fn create_jit_module<'tcx>(\n     jit_builder.symbols(imported_symbols);\n     let mut jit_module = JITModule::new(jit_builder);\n \n-    let mut cx = crate::CodegenCx::new(tcx, backend_config.clone(), jit_module.isa(), false);\n+    let mut cx = crate::CodegenCx::new(\n+        tcx,\n+        backend_config.clone(),\n+        jit_module.isa(),\n+        false,\n+        Symbol::intern(\"dummy_cgu_name\"),\n+    );\n \n     crate::allocator::codegen(tcx, &mut jit_module, &mut cx.unwind_context);\n     crate::main_shim::maybe_create_entry_wrapper(\n@@ -246,7 +252,13 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n \n             jit_module.prepare_for_function_redefine(func_id).unwrap();\n \n-            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module.isa(), false);\n+            let mut cx = crate::CodegenCx::new(\n+                tcx,\n+                backend_config,\n+                jit_module.isa(),\n+                false,\n+                Symbol::intern(\"dummy_cgu_name\"),\n+            );\n             tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, jit_module, instance));\n \n             assert!(cx.global_asm.is_empty());"}, {"sha": "93384bc55110167456e5e63ad52617d235456d6a", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 485, "deletions": 152, "changes": 637, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -6,6 +6,7 @@ use std::fmt::Write;\n \n use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_middle::mir::InlineAsmOperand;\n+use rustc_span::Symbol;\n use rustc_target::asm::*;\n \n pub(crate) fn codegen_inline_asm<'tcx>(\n@@ -17,10 +18,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n ) {\n     // FIXME add .eh_frame unwind info directives\n \n-    if template.is_empty() {\n-        // Black box\n-        return;\n-    } else if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n+    if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n         let true_ = fx.bcx.ins().iconst(types::I32, 1);\n         fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n         return;\n@@ -41,8 +39,10 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         assert_eq!(operands.len(), 4);\n         let (leaf, eax_place) = match operands[1] {\n             InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                let reg = expect_reg(reg);\n-                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::ax));\n+                assert_eq!(\n+                    reg,\n+                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n+                );\n                 (\n                     crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n                     crate::base::codegen_place(fx, out_place.unwrap()),\n@@ -64,8 +64,10 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         };\n         let (sub_leaf, ecx_place) = match operands[2] {\n             InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                let reg = expect_reg(reg);\n-                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::cx));\n+                assert_eq!(\n+                    reg,\n+                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n+                );\n                 (\n                     crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n                     crate::base::codegen_place(fx, out_place.unwrap()),\n@@ -75,8 +77,10 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         };\n         let edx_place = match operands[3] {\n             InlineAsmOperand::Out { reg, late: true, place } => {\n-                let reg = expect_reg(reg);\n-                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::dx));\n+                assert_eq!(\n+                    reg,\n+                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n+                );\n                 crate::base::codegen_place(fx, place.unwrap())\n             }\n             _ => unreachable!(),\n@@ -96,60 +100,59 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n     }\n \n-    let mut slot_size = Size::from_bytes(0);\n-    let mut clobbered_regs = Vec::new();\n     let mut inputs = Vec::new();\n     let mut outputs = Vec::new();\n \n-    let mut new_slot = |reg_class: InlineAsmRegClass| {\n-        let reg_size = reg_class\n-            .supported_types(InlineAsmArch::X86_64)\n-            .iter()\n-            .map(|(ty, _)| ty.size())\n-            .max()\n-            .unwrap();\n-        let align = rustc_target::abi::Align::from_bytes(reg_size.bytes()).unwrap();\n-        slot_size = slot_size.align_to(align);\n-        let offset = slot_size;\n-        slot_size += reg_size;\n-        offset\n+    let mut asm_gen = InlineAssemblyGenerator {\n+        tcx: fx.tcx,\n+        arch: fx.tcx.sess.asm_arch.unwrap(),\n+        template,\n+        operands,\n+        options,\n+        registers: Vec::new(),\n+        stack_slots_clobber: Vec::new(),\n+        stack_slots_input: Vec::new(),\n+        stack_slots_output: Vec::new(),\n+        stack_slot_size: Size::from_bytes(0),\n     };\n+    asm_gen.allocate_registers();\n+    asm_gen.allocate_stack_slots();\n+\n+    let inline_asm_index = fx.cx.inline_asm_index.get();\n+    fx.cx.inline_asm_index.set(inline_asm_index + 1);\n+    let asm_name = format!(\n+        \"__inline_asm_{}_n{}\",\n+        fx.cx.cgu_name.as_str().replace('.', \"__\").replace('-', \"_\"),\n+        inline_asm_index\n+    );\n+\n+    let generated_asm = asm_gen.generate_asm_wrapper(&asm_name);\n+    fx.cx.global_asm.push_str(&generated_asm);\n \n-    // FIXME overlap input and output slots to save stack space\n-    for operand in operands {\n+    for (i, operand) in operands.iter().enumerate() {\n         match *operand {\n-            InlineAsmOperand::In { reg, ref value } => {\n-                let reg = expect_reg(reg);\n-                clobbered_regs.push((reg, new_slot(reg.reg_class())));\n+            InlineAsmOperand::In { reg: _, ref value } => {\n                 inputs.push((\n-                    reg,\n-                    new_slot(reg.reg_class()),\n+                    asm_gen.stack_slots_input[i].unwrap(),\n                     crate::base::codegen_operand(fx, value).load_scalar(fx),\n                 ));\n             }\n-            InlineAsmOperand::Out { reg, late: _, place } => {\n-                let reg = expect_reg(reg);\n-                clobbered_regs.push((reg, new_slot(reg.reg_class())));\n+            InlineAsmOperand::Out { reg: _, late: _, place } => {\n                 if let Some(place) = place {\n                     outputs.push((\n-                        reg,\n-                        new_slot(reg.reg_class()),\n+                        asm_gen.stack_slots_output[i].unwrap(),\n                         crate::base::codegen_place(fx, place),\n                     ));\n                 }\n             }\n-            InlineAsmOperand::InOut { reg, late: _, ref in_value, out_place } => {\n-                let reg = expect_reg(reg);\n-                clobbered_regs.push((reg, new_slot(reg.reg_class())));\n+            InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n                 inputs.push((\n-                    reg,\n-                    new_slot(reg.reg_class()),\n+                    asm_gen.stack_slots_input[i].unwrap(),\n                     crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n                 ));\n                 if let Some(out_place) = out_place {\n                     outputs.push((\n-                        reg,\n-                        new_slot(reg.reg_class()),\n+                        asm_gen.stack_slots_output[i].unwrap(),\n                         crate::base::codegen_place(fx, out_place),\n                     ));\n                 }\n@@ -160,110 +163,474 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         }\n     }\n \n-    let inline_asm_index = fx.inline_asm_index;\n-    fx.inline_asm_index += 1;\n-    let asm_name = format!(\"{}__inline_asm_{}\", fx.symbol_name, inline_asm_index);\n-\n-    let generated_asm = generate_asm_wrapper(\n-        &asm_name,\n-        InlineAsmArch::X86_64,\n-        options,\n-        template,\n-        clobbered_regs,\n-        &inputs,\n-        &outputs,\n-    );\n-    fx.cx.global_asm.push_str(&generated_asm);\n-\n-    call_inline_asm(fx, &asm_name, slot_size, inputs, outputs);\n+    call_inline_asm(fx, &asm_name, asm_gen.stack_slot_size, inputs, outputs);\n }\n \n-fn generate_asm_wrapper(\n-    asm_name: &str,\n+struct InlineAssemblyGenerator<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     arch: InlineAsmArch,\n+    template: &'a [InlineAsmTemplatePiece],\n+    operands: &'a [InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n-    template: &[InlineAsmTemplatePiece],\n-    clobbered_regs: Vec<(InlineAsmReg, Size)>,\n-    inputs: &[(InlineAsmReg, Size, Value)],\n-    outputs: &[(InlineAsmReg, Size, CPlace<'_>)],\n-) -> String {\n-    let mut generated_asm = String::new();\n-    writeln!(generated_asm, \".globl {}\", asm_name).unwrap();\n-    writeln!(generated_asm, \".type {},@function\", asm_name).unwrap();\n-    writeln!(generated_asm, \".section .text.{},\\\"ax\\\",@progbits\", asm_name).unwrap();\n-    writeln!(generated_asm, \"{}:\", asm_name).unwrap();\n-\n-    generated_asm.push_str(\".intel_syntax noprefix\\n\");\n-    generated_asm.push_str(\"    push rbp\\n\");\n-    generated_asm.push_str(\"    mov rbp,rdi\\n\");\n-\n-    // Save clobbered registers\n-    if !options.contains(InlineAsmOptions::NORETURN) {\n-        // FIXME skip registers saved by the calling convention\n-        for &(reg, offset) in &clobbered_regs {\n-            save_register(&mut generated_asm, arch, reg, offset);\n+    registers: Vec<Option<InlineAsmReg>>,\n+    stack_slots_clobber: Vec<Option<Size>>,\n+    stack_slots_input: Vec<Option<Size>>,\n+    stack_slots_output: Vec<Option<Size>>,\n+    stack_slot_size: Size,\n+}\n+\n+impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n+    fn allocate_registers(&mut self) {\n+        let sess = self.tcx.sess;\n+        let map = allocatable_registers(\n+            self.arch,\n+            |feature| sess.target_features.contains(&Symbol::intern(feature)),\n+            &sess.target,\n+        );\n+        let mut allocated = FxHashMap::<_, (bool, bool)>::default();\n+        let mut regs = vec![None; self.operands.len()];\n+\n+        // Add explicit registers to the allocated set.\n+        for (i, operand) in self.operands.iter().enumerate() {\n+            match *operand {\n+                InlineAsmOperand::In { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n+                    regs[i] = Some(reg);\n+                    allocated.entry(reg).or_default().0 = true;\n+                }\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(reg), late: true, ..\n+                } => {\n+                    regs[i] = Some(reg);\n+                    allocated.entry(reg).or_default().1 = true;\n+                }\n+                InlineAsmOperand::Out { reg: InlineAsmRegOrRegClass::Reg(reg), .. }\n+                | InlineAsmOperand::InOut { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n+                    regs[i] = Some(reg);\n+                    allocated.insert(reg, (true, true));\n+                }\n+                _ => (),\n+            }\n         }\n-    }\n \n-    // Write input registers\n-    for &(reg, offset, _value) in inputs {\n-        restore_register(&mut generated_asm, arch, reg, offset);\n-    }\n+        // Allocate out/inout/inlateout registers first because they are more constrained.\n+        for (i, operand) in self.operands.iter().enumerate() {\n+            match *operand {\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::RegClass(class),\n+                    late: false,\n+                    ..\n+                }\n+                | InlineAsmOperand::InOut {\n+                    reg: InlineAsmRegOrRegClass::RegClass(class), ..\n+                } => {\n+                    let mut alloc_reg = None;\n+                    for &reg in &map[&class] {\n+                        let mut used = false;\n+                        reg.overlapping_regs(|r| {\n+                            if allocated.contains_key(&r) {\n+                                used = true;\n+                            }\n+                        });\n+\n+                        if !used {\n+                            alloc_reg = Some(reg);\n+                            break;\n+                        }\n+                    }\n+\n+                    let reg = alloc_reg.expect(\"cannot allocate registers\");\n+                    regs[i] = Some(reg);\n+                    allocated.insert(reg, (true, true));\n+                }\n+                _ => (),\n+            }\n+        }\n+\n+        // Allocate in/lateout.\n+        for (i, operand) in self.operands.iter().enumerate() {\n+            match *operand {\n+                InlineAsmOperand::In { reg: InlineAsmRegOrRegClass::RegClass(class), .. } => {\n+                    let mut alloc_reg = None;\n+                    for &reg in &map[&class] {\n+                        let mut used = false;\n+                        reg.overlapping_regs(|r| {\n+                            if allocated.get(&r).copied().unwrap_or_default().0 {\n+                                used = true;\n+                            }\n+                        });\n+\n+                        if !used {\n+                            alloc_reg = Some(reg);\n+                            break;\n+                        }\n+                    }\n+\n+                    let reg = alloc_reg.expect(\"cannot allocate registers\");\n+                    regs[i] = Some(reg);\n+                    allocated.entry(reg).or_default().0 = true;\n+                }\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::RegClass(class),\n+                    late: true,\n+                    ..\n+                } => {\n+                    let mut alloc_reg = None;\n+                    for &reg in &map[&class] {\n+                        let mut used = false;\n+                        reg.overlapping_regs(|r| {\n+                            if allocated.get(&r).copied().unwrap_or_default().1 {\n+                                used = true;\n+                            }\n+                        });\n+\n+                        if !used {\n+                            alloc_reg = Some(reg);\n+                            break;\n+                        }\n+                    }\n+\n+                    let reg = alloc_reg.expect(\"cannot allocate registers\");\n+                    regs[i] = Some(reg);\n+                    allocated.entry(reg).or_default().1 = true;\n+                }\n+                _ => (),\n+            }\n+        }\n \n-    if options.contains(InlineAsmOptions::ATT_SYNTAX) {\n-        generated_asm.push_str(\".att_syntax\\n\");\n+        self.registers = regs;\n     }\n \n-    // The actual inline asm\n-    for piece in template {\n-        match piece {\n-            InlineAsmTemplatePiece::String(s) => {\n-                generated_asm.push_str(s);\n+    fn allocate_stack_slots(&mut self) {\n+        let mut slot_size = Size::from_bytes(0);\n+        let mut slots_clobber = vec![None; self.operands.len()];\n+        let mut slots_input = vec![None; self.operands.len()];\n+        let mut slots_output = vec![None; self.operands.len()];\n+\n+        let new_slot_fn = |slot_size: &mut Size, reg_class: InlineAsmRegClass| {\n+            let reg_size =\n+                reg_class.supported_types(self.arch).iter().map(|(ty, _)| ty.size()).max().unwrap();\n+            let align = rustc_target::abi::Align::from_bytes(reg_size.bytes()).unwrap();\n+            let offset = slot_size.align_to(align);\n+            *slot_size = offset + reg_size;\n+            offset\n+        };\n+        let mut new_slot = |x| new_slot_fn(&mut slot_size, x);\n+\n+        // Allocate stack slots for saving clobbered registers\n+        let abi_clobber = InlineAsmClobberAbi::parse(\n+            self.arch,\n+            |feature| self.tcx.sess.target_features.contains(&Symbol::intern(feature)),\n+            &self.tcx.sess.target,\n+            Symbol::intern(\"C\"),\n+        )\n+        .unwrap()\n+        .clobbered_regs();\n+        for (i, reg) in self.registers.iter().enumerate().filter_map(|(i, r)| r.map(|r| (i, r))) {\n+            let mut need_save = true;\n+            // If the register overlaps with a register clobbered by function call, then\n+            // we don't need to save it.\n+            for r in abi_clobber {\n+                r.overlapping_regs(|r| {\n+                    if r == reg {\n+                        need_save = false;\n+                    }\n+                });\n+\n+                if !need_save {\n+                    break;\n+                }\n+            }\n+\n+            if need_save {\n+                slots_clobber[i] = Some(new_slot(reg.reg_class()));\n             }\n-            InlineAsmTemplatePiece::Placeholder { operand_idx: _, modifier: _, span: _ } => todo!(),\n         }\n+\n+        // Allocate stack slots for inout\n+        for (i, operand) in self.operands.iter().enumerate() {\n+            match *operand {\n+                InlineAsmOperand::InOut { reg, out_place: Some(_), .. } => {\n+                    let slot = new_slot(reg.reg_class());\n+                    slots_input[i] = Some(slot);\n+                    slots_output[i] = Some(slot);\n+                }\n+                _ => (),\n+            }\n+        }\n+\n+        let slot_size_before_input = slot_size;\n+        let mut new_slot = |x| new_slot_fn(&mut slot_size, x);\n+\n+        // Allocate stack slots for input\n+        for (i, operand) in self.operands.iter().enumerate() {\n+            match *operand {\n+                InlineAsmOperand::In { reg, .. }\n+                | InlineAsmOperand::InOut { reg, out_place: None, .. } => {\n+                    slots_input[i] = Some(new_slot(reg.reg_class()));\n+                }\n+                _ => (),\n+            }\n+        }\n+\n+        // Reset slot size to before input so that input and output operands can overlap\n+        // and save some memory.\n+        let slot_size_after_input = slot_size;\n+        slot_size = slot_size_before_input;\n+        let mut new_slot = |x| new_slot_fn(&mut slot_size, x);\n+\n+        // Allocate stack slots for output\n+        for (i, operand) in self.operands.iter().enumerate() {\n+            match *operand {\n+                InlineAsmOperand::Out { reg, place: Some(_), .. } => {\n+                    slots_output[i] = Some(new_slot(reg.reg_class()));\n+                }\n+                _ => (),\n+            }\n+        }\n+\n+        slot_size = slot_size.max(slot_size_after_input);\n+\n+        self.stack_slots_clobber = slots_clobber;\n+        self.stack_slots_input = slots_input;\n+        self.stack_slots_output = slots_output;\n+        self.stack_slot_size = slot_size;\n     }\n-    generated_asm.push('\\n');\n \n-    if options.contains(InlineAsmOptions::ATT_SYNTAX) {\n-        generated_asm.push_str(\".intel_syntax noprefix\\n\");\n+    fn generate_asm_wrapper(&self, asm_name: &str) -> String {\n+        let mut generated_asm = String::new();\n+        writeln!(generated_asm, \".globl {}\", asm_name).unwrap();\n+        writeln!(generated_asm, \".type {},@function\", asm_name).unwrap();\n+        writeln!(generated_asm, \".section .text.{},\\\"ax\\\",@progbits\", asm_name).unwrap();\n+        writeln!(generated_asm, \"{}:\", asm_name).unwrap();\n+\n+        let is_x86 = matches!(self.arch, InlineAsmArch::X86 | InlineAsmArch::X86_64);\n+\n+        if is_x86 {\n+            generated_asm.push_str(\".intel_syntax noprefix\\n\");\n+        }\n+        Self::prologue(&mut generated_asm, self.arch);\n+\n+        // Save clobbered registers\n+        if !self.options.contains(InlineAsmOptions::NORETURN) {\n+            for (reg, slot) in self\n+                .registers\n+                .iter()\n+                .zip(self.stack_slots_clobber.iter().copied())\n+                .filter_map(|(r, s)| r.zip(s))\n+            {\n+                Self::save_register(&mut generated_asm, self.arch, reg, slot);\n+            }\n+        }\n+\n+        // Write input registers\n+        for (reg, slot) in self\n+            .registers\n+            .iter()\n+            .zip(self.stack_slots_input.iter().copied())\n+            .filter_map(|(r, s)| r.zip(s))\n+        {\n+            Self::restore_register(&mut generated_asm, self.arch, reg, slot);\n+        }\n+\n+        if is_x86 && self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+            generated_asm.push_str(\".att_syntax\\n\");\n+        }\n+\n+        // The actual inline asm\n+        for piece in self.template {\n+            match piece {\n+                InlineAsmTemplatePiece::String(s) => {\n+                    generated_asm.push_str(s);\n+                }\n+                InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n+                    if self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+                        generated_asm.push('%');\n+                    }\n+                    self.registers[*operand_idx]\n+                        .unwrap()\n+                        .emit(&mut generated_asm, self.arch, *modifier)\n+                        .unwrap();\n+                }\n+            }\n+        }\n+        generated_asm.push('\\n');\n+\n+        if is_x86 && self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+            generated_asm.push_str(\".intel_syntax noprefix\\n\");\n+        }\n+\n+        if !self.options.contains(InlineAsmOptions::NORETURN) {\n+            // Read output registers\n+            for (reg, slot) in self\n+                .registers\n+                .iter()\n+                .zip(self.stack_slots_output.iter().copied())\n+                .filter_map(|(r, s)| r.zip(s))\n+            {\n+                Self::save_register(&mut generated_asm, self.arch, reg, slot);\n+            }\n+\n+            // Restore clobbered registers\n+            for (reg, slot) in self\n+                .registers\n+                .iter()\n+                .zip(self.stack_slots_clobber.iter().copied())\n+                .filter_map(|(r, s)| r.zip(s))\n+            {\n+                Self::restore_register(&mut generated_asm, self.arch, reg, slot);\n+            }\n+\n+            Self::epilogue(&mut generated_asm, self.arch);\n+        } else {\n+            Self::epilogue_noreturn(&mut generated_asm, self.arch);\n+        }\n+\n+        if is_x86 {\n+            generated_asm.push_str(\".att_syntax\\n\");\n+        }\n+        writeln!(generated_asm, \".size {name}, .-{name}\", name = asm_name).unwrap();\n+        generated_asm.push_str(\".text\\n\");\n+        generated_asm.push_str(\"\\n\\n\");\n+\n+        generated_asm\n     }\n \n-    if !options.contains(InlineAsmOptions::NORETURN) {\n-        // Read output registers\n-        for &(reg, offset, _place) in outputs {\n-            save_register(&mut generated_asm, arch, reg, offset);\n+    fn prologue(generated_asm: &mut String, arch: InlineAsmArch) {\n+        match arch {\n+            InlineAsmArch::X86 => {\n+                generated_asm.push_str(\"    push ebp\\n\");\n+                generated_asm.push_str(\"    mov ebp,[esp+8]\\n\");\n+            }\n+            InlineAsmArch::X86_64 => {\n+                generated_asm.push_str(\"    push rbp\\n\");\n+                generated_asm.push_str(\"    mov rbp,rdi\\n\");\n+            }\n+            InlineAsmArch::RiscV32 => {\n+                generated_asm.push_str(\"    addi sp, sp, -8\\n\");\n+                generated_asm.push_str(\"    sw ra, 4(sp)\\n\");\n+                generated_asm.push_str(\"    sw s0, 0(sp)\\n\");\n+                generated_asm.push_str(\"    mv s0, a0\\n\");\n+            }\n+            InlineAsmArch::RiscV64 => {\n+                generated_asm.push_str(\"    addi sp, sp, -16\\n\");\n+                generated_asm.push_str(\"    sd ra, 8(sp)\\n\");\n+                generated_asm.push_str(\"    sd s0, 0(sp)\\n\");\n+                generated_asm.push_str(\"    mv s0, a0\\n\");\n+            }\n+            _ => unimplemented!(\"prologue for {:?}\", arch),\n         }\n+    }\n \n-        // Restore clobbered registers\n-        for &(reg, offset) in clobbered_regs.iter().rev() {\n-            restore_register(&mut generated_asm, arch, reg, offset);\n+    fn epilogue(generated_asm: &mut String, arch: InlineAsmArch) {\n+        match arch {\n+            InlineAsmArch::X86 => {\n+                generated_asm.push_str(\"    pop ebp\\n\");\n+                generated_asm.push_str(\"    ret\\n\");\n+            }\n+            InlineAsmArch::X86_64 => {\n+                generated_asm.push_str(\"    pop rbp\\n\");\n+                generated_asm.push_str(\"    ret\\n\");\n+            }\n+            InlineAsmArch::RiscV32 => {\n+                generated_asm.push_str(\"    lw s0, 0(sp)\\n\");\n+                generated_asm.push_str(\"    lw ra, 4(sp)\\n\");\n+                generated_asm.push_str(\"    addi sp, sp, 8\\n\");\n+                generated_asm.push_str(\"    ret\\n\");\n+            }\n+            InlineAsmArch::RiscV64 => {\n+                generated_asm.push_str(\"    ld s0, 0(sp)\\n\");\n+                generated_asm.push_str(\"    ld ra, 8(sp)\\n\");\n+                generated_asm.push_str(\"    addi sp, sp, 16\\n\");\n+                generated_asm.push_str(\"    ret\\n\");\n+            }\n+            _ => unimplemented!(\"epilogue for {:?}\", arch),\n         }\n+    }\n \n-        generated_asm.push_str(\"    pop rbp\\n\");\n-        generated_asm.push_str(\"    ret\\n\");\n-    } else {\n-        generated_asm.push_str(\"    ud2\\n\");\n+    fn epilogue_noreturn(generated_asm: &mut String, arch: InlineAsmArch) {\n+        match arch {\n+            InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n+                generated_asm.push_str(\"    ud2\\n\");\n+            }\n+            InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n+                generated_asm.push_str(\"    ebreak\\n\");\n+            }\n+            _ => unimplemented!(\"epilogue_noreturn for {:?}\", arch),\n+        }\n     }\n \n-    generated_asm.push_str(\".att_syntax\\n\");\n-    writeln!(generated_asm, \".size {name}, .-{name}\", name = asm_name).unwrap();\n-    generated_asm.push_str(\".text\\n\");\n-    generated_asm.push_str(\"\\n\\n\");\n+    fn save_register(\n+        generated_asm: &mut String,\n+        arch: InlineAsmArch,\n+        reg: InlineAsmReg,\n+        offset: Size,\n+    ) {\n+        match arch {\n+            InlineAsmArch::X86 => {\n+                write!(generated_asm, \"    mov [ebp+0x{:x}], \", offset.bytes()).unwrap();\n+                reg.emit(generated_asm, InlineAsmArch::X86, None).unwrap();\n+                generated_asm.push('\\n');\n+            }\n+            InlineAsmArch::X86_64 => {\n+                write!(generated_asm, \"    mov [rbp+0x{:x}], \", offset.bytes()).unwrap();\n+                reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n+                generated_asm.push('\\n');\n+            }\n+            InlineAsmArch::RiscV32 => {\n+                generated_asm.push_str(\"    sw \");\n+                reg.emit(generated_asm, InlineAsmArch::RiscV32, None).unwrap();\n+                writeln!(generated_asm, \", 0x{:x}(s0)\", offset.bytes()).unwrap();\n+            }\n+            InlineAsmArch::RiscV64 => {\n+                generated_asm.push_str(\"    sd \");\n+                reg.emit(generated_asm, InlineAsmArch::RiscV64, None).unwrap();\n+                writeln!(generated_asm, \", 0x{:x}(s0)\", offset.bytes()).unwrap();\n+            }\n+            _ => unimplemented!(\"save_register for {:?}\", arch),\n+        }\n+    }\n \n-    generated_asm\n+    fn restore_register(\n+        generated_asm: &mut String,\n+        arch: InlineAsmArch,\n+        reg: InlineAsmReg,\n+        offset: Size,\n+    ) {\n+        match arch {\n+            InlineAsmArch::X86 => {\n+                generated_asm.push_str(\"    mov \");\n+                reg.emit(generated_asm, InlineAsmArch::X86, None).unwrap();\n+                writeln!(generated_asm, \", [ebp+0x{:x}]\", offset.bytes()).unwrap();\n+            }\n+            InlineAsmArch::X86_64 => {\n+                generated_asm.push_str(\"    mov \");\n+                reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n+                writeln!(generated_asm, \", [rbp+0x{:x}]\", offset.bytes()).unwrap();\n+            }\n+            InlineAsmArch::RiscV32 => {\n+                generated_asm.push_str(\"    lw \");\n+                reg.emit(generated_asm, InlineAsmArch::RiscV32, None).unwrap();\n+                writeln!(generated_asm, \", 0x{:x}(s0)\", offset.bytes()).unwrap();\n+            }\n+            InlineAsmArch::RiscV64 => {\n+                generated_asm.push_str(\"    ld \");\n+                reg.emit(generated_asm, InlineAsmArch::RiscV64, None).unwrap();\n+                writeln!(generated_asm, \", 0x{:x}(s0)\", offset.bytes()).unwrap();\n+            }\n+            _ => unimplemented!(\"restore_register for {:?}\", arch),\n+        }\n+    }\n }\n \n fn call_inline_asm<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     asm_name: &str,\n     slot_size: Size,\n-    inputs: Vec<(InlineAsmReg, Size, Value)>,\n-    outputs: Vec<(InlineAsmReg, Size, CPlace<'tcx>)>,\n+    inputs: Vec<(Size, Value)>,\n+    outputs: Vec<(Size, CPlace<'tcx>)>,\n ) {\n     let stack_slot = fx.bcx.func.create_stack_slot(StackSlotData {\n         kind: StackSlotKind::ExplicitSlot,\n-        offset: None,\n         size: u32::try_from(slot_size.bytes()).unwrap(),\n     });\n     if fx.clif_comments.enabled() {\n@@ -287,50 +654,16 @@ fn call_inline_asm<'tcx>(\n         fx.add_comment(inline_asm_func, asm_name);\n     }\n \n-    for (_reg, offset, value) in inputs {\n+    for (offset, value) in inputs {\n         fx.bcx.ins().stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n     }\n \n     let stack_slot_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n     fx.bcx.ins().call(inline_asm_func, &[stack_slot_addr]);\n \n-    for (_reg, offset, place) in outputs {\n+    for (offset, place) in outputs {\n         let ty = fx.clif_type(place.layout().ty).unwrap();\n         let value = fx.bcx.ins().stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n         place.write_cvalue(fx, CValue::by_val(value, place.layout()));\n     }\n }\n-\n-fn expect_reg(reg_or_class: InlineAsmRegOrRegClass) -> InlineAsmReg {\n-    match reg_or_class {\n-        InlineAsmRegOrRegClass::Reg(reg) => reg,\n-        InlineAsmRegOrRegClass::RegClass(class) => unimplemented!(\"{:?}\", class),\n-    }\n-}\n-\n-fn save_register(generated_asm: &mut String, arch: InlineAsmArch, reg: InlineAsmReg, offset: Size) {\n-    match arch {\n-        InlineAsmArch::X86_64 => {\n-            write!(generated_asm, \"    mov [rbp+0x{:x}], \", offset.bytes()).unwrap();\n-            reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n-            generated_asm.push('\\n');\n-        }\n-        _ => unimplemented!(\"save_register for {:?}\", arch),\n-    }\n-}\n-\n-fn restore_register(\n-    generated_asm: &mut String,\n-    arch: InlineAsmArch,\n-    reg: InlineAsmReg,\n-    offset: Size,\n-) {\n-    match arch {\n-        InlineAsmArch::X86_64 => {\n-            generated_asm.push_str(\"    mov \");\n-            reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n-            writeln!(generated_asm, \", [rbp+0x{:x}]\", offset.bytes()).unwrap();\n-        }\n-        _ => unimplemented!(\"restore_register for {:?}\", arch),\n-    }\n-}"}, {"sha": "f4703b22ecbcf75182fa202b18879204e00f4f98", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -503,10 +503,10 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             if intrinsic == sym::copy_nonoverlapping {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.target_config, dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.target_config, dst, src, byte_amount);\n             }\n         };\n         // NOTE: the volatile variants have src and dst swapped\n@@ -522,10 +522,10 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             // FIXME make the copy actually volatile when using emit_small_mem{cpy,move}\n             if intrinsic == sym::volatile_copy_nonoverlapping_memory {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.target_config, dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.target_config, dst, src, byte_amount);\n             }\n         };\n         size_of_val, <T> (c ptr) {\n@@ -673,7 +673,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let dst_ptr = dst.load_scalar(fx);\n             // FIXME make the memset actually volatile when switching to emit_small_memset\n             // FIXME use emit_small_memset\n-            fx.bcx.call_memset(fx.module.target_config(), dst_ptr, val, count);\n+            fx.bcx.call_memset(fx.target_config, dst_ptr, val, count);\n         };\n         ctlz | ctlz_nonzero, <T> (v arg) {\n             // FIXME trap on `ctlz_nonzero` with zero arg.\n@@ -1067,7 +1067,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         kw.Try, (v f, v data, v _catch_fn) {\n             // FIXME once unwinding is supported, change this to actually catch panics\n             let f_sig = fx.bcx.func.import_signature(Signature {\n-                call_conv: CallConv::triple_default(fx.triple()),\n+                call_conv: fx.target_config.default_call_conv,\n                 params: vec![AbiParam::new(fx.bcx.func.dfg.value_type(data))],\n                 returns: vec![],\n             });"}, {"sha": "6c0631d9ecbd0a2cb89eca538d36e61aa383fe73", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -67,7 +67,34 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         _ if intrinsic.as_str().starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n             validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n \n-            let n: u16 = intrinsic.as_str()[\"simd_shuffle\".len()..].parse().unwrap();\n+            // If this intrinsic is the older \"simd_shuffleN\" form, simply parse the integer.\n+            // If there is no suffix, use the index array length.\n+            let n: u16 = if intrinsic == sym::simd_shuffle {\n+                // Make sure this is actually an array, since typeck only checks the length-suffixed\n+                // version of this intrinsic.\n+                let idx_ty = fx.monomorphize(idx.ty(fx.mir, fx.tcx));\n+                match idx_ty.kind() {\n+                    ty::Array(ty, len) if matches!(ty.kind(), ty::Uint(ty::UintTy::U32)) => {\n+                        len.try_eval_usize(fx.tcx, ty::ParamEnv::reveal_all()).unwrap_or_else(|| {\n+                            span_bug!(span, \"could not evaluate shuffle index array length\")\n+                        }).try_into().unwrap()\n+                    }\n+                    _ => {\n+                        fx.tcx.sess.span_err(\n+                            span,\n+                            &format!(\n+                                \"simd_shuffle index must be an array of `u32`, got `{}`\",\n+                                idx_ty,\n+                            ),\n+                        );\n+                        // Prevent verifier error\n+                        crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+                        return;\n+                    }\n+                }\n+            } else {\n+                intrinsic.as_str()[\"simd_shuffle\".len()..].parse().unwrap()\n+            };\n \n             assert_eq!(x.layout(), y.layout());\n             let layout = x.layout();\n@@ -378,27 +405,27 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_reduce_min, (c v) {\n-            // FIXME support floats\n             validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n             simd_reduce(fx, v, None, ret, |fx, layout, a, b| {\n-                let lt = fx.bcx.ins().icmp(if layout.ty.is_signed() {\n-                    IntCC::SignedLessThan\n-                } else {\n-                    IntCC::UnsignedLessThan\n-                }, a, b);\n+                let lt = match layout.ty.kind() {\n+                    ty::Int(_) => fx.bcx.ins().icmp(IntCC::SignedLessThan, a, b),\n+                    ty::Uint(_) => fx.bcx.ins().icmp(IntCC::UnsignedLessThan, a, b),\n+                    ty::Float(_) => fx.bcx.ins().fcmp(FloatCC::LessThan, a, b),\n+                    _ => unreachable!(),\n+                };\n                 fx.bcx.ins().select(lt, a, b)\n             });\n         };\n \n         simd_reduce_max, (c v) {\n-            // FIXME support floats\n             validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n             simd_reduce(fx, v, None, ret, |fx, layout, a, b| {\n-                let gt = fx.bcx.ins().icmp(if layout.ty.is_signed() {\n-                    IntCC::SignedGreaterThan\n-                } else {\n-                    IntCC::UnsignedGreaterThan\n-                }, a, b);\n+                let gt = match layout.ty.kind() {\n+                    ty::Int(_) => fx.bcx.ins().icmp(IntCC::SignedGreaterThan, a, b),\n+                    ty::Uint(_) => fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, a, b),\n+                    ty::Float(_) => fx.bcx.ins().fcmp(FloatCC::GreaterThan, a, b),\n+                    _ => unreachable!(),\n+                };\n                 fx.bcx.ins().select(gt, a, b)\n             });\n         };"}, {"sha": "3f2884748272a413d3b3e50729c1ff655290ebff", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -4,7 +4,6 @@\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n \n-extern crate snap;\n #[macro_use]\n extern crate rustc_middle;\n extern crate rustc_ast;\n@@ -26,6 +25,7 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n+use std::cell::Cell;\n \n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n@@ -34,6 +34,7 @@ use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_session::config::OutputFilenames;\n use rustc_session::Session;\n+use rustc_span::Symbol;\n \n use cranelift_codegen::isa::TargetIsa;\n use cranelift_codegen::settings::{self, Configurable};\n@@ -59,7 +60,6 @@ mod inline_asm;\n mod intrinsics;\n mod linkage;\n mod main_shim;\n-mod metadata;\n mod num;\n mod optimize;\n mod pointer;\n@@ -71,9 +71,7 @@ mod value_and_place;\n mod vtable;\n \n mod prelude {\n-    pub(crate) use std::convert::{TryFrom, TryInto};\n-\n-    pub(crate) use rustc_span::{Span, FileNameDisplayPreference};\n+    pub(crate) use rustc_span::{FileNameDisplayPreference, Span};\n \n     pub(crate) use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n     pub(crate) use rustc_middle::bug;\n@@ -125,9 +123,11 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n struct CodegenCx<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     global_asm: String,\n+    inline_asm_index: Cell<usize>,\n     cached_context: Context,\n     debug_context: Option<DebugContext<'tcx>>,\n     unwind_context: UnwindContext,\n+    cgu_name: Symbol,\n }\n \n impl<'tcx> CodegenCx<'tcx> {\n@@ -136,6 +136,7 @@ impl<'tcx> CodegenCx<'tcx> {\n         backend_config: BackendConfig,\n         isa: &dyn TargetIsa,\n         debug_info: bool,\n+        cgu_name: Symbol,\n     ) -> Self {\n         assert_eq!(pointer_ty(tcx), isa.pointer_type());\n \n@@ -145,9 +146,11 @@ impl<'tcx> CodegenCx<'tcx> {\n         CodegenCx {\n             tcx,\n             global_asm: String::new(),\n+            inline_asm_index: Cell::new(0),\n             cached_context: Context::new(),\n             debug_context,\n             unwind_context,\n+            cgu_name,\n         }\n     }\n }\n@@ -269,30 +272,26 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n \n     let flags = settings::Flags::new(flags_builder);\n \n-    let variant = cranelift_codegen::isa::BackendVariant::MachInst;\n-\n     let isa_builder = match sess.opts.cg.target_cpu.as_deref() {\n         Some(\"native\") => {\n-            let builder = cranelift_native::builder_with_options(variant, true).unwrap();\n+            let builder = cranelift_native::builder_with_options(true).unwrap();\n             builder\n         }\n         Some(value) => {\n             let mut builder =\n-                cranelift_codegen::isa::lookup_variant(target_triple.clone(), variant)\n-                    .unwrap_or_else(|err| {\n-                        sess.fatal(&format!(\"can't compile for {}: {}\", target_triple, err));\n-                    });\n+                cranelift_codegen::isa::lookup(target_triple.clone()).unwrap_or_else(|err| {\n+                    sess.fatal(&format!(\"can't compile for {}: {}\", target_triple, err));\n+                });\n             if let Err(_) = builder.enable(value) {\n                 sess.fatal(\"the specified target cpu isn't currently supported by Cranelift.\");\n             }\n             builder\n         }\n         None => {\n             let mut builder =\n-                cranelift_codegen::isa::lookup_variant(target_triple.clone(), variant)\n-                    .unwrap_or_else(|err| {\n-                        sess.fatal(&format!(\"can't compile for {}: {}\", target_triple, err));\n-                    });\n+                cranelift_codegen::isa::lookup(target_triple.clone()).unwrap_or_else(|err| {\n+                    sess.fatal(&format!(\"can't compile for {}: {}\", target_triple, err));\n+                });\n             if target_triple.architecture == target_lexicon::Architecture::X86_64 {\n                 // Don't use \"haswell\" as the default, as it implies `has_lzcnt`.\n                 // macOS CI is still at Ivy Bridge EP, so `lzcnt` is interpreted as `bsr`."}, {"sha": "1c8fd0b01d9d94ed346e67bf5ae734bb9d12b50b", "filename": "compiler/rustc_codegen_cranelift/src/metadata.rs", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/87e8639d8dd900ebdd79e9f0491ca4ae40944f02/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e8639d8dd900ebdd79e9f0491ca4ae40944f02/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs?ref=87e8639d8dd900ebdd79e9f0491ca4ae40944f02", "patch": "@@ -1,76 +0,0 @@\n-//! Writing of the rustc metadata for dylibs\n-\n-use object::write::{Object, StandardSegment, Symbol, SymbolSection};\n-use object::{SectionKind, SymbolFlags, SymbolKind, SymbolScope};\n-\n-use rustc_metadata::EncodedMetadata;\n-use rustc_middle::ty::TyCtxt;\n-\n-// Adapted from https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src/librustc_codegen_llvm/base.rs#L47-L112\n-pub(crate) fn new_metadata_object(\n-    tcx: TyCtxt<'_>,\n-    cgu_name: &str,\n-    metadata: &EncodedMetadata,\n-) -> Vec<u8> {\n-    use snap::write::FrameEncoder;\n-    use std::io::Write;\n-\n-    let mut compressed = rustc_metadata::METADATA_HEADER.to_vec();\n-    FrameEncoder::new(&mut compressed).write_all(metadata.raw_data()).unwrap();\n-\n-    let triple = crate::target_triple(tcx.sess);\n-\n-    let binary_format = match triple.binary_format {\n-        target_lexicon::BinaryFormat::Elf => object::BinaryFormat::Elf,\n-        target_lexicon::BinaryFormat::Coff => object::BinaryFormat::Coff,\n-        target_lexicon::BinaryFormat::Macho => object::BinaryFormat::MachO,\n-        binary_format => tcx.sess.fatal(&format!(\"binary format {} is unsupported\", binary_format)),\n-    };\n-    let architecture = match triple.architecture {\n-        target_lexicon::Architecture::Aarch64(_) => object::Architecture::Aarch64,\n-        target_lexicon::Architecture::Arm(_) => object::Architecture::Arm,\n-        target_lexicon::Architecture::Avr => object::Architecture::Avr,\n-        target_lexicon::Architecture::Hexagon => object::Architecture::Hexagon,\n-        target_lexicon::Architecture::Mips32(_) => object::Architecture::Mips,\n-        target_lexicon::Architecture::Mips64(_) => object::Architecture::Mips64,\n-        target_lexicon::Architecture::Msp430 => object::Architecture::Msp430,\n-        target_lexicon::Architecture::Powerpc => object::Architecture::PowerPc,\n-        target_lexicon::Architecture::Powerpc64 => object::Architecture::PowerPc64,\n-        target_lexicon::Architecture::Powerpc64le => todo!(),\n-        target_lexicon::Architecture::Riscv32(_) => object::Architecture::Riscv32,\n-        target_lexicon::Architecture::Riscv64(_) => object::Architecture::Riscv64,\n-        target_lexicon::Architecture::S390x => object::Architecture::S390x,\n-        target_lexicon::Architecture::Sparc64 => object::Architecture::Sparc64,\n-        target_lexicon::Architecture::Sparcv9 => object::Architecture::Sparc64,\n-        target_lexicon::Architecture::X86_32(_) => object::Architecture::I386,\n-        target_lexicon::Architecture::X86_64 => object::Architecture::X86_64,\n-        architecture => {\n-            tcx.sess.fatal(&format!(\"target architecture {:?} is unsupported\", architecture,))\n-        }\n-    };\n-    let endian = match triple.endianness().unwrap() {\n-        target_lexicon::Endianness::Little => object::Endianness::Little,\n-        target_lexicon::Endianness::Big => object::Endianness::Big,\n-    };\n-\n-    let mut object = Object::new(binary_format, architecture, endian);\n-    object.add_file_symbol(cgu_name.as_bytes().to_vec());\n-\n-    let segment = object.segment_name(StandardSegment::Data).to_vec();\n-    let section_id = object.add_section(segment, b\".rustc\".to_vec(), SectionKind::Data);\n-    let offset = object.append_section_data(section_id, &compressed, 1);\n-    // For MachO and probably PE this is necessary to prevent the linker from throwing away the\n-    // .rustc section. For ELF this isn't necessary, but it also doesn't harm.\n-    object.add_symbol(Symbol {\n-        name: rustc_middle::middle::exported_symbols::metadata_symbol_name(tcx).into_bytes(),\n-        value: offset,\n-        size: compressed.len() as u64,\n-        kind: SymbolKind::Data,\n-        scope: SymbolScope::Dynamic,\n-        weak: false,\n-        section: SymbolSection::Section(section_id),\n-        flags: SymbolFlags::None,\n-    });\n-\n-    object.write().unwrap()\n-}"}, {"sha": "4dffb89e1057071035c32b32974cbaa4a3ad1dbc", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -57,7 +57,7 @@ use std::io::Write;\n \n use cranelift_codegen::{\n     entity::SecondaryMap,\n-    ir::{entities::AnyEntity, function::DisplayFunctionAnnotations},\n+    ir::entities::AnyEntity,\n     write::{FuncWriter, PlainWriter},\n };\n \n@@ -129,7 +129,6 @@ impl FuncWriter for &'_ CommentWriter {\n         &mut self,\n         w: &mut dyn fmt::Write,\n         func: &Function,\n-        reg_info: Option<&isa::RegInfo>,\n     ) -> Result<bool, fmt::Error> {\n         for comment in &self.global_comments {\n             if !comment.is_empty() {\n@@ -142,7 +141,7 @@ impl FuncWriter for &'_ CommentWriter {\n             writeln!(w)?;\n         }\n \n-        self.super_preamble(w, func, reg_info)\n+        self.super_preamble(w, func)\n     }\n \n     fn write_entity_definition(\n@@ -165,23 +164,21 @@ impl FuncWriter for &'_ CommentWriter {\n         &mut self,\n         w: &mut dyn fmt::Write,\n         func: &Function,\n-        isa: Option<&dyn isa::TargetIsa>,\n         block: Block,\n         indent: usize,\n     ) -> fmt::Result {\n-        PlainWriter.write_block_header(w, func, isa, block, indent)\n+        PlainWriter.write_block_header(w, func, block, indent)\n     }\n \n     fn write_instruction(\n         &mut self,\n         w: &mut dyn fmt::Write,\n         func: &Function,\n         aliases: &SecondaryMap<Value, Vec<Value>>,\n-        isa: Option<&dyn isa::TargetIsa>,\n         inst: Inst,\n         indent: usize,\n     ) -> fmt::Result {\n-        PlainWriter.write_instruction(w, func, aliases, isa, inst, indent)?;\n+        PlainWriter.write_instruction(w, func, aliases, inst, indent)?;\n         if let Some(comment) = self.entity_comments.get(&inst.into()) {\n             writeln!(w, \"; {}\", comment.replace('\\n', \"\\n; \"))?;\n         }\n@@ -249,7 +246,6 @@ pub(crate) fn write_clif_file<'tcx>(\n                 &mut clif_comments,\n                 &mut clif,\n                 &context.func,\n-                &DisplayFunctionAnnotations { isa: Some(isa), value_ranges: None },\n             )\n             .unwrap();\n \n@@ -278,7 +274,6 @@ impl fmt::Debug for FunctionCx<'_, '_, '_> {\n             &mut &self.clif_comments,\n             &mut clif,\n             &self.bcx.func,\n-            &DisplayFunctionAnnotations::default(),\n         )\n         .unwrap();\n         writeln!(f, \"\\n{}\", clif)"}, {"sha": "99b5366e3499359470f5d946f05aca567db1998e", "filename": "compiler/rustc_codegen_cranelift/src/trap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -9,7 +9,7 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n             \"puts\",\n             Linkage::Import,\n             &Signature {\n-                call_conv: CallConv::triple_default(fx.triple()),\n+                call_conv: fx.target_config.default_call_conv,\n                 params: vec![AbiParam::new(fx.pointer_type)],\n                 returns: vec![AbiParam::new(types::I32)],\n             },"}, {"sha": "f29d13ccabddd25b4bd4a208ac2fa32df2fb937e", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -329,7 +329,6 @@ impl<'tcx> CPlace<'tcx> {\n             // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n             // specify stack slot alignment.\n             size: (u32::try_from(layout.size.bytes()).unwrap() + 15) / 16 * 16,\n-            offset: None,\n         });\n         CPlace { inner: CPlaceInner::Addr(Pointer::stack_slot(stack_slot), None), layout }\n     }\n@@ -472,7 +471,6 @@ impl<'tcx> CPlace<'tcx> {\n                         // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n                         // specify stack slot alignment.\n                         size: (src_ty.bytes() + 15) / 16 * 16,\n-                        offset: None,\n                     });\n                     let ptr = Pointer::stack_slot(stack_slot);\n                     ptr.store(fx, data, MemFlags::trusted());\n@@ -512,6 +510,26 @@ impl<'tcx> CPlace<'tcx> {\n         let dst_layout = self.layout();\n         let to_ptr = match self.inner {\n             CPlaceInner::Var(_local, var) => {\n+                if let ty::Array(element, len) = dst_layout.ty.kind() {\n+                    // Can only happen for vector types\n+                    let len =\n+                        u16::try_from(len.eval_usize(fx.tcx, ParamEnv::reveal_all())).unwrap();\n+                    let vector_ty = fx.clif_type(element).unwrap().by(len).unwrap();\n+\n+                    let data = match from.0 {\n+                        CValueInner::ByRef(ptr, None) => {\n+                            let mut flags = MemFlags::new();\n+                            flags.set_notrap();\n+                            ptr.load(fx, vector_ty, flags)\n+                        }\n+                        CValueInner::ByVal(_)\n+                        | CValueInner::ByValPair(_, _)\n+                        | CValueInner::ByRef(_, Some(_)) => bug!(\"array should be ByRef\"),\n+                    };\n+\n+                    fx.bcx.def_var(var, data);\n+                    return;\n+                }\n                 let data = CValue(from.0, dst_layout).load_scalar(fx);\n                 let dst_ty = fx.clif_type(self.layout().ty).unwrap();\n                 transmute_value(fx, var, data, dst_ty);\n@@ -583,7 +601,7 @@ impl<'tcx> CPlace<'tcx> {\n                 let src_align = src_layout.align.abi.bytes() as u8;\n                 let dst_align = dst_layout.align.abi.bytes() as u8;\n                 fx.bcx.emit_small_memory_copy(\n-                    fx.module.target_config(),\n+                    fx.target_config,\n                     to_addr,\n                     from_addr,\n                     size,\n@@ -605,14 +623,39 @@ impl<'tcx> CPlace<'tcx> {\n         let layout = self.layout();\n \n         match self.inner {\n-            CPlaceInner::Var(local, var) => {\n-                if let Abi::Vector { .. } = layout.abi {\n+            CPlaceInner::Var(local, var) => match layout.ty.kind() {\n+                ty::Array(_, _) => {\n+                    // Can only happen for vector types\n                     return CPlace {\n                         inner: CPlaceInner::VarLane(local, var, field.as_u32().try_into().unwrap()),\n                         layout: layout.field(fx, field.as_u32().try_into().unwrap()),\n                     };\n                 }\n-            }\n+                ty::Adt(adt_def, substs) if layout.ty.is_simd() => {\n+                    let f0_ty = adt_def.non_enum_variant().fields[0].ty(fx.tcx, substs);\n+\n+                    match f0_ty.kind() {\n+                        ty::Array(_, _) => {\n+                            assert_eq!(field.as_u32(), 0);\n+                            return CPlace {\n+                                inner: CPlaceInner::Var(local, var),\n+                                layout: layout.field(fx, field.as_u32().try_into().unwrap()),\n+                            };\n+                        }\n+                        _ => {\n+                            return CPlace {\n+                                inner: CPlaceInner::VarLane(\n+                                    local,\n+                                    var,\n+                                    field.as_u32().try_into().unwrap(),\n+                                ),\n+                                layout: layout.field(fx, field.as_u32().try_into().unwrap()),\n+                            };\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            },\n             CPlaceInner::VarPair(local, var1, var2) => {\n                 let layout = layout.field(&*fx, field.index());\n \n@@ -629,7 +672,12 @@ impl<'tcx> CPlace<'tcx> {\n \n         let (field_ptr, field_layout) = codegen_field(fx, base, extra, layout, field);\n         if field_layout.is_unsized() {\n-            CPlace::for_ptr_with_extra(field_ptr, extra.unwrap(), field_layout)\n+            if let ty::Foreign(_) = field_layout.ty.kind() {\n+                assert!(extra.is_none());\n+                CPlace::for_ptr(field_ptr, field_layout)\n+            } else {\n+                CPlace::for_ptr_with_extra(field_ptr, extra.unwrap(), field_layout)\n+            }\n         } else {\n             CPlace::for_ptr(field_ptr, field_layout)\n         }"}, {"sha": "98b114de91078910d97a788605f64e59790ff95a", "filename": "compiler/rustc_codegen_cranelift/y.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_codegen_cranelift%2Fy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fy.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -43,7 +43,9 @@ mod utils;\n fn usage() {\n     eprintln!(\"Usage:\");\n     eprintln!(\"  ./y.rs prepare\");\n-    eprintln!(\"  ./y.rs build [--debug] [--sysroot none|clif|llvm] [--target-dir DIR]\");\n+    eprintln!(\n+        \"  ./y.rs build [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n+    );\n }\n \n macro_rules! arg_error {\n@@ -92,6 +94,7 @@ fn main() {\n     let mut target_dir = PathBuf::from(\"build\");\n     let mut channel = \"release\";\n     let mut sysroot_kind = SysrootKind::Clif;\n+    let mut use_unstable_features = true;\n     while let Some(arg) = args.next().as_deref() {\n         match arg {\n             \"--target-dir\" => {\n@@ -109,6 +112,7 @@ fn main() {\n                     None => arg_error!(\"--sysroot requires argument\"),\n                 }\n             }\n+            \"--no-unstable-features\" => use_unstable_features = false,\n             flag if flag.starts_with(\"-\") => arg_error!(\"Unknown flag {}\", flag),\n             arg => arg_error!(\"Unexpected argument {}\", arg),\n         }\n@@ -141,7 +145,8 @@ fn main() {\n         process::exit(1);\n     }\n \n-    let cg_clif_build_dir = build_backend::build_backend(channel, &host_triple);\n+    let cg_clif_build_dir =\n+        build_backend::build_backend(channel, &host_triple, use_unstable_features);\n     build_sysroot::build_sysroot(\n         channel,\n         sysroot_kind,"}, {"sha": "69c376c6169ba3279d300efc544a09685628d9a8", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -661,14 +661,22 @@ pub trait LintContext: Sized {\n                 BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {\n                     db.span_suggestion(span, &note, sugg, Applicability::MaybeIncorrect);\n                 }\n-                BuiltinLintDiagnostics::UnusedImports(message, replaces) => {\n+                BuiltinLintDiagnostics::UnusedImports(message, replaces, in_test_module) => {\n                     if !replaces.is_empty() {\n                         db.tool_only_multipart_suggestion(\n                             &message,\n                             replaces,\n                             Applicability::MachineApplicable,\n                         );\n                     }\n+\n+                    if let Some(span) = in_test_module {\n+                        let def_span = self.sess().source_map().guess_head_span(span);\n+                        db.span_help(\n+                            span.shrink_to_lo().to(def_span),\n+                            \"consider adding a `#[cfg(test)]` to the containing module\",\n+                        );\n+                    }\n                 }\n                 BuiltinLintDiagnostics::RedundantImport(spans, ident) => {\n                     for (span, is_imported) in spans {"}, {"sha": "97f6df51f88dd1ee4918b3fe1f8741e8f902b727", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -289,7 +289,7 @@ pub enum BuiltinLintDiagnostics {\n     ProcMacroDeriveResolutionFallback(Span),\n     MacroExpandedMacroExportsAccessedByAbsolutePaths(Span),\n     UnknownCrateTypes(Span, String, String),\n-    UnusedImports(String, Vec<(Span, String)>),\n+    UnusedImports(String, Vec<(Span, String)>, Option<Span>),\n     RedundantImport(Vec<(Span, bool)>, Ident),\n     DeprecatedMacro(Option<Symbol>, Span),\n     MissingAbi(Span, Abi),"}, {"sha": "4e5d21049a0d98597bb419df916ad002b851fa29", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -17,7 +17,7 @@ use rustc_session::utils::NativeLibKind;\n use rustc_session::{Session, StableCrateId};\n use rustc_span::hygiene::{ExpnHash, ExpnId};\n use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{kw, Symbol};\n \n use rustc_data_structures::sync::Lrc;\n use smallvec::SmallVec;\n@@ -295,6 +295,10 @@ pub fn provide(providers: &mut Providers) {\n             use std::collections::vec_deque::VecDeque;\n \n             let mut visible_parent_map: DefIdMap<DefId> = Default::default();\n+            // This is a secondary visible_parent_map, storing the DefId of parents that re-export\n+            // the child as `_`. Since we prefer parents that don't do this, merge this map at the\n+            // end, only if we're missing any keys from the former.\n+            let mut fallback_map: DefIdMap<DefId> = Default::default();\n \n             // Issue 46112: We want the map to prefer the shortest\n             // paths when reporting the path to an item. Therefore we\n@@ -317,12 +321,17 @@ pub fn provide(providers: &mut Providers) {\n                 bfs_queue.push_back(DefId { krate: cnum, index: CRATE_DEF_INDEX });\n             }\n \n-            let mut add_child = |bfs_queue: &mut VecDeque<_>, child: &Export, parent: DefId| {\n-                if !child.vis.is_public() {\n+            let mut add_child = |bfs_queue: &mut VecDeque<_>, export: &Export, parent: DefId| {\n+                if !export.vis.is_public() {\n                     return;\n                 }\n \n-                if let Some(child) = child.res.opt_def_id() {\n+                if let Some(child) = export.res.opt_def_id() {\n+                    if export.ident.name == kw::Underscore {\n+                        fallback_map.insert(child, parent);\n+                        return;\n+                    }\n+\n                     match visible_parent_map.entry(child) {\n                         Entry::Occupied(mut entry) => {\n                             // If `child` is defined in crate `cnum`, ensure\n@@ -345,6 +354,12 @@ pub fn provide(providers: &mut Providers) {\n                 }\n             }\n \n+            // Fill in any missing entries with the (less preferable) path ending in `::_`.\n+            // We still use this path in a diagnostic that suggests importing `::*`.\n+            for (child, parent) in fallback_map {\n+                visible_parent_map.entry(child).or_insert(parent);\n+            }\n+\n             visible_parent_map\n         },\n "}, {"sha": "47a9234419c2d9ca5c066bbf5dba383ae1c915d4", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -319,6 +319,9 @@ pub trait PrettyPrinter<'tcx>:\n     ///\n     /// `callers` is a chain of visible_parent's leading to `def_id`,\n     /// to support cycle detection during recursion.\n+    ///\n+    /// This method returns false if we can't print the visible path, so\n+    /// `print_def_path` can fall back on the item's real definition path.\n     fn try_print_visible_def_path_recur(\n         mut self,\n         def_id: DefId,\n@@ -405,19 +408,7 @@ pub trait PrettyPrinter<'tcx>:\n             Some(parent) => parent,\n             None => return Ok((self, false)),\n         };\n-        if callers.contains(&visible_parent) {\n-            return Ok((self, false));\n-        }\n-        callers.push(visible_parent);\n-        // HACK(eddyb) this bypasses `path_append`'s prefix printing to avoid\n-        // knowing ahead of time whether the entire path will succeed or not.\n-        // To support printers that do not implement `PrettyPrinter`, a `Vec` or\n-        // linked list on the stack would need to be built, before any printing.\n-        match self.try_print_visible_def_path_recur(visible_parent, callers)? {\n-            (cx, false) => return Ok((cx, false)),\n-            (cx, true) => self = cx,\n-        }\n-        callers.pop();\n+\n         let actual_parent = self.tcx().parent(def_id);\n         debug!(\n             \"try_print_visible_def_path: visible_parent={:?} actual_parent={:?}\",\n@@ -463,14 +454,21 @@ pub trait PrettyPrinter<'tcx>:\n             // `visible_parent_map`), looking for the specific child we currently have and then\n             // have access to the re-exported name.\n             DefPathData::TypeNs(ref mut name) if Some(visible_parent) != actual_parent => {\n+                // Item might be re-exported several times, but filter for the one\n+                // that's public and whose identifier isn't `_`.\n                 let reexport = self\n                     .tcx()\n                     .item_children(visible_parent)\n                     .iter()\n-                    .find(|child| child.res.opt_def_id() == Some(def_id))\n+                    .filter(|child| child.res.opt_def_id() == Some(def_id))\n+                    .find(|child| child.vis.is_public() && child.ident.name != kw::Underscore)\n                     .map(|child| child.ident.name);\n-                if let Some(reexport) = reexport {\n-                    *name = reexport;\n+\n+                if let Some(new_name) = reexport {\n+                    *name = new_name;\n+                } else {\n+                    // There is no name that is public and isn't `_`, so bail.\n+                    return Ok((self, false));\n                 }\n             }\n             // Re-exported `extern crate` (#43189).\n@@ -481,6 +479,20 @@ pub trait PrettyPrinter<'tcx>:\n         }\n         debug!(\"try_print_visible_def_path: data={:?}\", data);\n \n+        if callers.contains(&visible_parent) {\n+            return Ok((self, false));\n+        }\n+        callers.push(visible_parent);\n+        // HACK(eddyb) this bypasses `path_append`'s prefix printing to avoid\n+        // knowing ahead of time whether the entire path will succeed or not.\n+        // To support printers that do not implement `PrettyPrinter`, a `Vec` or\n+        // linked list on the stack would need to be built, before any printing.\n+        match self.try_print_visible_def_path_recur(visible_parent, callers)? {\n+            (cx, false) => return Ok((cx, false)),\n+            (cx, true) => self = cx,\n+        }\n+        callers.pop();\n+\n         Ok((self.path_append(Ok, &DisambiguatedDefPathData { data, disambiguator: 0 })?, true))\n     }\n "}, {"sha": "74edc3a2d5e6ff4aab7c25e957a171beafdb59f9", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -108,7 +108,7 @@ impl<'a> Resolver<'a> {\n     /// Reachable macros with block module parents exist due to `#[macro_export] macro_rules!`,\n     /// but they cannot use def-site hygiene, so the assumption holds\n     /// (<https://github.com/rust-lang/rust/pull/77984#issuecomment-712445508>).\n-    fn get_nearest_non_block_module(&mut self, mut def_id: DefId) -> Module<'a> {\n+    crate fn get_nearest_non_block_module(&mut self, mut def_id: DefId) -> Module<'a> {\n         loop {\n             match self.get_module(def_id) {\n                 Some(module) => return module,"}, {"sha": "601f2d96ff5eb5b1df61a7d502e78c0fb792475f", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -24,6 +24,7 @@\n //    in the last step\n \n use crate::imports::ImportKind;\n+use crate::module_to_string;\n use crate::Resolver;\n \n use rustc_ast as ast;\n@@ -314,12 +315,29 @@ impl Resolver<'_> {\n                 \"remove the unused import\"\n             };\n \n+            let parent_module = visitor.r.get_nearest_non_block_module(\n+                visitor.r.local_def_id(unused.use_tree_id).to_def_id(),\n+            );\n+            let test_module_span = match module_to_string(parent_module) {\n+                Some(module)\n+                    if module == \"test\"\n+                        || module == \"tests\"\n+                        || module.starts_with(\"test_\")\n+                        || module.starts_with(\"tests_\")\n+                        || module.ends_with(\"_test\")\n+                        || module.ends_with(\"_tests\") =>\n+                {\n+                    Some(parent_module.span)\n+                }\n+                _ => None,\n+            };\n+\n             visitor.r.lint_buffer.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n                 unused.use_tree_id,\n                 ms,\n                 &msg,\n-                BuiltinLintDiagnostics::UnusedImports(fix_msg.into(), fixes),\n+                BuiltinLintDiagnostics::UnusedImports(fix_msg.into(), fixes, test_module_span),\n             );\n         }\n     }"}, {"sha": "d5a4de86d4d1eea4d3ea32967c4aadf5fdee1903", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 68, "deletions": 7, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::fast_reject::{simplify_type, SimplifyParams, StripReferences};\n use rustc_middle::ty::print::with_crate_prefix;\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_span::lev_distance;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{source_map, FileName, MultiSpan, Span, Symbol};\n@@ -1310,25 +1310,66 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         mut msg: String,\n         candidates: Vec<DefId>,\n     ) {\n+        let parent_map = self.tcx.visible_parent_map(());\n+\n+        // Separate out candidates that must be imported with a glob, because they are named `_`\n+        // and cannot be referred with their identifier.\n+        let (candidates, globs): (Vec<_>, Vec<_>) = candidates.into_iter().partition(|trait_did| {\n+            if let Some(parent_did) = parent_map.get(trait_did) {\n+                // If the item is re-exported as `_`, we should suggest a glob-import instead.\n+                if Some(*parent_did) != self.tcx.parent(*trait_did)\n+                    && self\n+                        .tcx\n+                        .item_children(*parent_did)\n+                        .iter()\n+                        .filter(|child| child.res.opt_def_id() == Some(*trait_did))\n+                        .all(|child| child.ident.name == kw::Underscore)\n+                {\n+                    return false;\n+                }\n+            }\n+\n+            true\n+        });\n+\n         let module_did = self.tcx.parent_module(self.body_id);\n         let (span, found_use) = find_use_placement(self.tcx, module_did);\n         if let Some(span) = span {\n-            let path_strings = candidates.iter().map(|did| {\n+            let path_strings = candidates.iter().map(|trait_did| {\n                 // Produce an additional newline to separate the new use statement\n                 // from the directly following item.\n                 let additional_newline = if found_use { \"\" } else { \"\\n\" };\n                 format!(\n                     \"use {};\\n{}\",\n-                    with_crate_prefix(|| self.tcx.def_path_str(*did)),\n+                    with_crate_prefix(|| self.tcx.def_path_str(*trait_did)),\n                     additional_newline\n                 )\n             });\n \n-            err.span_suggestions(span, &msg, path_strings, Applicability::MaybeIncorrect);\n+            let glob_path_strings = globs.iter().map(|trait_did| {\n+                let parent_did = parent_map.get(trait_did).unwrap();\n+\n+                // Produce an additional newline to separate the new use statement\n+                // from the directly following item.\n+                let additional_newline = if found_use { \"\" } else { \"\\n\" };\n+                format!(\n+                    \"use {}::*; // trait {}\\n{}\",\n+                    with_crate_prefix(|| self.tcx.def_path_str(*parent_did)),\n+                    self.tcx.item_name(*trait_did),\n+                    additional_newline\n+                )\n+            });\n+\n+            err.span_suggestions(\n+                span,\n+                &msg,\n+                path_strings.chain(glob_path_strings),\n+                Applicability::MaybeIncorrect,\n+            );\n         } else {\n-            let limit = if candidates.len() == 5 { 5 } else { 4 };\n+            let limit = if candidates.len() + globs.len() == 5 { 5 } else { 4 };\n             for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n-                if candidates.len() > 1 {\n+                if candidates.len() + globs.len() > 1 {\n                     msg.push_str(&format!(\n                         \"\\ncandidate #{}: `use {};`\",\n                         i + 1,\n@@ -1341,8 +1382,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ));\n                 }\n             }\n+            for (i, trait_did) in\n+                globs.iter().take(limit.saturating_sub(candidates.len())).enumerate()\n+            {\n+                let parent_did = parent_map.get(trait_did).unwrap();\n+\n+                if candidates.len() + globs.len() > 1 {\n+                    msg.push_str(&format!(\n+                        \"\\ncandidate #{}: `use {}::*; // trait {}`\",\n+                        candidates.len() + i + 1,\n+                        with_crate_prefix(|| self.tcx.def_path_str(*parent_did)),\n+                        self.tcx.item_name(*trait_did),\n+                    ));\n+                } else {\n+                    msg.push_str(&format!(\n+                        \"\\n`use {}::*; // trait {}`\",\n+                        with_crate_prefix(|| self.tcx.def_path_str(*parent_did)),\n+                        self.tcx.item_name(*trait_did),\n+                    ));\n+                }\n+            }\n             if candidates.len() > limit {\n-                msg.push_str(&format!(\"\\nand {} others\", candidates.len() - limit));\n+                msg.push_str(&format!(\"\\nand {} others\", candidates.len() + globs.len() - limit));\n             }\n             err.note(&msg);\n         }"}, {"sha": "a93327a0132edcf5cb9c8f27932c0f8811e3d0c5", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -163,8 +163,9 @@ impl<T: ?Sized> *const T {\n     /// }\n     /// ```\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n     #[inline]\n-    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n+    pub const unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n         // SAFETY: the caller must guarantee that `self` is valid\n         // for a reference if it isn't null.\n         if self.is_null() { None } else { unsafe { Some(&*self) } }\n@@ -211,7 +212,8 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_ref<'a>(self) -> Option<&'a MaybeUninit<T>>\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n+    pub const unsafe fn as_uninit_ref<'a>(self) -> Option<&'a MaybeUninit<T>>\n     where\n         T: Sized,\n     {\n@@ -1068,7 +1070,8 @@ impl<T> *const [T] {\n     /// [allocated object]: crate::ptr#allocated-object\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n+    pub const unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {\n         if self.is_null() {\n             None\n         } else {"}, {"sha": "5fd3b2ebc60989567e2a7e8a80452a6ef90d4d49", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -166,8 +166,9 @@ impl<T: ?Sized> *mut T {\n     /// }\n     /// ```\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n     #[inline]\n-    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n+    pub const unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n         // SAFETY: the caller must guarantee that `self` is valid for a\n         // reference if it isn't null.\n         if self.is_null() { None } else { unsafe { Some(&*self) } }\n@@ -217,7 +218,8 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_ref<'a>(self) -> Option<&'a MaybeUninit<T>>\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n+    pub const unsafe fn as_uninit_ref<'a>(self) -> Option<&'a MaybeUninit<T>>\n     where\n         T: Sized,\n     {\n@@ -411,8 +413,9 @@ impl<T: ?Sized> *mut T {\n     /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n     /// ```\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n     #[inline]\n-    pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n+    pub const unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n         // SAFETY: the caller must guarantee that `self` is be valid for\n         // a mutable reference if it isn't null.\n         if self.is_null() { None } else { unsafe { Some(&mut *self) } }\n@@ -446,7 +449,8 @@ impl<T: ?Sized> *mut T {\n     /// [the module documentation]: crate::ptr#safety\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_mut<'a>(self) -> Option<&'a mut MaybeUninit<T>>\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n+    pub const unsafe fn as_uninit_mut<'a>(self) -> Option<&'a mut MaybeUninit<T>>\n     where\n         T: Sized,\n     {\n@@ -1335,7 +1339,8 @@ impl<T> *mut [T] {\n     /// [allocated object]: crate::ptr#allocated-object\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n+    pub const unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {\n         if self.is_null() {\n             None\n         } else {\n@@ -1386,7 +1391,8 @@ impl<T> *mut [T] {\n     /// [allocated object]: crate::ptr#allocated-object\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_slice_mut<'a>(self) -> Option<&'a mut [MaybeUninit<T>]> {\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n+    pub const unsafe fn as_uninit_slice_mut<'a>(self) -> Option<&'a mut [MaybeUninit<T>]> {\n         if self.is_null() {\n             None\n         } else {"}, {"sha": "3a7e99faccf23d2ff927bf0f1f78e82aec1a96e3", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -122,7 +122,8 @@ impl<T: Sized> NonNull<T> {\n     #[inline]\n     #[must_use]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_ref<'a>(&self) -> &'a MaybeUninit<T> {\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n+    pub const unsafe fn as_uninit_ref<'a>(&self) -> &'a MaybeUninit<T> {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a reference.\n         unsafe { &*self.cast().as_ptr() }\n@@ -155,7 +156,8 @@ impl<T: Sized> NonNull<T> {\n     #[inline]\n     #[must_use]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_mut<'a>(&mut self) -> &'a mut MaybeUninit<T> {\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n+    pub const unsafe fn as_uninit_mut<'a>(&mut self) -> &'a mut MaybeUninit<T> {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a reference.\n         unsafe { &mut *self.cast().as_ptr() }\n@@ -316,9 +318,10 @@ impl<T: ?Sized> NonNull<T> {\n     ///\n     /// [the module documentation]: crate::ptr#safety\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n     #[must_use]\n     #[inline]\n-    pub unsafe fn as_ref<'a>(&self) -> &'a T {\n+    pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a reference.\n         unsafe { &*self.as_ptr() }\n@@ -366,9 +369,10 @@ impl<T: ?Sized> NonNull<T> {\n     ///\n     /// [the module documentation]: crate::ptr#safety\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n     #[must_use]\n     #[inline]\n-    pub unsafe fn as_mut<'a>(&mut self) -> &'a mut T {\n+    pub const unsafe fn as_mut<'a>(&mut self) -> &'a mut T {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a mutable reference.\n         unsafe { &mut *self.as_ptr() }\n@@ -534,7 +538,8 @@ impl<T> NonNull<[T]> {\n     #[inline]\n     #[must_use]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_slice<'a>(&self) -> &'a [MaybeUninit<T>] {\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n+    pub const unsafe fn as_uninit_slice<'a>(&self) -> &'a [MaybeUninit<T>] {\n         // SAFETY: the caller must uphold the safety contract for `as_uninit_slice`.\n         unsafe { slice::from_raw_parts(self.cast().as_ptr(), self.len()) }\n     }\n@@ -596,7 +601,8 @@ impl<T> NonNull<[T]> {\n     #[inline]\n     #[must_use]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_slice_mut<'a>(&self) -> &'a mut [MaybeUninit<T>] {\n+    #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n+    pub const unsafe fn as_uninit_slice_mut<'a>(&self) -> &'a mut [MaybeUninit<T>] {\n         // SAFETY: the caller must uphold the safety contract for `as_uninit_slice_mut`.\n         unsafe { slice::from_raw_parts_mut(self.cast().as_ptr(), self.len()) }\n     }"}, {"sha": "5ef23871e8b5f37f9c4d369e07fe30b161cc5ee2", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -2462,17 +2462,16 @@ impl<'a, K, V> Entry<'a, K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(entry_insert)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<&str, String> = HashMap::new();\n-    /// let entry = map.entry(\"poneyland\").insert(\"hoho\".to_string());\n+    /// let entry = map.entry(\"poneyland\").insert_entry(\"hoho\".to_string());\n     ///\n     /// assert_eq!(entry.key(), &\"poneyland\");\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"entry_insert\", issue = \"65225\")]\n-    pub fn insert(self, value: V) -> OccupiedEntry<'a, K, V> {\n+    #[stable(feature = \"entry_insert\", since = \"1.59.0\")]\n+    pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {\n         match self {\n             Occupied(mut entry) => {\n                 entry.insert(value);\n@@ -2811,12 +2810,13 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// let mut map: HashMap<&str, u32> = HashMap::new();\n     ///\n     /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n-    ///     o.insert(37);\n+    ///     o.insert_entry(37);\n     /// }\n     /// assert_eq!(map[\"poneyland\"], 37);\n     /// ```\n     #[inline]\n-    fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {\n+    #[stable(feature = \"entry_insert\", since = \"1.59.0\")]\n+    pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {\n         let base = self.base.insert_entry(value);\n         OccupiedEntry { base }\n     }"}, {"sha": "bcf2ec06022d9a0d7d4f8f170f7ef0b12fee83c0", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -1273,7 +1273,7 @@ impl<T> JoinInner<T> {\n /// An owned permission to join on a thread (block on its termination).\n ///\n /// A `JoinHandle` *detaches* the associated thread when it is dropped, which\n-/// means that there is no longer any handle to thread and no way to `join`\n+/// means that there is no longer any handle to the thread and no way to `join`\n /// on it.\n ///\n /// Due to platform restrictions, it is not possible to [`Clone`] this"}, {"sha": "971bd3930cffda487acc85eaad8a12de06400d69", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -152,16 +152,26 @@ window.initSearch = function(rawSearchIndex) {\n         removeEmptyStringsFromArray(split);\n \n         function transformResults(results) {\n+            var duplicates = {};\n             var out = [];\n+\n             for (var i = 0, len = results.length; i < len; ++i) {\n-                if (results[i].id > -1) {\n-                    var obj = searchIndex[results[i].id];\n-                    obj.lev = results[i].lev;\n+                var result = results[i];\n+\n+                if (result.id > -1) {\n+                    var obj = searchIndex[result.id];\n+                    obj.lev = result.lev;\n                     var res = buildHrefAndPath(obj);\n                     obj.displayPath = pathSplitter(res[0]);\n                     obj.fullPath = obj.displayPath + obj.name;\n                     // To be sure than it some items aren't considered as duplicate.\n                     obj.fullPath += \"|\" + obj.ty;\n+\n+                    if (duplicates[obj.fullPath]) {\n+                        continue;\n+                    }\n+                    duplicates[obj.fullPath] = true;\n+\n                     obj.href = res[1];\n                     out.push(obj);\n                     if (out.length >= MAX_RESULTS) {\n@@ -971,19 +981,11 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         var output = document.createElement(\"div\");\n-        var duplicates = {};\n         var length = 0;\n         if (array.length > 0) {\n             output.className = \"search-results \" + extraClass;\n \n             array.forEach(function(item) {\n-                if (item.is_alias !== true) {\n-                    if (duplicates[item.fullPath]) {\n-                        return;\n-                    }\n-                    duplicates[item.fullPath] = true;\n-                }\n-\n                 var name = item.name;\n                 var type = itemTypes[item.ty];\n "}, {"sha": "2a25d60acff7bf9556cdf6d26a3a50910f4c5667", "filename": "src/test/ui/imports/auxiliary/overlapping_pub_trait_source.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Foverlapping_pub_trait_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Foverlapping_pub_trait_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Foverlapping_pub_trait_source.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -0,0 +1,13 @@\n+/* This crate declares an item as both `prelude::*` and `m::Tr`.\n+ * The compiler should always suggest `m::Tr`. */\n+\n+pub struct S;\n+\n+pub mod prelude {\n+    pub use crate::m::Tr as _;\n+}\n+\n+pub mod m {\n+    pub trait Tr { fn method(&self); }\n+    impl Tr for crate::S { fn method(&self) {} }\n+}"}, {"sha": "d73c9a795b673c04e4d31f10960b5ea172a00908", "filename": "src/test/ui/imports/auxiliary/unnamed_pub_trait_source.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Funnamed_pub_trait_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Funnamed_pub_trait_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Funnamed_pub_trait_source.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -0,0 +1,13 @@\n+/* This crate declares an item that is unnamed.\n+ * Its only public path is through `prelude::*`. */\n+\n+pub struct S;\n+\n+mod m {\n+    pub trait Tr { fn method(&self); }\n+    impl Tr for crate::S { fn method(&self) {} }\n+}\n+\n+pub mod prelude {\n+    pub use crate::m::Tr as _;\n+}"}, {"sha": "f5f5d4ed3804fe8c008f4d21e95d1baf09858813", "filename": "src/test/ui/imports/overlapping_pub_trait.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -0,0 +1,15 @@\n+// aux-build:overlapping_pub_trait_source.rs\n+\n+/*\n+ * This crate declares two public paths, `m::Tr` and `prelude::_`. Make sure we prefer the former.\n+ */\n+extern crate overlapping_pub_trait_source;\n+\n+fn main() {\n+    //~^ HELP the following trait is implemented but not in scope; perhaps add a `use` for it:\n+    //~| SUGGESTION overlapping_pub_trait_source::m::Tr\n+    use overlapping_pub_trait_source::S;\n+    S.method();\n+    //~^ ERROR no method named `method` found for struct `S` in the current scope [E0599]\n+    //~| HELP items from traits can only be used if the trait is in scope\n+}"}, {"sha": "d0c845a5e523f1588d7b2955818742e2fd6d22c3", "filename": "src/test/ui/imports/overlapping_pub_trait.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.stderr?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -0,0 +1,20 @@\n+error[E0599]: no method named `method` found for struct `S` in the current scope\n+  --> $DIR/overlapping_pub_trait.rs:12:7\n+   |\n+LL |     S.method();\n+   |       ^^^^^^ method not found in `S`\n+   |\n+  ::: $DIR/auxiliary/overlapping_pub_trait_source.rs:11:23\n+   |\n+LL |     pub trait Tr { fn method(&self); }\n+   |                       ------ the method is available for `S` here\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n+   |\n+LL | use overlapping_pub_trait_source::m::Tr;\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "b06b1e1d07dced7d1c671982a69aed9583da0bc5", "filename": "src/test/ui/imports/unnamed_pub_trait.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -0,0 +1,16 @@\n+// aux-build:unnamed_pub_trait_source.rs\n+\n+/*\n+ * This crate declares an unnameable public path for our item. Make sure we don't suggest\n+ * importing it by name, and instead we suggest importing it by glob.\n+ */\n+extern crate unnamed_pub_trait_source;\n+\n+fn main() {\n+    //~^ HELP the following trait is implemented but not in scope; perhaps add a `use` for it:\n+    //~| SUGGESTION unnamed_pub_trait_source::prelude::*; // trait Tr\n+    use unnamed_pub_trait_source::S;\n+    S.method();\n+    //~^ ERROR no method named `method` found for struct `S` in the current scope [E0599]\n+    //~| HELP items from traits can only be used if the trait is in scope\n+}"}, {"sha": "319dfd7e1b28b9e952d9513565f20a3c6c26e853", "filename": "src/test/ui/imports/unnamed_pub_trait.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.stderr?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -0,0 +1,20 @@\n+error[E0599]: no method named `method` found for struct `S` in the current scope\n+  --> $DIR/unnamed_pub_trait.rs:13:7\n+   |\n+LL |     S.method();\n+   |       ^^^^^^ method not found in `S`\n+   |\n+  ::: $DIR/auxiliary/unnamed_pub_trait_source.rs:7:23\n+   |\n+LL |     pub trait Tr { fn method(&self); }\n+   |                       ------ the method is available for `S` here\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n+   |\n+LL | use unnamed_pub_trait_source::prelude::*; // trait Tr\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "b003b99b6cff0e08d783d27cba298d98f59fc592", "filename": "src/test/ui/imports/unused-imports-in-test-module.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Funused-imports-in-test-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Funused-imports-in-test-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Funused-imports-in-test-module.rs?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -0,0 +1,64 @@\n+#![deny(unused_imports)]\n+\n+use std::io::BufRead; //~ ERROR unused import: `std::io::BufRead`\n+\n+fn a() {}\n+fn b() {}\n+\n+mod test {\n+    use super::a;  //~ ERROR unused import: `super::a`\n+\n+    fn foo() {\n+        use crate::b;  //~ ERROR unused import: `crate::b`\n+    }\n+}\n+\n+mod tests {\n+    use super::a;  //~ ERROR unused import: `super::a`\n+\n+    fn foo() {\n+        use crate::b;  //~ ERROR unused import: `crate::b`\n+    }\n+}\n+\n+mod test_a {\n+    use super::a;  //~ ERROR unused import: `super::a`\n+\n+    fn foo() {\n+        use crate::b;  //~ ERROR unused import: `crate::b`\n+    }\n+}\n+\n+mod a_test {\n+    use super::a;  //~ ERROR unused import: `super::a`\n+\n+    fn foo() {\n+        use crate::b;  //~ ERROR unused import: `crate::b`\n+    }\n+}\n+\n+mod tests_a {\n+    use super::a;  //~ ERROR unused import: `super::a`\n+\n+    fn foo() {\n+        use crate::b;  //~ ERROR unused import: `crate::b`\n+    }\n+}\n+\n+mod a_tests {\n+    use super::a;  //~ ERROR unused import: `super::a`\n+\n+    fn foo() {\n+        use crate::b;  //~ ERROR unused import: `crate::b`\n+    }\n+}\n+\n+mod fastest_search {\n+    use super::a;  //~ ERROR unused import: `super::a`\n+\n+    fn foo() {\n+        use crate::b;  //~ ERROR unused import: `crate::b`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2efea5b3609e17badb57075b95b9649ed506da83", "filename": "src/test/ui/imports/unused-imports-in-test-module.stderr", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Funused-imports-in-test-module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d57c61a9e04dcd3df633f41142009d6dcad4399/src%2Ftest%2Fui%2Fimports%2Funused-imports-in-test-module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Funused-imports-in-test-module.stderr?ref=3d57c61a9e04dcd3df633f41142009d6dcad4399", "patch": "@@ -0,0 +1,170 @@\n+error: unused import: `std::io::BufRead`\n+  --> $DIR/unused-imports-in-test-module.rs:3:5\n+   |\n+LL | use std::io::BufRead;\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused-imports-in-test-module.rs:1:9\n+   |\n+LL | #![deny(unused_imports)]\n+   |         ^^^^^^^^^^^^^^\n+\n+error: unused import: `super::a`\n+  --> $DIR/unused-imports-in-test-module.rs:9:9\n+   |\n+LL |     use super::a;\n+   |         ^^^^^^^^\n+   |\n+help: consider adding a `#[cfg(test)]` to the containing module\n+  --> $DIR/unused-imports-in-test-module.rs:8:1\n+   |\n+LL | mod test {\n+   | ^^^^^^^^\n+\n+error: unused import: `crate::b`\n+  --> $DIR/unused-imports-in-test-module.rs:12:13\n+   |\n+LL |         use crate::b;\n+   |             ^^^^^^^^\n+   |\n+help: consider adding a `#[cfg(test)]` to the containing module\n+  --> $DIR/unused-imports-in-test-module.rs:8:1\n+   |\n+LL | mod test {\n+   | ^^^^^^^^\n+\n+error: unused import: `super::a`\n+  --> $DIR/unused-imports-in-test-module.rs:17:9\n+   |\n+LL |     use super::a;\n+   |         ^^^^^^^^\n+   |\n+help: consider adding a `#[cfg(test)]` to the containing module\n+  --> $DIR/unused-imports-in-test-module.rs:16:1\n+   |\n+LL | mod tests {\n+   | ^^^^^^^^^\n+\n+error: unused import: `crate::b`\n+  --> $DIR/unused-imports-in-test-module.rs:20:13\n+   |\n+LL |         use crate::b;\n+   |             ^^^^^^^^\n+   |\n+help: consider adding a `#[cfg(test)]` to the containing module\n+  --> $DIR/unused-imports-in-test-module.rs:16:1\n+   |\n+LL | mod tests {\n+   | ^^^^^^^^^\n+\n+error: unused import: `super::a`\n+  --> $DIR/unused-imports-in-test-module.rs:25:9\n+   |\n+LL |     use super::a;\n+   |         ^^^^^^^^\n+   |\n+help: consider adding a `#[cfg(test)]` to the containing module\n+  --> $DIR/unused-imports-in-test-module.rs:24:1\n+   |\n+LL | mod test_a {\n+   | ^^^^^^^^^^\n+\n+error: unused import: `crate::b`\n+  --> $DIR/unused-imports-in-test-module.rs:28:13\n+   |\n+LL |         use crate::b;\n+   |             ^^^^^^^^\n+   |\n+help: consider adding a `#[cfg(test)]` to the containing module\n+  --> $DIR/unused-imports-in-test-module.rs:24:1\n+   |\n+LL | mod test_a {\n+   | ^^^^^^^^^^\n+\n+error: unused import: `super::a`\n+  --> $DIR/unused-imports-in-test-module.rs:33:9\n+   |\n+LL |     use super::a;\n+   |         ^^^^^^^^\n+   |\n+help: consider adding a `#[cfg(test)]` to the containing module\n+  --> $DIR/unused-imports-in-test-module.rs:32:1\n+   |\n+LL | mod a_test {\n+   | ^^^^^^^^^^\n+\n+error: unused import: `crate::b`\n+  --> $DIR/unused-imports-in-test-module.rs:36:13\n+   |\n+LL |         use crate::b;\n+   |             ^^^^^^^^\n+   |\n+help: consider adding a `#[cfg(test)]` to the containing module\n+  --> $DIR/unused-imports-in-test-module.rs:32:1\n+   |\n+LL | mod a_test {\n+   | ^^^^^^^^^^\n+\n+error: unused import: `super::a`\n+  --> $DIR/unused-imports-in-test-module.rs:41:9\n+   |\n+LL |     use super::a;\n+   |         ^^^^^^^^\n+   |\n+help: consider adding a `#[cfg(test)]` to the containing module\n+  --> $DIR/unused-imports-in-test-module.rs:40:1\n+   |\n+LL | mod tests_a {\n+   | ^^^^^^^^^^^\n+\n+error: unused import: `crate::b`\n+  --> $DIR/unused-imports-in-test-module.rs:44:13\n+   |\n+LL |         use crate::b;\n+   |             ^^^^^^^^\n+   |\n+help: consider adding a `#[cfg(test)]` to the containing module\n+  --> $DIR/unused-imports-in-test-module.rs:40:1\n+   |\n+LL | mod tests_a {\n+   | ^^^^^^^^^^^\n+\n+error: unused import: `super::a`\n+  --> $DIR/unused-imports-in-test-module.rs:49:9\n+   |\n+LL |     use super::a;\n+   |         ^^^^^^^^\n+   |\n+help: consider adding a `#[cfg(test)]` to the containing module\n+  --> $DIR/unused-imports-in-test-module.rs:48:1\n+   |\n+LL | mod a_tests {\n+   | ^^^^^^^^^^^\n+\n+error: unused import: `crate::b`\n+  --> $DIR/unused-imports-in-test-module.rs:52:13\n+   |\n+LL |         use crate::b;\n+   |             ^^^^^^^^\n+   |\n+help: consider adding a `#[cfg(test)]` to the containing module\n+  --> $DIR/unused-imports-in-test-module.rs:48:1\n+   |\n+LL | mod a_tests {\n+   | ^^^^^^^^^^^\n+\n+error: unused import: `super::a`\n+  --> $DIR/unused-imports-in-test-module.rs:57:9\n+   |\n+LL |     use super::a;\n+   |         ^^^^^^^^\n+\n+error: unused import: `crate::b`\n+  --> $DIR/unused-imports-in-test-module.rs:60:13\n+   |\n+LL |         use crate::b;\n+   |             ^^^^^^^^\n+\n+error: aborting due to 15 previous errors\n+"}]}