{"sha": "8824994ccd7efcc00ad03dee0c69d66c4161eea7", "node_id": "C_kwDOAAsO6NoAKDg4MjQ5OTRjY2Q3ZWZjYzAwYWQwM2RlZTBjNjlkNjZjNDE2MWVlYTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-07T03:50:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-07T03:50:22Z"}, "message": "Auto merge of #108691 - aliemjay:closure-subject, r=jackh726\n\nfix multiple issues when promoting type-test subject\n\nMultiple interdependent fixes.  See linked issues for a short description of each.\n\nWhen Promoting a type-test `T: 'a` from within the closure back to its parent function, there are a couple pre-existing bugs and limitations. They were exposed by the recent changes to opaque types because the type-test subject (`T`) is no longer a simple ParamTy.\n\nCommit 1:\nFixes #108635\nFixes #107426\n\nCommit 2:\nFixes #108639\n\nCommit 3:\nFixes #107516", "tree": {"sha": "edf8d0544222a8b98d860d83903d325a3772d182", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edf8d0544222a8b98d860d83903d325a3772d182"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8824994ccd7efcc00ad03dee0c69d66c4161eea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8824994ccd7efcc00ad03dee0c69d66c4161eea7", "html_url": "https://github.com/rust-lang/rust/commit/8824994ccd7efcc00ad03dee0c69d66c4161eea7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8824994ccd7efcc00ad03dee0c69d66c4161eea7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81be7b86d348a5b7cad08386003c43d44d1e9f94", "url": "https://api.github.com/repos/rust-lang/rust/commits/81be7b86d348a5b7cad08386003c43d44d1e9f94", "html_url": "https://github.com/rust-lang/rust/commit/81be7b86d348a5b7cad08386003c43d44d1e9f94"}, {"sha": "427dc18c25009adb75919df918f23556205ec859", "url": "https://api.github.com/repos/rust-lang/rust/commits/427dc18c25009adb75919df918f23556205ec859", "html_url": "https://github.com/rust-lang/rust/commit/427dc18c25009adb75919df918f23556205ec859"}], "stats": {"total": 368, "additions": 214, "deletions": 154}, "files": [{"sha": "96228338a4c22191d378e45b2897f99e402d92b5", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8824994ccd7efcc00ad03dee0c69d66c4161eea7/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824994ccd7efcc00ad03dee0c69d66c4161eea7/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=8824994ccd7efcc00ad03dee0c69d66c4161eea7", "patch": "@@ -10,10 +10,9 @@ use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, OpaqueHiddenType, Region, RegionVid};\n+use rustc_middle::ty::{self, OpaqueHiddenType, Region, RegionVid, TyCtxt};\n use rustc_span::symbol::sym;\n use std::env;\n-use std::fmt::Debug;\n use std::io;\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -325,7 +324,7 @@ pub(super) fn dump_mir_results<'tcx>(\n     infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n-    closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n+    closure_region_requirements: &Option<ClosureRegionRequirements<'tcx>>,\n ) {\n     if !dump_enabled(infcx.tcx, \"nll\", body.source.def_id()) {\n         return;\n@@ -340,9 +339,11 @@ pub(super) fn dump_mir_results<'tcx>(\n \n                 if let Some(closure_region_requirements) = closure_region_requirements {\n                     writeln!(out, \"| Free Region Constraints\")?;\n-                    for_each_region_constraint(closure_region_requirements, &mut |msg| {\n-                        writeln!(out, \"| {}\", msg)\n-                    })?;\n+                    for_each_region_constraint(\n+                        infcx.tcx,\n+                        closure_region_requirements,\n+                        &mut |msg| writeln!(out, \"| {}\", msg),\n+                    )?;\n                     writeln!(out, \"|\")?;\n                 }\n             }\n@@ -375,7 +376,7 @@ pub(super) fn dump_annotation<'tcx>(\n     infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n-    closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n+    closure_region_requirements: &Option<ClosureRegionRequirements<'tcx>>,\n     opaque_type_values: &VecMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n     errors: &mut crate::error::BorrowckErrors<'tcx>,\n ) {\n@@ -405,7 +406,7 @@ pub(super) fn dump_annotation<'tcx>(\n \n         // Dump the region constraints we are imposing *between* those\n         // newly created variables.\n-        for_each_region_constraint(closure_region_requirements, &mut |msg| {\n+        for_each_region_constraint(tcx, closure_region_requirements, &mut |msg| {\n             err.note(msg);\n             Ok(())\n         })\n@@ -426,16 +427,19 @@ pub(super) fn dump_annotation<'tcx>(\n     errors.buffer_non_error_diag(err);\n }\n \n-fn for_each_region_constraint(\n-    closure_region_requirements: &ClosureRegionRequirements<'_>,\n+fn for_each_region_constraint<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    closure_region_requirements: &ClosureRegionRequirements<'tcx>,\n     with_msg: &mut dyn FnMut(&str) -> io::Result<()>,\n ) -> io::Result<()> {\n     for req in &closure_region_requirements.outlives_requirements {\n-        let subject: &dyn Debug = match &req.subject {\n-            ClosureOutlivesSubject::Region(subject) => subject,\n-            ClosureOutlivesSubject::Ty(ty) => ty,\n+        let subject = match req.subject {\n+            ClosureOutlivesSubject::Region(subject) => format!(\"{:?}\", subject),\n+            ClosureOutlivesSubject::Ty(ty) => {\n+                format!(\"{:?}\", ty.instantiate(tcx, |vid| tcx.mk_re_var(vid)))\n+            }\n         };\n-        with_msg(&format!(\"where {:?}: {:?}\", subject, req.outlived_free_region,))?;\n+        with_msg(&format!(\"where {}: {:?}\", subject, req.outlived_free_region,))?;\n     }\n     Ok(())\n }"}, {"sha": "e6195de404c3c1115d80108e50f9bbca00cda4a6", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 51, "deletions": 86, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/8824994ccd7efcc00ad03dee0c69d66c4161eea7/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824994ccd7efcc00ad03dee0c69d66c4161eea7/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=8824994ccd7efcc00ad03dee0c69d66c4161eea7", "patch": "@@ -12,8 +12,9 @@ use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n-    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location, ReturnConstraint, TerminatorKind,\n+    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureOutlivesSubjectTy,\n+    ClosureRegionRequirements, ConstraintCategory, Local, Location, ReturnConstraint,\n+    TerminatorKind,\n };\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::traits::ObligationCauseCode;\n@@ -1084,18 +1085,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         true\n     }\n \n-    /// When we promote a type test `T: 'r`, we have to convert the\n-    /// type `T` into something we can store in a query result (so\n-    /// something allocated for `'tcx`). This is problematic if `ty`\n-    /// contains regions. During the course of NLL region checking, we\n-    /// will have replaced all of those regions with fresh inference\n-    /// variables. To create a test subject, we want to replace those\n-    /// inference variables with some region from the closure\n-    /// signature -- this is not always possible, so this is a\n-    /// fallible process. Presuming we do find a suitable region, we\n-    /// will use it's *external name*, which will be a `RegionKind`\n-    /// variant that can be used in query responses such as\n-    /// `ReEarlyBound`.\n+    /// When we promote a type test `T: 'r`, we have to replace all region\n+    /// variables in the type `T` with an equal universal region from the\n+    /// closure signature.\n+    /// This is not always possible, so this is a fallible process.\n     #[instrument(level = \"debug\", skip(self, infcx))]\n     fn try_promote_type_test_subject(\n         &self,\n@@ -1104,91 +1097,63 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<ClosureOutlivesSubject<'tcx>> {\n         let tcx = infcx.tcx;\n \n+        // Opaque types' substs may include useless lifetimes.\n+        // We will replace them with ReStatic.\n+        struct OpaqueFolder<'tcx> {\n+            tcx: TyCtxt<'tcx>,\n+        }\n+        impl<'tcx> ty::TypeFolder<TyCtxt<'tcx>> for OpaqueFolder<'tcx> {\n+            fn interner(&self) -> TyCtxt<'tcx> {\n+                self.tcx\n+            }\n+            fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+                use ty::TypeSuperFoldable as _;\n+                let tcx = self.tcx;\n+                let &ty::Alias(ty::Opaque, ty::AliasTy { substs, def_id, .. }) = t.kind() else {\n+                    return t.super_fold_with(self);\n+                };\n+                let substs =\n+                    std::iter::zip(substs, tcx.variances_of(def_id)).map(|(arg, v)| {\n+                        match (arg.unpack(), v) {\n+                            (ty::GenericArgKind::Lifetime(_), ty::Bivariant) => {\n+                                tcx.lifetimes.re_static.into()\n+                            }\n+                            _ => arg.fold_with(self),\n+                        }\n+                    });\n+                tcx.mk_opaque(def_id, tcx.mk_substs_from_iter(substs))\n+            }\n+        }\n+\n+        let ty = ty.fold_with(&mut OpaqueFolder { tcx });\n+\n         let ty = tcx.fold_regions(ty, |r, _depth| {\n-            let region_vid = self.to_region_vid(r);\n+            let r_vid = self.to_region_vid(r);\n+            let r_scc = self.constraint_sccs.scc(r_vid);\n \n             // The challenge if this. We have some region variable `r`\n             // whose value is a set of CFG points and universal\n             // regions. We want to find if that set is *equivalent* to\n             // any of the named regions found in the closure.\n-            //\n-            // To do so, we compute the\n-            // `non_local_universal_upper_bound`. This will be a\n-            // non-local, universal region that is greater than `r`.\n-            // However, it might not be *contained* within `r`, so\n-            // then we further check whether this bound is contained\n-            // in `r`. If so, we can say that `r` is equivalent to the\n-            // bound.\n-            //\n-            // Let's work through a few examples. For these, imagine\n-            // that we have 3 non-local regions (I'll denote them as\n-            // `'static`, `'a`, and `'b`, though of course in the code\n-            // they would be represented with indices) where:\n-            //\n-            // - `'static: 'a`\n-            // - `'static: 'b`\n-            //\n-            // First, let's assume that `r` is some existential\n-            // variable with an inferred value `{'a, 'static}` (plus\n-            // some CFG nodes). In this case, the non-local upper\n-            // bound is `'static`, since that outlives `'a`. `'static`\n-            // is also a member of `r` and hence we consider `r`\n-            // equivalent to `'static` (and replace it with\n-            // `'static`).\n-            //\n-            // Now let's consider the inferred value `{'a, 'b}`. This\n-            // means `r` is effectively `'a | 'b`. I'm not sure if\n-            // this can come about, actually, but assuming it did, we\n-            // would get a non-local upper bound of `'static`. Since\n-            // `'static` is not contained in `r`, we would fail to\n-            // find an equivalent.\n-            let upper_bound = self.non_local_universal_upper_bound(region_vid);\n-            if self.region_contains(region_vid, upper_bound) {\n-                self.definitions[upper_bound].external_name.unwrap_or(r)\n-            } else {\n-                // In the case of a failure, use a `ReVar` result. This will\n-                // cause the `needs_infer` later on to return `None`.\n-                r\n-            }\n+            // To do so, we simply check every candidate `u_r` for equality.\n+            self.scc_values\n+                .universal_regions_outlived_by(r_scc)\n+                .filter(|&u_r| !self.universal_regions.is_local_free_region(u_r))\n+                .find(|&u_r| self.eval_equal(u_r, r_vid))\n+                .map(|u_r| tcx.mk_re_var(u_r))\n+                // In the case of a failure, use `ReErased`. We will eventually\n+                // return `None` in this case.\n+                .unwrap_or(tcx.lifetimes.re_erased)\n         });\n \n         debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n \n-        // `needs_infer` will only be true if we failed to promote some region.\n-        if ty.needs_infer() {\n+        // This will be true if we failed to promote some region.\n+        if ty.has_erased_regions() {\n             return None;\n         }\n \n-        Some(ClosureOutlivesSubject::Ty(ty))\n-    }\n-\n-    /// Given some universal or existential region `r`, finds a\n-    /// non-local, universal region `r+` that outlives `r` at entry to (and\n-    /// exit from) the closure. In the worst case, this will be\n-    /// `'static`.\n-    ///\n-    /// This is used for two purposes. First, if we are propagated\n-    /// some requirement `T: r`, we can use this method to enlarge `r`\n-    /// to something we can encode for our creator (which only knows\n-    /// about non-local, universal regions). It is also used when\n-    /// encoding `T` as part of `try_promote_type_test_subject` (see\n-    /// that fn for details).\n-    ///\n-    /// This is based on the result `'y` of `universal_upper_bound`,\n-    /// except that it converts further takes the non-local upper\n-    /// bound of `'y`, so that the final result is non-local.\n-    fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\"non_local_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n-\n-        let lub = self.universal_upper_bound(r);\n-\n-        // Grow further to get smallest universal region known to\n-        // creator.\n-        let non_local_lub = self.universal_region_relations.non_local_upper_bound(lub);\n-\n-        debug!(\"non_local_universal_upper_bound: non_local_lub={:?}\", non_local_lub);\n-\n-        non_local_lub\n+        Some(ClosureOutlivesSubject::Ty(ClosureOutlivesSubjectTy::bind(tcx, ty)))\n     }\n \n     /// Returns a universally quantified region that outlives the"}, {"sha": "a93561350062c630b4ed52587175fbada2ad26bf", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8824994ccd7efcc00ad03dee0c69d66c4161eea7/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824994ccd7efcc00ad03dee0c69d66c4161eea7/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=8824994ccd7efcc00ad03dee0c69d66c4161eea7", "patch": "@@ -116,7 +116,9 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n             let subject = match outlives_requirement.subject {\n                 ClosureOutlivesSubject::Region(re) => closure_mapping[re].into(),\n-                ClosureOutlivesSubject::Ty(ty) => ty.into(),\n+                ClosureOutlivesSubject::Ty(subject_ty) => {\n+                    subject_ty.instantiate(self.tcx, |vid| closure_mapping[vid]).into()\n+                }\n             };\n \n             self.category = outlives_requirement.category;"}, {"sha": "4004966c40a77bc9d561432427b0b25ab7fe5eed", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8824994ccd7efcc00ad03dee0c69d66c4161eea7/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824994ccd7efcc00ad03dee0c69d66c4161eea7/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=8824994ccd7efcc00ad03dee0c69d66c4161eea7", "patch": "@@ -93,31 +93,6 @@ impl UniversalRegionRelations<'_> {\n         res\n     }\n \n-    /// Returns the \"postdominating\" bound of the set of\n-    /// `non_local_upper_bounds` for the given region.\n-    pub(crate) fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n-        let upper_bounds = self.non_local_upper_bounds(fr);\n-\n-        // In case we find more than one, reduce to one for\n-        // convenience. This is to prevent us from generating more\n-        // complex constraints, but it will cause spurious errors.\n-        let post_dom = self.inverse_outlives.mutual_immediate_postdominator(upper_bounds);\n-\n-        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n-\n-        post_dom\n-            .and_then(|post_dom| {\n-                // If the mutual immediate postdom is not local, then\n-                // there is no non-local result we can return.\n-                if !self.universal_regions.is_local_free_region(post_dom) {\n-                    Some(post_dom)\n-                } else {\n-                    None\n-                }\n-            })\n-            .unwrap_or(self.universal_regions.fr_static)\n-    }\n-\n     /// Finds a \"lower bound\" for `fr` that is not local. In other\n     /// words, returns the largest (*) known region `fr1` that (a) is\n     /// outlived by `fr` and (b) is not local."}, {"sha": "b964c1852d251c753233a8c38363e491cae4d450", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8824994ccd7efcc00ad03dee0c69d66c4161eea7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824994ccd7efcc00ad03dee0c69d66c4161eea7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=8824994ccd7efcc00ad03dee0c69d66c4161eea7", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::bit_set::BitMatrix;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use smallvec::SmallVec;\n@@ -289,13 +289,6 @@ pub struct ConstQualifs {\n /// instance of the closure is created, the corresponding free regions\n /// can be extracted from its type and constrained to have the given\n /// outlives relationship.\n-///\n-/// In some cases, we have to record outlives requirements between types and\n-/// regions as well. In that case, if those types include any regions, those\n-/// regions are recorded using their external names (`ReStatic`,\n-/// `ReEarlyBound`, `ReFree`). We use these because in a query response we\n-/// cannot use `ReVar` (which is what we use internally within the rest of the\n-/// NLL code).\n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct ClosureRegionRequirements<'tcx> {\n     /// The number of external regions defined on the closure. In our\n@@ -392,16 +385,59 @@ pub enum ClosureOutlivesSubject<'tcx> {\n     /// Subject is a type, typically a type parameter, but could also\n     /// be a projection. Indicates a requirement like `T: 'a` being\n     /// passed to the caller, where the type here is `T`.\n-    ///\n-    /// The type here is guaranteed not to contain any free regions at\n-    /// present.\n-    Ty(Ty<'tcx>),\n+    Ty(ClosureOutlivesSubjectTy<'tcx>),\n \n     /// Subject is a free region from the closure. Indicates a requirement\n     /// like `'a: 'b` being passed to the caller; the region here is `'a`.\n     Region(ty::RegionVid),\n }\n \n+/// Represents a `ty::Ty` for use in [`ClosureOutlivesSubject`].\n+///\n+/// This abstraction is necessary because the type may include `ReVar` regions,\n+/// which is what we use internally within NLL code, and they can't be used in\n+/// a query response.\n+///\n+/// DO NOT implement `TypeVisitable` or `TypeFoldable` traits, because this\n+/// type is not recognized as a binder for late-bound region.\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub struct ClosureOutlivesSubjectTy<'tcx> {\n+    inner: Ty<'tcx>,\n+}\n+\n+impl<'tcx> ClosureOutlivesSubjectTy<'tcx> {\n+    /// All regions of `ty` must be of kind `ReVar` and must represent\n+    /// universal regions *external* to the closure.\n+    pub fn bind(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Self {\n+        let inner = tcx.fold_regions(ty, |r, depth| match r.kind() {\n+            ty::ReVar(vid) => {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::new(vid.index()),\n+                    kind: ty::BrAnon(vid.as_u32(), None),\n+                };\n+                tcx.mk_re_late_bound(depth, br)\n+            }\n+            _ => bug!(\"unexpected region in ClosureOutlivesSubjectTy: {r:?}\"),\n+        });\n+\n+        Self { inner }\n+    }\n+\n+    pub fn instantiate(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        mut map: impl FnMut(ty::RegionVid) -> ty::Region<'tcx>,\n+    ) -> Ty<'tcx> {\n+        tcx.fold_regions(self.inner, |r, depth| match r.kind() {\n+            ty::ReLateBound(debruijn, br) => {\n+                debug_assert_eq!(debruijn, depth);\n+                map(ty::RegionVid::new(br.var.index()))\n+            }\n+            _ => bug!(\"unexpected region {r:?}\"),\n+        })\n+    }\n+}\n+\n /// The constituent parts of a mir constant of kind ADT or array.\n #[derive(Copy, Clone, Debug, HashStable)]\n pub struct DestructuredConstant<'tcx> {"}, {"sha": "d8772e86894dffac4b06347d40b88f828c0c021b", "filename": "tests/ui/nll/closure-requirements/type-test-subject-non-trivial-region.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-non-trivial-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-non-trivial-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-non-trivial-region.rs?ref=8824994ccd7efcc00ad03dee0c69d66c4161eea7", "patch": "@@ -0,0 +1,19 @@\n+// See #108639 for description.\n+// check-pass\n+\n+trait Trait {\n+    type Item<'a>: 'a;\n+}\n+\n+fn assert_static<T: 'static>(_: T) {}\n+fn relate<T>(_: T, _: T) {}\n+\n+fn test_args<I: Trait>() {\n+    let closure = |a, b| {\n+        relate(&a, b);\n+        assert_static(a);\n+    };\n+    closure(None::<I::Item<'_>>, &None::<I::Item<'_>>);\n+}\n+\n+fn main() {}"}, {"sha": "fce6f2fee7fdaa3e7b3e3d3e2444ad7211319ae8", "filename": "tests/ui/nll/closure-requirements/type-test-subject-opaque-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-opaque-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-opaque-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-opaque-1.rs?ref=8824994ccd7efcc00ad03dee0c69d66c4161eea7", "patch": "@@ -0,0 +1,18 @@\n+// Regression test for #107426.\n+// check-pass\n+\n+use std::marker::PhantomData;\n+#[derive(Clone, Copy)]\n+pub struct Scope<'a>(&'a PhantomData<&'a mut &'a ()>);\n+fn event<'a, F: FnMut() + 'a>(_: Scope<'a>, _: F) {}\n+fn make_fn<'a>(_: Scope<'a>) -> impl Fn() + Copy + 'a {\n+    || {}\n+}\n+\n+fn foo(cx: Scope) {\n+    let open_toggle = make_fn(cx);\n+\n+    || event(cx, open_toggle);\n+}\n+\n+fn main() {}"}, {"sha": "55905850f0c97ec3799d05cac322b7bad9c63c5a", "filename": "tests/ui/nll/closure-requirements/type-test-subject-opaque-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-opaque-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-opaque-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-opaque-2.rs?ref=8824994ccd7efcc00ad03dee0c69d66c4161eea7", "patch": "@@ -0,0 +1,17 @@\n+// Resgression test for #107516.\n+// check-pass\n+\n+fn iter1<'a: 'a>() -> impl Iterator<Item = &'static str> {\n+    None.into_iter()\n+}\n+\n+fn iter2<'a>() -> impl Iterator<Item = &'a str> {\n+    None.into_iter()\n+}\n+\n+struct Bivar<'a, I: Iterator<Item = &'a str> + 'a>(I);\n+\n+fn main() {\n+    let _ = || Bivar(iter1());\n+    let _ = || Bivar(iter2());\n+}"}, {"sha": "b5a95c170099d24d69bccbe246de25b4e0cfc4dd", "filename": "tests/ui/nll/closure-requirements/type-test-subject-unnamed-region.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-unnamed-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-unnamed-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-unnamed-region.rs?ref=8824994ccd7efcc00ad03dee0c69d66c4161eea7", "patch": "@@ -0,0 +1,24 @@\n+// See #108635 for description.\n+// check-pass\n+\n+trait Trait {\n+    type Item<'a>: 'a;\n+}\n+\n+fn assert_static<T: 'static>(_: T) {}\n+\n+fn test_args<I: Trait>() {\n+    let closure = |a, _b| assert_static(a);\n+\n+    closure(None::<I::Item<'_>>, &None::<I::Item<'_>>);\n+}\n+\n+fn test_upvars<I: Trait>() {\n+    let upvars = (None::<I::Item<'_>>, &None::<I::Item<'_>>);\n+    let _closure = || {\n+        let (a, _b) = upvars;\n+        assert_static(a);\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "11ada59c066393544e6ecffd2e370535a81e2aa9", "filename": "tests/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=8824994ccd7efcc00ad03dee0c69d66c4161eea7", "patch": "@@ -110,7 +110,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 4\n-   = note: where <T as Anything<ReEarlyBound(1, 'b)>>::AssocType: '_#3r\n+   = note: where <T as Anything<'_#2r>>::AssocType: '_#3r\n \n note: no external requirements\n   --> $DIR/projection-one-region-closure.rs:62:1"}, {"sha": "47d4f2e46c62b623bc175eae3f865ed36ed55a20", "filename": "tests/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=8824994ccd7efcc00ad03dee0c69d66c4161eea7", "patch": "@@ -86,7 +86,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 4\n-   = note: where <T as Anything<ReEarlyBound(1, 'b)>>::AssocType: '_#3r\n+   = note: where <T as Anything<'_#2r>>::AssocType: '_#3r\n \n note: no external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:52:1"}, {"sha": "530dd86819dc37fca35b9b9373a9a59bf0178fd4", "filename": "tests/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8824994ccd7efcc00ad03dee0c69d66c4161eea7/tests%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=8824994ccd7efcc00ad03dee0c69d66c4161eea7", "patch": "@@ -11,7 +11,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n            ]\n    = note: late-bound region is '_#4r\n    = note: number of external vids: 5\n-   = note: where <T as Anything<ReEarlyBound(0, 'b), ReEarlyBound(1, 'c)>>::AssocType: '_#3r\n+   = note: where <T as Anything<'_#1r, '_#2r>>::AssocType: '_#3r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:34:1\n@@ -23,14 +23,14 @@ LL | |     T: Anything<'b, 'c>,\n    |\n    = note: defining type: no_relationships_late::<'_#1r, '_#2r, T>\n \n-error[E0309]: the associated type `<T as Anything<ReEarlyBound(0, 'b), ReEarlyBound(1, 'c)>>::AssocType` may not live long enough\n+error[E0309]: the associated type `<T as Anything<'_#5r, '_#6r>>::AssocType` may not live long enough\n   --> $DIR/projection-two-region-trait-bound-closure.rs:38:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                                       ^^^^^^^^^^^^^^^^\n    |\n-   = help: consider adding an explicit lifetime bound `<T as Anything<ReEarlyBound(0, 'b), ReEarlyBound(1, 'c)>>::AssocType: 'a`...\n-   = note: ...so that the type `<T as Anything<ReEarlyBound(0, 'b), ReEarlyBound(1, 'c)>>::AssocType` will meet its required lifetime bounds\n+   = help: consider adding an explicit lifetime bound `<T as Anything<'_#5r, '_#6r>>::AssocType: 'a`...\n+   = note: ...so that the type `<T as Anything<'_#5r, '_#6r>>::AssocType` will meet its required lifetime bounds\n \n note: external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:48:29\n@@ -44,7 +44,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 5\n-   = note: where <T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType: '_#4r\n+   = note: where <T as Anything<'_#2r, '_#3r>>::AssocType: '_#4r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:43:1\n@@ -57,14 +57,14 @@ LL | |     'a: 'a,\n    |\n    = note: defining type: no_relationships_early::<'_#1r, '_#2r, '_#3r, T>\n \n-error[E0309]: the associated type `<T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType` may not live long enough\n+error[E0309]: the associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n   --> $DIR/projection-two-region-trait-bound-closure.rs:48:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                                       ^^^^^^^^^^^^^^^^\n    |\n-   = help: consider adding an explicit lifetime bound `<T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType: 'a`...\n-   = note: ...so that the type `<T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType` will meet its required lifetime bounds\n+   = help: consider adding an explicit lifetime bound `<T as Anything<'_#6r, '_#7r>>::AssocType: 'a`...\n+   = note: ...so that the type `<T as Anything<'_#6r, '_#7r>>::AssocType` will meet its required lifetime bounds\n \n note: external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:61:29\n@@ -78,7 +78,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 5\n-   = note: where <T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType: '_#4r\n+   = note: where <T as Anything<'_#2r, '_#3r>>::AssocType: '_#4r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:53:1\n@@ -103,7 +103,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 5\n-   = note: where <T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType: '_#4r\n+   = note: where <T as Anything<'_#2r, '_#3r>>::AssocType: '_#4r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:65:1\n@@ -128,7 +128,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 5\n-   = note: where <T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType: '_#4r\n+   = note: where <T as Anything<'_#2r, '_#3r>>::AssocType: '_#4r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:74:1\n@@ -154,7 +154,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n            ]\n    = note: late-bound region is '_#3r\n    = note: number of external vids: 4\n-   = note: where <T as Anything<ReEarlyBound(0, 'b), ReEarlyBound(0, 'b)>>::AssocType: '_#2r\n+   = note: where <T as Anything<'_#1r, '_#1r>>::AssocType: '_#2r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:83:1\n@@ -194,7 +194,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 4\n-   = note: where <T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(1, 'b)>>::AssocType: '_#3r\n+   = note: where <T as Anything<'_#2r, '_#2r>>::AssocType: '_#3r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:92:1\n@@ -219,7 +219,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 3\n-   = note: where <T as Anything<ReEarlyBound(0, 'a), ReEarlyBound(0, 'a)>>::AssocType: '_#2r\n+   = note: where <T as Anything<'_#1r, '_#1r>>::AssocType: '_#2r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:101:1"}]}