{"sha": "ff2a7c85757542f454934e00605355bbca7bc196", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMmE3Yzg1NzU3NTQyZjQ1NDkzNGUwMDYwNTM1NWJiY2E3YmMxOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-21T22:38:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-21T22:38:29Z"}, "message": "Auto merge of #47644 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 9 pull requests\n\n- Successful merges: #47247, #47334, #47512, #47582, #47595, #47625, #47632, #47633, #47637\n- Failed merges:", "tree": {"sha": "9baf95d78fe95a7d6b6424cab8e61c8877fb258a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9baf95d78fe95a7d6b6424cab8e61c8877fb258a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff2a7c85757542f454934e00605355bbca7bc196", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff2a7c85757542f454934e00605355bbca7bc196", "html_url": "https://github.com/rust-lang/rust/commit/ff2a7c85757542f454934e00605355bbca7bc196", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff2a7c85757542f454934e00605355bbca7bc196/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97520ccb101609af63f29919bb0a39115269c89e", "url": "https://api.github.com/repos/rust-lang/rust/commits/97520ccb101609af63f29919bb0a39115269c89e", "html_url": "https://github.com/rust-lang/rust/commit/97520ccb101609af63f29919bb0a39115269c89e"}, {"sha": "dcbf0bf5f5f59f936f32d18b729c66f236a974da", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcbf0bf5f5f59f936f32d18b729c66f236a974da", "html_url": "https://github.com/rust-lang/rust/commit/dcbf0bf5f5f59f936f32d18b729c66f236a974da"}], "stats": {"total": 2123, "additions": 1935, "deletions": 188}, "files": [{"sha": "9034aae171417c449ebdfc8c88f500bd28f459e8", "filename": ".mailmap", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -41,11 +41,12 @@ Boris Egorov <jightuse@gmail.com> <egorov@linux.com>\n Brandon Sanderson <singingboyo@gmail.com> Brandon Sanderson <singingboyo@hotmail.com>\n Brett Cannon <brett@python.org> Brett Cannon <brettcannon@users.noreply.github.com>\n Brian Anderson <banderson@mozilla.com> <andersrb@gmail.com>\n+Brian Anderson <banderson@mozilla.com> <banderson@mozilla.org>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n-Carol (Nichols || Goulding) <carol.nichols@gmail.com>\n-Carol (Nichols || Goulding) <cnichols@thinkthroughmath.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com> <cnichols@thinkthroughmath.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com> Carol Nichols <carol.nichols@gmail.com>\n Carol Willing <carolcode@willingconsulting.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n Chris Pressey <cpressey@gmail.com>"}, {"sha": "e412dd9e3e67010a6f0f2645c17e018494a21296", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -26,11 +26,6 @@ use config::Config;\n // The version number\n pub const CFG_RELEASE_NUM: &str = \"1.25.0\";\n \n-// An optional number to put after the label, e.g. '.2' -> '-beta.2'\n-// Be sure to make this starts with a dot to conform to semver pre-release\n-// versions (section 9)\n-pub const CFG_PRERELEASE_VERSION: &str = \".1\";\n-\n pub struct GitInfo {\n     inner: Option<Info>,\n }"}, {"sha": "224b31ef26872469d600fc87ff4b99cb006fb0bf", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -1652,7 +1652,6 @@ fn add_env(build: &Build, cmd: &mut Command, target: Interned<String>) {\n     cmd.env(\"CFG_RELEASE_INFO\", build.rust_version())\n        .env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM)\n        .env(\"CFG_RELEASE\", build.rust_release())\n-       .env(\"CFG_PRERELEASE_VERSION\", channel::CFG_PRERELEASE_VERSION)\n        .env(\"CFG_VER_MAJOR\", parts.next().unwrap())\n        .env(\"CFG_VER_MINOR\", parts.next().unwrap())\n        .env(\"CFG_VER_PATCH\", parts.next().unwrap())"}, {"sha": "3738828a4baed00011f87aea1fe41ec37c06f980", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -134,7 +134,7 @@ extern crate toml;\n #[cfg(unix)]\n extern crate libc;\n \n-use std::cell::RefCell;\n+use std::cell::{RefCell, Cell};\n use std::collections::{HashSet, HashMap};\n use std::env;\n use std::fs::{self, File};\n@@ -250,6 +250,7 @@ pub struct Build {\n     is_sudo: bool,\n     ci_env: CiEnv,\n     delayed_failures: RefCell<Vec<String>>,\n+    prerelease_version: Cell<Option<u32>>,\n }\n \n #[derive(Debug)]\n@@ -335,6 +336,7 @@ impl Build {\n             is_sudo,\n             ci_env: CiEnv::current(),\n             delayed_failures: RefCell::new(Vec::new()),\n+            prerelease_version: Cell::new(None),\n         }\n     }\n \n@@ -774,12 +776,59 @@ impl Build {\n     fn release(&self, num: &str) -> String {\n         match &self.config.channel[..] {\n             \"stable\" => num.to_string(),\n-            \"beta\" => format!(\"{}-beta{}\", num, channel::CFG_PRERELEASE_VERSION),\n+            \"beta\" => format!(\"{}-beta.{}\", num, self.beta_prerelease_version()),\n             \"nightly\" => format!(\"{}-nightly\", num),\n             _ => format!(\"{}-dev\", num),\n         }\n     }\n \n+    fn beta_prerelease_version(&self) -> u32 {\n+        if let Some(s) = self.prerelease_version.get() {\n+            return s\n+        }\n+\n+        let beta = output(\n+            Command::new(\"git\")\n+                .arg(\"ls-remote\")\n+                .arg(\"origin\")\n+                .arg(\"beta\")\n+                .current_dir(&self.src)\n+        );\n+        let beta = beta.trim().split_whitespace().next().unwrap();\n+        let master = output(\n+            Command::new(\"git\")\n+                .arg(\"ls-remote\")\n+                .arg(\"origin\")\n+                .arg(\"master\")\n+                .current_dir(&self.src)\n+        );\n+        let master = master.trim().split_whitespace().next().unwrap();\n+\n+        // Figure out where the current beta branch started.\n+        let base = output(\n+            Command::new(\"git\")\n+                .arg(\"merge-base\")\n+                .arg(beta)\n+                .arg(master)\n+                .current_dir(&self.src),\n+        );\n+        let base = base.trim();\n+\n+        // Next figure out how many merge commits happened since we branched off\n+        // beta. That's our beta number!\n+        let count = output(\n+            Command::new(\"git\")\n+                .arg(\"rev-list\")\n+                .arg(\"--count\")\n+                .arg(\"--merges\")\n+                .arg(format!(\"{}...HEAD\", base))\n+                .current_dir(&self.src),\n+        );\n+        let n = count.trim().parse().unwrap();\n+        self.prerelease_version.set(Some(n));\n+        n\n+    }\n+\n     /// Returns the value of `release` above for Rust itself.\n     fn rust_release(&self) -> String {\n         self.release(channel::CFG_RELEASE_NUM)"}, {"sha": "14a1906ff421dd24996e619005ff2cdfeaca90f2", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -36,6 +36,12 @@ fi\n rm -rf \"$CACHE_DIR\"\n mkdir \"$CACHE_DIR\"\n \n+# On the beta channel we'll be automatically calculating the prerelease version\n+# via the git history, so unshallow our shallow clone from CI.\n+if grep -q RUST_RELEASE_CHANNEL=beta src/ci/run.sh; then\n+  git fetch origin --unshallow beta master\n+fi\n+\n travis_fold start update_cache\n travis_time_start\n "}, {"sha": "327eaaf465130313227ef553b821486559666df0", "filename": "src/liballoc/btree/set.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -658,26 +658,26 @@ impl<T: Ord> BTreeSet<T> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// use std::collections::BTreeMap;\n+    /// use std::collections::BTreeSet;\n     ///\n-    /// let mut a = BTreeMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.insert(2, \"b\");\n-    /// a.insert(3, \"c\");\n-    /// a.insert(17, \"d\");\n-    /// a.insert(41, \"e\");\n+    /// let mut a = BTreeSet::new();\n+    /// a.insert(1);\n+    /// a.insert(2);\n+    /// a.insert(3);\n+    /// a.insert(17);\n+    /// a.insert(41);\n     ///\n     /// let b = a.split_off(&3);\n     ///\n     /// assert_eq!(a.len(), 2);\n     /// assert_eq!(b.len(), 3);\n     ///\n-    /// assert_eq!(a[&1], \"a\");\n-    /// assert_eq!(a[&2], \"b\");\n+    /// assert!(a.contains(&1));\n+    /// assert!(a.contains(&2));\n     ///\n-    /// assert_eq!(b[&3], \"c\");\n-    /// assert_eq!(b[&17], \"d\");\n-    /// assert_eq!(b[&41], \"e\");\n+    /// assert!(b.contains(&3));\n+    /// assert!(b.contains(&17));\n+    /// assert!(b.contains(&41));\n     /// ```\n     #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self where T: Borrow<Q> {"}, {"sha": "028983de556f20c0e0e3cd4f5482057c085e5266", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -630,6 +630,8 @@ impl<T> [T] {\n     /// assert_eq!(iter.next().unwrap(), &['m']);\n     /// assert!(iter.next().is_none());\n     /// ```\n+    ///\n+    /// [`exact_chunks`]: #method.exact_chunks\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n@@ -660,6 +662,8 @@ impl<T> [T] {\n     /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n     /// assert!(iter.next().is_none());\n     /// ```\n+    ///\n+    /// [`chunks`]: #method.chunks\n     #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n     #[inline]\n     pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n@@ -692,6 +696,8 @@ impl<T> [T] {\n     /// }\n     /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n     /// ```\n+    ///\n+    /// [`exact_chunks_mut`]: #method.exact_chunks_mut\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n@@ -728,6 +734,8 @@ impl<T> [T] {\n     /// }\n     /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n     /// ```\n+    ///\n+    /// [`chunks_mut`]: #method.chunks_mut\n     #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n     #[inline]\n     pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {"}, {"sha": "9259138bab0a9f891914a65f3710e03caff56ebf", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -906,7 +906,7 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Clears the buffer, removing all values.\n+    /// Clears the `VecDeque`, removing all values.\n     ///\n     /// # Examples\n     ///\n@@ -1624,18 +1624,18 @@ impl<T> VecDeque<T> {\n         return elem;\n     }\n \n-    /// Splits the collection into two at the given index.\n+    /// Splits the `VecDeque` into two at the given index.\n     ///\n-    /// Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n-    /// and the returned `Self` contains elements `[at, len)`.\n+    /// Returns a newly allocated `VecDeque`. `self` contains elements `[0, at)`,\n+    /// and the returned `VecDeque` contains elements `[at, len)`.\n     ///\n     /// Note that the capacity of `self` does not change.\n     ///\n     /// Element at index 0 is the front of the queue.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `at > len`\n+    /// Panics if `at > len`.\n     ///\n     /// # Examples\n     ///\n@@ -1815,7 +1815,8 @@ impl<T> VecDeque<T> {\n \n impl<T: Clone> VecDeque<T> {\n     /// Modifies the `VecDeque` in-place so that `len()` is equal to new_len,\n-    /// either by removing excess elements or by appending clones of `value` to the back.\n+    /// either by removing excess elements from the back or by appending clones of `value`\n+    /// to the back.\n     ///\n     /// # Examples\n     ///\n@@ -2390,7 +2391,7 @@ impl<T> IntoIterator for VecDeque<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n-    /// Consumes the list into a front-to-back iterator yielding elements by\n+    /// Consumes the `VecDeque` into a front-to-back iterator yielding elements by\n     /// value.\n     fn into_iter(self) -> IntoIter<T> {\n         IntoIter { inner: self }"}, {"sha": "32b55a05124acd53939fa8ec67b0b826b18e8ec7", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -2046,7 +2046,8 @@ impl<'a> LoweringContext<'a> {\n                 };\n \n                 // Correctly resolve `self` imports\n-                if path.segments.last().unwrap().identifier.name == keywords::SelfValue.name() {\n+                if path.segments.len() > 1 &&\n+                   path.segments.last().unwrap().identifier.name == keywords::SelfValue.name() {\n                     let _ = path.segments.pop();\n                     if ident.name == keywords::SelfValue.name() {\n                         *name = path.segments.last().unwrap().identifier.name;"}, {"sha": "3da2855929d3ab56b95b7427785ddff976387b48", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -34,13 +34,14 @@ use util::nodemap::{NodeMap, FxHashSet};\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n-use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n+use syntax::ast::{self, Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n+use syntax::util::parser::ExprPrecedence;\n use ty::AdtKind;\n \n use rustc_data_structures::indexed_vec;\n@@ -958,6 +959,31 @@ impl BinOp_ {\n     }\n }\n \n+impl Into<ast::BinOpKind> for BinOp_ {\n+    fn into(self) -> ast::BinOpKind {\n+        match self {\n+            BiAdd => ast::BinOpKind::Add,\n+            BiSub => ast::BinOpKind::Sub,\n+            BiMul => ast::BinOpKind::Mul,\n+            BiDiv => ast::BinOpKind::Div,\n+            BiRem => ast::BinOpKind::Rem,\n+            BiAnd => ast::BinOpKind::And,\n+            BiOr => ast::BinOpKind::Or,\n+            BiBitXor => ast::BinOpKind::BitXor,\n+            BiBitAnd => ast::BinOpKind::BitAnd,\n+            BiBitOr => ast::BinOpKind::BitOr,\n+            BiShl => ast::BinOpKind::Shl,\n+            BiShr => ast::BinOpKind::Shr,\n+            BiEq => ast::BinOpKind::Eq,\n+            BiLt => ast::BinOpKind::Lt,\n+            BiLe => ast::BinOpKind::Le,\n+            BiNe => ast::BinOpKind::Ne,\n+            BiGe => ast::BinOpKind::Ge,\n+            BiGt => ast::BinOpKind::Gt,\n+        }\n+    }\n+}\n+\n pub type BinOp = Spanned<BinOp_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1166,6 +1192,42 @@ pub struct Expr {\n     pub hir_id: HirId,\n }\n \n+impl Expr {\n+    pub fn precedence(&self) -> ExprPrecedence {\n+        match self.node {\n+            ExprBox(_) => ExprPrecedence::Box,\n+            ExprArray(_) => ExprPrecedence::Array,\n+            ExprCall(..) => ExprPrecedence::Call,\n+            ExprMethodCall(..) => ExprPrecedence::MethodCall,\n+            ExprTup(_) => ExprPrecedence::Tup,\n+            ExprBinary(op, ..) => ExprPrecedence::Binary(op.node.into()),\n+            ExprUnary(..) => ExprPrecedence::Unary,\n+            ExprLit(_) => ExprPrecedence::Lit,\n+            ExprType(..) | ExprCast(..) => ExprPrecedence::Cast,\n+            ExprIf(..) => ExprPrecedence::If,\n+            ExprWhile(..) => ExprPrecedence::While,\n+            ExprLoop(..) => ExprPrecedence::Loop,\n+            ExprMatch(..) => ExprPrecedence::Match,\n+            ExprClosure(..) => ExprPrecedence::Closure,\n+            ExprBlock(..) => ExprPrecedence::Block,\n+            ExprAssign(..) => ExprPrecedence::Assign,\n+            ExprAssignOp(..) => ExprPrecedence::AssignOp,\n+            ExprField(..) => ExprPrecedence::Field,\n+            ExprTupField(..) => ExprPrecedence::TupField,\n+            ExprIndex(..) => ExprPrecedence::Index,\n+            ExprPath(..) => ExprPrecedence::Path,\n+            ExprAddrOf(..) => ExprPrecedence::AddrOf,\n+            ExprBreak(..) => ExprPrecedence::Break,\n+            ExprAgain(..) => ExprPrecedence::Continue,\n+            ExprRet(..) => ExprPrecedence::Ret,\n+            ExprInlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprStruct(..) => ExprPrecedence::Struct,\n+            ExprRepeat(..) => ExprPrecedence::Repeat,\n+            ExprYield(..) => ExprPrecedence::Yield,\n+        }\n+    }\n+}\n+\n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"expr({}: {})\", self.id,"}, {"sha": "4cfa7a470a4faaca1c78b742bc2502c7f905d45d", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -1104,7 +1104,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr, prec: i8) -> io::Result<()> {\n-        let needs_par = expr_precedence(expr) < prec;\n+        let needs_par = expr.precedence().order() < prec;\n         if needs_par {\n             self.popen()?;\n         }\n@@ -2318,55 +2318,6 @@ fn stmt_ends_with_semi(stmt: &hir::Stmt_) -> bool {\n     }\n }\n \n-\n-fn expr_precedence(expr: &hir::Expr) -> i8 {\n-    use syntax::util::parser::*;\n-\n-    match expr.node {\n-        hir::ExprClosure(..) => PREC_CLOSURE,\n-\n-        hir::ExprBreak(..) |\n-        hir::ExprAgain(..) |\n-        hir::ExprRet(..) |\n-        hir::ExprYield(..) => PREC_JUMP,\n-\n-        // Binop-like expr kinds, handled by `AssocOp`.\n-        hir::ExprBinary(op, _, _) => bin_op_to_assoc_op(op.node).precedence() as i8,\n-\n-        hir::ExprCast(..) => AssocOp::As.precedence() as i8,\n-        hir::ExprType(..) => AssocOp::Colon.precedence() as i8,\n-\n-        hir::ExprAssign(..) |\n-        hir::ExprAssignOp(..) => AssocOp::Assign.precedence() as i8,\n-\n-        // Unary, prefix\n-        hir::ExprBox(..) |\n-        hir::ExprAddrOf(..) |\n-        hir::ExprUnary(..) => PREC_PREFIX,\n-\n-        // Unary, postfix\n-        hir::ExprCall(..) |\n-        hir::ExprMethodCall(..) |\n-        hir::ExprField(..) |\n-        hir::ExprTupField(..) |\n-        hir::ExprIndex(..) |\n-        hir::ExprInlineAsm(..) => PREC_POSTFIX,\n-\n-        // Never need parens\n-        hir::ExprArray(..) |\n-        hir::ExprRepeat(..) |\n-        hir::ExprTup(..) |\n-        hir::ExprLit(..) |\n-        hir::ExprPath(..) |\n-        hir::ExprIf(..) |\n-        hir::ExprWhile(..) |\n-        hir::ExprLoop(..) |\n-        hir::ExprMatch(..) |\n-        hir::ExprBlock(..) |\n-        hir::ExprStruct(..) => PREC_PAREN,\n-    }\n-}\n-\n fn bin_op_to_assoc_op(op: hir::BinOp_) -> AssocOp {\n     use hir::BinOp_::*;\n     match op {"}, {"sha": "8a29155d12d5b749303ce20e5b10842ad41c5105", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -1621,6 +1621,59 @@ println!(\"const value: {}\", SomeModule::PRIVATE); // ok!\n ```\n \"##,\n \n+E0659: r##\"\n+An item usage is ambiguous.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0659\n+pub mod moon {\n+    pub fn foo() {}\n+}\n+\n+pub mod earth {\n+    pub fn foo() {}\n+}\n+\n+mod collider {\n+    pub use moon::*;\n+    pub use earth::*;\n+}\n+\n+fn main() {\n+    collider::foo(); // ERROR: `foo` is ambiguous\n+}\n+```\n+\n+This error generally appears when two items with the same name are imported into\n+a module. Here, the `foo` functions are imported and reexported from the\n+`collider` module and therefore, when we're using `collider::foo()`, both\n+functions collide.\n+\n+To solve this error, the best solution is generally to keep the path before the\n+item when using it. Example:\n+\n+```\n+pub mod moon {\n+    pub fn foo() {}\n+}\n+\n+pub mod earth {\n+    pub fn foo() {}\n+}\n+\n+mod collider {\n+    pub use moon;\n+    pub use earth;\n+}\n+\n+fn main() {\n+    collider::moon::foo(); // ok!\n+    collider::earth::foo(); // ok!\n+}\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "d9ae776a4d7b26a9b499578b8714813a50edbe25", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -3802,7 +3802,7 @@ impl<'a> Resolver<'a> {\n                 self.session.buffer_lint(lint::builtin::LEGACY_IMPORTS, id, span, &msg);\n             } else {\n                 let mut err =\n-                    self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name));\n+                    struct_span_err!(self.session, span, E0659, \"`{}` is ambiguous\", name);\n                 err.span_note(b1.span, &msg1);\n                 match b2.def() {\n                     Def::Macro(..) if b2.span == DUMMY_SP =>"}, {"sha": "b6b863cfea6e66394a3f9749a447883eacb275ac", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 240, "deletions": 4, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -15,6 +15,7 @@ use rustc::infer::InferOk;\n use rustc::traits::ObligationCause;\n \n use syntax::ast;\n+use syntax::util::parser::AssocOp;\n use syntax_pos::{self, Span};\n use rustc::hir;\n use rustc::hir::print;\n@@ -137,7 +138,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((msg, suggestion)) = self.check_ref(expr, checked_ty, expected) {\n             err.span_suggestion(expr.span, msg, suggestion);\n-        } else {\n+        } else if !self.check_for_cast(&mut err, expr, expr_ty, expected) {\n             let methods = self.get_conversion_methods(expected, checked_ty);\n             if let Ok(expr_text) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n                 let suggestions = iter::repeat(expr_text).zip(methods.iter())\n@@ -287,8 +288,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // Maybe remove `&`?\n                         hir::ExprAddrOf(_, ref expr) => {\n                             if let Ok(code) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n-                                return Some((\"consider removing the borrow\",\n-                                             code));\n+                                return Some((\"consider removing the borrow\", code));\n                             }\n                         }\n \n@@ -303,12 +303,248 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                  format!(\"*{}\", code)));\n                                 }\n                             }\n-                        },\n+                        }\n                     }\n                 }\n                 None\n             }\n             _ => None,\n         }\n     }\n+\n+    fn check_for_cast(&self,\n+                      err: &mut DiagnosticBuilder<'tcx>,\n+                      expr: &hir::Expr,\n+                      checked_ty: Ty<'tcx>,\n+                      expected_ty: Ty<'tcx>)\n+                      -> bool {\n+        let will_truncate = \"will truncate the source value\";\n+        let depending_on_isize = \"will truncate or zero-extend depending on the bit width of \\\n+                                  `isize`\";\n+        let depending_on_usize = \"will truncate or zero-extend depending on the bit width of \\\n+                                  `usize`\";\n+        let will_sign_extend = \"will sign-extend the source value\";\n+        let will_zero_extend = \"will zero-extend the source value\";\n+\n+        // If casting this expression to a given numeric type would be appropriate in case of a type\n+        // mismatch.\n+        //\n+        // We want to minimize the amount of casting operations that are suggested, as it can be a\n+        // lossy operation with potentially bad side effects, so we only suggest when encountering\n+        // an expression that indicates that the original type couldn't be directly changed.\n+        //\n+        // For now, don't suggest casting with `as`.\n+        let can_cast = false;\n+\n+        let needs_paren = expr.precedence().order() < (AssocOp::As.precedence() as i8);\n+\n+        if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+            let msg = format!(\"you can cast an `{}` to `{}`\", checked_ty, expected_ty);\n+            let cast_suggestion = format!(\"{}{}{} as {}\",\n+                                          if needs_paren { \"(\" } else { \"\" },\n+                                          src,\n+                                          if needs_paren { \")\" } else { \"\" },\n+                                          expected_ty);\n+            let into_suggestion = format!(\"{}{}{}.into()\",\n+                                          if needs_paren { \"(\" } else { \"\" },\n+                                          src,\n+                                          if needs_paren { \")\" } else { \"\" });\n+\n+            match (&expected_ty.sty, &checked_ty.sty) {\n+                (&ty::TyInt(ref exp), &ty::TyInt(ref found)) => {\n+                    match (found.bit_width(), exp.bit_width()) {\n+                        (Some(found), Some(exp)) if found > exp => {\n+                            if can_cast {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                        }\n+                        (None, _) | (_, None) => {\n+                            if can_cast {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\",\n+                                                             msg,\n+                                                             depending_on_isize),\n+                                                    cast_suggestion);\n+                            }\n+                        }\n+                        _ => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                                into_suggestion);\n+                        }\n+                    }\n+                    true\n+                }\n+                (&ty::TyUint(ref exp), &ty::TyUint(ref found)) => {\n+                    match (found.bit_width(), exp.bit_width()) {\n+                        (Some(found), Some(exp)) if found > exp => {\n+                            if can_cast {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                        }\n+                        (None, _) | (_, None) => {\n+                            if can_cast {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\",\n+                                                             msg,\n+                                                             depending_on_usize),\n+                                                    cast_suggestion);\n+                            }\n+                        }\n+                        _ => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_zero_extend),\n+                                                into_suggestion);\n+                        }\n+                    }\n+                    true\n+                }\n+                (&ty::TyInt(ref exp), &ty::TyUint(ref found)) => {\n+                    if can_cast {\n+                        match (found.bit_width(), exp.bit_width()) {\n+                            (Some(found), Some(exp)) if found > exp - 1 => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                            (None, None) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                            (None, _) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\",\n+                                                             msg,\n+                                                             depending_on_isize),\n+                                                    cast_suggestion);\n+                            }\n+                            (_, None) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\",\n+                                                             msg,\n+                                                             depending_on_usize),\n+                                                    cast_suggestion);\n+                            }\n+                            _ => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_zero_extend),\n+                                                    cast_suggestion);\n+                            }\n+                        }\n+                    }\n+                    true\n+                }\n+                (&ty::TyUint(ref exp), &ty::TyInt(ref found)) => {\n+                    if can_cast {\n+                        match (found.bit_width(), exp.bit_width()) {\n+                            (Some(found), Some(exp)) if found - 1 > exp => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                            (None, None) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                                    cast_suggestion);\n+                            }\n+                            (None, _) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\",\n+                                                             msg,\n+                                                             depending_on_usize),\n+                                                    cast_suggestion);\n+                            }\n+                            (_, None) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\",\n+                                                             msg,\n+                                                             depending_on_isize),\n+                                                    cast_suggestion);\n+                            }\n+                            _ => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                                    cast_suggestion);\n+                            }\n+                        }\n+                    }\n+                    true\n+                }\n+                (&ty::TyFloat(ref exp), &ty::TyFloat(ref found)) => {\n+                    if found.bit_width() < exp.bit_width() {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{} in a lossless way\",\n+                                                     msg),\n+                                            into_suggestion);\n+                    } else if can_cast {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the closest possible value\",\n+                                                     msg),\n+                                            cast_suggestion);\n+                        err.warn(\"casting here will cause undefined behavior if the value is \\\n+                                  finite but larger or smaller than the largest or smallest \\\n+                                  finite value representable by `f32` (this is a bug and will be \\\n+                                  fixed)\");\n+                    }\n+                    true\n+                }\n+                (&ty::TyUint(_), &ty::TyFloat(_)) | (&ty::TyInt(_), &ty::TyFloat(_)) => {\n+                    if can_cast {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, rounding the float towards zero\",\n+                                                     msg),\n+                                            cast_suggestion);\n+                        err.warn(\"casting here will cause undefined behavior if the rounded value \\\n+                                  cannot be represented by the target integer type, including \\\n+                                  `Inf` and `NaN` (this is a bug and will be fixed)\");\n+                    }\n+                    true\n+                }\n+                (&ty::TyFloat(ref exp), &ty::TyUint(ref found)) => {\n+                    // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n+                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the floating point \\\n+                                                      representation of the integer\",\n+                                                      msg),\n+                                            into_suggestion);\n+                    } else if can_cast {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the floating point \\\n+                                                      representation of the integer, rounded if \\\n+                                                      necessary\",\n+                                                      msg),\n+                                            cast_suggestion);\n+                    }\n+                    true\n+                }\n+                (&ty::TyFloat(ref exp), &ty::TyInt(ref found)) => {\n+                    // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n+                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the floating point \\\n+                                                      representation of the integer\",\n+                                                      msg),\n+                                            into_suggestion);\n+                    } else if can_cast {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the floating point \\\n+                                                      representation of the integer, rounded if \\\n+                                                      necessary\",\n+                                                      msg),\n+                                            cast_suggestion);\n+                    }\n+                    true\n+                }\n+                _ => false,\n+            }\n+        } else {\n+            false\n+        }\n+    }\n }"}, {"sha": "21218489679393a92a655bf0012caa5ad242f962", "filename": "src/libstd/sys/unix/l4re.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -437,9 +437,5 @@ pub mod net {\n     pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n         unimpl!();\n     }\n-\n-    pub fn res_init_if_glibc_before_2_26() -> io::Result<()> {\n-        unimpl!();\n-    }\n }\n "}, {"sha": "3f65975e608800a7198d6c36bb84832e4a437a62", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -51,6 +51,10 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n     if err == 0 {\n         return Ok(())\n     }\n+\n+    // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n+    on_resolver_failure();\n+\n     if err == EAI_SYSTEM {\n         return Err(io::Error::last_os_error())\n     }\n@@ -377,21 +381,22 @@ impl IntoInner<c_int> for Socket {\n // res_init unconditionally, we call it only when we detect we're linking\n // against glibc version < 2.26. (That is, when we both know its needed and\n // believe it's thread-safe).\n-pub fn res_init_if_glibc_before_2_26() -> io::Result<()> {\n+#[cfg(target_env = \"gnu\")]\n+fn on_resolver_failure() {\n     // If the version fails to parse, we treat it the same as \"not glibc\".\n     if let Some(Ok(version_str)) = glibc_version_cstr().map(CStr::to_str) {\n         if let Some(version) = parse_glibc_version(version_str) {\n             if version < (2, 26) {\n-                let ret = unsafe { libc::res_init() };\n-                if ret != 0 {\n-                    return Err(io::Error::last_os_error());\n-                }\n+                unsafe { libc::res_init() };\n             }\n         }\n     }\n-    Ok(())\n }\n \n+#[cfg(not(target_env = \"gnu\"))]\n+fn on_resolver_failure() {}\n+\n+#[cfg(target_env = \"gnu\")]\n fn glibc_version_cstr() -> Option<&'static CStr> {\n     weak! {\n         fn gnu_get_libc_version() -> *const libc::c_char\n@@ -405,6 +410,7 @@ fn glibc_version_cstr() -> Option<&'static CStr> {\n \n // Returns Some((major, minor)) if the string is a valid \"x.y\" version,\n // ignoring any extra dot-separated parts. Otherwise return None.\n+#[cfg(target_env = \"gnu\")]\n fn parse_glibc_version(version: &str) -> Option<(usize, usize)> {\n     let mut parsed_ints = version.split(\".\").map(str::parse::<usize>).fuse();\n     match (parsed_ints.next(), parsed_ints.next()) {\n@@ -413,7 +419,7 @@ fn parse_glibc_version(version: &str) -> Option<(usize, usize)> {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(all(test, taget_env = \"gnu\"))]\n mod test {\n     use super::*;\n "}, {"sha": "b841afe1a5141dfd2db749ad09077400c8cc1933", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -166,27 +166,9 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     hints.ai_socktype = c::SOCK_STREAM;\n     let mut res = ptr::null_mut();\n     unsafe {\n-        match cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)) {\n-            Ok(_) => {\n-                Ok(LookupHost { original: res, cur: res })\n-            },\n-            #[cfg(unix)]\n-            Err(e) => {\n-                // If we're running glibc prior to version 2.26, the lookup\n-                // failure could be caused by caching a stale /etc/resolv.conf.\n-                // We need to call libc::res_init() to clear the cache. But we\n-                // shouldn't call it in on any other platform, because other\n-                // res_init implementations aren't thread-safe. See\n-                // https://github.com/rust-lang/rust/issues/41570 and\n-                // https://github.com/rust-lang/rust/issues/43592.\n-                use sys::net::res_init_if_glibc_before_2_26;\n-                let _ = res_init_if_glibc_before_2_26();\n-                Err(e)\n-            },\n-            // the cfg is needed here to avoid an \"unreachable pattern\" warning\n-            #[cfg(not(unix))]\n-            Err(e) => Err(e),\n-        }\n+        cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)).map(|_| {\n+            LookupHost { original: res, cur: res }\n+        })\n     }\n }\n "}, {"sha": "a64f1e9e4002cc098a9718e46c2000ec1ef5081c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -15,6 +15,7 @@ pub use self::UnsafeSource::*;\n pub use self::PathParameters::*;\n pub use symbol::{Ident, Symbol as Name};\n pub use util::ThinVec;\n+pub use util::parser::ExprPrecedence;\n \n use syntax_pos::{Span, DUMMY_SP};\n use codemap::{respan, Spanned};\n@@ -730,6 +731,7 @@ impl BinOpKind {\n             _ => false\n         }\n     }\n+\n     pub fn is_comparison(&self) -> bool {\n         use self::BinOpKind::*;\n         match *self {\n@@ -740,6 +742,7 @@ impl BinOpKind {\n             false,\n         }\n     }\n+\n     /// Returns `true` if the binary operator takes its arguments by value\n     pub fn is_by_value(&self) -> bool {\n         !self.is_comparison()\n@@ -966,6 +969,49 @@ impl Expr {\n \n         Some(P(Ty { node, id: self.id, span: self.span }))\n     }\n+\n+    pub fn precedence(&self) -> ExprPrecedence {\n+        match self.node {\n+            ExprKind::Box(_) => ExprPrecedence::Box,\n+            ExprKind::InPlace(..) => ExprPrecedence::InPlace,\n+            ExprKind::Array(_) => ExprPrecedence::Array,\n+            ExprKind::Call(..) => ExprPrecedence::Call,\n+            ExprKind::MethodCall(..) => ExprPrecedence::MethodCall,\n+            ExprKind::Tup(_) => ExprPrecedence::Tup,\n+            ExprKind::Binary(op, ..) => ExprPrecedence::Binary(op.node),\n+            ExprKind::Unary(..) => ExprPrecedence::Unary,\n+            ExprKind::Lit(_) => ExprPrecedence::Lit,\n+            ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n+            ExprKind::If(..) => ExprPrecedence::If,\n+            ExprKind::IfLet(..) => ExprPrecedence::IfLet,\n+            ExprKind::While(..) => ExprPrecedence::While,\n+            ExprKind::WhileLet(..) => ExprPrecedence::WhileLet,\n+            ExprKind::ForLoop(..) => ExprPrecedence::ForLoop,\n+            ExprKind::Loop(..) => ExprPrecedence::Loop,\n+            ExprKind::Match(..) => ExprPrecedence::Match,\n+            ExprKind::Closure(..) => ExprPrecedence::Closure,\n+            ExprKind::Block(..) => ExprPrecedence::Block,\n+            ExprKind::Catch(..) => ExprPrecedence::Catch,\n+            ExprKind::Assign(..) => ExprPrecedence::Assign,\n+            ExprKind::AssignOp(..) => ExprPrecedence::AssignOp,\n+            ExprKind::Field(..) => ExprPrecedence::Field,\n+            ExprKind::TupField(..) => ExprPrecedence::TupField,\n+            ExprKind::Index(..) => ExprPrecedence::Index,\n+            ExprKind::Range(..) => ExprPrecedence::Range,\n+            ExprKind::Path(..) => ExprPrecedence::Path,\n+            ExprKind::AddrOf(..) => ExprPrecedence::AddrOf,\n+            ExprKind::Break(..) => ExprPrecedence::Break,\n+            ExprKind::Continue(..) => ExprPrecedence::Continue,\n+            ExprKind::Ret(..) => ExprPrecedence::Ret,\n+            ExprKind::InlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprKind::Mac(..) => ExprPrecedence::Mac,\n+            ExprKind::Struct(..) => ExprPrecedence::Struct,\n+            ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n+            ExprKind::Paren(..) => ExprPrecedence::Paren,\n+            ExprKind::Try(..) => ExprPrecedence::Try,\n+            ExprKind::Yield(..) => ExprPrecedence::Yield,\n+        }\n+    }\n }\n \n impl fmt::Debug for Expr {"}, {"sha": "ff065b57b8d0b45b557d30b00045f044795a989f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -1839,7 +1839,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) -> io::Result<()> {\n-        let needs_par = parser::expr_precedence(expr) < prec;\n+        let needs_par = expr.precedence().order() < prec;\n         if needs_par {\n             self.popen()?;\n         }"}, {"sha": "86963c4000bd16c84e40a6c77a24e4f13b54b196", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 124, "deletions": 58, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n use parse::token::{Token, BinOpToken};\n use symbol::keywords;\n-use ast::{self, BinOpKind, ExprKind};\n+use ast::{self, BinOpKind};\n+\n+use std::cmp::Ordering;\n \n /// Associative operator with precedence.\n ///\n@@ -228,66 +230,130 @@ pub const PREC_POSTFIX: i8 = 60;\n pub const PREC_PAREN: i8 = 99;\n pub const PREC_FORCE_PAREN: i8 = 100;\n \n-pub fn expr_precedence(expr: &ast::Expr) -> i8 {\n-    match expr.node {\n-        ExprKind::Closure(..) => PREC_CLOSURE,\n-\n-        ExprKind::Break(..) |\n-        ExprKind::Continue(..) |\n-        ExprKind::Ret(..) |\n-        ExprKind::Yield(..) => PREC_JUMP,\n-\n-        // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to parse,\n-        // instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence ensures that\n-        // `pprust` will add parentheses in the right places to get the desired parse.\n-        ExprKind::Range(..) => PREC_RANGE,\n-\n-        // Binop-like expr kinds, handled by `AssocOp`.\n-        ExprKind::Binary(op, _, _) =>\n-            AssocOp::from_ast_binop(op.node).precedence() as i8,\n-\n-        ExprKind::InPlace(..) => AssocOp::Inplace.precedence() as i8,\n-        ExprKind::Cast(..) => AssocOp::As.precedence() as i8,\n-        ExprKind::Type(..) => AssocOp::Colon.precedence() as i8,\n-\n-        ExprKind::Assign(..) |\n-        ExprKind::AssignOp(..) => AssocOp::Assign.precedence() as i8,\n-\n-        // Unary, prefix\n-        ExprKind::Box(..) |\n-        ExprKind::AddrOf(..) |\n-        ExprKind::Unary(..) => PREC_PREFIX,\n-\n-        // Unary, postfix\n-        ExprKind::Call(..) |\n-        ExprKind::MethodCall(..) |\n-        ExprKind::Field(..) |\n-        ExprKind::TupField(..) |\n-        ExprKind::Index(..) |\n-        ExprKind::Try(..) |\n-        ExprKind::InlineAsm(..) |\n-        ExprKind::Mac(..) => PREC_POSTFIX,\n-\n-        // Never need parens\n-        ExprKind::Array(..) |\n-        ExprKind::Repeat(..) |\n-        ExprKind::Tup(..) |\n-        ExprKind::Lit(..) |\n-        ExprKind::Path(..) |\n-        ExprKind::Paren(..) |\n-        ExprKind::If(..) |\n-        ExprKind::IfLet(..) |\n-        ExprKind::While(..) |\n-        ExprKind::WhileLet(..) |\n-        ExprKind::ForLoop(..) |\n-        ExprKind::Loop(..) |\n-        ExprKind::Match(..) |\n-        ExprKind::Block(..) |\n-        ExprKind::Catch(..) |\n-        ExprKind::Struct(..) => PREC_PAREN,\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ExprPrecedence {\n+    Closure,\n+    Break,\n+    Continue,\n+    Ret,\n+    Yield,\n+\n+    Range,\n+\n+    Binary(BinOpKind),\n+\n+    InPlace,\n+    Cast,\n+    Type,\n+\n+    Assign,\n+    AssignOp,\n+\n+    Box,\n+    AddrOf,\n+    Unary,\n+\n+    Call,\n+    MethodCall,\n+    Field,\n+    TupField,\n+    Index,\n+    Try,\n+    InlineAsm,\n+    Mac,\n+\n+    Array,\n+    Repeat,\n+    Tup,\n+    Lit,\n+    Path,\n+    Paren,\n+    If,\n+    IfLet,\n+    While,\n+    WhileLet,\n+    ForLoop,\n+    Loop,\n+    Match,\n+    Block,\n+    Catch,\n+    Struct,\n+}\n+\n+impl PartialOrd for ExprPrecedence {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.order().cmp(&other.order()))\n+    }\n+}\n+\n+impl Ord for ExprPrecedence {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.order().cmp(&other.order())\n     }\n }\n \n+impl ExprPrecedence {\n+    pub fn order(self) -> i8 {\n+        match self {\n+            ExprPrecedence::Closure => PREC_CLOSURE,\n+\n+            ExprPrecedence::Break |\n+            ExprPrecedence::Continue |\n+            ExprPrecedence::Ret |\n+            ExprPrecedence::Yield => PREC_JUMP,\n+\n+            // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to\n+            // parse, instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence\n+            // ensures that `pprust` will add parentheses in the right places to get the desired\n+            // parse.\n+            ExprPrecedence::Range => PREC_RANGE,\n+\n+            // Binop-like expr kinds, handled by `AssocOp`.\n+            ExprPrecedence::Binary(op) => AssocOp::from_ast_binop(op).precedence() as i8,\n+            ExprPrecedence::InPlace => AssocOp::Inplace.precedence() as i8,\n+            ExprPrecedence::Cast => AssocOp::As.precedence() as i8,\n+            ExprPrecedence::Type => AssocOp::Colon.precedence() as i8,\n+\n+            ExprPrecedence::Assign |\n+            ExprPrecedence::AssignOp => AssocOp::Assign.precedence() as i8,\n+\n+            // Unary, prefix\n+            ExprPrecedence::Box |\n+            ExprPrecedence::AddrOf |\n+            ExprPrecedence::Unary => PREC_PREFIX,\n+\n+            // Unary, postfix\n+            ExprPrecedence::Call |\n+            ExprPrecedence::MethodCall |\n+            ExprPrecedence::Field |\n+            ExprPrecedence::TupField |\n+            ExprPrecedence::Index |\n+            ExprPrecedence::Try |\n+            ExprPrecedence::InlineAsm |\n+            ExprPrecedence::Mac => PREC_POSTFIX,\n+\n+            // Never need parens\n+            ExprPrecedence::Array |\n+            ExprPrecedence::Repeat |\n+            ExprPrecedence::Tup |\n+            ExprPrecedence::Lit |\n+            ExprPrecedence::Path |\n+            ExprPrecedence::Paren |\n+            ExprPrecedence::If |\n+            ExprPrecedence::IfLet |\n+            ExprPrecedence::While |\n+            ExprPrecedence::WhileLet |\n+            ExprPrecedence::ForLoop |\n+            ExprPrecedence::Loop |\n+            ExprPrecedence::Match |\n+            ExprPrecedence::Block |\n+            ExprPrecedence::Catch |\n+            ExprPrecedence::Struct => PREC_PAREN,\n+        }\n+    }\n+}\n+\n+\n /// Expressions that syntactically contain an \"exterior\" struct literal i.e. not surrounded by any\n /// parens or other delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not."}, {"sha": "4bd452b0aac3d50d93320392d9a4ebd7413af5ba", "filename": "src/test/compile-fail/E0659.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fcompile-fail%2FE0659.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fcompile-fail%2FE0659.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0659.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod moon {\n+    pub fn foo() {}\n+}\n+\n+mod earth {\n+    pub fn foo() {}\n+}\n+\n+mod collider {\n+    pub use moon::*;\n+    pub use earth::*;\n+}\n+\n+fn main() {\n+    collider::foo(); //~ ERROR E0659\n+}"}, {"sha": "a74401314a18cb3698e6ac419087d5872bcbd23e", "filename": "src/test/ui/imports/duplicate.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fimports%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fimports%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fduplicate.stderr?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -12,7 +12,7 @@ help: You can use `as` to change the binding name of the import\n 25 |     use a::foo as Otherfoo; //~ ERROR the name `foo` is defined multiple times\n    |         ^^^^^^^^^^^^^^^^^^\n \n-error: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous\n   --> $DIR/duplicate.rs:56:9\n    |\n 56 |     use self::foo::bar; //~ ERROR `foo` is ambiguous\n@@ -30,7 +30,7 @@ note: `foo` could also refer to the name imported here\n    |         ^^^^^^^^^^^\n    = note: consider adding an explicit import of `foo` to disambiguate\n \n-error: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous\n   --> $DIR/duplicate.rs:45:5\n    |\n 45 |     f::foo(); //~ ERROR `foo` is ambiguous\n@@ -48,7 +48,7 @@ note: `foo` could also refer to the name imported here\n    |             ^^^^\n    = note: consider adding an explicit import of `foo` to disambiguate\n \n-error: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous\n   --> $DIR/duplicate.rs:46:5\n    |\n 46 |     g::foo(); //~ ERROR `foo` is ambiguous\n@@ -66,7 +66,7 @@ note: `foo` could also refer to the name imported here\n    |             ^^^^\n    = note: consider adding an explicit import of `foo` to disambiguate\n \n-error: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous\n   --> $DIR/duplicate.rs:59:9\n    |\n 59 |         foo::bar(); //~ ERROR `foo` is ambiguous"}, {"sha": "32d78666004c422196b5e60c1f9ba69692753b2b", "filename": "src/test/ui/imports/macro-paths.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -1,4 +1,4 @@\n-error: `bar` is ambiguous\n+error[E0659]: `bar` is ambiguous\n   --> $DIR/macro-paths.rs:25:5\n    |\n 25 |     bar::m! { //~ ERROR ambiguous\n@@ -16,7 +16,7 @@ note: `bar` could also refer to the name imported here\n    |         ^^^^^^\n    = note: macro-expanded items do not shadow when used in a macro invocation path\n \n-error: `baz` is ambiguous\n+error[E0659]: `baz` is ambiguous\n   --> $DIR/macro-paths.rs:35:5\n    |\n 35 |     baz::m! { //~ ERROR ambiguous"}, {"sha": "75294f7bf1256391a89fcb3fc3d709fd9e5f24e8", "filename": "src/test/ui/imports/macros.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -15,7 +15,7 @@ note: `m` could also refer to the macro imported here\n 49 |     use two_macros::m;\n    |         ^^^^^^^^^^^^^\n \n-error: `m` is ambiguous\n+error[E0659]: `m` is ambiguous\n   --> $DIR/macros.rs:28:5\n    |\n 28 |     m! { //~ ERROR ambiguous\n@@ -33,7 +33,7 @@ note: `m` could also refer to the name imported here\n    |         ^^^^^^^^^^^^^\n    = note: macro-expanded macro imports do not shadow\n \n-error: `m` is ambiguous\n+error[E0659]: `m` is ambiguous\n   --> $DIR/macros.rs:41:9\n    |\n 41 |         m! { //~ ERROR ambiguous"}, {"sha": "8f4325fa12c72576aa5155ddf414e358e122e266", "filename": "src/test/ui/imports/shadow_builtin_macros.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -9,7 +9,7 @@ error: `panic` is already in scope\n    |\n    = note: macro-expanded `macro_rules!`s may not shadow existing macros (see RFC 1560)\n \n-error: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:27:14\n    |\n 27 |     fn f() { panic!(); } //~ ERROR ambiguous\n@@ -23,7 +23,7 @@ note: `panic` could refer to the name imported here\n    = note: `panic` is also a builtin macro\n    = note: consider adding an explicit import of `panic` to disambiguate\n \n-error: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:32:14\n    |\n 32 |     fn f() { panic!(); } //~ ERROR ambiguous\n@@ -37,7 +37,7 @@ note: `panic` could refer to the name imported here\n    = note: `panic` is also a builtin macro\n    = note: macro-expanded macro imports do not shadow\n \n-error: `n` is ambiguous\n+error[E0659]: `n` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:61:5\n    |\n 61 |     n!(); //~ ERROR ambiguous"}, {"sha": "0c886fdb52faad44b1ae8ab402448e4aca3444ff", "filename": "src/test/ui/issue-47623.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fissue-47623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fissue-47623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47623.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self; //~ERROR `self` imports are only allowed within a { } list\n+\n+fn main() {}"}, {"sha": "c5a42d4d846e8433f800eddbf0f9a36cdc5e87e5", "filename": "src/test/ui/issue-47623.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fissue-47623.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fissue-47623.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47623.stderr?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -0,0 +1,8 @@\n+error[E0429]: `self` imports are only allowed within a { } list\n+  --> $DIR/issue-47623.rs:11:5\n+   |\n+11 | use self; //~ERROR `self` imports are only allowed within a { } list\n+   |     ^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2092b6bce37c1733bcd4da00647779542b548eef", "filename": "src/test/ui/suggestions/numeric-cast-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo() -> i32 {\n+    4\n+}\n+fn main() {\n+    let x: u16 = foo();\n+    //~^ ERROR mismatched types\n+    let y: i64 = x + x;\n+    //~^ ERROR mismatched types\n+    let z: i32 = x + x;\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "90086d247d6e92764f3e2f925c54307d15ffaa61", "filename": "src/test/ui/suggestions/numeric-cast-2.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.stderr?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -0,0 +1,20 @@\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-2.rs:15:18\n+   |\n+15 |     let x: u16 = foo();\n+   |                  ^^^^^ expected u16, found i32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-2.rs:17:18\n+   |\n+17 |     let y: i64 = x + x;\n+   |                  ^^^^^ expected i64, found u16\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-2.rs:19:18\n+   |\n+19 |     let z: i32 = x + x;\n+   |                  ^^^^^ expected i32, found u16\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "6e144037ec2208a8eddf94dd5e7976696c862a4e", "filename": "src/test/ui/suggestions/numeric-cast.rs", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.rs?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -0,0 +1,315 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+fn foo<N>(_x: N) {}\n+\n+fn main() {\n+    let x_usize: usize = 1;\n+    let x_u64: u64 = 2;\n+    let x_u32: u32 = 3;\n+    let x_u16: u16 = 4;\n+    let x_u8: u8 = 5;\n+    let x_isize: isize = 6;\n+    let x_i64: i64 = 7;\n+    let x_i32: i32 = 8;\n+    let x_i16: i16 = 9;\n+    let x_i8: i8 = 10;\n+    let x_f64: f64 = 11.0;\n+    let x_f32: f32 = 12.0;\n+\n+    foo::<usize>(x_usize);\n+    foo::<usize>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<isize>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_isize);\n+    foo::<isize>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<u64>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_u64);\n+    foo::<u64>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<i64>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_i64);\n+    foo::<i64>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<u32>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_u32);\n+    foo::<u32>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<i32>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_i32);\n+    foo::<i32>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<u16>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_u16);\n+    foo::<u16>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<i16>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_i16);\n+    foo::<i16>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<u8>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_u8);\n+    foo::<u8>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<i8>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_i8);\n+    foo::<i8>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<f64>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_f64);\n+    foo::<f64>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<f32>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_f32);\n+}"}, {"sha": "0ce3d087f350927d1048489aeb202938b5d86488", "filename": "src/test/ui/suggestions/numeric-cast.stderr", "status": "added", "additions": 886, "deletions": 0, "changes": 886, "blob_url": "https://github.com/rust-lang/rust/blob/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff2a7c85757542f454934e00605355bbca7bc196/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.stderr?ref=ff2a7c85757542f454934e00605355bbca7bc196", "patch": "@@ -0,0 +1,886 @@\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:29:18\n+   |\n+29 |     foo::<usize>(x_u64);\n+   |                  ^^^^^ expected usize, found u64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:31:18\n+   |\n+31 |     foo::<usize>(x_u32);\n+   |                  ^^^^^ expected usize, found u32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:33:18\n+   |\n+33 |     foo::<usize>(x_u16);\n+   |                  ^^^^^ expected usize, found u16\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:35:18\n+   |\n+35 |     foo::<usize>(x_u8);\n+   |                  ^^^^ expected usize, found u8\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:37:18\n+   |\n+37 |     foo::<usize>(x_isize);\n+   |                  ^^^^^^^ expected usize, found isize\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:39:18\n+   |\n+39 |     foo::<usize>(x_i64);\n+   |                  ^^^^^ expected usize, found i64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:41:18\n+   |\n+41 |     foo::<usize>(x_i32);\n+   |                  ^^^^^ expected usize, found i32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:43:18\n+   |\n+43 |     foo::<usize>(x_i16);\n+   |                  ^^^^^ expected usize, found i16\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:45:18\n+   |\n+45 |     foo::<usize>(x_i8);\n+   |                  ^^^^ expected usize, found i8\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:47:18\n+   |\n+47 |     foo::<usize>(x_f64);\n+   |                  ^^^^^ expected usize, found f64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:49:18\n+   |\n+49 |     foo::<usize>(x_f32);\n+   |                  ^^^^^ expected usize, found f32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:52:18\n+   |\n+52 |     foo::<isize>(x_usize);\n+   |                  ^^^^^^^ expected isize, found usize\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:54:18\n+   |\n+54 |     foo::<isize>(x_u64);\n+   |                  ^^^^^ expected isize, found u64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:56:18\n+   |\n+56 |     foo::<isize>(x_u32);\n+   |                  ^^^^^ expected isize, found u32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:58:18\n+   |\n+58 |     foo::<isize>(x_u16);\n+   |                  ^^^^^ expected isize, found u16\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:60:18\n+   |\n+60 |     foo::<isize>(x_u8);\n+   |                  ^^^^ expected isize, found u8\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:63:18\n+   |\n+63 |     foo::<isize>(x_i64);\n+   |                  ^^^^^ expected isize, found i64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:65:18\n+   |\n+65 |     foo::<isize>(x_i32);\n+   |                  ^^^^^ expected isize, found i32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:67:18\n+   |\n+67 |     foo::<isize>(x_i16);\n+   |                  ^^^^^ expected isize, found i16\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:69:18\n+   |\n+69 |     foo::<isize>(x_i8);\n+   |                  ^^^^ expected isize, found i8\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:71:18\n+   |\n+71 |     foo::<isize>(x_f64);\n+   |                  ^^^^^ expected isize, found f64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:73:18\n+   |\n+73 |     foo::<isize>(x_f32);\n+   |                  ^^^^^ expected isize, found f32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:76:16\n+   |\n+76 |     foo::<u64>(x_usize);\n+   |                ^^^^^^^ expected u64, found usize\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:79:16\n+   |\n+79 |     foo::<u64>(x_u32);\n+   |                ^^^^^ expected u64, found u32\n+help: you can cast an `u32` to `u64`, which will zero-extend the source value\n+   |\n+79 |     foo::<u64>(x_u32.into());\n+   |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:81:16\n+   |\n+81 |     foo::<u64>(x_u16);\n+   |                ^^^^^ expected u64, found u16\n+help: you can cast an `u16` to `u64`, which will zero-extend the source value\n+   |\n+81 |     foo::<u64>(x_u16.into());\n+   |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:83:16\n+   |\n+83 |     foo::<u64>(x_u8);\n+   |                ^^^^ expected u64, found u8\n+help: you can cast an `u8` to `u64`, which will zero-extend the source value\n+   |\n+83 |     foo::<u64>(x_u8.into());\n+   |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:85:16\n+   |\n+85 |     foo::<u64>(x_isize);\n+   |                ^^^^^^^ expected u64, found isize\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:87:16\n+   |\n+87 |     foo::<u64>(x_i64);\n+   |                ^^^^^ expected u64, found i64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:89:16\n+   |\n+89 |     foo::<u64>(x_i32);\n+   |                ^^^^^ expected u64, found i32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:91:16\n+   |\n+91 |     foo::<u64>(x_i16);\n+   |                ^^^^^ expected u64, found i16\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:93:16\n+   |\n+93 |     foo::<u64>(x_i8);\n+   |                ^^^^ expected u64, found i8\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:95:16\n+   |\n+95 |     foo::<u64>(x_f64);\n+   |                ^^^^^ expected u64, found f64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:97:16\n+   |\n+97 |     foo::<u64>(x_f32);\n+   |                ^^^^^ expected u64, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:100:16\n+    |\n+100 |     foo::<i64>(x_usize);\n+    |                ^^^^^^^ expected i64, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:102:16\n+    |\n+102 |     foo::<i64>(x_u64);\n+    |                ^^^^^ expected i64, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:104:16\n+    |\n+104 |     foo::<i64>(x_u32);\n+    |                ^^^^^ expected i64, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:106:16\n+    |\n+106 |     foo::<i64>(x_u16);\n+    |                ^^^^^ expected i64, found u16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:108:16\n+    |\n+108 |     foo::<i64>(x_u8);\n+    |                ^^^^ expected i64, found u8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:110:16\n+    |\n+110 |     foo::<i64>(x_isize);\n+    |                ^^^^^^^ expected i64, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:113:16\n+    |\n+113 |     foo::<i64>(x_i32);\n+    |                ^^^^^ expected i64, found i32\n+help: you can cast an `i32` to `i64`, which will sign-extend the source value\n+    |\n+113 |     foo::<i64>(x_i32.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:115:16\n+    |\n+115 |     foo::<i64>(x_i16);\n+    |                ^^^^^ expected i64, found i16\n+help: you can cast an `i16` to `i64`, which will sign-extend the source value\n+    |\n+115 |     foo::<i64>(x_i16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:117:16\n+    |\n+117 |     foo::<i64>(x_i8);\n+    |                ^^^^ expected i64, found i8\n+help: you can cast an `i8` to `i64`, which will sign-extend the source value\n+    |\n+117 |     foo::<i64>(x_i8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:119:16\n+    |\n+119 |     foo::<i64>(x_f64);\n+    |                ^^^^^ expected i64, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:121:16\n+    |\n+121 |     foo::<i64>(x_f32);\n+    |                ^^^^^ expected i64, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:124:16\n+    |\n+124 |     foo::<u32>(x_usize);\n+    |                ^^^^^^^ expected u32, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:126:16\n+    |\n+126 |     foo::<u32>(x_u64);\n+    |                ^^^^^ expected u32, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:129:16\n+    |\n+129 |     foo::<u32>(x_u16);\n+    |                ^^^^^ expected u32, found u16\n+help: you can cast an `u16` to `u32`, which will zero-extend the source value\n+    |\n+129 |     foo::<u32>(x_u16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:131:16\n+    |\n+131 |     foo::<u32>(x_u8);\n+    |                ^^^^ expected u32, found u8\n+help: you can cast an `u8` to `u32`, which will zero-extend the source value\n+    |\n+131 |     foo::<u32>(x_u8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:133:16\n+    |\n+133 |     foo::<u32>(x_isize);\n+    |                ^^^^^^^ expected u32, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:135:16\n+    |\n+135 |     foo::<u32>(x_i64);\n+    |                ^^^^^ expected u32, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:137:16\n+    |\n+137 |     foo::<u32>(x_i32);\n+    |                ^^^^^ expected u32, found i32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:139:16\n+    |\n+139 |     foo::<u32>(x_i16);\n+    |                ^^^^^ expected u32, found i16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:141:16\n+    |\n+141 |     foo::<u32>(x_i8);\n+    |                ^^^^ expected u32, found i8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:143:16\n+    |\n+143 |     foo::<u32>(x_f64);\n+    |                ^^^^^ expected u32, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:145:16\n+    |\n+145 |     foo::<u32>(x_f32);\n+    |                ^^^^^ expected u32, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:148:16\n+    |\n+148 |     foo::<i32>(x_usize);\n+    |                ^^^^^^^ expected i32, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:150:16\n+    |\n+150 |     foo::<i32>(x_u64);\n+    |                ^^^^^ expected i32, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:152:16\n+    |\n+152 |     foo::<i32>(x_u32);\n+    |                ^^^^^ expected i32, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:154:16\n+    |\n+154 |     foo::<i32>(x_u16);\n+    |                ^^^^^ expected i32, found u16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:156:16\n+    |\n+156 |     foo::<i32>(x_u8);\n+    |                ^^^^ expected i32, found u8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:158:16\n+    |\n+158 |     foo::<i32>(x_isize);\n+    |                ^^^^^^^ expected i32, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:160:16\n+    |\n+160 |     foo::<i32>(x_i64);\n+    |                ^^^^^ expected i32, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:163:16\n+    |\n+163 |     foo::<i32>(x_i16);\n+    |                ^^^^^ expected i32, found i16\n+help: you can cast an `i16` to `i32`, which will sign-extend the source value\n+    |\n+163 |     foo::<i32>(x_i16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:165:16\n+    |\n+165 |     foo::<i32>(x_i8);\n+    |                ^^^^ expected i32, found i8\n+help: you can cast an `i8` to `i32`, which will sign-extend the source value\n+    |\n+165 |     foo::<i32>(x_i8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:167:16\n+    |\n+167 |     foo::<i32>(x_f64);\n+    |                ^^^^^ expected i32, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:169:16\n+    |\n+169 |     foo::<i32>(x_f32);\n+    |                ^^^^^ expected i32, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:172:16\n+    |\n+172 |     foo::<u16>(x_usize);\n+    |                ^^^^^^^ expected u16, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:174:16\n+    |\n+174 |     foo::<u16>(x_u64);\n+    |                ^^^^^ expected u16, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:176:16\n+    |\n+176 |     foo::<u16>(x_u32);\n+    |                ^^^^^ expected u16, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:179:16\n+    |\n+179 |     foo::<u16>(x_u8);\n+    |                ^^^^ expected u16, found u8\n+help: you can cast an `u8` to `u16`, which will zero-extend the source value\n+    |\n+179 |     foo::<u16>(x_u8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:181:16\n+    |\n+181 |     foo::<u16>(x_isize);\n+    |                ^^^^^^^ expected u16, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:183:16\n+    |\n+183 |     foo::<u16>(x_i64);\n+    |                ^^^^^ expected u16, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:185:16\n+    |\n+185 |     foo::<u16>(x_i32);\n+    |                ^^^^^ expected u16, found i32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:187:16\n+    |\n+187 |     foo::<u16>(x_i16);\n+    |                ^^^^^ expected u16, found i16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:189:16\n+    |\n+189 |     foo::<u16>(x_i8);\n+    |                ^^^^ expected u16, found i8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:191:16\n+    |\n+191 |     foo::<u16>(x_f64);\n+    |                ^^^^^ expected u16, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:193:16\n+    |\n+193 |     foo::<u16>(x_f32);\n+    |                ^^^^^ expected u16, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:196:16\n+    |\n+196 |     foo::<i16>(x_usize);\n+    |                ^^^^^^^ expected i16, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:198:16\n+    |\n+198 |     foo::<i16>(x_u64);\n+    |                ^^^^^ expected i16, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:200:16\n+    |\n+200 |     foo::<i16>(x_u32);\n+    |                ^^^^^ expected i16, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:202:16\n+    |\n+202 |     foo::<i16>(x_u16);\n+    |                ^^^^^ expected i16, found u16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:204:16\n+    |\n+204 |     foo::<i16>(x_u8);\n+    |                ^^^^ expected i16, found u8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:206:16\n+    |\n+206 |     foo::<i16>(x_isize);\n+    |                ^^^^^^^ expected i16, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:208:16\n+    |\n+208 |     foo::<i16>(x_i64);\n+    |                ^^^^^ expected i16, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:210:16\n+    |\n+210 |     foo::<i16>(x_i32);\n+    |                ^^^^^ expected i16, found i32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:213:16\n+    |\n+213 |     foo::<i16>(x_i8);\n+    |                ^^^^ expected i16, found i8\n+help: you can cast an `i8` to `i16`, which will sign-extend the source value\n+    |\n+213 |     foo::<i16>(x_i8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:215:16\n+    |\n+215 |     foo::<i16>(x_f64);\n+    |                ^^^^^ expected i16, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:217:16\n+    |\n+217 |     foo::<i16>(x_f32);\n+    |                ^^^^^ expected i16, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:220:15\n+    |\n+220 |     foo::<u8>(x_usize);\n+    |               ^^^^^^^ expected u8, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:222:15\n+    |\n+222 |     foo::<u8>(x_u64);\n+    |               ^^^^^ expected u8, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:224:15\n+    |\n+224 |     foo::<u8>(x_u32);\n+    |               ^^^^^ expected u8, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:226:15\n+    |\n+226 |     foo::<u8>(x_u16);\n+    |               ^^^^^ expected u8, found u16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:229:15\n+    |\n+229 |     foo::<u8>(x_isize);\n+    |               ^^^^^^^ expected u8, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:231:15\n+    |\n+231 |     foo::<u8>(x_i64);\n+    |               ^^^^^ expected u8, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:233:15\n+    |\n+233 |     foo::<u8>(x_i32);\n+    |               ^^^^^ expected u8, found i32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:235:15\n+    |\n+235 |     foo::<u8>(x_i16);\n+    |               ^^^^^ expected u8, found i16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:237:15\n+    |\n+237 |     foo::<u8>(x_i8);\n+    |               ^^^^ expected u8, found i8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:239:15\n+    |\n+239 |     foo::<u8>(x_f64);\n+    |               ^^^^^ expected u8, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:241:15\n+    |\n+241 |     foo::<u8>(x_f32);\n+    |               ^^^^^ expected u8, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:244:15\n+    |\n+244 |     foo::<i8>(x_usize);\n+    |               ^^^^^^^ expected i8, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:246:15\n+    |\n+246 |     foo::<i8>(x_u64);\n+    |               ^^^^^ expected i8, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:248:15\n+    |\n+248 |     foo::<i8>(x_u32);\n+    |               ^^^^^ expected i8, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:250:15\n+    |\n+250 |     foo::<i8>(x_u16);\n+    |               ^^^^^ expected i8, found u16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:252:15\n+    |\n+252 |     foo::<i8>(x_u8);\n+    |               ^^^^ expected i8, found u8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:254:15\n+    |\n+254 |     foo::<i8>(x_isize);\n+    |               ^^^^^^^ expected i8, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:256:15\n+    |\n+256 |     foo::<i8>(x_i64);\n+    |               ^^^^^ expected i8, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:258:15\n+    |\n+258 |     foo::<i8>(x_i32);\n+    |               ^^^^^ expected i8, found i32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:260:15\n+    |\n+260 |     foo::<i8>(x_i16);\n+    |               ^^^^^ expected i8, found i16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:263:15\n+    |\n+263 |     foo::<i8>(x_f64);\n+    |               ^^^^^ expected i8, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:265:15\n+    |\n+265 |     foo::<i8>(x_f32);\n+    |               ^^^^^ expected i8, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:268:16\n+    |\n+268 |     foo::<f64>(x_usize);\n+    |                ^^^^^^^ expected f64, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:270:16\n+    |\n+270 |     foo::<f64>(x_u64);\n+    |                ^^^^^ expected f64, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:272:16\n+    |\n+272 |     foo::<f64>(x_u32);\n+    |                ^^^^^ expected f64, found u32\n+help: you can cast an `u32` to `f64`, producing the floating point representation of the integer\n+    |\n+272 |     foo::<f64>(x_u32.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:274:16\n+    |\n+274 |     foo::<f64>(x_u16);\n+    |                ^^^^^ expected f64, found u16\n+help: you can cast an `u16` to `f64`, producing the floating point representation of the integer\n+    |\n+274 |     foo::<f64>(x_u16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:276:16\n+    |\n+276 |     foo::<f64>(x_u8);\n+    |                ^^^^ expected f64, found u8\n+help: you can cast an `u8` to `f64`, producing the floating point representation of the integer\n+    |\n+276 |     foo::<f64>(x_u8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:278:16\n+    |\n+278 |     foo::<f64>(x_isize);\n+    |                ^^^^^^^ expected f64, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:280:16\n+    |\n+280 |     foo::<f64>(x_i64);\n+    |                ^^^^^ expected f64, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:282:16\n+    |\n+282 |     foo::<f64>(x_i32);\n+    |                ^^^^^ expected f64, found i32\n+help: you can cast an `i32` to `f64`, producing the floating point representation of the integer\n+    |\n+282 |     foo::<f64>(x_i32.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:284:16\n+    |\n+284 |     foo::<f64>(x_i16);\n+    |                ^^^^^ expected f64, found i16\n+help: you can cast an `i16` to `f64`, producing the floating point representation of the integer\n+    |\n+284 |     foo::<f64>(x_i16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:286:16\n+    |\n+286 |     foo::<f64>(x_i8);\n+    |                ^^^^ expected f64, found i8\n+help: you can cast an `i8` to `f64`, producing the floating point representation of the integer\n+    |\n+286 |     foo::<f64>(x_i8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:289:16\n+    |\n+289 |     foo::<f64>(x_f32);\n+    |                ^^^^^ expected f64, found f32\n+help: you can cast an `f32` to `f64` in a lossless way\n+    |\n+289 |     foo::<f64>(x_f32.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:292:16\n+    |\n+292 |     foo::<f32>(x_usize);\n+    |                ^^^^^^^ expected f32, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:294:16\n+    |\n+294 |     foo::<f32>(x_u64);\n+    |                ^^^^^ expected f32, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:296:16\n+    |\n+296 |     foo::<f32>(x_u32);\n+    |                ^^^^^ expected f32, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:298:16\n+    |\n+298 |     foo::<f32>(x_u16);\n+    |                ^^^^^ expected f32, found u16\n+help: you can cast an `u16` to `f32`, producing the floating point representation of the integer\n+    |\n+298 |     foo::<f32>(x_u16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:300:16\n+    |\n+300 |     foo::<f32>(x_u8);\n+    |                ^^^^ expected f32, found u8\n+help: you can cast an `u8` to `f32`, producing the floating point representation of the integer\n+    |\n+300 |     foo::<f32>(x_u8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:302:16\n+    |\n+302 |     foo::<f32>(x_isize);\n+    |                ^^^^^^^ expected f32, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:304:16\n+    |\n+304 |     foo::<f32>(x_i64);\n+    |                ^^^^^ expected f32, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:306:16\n+    |\n+306 |     foo::<f32>(x_i32);\n+    |                ^^^^^ expected f32, found i32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:308:16\n+    |\n+308 |     foo::<f32>(x_i16);\n+    |                ^^^^^ expected f32, found i16\n+help: you can cast an `i16` to `f32`, producing the floating point representation of the integer\n+    |\n+308 |     foo::<f32>(x_i16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:310:16\n+    |\n+310 |     foo::<f32>(x_i8);\n+    |                ^^^^ expected f32, found i8\n+help: you can cast an `i8` to `f32`, producing the floating point representation of the integer\n+    |\n+310 |     foo::<f32>(x_i8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:312:16\n+    |\n+312 |     foo::<f32>(x_f64);\n+    |                ^^^^^ expected f32, found f64\n+\n+error: aborting due to 132 previous errors\n+"}]}