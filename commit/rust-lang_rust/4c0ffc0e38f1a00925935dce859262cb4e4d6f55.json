{"sha": "4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMGZmYzBlMzhmMWEwMDkyNTkzNWRjZTg1OTI2MmNiNGU0ZDZmNTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-18T04:23:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-18T04:23:25Z"}, "message": "Auto merge of #27823 - eefriedman:float-dep-core, r=alexcrichton\n\nThere wasn't any particular reason the functions needed to be there\r\nanyway, so just get rid of them, and adjust libstd to compensate.\r\n\r\nWith this change, libcore depends on exactly two floating-point functions:\r\nfmod and fmodf.  They are implicitly referenced because they are used to\r\nimplement \"%\".\r\n\r\nDependencies of libcore on Linux x86-x64 with this patch:\r\n```\r\n0000000000000000         *UND*\t0000000000000000 __powidf2\r\n0000000000000000         *UND*\t0000000000000000 __powisf2\r\n0000000000000000         *UND*\t0000000000000000 fmod\r\n0000000000000000         *UND*\t0000000000000000 fmodf\r\n0000000000000000         *UND*\t0000000000000000 memcmp\r\n0000000000000000         *UND*\t0000000000000000 memcpy\r\n0000000000000000         *UND*\t0000000000000000 memset\r\n0000000000000000         *UND*\t0000000000000000 rust_begin_unwind\r\n0000000000000000         *UND*\t0000000000000000 rust_eh_personality\r\n```", "tree": {"sha": "0a6b813b76397ec1d6acba8e8d7c9a3d7514d119", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a6b813b76397ec1d6acba8e8d7c9a3d7514d119"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "html_url": "https://github.com/rust-lang/rust/commit/4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de67d62c6b7e76ca53b66b3796258238348b3c96", "url": "https://api.github.com/repos/rust-lang/rust/commits/de67d62c6b7e76ca53b66b3796258238348b3c96", "html_url": "https://github.com/rust-lang/rust/commit/de67d62c6b7e76ca53b66b3796258238348b3c96"}, {"sha": "1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "html_url": "https://github.com/rust-lang/rust/commit/1ddee8070d3cb83609b1f71c29e3deda3d30fd51"}], "stats": {"total": 512, "additions": 194, "deletions": 318}, "files": [{"sha": "1b7cbb050d1d93ea0108f07f13f5441c3f674b66", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -216,63 +216,6 @@ impl Float for f32 {\n         (mantissa as u64, exponent, sign)\n     }\n \n-    /// Rounds towards minus infinity.\n-    #[inline]\n-    fn floor(self) -> f32 {\n-        return floorf(self);\n-\n-        // On MSVC LLVM will lower many math intrinsics to a call to the\n-        // corresponding function. On MSVC, however, many of these functions\n-        // aren't actually available as symbols to call, but rather they are all\n-        // `static inline` functions in header files. This means that from a C\n-        // perspective it's \"compatible\", but not so much from an ABI\n-        // perspective (which we're worried about).\n-        //\n-        // The inline header functions always just cast to a f64 and do their\n-        // operation, so we do that here as well, but only for MSVC targets.\n-        //\n-        // Note that there are many MSVC-specific float operations which\n-        // redirect to this comment, so `floorf` is just one case of a missing\n-        // function on MSVC, but there are many others elsewhere.\n-        #[cfg(target_env = \"msvc\")]\n-        fn floorf(f: f32) -> f32 { (f as f64).floor() as f32 }\n-        #[cfg(not(target_env = \"msvc\"))]\n-        fn floorf(f: f32) -> f32 { unsafe { intrinsics::floorf32(f) } }\n-    }\n-\n-    /// Rounds towards plus infinity.\n-    #[inline]\n-    fn ceil(self) -> f32 {\n-        return ceilf(self);\n-\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        fn ceilf(f: f32) -> f32 { (f as f64).ceil() as f32 }\n-        #[cfg(not(target_env = \"msvc\"))]\n-        fn ceilf(f: f32) -> f32 { unsafe { intrinsics::ceilf32(f) } }\n-    }\n-\n-    /// Rounds to nearest integer. Rounds half-way cases away from zero.\n-    #[inline]\n-    fn round(self) -> f32 {\n-        unsafe { intrinsics::roundf32(self) }\n-    }\n-\n-    /// Returns the integer part of the number (rounds towards zero).\n-    #[inline]\n-    fn trunc(self) -> f32 {\n-        unsafe { intrinsics::truncf32(self) }\n-    }\n-\n-    /// The fractional part of the number, satisfying:\n-    ///\n-    /// ```\n-    /// let x = 1.65f32;\n-    /// assert!(x == x.trunc() + x.fract())\n-    /// ```\n-    #[inline]\n-    fn fract(self) -> f32 { self - self.trunc() }\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[inline]\n@@ -308,14 +251,6 @@ impl Float for f32 {\n         self < 0.0 || (1.0 / self) == Float::neg_infinity()\n     }\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    #[inline]\n-    fn mul_add(self, a: f32, b: f32) -> f32 {\n-        unsafe { intrinsics::fmaf32(self, a, b) }\n-    }\n-\n     /// Returns the reciprocal (multiplicative inverse) of the number.\n     #[inline]\n     fn recip(self) -> f32 { 1.0 / self }\n@@ -325,81 +260,6 @@ impl Float for f32 {\n         unsafe { intrinsics::powif32(self, n) }\n     }\n \n-    #[inline]\n-    fn powf(self, n: f32) -> f32 {\n-        return powf(self, n);\n-\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        fn powf(f: f32, n: f32) -> f32 { (f as f64).powf(n as f64) as f32 }\n-        #[cfg(not(target_env = \"msvc\"))]\n-        fn powf(f: f32, n: f32) -> f32 { unsafe { intrinsics::powf32(f, n) } }\n-    }\n-\n-    #[inline]\n-    fn sqrt(self) -> f32 {\n-        if self < 0.0 {\n-            NAN\n-        } else {\n-            unsafe { intrinsics::sqrtf32(self) }\n-        }\n-    }\n-\n-    #[inline]\n-    fn rsqrt(self) -> f32 { self.sqrt().recip() }\n-\n-    /// Returns the exponential of the number.\n-    #[inline]\n-    fn exp(self) -> f32 {\n-        return expf(self);\n-\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        fn expf(f: f32) -> f32 { (f as f64).exp() as f32 }\n-        #[cfg(not(target_env = \"msvc\"))]\n-        fn expf(f: f32) -> f32 { unsafe { intrinsics::expf32(f) } }\n-    }\n-\n-    /// Returns 2 raised to the power of the number.\n-    #[inline]\n-    fn exp2(self) -> f32 {\n-        unsafe { intrinsics::exp2f32(self) }\n-    }\n-\n-    /// Returns the natural logarithm of the number.\n-    #[inline]\n-    fn ln(self) -> f32 {\n-        return logf(self);\n-\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        fn logf(f: f32) -> f32 { (f as f64).ln() as f32 }\n-        #[cfg(not(target_env = \"msvc\"))]\n-        fn logf(f: f32) -> f32 { unsafe { intrinsics::logf32(f) } }\n-    }\n-\n-    /// Returns the logarithm of the number with respect to an arbitrary base.\n-    #[inline]\n-    fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n-\n-    /// Returns the base 2 logarithm of the number.\n-    #[inline]\n-    fn log2(self) -> f32 {\n-        unsafe { intrinsics::log2f32(self) }\n-    }\n-\n-    /// Returns the base 10 logarithm of the number.\n-    #[inline]\n-    fn log10(self) -> f32 {\n-        return log10f(self);\n-\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        fn log10f(f: f32) -> f32 { (f as f64).log10() as f32 }\n-        #[cfg(not(target_env = \"msvc\"))]\n-        fn log10f(f: f32) -> f32 { unsafe { intrinsics::log10f32(f) } }\n-    }\n-\n     /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n     fn to_degrees(self) -> f32 { self * (180.0f32 / consts::PI) }"}, {"sha": "a057e5fe51a7d6c1003048dd6cbc3414c38ed424", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -216,39 +216,6 @@ impl Float for f64 {\n         (mantissa, exponent, sign)\n     }\n \n-    /// Rounds towards minus infinity.\n-    #[inline]\n-    fn floor(self) -> f64 {\n-        unsafe { intrinsics::floorf64(self) }\n-    }\n-\n-    /// Rounds towards plus infinity.\n-    #[inline]\n-    fn ceil(self) -> f64 {\n-        unsafe { intrinsics::ceilf64(self) }\n-    }\n-\n-    /// Rounds to nearest integer. Rounds half-way cases away from zero.\n-    #[inline]\n-    fn round(self) -> f64 {\n-        unsafe { intrinsics::roundf64(self) }\n-    }\n-\n-    /// Returns the integer part of the number (rounds towards zero).\n-    #[inline]\n-    fn trunc(self) -> f64 {\n-        unsafe { intrinsics::truncf64(self) }\n-    }\n-\n-    /// The fractional part of the number, satisfying:\n-    ///\n-    /// ```\n-    /// let x = 1.65f64;\n-    /// assert!(x == x.trunc() + x.fract())\n-    /// ```\n-    #[inline]\n-    fn fract(self) -> f64 { self - self.trunc() }\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[inline]\n@@ -284,74 +251,15 @@ impl Float for f64 {\n         self < 0.0 || (1.0 / self) == Float::neg_infinity()\n     }\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    #[inline]\n-    fn mul_add(self, a: f64, b: f64) -> f64 {\n-        unsafe { intrinsics::fmaf64(self, a, b) }\n-    }\n-\n     /// Returns the reciprocal (multiplicative inverse) of the number.\n     #[inline]\n     fn recip(self) -> f64 { 1.0 / self }\n \n-    #[inline]\n-    fn powf(self, n: f64) -> f64 {\n-        unsafe { intrinsics::powf64(self, n) }\n-    }\n-\n     #[inline]\n     fn powi(self, n: i32) -> f64 {\n         unsafe { intrinsics::powif64(self, n) }\n     }\n \n-    #[inline]\n-    fn sqrt(self) -> f64 {\n-        if self < 0.0 {\n-            NAN\n-        } else {\n-            unsafe { intrinsics::sqrtf64(self) }\n-        }\n-    }\n-\n-    #[inline]\n-    fn rsqrt(self) -> f64 { self.sqrt().recip() }\n-\n-    /// Returns the exponential of the number.\n-    #[inline]\n-    fn exp(self) -> f64 {\n-        unsafe { intrinsics::expf64(self) }\n-    }\n-\n-    /// Returns 2 raised to the power of the number.\n-    #[inline]\n-    fn exp2(self) -> f64 {\n-        unsafe { intrinsics::exp2f64(self) }\n-    }\n-\n-    /// Returns the natural logarithm of the number.\n-    #[inline]\n-    fn ln(self) -> f64 {\n-        unsafe { intrinsics::logf64(self) }\n-    }\n-\n-    /// Returns the logarithm of the number with respect to an arbitrary base.\n-    #[inline]\n-    fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n-\n-    /// Returns the base 2 logarithm of the number.\n-    #[inline]\n-    fn log2(self) -> f64 {\n-        unsafe { intrinsics::log2f64(self) }\n-    }\n-\n-    /// Returns the base 10 logarithm of the number.\n-    #[inline]\n-    fn log10(self) -> f64 {\n-        unsafe { intrinsics::log10f64(self) }\n-    }\n-\n     /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n     fn to_degrees(self) -> f64 { self * (180.0f64 / consts::PI) }"}, {"sha": "6265691bde9e9ff278c1d73aa50b76d02653b4ca", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -53,20 +53,15 @@ pub enum FullDecoded {\n \n /// A floating point type which can be `decode`d.\n pub trait DecodableFloat: Float + Copy {\n-    /// Returns `x * 2^exp`. Almost same to `std::{f32,f64}::ldexp`.\n-    /// This is used for testing.\n-    fn ldexpi(f: i64, exp: isize) -> Self;\n     /// The minimum positive normalized value.\n     fn min_pos_norm_value() -> Self;\n }\n \n impl DecodableFloat for f32 {\n-    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n     fn min_pos_norm_value() -> Self { f32::MIN_POSITIVE }\n }\n \n impl DecodableFloat for f64 {\n-    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n     fn min_pos_norm_value() -> Self { f64::MIN_POSITIVE }\n }\n "}, {"sha": "700523e49a2760273f3ce3ee05aa9ce4b93d62e7", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -132,7 +132,6 @@ functions.\n \n use prelude::v1::*;\n use i16;\n-use num::Float;\n use slice::bytes;\n pub use self::decoder::{decode, DecodableFloat, FullDecoded, Decoded};\n "}, {"sha": "ab610f28e9eca69cc8b7ff0f7bdc8508ccce5e7d", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -17,7 +17,6 @@ Almost direct (but slightly optimized) Rust translation of Figure 3 of [1].\n \n use prelude::v1::*;\n \n-use num::Float;\n use cmp::Ordering;\n \n use num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};"}, {"sha": "b0822ca76c76b8b2641fc80efb74bb23745e825b", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -18,8 +18,6 @@ Rust adaptation of Grisu3 algorithm described in [1]. It uses about\n \n use prelude::v1::*;\n \n-use num::Float;\n-\n use num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};\n \n /// A custom 64-bit floating point type, representing `f * 2^e`."}, {"sha": "23432a2044c456abf4c47204b9e016919bf922c0", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -1297,18 +1297,6 @@ pub trait Float: Sized {\n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Return the largest integer less than or equal to a number.\n-    fn floor(self) -> Self;\n-    /// Return the smallest integer greater than or equal to a number.\n-    fn ceil(self) -> Self;\n-    /// Return the nearest integer to a number. Round half-way cases away from\n-    /// `0.0`.\n-    fn round(self) -> Self;\n-    /// Return the integer part of a number.\n-    fn trunc(self) -> Self;\n-    /// Return the fractional part of a number.\n-    fn fract(self) -> Self;\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     fn abs(self) -> Self;\n@@ -1325,39 +1313,13 @@ pub trait Float: Sized {\n     /// `Float::neg_infinity()`.\n     fn is_negative(self) -> bool;\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    fn mul_add(self, a: Self, b: Self) -> Self;\n     /// Take the reciprocal (inverse) of a number, `1/x`.\n     fn recip(self) -> Self;\n \n     /// Raise a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n     fn powi(self, n: i32) -> Self;\n-    /// Raise a number to a floating point power.\n-    fn powf(self, n: Self) -> Self;\n-\n-    /// Take the square root of a number.\n-    ///\n-    /// Returns NaN if `self` is a negative number.\n-    fn sqrt(self) -> Self;\n-    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    fn rsqrt(self) -> Self;\n-\n-    /// Returns `e^(self)`, (the exponential function).\n-    fn exp(self) -> Self;\n-    /// Returns 2 raised to the power of the number, `2^(self)`.\n-    fn exp2(self) -> Self;\n-    /// Returns the natural logarithm of the number.\n-    fn ln(self) -> Self;\n-    /// Returns the logarithm of the number with respect to an arbitrary base.\n-    fn log(self, base: Self) -> Self;\n-    /// Returns the base 2 logarithm of the number.\n-    fn log2(self) -> Self;\n-    /// Returns the base 10 logarithm of the number.\n-    fn log10(self) -> Self;\n \n     /// Convert radians to degrees.\n     fn to_degrees(self) -> Self;"}, {"sha": "7c386c6c33e43c60b536b73310ce994b115161e9", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -445,7 +445,9 @@ rem_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n impl Rem for f32 {\n     type Output = f32;\n \n-    // see notes in `core::f32::Float::floor`\n+    // The builtin f32 rem operator is broken when targeting\n+    // MSVC; see comment in std::f32::floor.\n+    // FIXME: See also #27859.\n     #[inline]\n     #[cfg(target_env = \"msvc\")]\n     fn rem(self, other: f32) -> f32 {"}, {"sha": "8ae33a4420207038d5af70ba8818e56903d4f7f3", "filename": "src/libcoretest/num/flt2dec/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -164,12 +164,26 @@ fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16\n     }\n }\n \n+trait TestableFloat : DecodableFloat + fmt::Display {\n+    /// Returns `x * 2^exp`. Almost same to `std::{f32,f64}::ldexp`.\n+    /// This is used for testing.\n+    fn ldexpi(f: i64, exp: isize) -> Self;\n+}\n+\n+impl TestableFloat for f32 {\n+    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n+}\n+\n+impl TestableFloat for f64 {\n+    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n+}\n+\n fn check_exact_one<F, T>(mut f: F, x: i64, e: isize, tstr: &str, expected: &[u8], expectedk: i16)\n-        where T: DecodableFloat + fmt::Display,\n+        where T: TestableFloat,\n               F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n     // use a large enough buffer\n     let mut buf = [b'_'; 1024];\n-    let v: T = DecodableFloat::ldexpi(x, e);\n+    let v: T = TestableFloat::ldexpi(x, e);\n     let decoded = decode_finite(v);\n \n     try_exact!(f(&decoded) => &mut buf, &expected, expectedk;"}, {"sha": "ce72fa08a73de728ed3193a419d3556bf0fb1dcb", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -10,7 +10,7 @@\n \n //! The exponential distribution.\n \n-use core::num::Float;\n+use FloatMath;\n \n use {Rng, Rand};\n use distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};"}, {"sha": "2a5d4bbd2ec9db6818df0f201771fa148167cd8e", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -13,7 +13,7 @@\n use self::GammaRepr::*;\n use self::ChiSquaredRepr::*;\n \n-use core::num::Float;\n+use FloatMath;\n \n use {Rng, Open01};\n use super::normal::StandardNormal;"}, {"sha": "cc70a695c8d594c1ab85cac67006c7a1ad77cd5c", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -10,7 +10,7 @@\n \n //! The normal and derived distributions.\n \n-use core::num::Float;\n+use FloatMath;\n \n use {Rng, Rand, Open01};\n use distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};"}, {"sha": "c3dace513112fa48de18e8bcb900a85a4fce4472", "filename": "src/librand/lib.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -30,6 +30,7 @@\n             reason = \"use `rand` from crates.io\",\n             issue = \"27703\")]\n #![feature(core_float)]\n+#![feature(core_intrinsics)]\n #![feature(core_slice_ext)]\n #![feature(no_std)]\n #![feature(num_bits_bytes)]\n@@ -43,6 +44,8 @@\n #[cfg(test)] #[macro_use] extern crate std;\n #[cfg(test)] #[macro_use] extern crate log;\n \n+use core::f64;\n+use core::intrinsics;\n use core::marker::PhantomData;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n@@ -60,6 +63,43 @@ pub mod chacha;\n pub mod reseeding;\n mod rand_impls;\n \n+// Temporary trait to implement a few floating-point routines\n+// needed by librand; this is necessary because librand doesn't\n+// depend on libstd.  This will go away when librand is integrated\n+// into libstd.\n+trait FloatMath : Sized {\n+    fn exp(self) -> Self;\n+    fn ln(self) -> Self;\n+    fn sqrt(self) -> Self;\n+    fn powf(self, n: Self) -> Self;\n+}\n+\n+impl FloatMath for f64 {\n+    #[inline]\n+    fn exp(self) -> f64 {\n+        unsafe { intrinsics::expf64(self) }\n+    }\n+\n+    #[inline]\n+    fn ln(self) -> f64 {\n+        unsafe { intrinsics::logf64(self) }\n+    }\n+\n+    #[inline]\n+    fn powf(self, n: f64) -> f64 {\n+        unsafe { intrinsics::powf64(self, n) }\n+    }\n+\n+    #[inline]\n+    fn sqrt(self) -> f64 {\n+        if self < 0.0 {\n+            f64::NAN\n+        } else {\n+            unsafe { intrinsics::sqrtf64(self) }\n+        }\n+    }\n+}\n+\n /// A type that can be randomly generated using an `Rng`.\n #[doc(hidden)]\n pub trait Rand : Sized {"}, {"sha": "62f6cfcb36fb7bc10e52b45a08bf23205cd4db07", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 92, "deletions": 17, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -16,7 +16,6 @@\n #![allow(missing_docs)]\n \n use core::num;\n-#[cfg(not(target_env = \"msvc\"))]\n use intrinsics;\n use libc::c_int;\n use num::{FpCategory, ParseFloatError};\n@@ -40,11 +39,11 @@ mod cmath {\n         pub fn fmaxf(a: c_float, b: c_float) -> c_float;\n         pub fn fminf(a: c_float, b: c_float) -> c_float;\n         pub fn fmodf(a: c_float, b: c_float) -> c_float;\n-        pub fn nextafterf(x: c_float, y: c_float) -> c_float;\n+        pub fn ilogbf(n: c_float) -> c_int;\n         pub fn logbf(n: c_float) -> c_float;\n         pub fn log1pf(n: c_float) -> c_float;\n-        pub fn ilogbf(n: c_float) -> c_int;\n         pub fn modff(n: c_float, iptr: &mut c_float) -> c_float;\n+        pub fn nextafterf(x: c_float, y: c_float) -> c_float;\n         pub fn tgammaf(n: c_float) -> c_float;\n \n         #[cfg_attr(all(windows, target_env = \"msvc\"), link_name = \"__lgammaf_r\")]\n@@ -270,7 +269,27 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn floor(self) -> f32 { num::Float::floor(self) }\n+    pub fn floor(self) -> f32 {\n+        return floorf(self);\n+\n+        // On MSVC LLVM will lower many math intrinsics to a call to the\n+        // corresponding function. On MSVC, however, many of these functions\n+        // aren't actually available as symbols to call, but rather they are all\n+        // `static inline` functions in header files. This means that from a C\n+        // perspective it's \"compatible\", but not so much from an ABI\n+        // perspective (which we're worried about).\n+        //\n+        // The inline header functions always just cast to a f64 and do their\n+        // operation, so we do that here as well, but only for MSVC targets.\n+        //\n+        // Note that there are many MSVC-specific float operations which\n+        // redirect to this comment, so `floorf` is just one case of a missing\n+        // function on MSVC, but there are many others elsewhere.\n+        #[cfg(target_env = \"msvc\")]\n+        fn floorf(f: f32) -> f32 { (f as f64).floor() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn floorf(f: f32) -> f32 { unsafe { intrinsics::floorf32(f) } }\n+    }\n \n     /// Returns the smallest integer greater than or equal to a number.\n     ///\n@@ -283,7 +302,15 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn ceil(self) -> f32 { num::Float::ceil(self) }\n+    pub fn ceil(self) -> f32 {\n+        return ceilf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn ceilf(f: f32) -> f32 { (f as f64).ceil() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn ceilf(f: f32) -> f32 { unsafe { intrinsics::ceilf32(f) } }\n+    }\n \n     /// Returns the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n@@ -297,7 +324,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn round(self) -> f32 { num::Float::round(self) }\n+    pub fn round(self) -> f32 {\n+        unsafe { intrinsics::roundf32(self) }\n+    }\n \n     /// Returns the integer part of a number.\n     ///\n@@ -310,7 +339,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn trunc(self) -> f32 { num::Float::trunc(self) }\n+    pub fn trunc(self) -> f32 {\n+        unsafe { intrinsics::truncf32(self) }\n+    }\n \n     /// Returns the fractional part of a number.\n     ///\n@@ -327,7 +358,7 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn fract(self) -> f32 { num::Float::fract(self) }\n+    pub fn fract(self) -> f32 { self - self.trunc() }\n \n     /// Computes the absolute value of `self`. Returns `NAN` if the\n     /// number is `NAN`.\n@@ -426,7 +457,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn mul_add(self, a: f32, b: f32) -> f32 { num::Float::mul_add(self, a, b) }\n+    pub fn mul_add(self, a: f32, b: f32) -> f32 {\n+        unsafe { intrinsics::fmaf32(self, a, b) }\n+    }\n \n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n@@ -470,7 +503,15 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn powf(self, n: f32) -> f32 { num::Float::powf(self, n) }\n+    pub fn powf(self, n: f32) -> f32 {\n+        return powf(self, n);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn powf(f: f32, n: f32) -> f32 { (f as f64).powf(n as f64) as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn powf(f: f32, n: f32) -> f32 { unsafe { intrinsics::powf32(f, n) } }\n+    }\n \n     /// Takes the square root of a number.\n     ///\n@@ -489,7 +530,13 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn sqrt(self) -> f32 { num::Float::sqrt(self) }\n+    pub fn sqrt(self) -> f32 {\n+        if self < 0.0 {\n+            NAN\n+        } else {\n+            unsafe { intrinsics::sqrtf32(self) }\n+        }\n+    }\n \n     /// Returns `e^(self)`, (the exponential function).\n     ///\n@@ -507,7 +554,15 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn exp(self) -> f32 { num::Float::exp(self) }\n+    pub fn exp(self) -> f32 {\n+        return expf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn expf(f: f32) -> f32 { (f as f64).exp() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn expf(f: f32) -> f32 { unsafe { intrinsics::expf32(f) } }\n+    }\n \n     /// Returns `2^(self)`.\n     ///\n@@ -523,7 +578,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn exp2(self) -> f32 { num::Float::exp2(self) }\n+    pub fn exp2(self) -> f32 {\n+        unsafe { intrinsics::exp2f32(self) }\n+    }\n \n     /// Returns the natural logarithm of the number.\n     ///\n@@ -541,7 +598,15 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn ln(self) -> f32 { num::Float::ln(self) }\n+    pub fn ln(self) -> f32 {\n+        return logf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn logf(f: f32) -> f32 { (f as f64).ln() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn logf(f: f32) -> f32 { unsafe { intrinsics::logf32(f) } }\n+    }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base.\n     ///\n@@ -562,7 +627,7 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log(self, base: f32) -> f32 { num::Float::log(self, base) }\n+    pub fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number.\n     ///\n@@ -578,7 +643,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log2(self) -> f32 { num::Float::log2(self) }\n+    pub fn log2(self) -> f32 {\n+        unsafe { intrinsics::log2f32(self) }\n+    }\n \n     /// Returns the base 10 logarithm of the number.\n     ///\n@@ -594,7 +661,15 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log10(self) -> f32 { num::Float::log10(self) }\n+    pub fn log10(self) -> f32 {\n+        return log10f(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn log10f(f: f32) -> f32 { (f as f64).log10() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn log10f(f: f32) -> f32 { unsafe { intrinsics::log10f32(f) } }\n+    }\n \n     /// Converts radians to degrees.\n     ///"}, {"sha": "14c540e819e96e373a3a3919c74779898be3c3ab", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ffc0e38f1a00925935dce859262cb4e4d6f55/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=4c0ffc0e38f1a00925935dce859262cb4e4d6f55", "patch": "@@ -45,12 +45,12 @@ mod cmath {\n         pub fn fmax(a: c_double, b: c_double) -> c_double;\n         pub fn fmin(a: c_double, b: c_double) -> c_double;\n         pub fn fmod(a: c_double, b: c_double) -> c_double;\n-        pub fn nextafter(x: c_double, y: c_double) -> c_double;\n         pub fn frexp(n: c_double, value: &mut c_int) -> c_double;\n+        pub fn ilogb(n: c_double) -> c_int;\n         pub fn ldexp(x: c_double, n: c_int) -> c_double;\n         pub fn logb(n: c_double) -> c_double;\n         pub fn log1p(n: c_double) -> c_double;\n-        pub fn ilogb(n: c_double) -> c_int;\n+        pub fn nextafter(x: c_double, y: c_double) -> c_double;\n         pub fn modf(n: c_double, iptr: &mut c_double) -> c_double;\n         pub fn sinh(n: c_double) -> c_double;\n         pub fn tan(n: c_double) -> c_double;\n@@ -222,7 +222,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn floor(self) -> f64 { num::Float::floor(self) }\n+    pub fn floor(self) -> f64 {\n+        unsafe { intrinsics::floorf64(self) }\n+    }\n \n     /// Returns the smallest integer greater than or equal to a number.\n     ///\n@@ -235,7 +237,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn ceil(self) -> f64 { num::Float::ceil(self) }\n+    pub fn ceil(self) -> f64 {\n+        unsafe { intrinsics::ceilf64(self) }\n+    }\n \n     /// Returns the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n@@ -249,7 +253,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn round(self) -> f64 { num::Float::round(self) }\n+    pub fn round(self) -> f64 {\n+        unsafe { intrinsics::roundf64(self) }\n+    }\n \n     /// Returns the integer part of a number.\n     ///\n@@ -262,7 +268,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn trunc(self) -> f64 { num::Float::trunc(self) }\n+    pub fn trunc(self) -> f64 {\n+        unsafe { intrinsics::truncf64(self) }\n+    }\n \n     /// Returns the fractional part of a number.\n     ///\n@@ -277,7 +285,7 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn fract(self) -> f64 { num::Float::fract(self) }\n+    pub fn fract(self) -> f64 { self - self.trunc() }\n \n     /// Computes the absolute value of `self`. Returns `NAN` if the\n     /// number is `NAN`.\n@@ -386,7 +394,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn mul_add(self, a: f64, b: f64) -> f64 { num::Float::mul_add(self, a, b) }\n+    pub fn mul_add(self, a: f64, b: f64) -> f64 {\n+        unsafe { intrinsics::fmaf64(self, a, b) }\n+    }\n \n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n@@ -424,7 +434,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn powf(self, n: f64) -> f64 { num::Float::powf(self, n) }\n+    pub fn powf(self, n: f64) -> f64 {\n+        unsafe { intrinsics::powf64(self, n) }\n+    }\n \n     /// Takes the square root of a number.\n     ///\n@@ -441,7 +453,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn sqrt(self) -> f64 { num::Float::sqrt(self) }\n+    pub fn sqrt(self) -> f64 {\n+        unsafe { intrinsics::sqrtf64(self) }\n+    }\n \n     /// Returns `e^(self)`, (the exponential function).\n     ///\n@@ -457,7 +471,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn exp(self) -> f64 { num::Float::exp(self) }\n+    pub fn exp(self) -> f64 {\n+        unsafe { intrinsics::expf64(self) }\n+    }\n \n     /// Returns `2^(self)`.\n     ///\n@@ -471,7 +487,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn exp2(self) -> f64 { num::Float::exp2(self) }\n+    pub fn exp2(self) -> f64 {\n+        unsafe { intrinsics::exp2f64(self) }\n+    }\n \n     /// Returns the natural logarithm of the number.\n     ///\n@@ -487,7 +505,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn ln(self) -> f64 { num::Float::ln(self) }\n+    pub fn ln(self) -> f64 {\n+        unsafe { intrinsics::logf64(self) }\n+    }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base.\n     ///\n@@ -506,7 +526,7 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log(self, base: f64) -> f64 { num::Float::log(self, base) }\n+    pub fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number.\n     ///\n@@ -520,7 +540,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log2(self) -> f64 { num::Float::log2(self) }\n+    pub fn log2(self) -> f64 {\n+        unsafe { intrinsics::log2f64(self) }\n+    }\n \n     /// Returns the base 10 logarithm of the number.\n     ///\n@@ -534,7 +556,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log10(self) -> f64 { num::Float::log10(self) }\n+    pub fn log10(self) -> f64 {\n+        unsafe { intrinsics::log10f64(self) }\n+    }\n \n     /// Converts radians to degrees.\n     ///"}]}