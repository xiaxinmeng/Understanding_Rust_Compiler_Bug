{"sha": "97dd53d5effb08d61bd737557cce8ce0e3a8567f", "node_id": "C_kwDOAAsO6NoAKDk3ZGQ1M2Q1ZWZmYjA4ZDYxYmQ3Mzc1NTdjY2U4Y2UwZTNhODU2N2Y", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-04T19:26:02Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-04T19:26:02Z"}, "message": "remove ancient tex files", "tree": {"sha": "c12186169952e9c817d6740658f9d9e3bca06f08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c12186169952e9c817d6740658f9d9e3bca06f08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97dd53d5effb08d61bd737557cce8ce0e3a8567f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97dd53d5effb08d61bd737557cce8ce0e3a8567f", "html_url": "https://github.com/rust-lang/rust/commit/97dd53d5effb08d61bd737557cce8ce0e3a8567f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97dd53d5effb08d61bd737557cce8ce0e3a8567f/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "709e29a16749333c29ba6311f79037df837d1426", "url": "https://api.github.com/repos/rust-lang/rust/commits/709e29a16749333c29ba6311f79037df837d1426", "html_url": "https://github.com/rust-lang/rust/commit/709e29a16749333c29ba6311f79037df837d1426"}], "stats": {"total": 1131, "additions": 0, "deletions": 1131}, "files": [{"sha": "23aa1a481b3ebc8eb1358f31a6e49f08090bc5d9", "filename": "tex/final-presentation/latexmkrc", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/709e29a16749333c29ba6311f79037df837d1426/tex%2Ffinal-presentation%2Flatexmkrc", "raw_url": "https://github.com/rust-lang/rust/raw/709e29a16749333c29ba6311f79037df837d1426/tex%2Ffinal-presentation%2Flatexmkrc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Ffinal-presentation%2Flatexmkrc?ref=709e29a16749333c29ba6311f79037df837d1426", "patch": "@@ -1,12 +0,0 @@\n-# vim: ft=perl\n-\n-$pdf_mode = 1;\n-$pdflatex = 'lualatex --shell-escape %O %S';\n-$out_dir = 'out';\n-\n-# This improves latexmk's detection of source files and generated files.\n-$recorder = 1;\n-\n-# Ignore always-regenerated *.pyg files from the minted package when considering\n-# whether to run pdflatex again.\n-$hash_calc_ignore_pattern{'pyg'} = '.*';"}, {"sha": "38484c670e01f3f355672d6c95f79f035a963a44", "filename": "tex/final-presentation/rust-logo-512x512.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/709e29a16749333c29ba6311f79037df837d1426/tex%2Ffinal-presentation%2Frust-logo-512x512.png", "raw_url": "https://github.com/rust-lang/rust/raw/709e29a16749333c29ba6311f79037df837d1426/tex%2Ffinal-presentation%2Frust-logo-512x512.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Ffinal-presentation%2Frust-logo-512x512.png?ref=709e29a16749333c29ba6311f79037df837d1426"}, {"sha": "c5e1f51ba19c60f675e25dcb0cf3252db4585c3e", "filename": "tex/final-presentation/slides.tex", "status": "removed", "additions": 0, "deletions": 444, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/709e29a16749333c29ba6311f79037df837d1426/tex%2Ffinal-presentation%2Fslides.tex", "raw_url": "https://github.com/rust-lang/rust/raw/709e29a16749333c29ba6311f79037df837d1426/tex%2Ffinal-presentation%2Fslides.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Ffinal-presentation%2Fslides.tex?ref=709e29a16749333c29ba6311f79037df837d1426", "patch": "@@ -1,444 +0,0 @@\n-\\documentclass{beamer}\n-\\usecolortheme{beaver}\n-\\beamertemplatenavigationsymbolsempty\n-\n-% Fonts\n-\\usepackage{fontspec}\n-\\setmainfont{Source Serif Pro}[Ligatures=TeX]\n-\\setsansfont{Source Sans Pro}[Ligatures=TeX]\n-\\setmonofont{Source Code Pro}[\n-  BoldFont={* Medium},\n-  BoldItalicFont={* Medium Italic},\n-]\n-\n-\\usepackage[outputdir=out]{minted}\n-\\usepackage{tikz}\n-\\usetikzlibrary{positioning, fit}\n-\n-\\tikzset{\n-  invisible/.style={opacity=0,text opacity=0},\n-  highlight/.style={color=red},\n-  intro/.code args={<#1>}{%\n-    \\only<#1>{\\pgfkeysalso{highlight}}\n-    \\alt<#1->{}{\\pgfkeysalso{invisible}}\n-  },\n-}\n-\n-\\title{Miri}\n-\\subtitle{An interpreter for Rust's mid-level intermediate representation}\n-\\author{\n-  Scott Olson\n-  \\texorpdfstring{\\\\ \\scriptsize{Supervisor: Christopher Dutchyn}}{}\n-}\n-\\institute{\n-  CMPT 400 \\\\\n-  University of Saskatchewan\n-}\n-\\date{}\n-\\titlegraphic{\n-  \\includegraphics[width=64px,height=64px]{rust-logo-512x512.png} \\\\\n-  \\scriptsize{\\url{https://www.rust-lang.org}}\n-}\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-% Intro slides\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\begin{document}\n-\n-\\maketitle\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{What is Rust? \\small{[review]}}\n-\n-  According to the website\\dots\n-\n-  \\begin{quote}\n-    \\textbf{Rust} is a systems programming language that runs blazingly fast,\n-    prevents nearly all segfaults, and guarantees thread safety.\n-  \\end{quote}\n-\n-  It's a new programming language from Mozilla, and it looks like this:\n-\n-  \\begin{minted}[\n-    autogobble,\n-    fontsize=\\footnotesize,\n-    mathescape,\n-    xleftmargin=.3in,\n-  ]{rust}\n-    fn factorial(n: u64) -> u64 {\n-        (1..n).fold(1, |a, b| a * b)\n-    }\n-\n-    fn main() {\n-        for x in 1..6 {\n-            println!(\"{}\", factorial(x));\n-        }\n-        // $\\Rightarrow$ 1\n-        // $\\Rightarrow$ 1\n-        // $\\Rightarrow$ 2\n-        // $\\Rightarrow$ 6\n-        // $\\Rightarrow$ 24\n-    }\n-  \\end{minted}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\frametitle{How does Rust compile code? \\onslide<-6>{\\small{[review]}}}\n-\n-  \\begin{center}\n-    \\begin{tikzpicture}[x=4cm, y=3.5cm, auto, rounded corners]\n-      \\tikzstyle{basic-stage}=[rectangle, draw, thick, align=center]\n-      \\tikzstyle{stage}=[basic-stage, font=\\tiny]\n-      \\tikzstyle{pass}=[thick, -stealth]\n-      \\tikzstyle{pass-label}=[font=\\footnotesize]\n-\n-      \\node[basic-stage] (src) at (0,0) {Source\\\\Code};\n-      \\node[basic-stage] (mach) at (2,-1) {Machine\\\\Code};\n-\n-      \\draw<1>[pass, out=0, in=180]\n-        (src.east) to node[font=\\Huge] {?} (mach.west);\n-\n-      \\node[stage, intro=<2>] (ast) at (1,0)\n-        {\\normalsize{AST} \\\\ Abstract Syntax Tree};\n-      \\draw[pass, intro=<2>]\n-        (src) -- node[pass-label] {Parse} (ast);\n-\n-      \\node[stage, intro=<3>] (hir) at (2,0)\n-        {\\normalsize{HIR} \\\\ High-level Intermediate\\\\Representation};\n-      \\draw[pass, intro=<3>]\n-        (ast) -- node[pass-label] {Simplify} (hir);\n-\n-      \\node[stage, intro=<4>] (mir) at (0,-1)\n-        {\\normalsize{MIR} \\\\ Mid-level Intermediate\\\\Representation};\n-      \\path (hir.south) -- coordinate (middle) (mir.north);\n-      \\draw[pass, intro=<4>]\n-        (hir.south) |- (middle) -| (mir.north);\n-      \\node[pass-label, above, intro=<4>] at (middle) {Lower};\n-\n-      \\node[stage, intro=<5>] (llvm) at (1,-1)\n-        {\\normalsize{LLVM IR} \\\\ Low-level Intermediate\\\\Representation};\n-      \\draw[pass, intro=<5>]\n-        (mir) -- node[pass-label] {Translate} (llvm);\n-\n-      \\draw<6->[pass, intro=<6>]\n-        (llvm) -- node[pass-label] {Magic} (mach);\n-\n-      \\node[stage, intro=<7>] (exec) at (1,-1.75)\n-        {\\normalsize{Execution}};\n-      \\draw[pass, intro=<7>]\n-        (mach) -- node[pass-label] {CPU} (exec);\n-\n-      \\draw[pass, intro=<8>]\n-        (mir) -- node[pass-label] {Miri} (exec);\n-    \\end{tikzpicture}\n-  \\end{center}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\frametitle{Why build Miri?}\n-  \\begin{itemize}\n-    \\item For fun and learning.\n-\n-    \\item I originally planned to use it for testing the compiler and execution\n-      of unsafe code, but shifted my goals along the way. \\pause\n-\n-    \\item Now it serves as an experimental implementation of the upcoming\n-      compile-time function evaluation feature in Rust. \\pause\n-\n-      \\begin{itemize}\n-        \\item Similar to C++14's \\mintinline{cpp}{constexpr} feature.\n-\n-        \\item You can do complicated calculations at compile time and compile\n-          their \\emph{results} into the executable. \\pause\n-\n-        \\item For example, you can compute a ``perfect hash function'' for a\n-          statically-known map at compile-time and have guaranteed no-collision\n-          lookup at runtime. \\pause\n-\n-        \\item Miri actually supports far more of Rust than C++14's\n-          \\mintinline{cpp}{constexpr} does of C++ --- even heap allocation and\n-          unsafe code.\n-      \\end{itemize}\n-  \\end{itemize}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\frametitle{How was it built?}\n-\n-  At first I wrote a naive version with a number of downsides:\n-\n-  \\begin{itemize}\n-    \\item represented values in a traditional dynamic language format, where\n-      every value was the same size.\n-\n-    \\item didn't work well for aggregates (structs, enums, arrays, etc.).\n-\n-    \\item made unsafe programming tricks that make assumptions about low-level\n-      value layout essentially impossible.\n-  \\end{itemize}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\frametitle{How was it built?}\n-  \\begin{itemize}\n-    \\item Later, a Rust compiler team member proposed a ``Rust abstract\n-      machine'' with specialized value layout which solved my previous problems.\n-      \\pause\n-\n-    \\item His proposal was intended for a compile-time function evaluator in the\n-      Rust compiler, so I effectively implemented an experimental version of\n-      that. \\pause\n-\n-    \\item After this point, making Miri work well was primarily a software\n-      engineering problem.\n-  \\end{itemize}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\frametitle{Data layout}\n-  \\begin{itemize}\n-    \\item Memory in Miri is literally a HashMap from ``allocation IDs'' to\n-      ``abstract allocations''.\n-\n-    \\item Allocations are represented by: \\pause\n-      \\begin{enumerate}\n-        \\item An array of \\textbf{raw bytes} with a size based on the type of\n-          the value \\pause\n-        \\item A set of \\textbf{relocations} --- pointers into other abstract\n-          allocations \\pause\n-        \\item A mask determining which bytes are \\textbf{undefined}\n-      \\end{enumerate}\n-  \\end{itemize}\n-\\end{frame}\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{\\texttt{square} example}\n-  \\begin{center}\n-    \\begin{minted}[autogobble,fontsize=\\scriptsize]{rust}\n-      // Rust\n-      fn square(n: u64) -> u64 {\n-          n * n\n-      }\n-\n-      // Generated MIR\n-      fn square(arg0: u64) -> u64 {\n-          let var0: u64; // n           // On function entry, Miri creates\n-                                        // virtual allocations for all the\n-                                        // arguments, variables, and\n-                                        // temporaries.\n-\n-          bb0: {\n-              var0 = arg0;              // Copy the argument into `n`.\n-              return = Mul(var0, var0); // Multiply `n` with itself.\n-              goto -> bb1;              // Jump to basic block `bb1`.\n-          }\n-\n-          bb1: {\n-              return;                   // Return from the current fn.\n-          }\n-      }\n-    \\end{minted}\n-  \\end{center}\n-\\end{frame}\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{\\texttt{sum} example}\n-  \\begin{center}\n-    \\begin{minted}[autogobble,fontsize=\\tiny]{rust}\n-      // Rust\n-      fn sum() -> u64 {\n-          let mut sum = 0; let mut i = 0;\n-          while i < 10 { sum += i; i += 1; }\n-          sum\n-      }\n-\n-      // Generated MIR\n-      fn sum() -> u64 {\n-          let mut var0: u64; // sum\n-          let mut var1: u64; // i\n-          let mut tmp0: bool;\n-\n-          bb0: {\n-              // sum = 0; i = 0;\n-              var0 = const 0u64; var1 = const 0u64; goto -> bb1;\n-          }\n-          bb1: {\n-              // if i < 10 { goto bb2; } else { goto bb3; }\n-              tmp0 = Lt(var1, const 10u64);\n-              if(tmp0) -> [true: bb2, false: bb3];\n-          }\n-          bb2: {\n-              var0 = Add(var0, var1);       // sum = sum + i;\n-              var1 = Add(var1, const 1u64); // i = i + 1;\n-              goto -> bb1;\n-          }\n-          bb3: {\n-              return = var0; goto -> bb4;\n-          }\n-          bb4: { return; }\n-      }\n-    \\end{minted}\n-  \\end{center}\n-\\end{frame}\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{Heap allocations!}\n-  \\begin{minted}[autogobble,fontsize=\\scriptsize]{rust}\n-    fn make_vec() -> Vec<u8> {\n-        // Empty array with space for 4 bytes - allocated on the heap!\n-        let mut vec = Vec::with_capacity(4);\n-        // Initialize the first two slots.\n-        vec.push(1);\n-        vec.push(2);\n-        vec\n-    }\n-\n-    // For reference:\n-    //   struct Vec<T> { capacity: usize, data: *mut T, length: usize }\n-\n-    // Resulting allocations (on 32-bit little-endian architectures):\n-    //   Region A:\n-    //     04 00 00 00  00 00 00 00  02 00 00 00\n-    //                  \u2514\u2500\u2500\u2500(B)\u2500\u2500\u2500\u2518\n-    //\n-    //   Region B:\n-    //     01 02 __ __ (underscores denote undefined bytes)\n-  \\end{minted}\n-\n-  \\footnotesize{Evaluating the above involves a number of compiler built-ins,\n-  ``unsafe'' code blocks, and more inside the standard library,\n-  but Miri handles it all.}\n-\\end{frame}\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{Unsafe code!}\n-  \\begin{minted}[autogobble,fontsize=\\scriptsize]{rust}\n-    fn out_of_bounds() -> u8 {\n-        let mut vec = vec![1, 2]\n-        unsafe { *vec.get_unchecked(5) }\n-    }\n-\n-    // test.rs:3: error: pointer offset outside bounds of allocation\n-    // test.rs:3:     unsafe { *vec.get_unchecked(5) }\n-    //                         ^~~~~~~~~~~~~~~~~~~~~\n-\n-    fn undefined_bytes() -> u8 {\n-        let mut vec = Vec::with_capacity(10);\n-        unsafe { *vec.get_unchecked(5) }\n-    }\n-\n-    // test.rs:3: error: attempted to read undefined bytes\n-    // test.rs:3:     unsafe { *vec.get_unchecked(5) }\n-    //                         ^~~~~~~~~~~~~~~~~~~~~\n-  \\end{minted}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\frametitle{What can't Miri do?}\n-  \\begin{itemize}\n-    \\item Miri can't do all the stuff I didn't implement yet. :)\n-      \\begin{itemize}\n-        \\item non-trivial casts\n-        \\item function pointers\n-        \\item calling destructors and freeing memory\n-        \\item taking target architecture endianess and alignment information\n-          into account when computing data layout\n-        \\item handling all constants properly (but, well, Miri might be\n-          replacing the old constants system)\n-      \\end{itemize}\n-      \\pause\n-\n-    \\item Miri can't do foreign function calls (e.g. calling functions defined\n-      in C or C++), but there is a reasonable way it could be done with libffi.\n-      \\begin{itemize}\n-        \\item On the other hand, for constant evaluation in the compiler, you\n-          want the evaluator to be deterministic and safe, so FFI calls might be\n-          banned anyway.\n-      \\end{itemize}\n-      \\pause\n-\n-    \\item Without quite some effort, Miri will probably never handle inline\n-      assembly...\n-  \\end{itemize}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\begin{center}\n-    \\LARGE{Questions?}\n-  \\end{center}\n-\\end{frame}\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-% Extra slides\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{\\texttt{varN} vs. \\texttt{argN}}\n-  \\begin{center}\n-    \\begin{minted}[autogobble,fontsize=\\scriptsize]{rust}\n-      // Rust\n-      type Pair = (u64, u64);\n-      fn swap((a, b): Pair) -> Pair {\n-          (b, a)\n-      }\n-\n-      // Generated MIR\n-      fn swap(arg0: (u64, u64)) -> (u64, u64) {\n-          let var0: u64; // a\n-          let var1: u64; // b\n-\n-          bb0: {\n-              var0 = arg0.0;         // get the 1st part of the pair\n-              var1 = arg0.1;         // get the 2nd part of the pair\n-              return = (var1, var0); // build a new pair in the result\n-              goto -> bb1;\n-          }\n-\n-          bb1: {\n-              return;\n-          }\n-      }\n-    \\end{minted}\n-  \\end{center}\n-\\end{frame}\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{\\texttt{factorial} example}\n-  \\begin{center}\n-    \\begin{minted}[autogobble,fontsize=\\tiny]{rust}\n-      // Rust\n-      fn factorial(n: u64) -> u64 {\n-          (1..n).fold(1, |a, b| a * b)\n-      }\n-\n-      // Generated MIR\n-      fn factorial(arg0: u64) -> u64 {\n-          let var0: u64; // n\n-          let mut tmp0: Range<u64>; // Miri calculates sizes for generics like Range<u64>.\n-          let mut tmp1: [closure];\n-\n-          bb0: {\n-              var0 = arg0;\n-\n-              // tmp0 = 1..n\n-              tmp0 = Range<u64> { start: const 1u64, end: var0 };\n-\n-              // tmp1 = |a, b| a * b\n-              tmp1 = [closure];\n-\n-              // This loads the MIR for the `fold` fn from the standard library.\n-              // In general, MIR for any function from any library can be loaded.\n-              // return tmp0.fold(1, tmp1)\n-              return = Range<u64>::fold(tmp0, const 1u64, tmp1) -> bb1;\n-          }\n-\n-          bb1: {\n-              return;\n-          }\n-      }\n-    \\end{minted}\n-  \\end{center}\n-\\end{frame}\n-\n-\\end{document}"}, {"sha": "23aa1a481b3ebc8eb1358f31a6e49f08090bc5d9", "filename": "tex/report/latexmkrc", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/709e29a16749333c29ba6311f79037df837d1426/tex%2Freport%2Flatexmkrc", "raw_url": "https://github.com/rust-lang/rust/raw/709e29a16749333c29ba6311f79037df837d1426/tex%2Freport%2Flatexmkrc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Freport%2Flatexmkrc?ref=709e29a16749333c29ba6311f79037df837d1426", "patch": "@@ -1,12 +0,0 @@\n-# vim: ft=perl\n-\n-$pdf_mode = 1;\n-$pdflatex = 'lualatex --shell-escape %O %S';\n-$out_dir = 'out';\n-\n-# This improves latexmk's detection of source files and generated files.\n-$recorder = 1;\n-\n-# Ignore always-regenerated *.pyg files from the minted package when considering\n-# whether to run pdflatex again.\n-$hash_calc_ignore_pattern{'pyg'} = '.*';"}, {"sha": "27a063de0272aed0f19a1e03d442e4ba4b506c51", "filename": "tex/report/miri-report.tex", "status": "removed", "additions": 0, "deletions": 663, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/709e29a16749333c29ba6311f79037df837d1426/tex%2Freport%2Fmiri-report.tex", "raw_url": "https://github.com/rust-lang/rust/raw/709e29a16749333c29ba6311f79037df837d1426/tex%2Freport%2Fmiri-report.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Freport%2Fmiri-report.tex?ref=709e29a16749333c29ba6311f79037df837d1426", "patch": "@@ -1,663 +0,0 @@\n-% vim: tw=100\n-\n-\\documentclass[twocolumn]{article}\n-\\usepackage{blindtext}\n-\\usepackage[hypcap]{caption}\n-\\usepackage{fontspec}\n-\\usepackage[colorlinks, urlcolor={blue!80!black}]{hyperref}\n-\\usepackage[outputdir=out]{minted}\n-\\usepackage{relsize}\n-\\usepackage{xcolor}\n-\n-\\setmonofont{Source Code Pro}[\n-  BoldFont={* Medium},\n-  BoldItalicFont={* Medium Italic},\n-  Scale=MatchLowercase,\n-]\n-\n-\\newcommand{\\rust}[1]{\\mintinline{rust}{#1}}\n-\n-\\begin{document}\n-\n-\\title{Miri: \\\\ \\smaller{An interpreter for Rust's mid-level intermediate representation}}\n-\\author{Scott Olson\\footnote{\\href{mailto:scott@solson.me}{scott@solson.me}} \\\\\n-  \\smaller{Supervised by Christopher Dutchyn}}\n-\\date{April 12th, 2016}\n-\\maketitle\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Abstract}\n-\n-The increasing need for safe low-level code in contexts like operating systems and browsers is\n-driving the development of Rust\\footnote{\\url{https://www.rust-lang.org}}, a programming language\n-promising high performance without the risk of memory unsafety. To make programming more convenient,\n-it's often desirable to be able to generate code or perform some computation at compile-time. The\n-former is mostly covered by Rust's existing macro feature or build-time code generation, but the\n-latter is currently restricted to a limited form of constant evaluation capable of little beyond\n-simple math.\n-\n-The architecture of the compiler at the time the existing constant evaluator was built limited its\n-potential for future extension. However, a new intermediate representation was recently\n-added\\footnote{\\href{https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md}{Rust RFC \\#1211: Mid-level IR (MIR)}}\n-to the Rust compiler between the abstract syntax tree and the back-end LLVM IR, called mid-level\n-intermediate representation, or MIR for short. This report will demonstrate that writing an\n-interpreter for MIR is a surprisingly effective approach for supporting a large proportion of Rust's\n-features in compile-time execution.\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Background}\n-\n-The Rust compiler generates an instance of \\rust{Mir} for each function [\\autoref{fig:mir}]. Each\n-\\rust{Mir} structure represents a control-flow graph for a given function, and contains a list of\n-``basic blocks'' which in turn contain a list of statements followed by a single terminator. Each\n-statement is of the form \\rust{place = rvalue}. An \\rust{Place} is used for referencing variables\n-and calculating addresses such as when dereferencing pointers, accessing fields, or indexing arrays.\n-An \\rust{Rvalue} represents the core set of operations possible in MIR, including reading a value\n-from an place, performing math operations, creating new pointers, structures, and arrays, and so\n-on. Finally, a terminator decides where control will flow next, optionally based on the value of a\n-boolean or integer.\n-\n-\\begin{figure}[ht]\n-  \\begin{minted}[autogobble]{rust}\n-    struct Mir {\n-        basic_blocks: Vec<BasicBlockData>,\n-        // ...\n-    }\n-\n-    struct BasicBlockData {\n-        statements: Vec<Statement>,\n-        terminator: Terminator,\n-        // ...\n-    }\n-\n-    struct Statement {\n-        place: Place,\n-        rvalue: Rvalue\n-    }\n-\n-    enum Terminator {\n-        Goto { target: BasicBlock },\n-        If {\n-            cond: Operand,\n-            targets: [BasicBlock; 2]\n-        },\n-        // ...\n-    }\n-  \\end{minted}\n-  \\caption{MIR (simplified)}\n-  \\label{fig:mir}\n-\\end{figure}\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{First implementation}\n-\n-\\subsection{Basic operation}\n-\n-To investigate the possibility of executing Rust at compile-time I wrote an interpreter for MIR\n-called Miri\\footnote{\\url{https://github.com/solson/miri}}. The structure of the interpreter closely\n-mirrors the structure of MIR itself. It starts executing a function by iterating the statement list\n-in the starting basic block, translating the place into a pointer and using the rvalue to decide\n-what to write into that pointer. Evaluating the rvalue may involve reads (such as for the two sides\n-of a binary operation) or construction of new values. When the terminator is reached, it is used to\n-decide which basic block to jump to next. Finally, Miri repeats this entire process, reading\n-statements from the new block.\n-\n-\\subsection{Function calls}\n-\n-To handle function call terminators\\footnote{Calls occur only as terminators, never as rvalues.},\n-Miri is required to store some information in a virtual call stack so that it may pick up where it\n-left off when the callee returns. Each stack frame stores a reference to the \\rust{Mir} for the\n-function being executed, its local variables, its return value location\\footnote{Return value\n-pointers are passed in by callers.}, and the basic block where execution should resume. When Miri\n-encounters a \\rust{Return} terminator in the MIR, it pops one frame off the stack and resumes the\n-previous function. Miri's execution ends when the function it was initially invoked with returns,\n-leaving the call stack empty.\n-\n-It should be noted that Miri does not itself recurse when a function is called; it merely pushes a\n-virtual stack frame and jumps to the top of the interpreter loop. Consequently, Miri can interpret\n-deeply recursive programs without overflowing its native call stack. This approach would allow Miri\n-to set a virtual stack depth limit and report an error when a program exceeds it.\n-\n-\\subsection{Flaws}\n-\n-This version of Miri supported quite a bit of the Rust language, including booleans, integers,\n-if-conditions, while-loops, structures, enums, arrays, tuples, pointers, and function calls,\n-requiring approximately 400 lines of Rust code. However, it had a particularly naive value\n-representation with a number of downsides. It resembled the data layout of a dynamic language like\n-Ruby or Python, where every value has the same size\\footnote{An \\rust{enum} is a discriminated union\n-with a tag and space to fit the largest variant, regardless of which variant it contains.} in the\n-interpreter:\n-\n-\\begin{minted}[autogobble]{rust}\n-  enum Value {\n-      Uninitialized,\n-      Bool(bool),\n-      Int(i64),\n-      Pointer(Pointer), // index into stack\n-      Aggregate {\n-        variant: usize,\n-        data: Pointer,\n-      },\n-  }\n-\\end{minted}\n-\n-This representation did not work well for aggregate types\\footnote{That is, structures, enums,\n-arrays, tuples, and closures.} and required strange hacks to support them. Their contained values\n-were allocated elsewhere on the stack and pointed to by the aggregate value, which made it more\n-complicated to implement copying aggregate values from place to place.\n-\n-Moreover, while the aggregate issues could be worked around, this value representation made common\n-unsafe programming tricks (which make assumptions about the low-level value layout) fundamentally\n-impossible.\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Current implementation}\n-\n-Roughly halfway through my time working on Miri, Eduard\n-Burtescu\\footnote{\\href{https://github.com/eddyb}{eddyb on GitHub}} from the Rust compiler\n-team\\footnote{\\url{https://www.rust-lang.org/team.html\\#Compiler}} made a post on Rust's internal\n-forums about a ``Rust Abstract Machine''\n-specification\\footnote{\\href{https://internals.rust-lang.org/t/mir-constant-evaluation/3143/31}{Burtescu's\n-reply on ``MIR constant evaluation''}} which could be used to implement more powerful compile-time\n-function execution, similar to what is supported by C++14's \\mintinline{cpp}{constexpr} feature.\n-After clarifying some of the details of the data layout with Burtescu via IRC, I started\n-implementing it in Miri.\n-\n-\\subsection{Raw value representation}\n-\n-The main difference in the new value representation was to represent values by ``abstract\n-allocations'' containing arrays of raw bytes with different sizes depending on their types. This\n-mimics how Rust values are represented when compiled for physical machines. In addition to the raw\n-bytes, allocations carry information about pointers and undefined bytes.\n-\n-\\begin{minted}[autogobble]{rust}\n-  struct Memory {\n-      map: HashMap<AllocId, Allocation>,\n-      next_id: AllocId,\n-  }\n-\n-  struct Allocation {\n-      bytes: Vec<u8>,\n-      relocations: BTreeMap<usize, AllocId>,\n-      undef_mask: UndefMask,\n-  }\n-\\end{minted}\n-\n-\\subsubsection{Relocations}\n-\n-The abstract machine represents pointers through ``relocations'', which are analogous to relocations\n-in linkers\\footnote{\\href{https://en.wikipedia.org/wiki/Relocation_(computing)}{Relocation\n-(computing) - Wikipedia}}. Instead of storing a global memory address in the raw byte representation\n-like on a physical machine, we store an offset from the start of the target allocation and add an\n-entry to the relocation table which maps the index of the offset bytes to the target allocation.\n-\n-In \\autoref{fig:reloc}, the relocation stored at offset 0 in \\rust{y} points to offset 2 in \\rust{x}\n-(the 2nd 16-bit integer). Thus, the relocation table for \\rust{y} is \\texttt{\\{0 =>\n-x\\}}, meaning the next $N$ bytes after offset 0 denote an offset into allocation \\rust{x} where $N$\n-is the size of a pointer (4 in this example). The example shows this as a labelled line beneath the\n-offset bytes.\n-\n-In effect, the abstract machine represents pointers as \\rust{(allocation_id, offset)} pairs. This\n-makes it easy to detect when pointer accesses go out of bounds.\n-\n-\\begin{figure}[hb]\n-  \\begin{minted}[autogobble]{rust}\n-    let x: [i16; 3] = [0xAABB, 0xCCDD, 0xEEFF];\n-    let y = &x[1];\n-    // x: BB AA DD CC FF EE (6 bytes)\n-    // y: 02 00 00 00 (4 bytes)\n-    //    \u2514\u2500\u2500\u2500(x)\u2500\u2500\u2500\u2518\n-  \\end{minted}\n-  \\caption{Example relocation on 32-bit little-endian}\n-  \\label{fig:reloc}\n-\\end{figure}\n-\n-\\subsubsection{Undefined byte mask}\n-\n-The final piece of an abstract allocation is the undefined byte mask. Logically, we store a boolean\n-for the definedness of every byte in the allocation, but there are multiple ways to make the storage\n-more compact. I tried two implementations: one based on the endpoints of alternating ranges of\n-defined and undefined bytes and the other based on a bitmask. The former is more compact but I found\n-it surprisingly difficult to update cleanly. I currently use the much simpler bitmask system.\n-\n-See \\autoref{fig:undef} for an example of an undefined byte in a value, represented by underscores.\n-Note that there is a value for the second byte in the byte array, but it doesn't matter what it is.\n-The bitmask would be $10_2$, i.e.\\ \\rust{[true, false]}.\n-\n-\\begin{figure}[hb]\n-  \\begin{minted}[autogobble]{rust}\n-    let x: [u8; 2] = unsafe {\n-        [1, std::mem::uninitialized()]\n-    };\n-    // x: 01 __ (2 bytes)\n-  \\end{minted}\n-  \\caption{Example undefined byte}\n-  \\label{fig:undef}\n-\\end{figure}\n-\n-\\subsection{Computing data layout}\n-\n-Currently, the Rust compiler's data layouts for types are hidden from Miri, so it does its own data\n-layout computation which will not always match what the compiler does, since Miri doesn't take\n-target type alignments into account. In the future, the Rust compiler may be modified so that Miri\n-can use the exact same data layout.\n-\n-Miri's data layout calculation is a relatively simple transformation from Rust types to a structure\n-with constant size values for primitives and sets of fields with offsets for aggregate types. These\n-layouts are cached for performance.\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Deterministic execution}\n-\\label{sec:deterministic}\n-\n-In order to be effective as a compile-time evaluator, Miri must have \\emph{deterministic execution},\n-as explained by Burtescu in the ``Rust Abstract Machine'' post. That is, given a function and\n-arguments to that function, Miri should always produce identical results. This is important for\n-coherence in the type checker when constant evaluations are involved in types, such as for sizes of\n-array types:\n-\n-\\begin{minted}[autogobble,mathescape]{rust}\n-  const fn get_size() -> usize { /* $\\ldots$ */ }\n-  let array: [i32; get_size()];\n-\\end{minted}\n-\n-Since Miri allows execution of unsafe code\\footnote{In fact, the distinction between safe and unsafe\n-doesn't exist at the MIR level.}, it is specifically designed to remain safe while interpreting\n-potentially unsafe code. When Miri encounters an unrecoverable error, it reports it via the Rust\n-compiler's usual error reporting mechanism, pointing to the part of the original code where the\n-error occurred. Below is an example from Miri's\n-repository.\\footnote{\\href{https://github.com/solson/miri/blob/master/test/errors.rs}{miri/test/errors.rs}}\n-\n-\\begin{minted}[autogobble]{rust}\n-  let b = Box::new(42);\n-  let p: *const i32 = &*b;\n-  drop(b);\n-  unsafe { *p }\n-  //       ~~ error: dangling pointer\n-  //            was dereferenced\n-\\end{minted}\n-\\label{dangling-pointer}\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Language support}\n-\n-In its current state, Miri supports a large proportion of the Rust language, detailed below. The\n-major exception is a lack of support for  FFI\\footnote{Foreign Function Interface, e.g.\\ calling\n-functions defined in Assembly, C, or C++.}, which eliminates possibilities like reading and writing\n-files, user input, graphics, and more. However, for compile-time evaluation in Rust, this limitation\n-is desired.\n-\n-\\subsection{Primitives}\n-\n-Miri supports booleans, integers of various sizes and signed-ness (i.e.\\ \\rust{i8}, \\rust{i16},\n-\\rust{i32}, \\rust{i64}, \\rust{isize}, \\rust{u8}, \\rust{u16}, \\rust{u32}, \\rust{u64}, \\rust{usize}),\n-and unary and binary operations over these types. The \\rust{isize} and \\rust{usize} types will be\n-sized according to the target machine's pointer size just like in compiled Rust. The \\rust{char} and\n-float types (\\rust{f32}, \\rust{f64}) are not supported yet, but there are no known barriers to doing\n-so.\n-\n-When examining a boolean in an \\rust{if} condition, Miri will report an error if its byte\n-representation is not precisely 0 or 1, since having any other value for a boolean is undefined\n-behaviour in Rust. The \\rust{char} type will have similar restrictions once it is implemented.\n-\n-\\subsection{Pointers}\n-\n-Both references and raw pointers are supported, with essentially no difference between them in Miri.\n-It is also possible to do pointer comparisons and math. However, a few operations are considered\n-errors and a few require special support.\n-\n-Firstly, pointers into the same allocations may be compared for ordering, but pointers into\n-different allocations are considered unordered and Miri will complain if you attempt this. The\n-reasoning is that different allocations may have different orderings in the global address space at\n-runtime, making this non-deterministic. However, pointers into different allocations \\emph{may} be\n-compared for direct equality (they are always unequal).\n-\n-Secondly, pointers represented using relocations may be compared against pointers casted from\n-integers (e.g.\\ \\rust{0 as *const i32}) for things like null pointer checks. To handle these cases,\n-Miri has a concept of ``integer pointers'' which are always unequal to abstract pointers. Integer\n-pointers can be compared and operated upon freely. However, note that it is impossible to go from an\n-integer pointer to an abstract pointer backed by a relocation. It is not valid to dereference an\n-integer pointer.\n-\n-\\subsubsection{Slice pointers}\n-\n-Rust supports pointers to ``dynamically-sized types'' such as \\rust{[T]} and \\rust{str} which\n-represent arrays of indeterminate size. Pointers to such types contain an address \\emph{and} the\n-length of the referenced array. Miri supports these fully.\n-\n-\\subsubsection{Trait objects}\n-\n-Rust also supports pointers to ``trait objects'' which represent some type that implements a trait,\n-with the specific type unknown at compile-time. These are implemented using virtual dispatch with a\n-vtable, similar to virtual methods in C++. Miri does not currently support these at all.\n-\n-\\subsection{Aggregates}\n-\n-Aggregates include types declared with \\rust{struct} or \\rust{enum} as well as tuples, arrays, and\n-closures. Miri supports all common usage of all of these types. The main missing piece is to handle\n-\\texttt{\\#[repr(..)]} annotations which adjust the layout of a \\rust{struct} or \\rust{enum}.\n-\n-\\subsection{Place projections}\n-\n-This category includes field accesses, dereferencing, accessing data in an \\rust{enum} variant, and\n-indexing arrays. Miri supports all of these, including nested projections such as\n-\\rust{*foo.bar[2]}.\n-\n-\\subsection{Control flow}\n-\n-All of Rust's standard control flow features, including \\rust{loop}, \\rust{while}, \\rust{for},\n-\\rust{if}, \\rust{if let}, \\rust{while let}, \\rust{match}, \\rust{break}, \\rust{continue}, and\n-\\rust{return} are supported. In fact, supporting these was quite easy since the Rust compiler\n-reduces them all down to a small set of control-flow graph primitives in MIR.\n-\n-\\subsection{Function calls}\n-\n-As previously described, Miri supports arbitrary function calls without growing the native stack\n-(only its virtual call stack). It is somewhat limited by the fact that cross-crate\\footnote{A crate\n-is a single Rust library (or executable).} calls only work for functions whose MIR is stored in\n-crate metadata. This is currently true for \\rust{const}, generic, and inline functions.\n-A branch of the compiler could be made that stores MIR for all functions. This would be a non-issue\n-for a compile-time evaluator based on Miri, since it would only call \\rust{const fn}s.\n-\n-\\subsubsection{Method calls}\n-\n-Miri supports trait method calls, including invoking all the compiler-internal lookup needed to find\n-the correct implementation of the method.\n-\n-\\subsubsection{Closures}\n-\n-Calls to closures are also supported with the exception of one edge case\\footnote{Calling a closure\n-that takes a reference to its captures via a closure interface that passes the captures by value is\n-not yet supported.}. The value part of a closure that holds the captured variables is handled as an\n-aggregate and the function call part is mostly the same as a trait method call, but with the added\n-complication that closures use a separate calling convention within the compiler.\n-\n-\\subsubsection{Function pointers}\n-\n-Function pointers are not currently supported by Miri, but there is a relatively simple way they\n-could be encoded using a relocation with a special reserved allocation identifier. The offset of the\n-relocation would determine which function it points to in a special array of functions in the\n-interpreter.\n-\n-\\subsubsection{Intrinsics}\n-\n-To support unsafe code, and in particular to support Rust's standard library, it became clear that\n-Miri would have to support calls to compiler\n-intrinsics\\footnote{\\url{https://doc.rust-lang.org/stable/std/intrinsics/index.html}}. Intrinsics\n-are function calls which cause the Rust compiler to produce special-purpose code instead of a\n-regular function call. Miri simply recognizes intrinsic calls by their unique\n-ABI\\footnote{Application Binary Interface, which defines calling conventions. Includes ``C'',\n-``Rust'', and ``rust-intrinsic''.} and name and runs special-purpose code to handle them.\n-\n-An example of an important intrinsic is \\rust{size_of} which will cause Miri to write the size of\n-the type in question to the return value location. The Rust standard library uses intrinsics heavily\n-to implement various data structures, so this was a major step toward supporting them. Intrinsics\n-have been implemented on a case-by-case basis as tests which required them were written, and not all\n-intrinsics are supported yet.\n-\n-\\subsubsection{Generic function calls}\n-\n-Miri needs special support for generic function calls since Rust is a \\emph{monomorphizing}\n-compiler, meaning it generates a special version of each function for each distinct set of type\n-parameters it gets called with. Since functions in MIR are still polymorphic, Miri has to do the\n-same thing and substitute function type parameters into all types it encounters to get fully\n-concrete, monomorphized types. For example, in\\ldots\n-\n-\\begin{minted}[autogobble]{rust}\n-  fn some<T>(t: T) -> Option<T> { Some(t) }\n-\\end{minted}\n-\n-\\ldots{}Miri needs to know the size of \\rust{T} to copy the right amount of bytes from the argument\n-to the return value. If we call \\rust{some(10i32)} Miri will execute \\rust{some} knowing that\n-\\rust{T = i32} and generate a representation for \\rust{Option<i32>}.\n-\n-Miri currently does this monomorphization lazily on-demand unlike the Rust back-end which does it\n-all ahead of time.\n-\n-\\subsection{Heap allocations}\n-\n-The next piece of the puzzle for supporting interesting programs (and the standard library) was heap\n-allocations. There are two main interfaces for heap allocation in Rust: the built-in \\rust{Box}\n-rvalue in MIR and a set of C ABI foreign functions including \\rust{__rust_allocate},\n-\\rust{__rust_reallocate}, and \\rust{__rust_deallocate}. These correspond approximately to\n-\\mintinline{c}{malloc}, \\mintinline{c}{realloc}, and \\mintinline{c}{free} in C.\n-\n-The \\rust{Box} rvalue allocates enough space for a single value of a given type. This was easy to\n-support in Miri. It simply creates a new abstract allocation in the same manner as for\n-stack-allocated values, since there's no major difference between them in Miri.\n-\n-The allocator functions, which are used to implement things like Rust's standard \\rust{Vec<T>} type,\n-were a bit trickier. Rust declares them as \\rust{extern \"C\" fn} so that different allocator\n-libraries can be linked in at the user's option. Since Miri doesn't actually support FFI and wants\n-full control of allocations for safety, it ``cheats'' and recognizes these allocator functions in\n-essentially the same way it recognizes compiler intrinsics. Then, a call to \\rust{__rust_allocate}\n-simply creates another abstract allocation with the requested size and \\rust{__rust_reallocate}\n-grows one.\n-\n-In the future, Miri should also track which allocations came from \\rust{__rust_allocate} so it can\n-reject reallocate or deallocate calls on stack allocations.\n-\n-\\subsection{Destructors}\n-\n-When a value which ``owns'' some resource (like a heap allocation or file handle) goes out of scope,\n-Rust inserts \\emph{drop glue} that calls the user-defined destructor for the type if it has one, and\n-then drops all of the subfields. Destructors for types like \\rust{Box<T>} and \\rust{Vec<T>}\n-deallocate heap memory.\n-\n-Miri doesn't yet support calling user-defined destructors, but it has most of the machinery in place\n-to do so already. There \\emph{is} support for dropping \\rust{Box<T>} types, including deallocating\n-their associated allocations. This is enough to properly execute the dangling pointer example in\n-\\autoref{sec:deterministic}.\n-\n-\\subsection{Constants}\n-\n-Only basic integer, boolean, string, and byte-string literals are currently supported. Evaluating\n-more complicated constant expressions in their current form would be a somewhat pointless exercise\n-for Miri. Instead, we should lower constant expressions to MIR so Miri can run them directly, which\n-is precisely what would need be done to use Miri as the compiler's constant evaluator.\n-\n-\\subsection{Static variables}\n-\n-Miri doesn't currently support statics, but they would need support similar to constants. Also note\n-that while it would be invalid to write to static (i.e.\\ global) variables in Miri executions, it\n-would probably be fine to allow reads.\n-\n-\\subsection{Standard library}\n-\n-Throughout the implementation of the above features, I often followed this process:\n-\n-\\begin{enumerate}\n-  \\item Try using a feature from the standard library.\n-  \\item See where Miri runs into stuff it can't handle.\n-  \\item Fix the problem.\n-  \\item Go to 1.\n-\\end{enumerate}\n-\n-At present, Miri supports a number of major non-trivial features from the standard library along\n-with tons of minor features. Smart pointer types such as \\rust{Box}, \\rust{Rc}\\footnote{Reference\n-counted shared pointer} and \\rust{Arc}\\footnote{Atomically reference-counted thread-safe shared\n-pointer} all seem to work. I've also tested using the shared smart pointer types with \\rust{Cell}\n-and \\rust{RefCell}\\footnote{\\href{https://doc.rust-lang.org/stable/std/cell/index.html}{Rust\n-documentation for cell types}} for internal mutability, and that works as well, although\n-\\rust{RefCell} can't ever be borrowed twice until I implement destructor calls, since a destructor\n-is what releases the borrow.\n-\n-But the standard library collection I spent the most time on was \\rust{Vec}, the standard\n-dynamically-growable array type, similar to C++'s \\texttt{std::vector} or Java's\n-\\texttt{java.util.ArrayList}. In Rust, \\rust{Vec} is an extremely pervasive collection, so\n-supporting it is a big win for supporting a larger swath of Rust programs in Miri.\n-\n-See \\autoref{fig:vec} for an example (working in Miri today) of initializing a \\rust{Vec} with a\n-small amount of space on the heap and then pushing enough elements to force it to reallocate its\n-data array. This involves cross-crate generic function calls, unsafe code using raw pointers, heap\n-allocation, handling of uninitialized memory, compiler intrinsics, and more.\n-\n-\\begin{figure}[t]\n-  \\begin{minted}[autogobble]{rust}\n-    struct Vec<T> {\n-        data: *mut T,    // 4 byte pointer\n-        capacity: usize, // 4 byte integer\n-        length: usize,   // 4 byte integer\n-    }\n-\n-    let mut v: Vec<u8> =\n-        Vec::with_capacity(2);\n-    // v: 00 00 00 00 02 00 00 00 00 00 00 00\n-    //    \u2514\u2500(data)\u2500\u2500\u2518\n-    // data: __ __\n-\n-    v.push(1);\n-    // v: 00 00 00 00 02 00 00 00 01 00 00 00\n-    //    \u2514\u2500(data)\u2500\u2500\u2518\n-    // data: 01 __\n-\n-    v.push(2);\n-    // v: 00 00 00 00 02 00 00 00 02 00 00 00\n-    //    \u2514\u2500(data)\u2500\u2500\u2518\n-    // data: 01 02\n-\n-    v.push(3);\n-    // v: 00 00 00 00 04 00 00 00 03 00 00 00\n-    //    \u2514\u2500(data)\u2500\u2500\u2518\n-    // data: 01 02 03 __\n-  \\end{minted}\n-  \\caption{\\rust{Vec} example on 32-bit little-endian}\n-  \\label{fig:vec}\n-\\end{figure}\n-\n-Miri supports unsafe operations on \\rust{Vec} like \\rust{v.set_len(10)} or\n-\\rust{v.get_unchecked(2)}, provided that such calls do no invoke undefined behaviour. If a call\n-\\emph{does} invoke undefined behaviour, Miri will abort with an appropriate error message (see\n-\\autoref{fig:vec-error}).\n-\n-\\begin{figure}[t]\n-  \\begin{minted}[autogobble]{rust}\n-    fn out_of_bounds() -> u8 {\n-        let v = vec![1, 2];\n-        let p = unsafe { v.get_unchecked(5) };\n-        *p + 10\n-    //  ~~ error: pointer offset outside\n-    //       bounds of allocation\n-    }\n-\n-    fn undefined_bytes() -> u8 {\n-        let v = Vec::<u8>::with_capacity(10);\n-        let p = unsafe { v.get_unchecked(5) };\n-        *p + 10\n-    //  ~~~~~~~ error: attempted to read\n-    //            undefined bytes\n-    }\n-  \\end{minted}\n-  \\caption{\\rust{Vec} examples with undefined behaviour}\n-  \\label{fig:vec-error}\n-\\end{figure}\n-\n-\\newpage\n-\n-Here is one final code sample Miri can execute that demonstrates many features at once, including\n-vectors, heap allocation, iterators, closures, raw pointers, and math:\n-\n-\\begin{minted}[autogobble]{rust}\n-  let x: u8 = vec![1, 2, 3, 4]\n-      .into_iter()\n-      .map(|x| x * x)\n-      .fold(0, |x, y| x + y);\n-    // x: 1e (that is, the hex value\n-    //        0x1e = 30 = 1 + 4 + 9 + 16)\n-\\end{minted}\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Future directions}\n-\n-\\subsection{Finishing the implementation}\n-\n-There are a number of pressing items on my to-do list for Miri, including:\n-\n-\\begin{itemize}\n-  \\item A much more comprehensive and automated test suite.\n-  \\item User-defined destructor calls.\n-  \\item Non-trivial casts between primitive types like integers and pointers.\n-  \\item Handling statics and global memory.\n-  \\item Reporting errors for all undefined behaviour.\\footnote{\\href{https://doc.rust-lang.org/reference.html\\#behavior-considered-undefined}{The Rust reference on what is considered undefined behaviour}}\n-  \\item Function pointers.\n-  \\item Accounting for target machine primitive type alignment and endianness.\n-  \\item Optimizations (undefined byte masks, tail-calls).\n-  \\item Benchmarking Miri vs. unoptimized Rust.\n-  \\item Various \\texttt{TODO}s and \\texttt{FIXME}s left in the code.\n-  \\item Integrating into the compiler proper.\n-\\end{itemize}\n-\n-\\subsection{Future projects}\n-\n-Other possible Miri-related projects include:\n-\n-\\begin{itemize}\n-  \\item A read-eval-print-loop (REPL) for Rust, which may be easier to implement on top of Miri than\n-    the usual LLVM back-end.\n-  \\item A graphical or text-mode debugger that steps through MIR execution one statement at a time,\n-    for figuring out why some compile-time execution is raising an error or simply learning how Rust\n-    works at a low level.\n-  \\item A less restricted version of Miri that is able to run foreign functions from C/C++ and\n-    generally has full access to the operating system. Such an interpreter could be used to more\n-    quickly prototype changes to the Rust language that would otherwise require changes to the LLVM\n-    back-end.\n-  \\item Unit-testing the compiler by comparing the results of Miri's execution against the results\n-    of LLVM-compiled machine code's execution. This would help to guarantee that compile-time\n-    execution works the same as runtime execution.\n-  \\item Some kind of Miri-based symbolic evaluator that examines multiple possible code paths at\n-    once to determine if undefined behaviour could be observed on any of them.\n-\\end{itemize}\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Final thoughts}\n-\n-Writing an interpreter which models values of varying sizes, stack and heap allocation, unsafe\n-memory operations, and more requires some unconventional techniques compared to conventional\n-interpreters targeting dynamically-typed languages. However, aside from the somewhat complicated\n-abstract memory model, making Miri work was primarily a software engineering problem, and not a\n-particularly tricky one. This is a testament to MIR's suitability as an intermediate representation\n-for Rust---removing enough unnecessary abstraction to keep it simple. For example, Miri doesn't even\n-need to know that there are different kinds of loops, or how to match patterns in a \\rust{match}\n-expression.\n-\n-Another advantage to targeting MIR is that any new features at the syntax-level or type-level\n-generally require little to no change in Miri. For example, when the new ``question mark'' syntax\n-for error handling\\footnote{\n-  \\href{https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md}\n-    {Question mark syntax RFC}}\n-was added to rustc, Miri required no change to support it.\n-When specialization\\footnote{\n-  \\href{https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md}\n-    {Specialization RFC}}\n-was added, Miri supported it with just minor changes to trait method lookup.\n-\n-Of course, Miri also has limitations. The inability to execute FFI and inline assembly reduces the\n-amount of Rust programs Miri could ever execute. The good news is that in the constant evaluator,\n-FFI can be stubbed out in cases where it makes sense, like I did with \\rust{__rust_allocate}. For a\n-version of Miri not intended for constant evaluation, it may be possible to use libffi to call C\n-functions from the interpreter.\n-\n-In conclusion, Miri is a surprisingly effective project, and a lot of fun to implement. Due to MIR's\n-tendency to collapse multiple source-level features into one, I often ended up supporting features I\n-hadn't explicitly intended to. I am excited to work with the compiler team going forward to try to\n-make Miri useful for constant evaluation in Rust.\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Thanks}\n-\n-A big thanks goes to Eduard Burtescu for writing the abstract machine specification and answering my\n-incessant questions on IRC, to Niko Matsakis for coming up with the idea for Miri and supporting my\n-desire to work with the Rust compiler, and to my research supervisor Christopher Dutchyn. Thanks\n-also to everyone else on the compiler team and on Mozilla IRC who helped me figure stuff out.\n-Finally, thanks to Daniel Keep and everyone else who helped fix my numerous writing mistakes.\n-\n-\\end{document}"}]}