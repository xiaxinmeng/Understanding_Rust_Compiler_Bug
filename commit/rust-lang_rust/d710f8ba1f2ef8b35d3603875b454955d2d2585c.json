{"sha": "d710f8ba1f2ef8b35d3603875b454955d2d2585c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MTBmOGJhMWYyZWY4YjM1ZDM2MDM4NzViNDU0OTU1ZDJkMjU4NWM=", "commit": {"author": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2015-10-21T16:59:24Z"}, "committer": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2015-10-21T17:05:27Z"}, "message": "Moar comments.", "tree": {"sha": "d805d3722eed97e01b4662983afa6a94f349ca1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d805d3722eed97e01b4662983afa6a94f349ca1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d710f8ba1f2ef8b35d3603875b454955d2d2585c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d710f8ba1f2ef8b35d3603875b454955d2d2585c", "html_url": "https://github.com/rust-lang/rust/commit/d710f8ba1f2ef8b35d3603875b454955d2d2585c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d710f8ba1f2ef8b35d3603875b454955d2d2585c/comments", "author": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a71c5c33170707cbf01cf0b975b45b0cdfbb2f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a71c5c33170707cbf01cf0b975b45b0cdfbb2f5", "html_url": "https://github.com/rust-lang/rust/commit/9a71c5c33170707cbf01cf0b975b45b0cdfbb2f5"}], "stats": {"total": 89, "additions": 59, "deletions": 30}, "files": [{"sha": "4fa57726ef5f0fcc7947a2814f5299dc565618ad", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=d710f8ba1f2ef8b35d3603875b454955d2d2585c", "patch": "@@ -65,11 +65,11 @@ pub fn opts() -> TargetOptions {\n             \"-nostdlib\".to_string(),\n         ),\n         pre_link_objects_exe: vec!(\n-            \"crt2.o\".to_string(),\n-            \"rsbegin.o\".to_string(),\n+            \"crt2.o\".to_string(),    // mingw C runtime initialization for executables\n+            \"rsbegin.o\".to_string(), // Rust compiler runtime initialization, see rsbegin.rs\n         ),\n         pre_link_objects_dll: vec!(\n-            \"dllcrt2.o\".to_string(),\n+            \"dllcrt2.o\".to_string(), // mingw C runtime initialization for dlls\n             \"rsbegin.o\".to_string(),\n         ),\n         late_link_args: vec!("}, {"sha": "a624b3521267af94106476098105af3f16a78ac6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d710f8ba1f2ef8b35d3603875b454955d2d2585c", "patch": "@@ -400,15 +400,6 @@ pub mod __rand {\n     pub use rand::{thread_rng, ThreadRng, Rng};\n }\n \n-// Rust runtime's startup objects depend on these symbols, so they must be public.\n-// Since sys_common isn't public, we have to re-export them here explicitly.\n-#[doc(hidden)]\n-#[unstable(feature = \"eh_frame_registry\", issue = \"0\")]\n-#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n-pub mod __frame_registry {\n-    pub use sys_common::unwind::imp::eh_frame_registry::*;\n-}\n-\n // Include a number of private modules that exist solely to provide\n // the rustdoc documentation for primitive types. Using `include!`\n // because rustdoc only looks for these modules at the crate level."}, {"sha": "44961611b7bd78bf2e10c4e861de556ed2342666", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=d710f8ba1f2ef8b35d3603875b454955d2d2585c", "patch": "@@ -32,6 +32,11 @@ use thread::{self, Thread};\n // Reexport some of our utilities which are expected by other crates.\n pub use sys_common::unwind::{begin_unwind, begin_unwind_fmt};\n \n+// Rust runtime's startup objects depend on these symbols, so they must be public.\n+// Since sys_common isn't public, we have to re-export them here.\n+#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n+pub use sys_common::unwind::imp::eh_frame_registry::*;\n+\n #[cfg(not(test))]\n #[lang = \"start\"]\n fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {"}, {"sha": "0a598b559514c7db4be49eb36c576e8ff1216df4", "filename": "src/libstd/sys/common/unwind/gcc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs?ref=d710f8ba1f2ef8b35d3603875b454955d2d2585c", "patch": "@@ -232,6 +232,7 @@ pub mod eabi {\n     }\n }\n \n+// See docs in the `unwind` module.\n #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\", not(test)))]\n #[lang = \"eh_unwind_resume\"]\n #[unwind]\n@@ -241,6 +242,10 @@ unsafe extern fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {\n \n #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n pub mod eh_frame_registry {\n+    // The implementation of stack unwinding is (for now) deferred to libgcc_eh, however Rust\n+    // crates use these Rust-specific entry points to avoid potential clashes with GCC runtime.\n+    // See also: rtbegin.rs, `unwind` module.\n+\n     #[link(name = \"gcc_eh\")]\n     extern {\n         fn __register_frame_info(eh_frame_begin: *const u8, object: *mut u8);"}, {"sha": "e42a4694070cb1e418b1923e4f18ccc35c0c2b98", "filename": "src/libstd/sys/common/unwind/mod.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs?ref=d710f8ba1f2ef8b35d3603875b454955d2d2585c", "patch": "@@ -34,28 +34,35 @@\n //! object being thrown, and to decide whether it should be caught at that stack\n //! frame.  Once the handler frame has been identified, cleanup phase begins.\n //!\n-//! In the cleanup phase, personality routines invoke cleanup code associated\n-//! with their stack frames (i.e. destructors).  Once stack has been unwound down\n-//! to the handler frame level, unwinding stops and the last personality routine\n-//! transfers control to its catch block.\n+//! In the cleanup phase, the unwinder invokes each personality routine again.\n+//! This time it decides which (if any) cleanup code needs to be run for\n+//! the current stack frame.  If so, the control is transferred to a special branch\n+//! in the function body, the \"landing pad\", which invokes destructors, frees memory,\n+//! etc.  At the end of the landing pad, control is transferred back to the unwinder\n+//! and unwinding resumes.\n //!\n-//! ## Frame unwind info registration\n+//! Once stack has been unwound down to the handler frame level, unwinding stops\n+//! and the last personality routine transfers control to the catch block.\n //!\n-//! Each module has its own frame unwind info section (usually \".eh_frame\"), and\n-//! unwinder needs to know about all of them in order for unwinding to be able to\n-//! cross module boundaries.\n+//! ## `eh_personality` and `eh_unwind_resume`\n //!\n-//! On some platforms, like Linux, this is achieved by dynamically enumerating\n-//! currently loaded modules via the dl_iterate_phdr() API and finding all\n-//! .eh_frame sections.\n+//! These language items are used by the compiler when generating unwind info.\n+//! The first one is the personality routine described above.  The second one\n+//! allows compilation target to customize the process of resuming unwind at the\n+//! end of the landing pads.  `eh_unwind_resume` is used only if `custom_unwind_resume`\n+//! flag in the target options is set.\n //!\n-//! Others, like Windows, require modules to actively register their unwind info\n-//! sections by calling __register_frame_info() API at startup.  In the latter\n-//! case it is essential that there is only one copy of the unwinder runtime in\n-//! the process.  This is usually achieved by linking to the dynamic version of\n-//! the unwind runtime.\n+//! ## Frame unwind info registration\n //!\n-//! Currently Rust uses unwind runtime provided by libgcc.\n+//! Each module's image contains a frame unwind info section (usually \".eh_frame\").\n+//! When a module is loaded/unloaded into the process, the unwinder must be informed\n+//! about the location of this section in memory. The methods of achieving that vary\n+//! by the platform.\n+//! On some (e.g. Linux), the unwinder can discover unwind info sections on its own\n+//! (by dynamically enumerating currently loaded modules via the dl_iterate_phdr() API\n+//! and finding their \".eh_frame\" sections);\n+//! Others, like Windows, require modules to actively register their unwind info\n+//! sections via unwinder API (see `rust_eh_register_frames`/`rust_eh_unregister_frames`).\n \n #![allow(dead_code)]\n #![allow(unused_imports)]"}, {"sha": "af9a01ea2e4f7f8f0285d32708f44b1810018bb8", "filename": "src/rtstartup/rsbegin.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Frtstartup%2Frsbegin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Frtstartup%2Frsbegin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frtstartup%2Frsbegin.rs?ref=d710f8ba1f2ef8b35d3603875b454955d2d2585c", "patch": "@@ -8,8 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// rsbegin.o and rsend.o are the so called \"compiler runtime startup objects\".\n+// They contain code needed to correctly initialize the compiler runtime.\n+//\n+// When an executable or dylib image is linked, all user code and libraries are\n+// \"sandwiched\" between these two object files, so code or data from rsbegin.o\n+// become first in the respective sections of the image, whereas code and data\n+// from rsend.o become the last ones.  This effect can be used to place symbols\n+// at the beginning or at the end of a section, as well as to insert any required\n+// headers or footers.\n+//\n+// Note that the actual module entry point is located in the C runtime startup\n+// object (usually called `crtX.o), which then invokes initialization callbacks\n+// of other runtime components (registered via yet another special image section).\n+\n #![feature(no_std)]\n-#![feature(linkage)]\n \n #![crate_type=\"rlib\"]\n #![no_std]\n@@ -20,27 +33,33 @@ pub mod eh_frames\n {\n     #[no_mangle]\n     #[link_section = \".eh_frame\"]\n+    // Marks beginning of the stack frame unwind info section\n     pub static __EH_FRAME_BEGIN__: [u8; 0] = [];\n \n     // Scratch space for unwinder's internal book-keeping.\n     // This is defined as `struct object` in $GCC/libgcc/unwind-dw2-fde.h.\n     static mut obj: [isize; 6] = [0; 6];\n \n+    // Unwind info registration/deregistration routines.\n+    // See the docs of `unwind` module in libstd.\n     extern {\n         fn rust_eh_register_frames(eh_frame_begin: *const u8, object: *mut u8);\n         fn rust_eh_unregister_frames(eh_frame_begin: *const u8, object: *mut u8);\n     }\n \n     unsafe fn init() {\n+        // register unwind info on module startup\n         rust_eh_register_frames(&__EH_FRAME_BEGIN__ as *const u8,\n                                 &mut obj as *mut _ as *mut u8);\n     }\n \n     unsafe fn uninit() {\n+        // unregister on shutdown\n         rust_eh_unregister_frames(&__EH_FRAME_BEGIN__ as *const u8,\n                                   &mut obj as *mut _ as *mut u8);\n     }\n \n+    // MSVC-specific init/uninit routine registration\n     pub mod ms_init\n     {\n         // .CRT$X?? sections are roughly analogous to ELF's .init_array and .fini_array,"}, {"sha": "ecb6a228e1776d5f396739fa088b308ce152fee9", "filename": "src/rtstartup/rsend.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Frtstartup%2Frsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d710f8ba1f2ef8b35d3603875b454955d2d2585c/src%2Frtstartup%2Frsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frtstartup%2Frsend.rs?ref=d710f8ba1f2ef8b35d3603875b454955d2d2585c", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// See rsbegin.rs for details.\n+\n #![feature(no_std)]\n \n #![crate_type=\"rlib\"]"}]}