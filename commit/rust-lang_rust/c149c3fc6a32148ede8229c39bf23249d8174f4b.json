{"sha": "c149c3fc6a32148ede8229c39bf23249d8174f4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNDljM2ZjNmEzMjE0OGVkZTgyMjljMzliZjIzMjQ5ZDgxNzRmNGI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-13T00:46:56Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-13T00:46:56Z"}, "message": "Re-do packed memory accesses\n\nWe now track in the lvalue whether what we computed is expected to be aligend or not, and then set some state in the memory system accordingly to make it (not) do alignment checks", "tree": {"sha": "c762b514ed025079cb815d241605346b920bce70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c762b514ed025079cb815d241605346b920bce70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c149c3fc6a32148ede8229c39bf23249d8174f4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c149c3fc6a32148ede8229c39bf23249d8174f4b", "html_url": "https://github.com/rust-lang/rust/commit/c149c3fc6a32148ede8229c39bf23249d8174f4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c149c3fc6a32148ede8229c39bf23249d8174f4b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fda18f64cdef25daeeecbd7453cd45c47cfacff3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fda18f64cdef25daeeecbd7453cd45c47cfacff3", "html_url": "https://github.com/rust-lang/rust/commit/fda18f64cdef25daeeecbd7453cd45c47cfacff3"}], "stats": {"total": 226, "additions": 87, "deletions": 139}, "files": [{"sha": "0e63e033cfb78fd207d9a8d51638d7024304f5de", "filename": "src/eval_context.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c149c3fc6a32148ede8229c39bf23249d8174f4b/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c149c3fc6a32148ede8229c39bf23249d8174f4b/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=c149c3fc6a32148ede8229c39bf23249d8174f4b", "patch": "@@ -446,6 +446,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let dest = Lvalue::Ptr {\n             ptr: dest_ptr.into(),\n             extra: LvalueExtra::DowncastVariant(variant_idx),\n+            aligned: true,\n         };\n \n         self.assign_fields(dest, dest_ty, operands)\n@@ -496,8 +497,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc::mir::Rvalue::*;\n         match *rvalue {\n             Use(ref operand) => {\n-                let value = self.eval_operand(operand)?;\n+                let (value, aligned) = self.eval_operand_maybe_unaligned(operand)?;\n+                self.memory.reads_are_aligned = aligned;\n                 self.write_value(value, dest, dest_ty)?;\n+                self.memory.reads_are_aligned = true;\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n@@ -528,15 +531,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.inc_step_counter_and_check_limit(operands.len() as u64)?;\n                 use rustc::ty::layout::Layout::*;\n                 match *dest_layout {\n-                    Univariant { ref variant, .. } => {\n-                        if variant.packed {\n-                            let ptr = self.force_allocation(dest)?.to_ptr_and_extra().0.to_ptr()?;\n-                            self.memory.mark_packed(ptr, variant.stride().bytes());\n-                        }\n-                        self.assign_fields(dest, dest_ty, operands)?;\n-                    }\n-\n-                    Array { .. } => {\n+                    Univariant { .. } | Array { .. } => {\n                         self.assign_fields(dest, dest_ty, operands)?;\n                     }\n \n@@ -547,10 +542,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 .expect(\"broken mir: Adt variant id invalid\")\n                                 .to_u128_unchecked();\n                             let discr_size = discr.size().bytes();\n-                            if variants[variant].packed {\n-                                let ptr = self.force_allocation(dest)?.to_ptr_and_extra().0.to_ptr()?;\n-                                self.memory.mark_packed(ptr, variants[variant].stride().bytes());\n-                            }\n \n                             self.assign_discr_and_fields(\n                                 dest,\n@@ -587,12 +578,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         }\n                     }\n \n-                    StructWrappedNullablePointer { nndiscr, ref nonnull, ref discrfield, .. } => {\n+                    StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n                         if let mir::AggregateKind::Adt(_, variant, _, _) = **kind {\n-                            if nonnull.packed {\n-                                let ptr = self.force_allocation(dest)?.to_ptr_and_extra().0.to_ptr()?;\n-                                self.memory.mark_packed(ptr, nonnull.stride().bytes());\n-                            }\n                             if nndiscr == variant as u64 {\n                                 self.assign_fields(dest, dest_ty, operands)?;\n                             } else {\n@@ -682,7 +669,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Ref(_, _, ref lvalue) => {\n                 let src = self.eval_lvalue(lvalue)?;\n-                let (ptr, extra) = self.force_allocation(src)?.to_ptr_and_extra();\n+                // We ignore the alignment of the lvalue here -- this rvalue produces sth. of type &, which must always be aligned.\n+                let (ptr, extra, _aligned) = self.force_allocation(src)?.to_ptr_extra_aligned();\n                 let ty = self.lvalue_ty(lvalue);\n \n                 let val = match extra {\n@@ -695,7 +683,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 // Check alignment and non-NULLness.\n                 let (_, align) = self.size_and_align_of_dst(ty, val)?;\n-                self.memory.check_align(ptr, align, 0)?;\n+                self.memory.check_align(ptr, align)?;\n \n                 self.write_value(val, dest, dest_ty)?;\n             }\n@@ -967,7 +955,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.value_to_primval(value, ty)\n     }\n \n-    pub(super) fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn eval_operand_maybe_unaligned(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, (Value, bool)> {\n         use rustc::mir::Operand::*;\n         match *op {\n             Consume(ref lvalue) => self.eval_and_read_lvalue(lvalue),\n@@ -993,11 +981,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 };\n \n-                Ok(value)\n+                Ok((value, true))\n             }\n         }\n     }\n \n+    pub(super) fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n+        // This is called when the packed flag is not taken into account. Ignore alignment.\n+        Ok(self.eval_operand_maybe_unaligned(op)?.0)\n+    }\n+\n     pub(super) fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(operand.ty(self.mir(), self.tcx), self.substs())\n     }\n@@ -1131,9 +1124,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_value_possibly_by_val(src_val, write_dest, dest.value, dest_ty)\n             },\n \n-            Lvalue::Ptr { ptr, extra } => {\n+            Lvalue::Ptr { ptr, extra, aligned } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                self.write_value_to_ptr(src_val, ptr, dest_ty)\n+                self.memory.writes_are_aligned = aligned;\n+                let r = self.write_value_to_ptr(src_val, ptr, dest_ty);\n+                self.memory.writes_are_aligned = true;\n+                r\n             }\n \n             Lvalue::Local { frame, local } => {"}, {"sha": "18ec7a77cb8ce90708cb1a09449e93ae9230adf7", "filename": "src/lvalue.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c149c3fc6a32148ede8229c39bf23249d8174f4b/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c149c3fc6a32148ede8229c39bf23249d8174f4b/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=c149c3fc6a32148ede8229c39bf23249d8174f4b", "patch": "@@ -17,6 +17,8 @@ pub enum Lvalue<'tcx> {\n         /// before ever being dereferenced.\n         ptr: Pointer,\n         extra: LvalueExtra,\n+        /// Remember whether this lvalue is *supposed* to be aligned.\n+        aligned: bool,\n     },\n \n     /// An lvalue referring to a value on the stack. Represented by a stack frame index paired with\n@@ -68,24 +70,25 @@ impl<'tcx> Lvalue<'tcx> {\n     }\n \n     pub(crate) fn from_primval_ptr(ptr: Pointer) -> Self {\n-        Lvalue::Ptr { ptr, extra: LvalueExtra::None }\n+        Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true }\n     }\n \n     pub(crate) fn from_ptr(ptr: MemoryPointer) -> Self {\n         Self::from_primval_ptr(ptr.into())\n     }\n \n-    pub(super) fn to_ptr_and_extra(self) -> (Pointer, LvalueExtra) {\n+    pub(super) fn to_ptr_extra_aligned(self) -> (Pointer, LvalueExtra, bool) {\n         match self {\n-            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n+            Lvalue::Ptr { ptr, extra, aligned } => (ptr, extra, aligned),\n             _ => bug!(\"to_ptr_and_extra: expected Lvalue::Ptr, got {:?}\", self),\n \n         }\n     }\n \n     pub(super) fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n-        let (ptr, extra) = self.to_ptr_and_extra();\n+        let (ptr, extra, aligned) = self.to_ptr_extra_aligned();\n         assert_eq!(extra, LvalueExtra::None);\n+        assert_eq!(aligned, true, \"tried converting an unaligned lvalue into a ptr\");\n         ptr.to_ptr()\n     }\n \n@@ -175,13 +178,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn eval_and_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n+    /// Returns a value and (in case of a ByRef) if we are supposed to use aligned accesses.\n+    pub(super) fn eval_and_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, (Value, bool)> {\n         let ty = self.lvalue_ty(lvalue);\n         // Shortcut for things like accessing a fat pointer's field,\n         // which would otherwise (in the `eval_lvalue` path) require moving a `ByValPair` to memory\n         // and returning an `Lvalue::Ptr` to it\n         if let Some(val) = self.try_read_lvalue(lvalue)? {\n-            return Ok(val);\n+            return Ok((val, true));\n         }\n         let lvalue = self.eval_lvalue(lvalue)?;\n \n@@ -190,15 +194,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n \n         match lvalue {\n-            Lvalue::Ptr { ptr, extra } => {\n+            Lvalue::Ptr { ptr, extra, aligned } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                Ok(Value::ByRef(ptr))\n+                Ok((Value::ByRef(ptr), aligned))\n             }\n             Lvalue::Local { frame, local } => {\n-                self.stack[frame].get_local(local)\n+                Ok((self.stack[frame].get_local(local)?, true))\n             }\n             Lvalue::Global(cid) => {\n-                Ok(self.globals.get(&cid).expect(\"global not cached\").value)\n+                Ok((self.globals.get(&cid).expect(\"global not cached\").value, true))\n             }\n         }\n     }\n@@ -239,7 +243,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             },\n \n             General { ref variants, .. } => {\n-                let (_, base_extra) = base.to_ptr_and_extra();\n+                let (_, base_extra, _) = base.to_ptr_extra_aligned();\n                 if let LvalueExtra::DowncastVariant(variant_idx) = base_extra {\n                     // +1 for the discriminant, which is field 0\n                     (variants[variant_idx].offsets[field_index + 1], variants[variant_idx].packed)\n@@ -289,8 +293,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         };\n \n         // Do not allocate in trivial cases\n-        let (base_ptr, base_extra) = match base {\n-            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n+        let (base_ptr, base_extra, aligned) = match base {\n+            Lvalue::Ptr { ptr, extra, aligned } => (ptr, extra, aligned),\n             Lvalue::Local { frame, local } => match self.stack[frame].get_local(local)? {\n                 // in case the type has a single field, just return the value\n                 Value::ByVal(_) if self.get_field_count(base_ty).map(|c| c == 1).unwrap_or(false) => {\n@@ -299,7 +303,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 },\n                 Value::ByRef(_) |\n                 Value::ByValPair(..) |\n-                Value::ByVal(_) => self.force_allocation(base)?.to_ptr_and_extra(),\n+                Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n             },\n             Lvalue::Global(cid) => match self.globals.get(&cid).expect(\"uncached global\").value {\n                 // in case the type has a single field, just return the value\n@@ -309,7 +313,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 },\n                 Value::ByRef(_) |\n                 Value::ByValPair(..) |\n-                Value::ByVal(_) => self.force_allocation(base)?.to_ptr_and_extra(),\n+                Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n             },\n         };\n \n@@ -325,11 +329,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let field_ty = self.monomorphize(field_ty, self.substs());\n \n-        if packed {\n-            let size = self.type_size(field_ty)?.expect(\"packed struct must be sized\");\n-            self.memory.mark_packed(ptr.to_ptr()?, size);\n-        }\n-\n         let extra = if self.type_is_sized(field_ty) {\n             LvalueExtra::None\n         } else {\n@@ -343,15 +342,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             base_extra\n         };\n \n-        Ok(Lvalue::Ptr { ptr, extra })\n+        Ok(Lvalue::Ptr { ptr, extra, aligned: aligned && !packed })\n     }\n \n     fn eval_lvalue_projection(\n         &mut self,\n         proj: &mir::LvalueProjection<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         use rustc::mir::ProjectionElem::*;\n-        let (ptr, extra) = match proj.elem {\n+        let (ptr, extra, aligned) = match proj.elem {\n             Field(field, field_ty) => {\n                 let base = self.eval_lvalue(&proj.base)?;\n                 let base_ty = self.lvalue_ty(&proj.base);\n@@ -364,20 +363,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let base_layout = self.type_layout(base_ty)?;\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, base_extra) = base.to_ptr_and_extra();\n+                let (base_ptr, base_extra, aligned) = base.to_ptr_extra_aligned();\n \n                 use rustc::ty::layout::Layout::*;\n                 let extra = match *base_layout {\n                     General { .. } => LvalueExtra::DowncastVariant(variant),\n                     RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => base_extra,\n                     _ => bug!(\"variant downcast on non-aggregate: {:?}\", base_layout),\n                 };\n-                (base_ptr, extra)\n+                (base_ptr, extra, aligned)\n             }\n \n             Deref => {\n                 let base_ty = self.lvalue_ty(&proj.base);\n-                let val = self.eval_and_read_lvalue(&proj.base)?;\n+                let (val, _aligned) = self.eval_and_read_lvalue(&proj.base)?;\n+                // Conservatively, the intermediate accesses of a Deref lvalue do not take into account the packed flag.\n+                // Hence we ignore alignment here.\n \n                 let pointee_type = match base_ty.sty {\n                     ty::TyRawPtr(ref tam) |\n@@ -391,13 +392,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match self.tcx.struct_tail(pointee_type).sty {\n                     ty::TyDynamic(..) => {\n                         let (ptr, vtable) = val.expect_ptr_vtable_pair(&self.memory)?;\n-                        (ptr, LvalueExtra::Vtable(vtable))\n+                        (ptr, LvalueExtra::Vtable(vtable), true)\n                     },\n                     ty::TyStr | ty::TySlice(_) => {\n                         let (ptr, len) = val.expect_slice(&self.memory)?;\n-                        (ptr, LvalueExtra::Length(len))\n+                        (ptr, LvalueExtra::Length(len), true)\n                     },\n-                    _ => (val.read_ptr(&self.memory)?, LvalueExtra::None),\n+                    _ => (val.read_ptr(&self.memory)?, LvalueExtra::None, true),\n                 }\n             }\n \n@@ -406,7 +407,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let base_ty = self.lvalue_ty(&proj.base);\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, _) = base.to_ptr_and_extra();\n+                let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n \n                 let (elem_ty, len) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n@@ -415,15 +416,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let n = self.value_to_primval(n_ptr, usize)?.to_u64()?;\n                 assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n                 let ptr = base_ptr.offset(n * elem_size, self.memory.layout)?;\n-                (ptr, LvalueExtra::None)\n+                (ptr, LvalueExtra::None, aligned)\n             }\n \n             ConstantIndex { offset, min_length, from_end } => {\n                 let base = self.eval_lvalue(&proj.base)?;\n                 let base_ty = self.lvalue_ty(&proj.base);\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, _) = base.to_ptr_and_extra();\n+                let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"sequence element must be sized\");\n@@ -436,26 +437,26 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n \n                 let ptr = base_ptr.offset(index * elem_size, self.memory.layout)?;\n-                (ptr, LvalueExtra::None)\n+                (ptr, LvalueExtra::None, aligned)\n             }\n \n             Subslice { from, to } => {\n                 let base = self.eval_lvalue(&proj.base)?;\n                 let base_ty = self.lvalue_ty(&proj.base);\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, _) = base.to_ptr_and_extra();\n+                let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 assert!(u64::from(from) <= n - u64::from(to));\n                 let ptr = base_ptr.offset(u64::from(from) * elem_size, self.memory.layout)?;\n                 let extra = LvalueExtra::Length(n - u64::from(to) - u64::from(from));\n-                (ptr, extra)\n+                (ptr, extra, aligned)\n             }\n         };\n \n-        Ok(Lvalue::Ptr { ptr, extra })\n+        Ok(Lvalue::Ptr { ptr, extra, aligned })\n     }\n \n     pub(super) fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {"}, {"sha": "debdf05a6cdc4c74b1cf97447ca22238b4b1ed16", "filename": "src/memory.rs", "status": "modified", "additions": 15, "deletions": 65, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c149c3fc6a32148ede8229c39bf23249d8174f4b/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c149c3fc6a32148ede8229c39bf23249d8174f4b/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=c149c3fc6a32148ede8229c39bf23249d8174f4b", "patch": "@@ -1,5 +1,5 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n-use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque, BTreeSet};\n+use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, ptr, mem, io};\n \n use rustc::ty;\n@@ -124,20 +124,6 @@ pub struct Memory<'a, 'tcx> {\n     /// Target machine data layout to emulate.\n     pub layout: &'a TargetDataLayout,\n \n-    /// List of memory regions containing packed structures.\n-    ///\n-    /// We mark memory as \"packed\" or \"unaligned\" for a single statement, and clear the marking\n-    /// afterwards. In the case where no packed structs are present, it's just a single emptyness\n-    /// check of a set instead of heavily influencing all memory access code as other solutions\n-    /// would. This is simpler than the alternative of passing a \"packed\" parameter to every\n-    /// load/store method.\n-    ///\n-    /// One disadvantage of this solution is the fact that you can cast a pointer to a packed\n-    /// struct to a pointer to a normal struct and if you access a field of both in the same MIR\n-    /// statement, the normal struct access will succeed even though it shouldn't. But even with\n-    /// mir optimizations, that situation is hard/impossible to produce.\n-    packed: BTreeSet<Entry>,\n-\n     /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n     /// allocations for string and bytestring literals.\n     literal_alloc_cache: HashMap<Vec<u8>, AllocId>,\n@@ -147,6 +133,11 @@ pub struct Memory<'a, 'tcx> {\n \n     /// The Key to use for the next thread-local allocation.\n     next_thread_local: TlsKey,\n+\n+    /// To avoid having to pass flags to every single memory access, we have some global state saying whether\n+    /// alignment checking is currently enforced for read and/or write accesses.\n+    pub reads_are_aligned: bool,\n+    pub writes_are_aligned: bool,\n }\n \n impl<'a, 'tcx> Memory<'a, 'tcx> {\n@@ -159,11 +150,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             layout,\n             memory_size: max_memory,\n             memory_usage: 0,\n-            packed: BTreeSet::new(),\n             static_alloc: HashSet::new(),\n             literal_alloc_cache: HashMap::new(),\n             thread_local: BTreeMap::new(),\n             next_thread_local: 0,\n+            reads_are_aligned: true,\n+            writes_are_aligned: true,\n         }\n     }\n \n@@ -278,30 +270,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.layout.endian\n     }\n \n-    pub fn check_align(&self, ptr: Pointer, align: u64, len: u64) -> EvalResult<'tcx> {\n+    pub fn check_align(&self, ptr: Pointer, align: u64) -> EvalResult<'tcx> {\n         let offset = match ptr.into_inner_primval() {\n             PrimVal::Ptr(ptr) => {\n                 let alloc = self.get(ptr.alloc_id)?;\n-                // check whether the memory was marked as packed\n-                // we select all elements that have the correct alloc_id and are within\n-                // the range given by the offset into the allocation and the length\n-                let start = Entry {\n-                    alloc_id: ptr.alloc_id,\n-                    packed_start: 0,\n-                    packed_end: ptr.offset + len,\n-                };\n-                let end = Entry {\n-                    alloc_id: ptr.alloc_id,\n-                    packed_start: ptr.offset + len,\n-                    packed_end: 0,\n-                };\n-                for &Entry { packed_start, packed_end, .. } in self.packed.range(start..end) {\n-                    // if the region we are checking is covered by a region in `packed`\n-                    // ignore the actual alignment\n-                    if packed_start <= ptr.offset && (ptr.offset + len) <= packed_end {\n-                        return Ok(());\n-                    }\n-                }\n                 if alloc.align < align {\n                     return Err(EvalError::AlignmentCheckFailed {\n                         has: alloc.align,\n@@ -338,18 +310,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub(crate) fn mark_packed(&mut self, ptr: MemoryPointer, len: u64) {\n-        self.packed.insert(Entry {\n-            alloc_id: ptr.alloc_id,\n-            packed_start: ptr.offset,\n-            packed_end: ptr.offset + len,\n-        });\n-    }\n-\n-    pub(crate) fn clear_packed(&mut self) {\n-        self.packed.clear();\n-    }\n-\n     pub(crate) fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.next_thread_local;\n         self.next_thread_local += 1;\n@@ -426,20 +386,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n }\n \n-// The derived `Ord` impl sorts first by the first field, then, if the fields are the same\n-// by the second field, and if those are the same, too, then by the third field.\n-// This is exactly what we need for our purposes, since a range within an allocation\n-// will give us all `Entry`s that have that `AllocId`, and whose `packed_start` is <= than\n-// the one we're looking for, but not > the end of the range we're checking.\n-// At the same time the `packed_end` is irrelevant for the sorting and range searching, but used for the check.\n-// This kind of search breaks, if `packed_end < packed_start`, so don't do that!\n-#[derive(Eq, PartialEq, Ord, PartialOrd)]\n-struct Entry {\n-    alloc_id: AllocId,\n-    packed_start: u64,\n-    packed_end: u64,\n-}\n-\n /// Allocation accessors\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n@@ -576,7 +522,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Ok(&[]);\n         }\n         // FIXME: check alignment for zst memory accesses?\n-        self.check_align(ptr.into(), align, size)?;\n+        if self.reads_are_aligned {\n+            self.check_align(ptr.into(), align)?;\n+        }\n         self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -590,7 +538,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Ok(&mut []);\n         }\n         // FIXME: check alignment for zst memory accesses?\n-        self.check_align(ptr.into(), align, size)?;\n+        if self.writes_are_aligned {\n+            self.check_align(ptr.into(), align)?;\n+        }\n         self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);"}, {"sha": "3fd28463e07356a9d6745071bb473c0b6630dc15", "filename": "src/step.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c149c3fc6a32148ede8229c39bf23249d8174f4b/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c149c3fc6a32148ede8229c39bf23249d8174f4b/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=c149c3fc6a32148ede8229c39bf23249d8174f4b", "patch": "@@ -28,8 +28,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     /// Returns true as long as there are more things to do.\n     pub fn step(&mut self) -> EvalResult<'tcx, bool> {\n-        // see docs on the `Memory::packed` field for why we do this\n-        self.memory.clear_packed();\n+        assert!(self.memory.reads_are_aligned && self.memory.writes_are_aligned, \"Someone forgot to clear the 'unaligned' flag\");\n         self.inc_step_counter_and_check_limit(1)?;\n         if self.stack.is_empty() {\n             return Ok(false);"}, {"sha": "d0ad71a7293d7c65b34af0a448b76c45ae4d921e", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c149c3fc6a32148ede8229c39bf23249d8174f4b/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c149c3fc6a32148ede8229c39bf23249d8174f4b/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=c149c3fc6a32148ede8229c39bf23249d8174f4b", "patch": "@@ -12,9 +12,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(crate) fn drop_lvalue(&mut self, lval: Lvalue<'tcx>, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n         trace!(\"drop_lvalue: {:#?}\", lval);\n         let val = match self.force_allocation(lval)? {\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => ptr.to_value_with_vtable(vtable),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => ptr.to_value_with_len(len),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::None } => ptr.to_value(),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable), aligned: true } => ptr.to_value_with_vtable(vtable),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len), aligned: true } => ptr.to_value_with_len(len),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true } => ptr.to_value(),\n             _ => bug!(\"force_allocation broken\"),\n         };\n         self.drop(val, instance, ty, span)"}, {"sha": "def080d5b206b199cff72e82f172bfd3e62e092a", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c149c3fc6a32148ede8229c39bf23249d8174f4b/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c149c3fc6a32148ede8229c39bf23249d8174f4b/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=c149c3fc6a32148ede8229c39bf23249d8174f4b", "patch": "@@ -270,8 +270,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 match dest {\n                     Lvalue::Local { frame, local } => self.modify_local(frame, local, init)?,\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::None } => self.memory.write_repeat(ptr, 0, size)?,\n-                    Lvalue::Ptr { .. } => bug!(\"init intrinsic tried to write to fat ptr target\"),\n+                    Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true } => self.memory.write_repeat(ptr, 0, size)?,\n+                    Lvalue::Ptr { .. } => bug!(\"init intrinsic tried to write to fat or unaligned ptr target\"),\n                     Lvalue::Global(cid) => self.modify_global(cid, init)?,\n                 }\n             }\n@@ -394,11 +394,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"transmute\" => {\n                 let src_ty = substs.type_at(0);\n-                let dest_ty = substs.type_at(1);\n-                let size = self.type_size(dest_ty)?.expect(\"transmute() type must be sized\");\n                 let ptr = self.force_allocation(dest)?.to_ptr()?;\n-                self.memory.mark_packed(ptr, size);\n+                self.memory.writes_are_aligned = false;\n                 self.write_value_to_ptr(arg_vals[0], ptr.into(), src_ty)?;\n+                self.memory.writes_are_aligned = true;\n             }\n \n             \"unchecked_shl\" => {\n@@ -448,9 +447,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 match dest {\n                     Lvalue::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::None } =>\n+                    Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true } =>\n                         self.memory.mark_definedness(ptr, size, false)?,\n-                    Lvalue::Ptr { .. } => bug!(\"uninit intrinsic tried to write to fat ptr target\"),\n+                    Lvalue::Ptr { .. } => bug!(\"uninit intrinsic tried to write to fat or unaligned ptr target\"),\n                     Lvalue::Global(cid) => self.modify_global(cid, uninit)?,\n                 }\n             }\n@@ -465,7 +464,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                 if count > 0 {\n                     // TODO: Should we, at least, validate the alignment? (Also see memory::copy)\n-                    self.memory.check_align(ptr, ty_align, size * count)?;\n+                    self.memory.check_align(ptr, ty_align)?;\n                     self.memory.write_repeat(ptr, val_byte, size * count)?;\n                 }\n             }"}, {"sha": "796204ea4eef20bf76feb039fc5b5e92796954cf", "filename": "tests/run-pass/packed_struct.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c149c3fc6a32148ede8229c39bf23249d8174f4b/tests%2Frun-pass%2Fpacked_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c149c3fc6a32148ede8229c39bf23249d8174f4b/tests%2Frun-pass%2Fpacked_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpacked_struct.rs?ref=c149c3fc6a32148ede8229c39bf23249d8174f4b", "patch": "@@ -5,7 +5,7 @@ struct S {\n }\n \n fn main() {\n-    let x = S {\n+    let mut x = S {\n         a: 42,\n         b: 99,\n     };\n@@ -16,4 +16,7 @@ fn main() {\n     // can't do `assert_eq!(x.a, 42)`, because `assert_eq!` takes a reference\n     assert_eq!({x.a}, 42);\n     assert_eq!({x.b}, 99);\n+\n+    x.b = 77;\n+    assert_eq!({x.b}, 77);\n }"}]}