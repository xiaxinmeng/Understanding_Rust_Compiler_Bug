{"sha": "d57c9f79801762aa23adc21adbb638678268e96b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1N2M5Zjc5ODAxNzYyYWEyM2FkYzIxYWRiYjYzODY3ODI2OGU5NmI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-08T16:51:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-08T16:51:20Z"}, "message": "Merge #7891\n\n7891: Improve handling of rustc_private r=matklad a=DJMcNab\n\nThis PR changes how `rust-analyzer` handles `rustc_private`. In particular, packages now must opt-in to using `rustc_private` in `Cargo.toml`, by adding:\r\n```toml\r\n[package.metadata.rust-analyzer]\r\nrustc_private=true\r\n```\r\n\r\nThis means that depending on crates which also use `rustc_private` will be significantly improved, since their dependencies on the `rustc_private` crates will be resolved properly.\r\n\r\nA similar approach could be used in #6714 to allow annotating that your package uses the `test` crate, although I have not yet handled that in this PR.\r\n\r\nAdditionally, we now only index the crates which are transitive dependencies of `rustc_driver` in the `rustcSource` directory. This should not cause any change in behaviour when using `rustcSource: \"discover\"`, as the source used then will only be a partial clone. However, if `rustcSource` pointing at a local checkout of rustc, this should significantly improve the memory usage and lower indexing time. This is because we avoids indexing all crates in `src/tools/`, which includes `rust-analyzer` itself.\r\n\r\nFurthermore, we also prefer named dependencies over dependencies from `rustcSource`. This ensures that feature resolution for crates which are depended on by both `rustc` and your crate uses the correct set for analysing your crate.\r\n\r\nSee also [introductory zulip stream](https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Fixed.20crate.20graphs.20and.20optional.20builtin.20crates/near/229086673)\r\n\r\nI have tested this in [priroda](https://github.com/oli-obk/priroda/), and it provides a significant improvement to the development experience (once I give `miri` the required data in `Cargo.toml`)\r\n\r\nTodo:\r\n- [ ] Documentation\r\n\r\nThis is ready to review, and I will add documentation if this would be accepted (or if I get time to do so anyway)\n\nCo-authored-by: Daniel McNab <36049421+DJMcNab@users.noreply.github.com>", "tree": {"sha": "b4d67ea46bb187dde2200086eb9d3af731be3765", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4d67ea46bb187dde2200086eb9d3af731be3765"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d57c9f79801762aa23adc21adbb638678268e96b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgRlYICRBK7hj4Ov3rIwAAdHIIAE5wIsOcj5o4X2asrcRlqgDD\nEHX6NNRIUqUcwQ2jVBO0SP+Ur9jWDOZL75IGOyqgzmbK0gywLRz9CqPhsLjk6udg\naokrqdtxW6z7cmlc6yTz5oTyRL1DTMLo61hEDaJ7cj/pyEN6+R2kZj0XWJGPCAbH\nv7J/GPs5S6QkluFOdqbIWx48jdN+0FgtAG/o2vHVnZhj6kF6spT917SyPKInywez\nEXtZ0u3BwlzZWIxnED29eMsMJD79cqMwi/VTuNaXYN/Lq5cXa/lNDKLLmhscbVr9\nXNcOccnYGcjjnJkOXpI9gaBdXUzQHp0WgQgV8ER8KCD8Vew2H6PRDpM8JqjCeD8=\n=4uXD\n-----END PGP SIGNATURE-----\n", "payload": "tree b4d67ea46bb187dde2200086eb9d3af731be3765\nparent f2b8df17db254342eb17e8ac8df9e81e8b34775c\nparent 20007fd3a8aa16bec0c4f9ebc1489c157f846df4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615222280 +0000\ncommitter GitHub <noreply@github.com> 1615222280 +0000\n\nMerge #7891\n\n7891: Improve handling of rustc_private r=matklad a=DJMcNab\n\nThis PR changes how `rust-analyzer` handles `rustc_private`. In particular, packages now must opt-in to using `rustc_private` in `Cargo.toml`, by adding:\r\n```toml\r\n[package.metadata.rust-analyzer]\r\nrustc_private=true\r\n```\r\n\r\nThis means that depending on crates which also use `rustc_private` will be significantly improved, since their dependencies on the `rustc_private` crates will be resolved properly.\r\n\r\nA similar approach could be used in #6714 to allow annotating that your package uses the `test` crate, although I have not yet handled that in this PR.\r\n\r\nAdditionally, we now only index the crates which are transitive dependencies of `rustc_driver` in the `rustcSource` directory. This should not cause any change in behaviour when using `rustcSource: \"discover\"`, as the source used then will only be a partial clone. However, if `rustcSource` pointing at a local checkout of rustc, this should significantly improve the memory usage and lower indexing time. This is because we avoids indexing all crates in `src/tools/`, which includes `rust-analyzer` itself.\r\n\r\nFurthermore, we also prefer named dependencies over dependencies from `rustcSource`. This ensures that feature resolution for crates which are depended on by both `rustc` and your crate uses the correct set for analysing your crate.\r\n\r\nSee also [introductory zulip stream](https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Fixed.20crate.20graphs.20and.20optional.20builtin.20crates/near/229086673)\r\n\r\nI have tested this in [priroda](https://github.com/oli-obk/priroda/), and it provides a significant improvement to the development experience (once I give `miri` the required data in `Cargo.toml`)\r\n\r\nTodo:\r\n- [ ] Documentation\r\n\r\nThis is ready to review, and I will add documentation if this would be accepted (or if I get time to do so anyway)\n\nCo-authored-by: Daniel McNab <36049421+DJMcNab@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d57c9f79801762aa23adc21adbb638678268e96b", "html_url": "https://github.com/rust-lang/rust/commit/d57c9f79801762aa23adc21adbb638678268e96b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d57c9f79801762aa23adc21adbb638678268e96b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2b8df17db254342eb17e8ac8df9e81e8b34775c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b8df17db254342eb17e8ac8df9e81e8b34775c", "html_url": "https://github.com/rust-lang/rust/commit/f2b8df17db254342eb17e8ac8df9e81e8b34775c"}, {"sha": "20007fd3a8aa16bec0c4f9ebc1489c157f846df4", "url": "https://api.github.com/repos/rust-lang/rust/commits/20007fd3a8aa16bec0c4f9ebc1489c157f846df4", "html_url": "https://github.com/rust-lang/rust/commit/20007fd3a8aa16bec0c4f9ebc1489c157f846df4"}], "stats": {"total": 168, "additions": 114, "deletions": 54}, "files": [{"sha": "bc6e203414ee3590614b0f5946e742e6b4e1daef", "filename": "crates/project_model/src/cargo_workspace.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d57c9f79801762aa23adc21adbb638678268e96b/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d57c9f79801762aa23adc21adbb638678268e96b/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs?ref=d57c9f79801762aa23adc21adbb638678268e96b", "patch": "@@ -9,6 +9,8 @@ use cargo_metadata::{CargoOpt, MetadataCommand};\n use la_arena::{Arena, Idx};\n use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::FxHashMap;\n+use serde::Deserialize;\n+use serde_json::from_value;\n \n use crate::build_data::BuildDataConfig;\n use crate::utf8_stdout;\n@@ -104,6 +106,13 @@ pub struct PackageData {\n     pub active_features: Vec<String>,\n     // String representation of package id\n     pub id: String,\n+    // The contents of [package.metadata.rust-analyzer]\n+    pub metadata: RustAnalyzerPackageMetaData,\n+}\n+\n+#[derive(Deserialize, Default, Debug, Clone, Eq, PartialEq)]\n+pub struct RustAnalyzerPackageMetaData {\n+    pub rustc_private: bool,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -161,6 +170,13 @@ impl PackageData {\n     }\n }\n \n+#[derive(Deserialize, Default)]\n+// Deserialise helper for the cargo metadata\n+struct PackageMetadata {\n+    #[serde(rename = \"rust-analyzer\")]\n+    rust_analyzer: Option<RustAnalyzerPackageMetaData>,\n+}\n+\n impl CargoWorkspace {\n     pub fn from_cargo_metadata(\n         cargo_toml: &AbsPath,\n@@ -244,8 +260,10 @@ impl CargoWorkspace {\n \n         meta.packages.sort_by(|a, b| a.id.cmp(&b.id));\n         for meta_pkg in &meta.packages {\n-            let cargo_metadata::Package { id, edition, name, manifest_path, version, .. } =\n-                meta_pkg;\n+            let cargo_metadata::Package {\n+                id, edition, name, manifest_path, version, metadata, ..\n+            } = meta_pkg;\n+            let meta = from_value::<PackageMetadata>(metadata.clone()).unwrap_or_default();\n             let is_member = ws_members.contains(&id);\n             let edition = edition\n                 .parse::<Edition>()\n@@ -262,6 +280,7 @@ impl CargoWorkspace {\n                 dependencies: Vec::new(),\n                 features: meta_pkg.features.clone().into_iter().collect(),\n                 active_features: Vec::new(),\n+                metadata: meta.rust_analyzer.unwrap_or_default(),\n             });\n             let pkg_data = &mut packages[pkg];\n             pkg_by_id.insert(id, pkg);"}, {"sha": "1b53fcc30a6eb6378d10b1104b056b7e43401821", "filename": "crates/project_model/src/workspace.rs", "status": "modified", "additions": 89, "deletions": 49, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/d57c9f79801762aa23adc21adbb638678268e96b/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d57c9f79801762aa23adc21adbb638678268e96b/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=d57c9f79801762aa23adc21adbb638678268e96b", "patch": "@@ -2,11 +2,7 @@\n //! metadata` or `rust-project.json`) into representation stored in the salsa\n //! database -- `CrateGraph`.\n \n-use std::{\n-    fmt, fs,\n-    path::{Component, Path},\n-    process::Command,\n-};\n+use std::{collections::VecDeque, fmt, fs, path::Path, process::Command};\n \n use anyhow::{Context, Result};\n use base_db::{CrateDisplayName, CrateGraph, CrateId, CrateName, Edition, Env, FileId, ProcMacro};\n@@ -60,6 +56,7 @@ impl fmt::Debug for ProjectWorkspace {\n         match self {\n             ProjectWorkspace::Cargo { cargo, sysroot, rustc, rustc_cfg } => f\n                 .debug_struct(\"Cargo\")\n+                .field(\"root\", &cargo.workspace_root().file_name())\n                 .field(\"n_packages\", &cargo.packages().len())\n                 .field(\"n_sysroot_crates\", &sysroot.crates().len())\n                 .field(\n@@ -279,11 +276,8 @@ impl ProjectWorkspace {\n \n     pub fn collect_build_data_configs(&self, collector: &mut BuildDataCollector) {\n         match self {\n-            ProjectWorkspace::Cargo { cargo, rustc, .. } => {\n+            ProjectWorkspace::Cargo { cargo, .. } => {\n                 collector.add_config(&cargo.workspace_root(), cargo.build_data_config().clone());\n-                if let Some(rustc) = rustc {\n-                    collector.add_config(rustc.workspace_root(), rustc.build_data_config().clone());\n-                }\n             }\n             _ => {}\n         }\n@@ -380,9 +374,11 @@ fn cargo_to_crate_graph(\n     cfg_options.insert_atom(\"debug_assertions\".into());\n \n     let mut pkg_crates = FxHashMap::default();\n-\n+    // Does any crate signal to rust-analyzer that they need the rustc_private crates?\n+    let mut has_private = false;\n     // Next, create crates for each package, target pair\n     for pkg in cargo.packages() {\n+        has_private |= cargo[pkg].metadata.rustc_private;\n         let mut lib_tgt = None;\n         for &tgt in cargo[pkg].targets.iter() {\n             if let Some(file_id) = load(&cargo[tgt].root) {\n@@ -443,73 +439,117 @@ fn cargo_to_crate_graph(\n         }\n     }\n \n-    let mut rustc_pkg_crates = FxHashMap::default();\n+    if has_private {\n+        // If the user provided a path to rustc sources, we add all the rustc_private crates\n+        // and create dependencies on them for the crates which opt-in to that\n+        if let Some(rustc_workspace) = rustc {\n+            handle_rustc_crates(\n+                rustc_workspace,\n+                load,\n+                &mut crate_graph,\n+                rustc_build_data_map,\n+                &cfg_options,\n+                proc_macro_loader,\n+                &mut pkg_to_lib_crate,\n+                &public_deps,\n+                cargo,\n+                &pkg_crates,\n+            );\n+        }\n+    }\n+    crate_graph\n+}\n \n-    // If the user provided a path to rustc sources, we add all the rustc_private crates\n-    // and create dependencies on them for the crates in the current workspace\n-    if let Some(rustc_workspace) = rustc {\n-        for pkg in rustc_workspace.packages() {\n+fn handle_rustc_crates(\n+    rustc_workspace: &CargoWorkspace,\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+    crate_graph: &mut CrateGraph,\n+    rustc_build_data_map: Option<&FxHashMap<String, BuildData>>,\n+    cfg_options: &CfgOptions,\n+    proc_macro_loader: &dyn Fn(&Path) -> Vec<ProcMacro>,\n+    pkg_to_lib_crate: &mut FxHashMap<la_arena::Idx<crate::PackageData>, CrateId>,\n+    public_deps: &[(CrateName, CrateId)],\n+    cargo: &CargoWorkspace,\n+    pkg_crates: &FxHashMap<la_arena::Idx<crate::PackageData>, Vec<CrateId>>,\n+) {\n+    let mut rustc_pkg_crates = FxHashMap::default();\n+    // The root package of the rustc-dev component is rustc_driver, so we match that\n+    let root_pkg =\n+        rustc_workspace.packages().find(|package| rustc_workspace[*package].name == \"rustc_driver\");\n+    // The rustc workspace might be incomplete (such as if rustc-dev is not\n+    // installed for the current toolchain) and `rustcSource` is set to discover.\n+    if let Some(root_pkg) = root_pkg {\n+        // Iterate through every crate in the dependency subtree of rustc_driver using BFS\n+        let mut queue = VecDeque::new();\n+        queue.push_back(root_pkg);\n+        while let Some(pkg) = queue.pop_front() {\n+            // Don't duplicate packages if they are dependended on a diamond pattern\n+            // N.B. if this line is ommitted, we try to analyse over 4_800_000 crates\n+            // which is not ideal\n+            if rustc_pkg_crates.contains_key(&pkg) {\n+                continue;\n+            }\n+            for dep in &rustc_workspace[pkg].dependencies {\n+                queue.push_back(dep.pkg);\n+            }\n             for &tgt in rustc_workspace[pkg].targets.iter() {\n                 if rustc_workspace[tgt].kind != TargetKind::Lib {\n                     continue;\n                 }\n-                // Exclude alloc / core / std\n-                if rustc_workspace[tgt]\n-                    .root\n-                    .components()\n-                    .any(|c| c == Component::Normal(\"library\".as_ref()))\n-                {\n-                    continue;\n-                }\n-\n                 if let Some(file_id) = load(&rustc_workspace[tgt].root) {\n                     let crate_id = add_target_crate_root(\n-                        &mut crate_graph,\n+                        crate_graph,\n                         &rustc_workspace[pkg],\n                         rustc_build_data_map.and_then(|it| it.get(&rustc_workspace[pkg].id)),\n                         &cfg_options,\n                         proc_macro_loader,\n                         file_id,\n                     );\n                     pkg_to_lib_crate.insert(pkg, crate_id);\n-                    // Add dependencies on the core / std / alloc for rustc\n+                    // Add dependencies on core / std / alloc for this crate\n                     for (name, krate) in public_deps.iter() {\n-                        add_dep(&mut crate_graph, crate_id, name.clone(), *krate);\n+                        add_dep(crate_graph, crate_id, name.clone(), *krate);\n                     }\n                     rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n                 }\n             }\n         }\n-        // Now add a dep edge from all targets of upstream to the lib\n-        // target of downstream.\n-        for pkg in rustc_workspace.packages() {\n-            for dep in rustc_workspace[pkg].dependencies.iter() {\n-                let name = CrateName::new(&dep.name).unwrap();\n-                if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                    for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n-                        add_dep(&mut crate_graph, from, name.clone(), to);\n-                    }\n+    }\n+    // Now add a dep edge from all targets of upstream to the lib\n+    // target of downstream.\n+    for pkg in rustc_pkg_crates.keys().copied() {\n+        for dep in rustc_workspace[pkg].dependencies.iter() {\n+            let name = CrateName::new(&dep.name).unwrap();\n+            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n+                    add_dep(crate_graph, from, name.clone(), to);\n                 }\n             }\n         }\n-\n-        // Add dependencies for all the crates of the current workspace to rustc_private libraries\n-        for dep in rustc_workspace.packages() {\n-            let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n-\n-            if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n-                for pkg in cargo.packages() {\n-                    if !cargo[pkg].is_member {\n-                        continue;\n-                    }\n-                    for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                        add_dep(&mut crate_graph, from, name.clone(), to);\n+    }\n+    // Add a dependency on the rustc_private crates for all targets of each package\n+    // which opts in\n+    for dep in rustc_workspace.packages() {\n+        let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n+\n+        if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n+            for pkg in cargo.packages() {\n+                let package = &cargo[pkg];\n+                if !package.metadata.rustc_private {\n+                    continue;\n+                }\n+                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                    // Avoid creating duplicate dependencies\n+                    // This avoids the situation where `from` depends on e.g. `arrayvec`, but\n+                    // `rust_analyzer` thinks that it should use the one from the `rustcSource`\n+                    // instead of the one from `crates.io`\n+                    if !crate_graph[from].dependencies.iter().any(|d| d.name == name) {\n+                        add_dep(crate_graph, from, name.clone(), to);\n                     }\n                 }\n             }\n         }\n     }\n-    crate_graph\n }\n \n fn add_target_crate_root("}, {"sha": "4dbabdba78480a17b19db326e085b15aa0327af0", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d57c9f79801762aa23adc21adbb638678268e96b/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d57c9f79801762aa23adc21adbb638678268e96b/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=d57c9f79801762aa23adc21adbb638678268e96b", "patch": "@@ -181,7 +181,8 @@ config_data! {\n         runnables_cargoExtraArgs: Vec<String>   = \"[]\",\n \n         /// Path to the rust compiler sources, for usage in rustc_private projects, or \"discover\"\n-        /// to try to automatically find it.\n+        /// to try to automatically find it. Any project which uses rust-analyzer with the rustcPrivate\n+        /// crates must set `[package.metadata.rust-analyzer] rustc_private=true` to use it.\n         rustcSource : Option<String> = \"null\",\n \n         /// Additional arguments to `rustfmt`."}, {"sha": "5243bcbf6a6a57f99c153bc8e2b6e03cad58a469", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d57c9f79801762aa23adc21adbb638678268e96b/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/d57c9f79801762aa23adc21adbb638678268e96b/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=d57c9f79801762aa23adc21adbb638678268e96b", "patch": "@@ -107,7 +107,7 @@\n [[rust-analyzer.runnables.cargoExtraArgs]]rust-analyzer.runnables.cargoExtraArgs (default: `[]`)::\n  Additional arguments to be passed to cargo for runnables such as  tests or binaries.\\nFor example, it may be `--release`.\n [[rust-analyzer.rustcSource]]rust-analyzer.rustcSource (default: `null`)::\n- Path to the rust compiler sources, for usage in rustc_private projects, or \"discover\"  to try to automatically find it.\n+ Path to the rust compiler sources, for usage in rustc_private projects, or \"discover\"  to try to automatically find it. Any project which uses rust-analyzer with the rustcPrivate  crates must set `[package.metadata.rust-analyzer] rustc_private=true` to use it.\n [[rust-analyzer.rustfmt.extraArgs]]rust-analyzer.rustfmt.extraArgs (default: `[]`)::\n  Additional arguments to `rustfmt`.\n [[rust-analyzer.rustfmt.overrideCommand]]rust-analyzer.rustfmt.overrideCommand (default: `null`)::"}, {"sha": "856f1c94e5ad33d03d51e7dfedcf6c2493795004", "filename": "editors/code/package.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d57c9f79801762aa23adc21adbb638678268e96b/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/d57c9f79801762aa23adc21adbb638678268e96b/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=d57c9f79801762aa23adc21adbb638678268e96b", "patch": "@@ -713,7 +713,7 @@\n                     }\n                 },\n                 \"rust-analyzer.rustcSource\": {\n-                    \"markdownDescription\": \"Path to the rust compiler sources, for usage in rustc_private projects, or \\\"discover\\\" to try to automatically find it.\",\n+                    \"markdownDescription\": \"Path to the rust compiler sources, for usage in rustc_private projects, or \\\"discover\\\" to try to automatically find it. Any project which uses rust-analyzer with the rustcPrivate crates must set `[package.metadata.rust-analyzer] rustc_private=true` to use it.\",\n                     \"default\": null,\n                     \"type\": [\n                         \"null\","}]}