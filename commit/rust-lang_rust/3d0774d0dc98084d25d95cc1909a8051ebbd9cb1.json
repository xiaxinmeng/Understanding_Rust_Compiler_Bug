{"sha": "3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMDc3NGQwZGM5ODA4NGQyNWQ5NWNjMTkwOWE4MDUxZWJiZDljYjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-18T15:54:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-18T15:54:59Z"}, "message": "Auto merge of #86700 - lqd:matthews-nll-hrtb-errors, r=nikomatsakis\n\nMatthew's work on improving NLL's \"higher-ranked subtype error\"s\n\nThis PR rebases `@matthewjasper's` [branch](https://github.com/matthewjasper/rust/tree/nll-hrtb-errors) which has great work to fix the obscure higher-ranked subtype errors that are tracked in #57374.\n\nThese are a blocker to turning full NLLs on, and doing some internal cleanups to remove some of the old region code.\n\nThe goal is so `@nikomatsakis` can take a look at this early, and I'll then do my best to help do the changes and followup work to land this work, and move closer to turning off the migration mode.\n\nI've only updated the branch and made it compile, removed a warning or two.\n\nr? `@nikomatsakis`\n\n(Here's the [zulip topic to discuss this](https://rust-lang.zulipchat.com/#narrow/stream/122657-t-compiler.2Fwg-nll/topic/.2357374.3A.20improving.20higher-ranked.20subtype.20errors.20via.20.2386700) that Niko wanted)", "tree": {"sha": "fc3a58189d33e8a6044f15dcd7705bc3f79be7b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc3a58189d33e8a6044f15dcd7705bc3f79be7b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "html_url": "https://github.com/rust-lang/rust/commit/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29d61427ac47dc16c83e1c66b929b1198a3ccc35", "url": "https://api.github.com/repos/rust-lang/rust/commits/29d61427ac47dc16c83e1c66b929b1198a3ccc35", "html_url": "https://github.com/rust-lang/rust/commit/29d61427ac47dc16c83e1c66b929b1198a3ccc35"}, {"sha": "8343806ff5d130f2ad8e0bc9814694864dcb5397", "url": "https://api.github.com/repos/rust-lang/rust/commits/8343806ff5d130f2ad8e0bc9814694864dcb5397", "html_url": "https://github.com/rust-lang/rust/commit/8343806ff5d130f2ad8e0bc9814694864dcb5397"}], "stats": {"total": 1388, "additions": 1043, "deletions": 345}, "files": [{"sha": "3420fe5e61c92f1ec871ca4f42e4950e0da067de", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -4057,6 +4057,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n+ \"rustc_traits\",\n  \"smallvec\",\n  \"tracing\",\n ]"}, {"sha": "3d48d4c2fca6cca30808f4664db22c6cc8a992e2", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1180,16 +1180,26 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     //         |   |\n                     //         |   elided as they were the same\n                     //         not elided, they were different, but irrelevant\n+                    //\n+                    // For bound lifetimes, keep the names of the lifetimes,\n+                    // even if they are the same so that it's clear what's happening\n+                    // if we have something like\n+                    //\n+                    // for<'r, 's> fn(Inv<'r>, Inv<'s>)\n+                    // for<'r> fn(Inv<'r>, Inv<'r>)\n                     let lifetimes = sub1.regions().zip(sub2.regions());\n                     for (i, lifetimes) in lifetimes.enumerate() {\n                         let l1 = lifetime_display(lifetimes.0);\n                         let l2 = lifetime_display(lifetimes.1);\n-                        if lifetimes.0 == lifetimes.1 {\n-                            values.0.push_normal(\"'_\");\n-                            values.1.push_normal(\"'_\");\n-                        } else {\n+                        if lifetimes.0 != lifetimes.1 {\n                             values.0.push_highlighted(l1);\n                             values.1.push_highlighted(l2);\n+                        } else if lifetimes.0.is_late_bound() {\n+                            values.0.push_normal(l1);\n+                            values.1.push_normal(l2);\n+                        } else {\n+                            values.0.push_normal(\"'_\");\n+                            values.1.push_normal(\"'_\");\n                         }\n                         self.push_comma(&mut values.0, &mut values.1, len, i);\n                     }"}, {"sha": "9b9ded5c6bab4a1d1afd6ed89101117308233fc7", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,4 +1,5 @@\n pub use self::freshen::TypeFreshener;\n+pub use self::lexical_region_resolve::RegionResolutionError;\n pub use self::LateBoundRegionConversionTime::*;\n pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n@@ -1110,7 +1111,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// etc) this is the root universe U0. For inference variables or\n     /// placeholders, however, it will return the universe which which\n     /// they are associated.\n-    fn universe_of_region(&self, r: ty::Region<'tcx>) -> ty::UniverseIndex {\n+    pub fn universe_of_region(&self, r: ty::Region<'tcx>) -> ty::UniverseIndex {\n         self.inner.borrow_mut().unwrap_region_constraints().universe(r)\n     }\n \n@@ -1288,6 +1289,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         op(inner.unwrap_region_constraints().data())\n     }\n \n+    pub fn region_var_origin(&self, vid: ty::RegionVid) -> RegionVariableOrigin {\n+        let mut inner = self.inner.borrow_mut();\n+        let inner = &mut *inner;\n+        inner\n+            .region_constraint_storage\n+            .as_mut()\n+            .expect(\"regions already resolved\")\n+            .with_log(&mut inner.undo_log)\n+            .var_origin(vid)\n+    }\n+\n     /// Takes ownership of the list of variable regions. This implies\n     /// that all the region constraints have already been taken, and\n     /// hence that `resolve_regions_and_report_errors` can never be\n@@ -1505,7 +1517,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.inner.borrow_mut().projection_cache().clear();\n     }\n \n-    fn universe(&self) -> ty::UniverseIndex {\n+    pub fn universe(&self) -> ty::UniverseIndex {\n         self.universe.get()\n     }\n "}, {"sha": "5adbfd469a4aef3889d7a17ec599c8c6286667ec", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -445,6 +445,11 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         self.var_infos[vid].universe\n     }\n \n+    /// Returns the origin for the given variable.\n+    pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n+        self.var_infos[vid].origin\n+    }\n+\n     fn add_constraint(&mut self, constraint: Constraint<'tcx>, origin: SubregionOrigin<'tcx>) {\n         // cannot add constraints once regions are resolved\n         debug!(\"RegionConstraintCollector: add_constraint({:?})\", constraint);"}, {"sha": "3049fb3b383b30292f7438823c476758e9998206", "filename": "compiler/rustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2FCargo.toml?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -27,6 +27,7 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n+rustc_traits = { path = \"../rustc_traits\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_apfloat = { path = \"../rustc_apfloat\" }"}, {"sha": "d0284dd03023667ca43d58810bc7e93c961bcc94", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/bound_region_errors.rs", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fbound_region_errors.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -0,0 +1,341 @@\n+use rustc_errors::DiagnosticBuilder;\n+use rustc_infer::infer::canonical::Canonical;\n+use rustc_infer::infer::error_reporting::nice_region_error::NiceRegionError;\n+use rustc_infer::infer::region_constraints::Constraint;\n+use rustc_infer::infer::{InferCtxt, RegionResolutionError, SubregionOrigin, TyCtxtInferExt as _};\n+use rustc_infer::traits::{Normalized, ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_span::Span;\n+use rustc_trait_selection::traits::query::type_op;\n+use rustc_trait_selection::traits::{SelectionContext, TraitEngineExt as _};\n+use rustc_traits::type_op_prove_predicate_with_span;\n+\n+use std::fmt;\n+use std::rc::Rc;\n+\n+use crate::borrow_check::region_infer::values::RegionElement;\n+use crate::borrow_check::MirBorrowckCtxt;\n+\n+#[derive(Clone)]\n+crate struct UniverseInfo<'tcx>(UniverseInfoInner<'tcx>);\n+\n+/// What operation a universe was created for.\n+#[derive(Clone)]\n+enum UniverseInfoInner<'tcx> {\n+    /// Relating two types which have binders.\n+    RelateTys { expected: Ty<'tcx>, found: Ty<'tcx> },\n+    /// Created from performing a `TypeOp`.\n+    TypeOp(Rc<dyn TypeOpInfo<'tcx> + 'tcx>),\n+    /// Any other reason.\n+    Other,\n+}\n+\n+impl UniverseInfo<'tcx> {\n+    crate fn other() -> UniverseInfo<'tcx> {\n+        UniverseInfo(UniverseInfoInner::Other)\n+    }\n+\n+    crate fn relate(expected: Ty<'tcx>, found: Ty<'tcx>) -> UniverseInfo<'tcx> {\n+        UniverseInfo(UniverseInfoInner::RelateTys { expected, found })\n+    }\n+\n+    crate fn report_error(\n+        &self,\n+        mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n+        placeholder: ty::PlaceholderRegion,\n+        error_element: RegionElement,\n+        span: Span,\n+    ) {\n+        match self.0 {\n+            UniverseInfoInner::RelateTys { expected, found } => {\n+                let body_id = mbcx.infcx.tcx.hir().local_def_id_to_hir_id(mbcx.mir_def_id());\n+                let err = mbcx.infcx.report_mismatched_types(\n+                    &ObligationCause::misc(span, body_id),\n+                    expected,\n+                    found,\n+                    TypeError::RegionsPlaceholderMismatch,\n+                );\n+                err.buffer(&mut mbcx.errors_buffer);\n+            }\n+            UniverseInfoInner::TypeOp(ref type_op_info) => {\n+                type_op_info.report_error(mbcx, placeholder, error_element, span);\n+            }\n+            UniverseInfoInner::Other => {\n+                // FIXME: This error message isn't great, but it doesn't show\n+                // up in the existing UI tests. Consider investigating this\n+                // some more.\n+                mbcx.infcx\n+                    .tcx\n+                    .sess\n+                    .struct_span_err(span, \"higher-ranked subtype error\")\n+                    .buffer(&mut mbcx.errors_buffer);\n+            }\n+        }\n+    }\n+}\n+\n+crate trait ToUniverseInfo<'tcx> {\n+    fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx>;\n+}\n+\n+impl<'tcx> ToUniverseInfo<'tcx>\n+    for Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::prove_predicate::ProvePredicate<'tcx>>>\n+{\n+    fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        UniverseInfo(UniverseInfoInner::TypeOp(Rc::new(PredicateQuery {\n+            canonical_query: self,\n+            base_universe,\n+        })))\n+    }\n+}\n+\n+impl<'tcx, T: Copy + fmt::Display + TypeFoldable<'tcx> + 'tcx> ToUniverseInfo<'tcx>\n+    for Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Normalize<T>>>\n+{\n+    fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        UniverseInfo(UniverseInfoInner::TypeOp(Rc::new(NormalizeQuery {\n+            canonical_query: self,\n+            base_universe,\n+        })))\n+    }\n+}\n+\n+impl<'tcx> ToUniverseInfo<'tcx>\n+    for Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::AscribeUserType<'tcx>>>\n+{\n+    fn to_universe_info(self, _base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        // Ascribe user type isn't usually called on types that have different\n+        // bound regions.\n+        UniverseInfo::other()\n+    }\n+}\n+\n+impl<'tcx, F, G> ToUniverseInfo<'tcx> for Canonical<'tcx, type_op::custom::CustomTypeOp<F, G>> {\n+    fn to_universe_info(self, _base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        // We can't rerun custom type ops.\n+        UniverseInfo::other()\n+    }\n+}\n+\n+#[allow(unused_lifetimes)]\n+trait TypeOpInfo<'tcx> {\n+    /// Returns an error to be reported if rerunning the type op fails to\n+    /// recover the error's cause.\n+    fn fallback_error(&self, tcx: TyCtxt<'tcx>, span: Span) -> DiagnosticBuilder<'tcx>;\n+\n+    fn base_universe(&self) -> ty::UniverseIndex;\n+\n+    fn nice_error(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+        placeholder_region: ty::Region<'tcx>,\n+        error_region: Option<ty::Region<'tcx>>,\n+    ) -> Option<DiagnosticBuilder<'tcx>>;\n+\n+    fn report_error(\n+        &self,\n+        mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n+        placeholder: ty::PlaceholderRegion,\n+        error_element: RegionElement,\n+        span: Span,\n+    ) {\n+        let tcx = mbcx.infcx.tcx;\n+        let base_universe = self.base_universe();\n+\n+        let adjusted_universe = if let Some(adjusted) =\n+            placeholder.universe.as_u32().checked_sub(base_universe.as_u32())\n+        {\n+            adjusted\n+        } else {\n+            self.fallback_error(tcx, span).buffer(&mut mbcx.errors_buffer);\n+            return;\n+        };\n+\n+        let placeholder_region = tcx.mk_region(ty::RePlaceholder(ty::Placeholder {\n+            name: placeholder.name,\n+            universe: adjusted_universe.into(),\n+        }));\n+\n+        let error_region =\n+            if let RegionElement::PlaceholderRegion(error_placeholder) = error_element {\n+                let adjusted_universe =\n+                    error_placeholder.universe.as_u32().checked_sub(base_universe.as_u32());\n+                adjusted_universe.map(|adjusted| {\n+                    tcx.mk_region(ty::RePlaceholder(ty::Placeholder {\n+                        name: error_placeholder.name,\n+                        universe: adjusted.into(),\n+                    }))\n+                })\n+            } else {\n+                None\n+            };\n+\n+        debug!(?placeholder_region);\n+\n+        let nice_error = self.nice_error(tcx, span, placeholder_region, error_region);\n+\n+        if let Some(nice_error) = nice_error {\n+            nice_error.buffer(&mut mbcx.errors_buffer);\n+        } else {\n+            self.fallback_error(tcx, span).buffer(&mut mbcx.errors_buffer);\n+        }\n+    }\n+}\n+\n+struct PredicateQuery<'tcx> {\n+    canonical_query:\n+        Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::prove_predicate::ProvePredicate<'tcx>>>,\n+    base_universe: ty::UniverseIndex,\n+}\n+\n+impl TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n+    fn fallback_error(&self, tcx: TyCtxt<'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        let mut err = tcx.sess.struct_span_err(span, \"higher-ranked lifetime error\");\n+        err.note(&format!(\"could not prove {}\", self.canonical_query.value.value.predicate));\n+        err\n+    }\n+\n+    fn base_universe(&self) -> ty::UniverseIndex {\n+        self.base_universe\n+    }\n+\n+    fn nice_error(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+        placeholder_region: ty::Region<'tcx>,\n+        error_region: Option<ty::Region<'tcx>>,\n+    ) -> Option<DiagnosticBuilder<'tcx>> {\n+        tcx.infer_ctxt().enter_with_canonical(span, &self.canonical_query, |ref infcx, key, _| {\n+            let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n+            type_op_prove_predicate_with_span(infcx, &mut *fulfill_cx, key, Some(span));\n+            try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        })\n+    }\n+}\n+\n+struct NormalizeQuery<'tcx, T> {\n+    canonical_query: Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Normalize<T>>>,\n+    base_universe: ty::UniverseIndex,\n+}\n+\n+impl<T> TypeOpInfo<'tcx> for NormalizeQuery<'tcx, T>\n+where\n+    T: Copy + fmt::Display + TypeFoldable<'tcx> + 'tcx,\n+{\n+    fn fallback_error(&self, tcx: TyCtxt<'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        let mut err = tcx.sess.struct_span_err(span, \"higher-ranked lifetime error\");\n+        err.note(&format!(\"could not normalize `{}`\", self.canonical_query.value.value.value));\n+        err\n+    }\n+\n+    fn base_universe(&self) -> ty::UniverseIndex {\n+        self.base_universe\n+    }\n+\n+    fn nice_error(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+        placeholder_region: ty::Region<'tcx>,\n+        error_region: Option<ty::Region<'tcx>>,\n+    ) -> Option<DiagnosticBuilder<'tcx>> {\n+        tcx.infer_ctxt().enter_with_canonical(span, &self.canonical_query, |ref infcx, key, _| {\n+            let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n+\n+            let mut selcx = SelectionContext::new(infcx);\n+\n+            // FIXME(lqd): Unify and de-duplicate the following with the actual\n+            // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n+            // `ObligationCause`. The normalization results are currently different between\n+            // `AtExt::normalize` used in the query and `normalize` called below: the former fails\n+            // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n+            // after #85499 lands to see if its fixes have erased this difference.\n+            let (param_env, value) = key.into_parts();\n+            let Normalized { value: _, obligations } = rustc_trait_selection::traits::normalize(\n+                &mut selcx,\n+                param_env,\n+                ObligationCause::dummy_with_span(span),\n+                value.value,\n+            );\n+            fulfill_cx.register_predicate_obligations(infcx, obligations);\n+\n+            try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        })\n+    }\n+}\n+\n+fn try_extract_error_from_fulfill_cx<'tcx>(\n+    mut fulfill_cx: Box<dyn TraitEngine<'tcx> + 'tcx>,\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    placeholder_region: ty::Region<'tcx>,\n+    error_region: Option<ty::Region<'tcx>>,\n+) -> Option<DiagnosticBuilder<'tcx>> {\n+    let tcx = infcx.tcx;\n+\n+    // We generally shouldn't have errors here because the query was\n+    // already run, but there's no point using `delay_span_bug`\n+    // when we're going to emit an error here anyway.\n+    let _errors = fulfill_cx.select_all_or_error(infcx).err().unwrap_or_else(Vec::new);\n+\n+    let (sub_region, cause) = infcx.with_region_constraints(|region_constraints| {\n+        debug!(?region_constraints);\n+        region_constraints.constraints.iter().find_map(|(constraint, cause)| {\n+            match *constraint {\n+                Constraint::RegSubReg(sub, sup) if sup == placeholder_region && sup != sub => {\n+                    Some((sub, cause.clone()))\n+                }\n+                // FIXME: Should this check the universe of the var?\n+                Constraint::VarSubReg(vid, sup) if sup == placeholder_region => {\n+                    Some((tcx.mk_region(ty::ReVar(vid)), cause.clone()))\n+                }\n+                _ => None,\n+            }\n+        })\n+    })?;\n+\n+    debug!(?sub_region, ?cause);\n+    let nice_error = match (error_region, sub_region) {\n+        (Some(error_region), &ty::ReVar(vid)) => NiceRegionError::new(\n+            infcx,\n+            RegionResolutionError::SubSupConflict(\n+                vid,\n+                infcx.region_var_origin(vid),\n+                cause.clone(),\n+                error_region,\n+                cause.clone(),\n+                placeholder_region,\n+            ),\n+        ),\n+        (Some(error_region), _) => NiceRegionError::new(\n+            infcx,\n+            RegionResolutionError::ConcreteFailure(cause.clone(), error_region, placeholder_region),\n+        ),\n+        // Note universe here is wrong...\n+        (None, &ty::ReVar(vid)) => NiceRegionError::new(\n+            infcx,\n+            RegionResolutionError::UpperBoundUniverseConflict(\n+                vid,\n+                infcx.region_var_origin(vid),\n+                infcx.universe_of_region(sub_region),\n+                cause.clone(),\n+                placeholder_region,\n+            ),\n+        ),\n+        (None, _) => NiceRegionError::new(\n+            infcx,\n+            RegionResolutionError::ConcreteFailure(cause.clone(), sub_region, placeholder_region),\n+        ),\n+    };\n+    nice_error.try_report_from_nll().or_else(|| {\n+        if let SubregionOrigin::Subtype(trace) = cause {\n+            Some(\n+                infcx.report_and_explain_type_error(*trace, &TypeError::RegionsPlaceholderMismatch),\n+            )\n+        } else {\n+            None\n+        }\n+    })\n+}"}, {"sha": "55c6410ed320497730f7e1f90ae03f61a682e139", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -28,12 +28,14 @@ mod outlives_suggestion;\n mod region_name;\n mod var_name;\n \n+mod bound_region_errors;\n mod conflict_errors;\n mod explain_borrow;\n mod move_errors;\n mod mutability_errors;\n mod region_errors;\n \n+crate use bound_region_errors::{ToUniverseInfo, UniverseInfo};\n crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};"}, {"sha": "fe9df41db45e2b9a9c42e137a8cb240188e0fd9c", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -75,8 +75,8 @@ crate enum RegionErrorKind<'tcx> {\n         longer_fr: RegionVid,\n         /// The region element that erroneously must be outlived by `longer_fr`.\n         error_element: RegionElement,\n-        /// The origin of the placeholder region.\n-        fr_origin: NllRegionVariableOrigin,\n+        /// The placeholder region.\n+        placeholder: ty::PlaceholderRegion,\n     },\n \n     /// Any other lifetime error.\n@@ -210,25 +210,23 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 RegionErrorKind::BoundUniversalRegionError {\n                     longer_fr,\n-                    fr_origin,\n+                    placeholder,\n                     error_element,\n                 } => {\n-                    let error_region = self.regioncx.region_from_element(longer_fr, error_element);\n+                    let error_vid = self.regioncx.region_from_element(longer_fr, &error_element);\n \n                     // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n                     let (_, span) = self.regioncx.find_outlives_blame_span(\n                         &self.body,\n                         longer_fr,\n-                        fr_origin,\n-                        error_region,\n+                        NllRegionVariableOrigin::Placeholder(placeholder),\n+                        error_vid,\n                     );\n \n-                    // FIXME: improve this error message\n-                    self.infcx\n-                        .tcx\n-                        .sess\n-                        .struct_span_err(span, \"higher-ranked subtype error\")\n-                        .buffer(&mut self.errors_buffer);\n+                    let universe = placeholder.universe;\n+                    let universe_info = self.regioncx.universe_info(universe);\n+\n+                    universe_info.report_error(self, placeholder, error_element, span);\n                 }\n \n                 RegionErrorKind::RegionError { fr_origin, longer_fr, shorter_fr, is_reported } => {"}, {"sha": "66ca94d3b415d644800462abf385349c43f5982f", "filename": "compiler/rustc_mir/src/borrow_check/nll.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -241,6 +241,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         outlives_constraints,\n         member_constraints,\n         closure_bounds_mapping,\n+        universe_causes,\n         type_tests,\n     } = constraints;\n     let placeholder_indices = Rc::new(placeholder_indices);\n@@ -262,6 +263,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         outlives_constraints,\n         member_constraints,\n         closure_bounds_mapping,\n+        universe_causes,\n         type_tests,\n         liveness_constraints,\n         elements,"}, {"sha": "a96cdbc13f345a2891feb89bb0f55f1f9622de66", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -21,7 +21,7 @@ use crate::borrow_check::{\n     constraints::{\n         graph::NormalConstraintGraph, ConstraintSccIndex, OutlivesConstraint, OutlivesConstraintSet,\n     },\n-    diagnostics::{RegionErrorKind, RegionErrors},\n+    diagnostics::{RegionErrorKind, RegionErrors, UniverseInfo},\n     member_constraints::{MemberConstraintSet, NllMemberConstraintIndex},\n     nll::{PoloniusOutput, ToRegionVid},\n     region_infer::reverse_sccs::ReverseSccGraph,\n@@ -84,6 +84,9 @@ pub struct RegionInferenceContext<'tcx> {\n     closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n+    /// Map universe indexes to information on why we created it.\n+    universe_causes: IndexVec<ty::UniverseIndex, UniverseInfo<'tcx>>,\n+\n     /// Contains the minimum universe of any variable within the same\n     /// SCC. We will ensure that no SCC contains values that are not\n     /// visible from this index.\n@@ -253,6 +256,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             Location,\n             FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n         >,\n+        universe_causes: IndexVec<ty::UniverseIndex, UniverseInfo<'tcx>>,\n         type_tests: Vec<TypeTest<'tcx>>,\n         liveness_constraints: LivenessValues<RegionVid>,\n         elements: &Rc<RegionValueElements>,\n@@ -293,6 +297,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             member_constraints,\n             member_constraints_applied: Vec::new(),\n             closure_bounds_mapping,\n+            universe_causes,\n             scc_universes,\n             scc_representatives,\n             scc_values,\n@@ -1632,7 +1637,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         errors_buffer.push(RegionErrorKind::BoundUniversalRegionError {\n             longer_fr,\n             error_element,\n-            fr_origin: NllRegionVariableOrigin::Placeholder(placeholder),\n+            placeholder,\n         });\n     }\n \n@@ -1918,8 +1923,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Get the region outlived by `longer_fr` and live at `element`.\n-    crate fn region_from_element(&self, longer_fr: RegionVid, element: RegionElement) -> RegionVid {\n-        match element {\n+    crate fn region_from_element(\n+        &self,\n+        longer_fr: RegionVid,\n+        element: &RegionElement,\n+    ) -> RegionVid {\n+        match *element {\n             RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n             RegionElement::RootUniversalRegion(r) => r,\n             RegionElement::PlaceholderRegion(error_placeholder) => self\n@@ -2138,6 +2147,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         categorized_path.remove(0)\n     }\n+\n+    crate fn universe_info(&self, universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        self.universe_causes[universe].clone()\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {"}, {"sha": "9fafcfafe67cdba8ba3b20619ffcfd1dd6361fc7", "filename": "compiler/rustc_mir/src/borrow_check/type_check/canonical.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fcanonical.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -0,0 +1,158 @@\n+use std::fmt;\n+\n+use rustc_hir as hir;\n+use rustc_infer::infer::canonical::Canonical;\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::mir::ConstraintCategory;\n+use rustc_middle::ty::{self, ToPredicate, TypeFoldable};\n+use rustc_span::Span;\n+use rustc_trait_selection::traits::query::type_op::{self, TypeOpOutput};\n+use rustc_trait_selection::traits::query::Fallible;\n+\n+use crate::borrow_check::diagnostics::{ToUniverseInfo, UniverseInfo};\n+\n+use super::{Locations, NormalizeLocation, TypeChecker};\n+\n+impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n+    /// Given some operation `op` that manipulates types, proves\n+    /// predicates, or otherwise uses the inference context, executes\n+    /// `op` and then executes all the further obligations that `op`\n+    /// returns. This will yield a set of outlives constraints amongst\n+    /// regions which are extracted and stored as having occurred at\n+    /// `locations`.\n+    ///\n+    /// **Any `rustc_infer::infer` operations that might generate region\n+    /// constraints should occur within this method so that those\n+    /// constraints can be properly localized!**\n+    pub(super) fn fully_perform_op<R, Op>(\n+        &mut self,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+        op: Op,\n+    ) -> Fallible<R>\n+    where\n+        Op: type_op::TypeOp<'tcx, Output = R>,\n+        Canonical<'tcx, Op>: ToUniverseInfo<'tcx>,\n+    {\n+        let old_universe = self.infcx.universe();\n+\n+        let TypeOpOutput { output, constraints, canonicalized_query } =\n+            op.fully_perform(self.infcx)?;\n+\n+        if let Some(data) = &constraints {\n+            self.push_region_constraints(locations, category, data);\n+        }\n+\n+        let universe = self.infcx.universe();\n+\n+        if old_universe != universe {\n+            let universe_info = match canonicalized_query {\n+                Some(canonicalized_query) => canonicalized_query.to_universe_info(old_universe),\n+                None => UniverseInfo::other(),\n+            };\n+            for u in old_universe..universe {\n+                let info_universe =\n+                    self.borrowck_context.constraints.universe_causes.push(universe_info.clone());\n+                assert_eq!(u.as_u32() + 1, info_universe.as_u32());\n+            }\n+        }\n+\n+        Ok(output)\n+    }\n+\n+    pub(super) fn instantiate_canonical_with_fresh_inference_vars<T>(\n+        &mut self,\n+        span: Span,\n+        canonical: &Canonical<'tcx, T>,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let (instantiated, _) =\n+            self.infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);\n+\n+        for _ in 0..canonical.max_universe.as_u32() {\n+            let info = UniverseInfo::other();\n+            self.borrowck_context.constraints.universe_causes.push(info);\n+        }\n+\n+        instantiated\n+    }\n+\n+    pub(super) fn prove_trait_ref(\n+        &mut self,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) {\n+        self.prove_predicates(\n+            Some(ty::PredicateKind::Trait(ty::TraitPredicate {\n+                trait_ref,\n+                constness: hir::Constness::NotConst,\n+            })),\n+            locations,\n+            category,\n+        );\n+    }\n+\n+    pub(super) fn normalize_and_prove_instantiated_predicates(\n+        &mut self,\n+        instantiated_predicates: ty::InstantiatedPredicates<'tcx>,\n+        locations: Locations,\n+    ) {\n+        for predicate in instantiated_predicates.predicates {\n+            let predicate = self.normalize(predicate, locations);\n+            self.prove_predicate(predicate, locations, ConstraintCategory::Boring);\n+        }\n+    }\n+\n+    pub(super) fn prove_predicates(\n+        &mut self,\n+        predicates: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) {\n+        for predicate in predicates {\n+            let predicate = predicate.to_predicate(self.tcx());\n+            debug!(\"prove_predicates(predicate={:?}, locations={:?})\", predicate, locations,);\n+\n+            self.prove_predicate(predicate, locations, category);\n+        }\n+    }\n+\n+    pub(super) fn prove_predicate(\n+        &mut self,\n+        predicate: ty::Predicate<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) {\n+        debug!(\"prove_predicate(predicate={:?}, location={:?})\", predicate, locations,);\n+\n+        let param_env = self.param_env;\n+        self.fully_perform_op(\n+            locations,\n+            category,\n+            param_env.and(type_op::prove_predicate::ProvePredicate::new(predicate)),\n+        )\n+        .unwrap_or_else(|NoSolution| {\n+            span_mirbug!(self, NoSolution, \"could not prove {:?}\", predicate);\n+        })\n+    }\n+\n+    pub(super) fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n+    where\n+        T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,\n+    {\n+        debug!(\"normalize(value={:?}, location={:?})\", value, location);\n+        let param_env = self.param_env;\n+        self.fully_perform_op(\n+            location.to_locations(),\n+            ConstraintCategory::Boring,\n+            param_env.and(type_op::normalize::Normalize::new(value)),\n+        )\n+        .unwrap_or_else(|NoSolution| {\n+            span_mirbug!(self, NoSolution, \"failed to normalize `{:?}`\", value);\n+            value\n+        })\n+    }\n+}"}, {"sha": "012d67255d13bd6b96171cbb0a48104d6c41eb68", "filename": "compiler/rustc_mir/src/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -11,6 +11,7 @@ use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOp};\n use std::rc::Rc;\n+use type_op::TypeOpOutput;\n \n use crate::borrow_check::{\n     nll::ToRegionVid,\n@@ -255,7 +256,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n         let constraint_sets: Vec<_> = unnormalized_input_output_tys\n             .flat_map(|ty| {\n                 debug!(\"build: input_or_output={:?}\", ty);\n-                let (ty, constraints1) = self\n+                let TypeOpOutput { output: ty, constraints: constraints1, .. } = self\n                     .param_env\n                     .and(type_op::normalize::Normalize::new(ty))\n                     .fully_perform(self.infcx)\n@@ -264,7 +265,11 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                             .tcx\n                             .sess\n                             .delay_span_bug(DUMMY_SP, &format!(\"failed to normalize {:?}\", ty));\n-                        (self.infcx.tcx.ty_error(), None)\n+                        TypeOpOutput {\n+                            output: self.infcx.tcx.ty_error(),\n+                            constraints: None,\n+                            canonicalized_query: None,\n+                        }\n                     });\n                 let constraints2 = self.add_implied_bounds(ty);\n                 normalized_inputs_and_output.push(ty);\n@@ -317,7 +322,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n     /// from this local.\n     fn add_implied_bounds(&mut self, ty: Ty<'tcx>) -> Option<Rc<QueryRegionConstraints<'tcx>>> {\n         debug!(\"add_implied_bounds(ty={:?})\", ty);\n-        let (bounds, constraints) = self\n+        let TypeOpOutput { output: bounds, constraints, .. } = self\n             .param_env\n             .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n             .fully_perform(self.infcx)"}, {"sha": "f8989a7d9df1c2be7e7c018fbdafe2e15651e1a8", "filename": "compiler/rustc_mir/src/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     // Instantiate the canonicalized variables from\n                     // user-provided signature (e.g., the `_` in the code\n                     // above) with fresh variables.\n-                    let (poly_sig, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+                    let poly_sig = self.instantiate_canonical_with_fresh_inference_vars(\n                         body.span,\n                         &user_provided_poly_sig,\n                     );"}, {"sha": "e411f1dc10889d901884a04cd46a711087cdb118", "filename": "compiler/rustc_mir/src/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -5,7 +5,7 @@ use rustc_middle::mir::{BasicBlock, Body, ConstraintCategory, Local, Location};\n use rustc_middle::ty::{Ty, TypeFoldable};\n use rustc_trait_selection::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc_trait_selection::traits::query::type_op::outlives::DropckOutlives;\n-use rustc_trait_selection::traits::query::type_op::TypeOp;\n+use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n use std::rc::Rc;\n \n use crate::dataflow::impls::MaybeInitializedPlaces;\n@@ -519,9 +519,9 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n         debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n \n         let param_env = typeck.param_env;\n-        let (dropck_result, region_constraint_data) =\n+        let TypeOpOutput { output, constraints, .. } =\n             param_env.and(DropckOutlives::new(dropped_ty)).fully_perform(typeck.infcx).unwrap();\n \n-        DropData { dropck_result, region_constraint_data }\n+        DropData { dropck_result: output, region_constraint_data: constraints }\n     }\n }"}, {"sha": "d05e0135dfe76d35af6a41b22f368610a454822f", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 30, "deletions": 123, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -38,7 +38,7 @@ use rustc_trait_selection::opaque_types::{GenerateMemberConstraints, InferCtxtEx\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n-use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n+use rustc_trait_selection::traits::query::Fallible;\n use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligations};\n \n use crate::dataflow::impls::MaybeInitializedPlaces;\n@@ -51,6 +51,7 @@ use crate::transform::{\n use crate::borrow_check::{\n     borrow_set::BorrowSet,\n     constraints::{OutlivesConstraint, OutlivesConstraintSet},\n+    diagnostics::UniverseInfo,\n     facts::AllFacts,\n     location::LocationTable,\n     member_constraints::MemberConstraintSet,\n@@ -89,6 +90,7 @@ macro_rules! span_mirbug_and_err {\n     })\n }\n \n+mod canonical;\n mod constraint_conversion;\n pub mod free_region_relations;\n mod input_output;\n@@ -142,6 +144,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         member_constraints: MemberConstraintSet::default(),\n         closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n+        universe_causes: IndexVec::from_elem_n(UniverseInfo::other(), 1),\n     };\n \n     let CreateResult {\n@@ -156,6 +159,11 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         &mut constraints,\n     );\n \n+    for _ in ty::UniverseIndex::ROOT..infcx.universe() {\n+        let info = UniverseInfo::other();\n+        constraints.universe_causes.push(info);\n+    }\n+\n     let mut borrowck_context = BorrowCheckContext {\n         universal_regions,\n         location_table,\n@@ -376,8 +384,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                                      ty,\n                                      san_ty| {\n                         if let Err(terr) = verifier.cx.eq_types(\n-                            san_ty,\n                             ty,\n+                            san_ty,\n                             location.to_locations(),\n                             ConstraintCategory::Boring,\n                         ) {\n@@ -425,8 +433,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                 let literal_ty = constant.literal.ty().builtin_deref(true).unwrap().ty;\n \n                 if let Err(terr) = self.cx.eq_types(\n-                    normalized_ty,\n                     literal_ty,\n+                    normalized_ty,\n                     locations,\n                     ConstraintCategory::Boring,\n                 ) {\n@@ -542,7 +550,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     return PlaceTy::from_ty(self.tcx().ty_error());\n                 }\n             }\n-            place_ty = self.sanitize_projection(place_ty, elem, place, location)\n+            place_ty = self.sanitize_projection(place_ty, elem, place, location);\n         }\n \n         if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n@@ -916,6 +924,8 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     crate closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n+    crate universe_causes: IndexVec<ty::UniverseIndex, UniverseInfo<'tcx>>,\n+\n     crate type_tests: Vec<TypeTest<'tcx>>,\n }\n \n@@ -1043,8 +1053,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n         for user_annotation in self.user_type_annotations {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n-            let (annotation, _) =\n-                self.infcx.instantiate_canonical_with_fresh_inference_vars(span, user_ty);\n+            let annotation = self.instantiate_canonical_with_fresh_inference_vars(span, user_ty);\n             match annotation {\n                 UserType::Ty(mut ty) => {\n                     ty = self.normalize(ty, Locations::All(span));\n@@ -1097,31 +1106,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n-    /// Given some operation `op` that manipulates types, proves\n-    /// predicates, or otherwise uses the inference context, executes\n-    /// `op` and then executes all the further obligations that `op`\n-    /// returns. This will yield a set of outlives constraints amongst\n-    /// regions which are extracted and stored as having occurred at\n-    /// `locations`.\n-    ///\n-    /// **Any `rustc_infer::infer` operations that might generate region\n-    /// constraints should occur within this method so that those\n-    /// constraints can be properly localized!**\n-    fn fully_perform_op<R>(\n-        &mut self,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-        op: impl type_op::TypeOp<'tcx, Output = R>,\n-    ) -> Fallible<R> {\n-        let (r, opt_data) = op.fully_perform(self.infcx)?;\n-\n-        if let Some(data) = &opt_data {\n-            self.push_region_constraints(locations, category, data);\n-        }\n-\n-        Ok(r)\n-    }\n-\n     fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n@@ -1161,7 +1145,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             b,\n             locations,\n             category,\n-            Some(self.borrowck_context),\n+            self.borrowck_context,\n         )\n     }\n \n@@ -1173,17 +1157,19 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        self.relate_types(sub, ty::Variance::Covariant, sup, locations, category)\n+        // Use this order of parameters because the sup type is usually the\n+        // \"expected\" type in diagnostics.\n+        self.relate_types(sup, ty::Variance::Contravariant, sub, locations, category)\n     }\n \n     fn eq_types(\n         &mut self,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        self.relate_types(a, ty::Variance::Invariant, b, locations, category)\n+        self.relate_types(expected, ty::Variance::Invariant, found, locations, category)\n     }\n \n     fn relate_type_and_user_type(\n@@ -1222,7 +1208,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n \n         let ty = curr_projected_ty.ty;\n-        self.relate_types(a, v, ty, locations, category)?;\n+        self.relate_types(ty, v.xform(ty::Variance::Contravariant), a, locations, category)?;\n \n         Ok(())\n     }\n@@ -2053,8 +2039,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n \n                         if let Err(terr) = self.eq_types(\n-                            ty_fn_ptr_from,\n                             ty,\n+                            ty_fn_ptr_from,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n                         ) {\n@@ -2077,8 +2063,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_fn_ptr_from = tcx.mk_fn_ptr(tcx.signature_unclosure(sig, *unsafety));\n \n                         if let Err(terr) = self.eq_types(\n-                            ty_fn_ptr_from,\n                             ty,\n+                            ty_fn_ptr_from,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n                         ) {\n@@ -2106,8 +2092,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n \n                         if let Err(terr) = self.eq_types(\n-                            ty_fn_ptr_from,\n                             ty,\n+                            ty_fn_ptr_from,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n                         ) {\n@@ -2294,20 +2280,18 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             kind: TypeVariableOriginKind::MiscVariable,\n                             span: body.source_info(location).span,\n                         });\n-                        self.relate_types(\n-                            common_ty,\n-                            ty::Variance::Contravariant,\n+                        self.sub_types(\n                             ty_left,\n+                            common_ty,\n                             location.to_locations(),\n                             ConstraintCategory::Boring,\n                         )\n                         .unwrap_or_else(|err| {\n                             bug!(\"Could not equate type variable with {:?}: {:?}\", ty_left, err)\n                         });\n-                        if let Err(terr) = self.relate_types(\n-                            common_ty,\n-                            ty::Variance::Contravariant,\n+                        if let Err(terr) = self.sub_types(\n                             ty_right,\n+                            common_ty,\n                             location.to_locations(),\n                             ConstraintCategory::Boring,\n                         ) {\n@@ -2682,66 +2666,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         tcx.predicates_of(def_id).instantiate(tcx, substs)\n     }\n \n-    fn prove_trait_ref(\n-        &mut self,\n-        trait_ref: ty::TraitRef<'tcx>,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-    ) {\n-        self.prove_predicates(\n-            Some(ty::PredicateKind::Trait(ty::TraitPredicate {\n-                trait_ref,\n-                constness: hir::Constness::NotConst,\n-            })),\n-            locations,\n-            category,\n-        );\n-    }\n-\n-    fn normalize_and_prove_instantiated_predicates(\n-        &mut self,\n-        instantiated_predicates: ty::InstantiatedPredicates<'tcx>,\n-        locations: Locations,\n-    ) {\n-        for predicate in instantiated_predicates.predicates {\n-            let predicate = self.normalize(predicate, locations);\n-            self.prove_predicate(predicate, locations, ConstraintCategory::Boring);\n-        }\n-    }\n-\n-    fn prove_predicates(\n-        &mut self,\n-        predicates: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-    ) {\n-        for predicate in predicates {\n-            let predicate = predicate.to_predicate(self.tcx());\n-            debug!(\"prove_predicates(predicate={:?}, locations={:?})\", predicate, locations,);\n-\n-            self.prove_predicate(predicate, locations, category);\n-        }\n-    }\n-\n-    fn prove_predicate(\n-        &mut self,\n-        predicate: ty::Predicate<'tcx>,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-    ) {\n-        debug!(\"prove_predicate(predicate={:?}, location={:?})\", predicate, locations,);\n-\n-        let param_env = self.param_env;\n-        self.fully_perform_op(\n-            locations,\n-            category,\n-            param_env.and(type_op::prove_predicate::ProvePredicate::new(predicate)),\n-        )\n-        .unwrap_or_else(|NoSolution| {\n-            span_mirbug!(self, NoSolution, \"could not prove {:?}\", predicate);\n-        })\n-    }\n-\n     fn typeck_mir(&mut self, body: &Body<'tcx>) {\n         self.last_span = body.span;\n         debug!(\"run_on_mir: {:?}\", body.span);\n@@ -2764,23 +2688,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             self.check_iscleanup(&body, block_data);\n         }\n     }\n-\n-    fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n-    where\n-        T: type_op::normalize::Normalizable<'tcx> + Copy + 'tcx,\n-    {\n-        debug!(\"normalize(value={:?}, location={:?})\", value, location);\n-        let param_env = self.param_env;\n-        self.fully_perform_op(\n-            location.to_locations(),\n-            ConstraintCategory::Boring,\n-            param_env.and(type_op::normalize::Normalize::new(value)),\n-        )\n-        .unwrap_or_else(|NoSolution| {\n-            span_mirbug!(self, NoSolution, \"failed to normalize `{:?}`\", value);\n-            value\n-        })\n-    }\n }\n \n trait NormalizeLocation: fmt::Debug + Copy {"}, {"sha": "971c4daa6b311ae49ce41629b202f1fba271d230", "filename": "compiler/rustc_mir/src/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::ty::{self, Const, Ty};\n use rustc_trait_selection::traits::query::Fallible;\n \n use crate::borrow_check::constraints::OutlivesConstraint;\n+use crate::borrow_check::diagnostics::UniverseInfo;\n use crate::borrow_check::type_check::{BorrowCheckContext, Locations};\n \n /// Adds sufficient constraints to ensure that `a R b` where `R` depends on `v`:\n@@ -24,12 +25,19 @@ pub(super) fn relate_types<'tcx>(\n     b: Ty<'tcx>,\n     locations: Locations,\n     category: ConstraintCategory,\n-    borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n+    borrowck_context: &mut BorrowCheckContext<'_, 'tcx>,\n ) -> Fallible<()> {\n     debug!(\"relate_types(a={:?}, v={:?}, b={:?}, locations={:?})\", a, v, b, locations);\n     TypeRelating::new(\n         infcx,\n-        NllTypeRelatingDelegate::new(infcx, borrowck_context, param_env, locations, category),\n+        NllTypeRelatingDelegate::new(\n+            infcx,\n+            borrowck_context,\n+            param_env,\n+            locations,\n+            category,\n+            UniverseInfo::relate(a, b),\n+        ),\n         v,\n     )\n     .relate(a, b)?;\n@@ -38,7 +46,7 @@ pub(super) fn relate_types<'tcx>(\n \n struct NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     infcx: &'me InferCtxt<'me, 'tcx>,\n-    borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n+    borrowck_context: &'me mut BorrowCheckContext<'bccx, 'tcx>,\n \n     param_env: ty::ParamEnv<'tcx>,\n \n@@ -47,17 +55,22 @@ struct NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n \n     /// What category do we assign the resulting `'a: 'b` relationships?\n     category: ConstraintCategory,\n+\n+    /// Information so that error reporting knows what types we are relating\n+    /// when reporting a bound region error.\n+    universe_info: UniverseInfo<'tcx>,\n }\n \n impl NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     fn new(\n         infcx: &'me InferCtxt<'me, 'tcx>,\n-        borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n+        borrowck_context: &'me mut BorrowCheckContext<'bccx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n+        universe_info: UniverseInfo<'tcx>,\n     ) -> Self {\n-        Self { infcx, borrowck_context, param_env, locations, category }\n+        Self { infcx, borrowck_context, param_env, locations, category, universe_info }\n     }\n }\n \n@@ -67,24 +80,20 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n     }\n \n     fn create_next_universe(&mut self) -> ty::UniverseIndex {\n-        self.infcx.create_next_universe()\n+        let info_universe =\n+            self.borrowck_context.constraints.universe_causes.push(self.universe_info.clone());\n+        let universe = self.infcx.create_next_universe();\n+        assert_eq!(info_universe, universe);\n+        universe\n     }\n \n     fn next_existential_region_var(&mut self, from_forall: bool) -> ty::Region<'tcx> {\n-        if self.borrowck_context.is_some() {\n-            let origin = NllRegionVariableOrigin::Existential { from_forall };\n-            self.infcx.next_nll_region_var(origin)\n-        } else {\n-            self.infcx.tcx.lifetimes.re_erased\n-        }\n+        let origin = NllRegionVariableOrigin::Existential { from_forall };\n+        self.infcx.next_nll_region_var(origin)\n     }\n \n     fn next_placeholder_region(&mut self, placeholder: ty::PlaceholderRegion) -> ty::Region<'tcx> {\n-        if let Some(borrowck_context) = &mut self.borrowck_context {\n-            borrowck_context.constraints.placeholder_region(self.infcx, placeholder)\n-        } else {\n-            self.infcx.tcx.lifetimes.re_erased\n-        }\n+        self.borrowck_context.constraints.placeholder_region(self.infcx, placeholder)\n     }\n \n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n@@ -100,17 +109,15 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n         sub: ty::Region<'tcx>,\n         info: ty::VarianceDiagInfo<'tcx>,\n     ) {\n-        if let Some(borrowck_context) = &mut self.borrowck_context {\n-            let sub = borrowck_context.universal_regions.to_region_vid(sub);\n-            let sup = borrowck_context.universal_regions.to_region_vid(sup);\n-            borrowck_context.constraints.outlives_constraints.push(OutlivesConstraint {\n-                sup,\n-                sub,\n-                locations: self.locations,\n-                category: self.category,\n-                variance_info: info,\n-            });\n-        }\n+        let sub = self.borrowck_context.universal_regions.to_region_vid(sub);\n+        let sup = self.borrowck_context.universal_regions.to_region_vid(sup);\n+        self.borrowck_context.constraints.outlives_constraints.push(OutlivesConstraint {\n+            sup,\n+            sub,\n+            locations: self.locations,\n+            category: self.category,\n+            variance_info: info,\n+        });\n     }\n \n     // We don't have to worry about the equality of consts during borrow checking"}, {"sha": "b5398f8a4353b222599a49f008bb91a8ccc47035", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,13 +1,13 @@\n-use crate::infer::{InferCtxt, InferOk};\n-use crate::traits::query::Fallible;\n-use std::fmt;\n-\n use crate::infer::canonical::query_response;\n-use crate::infer::canonical::QueryRegionConstraints;\n+use crate::infer::{InferCtxt, InferOk};\n use crate::traits::engine::TraitEngineExt as _;\n+use crate::traits::query::type_op::TypeOpOutput;\n+use crate::traits::query::Fallible;\n use crate::traits::{ObligationCause, TraitEngine};\n use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::DUMMY_SP;\n+\n+use std::fmt;\n use std::rc::Rc;\n \n pub struct CustomTypeOp<F, G> {\n@@ -35,10 +35,7 @@ where\n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n     /// (they will be given over to the NLL region solver).\n-    fn fully_perform(\n-        self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Fallible<(Self::Output, Option<Rc<QueryRegionConstraints<'tcx>>>)> {\n+    fn fully_perform(self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n         if cfg!(debug_assertions) {\n             info!(\"fully_perform({:?})\", self);\n         }\n@@ -58,10 +55,10 @@ where\n \n /// Executes `op` and then scrapes out all the \"old style\" region\n /// constraints that result, creating query-region-constraints.\n-fn scrape_region_constraints<'tcx, R>(\n+fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n-) -> Fallible<(R, Option<Rc<QueryRegionConstraints<'tcx>>>)> {\n+) -> Fallible<TypeOpOutput<'tcx, Op>> {\n     let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n     let dummy_body_id = ObligationCause::dummy().body_id;\n \n@@ -101,8 +98,12 @@ fn scrape_region_constraints<'tcx, R>(\n     );\n \n     if region_constraints.is_empty() {\n-        Ok((value, None))\n+        Ok(TypeOpOutput { output: value, constraints: None, canonicalized_query: None })\n     } else {\n-        Ok((value, Some(Rc::new(region_constraints))))\n+        Ok(TypeOpOutput {\n+            output: value,\n+            constraints: Some(Rc::new(region_constraints)),\n+            canonicalized_query: None,\n+        })\n     }\n }"}, {"sha": "3863dd61cefc09894f542ac784cd5f3d8b94f645", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -3,7 +3,7 @@ use crate::traits::query::outlives_bounds::OutlivesBound;\n use crate::traits::query::Fallible;\n use rustc_middle::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n-#[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n+#[derive(Copy, Clone, Debug, HashStable, TypeFoldable, Lift)]\n pub struct ImpliedOutlivesBounds<'tcx> {\n     pub ty: Ty<'tcx>,\n }"}, {"sha": "12ca3faeb379785e34b8f3b1c3e55ab6b3726743", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -4,6 +4,7 @@ use crate::infer::canonical::{\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits::query::Fallible;\n use crate::traits::ObligationCause;\n+use rustc_infer::infer::canonical::Canonical;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n use std::fmt;\n@@ -30,10 +31,18 @@ pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n     /// (they will be given over to the NLL region solver).\n-    fn fully_perform(\n-        self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Fallible<(Self::Output, Option<Rc<QueryRegionConstraints<'tcx>>>)>;\n+    fn fully_perform(self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>>;\n+}\n+\n+/// The output from performing a type op\n+pub struct TypeOpOutput<'tcx, Op: TypeOp<'tcx>> {\n+    /// The output from the type op.\n+    pub output: Op::Output,\n+    /// Any region constraints from performing the type op.\n+    pub constraints: Option<Rc<QueryRegionConstraints<'tcx>>>,\n+    /// The canonicalized form of the query.\n+    /// This for error reporting to be able to rerun the query.\n+    pub canonicalized_query: Option<Canonical<'tcx, Op>>,\n }\n \n /// \"Query type ops\" are type ops that are implemented using a\n@@ -45,7 +54,7 @@ pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n /// which produces the resulting query region constraints.\n ///\n /// [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html\n-pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n+pub trait QueryTypeOp<'tcx>: fmt::Debug + Copy + TypeFoldable<'tcx> + 'tcx {\n     type QueryResponse: TypeFoldable<'tcx>;\n \n     /// Give query the option for a simple fast path that never\n@@ -71,9 +80,9 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n         query_key: ParamEnvAnd<'tcx, Self>,\n         infcx: &InferCtxt<'_, 'tcx>,\n         output_query_region_constraints: &mut QueryRegionConstraints<'tcx>,\n-    ) -> Fallible<Self::QueryResponse> {\n+    ) -> Fallible<(Self::QueryResponse, Option<Canonical<'tcx, ParamEnvAnd<'tcx, Self>>>)> {\n         if let Some(result) = QueryTypeOp::try_fast_path(infcx.tcx, &query_key) {\n-            return Ok(result);\n+            return Ok((result, None));\n         }\n \n         // FIXME(#33684) -- We need to use\n@@ -101,14 +110,14 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n         // create obligations. In that case, we have to go\n         // fulfill them. We do this via a (recursive) query.\n         for obligation in obligations {\n-            let () = ProvePredicate::fully_perform_into(\n+            let ((), _) = ProvePredicate::fully_perform_into(\n                 obligation.param_env.and(ProvePredicate::new(obligation.predicate)),\n                 infcx,\n                 output_query_region_constraints,\n             )?;\n         }\n \n-        Ok(value)\n+        Ok((value, Some(canonical_self)))\n     }\n }\n \n@@ -118,18 +127,16 @@ where\n {\n     type Output = Q::QueryResponse;\n \n-    fn fully_perform(\n-        self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Fallible<(Self::Output, Option<Rc<QueryRegionConstraints<'tcx>>>)> {\n+    fn fully_perform(self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n         let mut region_constraints = QueryRegionConstraints::default();\n-        let r = Q::fully_perform_into(self, infcx, &mut region_constraints)?;\n+        let (output, canonicalized_query) =\n+            Q::fully_perform_into(self, infcx, &mut region_constraints)?;\n \n         // Promote the final query-region-constraints into a\n         // (optional) ref-counted vector:\n-        let opt_qrc =\n+        let region_constraints =\n             if region_constraints.is_empty() { None } else { Some(Rc::new(region_constraints)) };\n \n-        Ok((r, opt_qrc))\n+        Ok(TypeOpOutput { output, constraints: region_constraints, canonicalized_query })\n     }\n }"}, {"sha": "8dd7c5bdfaebc84183c92f19b35dd218f123ad5e", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -19,6 +19,8 @@ mod normalize_erasing_regions;\n mod normalize_projection_ty;\n mod type_op;\n \n+pub use type_op::type_op_prove_predicate_with_span;\n+\n use rustc_middle::ty::query::Providers;\n \n pub fn provide(p: &mut Providers) {"}, {"sha": "c2e0a9987858eac0bb75a3e69f796719d874f4d1", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArg, Subst, UserSelfTy, UserSubsts};\n use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable, Variance};\n use rustc_middle::ty::{ParamEnv, ParamEnvAnd, Predicate, ToPredicate};\n-use rustc_span::DUMMY_SP;\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n@@ -236,11 +236,25 @@ fn type_op_prove_predicate<'tcx>(\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, ProvePredicate<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n-        let (param_env, ProvePredicate { predicate }) = key.into_parts();\n-        fulfill_cx.register_predicate_obligation(\n-            infcx,\n-            Obligation::new(ObligationCause::dummy(), param_env, predicate),\n-        );\n+        type_op_prove_predicate_with_span(infcx, fulfill_cx, key, None);\n         Ok(())\n     })\n }\n+\n+/// The core of the `type_op_prove_predicate` query: for diagnostics purposes in NLL HRTB errors,\n+/// this query can be re-run to better track the span of the obligation cause, and improve the error\n+/// message. Do not call directly unless you're in that very specific context.\n+pub fn type_op_prove_predicate_with_span<'a, 'tcx: 'a>(\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    fulfill_cx: &'a mut dyn TraitEngine<'tcx>,\n+    key: ParamEnvAnd<'tcx, ProvePredicate<'tcx>>,\n+    span: Option<Span>,\n+) {\n+    let cause = if let Some(span) = span {\n+        ObligationCause::dummy_with_span(span)\n+    } else {\n+        ObligationCause::dummy()\n+    };\n+    let (param_env, ProvePredicate { predicate }) = key.into_parts();\n+    fulfill_cx.register_predicate_obligation(infcx, Obligation::new(cause, param_env, predicate));\n+}"}, {"sha": "59e27cd2e7dd6e2b8bc014d8bb37bc4acb0e9d4e", "filename": "src/test/ui/associated-types/higher-ranked-projection.bad.nll.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,12 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/higher-ranked-projection.rs:25:5\n    |\n LL |     foo(());\n-   |     ^^^^^^^\n+   |     ^^^^^^^ one type is more general than the other\n+   |\n+   = note:   expected type `&'a ()`\n+           found reference `&()`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "768dc8e12db504861158dff33e4006d3f71b6c13", "filename": "src/test/ui/closure-expected-type/expect-fn-supply-fn.nll.stderr", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -21,23 +21,33 @@ LL |     with_closure_expecting_fn_with_free_region(|x: fn(&'x u32), y| {});\n    |\n    = help: consider replacing `'x` with `'static`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/expect-fn-supply-fn.rs:32:49\n    |\n LL |     with_closure_expecting_fn_with_free_region(|x: fn(&u32), y| {});\n-   |                                                 ^\n+   |                                                 ^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r> fn(&'r u32)`\n+              found fn pointer `fn(&u32)`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/expect-fn-supply-fn.rs:39:50\n    |\n LL |     with_closure_expecting_fn_with_bound_region(|x: fn(&'x u32), y| {});\n-   |                                                  ^\n+   |                                                  ^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `fn(&'x u32)`\n+              found fn pointer `for<'r> fn(&'r u32)`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/expect-fn-supply-fn.rs:48:50\n    |\n LL |     with_closure_expecting_fn_with_bound_region(|x: Foo<'_>, y| {\n-   |                                                  ^\n+   |                                                  ^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `fn(&u32)`\n+              found fn pointer `for<'r> fn(&'r u32)`\n \n error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "76970fb7872142f0260cb46ed333c13c9ea10039", "filename": "src/test/ui/generator/auto-trait-regions.nll.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -24,17 +24,23 @@ LL |         assert_foo(a);\n    |\n    = note: consider using a `let` binding to create a longer lived value\n \n-error: higher-ranked subtype error\n+error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:31:5\n    |\n LL |     assert_foo(gen);\n-   |     ^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `&'0 OnlyFooIfStaticRef` must implement `Foo`, for any lifetime `'0`...\n+   = note: ...but `Foo` is actually implemented for the type `&'static OnlyFooIfStaticRef`\n \n-error: higher-ranked subtype error\n+error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:50:5\n    |\n LL |     assert_foo(gen);\n-   |     ^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `Foo` would have to be implemented for the type `A<'0, '1>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but `Foo` is actually implemented for the type `A<'_, '2>`, for some specific lifetime `'2`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "25bc6afc550b3a08e9ae3cbc115b2f81d5c13792", "filename": "src/test/ui/generator/resume-arg-late-bound.nll.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,12 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/resume-arg-late-bound.rs:15:5\n    |\n LL |     test(gen);\n-   |     ^^^^^^^^^\n+   |     ^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'a> Generator<&'a mut bool>`\n+              found type `Generator<&mut bool>`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "d617571753c1d28559ab06c4de64756a359d184b", "filename": "src/test/ui/higher-rank-trait-bounds/issue-59311.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -14,7 +14,7 @@ pub fn crash<V>(v: &V)\n where\n     for<'a> &'a V: T + 'static,\n {\n-    v.t(|| {}); //~ ERROR: higher-ranked subtype error\n+    v.t(|| {}); //~ ERROR: higher-ranked lifetime error\n }\n \n fn main() {}"}, {"sha": "c16c8206153248d8202e782e21b85c7d79e39073", "filename": "src/test/ui/higher-rank-trait-bounds/issue-59311.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,10 @@\n-error: higher-ranked subtype error\n+error: higher-ranked lifetime error\n   --> $DIR/issue-59311.rs:17:9\n    |\n LL |     v.t(|| {});\n    |         ^^^^^\n+   |\n+   = note: could not prove for<'a> &'a V: 'static\n \n error: aborting due to previous error\n "}, {"sha": "439a113ef38112226b3cac1ec5e0792d7351e74b", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,14 +1,17 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/hr-subtype.rs:45:13\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n ...\n LL | / check! { bound_a_b_ret_a_vs_bound_a_ret_a: (for<'a,'b> fn(&'a u32, &'b u32) -> &'a u32,\n LL | | for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }\n    | |_____________________________________________- in this macro invocation\n    |\n+   = note: expected enum `Option<for<'r, 's> fn(&'r u32, &'s u32) -> &'r u32>`\n+              found enum `Option<for<'r> fn(&'r u32, &'r u32) -> &'r u32>`\n    = note: this error originates in the macro `check` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "61b3f0ca2847c60b75b9d92d230e3a51bcc1a8cf", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_free_x.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,14 +1,17 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/hr-subtype.rs:45:13\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n ...\n LL | / check! { bound_a_vs_free_x: (for<'a> fn(&'a u32),\n LL | | fn(&'x u32)) }\n    | |______________- in this macro invocation\n    |\n+   = note: expected enum `Option<for<'r> fn(&'r u32)>`\n+              found enum `Option<fn(&u32)>`\n    = note: this error originates in the macro `check` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "75e2ba58f33fbe9391347a3e349f1341272205d3", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_inv_a_b_vs_bound_inv_a.nll.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,26 +1,31 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/hr-subtype.rs:45:13\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n ...\n LL | / check! { bound_inv_a_b_vs_bound_inv_a: (for<'a,'b> fn(Inv<'a>, Inv<'b>),\n LL | | for<'a>    fn(Inv<'a>, Inv<'a>)) }\n    | |__________________________________- in this macro invocation\n    |\n+   = note: expected enum `Option<for<'r, 's> fn(Inv<'r>, Inv<'s>)>`\n+              found enum `Option<for<'r> fn(Inv<'r>, Inv<'r>)>`\n    = note: this error originates in the macro `check` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/hr-subtype.rs:45:13\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n ...\n LL | / check! { bound_inv_a_b_vs_bound_inv_a: (for<'a,'b> fn(Inv<'a>, Inv<'b>),\n LL | | for<'a>    fn(Inv<'a>, Inv<'a>)) }\n    | |__________________________________- in this macro invocation\n    |\n+   = note: expected enum `Option<for<'r, 's> fn(Inv<'r>, Inv<'s>)>`\n+              found enum `Option<for<'r> fn(Inv<'r>, Inv<'r>)>`\n    = note: this error originates in the macro `check` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "46f5308dd87ba4cb193cc6884f806743790f883f", "filename": "src/test/ui/hrtb/hrtb-conflate-regions.nll.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,14 +1,20 @@\n-error: higher-ranked subtype error\n+error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-conflate-regions.rs:27:10\n    |\n LL | fn b() { want_foo2::<SomeStruct>(); }\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `SomeStruct` must implement `Foo<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `Foo<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n-error: higher-ranked subtype error\n+error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-conflate-regions.rs:27:10\n    |\n LL | fn b() { want_foo2::<SomeStruct>(); }\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `SomeStruct` must implement `Foo<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `Foo<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1ee3c67496397e032e68446477414f586f20005d", "filename": "src/test/ui/hrtb/hrtb-exists-forall-fn.nll.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,12 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/hrtb-exists-forall-fn.rs:17:12\n    |\n LL |     let _: for<'b> fn(&'b u32) = foo();\n-   |            ^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'b> fn(&'b u32)`\n+              found fn pointer `fn(&u32)`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "364b613fc7717b87ac4401c7d5edaa7883bad873", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-contravariant.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,11 @@\n-error: higher-ranked subtype error\n+error: implementation of `Trait` is not general enough\n   --> $DIR/hrtb-exists-forall-trait-contravariant.rs:34:5\n    |\n LL |     foo::<()>();\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ implementation of `Trait` is not general enough\n+   |\n+   = note: `()` must implement `Trait<for<'b> fn(&'b u32)>`\n+   = note: ...but it actually implements `Trait<fn(&'0 u32)>`, for some specific lifetime `'0`\n \n error: aborting due to previous error\n "}, {"sha": "cb2ce8a4116aa887b5621130f33e9f5e1bbd391d", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-invariant.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,11 @@\n-error: higher-ranked subtype error\n+error: implementation of `Trait` is not general enough\n   --> $DIR/hrtb-exists-forall-trait-invariant.rs:28:5\n    |\n LL |     foo::<()>();\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ implementation of `Trait` is not general enough\n+   |\n+   = note: `()` must implement `Trait<for<'b> fn(Cell<&'b u32>)>`\n+   = note: ...but it actually implements `Trait<fn(Cell<&'0 u32>)>`, for some specific lifetime `'0`\n \n error: aborting due to previous error\n "}, {"sha": "a812282def9a80835779b90b0707d81e9eb2b2fa", "filename": "src/test/ui/hrtb/hrtb-just-for-static.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,11 @@\n-error: higher-ranked subtype error\n+error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-just-for-static.rs:24:5\n    |\n LL |     want_hrtb::<StaticInt>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `StaticInt` must implement `Foo<&'0 isize>`, for any lifetime `'0`...\n+   = note: ...but it actually implements `Foo<&'static isize>`\n \n error: lifetime may not live long enough\n   --> $DIR/hrtb-just-for-static.rs:30:5"}, {"sha": "aefe3cdfd6487a00466de9cef3ef7e1b68967e4f", "filename": "src/test/ui/hrtb/hrtb-perfect-forwarding.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -57,11 +57,14 @@ LL |     foo_hrtb_bar_not(&mut t);\n    |\n    = help: consider replacing `'b` with `'static`\n \n-error: higher-ranked subtype error\n+error: implementation of `Bar` is not general enough\n   --> $DIR/hrtb-perfect-forwarding.rs:43:5\n    |\n LL |     foo_hrtb_bar_not(&mut t);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Bar` is not general enough\n+   |\n+   = note: `T` must implement `Bar<&'0 isize>`, for any lifetime `'0`...\n+   = note: ...but it actually implements `Bar<&'1 isize>`, for some specific lifetime `'1`\n \n warning: function cannot return without recursing\n   --> $DIR/hrtb-perfect-forwarding.rs:48:1"}, {"sha": "309e1a676edafa4669f72f15f32c129f69cf4e50", "filename": "src/test/ui/hrtb/issue-46989.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,11 @@\n-error: higher-ranked subtype error\n+error: implementation of `Foo` is not general enough\n   --> $DIR/issue-46989.rs:38:5\n    |\n LL |     assert_foo::<fn(&i32)>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `Foo` would have to be implemented for the type `for<'r> fn(&'r i32)`\n+   = note: ...but `Foo` is actually implemented for the type `fn(&'0 i32)`, for some specific lifetime `'0`\n \n error: aborting due to previous error\n "}, {"sha": "e6f0b5fbfba1dc098b8501a9f22a5a1e19c07707", "filename": "src/test/ui/issues/issue-40000.nll.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fissues%2Fissue-40000.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fissues%2Fissue-40000.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40000.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,14 +1,21 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/issue-40000.rs:6:9\n    |\n LL |     foo(bar);\n-   |         ^^^\n+   |         ^^^ one type is more general than the other\n+   |\n+   = note: expected trait object `dyn for<'r> Fn(&'r i32)`\n+              found trait object `dyn Fn(&i32)`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/issue-40000.rs:6:9\n    |\n LL |     foo(bar);\n-   |         ^^^\n+   |         ^^^ one type is more general than the other\n+   |\n+   = note: expected trait object `dyn for<'r> Fn(&'r i32)`\n+              found trait object `dyn Fn(&i32)`\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "6e8b69c4beebb2bfbfefb11ab6b43ba18d580a83", "filename": "src/test/ui/issues/issue-54302-cases.nll.stderr", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,26 +1,38 @@\n-error: higher-ranked subtype error\n+error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:63:5\n    |\n LL |     <u32 as RefFoo<u32>>::ref_foo(a)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `Foo<'static, u32>` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n+   = note: ...but `Foo<'_, u32>` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n \n-error: higher-ranked subtype error\n+error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:69:5\n    |\n LL |     <i32 as RefFoo<i32>>::ref_foo(a)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `Foo<'static, i32>` would have to be implemented for the type `&'0 i32`, for any lifetime `'0`...\n+   = note: ...but `Foo<'_, i32>` is actually implemented for the type `&'1 i32`, for some specific lifetime `'1`\n \n-error: higher-ranked subtype error\n+error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:75:5\n    |\n LL |     <u64 as RefFoo<u64>>::ref_foo(a)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `Foo<'static, u64>` would have to be implemented for the type `&'0 u64`, for any lifetime `'0`...\n+   = note: ...but `Foo<'_, u64>` is actually implemented for the type `&'1 u64`, for some specific lifetime `'1`\n \n-error: higher-ranked subtype error\n+error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:81:5\n    |\n LL |     <i64 as RefFoo<i64>>::ref_foo(a)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `Foo<'static, i64>` would have to be implemented for the type `&'0 i64`, for any lifetime `'0`...\n+   = note: ...but `Foo<'_, i64>` is actually implemented for the type `&'1 i64`, for some specific lifetime `'1`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "97fd6678c997e6d959bd61680b7ab1bc2b947ae4", "filename": "src/test/ui/issues/issue-55731.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fissues%2Fissue-55731.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fissues%2Fissue-55731.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55731.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,11 +1,14 @@\n-error: higher-ranked subtype error\n+error: implementation of `DistributedIteratorMulti` is not general enough\n   --> $DIR/issue-55731.rs:48:5\n    |\n LL | /     multi(Map {\n LL | |         i: Cloned(PhantomData),\n LL | |         f: X,\n LL | |     });\n-   | |______^\n+   | |______^ implementation of `DistributedIteratorMulti` is not general enough\n+   |\n+   = note: `DistributedIteratorMulti<&'0 ()>` would have to be implemented for the type `Cloned<&()>`, for any lifetime `'0`...\n+   = note: ...but `DistributedIteratorMulti<&'1 ()>` is actually implemented for the type `Cloned<&'1 ()>`, for some specific lifetime `'1`\n \n error: aborting due to previous error\n "}, {"sha": "2ab49ec61cf597ef187b72d897312e9ffd112962", "filename": "src/test/ui/issues/issue-57843.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fissues%2Fissue-57843.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fissues%2Fissue-57843.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57843.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,11 @@\n-error: higher-ranked subtype error\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue-57843.rs:25:9\n    |\n LL |     Foo(Box::new(|_| ()));\n-   |         ^^^^^^^^^^^^^^^^\n+   |         ^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'2 bool)` must implement `FnOnce<(&'1 bool,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 bool,)>`, for some specific lifetime `'2`\n \n error: aborting due to previous error\n "}, {"sha": "907b43d6762e98e51a36463b5a110ec222920a89", "filename": "src/test/ui/lifetimes/issue-79187-2.nll.stderr", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187-2.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -16,29 +16,47 @@ LL |     take_foo(|a: &i32| -> &i32 { a });\n    |                  |        let's call the lifetime of this reference `'2`\n    |                  let's call the lifetime of this reference `'1`\n \n-error: higher-ranked subtype error\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue-79187-2.rs:8:5\n    |\n LL |     take_foo(|a| a);\n-   |     ^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'2 i32) -> &i32` must implement `FnOnce<(&'1 i32,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 i32,)>`, for some specific lifetime `'2`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/issue-79187-2.rs:8:5\n    |\n LL |     take_foo(|a| a);\n-   |     ^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'r> Fn<(&'r i32,)>`\n+              found type `Fn<(&i32,)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/issue-79187-2.rs:8:14\n+   |\n+LL |     take_foo(|a| a);\n+   |              ^^^^^\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/issue-79187-2.rs:9:5\n    |\n LL |     take_foo(|a: &i32| a);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected reference `&i32`\n+              found reference `&i32`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/issue-79187-2.rs:10:5\n    |\n LL |     take_foo(|a: &i32| -> &i32 { a });\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected reference `&i32`\n+              found reference `&i32`\n \n error: aborting due to 6 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "725b132e83a12b0aaeb5596bfc2cba9c9b1b36ec", "filename": "src/test/ui/lifetimes/issue-79187.nll.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,14 +1,26 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/issue-79187.rs:5:5\n    |\n LL |     thing(f);\n-   |     ^^^^^^^^\n+   |     ^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'r> FnOnce<(&'r u32,)>`\n+              found type `FnOnce<(&u32,)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/issue-79187.rs:4:13\n+   |\n+LL |     let f = |_| ();\n+   |             ^^^^^^\n \n-error: higher-ranked subtype error\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue-79187.rs:5:5\n    |\n LL |     thing(f);\n-   |     ^^^^^^^^\n+   |     ^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'2 u32)` must implement `FnOnce<(&'1 u32,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 u32,)>`, for some specific lifetime `'2`\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "3fdc2da9f1e2e3f0c22ae2ed344937a965b2149e", "filename": "src/test/ui/lub-glb/old-lub-glb-hr-noteq1.nll.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq1.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,12 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/old-lub-glb-hr-noteq1.rs:11:14\n    |\n LL |         _ => y,\n-   |              ^\n+   |              ^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r, 's> fn(&'r u8, &'s u8) -> &'r u8`\n+              found fn pointer `for<'r> fn(&'r u8, &'r u8) -> &'r u8`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "ad14d6b7521bcaf97090931114f75e66e350f341", "filename": "src/test/ui/lub-glb/old-lub-glb-object.nll.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,14 +1,21 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/old-lub-glb-object.rs:10:14\n    |\n LL |         _ => y,\n-   |              ^\n+   |              ^ one type is more general than the other\n+   |\n+   = note: expected trait object `dyn for<'r, 's> Foo<&'r u8, &'s u8>`\n+              found trait object `dyn for<'r> Foo<&'r u8, &'r u8>`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/old-lub-glb-object.rs:10:14\n    |\n LL |         _ => y,\n-   |              ^\n+   |              ^ one type is more general than the other\n+   |\n+   = note: expected trait object `dyn for<'r, 's> Foo<&'r u8, &'s u8>`\n+              found trait object `dyn for<'r> Foo<&'r u8, &'r u8>`\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "f29126e6afc76c7430e0896533fcf2510ab7516d", "filename": "src/test/ui/mismatched_types/closure-mismatch.nll.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,14 +1,26 @@\n-error: higher-ranked subtype error\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/closure-mismatch.rs:8:5\n    |\n LL |     baz(|_| ());\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'2 ())` must implement `FnOnce<(&'1 (),)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 (),)>`, for some specific lifetime `'2`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/closure-mismatch.rs:8:5\n    |\n LL |     baz(|_| ());\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'r> Fn<(&'r (),)>`\n+              found type `Fn<(&(),)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/closure-mismatch.rs:8:9\n+   |\n+LL |     baz(|_| ());\n+   |         ^^^^^^\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "0730dcc9e497821f122a0253bad1bf5cd98bcdb5", "filename": "src/test/ui/nll/relate_tys/fn-subtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -6,5 +6,5 @@\n \n fn main() {\n     let x: fn(&'static ()) = |_| {};\n-    let y: for<'a> fn(&'a ()) = x; //~ ERROR higher-ranked subtype error\n+    let y: for<'a> fn(&'a ()) = x; //~ ERROR mismatched types [E0308]\n }"}, {"sha": "94def6900867795ca0adfe8246effba8e3c2c542", "filename": "src/test/ui/nll/relate_tys/fn-subtype.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,12 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/fn-subtype.rs:9:33\n    |\n LL |     let y: for<'a> fn(&'a ()) = x;\n-   |                                 ^\n+   |                                 ^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r> fn(&'r ())`\n+              found fn pointer `fn(&())`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "a6d6ffa0ce3d2d8dfc209826d69e7009c4b08988", "filename": "src/test/ui/nll/relate_tys/hr-fn-aaa-as-aba.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -12,15 +12,15 @@ fn make_it() -> for<'a> fn(&'a u32, &'a u32) -> &'a u32 {\n \n fn foo() {\n     let a: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n-    //~^ ERROR higher-ranked subtype error\n+    //~^ ERROR mismatched types [E0308]\n     drop(a);\n }\n \n fn bar() {\n     // The code path for patterns is mildly different, so go ahead and\n     // test that too:\n     let _: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n-    //~^ ERROR higher-ranked subtype error\n+    //~^ ERROR mismatched types [E0308]\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "8c1eaeb6aa7b9777aa61243a0b7a64a460976f64", "filename": "src/test/ui/nll/relate_tys/hr-fn-aaa-as-aba.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,14 +1,21 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/hr-fn-aaa-as-aba.rs:14:58\n    |\n LL |     let a: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n-   |                                                          ^^^^^^^^^\n+   |                                                          ^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r, 's> fn(&'r u32, &'s u32) -> &'r u32`\n+              found fn pointer `for<'a> fn(&'a u32, &'a u32) -> &'a u32`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/hr-fn-aaa-as-aba.rs:22:12\n    |\n LL |     let _: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32`\n+              found fn pointer `for<'r> fn(&'r u32, &'r u32) -> &'r u32`\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "37a01f28946d204fa83357f296aef362febd21b3", "filename": "src/test/ui/nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -30,6 +30,6 @@ impl<T> Y for fn(T) {\n \n fn main() {\n     let _x = <fn(&())>::make_f();\n-    //~^ higher-ranked subtype error\n-    //~| higher-ranked subtype error\n+    //~^ ERROR implementation of `Y` is not general enough\n+    //~| ERROR implementation of `Y` is not general enough\n }"}, {"sha": "ed79c7df25e2a0aa0dab078bc195b2e0eb44cafd", "filename": "src/test/ui/nll/relate_tys/impl-fn-ignore-binder-via-bottom.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,14 +1,20 @@\n-error: higher-ranked subtype error\n+error: implementation of `Y` is not general enough\n   --> $DIR/impl-fn-ignore-binder-via-bottom.rs:32:14\n    |\n LL |     let _x = <fn(&())>::make_f();\n-   |              ^^^^^^^^^^^^^^^^^^^\n+   |              ^^^^^^^^^^^^^^^^^^^ implementation of `Y` is not general enough\n+   |\n+   = note: `Y` would have to be implemented for the type `for<'r> fn(&'r ())`\n+   = note: ...but `Y` is actually implemented for the type `fn(&'0 ())`, for some specific lifetime `'0`\n \n-error: higher-ranked subtype error\n+error: implementation of `Y` is not general enough\n   --> $DIR/impl-fn-ignore-binder-via-bottom.rs:32:14\n    |\n LL |     let _x = <fn(&())>::make_f();\n-   |              ^^^^^^^^^^^^^^^^^^^\n+   |              ^^^^^^^^^^^^^^^^^^^ implementation of `Y` is not general enough\n+   |\n+   = note: `Y` would have to be implemented for the type `for<'r> fn(&'r ())`\n+   = note: ...but `Y` is actually implemented for the type `fn(&'0 ())`, for some specific lifetime `'0`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2e94fc5c12df1507663617b479ffed8043ea8c93", "filename": "src/test/ui/nll/relate_tys/trait-hrtb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -12,5 +12,5 @@ fn make_foo<'a>() -> Box<dyn Foo<'a>> {\n \n fn main() {\n     let x: Box<dyn Foo<'static>> = make_foo();\n-    let y: Box<dyn for<'a> Foo<'a>> = x; //~ ERROR higher-ranked subtype error\n+    let y: Box<dyn for<'a> Foo<'a>> = x; //~ ERROR mismatched types [E0308]\n }"}, {"sha": "60a7f204446806872f27e12670de0bfe46849759", "filename": "src/test/ui/nll/relate_tys/trait-hrtb.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,12 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/trait-hrtb.rs:15:39\n    |\n LL |     let y: Box<dyn for<'a> Foo<'a>> = x;\n-   |                                       ^\n+   |                                       ^ one type is more general than the other\n+   |\n+   = note: expected trait object `dyn for<'r> Foo<'r>`\n+              found trait object `dyn Foo<'_>`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "8389c8e8377ed0dd65df9674e5e65df9e84a6fcb", "filename": "src/test/ui/nll/relate_tys/universe-violation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.rs?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -12,6 +12,6 @@ fn make_it() -> fn(&'static u32) -> &'static u32 {\n \n fn main() {\n     let a: fn(_) -> _ = make_it();\n-    let b: fn(&u32) -> &u32 = a; //~ ERROR higher-ranked subtype error\n+    let b: fn(&u32) -> &u32 = a; //~ ERROR mismatched types [E0308]\n     drop(a);\n }"}, {"sha": "ff4c7abc250553c434fe9e72c2c71c4823a81320", "filename": "src/test/ui/nll/relate_tys/universe-violation.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,12 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/universe-violation.rs:15:31\n    |\n LL |     let b: fn(&u32) -> &u32 = a;\n-   |                               ^\n+   |                               ^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r> fn(&'r u32) -> &'r u32`\n+              found fn pointer `fn(&u32) -> &u32`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "a64ad46ef462b0b12f9f0eba1bd7869e0974ce77", "filename": "src/test/ui/regions/region-lifetime-bounds-on-fns-where-clause.nll.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -27,17 +27,24 @@ LL |     a(x, y);\n    = note: mutable references are invariant over their type parameter\n    = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/region-lifetime-bounds-on-fns-where-clause.rs:20:12\n    |\n LL |     let _: fn(&mut &isize, &mut &isize) = a;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r, 's, 't0, 't1> fn(&'r mut &'s isize, &'t0 mut &'t1 isize)`\n+              found fn pointer `for<'r, 's> fn(&'r mut &isize, &'s mut &isize)`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/region-lifetime-bounds-on-fns-where-clause.rs:20:12\n    |\n LL |     let _: fn(&mut &isize, &mut &isize) = a;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r, 's, 't0, 't1> fn(&'r mut &'s isize, &'t0 mut &'t1 isize)`\n+              found fn pointer `for<'r, 's> fn(&'r mut &isize, &'s mut &isize)`\n \n error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "ce5e7d01723083e606e532e735da9483d2f3be78", "filename": "src/test/ui/regions/region-multiple-lifetime-bounds-on-fns-where-clause.nll.stderr", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -27,23 +27,33 @@ LL |     a(x, y, z);\n    = note: mutable references are invariant over their type parameter\n    = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/region-multiple-lifetime-bounds-on-fns-where-clause.rs:22:12\n    |\n LL |     let _: fn(&mut &isize, &mut &isize, &mut &isize) = a;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r, 's, 't0, 't1, 't2, 't3> fn(&'r mut &'s isize, &'t0 mut &'t1 isize, &'t2 mut &'t3 isize)`\n+              found fn pointer `for<'r, 's, 't0> fn(&'r mut &isize, &'s mut &isize, &'t0 mut &isize)`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/region-multiple-lifetime-bounds-on-fns-where-clause.rs:22:12\n    |\n LL |     let _: fn(&mut &isize, &mut &isize, &mut &isize) = a;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r, 's, 't0, 't1, 't2, 't3> fn(&'r mut &'s isize, &'t0 mut &'t1 isize, &'t2 mut &'t3 isize)`\n+              found fn pointer `for<'r, 's, 't0> fn(&'r mut &isize, &'s mut &isize, &'t0 mut &isize)`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/region-multiple-lifetime-bounds-on-fns-where-clause.rs:22:12\n    |\n LL |     let _: fn(&mut &isize, &mut &isize, &mut &isize) = a;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r, 's, 't0, 't1, 't2, 't3> fn(&'r mut &'s isize, &'t0 mut &'t1 isize, &'t2 mut &'t3 isize)`\n+              found fn pointer `for<'r, 's, 't0> fn(&'r mut &isize, &'s mut &isize, &'t0 mut &isize)`\n \n error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c2956cd89580f757e4c66c47c49f05794301267d", "filename": "src/test/ui/regions/regions-fn-subtyping-return-static-fail.nll.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static-fail.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static-fail.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static-fail.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,12 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/regions-fn-subtyping-return-static-fail.rs:48:5\n    |\n LL |     want_G(baz);\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'cx> fn(&'cx S) -> &'static S`\n+              found fn pointer `for<'r> fn(&'r S) -> &'r S`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "cae692ad2f6fa39a3689056ed9f28144f6f4f669", "filename": "src/test/ui/regions/regions-lifetime-bounds-on-fns.nll.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -27,17 +27,24 @@ LL |     a(x, y);\n    = note: mutable references are invariant over their type parameter\n    = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/regions-lifetime-bounds-on-fns.rs:20:12\n    |\n LL |     let _: fn(&mut &isize, &mut &isize) = a;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r, 's, 't0, 't1> fn(&'r mut &'s isize, &'t0 mut &'t1 isize)`\n+              found fn pointer `for<'r, 's> fn(&'r mut &isize, &'s mut &isize)`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/regions-lifetime-bounds-on-fns.rs:20:12\n    |\n LL |     let _: fn(&mut &isize, &mut &isize) = a;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r, 's, 't0, 't1> fn(&'r mut &'s isize, &'t0 mut &'t1 isize)`\n+              found fn pointer `for<'r, 's> fn(&'r mut &isize, &'s mut &isize)`\n \n error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "cc247bbcb119900591bf063b80835d20690cd32d", "filename": "src/test/ui/rfc1623.nll.stderr", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Frfc1623.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Frfc1623.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1623.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -19,7 +19,7 @@ LL | struct SomeStruct<'x, 'y, 'z: 'x> {\n    = note: required because it appears within the type `&SomeStruct`\n    = note: shared static variables must have a type that implements `Sync`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/rfc1623.rs:21:35\n    |\n LL |   static SOME_STRUCT: &SomeStruct = &SomeStruct {\n@@ -29,9 +29,12 @@ LL | |     bar: &Bar { bools: &[true, true] },\n LL | |     f: &id,\n LL | |\n LL | | };\n-   | |_^\n+   | |_^ one type is more general than the other\n+   |\n+   = note: expected type `for<'r, 's> Fn<(&'r Foo<'s>,)>`\n+              found type `Fn<(&Foo<'_>,)>`\n \n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n   --> $DIR/rfc1623.rs:21:35\n    |\n LL |   static SOME_STRUCT: &SomeStruct = &SomeStruct {\n@@ -41,9 +44,12 @@ LL | |     bar: &Bar { bools: &[true, true] },\n LL | |     f: &id,\n LL | |\n LL | | };\n-   | |_^\n+   | |_^ one type is more general than the other\n+   |\n+   = note: expected type `for<'r, 's> Fn<(&'r Foo<'s>,)>`\n+              found type `Fn<(&Foo<'_>,)>`\n \n-error: higher-ranked subtype error\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/rfc1623.rs:21:35\n    |\n LL |   static SOME_STRUCT: &SomeStruct = &SomeStruct {\n@@ -53,9 +59,12 @@ LL | |     bar: &Bar { bools: &[true, true] },\n LL | |     f: &id,\n LL | |\n LL | | };\n-   | |_^\n+   | |_^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'2 Foo<'_>) -> &'2 Foo<'_> {id::<&'2 Foo<'_>>}` must implement `FnOnce<(&'1 Foo<'_>,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 Foo<'_>,)>`, for some specific lifetime `'2`\n \n-error: higher-ranked subtype error\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/rfc1623.rs:21:35\n    |\n LL |   static SOME_STRUCT: &SomeStruct = &SomeStruct {\n@@ -65,8 +74,12 @@ LL | |     bar: &Bar { bools: &[true, true] },\n LL | |     f: &id,\n LL | |\n LL | | };\n-   | |_^\n+   | |_^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&Foo<'2>) -> &Foo<'2> {id::<&Foo<'2>>}` must implement `FnOnce<(&Foo<'1>,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&Foo<'2>,)>`, for some specific lifetime `'2`\n \n error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0277, E0308.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "147a20974732def5fe8f699bf701381f718c4229", "filename": "src/test/ui/unboxed-closures/issue-30906.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-30906.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-30906.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-30906.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,11 @@\n-error: higher-ranked subtype error\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue-30906.rs:18:5\n    |\n LL |     test(Compose(f, |_| {}));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'2 str) -> T` must implement `FnOnce<(&'1 str,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 str,)>`, for some specific lifetime `'2`\n \n error: aborting due to previous error\n "}, {"sha": "f65db78fc8993b55753ab7bfdd463e57c014d20b", "filename": "src/test/ui/where-clauses/where-for-self-2.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.nll.stderr?ref=3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "patch": "@@ -1,8 +1,11 @@\n-error: higher-ranked subtype error\n+error: implementation of `Bar` is not general enough\n   --> $DIR/where-for-self-2.rs:23:5\n    |\n LL |     foo(&X);\n-   |     ^^^^^^^\n+   |     ^^^^^^^ implementation of `Bar` is not general enough\n+   |\n+   = note: `&'0 u32` must implement `Bar`, for any lifetime `'0`...\n+   = note: ...but `Bar` is actually implemented for the type `&'static u32`\n \n error: aborting due to previous error\n "}]}