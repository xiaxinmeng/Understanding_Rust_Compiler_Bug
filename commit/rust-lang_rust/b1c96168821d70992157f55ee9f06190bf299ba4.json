{"sha": "b1c96168821d70992157f55ee9f06190bf299ba4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYzk2MTY4ODIxZDcwOTkyMTU3ZjU1ZWU5ZjA2MTkwYmYyOTliYTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-15T01:38:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-15T01:38:00Z"}, "message": "Auto merge of #28274 - arielb1:split-ty, r=nikomatsakis\n\nThat file got way too big for its own good. It could be split more - this is just a start.\r\n\r\nr? @nikomatsakis", "tree": {"sha": "b4cb0b0aa4d7d8934e42946887797ced0e58fbe4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4cb0b0aa4d7d8934e42946887797ced0e58fbe4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1c96168821d70992157f55ee9f06190bf299ba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1c96168821d70992157f55ee9f06190bf299ba4", "html_url": "https://github.com/rust-lang/rust/commit/b1c96168821d70992157f55ee9f06190bf299ba4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1c96168821d70992157f55ee9f06190bf299ba4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e629dba0ee190cab49df0c5db299fb8d77264dda", "url": "https://api.github.com/repos/rust-lang/rust/commits/e629dba0ee190cab49df0c5db299fb8d77264dda", "html_url": "https://github.com/rust-lang/rust/commit/e629dba0ee190cab49df0c5db299fb8d77264dda"}, {"sha": "5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "html_url": "https://github.com/rust-lang/rust/commit/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349"}], "stats": {"total": 17129, "additions": 8697, "deletions": 8432}, "files": [{"sha": "cfeab976e24cb110d00a1dff96289c8b4f4a82e3", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -107,7 +107,6 @@ pub mod front {\n pub mod middle {\n     pub mod astconv_util;\n     pub mod astencode;\n-    pub mod cast;\n     pub mod cfg;\n     pub mod check_const;\n     pub mod check_static_recursion;\n@@ -124,15 +123,13 @@ pub mod middle {\n     pub mod effect;\n     pub mod entry;\n     pub mod expr_use_visitor;\n-    pub mod fast_reject;\n     pub mod free_region;\n     pub mod intrinsicck;\n     pub mod infer;\n     pub mod implicator;\n     pub mod lang_items;\n     pub mod liveness;\n     pub mod mem_categorization;\n-    pub mod outlives;\n     pub mod pat_util;\n     pub mod privacy;\n     pub mod reachable;\n@@ -143,11 +140,6 @@ pub mod middle {\n     pub mod subst;\n     pub mod traits;\n     pub mod ty;\n-    pub mod ty_fold;\n-    pub mod ty_match;\n-    pub mod ty_relate;\n-    pub mod ty_walk;\n-    pub mod wf;\n     pub mod weak_lang_items;\n }\n "}, {"sha": "e1cb9bd0e77cf60db4317ad998cae8d564355d64", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -247,9 +247,11 @@ pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n     decoder::get_impl_polarity(&*cdata, def.node)\n }\n \n-pub fn get_custom_coerce_unsized_kind<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                            def: DefId)\n-                                            -> Option<ty::CustomCoerceUnsized> {\n+pub fn get_custom_coerce_unsized_kind<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    def: DefId)\n+    -> Option<ty::adjustment::CustomCoerceUnsized>\n+{\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_custom_coerce_unsized_kind(&*cdata, def.node)"}, {"sha": "e2cf50cf30ad0b4a768c510eb25bf12a150f62c6", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -540,9 +540,11 @@ pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n     }\n }\n \n-pub fn get_custom_coerce_unsized_kind<'tcx>(cdata: Cmd,\n-                                            id: ast::NodeId)\n-                                            -> Option<ty::CustomCoerceUnsized> {\n+pub fn get_custom_coerce_unsized_kind<'tcx>(\n+    cdata: Cmd,\n+    id: ast::NodeId)\n+    -> Option<ty::adjustment::CustomCoerceUnsized>\n+{\n     let item_doc = cdata.lookup_item(id);\n     reader::maybe_get_doc(item_doc, tag_impl_coerce_unsized_kind).map(|kind_doc| {\n         let mut decoder = reader::Decoder::new(kind_doc);"}, {"sha": "0bd4434857abd50ca1d6d989b05ad0d8c449e6fa", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -27,7 +27,8 @@ use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId};\n use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n-use middle::cast;\n+use middle::ty::adjustment;\n+use middle::ty::cast;\n use middle::check_const::ConstQualif;\n use middle::def;\n use middle::def_id::{DefId, LOCAL_CRATE};\n@@ -646,11 +647,11 @@ trait rbml_writer_helpers<'tcx> {\n     fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds);\n     fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture);\n     fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                                adj: &ty::AutoAdjustment<'tcx>);\n+                                adj: &adjustment::AutoAdjustment<'tcx>);\n     fn emit_autoref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                        autoref: &ty::AutoRef<'tcx>);\n+                        autoref: &adjustment::AutoRef<'tcx>);\n     fn emit_auto_deref_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                               auto_deref_ref: &ty::AutoDerefRef<'tcx>);\n+                               auto_deref_ref: &adjustment::AutoDerefRef<'tcx>);\n }\n \n impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n@@ -771,22 +772,22 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     }\n \n     fn emit_auto_adjustment<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                                adj: &ty::AutoAdjustment<'tcx>) {\n+                                adj: &adjustment::AutoAdjustment<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"AutoAdjustment\", |this| {\n             match *adj {\n-                ty::AdjustReifyFnPointer=> {\n+                adjustment::AdjustReifyFnPointer=> {\n                     this.emit_enum_variant(\"AdjustReifyFnPointer\", 1, 0, |_| Ok(()))\n                 }\n \n-                ty::AdjustUnsafeFnPointer => {\n+                adjustment::AdjustUnsafeFnPointer => {\n                     this.emit_enum_variant(\"AdjustUnsafeFnPointer\", 2, 0, |_| {\n                         Ok(())\n                     })\n                 }\n \n-                ty::AdjustDerefRef(ref auto_deref_ref) => {\n+                adjustment::AdjustDerefRef(ref auto_deref_ref) => {\n                     this.emit_enum_variant(\"AdjustDerefRef\", 3, 2, |this| {\n                         this.emit_enum_variant_arg(0,\n                             |this| Ok(this.emit_auto_deref_ref(ecx, auto_deref_ref)))\n@@ -797,19 +798,19 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     }\n \n     fn emit_autoref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                        autoref: &ty::AutoRef<'tcx>) {\n+                        autoref: &adjustment::AutoRef<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"AutoRef\", |this| {\n             match autoref {\n-                &ty::AutoPtr(r, m) => {\n+                &adjustment::AutoPtr(r, m) => {\n                     this.emit_enum_variant(\"AutoPtr\", 0, 2, |this| {\n                         this.emit_enum_variant_arg(0,\n                             |this| Ok(this.emit_region(ecx, *r)));\n                         this.emit_enum_variant_arg(1, |this| m.encode(this))\n                     })\n                 }\n-                &ty::AutoUnsafe(m) => {\n+                &adjustment::AutoUnsafe(m) => {\n                     this.emit_enum_variant(\"AutoUnsafe\", 1, 1, |this| {\n                         this.emit_enum_variant_arg(0, |this| m.encode(this))\n                     })\n@@ -819,7 +820,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     }\n \n     fn emit_auto_deref_ref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                               auto_deref_ref: &ty::AutoDerefRef<'tcx>) {\n+                               auto_deref_ref: &adjustment::AutoDerefRef<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_struct(\"AutoDerefRef\", 2, |this| {\n@@ -974,7 +975,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     if let Some(adjustment) = tcx.tables.borrow().adjustments.get(&id) {\n         match *adjustment {\n-            ty::AdjustDerefRef(ref adj) => {\n+            adjustment::AdjustDerefRef(ref adj) => {\n                 for autoderef in 0..adj.autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, autoderef as u32);\n                     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n@@ -1063,17 +1064,17 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     fn read_upvar_capture(&mut self, dcx: &DecodeContext)\n                           -> ty::UpvarCapture;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                    -> ty::AutoAdjustment<'tcx>;\n+                                    -> adjustment::AutoAdjustment<'tcx>;\n     fn read_cast_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                  -> cast::CastKind;\n     fn read_closure_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                  -> ty::ClosureKind;\n     fn read_closure_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                -> ty::ClosureTy<'tcx>;\n     fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                   -> ty::AutoDerefRef<'tcx>;\n+                                   -> adjustment::AutoDerefRef<'tcx>;\n     fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                            -> ty::AutoRef<'tcx>;\n+                            -> adjustment::AutoRef<'tcx>;\n     fn convert_def_id(&mut self,\n                       dcx: &DecodeContext,\n                       source: DefIdSource,\n@@ -1246,30 +1247,30 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n     fn read_auto_adjustment<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                    -> ty::AutoAdjustment<'tcx> {\n+                                    -> adjustment::AutoAdjustment<'tcx> {\n         self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AdjustReifyFnPointer\", \"AdjustUnsafeFnPointer\", \"AdjustDerefRef\"];\n             this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n-                    1 => ty::AdjustReifyFnPointer,\n-                    2 => ty::AdjustUnsafeFnPointer,\n+                    1 => adjustment::AdjustReifyFnPointer,\n+                    2 => adjustment::AdjustUnsafeFnPointer,\n                     3 => {\n-                        let auto_deref_ref: ty::AutoDerefRef =\n+                        let auto_deref_ref: adjustment::AutoDerefRef =\n                             this.read_enum_variant_arg(0,\n                                 |this| Ok(this.read_auto_deref_ref(dcx))).unwrap();\n \n-                        ty::AdjustDerefRef(auto_deref_ref)\n+                        adjustment::AdjustDerefRef(auto_deref_ref)\n                     }\n-                    _ => panic!(\"bad enum variant for ty::AutoAdjustment\")\n+                    _ => panic!(\"bad enum variant for adjustment::AutoAdjustment\")\n                 })\n             })\n         }).unwrap()\n     }\n \n     fn read_auto_deref_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                   -> ty::AutoDerefRef<'tcx> {\n+                                   -> adjustment::AutoDerefRef<'tcx> {\n         self.read_struct(\"AutoDerefRef\", 2, |this| {\n-            Ok(ty::AutoDerefRef {\n+            Ok(adjustment::AutoDerefRef {\n                 autoderefs: this.read_struct_field(\"autoderefs\", 0, |this| {\n                     Decodable::decode(this)\n                 }).unwrap(),\n@@ -1296,7 +1297,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n     fn read_autoref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                            -> ty::AutoRef<'tcx> {\n+                            -> adjustment::AutoRef<'tcx> {\n         self.read_enum(\"AutoRef\", |this| {\n             let variants = [\"AutoPtr\", \"AutoUnsafe\"];\n             this.read_enum_variant(&variants, |this, i| {\n@@ -1311,15 +1312,15 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                 Decodable::decode(this)\n                             }).unwrap();\n \n-                        ty::AutoPtr(dcx.tcx.mk_region(r), m)\n+                        adjustment::AutoPtr(dcx.tcx.mk_region(r), m)\n                     }\n                     1 => {\n                         let m: hir::Mutability =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n-                        ty::AutoUnsafe(m)\n+                        adjustment::AutoUnsafe(m)\n                     }\n-                    _ => panic!(\"bad enum variant for ty::AutoRef\")\n+                    _ => panic!(\"bad enum variant for adjustment::AutoRef\")\n                 })\n             })\n         }).unwrap()\n@@ -1467,7 +1468,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         dcx.tcx.tables.borrow_mut().method_map.insert(method_call, method);\n                     }\n                     c::tag_table_adjustments => {\n-                        let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);\n+                        let adj =\n+                            val_dsr.read_auto_adjustment(dcx);\n                         dcx.tcx.tables.borrow_mut().adjustments.insert(id, adj);\n                     }\n                     c::tag_table_closure_tys => {"}, {"sha": "661299cd7f3fc0aec502bee21c5ae89e2a0331f9", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -24,7 +24,7 @@\n // - It's not possible to take the address of a static item with unsafe interior. This is enforced\n // by borrowck::gather_loans\n \n-use middle::cast::{CastKind};\n+use middle::ty::cast::{CastKind};\n use middle::const_eval;\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use middle::def;\n@@ -798,8 +798,13 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n /// Check the adjustments of an expression\n fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n     match v.tcx.tables.borrow().adjustments.get(&e.id) {\n-        None | Some(&ty::AdjustReifyFnPointer) | Some(&ty::AdjustUnsafeFnPointer) => {}\n-        Some(&ty::AdjustDerefRef(ty::AutoDerefRef { autoderefs, .. })) => {\n+        None |\n+        Some(&ty::adjustment::AdjustReifyFnPointer) |\n+        Some(&ty::adjustment::AdjustUnsafeFnPointer) => {}\n+\n+        Some(&ty::adjustment::AdjustDerefRef(\n+            ty::adjustment::AutoDerefRef { autoderefs, .. }\n+        )) => {\n             if (0..autoderefs as u32).any(|autoderef| {\n                     v.tcx.is_overloaded_autoderef(e.id, autoderef)\n             }) {"}, {"sha": "a8fed5eab16bef2d690c90f5ac9b3cd4d9b153ff", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -25,6 +25,7 @@ use middle::def_id::{DefId};\n use middle::infer;\n use middle::mem_categorization as mc;\n use middle::ty;\n+use middle::ty::adjustment;\n \n use rustc_front::hir;\n \n@@ -726,16 +727,16 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         let adj = typer.adjustments().get(&expr.id).map(|x| x.clone());\n         if let Some(adjustment) = adj {\n             match adjustment {\n-                ty::AdjustReifyFnPointer |\n-                ty::AdjustUnsafeFnPointer => {\n+                adjustment::AdjustReifyFnPointer |\n+                adjustment::AdjustUnsafeFnPointer => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n                     debug!(\"walk_adjustment(AdjustReifyFnPointer|AdjustUnsafeFnPointer)\");\n                     let cmt_unadjusted =\n                         return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                     self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 }\n-                ty::AdjustDerefRef(ref adj) => {\n+                adjustment::AdjustDerefRef(ref adj) => {\n                     self.walk_autoderefref(expr, adj);\n                 }\n             }\n@@ -778,7 +779,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n     fn walk_autoderefref(&mut self,\n                          expr: &hir::Expr,\n-                         adj: &ty::AutoDerefRef<'tcx>) {\n+                         adj: &adjustment::AutoDerefRef<'tcx>) {\n         debug!(\"walk_autoderefref expr={:?} adj={:?}\",\n                expr,\n                adj);\n@@ -809,7 +810,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     fn walk_autoref(&mut self,\n                     expr: &hir::Expr,\n                     cmt_base: mc::cmt<'tcx>,\n-                    opt_autoref: Option<ty::AutoRef<'tcx>>)\n+                    opt_autoref: Option<adjustment::AutoRef<'tcx>>)\n                     -> mc::cmt<'tcx>\n     {\n         debug!(\"walk_autoref(expr.id={} cmt_derefd={:?} opt_autoref={:?})\",\n@@ -828,7 +829,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         };\n \n         match *autoref {\n-            ty::AutoPtr(r, m) => {\n+            adjustment::AutoPtr(r, m) => {\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n                                      cmt_base,\n@@ -837,7 +838,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                                      AutoRef);\n             }\n \n-            ty::AutoUnsafe(m) => {\n+            adjustment::AutoUnsafe(m) => {\n                 debug!(\"walk_autoref: expr.id={} cmt_base={:?}\",\n                        expr.id,\n                        cmt_base);"}, {"sha": "2e9e5fafb1d9b348dce9a2afb58aa48d37422160", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -16,7 +16,7 @@\n //! region outlives another and so forth.\n \n use middle::ty::{self, FreeRegion, Region};\n-use middle::wf::ImpliedBound;\n+use middle::ty::wf::ImpliedBound;\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n #[derive(Clone)]"}, {"sha": "9f33c4df03d41717ce77cd477f3c6fcc3ceac594", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -15,7 +15,7 @@ use middle::infer::{InferCtxt, GenericKind};\n use middle::subst::Substs;\n use middle::traits;\n use middle::ty::{self, RegionEscape, ToPredicate, Ty};\n-use middle::ty_fold::{TypeFoldable, TypeFolder};\n+use middle::ty::fold::{TypeFoldable, TypeFolder};\n \n use syntax::ast;\n use syntax::codemap::Span;"}, {"sha": "2d9432b75e719fd13737c4722e37ed4cf4b5e038", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -30,7 +30,7 @@ use super::type_variable::{BiTo};\n \n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use middle::ty::relate::{Relate, RelateResult, TypeRelation};\n \n pub struct Bivariate<'a, 'tcx: 'a> {\n     fields: CombineFields<'a, 'tcx>"}, {"sha": "2447a8cee7bbb9d56bf9c0e1d2f8969a350e04f1", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -43,10 +43,10 @@ use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n use middle::ty::{TyVar};\n use middle::ty::{IntType, UintType};\n-use middle::ty::{self, Ty, TypeError};\n-use middle::ty_fold;\n-use middle::ty_fold::{TypeFolder, TypeFoldable};\n-use middle::ty_relate::{self, Relate, RelateResult, TypeRelation};\n+use middle::ty::{self, Ty};\n+use middle::ty::error::TypeError;\n+use middle::ty::fold::{TypeFolder, TypeFoldable};\n+use middle::ty::relate::{Relate, RelateResult, TypeRelation};\n \n use syntax::codemap::Span;\n use rustc_front::hir;\n@@ -56,7 +56,7 @@ pub struct CombineFields<'a, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub a_is_expected: bool,\n     pub trace: TypeTrace<'tcx>,\n-    pub cause: Option<ty_relate::Cause>,\n+    pub cause: Option<ty::relate::Cause>,\n }\n \n pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n@@ -108,12 +108,12 @@ pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n         // All other cases of inference are errors\n         (&ty::TyInfer(_), _) |\n         (_, &ty::TyInfer(_)) => {\n-            Err(TypeError::Sorts(ty_relate::expected_found(relation, &a, &b)))\n+            Err(TypeError::Sorts(ty::relate::expected_found(relation, &a, &b)))\n         }\n \n \n         _ => {\n-            ty_relate::super_relate_tys(relation, a, b)\n+            ty::relate::super_relate_tys(relation, a, b)\n         }\n     }\n }\n@@ -293,7 +293,7 @@ struct Generalizer<'cx, 'tcx:'cx> {\n     cycle_detected: bool,\n }\n \n-impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n+impl<'cx, 'tcx> ty::fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -319,7 +319,7 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n                 }\n             }\n             _ => {\n-                ty_fold::super_fold_ty(self, t)\n+                ty::fold::super_fold_ty(self, t)\n             }\n         }\n     }\n@@ -363,12 +363,12 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n \n pub trait RelateResultCompare<'tcx, T> {\n     fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n-        F: FnOnce() -> ty::TypeError<'tcx>;\n+        F: FnOnce() -> TypeError<'tcx>;\n }\n \n impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'tcx, T> {\n     fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n-        F: FnOnce() -> ty::TypeError<'tcx>,\n+        F: FnOnce() -> TypeError<'tcx>,\n     {\n         self.clone().and_then(|s| {\n             if s == t {\n@@ -381,16 +381,16 @@ impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'t\n }\n \n fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::IntVarValue))\n-                               -> ty::TypeError<'tcx>\n+                               -> TypeError<'tcx>\n {\n     let (a, b) = v;\n-    TypeError::IntMismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n+    TypeError::IntMismatch(ty::relate::expected_found_bool(a_is_expected, &a, &b))\n }\n \n fn float_unification_error<'tcx>(a_is_expected: bool,\n                                  v: (hir::FloatTy, hir::FloatTy))\n-                                 -> ty::TypeError<'tcx>\n+                                 -> TypeError<'tcx>\n {\n     let (a, b) = v;\n-    TypeError::FloatMismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n+    TypeError::FloatMismatch(ty::relate::expected_found_bool(a_is_expected, &a, &b))\n }"}, {"sha": "07ce4688c069f1ec9e46f7ea5ac0ca965580a78b", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -15,7 +15,7 @@ use super::type_variable::{EqTo};\n \n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use middle::ty::relate::{Relate, RelateResult, TypeRelation};\n \n pub struct Equate<'a, 'tcx: 'a> {\n     fields: CombineFields<'a, 'tcx>"}, {"sha": "f0fa7d7cdf851b0f5a12bfbeb6a5423e5fc3de9e", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -82,8 +82,9 @@ use middle::def_id::DefId;\n use middle::infer;\n use middle::region;\n use middle::subst;\n-use middle::ty::{self, Ty, TypeError, HasTypeFlags};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty::{Region, ReFree};\n+use middle::ty::error::TypeError;\n \n use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n@@ -225,19 +226,19 @@ pub trait ErrorReporting<'tcx> {\n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n                       -> Vec<RegionResolutionError<'tcx>>;\n \n-    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::TypeError<'tcx>);\n+    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &TypeError<'tcx>);\n \n-    fn check_and_note_conflicting_crates(&self, terr: &ty::TypeError<'tcx>, sp: Span);\n+    fn check_and_note_conflicting_crates(&self, terr: &TypeError<'tcx>, sp: Span);\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n-                                     terr: &ty::TypeError<'tcx>);\n+                                     terr: &TypeError<'tcx>);\n \n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n     fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + HasTypeFlags>(\n         &self,\n-        exp_found: &ty::ExpectedFound<T>)\n+        exp_found: &ty::error::ExpectedFound<T>)\n         -> Option<String>;\n \n     fn report_concrete_failure(&self,\n@@ -266,7 +267,7 @@ pub trait ErrorReporting<'tcx> {\n \n     fn report_processed_errors(&self,\n                                var_origin: &[RegionVariableOrigin],\n-                               trace_origin: &[(TypeTrace<'tcx>, ty::TypeError<'tcx>)],\n+                               trace_origin: &[(TypeTrace<'tcx>, TypeError<'tcx>)],\n                                same_regions: &[SameRegions]);\n \n     fn give_suggestion(&self, same_regions: &[SameRegions]);\n@@ -473,7 +474,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::TypeError<'tcx>) {\n+    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &TypeError<'tcx>) {\n         let expected_found_str = match self.values_str(&trace.values) {\n             Some(v) => v,\n             None => {\n@@ -497,7 +498,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     }\n \n     /// Adds a note if the types come from similarly named crates\n-    fn check_and_note_conflicting_crates(&self, terr: &ty::TypeError<'tcx>, sp: Span) {\n+    fn check_and_note_conflicting_crates(&self, terr: &TypeError<'tcx>, sp: Span) {\n         let report_path_match = |did1: DefId, did2: DefId| {\n             // Only external crates, if either is from a local\n             // module we could have false positives\n@@ -520,7 +521,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n         match *terr {\n-            ty::TypeError::Sorts(ref exp_found) => {\n+            TypeError::Sorts(ref exp_found) => {\n                 // if they are both \"path types\", there's a chance of ambiguity\n                 // due to different versions of the same crate\n                 match (&exp_found.expected.sty, &exp_found.found.sty) {\n@@ -533,7 +534,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     _ => ()\n                 }\n             },\n-            ty::TypeError::Traits(ref exp_found) => {\n+            TypeError::Traits(ref exp_found) => {\n                 self.tcx.sess.note(\"errrr0\");\n                 report_path_match(exp_found.expected, exp_found.found);\n             },\n@@ -543,7 +544,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n-                                     terr: &ty::TypeError<'tcx>) {\n+                                     terr: &TypeError<'tcx>) {\n         let span = trace.origin.span();\n         self.report_type_error(trace, terr);\n         self.tcx.note_and_explain_type_err(terr, span);\n@@ -561,7 +562,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + HasTypeFlags>(\n         &self,\n-        exp_found: &ty::ExpectedFound<T>)\n+        exp_found: &ty::error::ExpectedFound<T>)\n         -> Option<String>\n     {\n         let expected = exp_found.expected.resolve(self);\n@@ -975,7 +976,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_processed_errors(&self,\n                                var_origins: &[RegionVariableOrigin],\n-                               trace_origins: &[(TypeTrace<'tcx>, ty::TypeError<'tcx>)],\n+                               trace_origins: &[(TypeTrace<'tcx>, TypeError<'tcx>)],\n                                same_regions: &[SameRegions]) {\n         for vo in var_origins {\n             self.report_inference_failure(vo.clone());"}, {"sha": "0bae3cd2d86903dac5912b503c914c83293a2d67", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -31,9 +31,8 @@\n //! inferencer knows \"so far\".\n \n use middle::ty::{self, Ty, HasTypeFlags};\n-use middle::ty_fold;\n-use middle::ty_fold::TypeFoldable;\n-use middle::ty_fold::TypeFolder;\n+use middle::ty::fold::TypeFoldable;\n+use middle::ty::fold::TypeFolder;\n use std::collections::hash_map::{self, Entry};\n \n use super::InferCtxt;\n@@ -170,7 +169,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::TyTuple(..) |\n             ty::TyProjection(..) |\n             ty::TyParam(..) => {\n-                ty_fold::super_fold_ty(self, t)\n+                ty::fold::super_fold_ty(self, t)\n             }\n         }\n     }"}, {"sha": "0035f31e8db942110df94b2c45642a6d532553b2", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -15,7 +15,7 @@ use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n use middle::ty::{self, Ty};\n-use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use middle::ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'a, 'tcx: 'a> {"}, {"sha": "b0fce71d3f06143523856dacc51e85acd62164e0", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -14,9 +14,10 @@\n use super::{CombinedSnapshot, InferCtxt, HigherRankedType, SkolemizationMap};\n use super::combine::CombineFields;\n \n-use middle::ty::{self, TypeError, Binder};\n-use middle::ty_fold::{self, TypeFoldable};\n-use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use middle::ty::{self, Binder};\n+use middle::ty::error::TypeError;\n+use middle::ty::fold::TypeFoldable;\n+use middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n@@ -358,7 +359,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n     where T: TypeFoldable<'tcx>,\n           F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n-    ty_fold::fold_regions(tcx, unbound_value, &mut false, |region, current_depth| {\n+    tcx.fold_regions(unbound_value, &mut false, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,\n         // because the ones at the current level should have been replaced\n         // with fresh variables\n@@ -438,7 +439,7 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n \n         let mut escaping_region_vars = FnvHashSet();\n         for ty in &escaping_types {\n-            ty_fold::collect_regions(self.tcx, ty, &mut escaping_region_vars);\n+            self.tcx.collect_regions(ty, &mut escaping_region_vars);\n         }\n \n         region_vars.retain(|&region_vid| {\n@@ -468,7 +469,7 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n      * details.\n      */\n \n-    let (result, map) = ty_fold::replace_late_bound_regions(infcx.tcx, binder, |br| {\n+    let (result, map) = infcx.tcx.replace_late_bound_regions(binder, |br| {\n         infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n     });\n \n@@ -590,7 +591,7 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     // binder is that we encountered in `value`. The caller is\n     // responsible for ensuring that (a) `value` contains at least one\n     // binder and (b) that binder is the one we want to use.\n-    let result = ty_fold::fold_regions(infcx.tcx, &value, &mut false, |r, current_depth| {\n+    let result = infcx.tcx.fold_regions(&value, &mut false, |r, current_depth| {\n         match inv_skol_map.get(&r) {\n             None => r,\n             Some(br) => {"}, {"sha": "2a560ec8a1d237dd497d70ef6fe7fc569c10dc75", "filename": "src/librustc/middle/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -34,7 +34,7 @@ use super::InferCtxt;\n \n use middle::ty::TyVar;\n use middle::ty::{self, Ty};\n-use middle::ty_relate::{RelateResult, TypeRelation};\n+use middle::ty::relate::{RelateResult, TypeRelation};\n \n pub trait LatticeDir<'f,'tcx> : TypeRelation<'f,'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;"}, {"sha": "238dad65ef0d93db67ab2b388241da88cdd5ff9f", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -15,7 +15,7 @@ use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n use middle::ty::{self, Ty};\n-use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use middle::ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'a, 'tcx: 'a> {\n@@ -83,4 +83,3 @@ impl<'a, 'tcx> LatticeDir<'a,'tcx> for Lub<'a, 'tcx> {\n         Ok(())\n     }\n }\n-"}, {"sha": "ffb631e105b3a0bf05895ed4201ff67b4c76b6cb", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -30,10 +30,12 @@ use middle::subst::Substs;\n use middle::subst::Subst;\n use middle::traits::{self, FulfillmentContext, Normalized,\n                      SelectionContext, ObligationCause};\n-use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n-use middle::ty::{self, Ty, TypeError, HasTypeFlags};\n-use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n-use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use middle::ty::adjustment;\n+use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n+use middle::ty::{self, Ty, HasTypeFlags};\n+use middle::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n+use middle::ty::fold::{TypeFolder, TypeFoldable};\n+use middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{RefCell, Ref};\n use std::fmt;\n@@ -171,9 +173,9 @@ impl fmt::Display for TypeOrigin {\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n-    Types(ty::ExpectedFound<Ty<'tcx>>),\n-    TraitRefs(ty::ExpectedFound<ty::TraitRef<'tcx>>),\n-    PolyTraitRefs(ty::ExpectedFound<ty::PolyTraitRef<'tcx>>),\n+    Types(ExpectedFound<Ty<'tcx>>),\n+    TraitRefs(ExpectedFound<ty::TraitRef<'tcx>>),\n+    PolyTraitRefs(ExpectedFound<ty::PolyTraitRef<'tcx>>),\n }\n \n /// The trace designates the path through inference that we took to\n@@ -479,12 +481,12 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n fn expected_found<T>(a_is_expected: bool,\n                      a: T,\n                      b: T)\n-                     -> ty::ExpectedFound<T>\n+                     -> ExpectedFound<T>\n {\n     if a_is_expected {\n-        ty::ExpectedFound {expected: a, found: b}\n+        ExpectedFound {expected: a, found: b}\n     } else {\n-        ty::ExpectedFound {expected: b, found: a}\n+        ExpectedFound {expected: b, found: a}\n     }\n }\n \n@@ -583,7 +585,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n /// Returns an equivalent value with all free regions removed (note\n /// that late-bound regions remain, because they are important for\n /// subtyping, but they are anonymized and normalized as well). This\n-/// is a stronger, caching version of `ty_fold::erase_regions`.\n+/// is a stronger, caching version of `ty::fold::erase_regions`.\n pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n     where T : TypeFoldable<'tcx>\n {\n@@ -603,7 +605,7 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n                 Some(u) => return u\n             }\n \n-            let t_norm = ty_fold::super_fold_ty(self, ty);\n+            let t_norm = ty::fold::super_fold_ty(self, ty);\n             self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n             return t_norm;\n         }\n@@ -612,7 +614,7 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n             where T : TypeFoldable<'tcx>\n         {\n             let u = self.tcx().anonymize_late_bound_regions(t);\n-            ty_fold::super_fold_binder(self, &u)\n+            ty::fold::super_fold_binder(self, &u)\n         }\n \n         fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n@@ -656,7 +658,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn type_is_unconstrained_numeric(&'a self, ty: Ty) -> UnconstrainedNumeric {\n-        use middle::ty::UnconstrainedNumeric::{Neither, UnconstrainedInt, UnconstrainedFloat};\n+        use middle::ty::error::UnconstrainedNumeric::Neither;\n+        use middle::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n         match ty.sty {\n             ty::TyInfer(ty::IntVar(vid)) => {\n                 if self.int_unification_table.borrow_mut().has_value(vid) {\n@@ -1149,7 +1152,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Apply `adjustment` to the type of `expr`\n     pub fn adjust_expr_ty(&self,\n                           expr: &hir::Expr,\n-                          adjustment: Option<&ty::AutoAdjustment<'tcx>>)\n+                          adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n                           -> Ty<'tcx>\n     {\n         let raw_ty = self.expr_ty(expr);\n@@ -1312,7 +1315,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                      sp: Span,\n                                      mk_msg: M,\n                                      actual_ty: String,\n-                                     err: Option<&ty::TypeError<'tcx>>) where\n+                                     err: Option<&TypeError<'tcx>>) where\n         M: FnOnce(Option<String>, String) -> String,\n     {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n@@ -1323,7 +1326,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                    mk_msg: M,\n                                                    expected_ty: Option<Ty<'tcx>>,\n                                                    actual_ty: String,\n-                                                   err: Option<&ty::TypeError<'tcx>>) where\n+                                                   err: Option<&TypeError<'tcx>>) where\n         M: FnOnce(Option<String>, String) -> String,\n     {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n@@ -1349,7 +1352,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                  sp: Span,\n                                  mk_msg: M,\n                                  actual_ty: Ty<'tcx>,\n-                                 err: Option<&ty::TypeError<'tcx>>) where\n+                                 err: Option<&TypeError<'tcx>>) where\n         M: FnOnce(String) -> String,\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n@@ -1368,10 +1371,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                    span: Span,\n                                    expected: Ty<'tcx>,\n                                    actual: Ty<'tcx>,\n-                                   err: &ty::TypeError<'tcx>) {\n+                                   err: &TypeError<'tcx>) {\n         let trace = TypeTrace {\n             origin: Misc(span),\n-            values: Types(ty::ExpectedFound {\n+            values: Types(ExpectedFound {\n                 expected: expected,\n                 found: actual\n             })\n@@ -1385,14 +1388,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                             actual: type_variable::Default<'tcx>) {\n         let trace = TypeTrace {\n             origin: Misc(span),\n-            values: Types(ty::ExpectedFound {\n+            values: Types(ExpectedFound {\n                 expected: expected.ty,\n                 found: actual.ty\n             })\n         };\n \n         self.report_and_explain_type_error(trace,\n-            &TypeError::TyParamDefaultMismatch(ty::ExpectedFound {\n+            &TypeError::TyParamDefaultMismatch(ExpectedFound {\n                 expected: expected,\n                 found: actual\n         }));\n@@ -1406,8 +1409,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n         where T : TypeFoldable<'tcx>\n     {\n-        ty_fold::replace_late_bound_regions(\n-            self.tcx,\n+        self.tcx.replace_late_bound_regions(\n             value,\n             |br| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n     }\n@@ -1484,9 +1486,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .map(|method| method.def_id)\n     }\n \n-    pub fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+    pub fn adjustments(&self) -> Ref<NodeMap<adjustment::AutoAdjustment<'tcx>>> {\n         fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n-                                        -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n+                                        -> &'a NodeMap<adjustment::AutoAdjustment<'tcx>> {\n             &tables.adjustments\n         }\n \n@@ -1555,7 +1557,7 @@ impl<'tcx> TypeTrace<'tcx> {\n     pub fn dummy(tcx: &ty::ctxt<'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n-            values: Types(ty::ExpectedFound {\n+            values: Types(ExpectedFound {\n                 expected: tcx.types.err,\n                 found: tcx.types.err,\n             })"}, {"sha": "1fc5294877065efc2bffd945ff534fb2941ee3e7", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -23,11 +23,12 @@ use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n use rustc_data_structures::graph::{self, Direction, NodeIndex};\n use middle::free_region::FreeRegionMap;\n use middle::region;\n-use middle::ty::{self, Ty, TypeError};\n+use middle::ty::{self, Ty};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n-use middle::ty_relate::RelateResult;\n+use middle::ty::error::TypeError;\n+use middle::ty::relate::RelateResult;\n use util::common::indenter;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n@@ -157,7 +158,7 @@ pub enum RegionResolutionError<'tcx> {\n     /// should put a lifetime. In those cases we process and put those errors\n     /// into `ProcessedErrors` before we do any reporting.\n     ProcessedErrors(Vec<RegionVariableOrigin>,\n-                    Vec<(TypeTrace<'tcx>, ty::TypeError<'tcx>)>,\n+                    Vec<(TypeTrace<'tcx>, TypeError<'tcx>)>,\n                     Vec<SameRegions>),\n }\n "}, {"sha": "4bcceade775999c1d90d024890a7bfb4421e044f", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -10,7 +10,7 @@\n \n use super::{InferCtxt, FixupError, FixupResult};\n use middle::ty::{self, Ty, HasTypeFlags};\n-use middle::ty_fold::{self, TypeFoldable};\n+use middle::ty::fold::{TypeFoldable};\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC TYPE RESOLVER\n@@ -30,7 +30,7 @@ impl<'a, 'tcx> OpportunisticTypeResolver<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx> {\n+impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -40,7 +40,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx>\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t0 = self.infcx.shallow_resolve(t);\n-            ty_fold::super_fold_ty(self, t0)\n+            ty::fold::super_fold_ty(self, t0)\n         }\n     }\n }\n@@ -69,7 +69,7 @@ struct FullTypeResolver<'a, 'tcx:'a> {\n     err: Option<FixupError>,\n }\n \n-impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n+impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                                 t));\n                 }\n                 _ => {\n-                    ty_fold::super_fold_ty(self, t)\n+                    ty::fold::super_fold_ty(self, t)\n                 }\n             }\n         }"}, {"sha": "155f5f44002f428826a966b59b687a5db3107d90", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -15,7 +15,7 @@ use super::type_variable::{SubtypeOf, SupertypeOf};\n \n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use middle::ty_relate::{Cause, Relate, RelateResult, TypeRelation};\n+use middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use std::mem;\n \n /// \"Greatest lower bound\" (common subtype)"}, {"sha": "dd2f48d25b4b0c6cc00c69dbd56b508fa824e141", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -77,6 +77,7 @@ use front::map as ast_map;\n use middle::infer;\n use middle::check_const;\n use middle::def;\n+use middle::ty::adjustment;\n use middle::ty::{self, Ty};\n \n use rustc_front::hir::{MutImmutable, MutMutable};\n@@ -421,16 +422,16 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n \n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AdjustDerefRef(\n-                        ty::AutoDerefRef {\n+                    adjustment::AdjustDerefRef(\n+                        adjustment::AutoDerefRef {\n                             autoref: None, unsize: None, autoderefs, ..}) => {\n                         // Equivalent to *expr or something similar.\n                         self.cat_expr_autoderefd(expr, autoderefs)\n                     }\n \n-                    ty::AdjustReifyFnPointer |\n-                    ty::AdjustUnsafeFnPointer |\n-                    ty::AdjustDerefRef(_) => {\n+                    adjustment::AdjustReifyFnPointer |\n+                    adjustment::AdjustUnsafeFnPointer |\n+                    adjustment::AdjustDerefRef(_) => {\n                         debug!(\"cat_expr({:?}): {:?}\",\n                                adjustment,\n                                expr);"}, {"sha": "c44891de0a055356b81400c8d3239b5892f2c211", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -14,7 +14,7 @@ pub use self::ParamSpace::*;\n pub use self::RegionSubsts::*;\n \n use middle::ty::{self, Ty, HasTypeFlags, RegionEscape};\n-use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n+use middle::ty::fold::{TypeFoldable, TypeFolder};\n \n use std::fmt;\n use std::iter::IntoIterator;\n@@ -643,7 +643,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                 self.ty_for_param(p, t)\n             }\n             _ => {\n-                ty_fold::super_fold_ty(self, t)\n+                ty::fold::super_fold_ty(self, t)\n             }\n         };\n \n@@ -731,13 +731,13 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n             return ty;\n         }\n \n-        let result = ty_fold::shift_regions(self.tcx(), self.region_binders_passed, &ty);\n+        let result = ty::fold::shift_regions(self.tcx(), self.region_binders_passed, &ty);\n         debug!(\"shift_regions: shifted result = {:?}\", result);\n \n         result\n     }\n \n     fn shift_region_through_binders(&self, region: ty::Region) -> ty::Region {\n-        ty_fold::shift_region(region, self.region_binders_passed)\n+        ty::fold::shift_region(region, self.region_binders_passed)\n     }\n }"}, {"sha": "5322a571ed91e8199c8010c0237b6d07438aa3e9", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -27,7 +27,7 @@ use fmt_macros::{Parser, Piece, Position};\n use middle::def_id::DefId;\n use middle::infer::InferCtxt;\n use middle::ty::{self, ToPredicate, HasTypeFlags, ToPolyTraitRef, TraitRef, Ty};\n-use middle::ty_fold::TypeFoldable;\n+use middle::ty::fold::TypeFoldable;\n use std::collections::HashMap;\n use std::fmt;\n use syntax::codemap::Span;"}, {"sha": "29032f0c4719a3df4afdd0fe9c2891825926fe2c", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -10,9 +10,7 @@\n \n use middle::infer::InferCtxt;\n use middle::ty::{self, RegionEscape, Ty, HasTypeFlags};\n-use middle::wf;\n \n-use std::fmt;\n use syntax::ast;\n use util::common::ErrorReported;\n use util::nodemap::{FnvHashSet, NodeMap};\n@@ -496,8 +494,8 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                 ObligationCauseCode::RFC1214(_) => true,\n                 _ => false,\n             };\n-            match wf::obligations(selcx.infcx(), obligation.cause.body_id,\n-                                  ty, obligation.cause.span, rfc1214) {\n+            match ty::wf::obligations(selcx.infcx(), obligation.cause.body_id,\n+                                      ty, obligation.cause.span, rfc1214) {\n                 Some(obligations) => {\n                     new_obligations.extend(obligations);\n                     true\n@@ -510,14 +508,6 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     }\n }\n \n-impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n-               self.sub_region,\n-               self.sup_type)\n-    }\n-}\n-\n fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n                                     r_b: ty::Region,\n                                     cause: ObligationCause<'tcx>,"}, {"sha": "14765e861c32d04636064145606bdd62a6864af3", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -19,7 +19,7 @@ use middle::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use middle::subst;\n use middle::ty::{self, HasTypeFlags, Ty};\n-use middle::ty_fold::TypeFoldable;\n+use middle::ty::fold::TypeFoldable;\n use middle::infer::{self, fixup_err_to_string, InferCtxt};\n use std::rc::Rc;\n use syntax::ast;\n@@ -63,6 +63,7 @@ mod fulfill;\n mod project;\n mod object_safety;\n mod select;\n+mod structural_impls;\n mod util;\n \n /// An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n@@ -168,7 +169,7 @@ pub enum SelectionError<'tcx> {\n     Unimplemented,\n     OutputTypeParameterMismatch(ty::PolyTraitRef<'tcx>,\n                                 ty::PolyTraitRef<'tcx>,\n-                                ty::TypeError<'tcx>),\n+                                ty::error::TypeError<'tcx>),\n     TraitNotObjectSafe(DefId),\n }\n "}, {"sha": "a2c09f88ab331cfbc3c9db74865dc403f98d9208", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -24,12 +24,10 @@ use super::util;\n use middle::infer;\n use middle::subst::Subst;\n use middle::ty::{self, ToPredicate, RegionEscape, HasTypeFlags, ToPolyTraitRef, Ty};\n-use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n+use middle::ty::fold::{TypeFoldable, TypeFolder};\n use syntax::parse::token;\n use util::common::FN_OUTPUT_NAME;\n \n-use std::fmt;\n-\n pub type PolyProjectionObligation<'tcx> =\n     Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n \n@@ -51,7 +49,7 @@ pub enum ProjectionTyError<'tcx> {\n \n #[derive(Clone)]\n pub struct MismatchedProjectionTypes<'tcx> {\n-    pub err: ty::TypeError<'tcx>\n+    pub err: ty::error::TypeError<'tcx>\n }\n \n #[derive(PartialEq, Eq, Debug)]\n@@ -265,7 +263,7 @@ impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n         // normalize it when we instantiate those bound regions (which\n         // should occur eventually).\n \n-        let ty = ty_fold::super_fold_ty(self, ty);\n+        let ty = ty::fold::super_fold_ty(self, ty);\n         match ty.sty {\n             ty::TyProjection(ref data) if !data.has_escaping_regions() => { // (*)\n \n@@ -917,27 +915,3 @@ fn confirm_impl_candidate<'cx,'tcx>(\n                               &format!(\"No associated type for {:?}\",\n                                        trait_ref));\n }\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Normalized<'tcx, T> {\n-        Normalized {\n-            value: self.value.fold_with(folder),\n-            obligations: self.obligations.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, T: HasTypeFlags> HasTypeFlags for Normalized<'tcx, T> {\n-    fn has_type_flags(&self, flags: ty::TypeFlags) -> bool {\n-        self.value.has_type_flags(flags) ||\n-            self.obligations.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx, T:fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Normalized({:?},{:?})\",\n-               self.value,\n-               self.obligations)\n-    }\n-}"}, {"sha": "6f422018c13d595fd94b6038cbcb917ebb5d7efa", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -38,15 +38,13 @@ use super::object_safety;\n use super::util;\n \n use middle::def_id::{DefId, LOCAL_CRATE};\n-use middle::fast_reject;\n-use middle::subst::{Subst, Substs, TypeSpace};\n-use middle::ty::{self, ToPredicate, RegionEscape, ToPolyTraitRef, Ty, HasTypeFlags};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n-use middle::ty_fold::TypeFoldable;\n-use middle::ty_match;\n-use middle::ty_relate::TypeRelation;\n-use middle::wf;\n+use middle::subst::{Subst, Substs, TypeSpace};\n+use middle::ty::{self, ToPredicate, RegionEscape, ToPolyTraitRef, Ty, HasTypeFlags};\n+use middle::ty::fast_reject;\n+use middle::ty::fold::TypeFoldable;\n+use middle::ty::relate::TypeRelation;\n \n use std::cell::RefCell;\n use std::fmt;\n@@ -471,9 +469,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::Predicate::WellFormed(ty) => {\n-                match wf::obligations(self.infcx, obligation.cause.body_id,\n-                                      ty, obligation.cause.span,\n-                                      obligation.cause.code.is_rfc1214()) {\n+                match ty::wf::obligations(self.infcx, obligation.cause.body_id,\n+                                          ty, obligation.cause.span,\n+                                          obligation.cause.code.is_rfc1214()) {\n                     Some(obligations) =>\n                         self.evaluate_predicates_recursively(previous_stack, obligations.iter()),\n                     None =>\n@@ -2824,7 +2822,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                               current: &ty::PolyTraitRef<'tcx>)\n                               -> bool\n     {\n-        let mut matcher = ty_match::Match::new(self.tcx());\n+        let mut matcher = ty::_match::Match::new(self.tcx());\n         matcher.relate(previous, current).is_ok()\n     }\n "}, {"sha": "88c219a7c7acefa490aced29de818887cd3df9aa", "filename": "src/librustc/middle/traits/structural_impls.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -0,0 +1,235 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::traits;\n+use middle::traits::project::Normalized;\n+use middle::ty::{HasTypeFlags, TypeFlags, RegionEscape};\n+use middle::ty::fold::{TypeFoldable, TypeFolder};\n+\n+use std::fmt;\n+\n+// structural impls for the structs in middle::traits\n+\n+impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Normalized({:?},{:?})\",\n+               self.value,\n+               self.obligations)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::RegionObligation<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n+               self.sub_region,\n+               self.sup_type)\n+    }\n+}\n+impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Obligation(predicate={:?},depth={})\",\n+               self.predicate,\n+               self.recursion_depth)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            super::VtableImpl(ref v) =>\n+                write!(f, \"{:?}\", v),\n+\n+            super::VtableDefaultImpl(ref t) =>\n+                write!(f, \"{:?}\", t),\n+\n+            super::VtableClosure(ref d) =>\n+                write!(f, \"{:?}\", d),\n+\n+            super::VtableFnPointer(ref d) =>\n+                write!(f, \"VtableFnPointer({:?})\", d),\n+\n+            super::VtableObject(ref d) =>\n+                write!(f, \"{:?}\", d),\n+\n+            super::VtableParam(ref n) =>\n+                write!(f, \"VtableParam({:?})\", n),\n+\n+            super::VtableBuiltin(ref d) =>\n+                write!(f, \"{:?}\", d)\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableImpl(impl_def_id={:?}, substs={:?}, nested={:?})\",\n+               self.impl_def_id,\n+               self.substs,\n+               self.nested)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+               self.closure_def_id,\n+               self.substs,\n+               self.nested)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableBuiltin(nested={:?})\", self.nested)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableDefaultImplData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableDefaultImplData(trait_def_id={:?}, nested={:?})\",\n+               self.trait_def_id,\n+               self.nested)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::VtableObjectData<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableObject(upcast={:?}, vtable_base={})\",\n+               self.upcast_trait_ref,\n+               self.vtable_base)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::FulfillmentError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"FulfillmentError({:?},{:?})\",\n+               self.obligation,\n+               self.code)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::FulfillmentErrorCode<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n+            super::CodeProjectionError(ref e) => write!(f, \"{:?}\", e),\n+            super::CodeAmbiguity => write!(f, \"Ambiguity\")\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"MismatchedProjectionTypes({:?})\", self.err)\n+    }\n+}\n+\n+impl<'tcx, P: RegionEscape> RegionEscape for traits::Obligation<'tcx,P> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.predicate.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx, T: HasTypeFlags> HasTypeFlags for traits::Obligation<'tcx, T> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.predicate.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx, T: HasTypeFlags> HasTypeFlags for Normalized<'tcx, T> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.value.has_type_flags(flags) ||\n+            self.obligations.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O>\n+{\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx, O> {\n+        traits::Obligation {\n+            cause: self.cause.clone(),\n+            recursion_depth: self.recursion_depth,\n+            predicate: self.predicate.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImplData<'tcx, N> {\n+        traits::VtableImplData {\n+            impl_def_id: self.impl_def_id,\n+            substs: self.substs.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableClosureData<'tcx, N> {\n+        traits::VtableClosureData {\n+            closure_def_id: self.closure_def_id,\n+            substs: self.substs.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultImplData<N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableDefaultImplData<N> {\n+        traits::VtableDefaultImplData {\n+            trait_def_id: self.trait_def_id,\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableBuiltinData<N> {\n+        traits::VtableBuiltinData {\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<'tcx, N> {\n+        match *self {\n+            traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n+            traits::VtableDefaultImpl(ref t) => traits::VtableDefaultImpl(t.fold_with(folder)),\n+            traits::VtableClosure(ref d) => {\n+                traits::VtableClosure(d.fold_with(folder))\n+            }\n+            traits::VtableFnPointer(ref d) => {\n+                traits::VtableFnPointer(d.fold_with(folder))\n+            }\n+            traits::VtableParam(ref n) => traits::VtableParam(n.fold_with(folder)),\n+            traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n+            traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n+        traits::VtableObjectData {\n+            upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n+            vtable_base: self.vtable_base\n+        }\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Normalized<'tcx, T> {\n+        Normalized {\n+            value: self.value.fold_with(folder),\n+            obligations: self.obligations.fold_with(folder),\n+        }\n+    }\n+}"}, {"sha": "1c5156aab02be9c0a53b57df21167d87e51d57d9", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 2, "deletions": 109, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -11,14 +11,12 @@\n use middle::def_id::DefId;\n use middle::infer::InferCtxt;\n use middle::subst::Substs;\n-use middle::ty::{self, HasTypeFlags, Ty, ToPredicate, ToPolyTraitRef};\n-use std::fmt;\n+use middle::ty::{self, Ty, ToPredicate, ToPolyTraitRef};\n use syntax::codemap::Span;\n use util::common::ErrorReported;\n use util::nodemap::FnvHashSet;\n \n-use super::{Obligation, ObligationCause, PredicateObligation,\n-            VtableImpl, VtableParam, VtableImplData, VtableDefaultImplData};\n+use super::{Obligation, ObligationCause, PredicateObligation};\n \n struct PredicateSet<'a,'tcx:'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n@@ -477,108 +475,3 @@ pub fn closure_trait_ref_and_return_type<'tcx>(\n     };\n     ty::Binder((trait_ref, sig.0.output.unwrap_or(tcx.mk_nil())))\n }\n-\n-impl<'tcx,O:fmt::Debug> fmt::Debug for super::Obligation<'tcx, O> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Obligation(predicate={:?},depth={})\",\n-               self.predicate,\n-               self.recursion_depth)\n-    }\n-}\n-\n-impl<'tcx, N:fmt::Debug> fmt::Debug for super::Vtable<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            super::VtableImpl(ref v) =>\n-                write!(f, \"{:?}\", v),\n-\n-            super::VtableDefaultImpl(ref t) =>\n-                write!(f, \"{:?}\", t),\n-\n-            super::VtableClosure(ref d) =>\n-                write!(f, \"{:?}\", d),\n-\n-            super::VtableFnPointer(ref d) =>\n-                write!(f, \"VtableFnPointer({:?})\", d),\n-\n-            super::VtableObject(ref d) =>\n-                write!(f, \"{:?}\", d),\n-\n-            super::VtableParam(ref n) =>\n-                write!(f, \"VtableParam({:?})\", n),\n-\n-            super::VtableBuiltin(ref d) =>\n-                write!(f, \"{:?}\", d)\n-        }\n-    }\n-}\n-\n-impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableImplData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableImpl(impl_def_id={:?}, substs={:?}, nested={:?})\",\n-               self.impl_def_id,\n-               self.substs,\n-               self.nested)\n-    }\n-}\n-\n-impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableClosureData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n-               self.closure_def_id,\n-               self.substs,\n-               self.nested)\n-    }\n-}\n-\n-impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableBuiltinData<N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableBuiltin(nested={:?})\", self.nested)\n-    }\n-}\n-\n-impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableDefaultImplData<N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableDefaultImplData(trait_def_id={:?}, nested={:?})\",\n-               self.trait_def_id,\n-               self.nested)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableObject(upcast={:?}, vtable_base={})\",\n-               self.upcast_trait_ref,\n-               self.vtable_base)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for super::FulfillmentError<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"FulfillmentError({:?},{:?})\",\n-               self.obligation,\n-               self.code)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for super::FulfillmentErrorCode<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n-            super::CodeProjectionError(ref e) => write!(f, \"{:?}\", e),\n-            super::CodeAmbiguity => write!(f, \"Ambiguity\")\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for super::MismatchedProjectionTypes<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"MismatchedProjectionTypes({:?})\", self.err)\n-    }\n-}\n-\n-impl<'tcx, T: HasTypeFlags> HasTypeFlags for Obligation<'tcx, T> {\n-    fn has_type_flags(&self, flags: ty::TypeFlags) -> bool {\n-        self.predicate.has_type_flags(flags)\n-    }\n-}"}, {"sha": "7f61526a8f903b487e04cc8b7d7bd524d9782730", "filename": "src/librustc/middle/ty.rs", "status": "removed", "additions": 0, "deletions": 7512, "changes": 7512, "blob_url": "https://github.com/rust-lang/rust/blob/e629dba0ee190cab49df0c5db299fb8d77264dda/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e629dba0ee190cab49df0c5db299fb8d77264dda/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e629dba0ee190cab49df0c5db299fb8d77264dda"}, {"sha": "5a3ad9095ad2c1b945b5f9af25ca7a85e93fee60", "filename": "src/librustc/middle/ty/_match.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2F_match.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n use middle::ty::{self, Ty};\n-use middle::ty_relate::{self, Relate, TypeRelation, RelateResult};\n+use middle::ty::error::TypeError;\n+use middle::ty::relate::{self, Relate, TypeRelation, RelateResult};\n \n /// A type \"A\" *matches* \"B\" if the fresh types in B could be\n /// substituted with values so as to make it equal to A. Matching is\n@@ -73,15 +74,15 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n \n             (&ty::TyInfer(_), _) |\n             (_, &ty::TyInfer(_)) => {\n-                Err(ty::TypeError::Sorts(ty_relate::expected_found(self, &a, &b)))\n+                Err(TypeError::Sorts(relate::expected_found(self, &a, &b)))\n             }\n \n             (&ty::TyError, _) | (_, &ty::TyError) => {\n                 Ok(self.tcx().types.err)\n             }\n \n             _ => {\n-                ty_relate::super_relate_tys(self, a, b)\n+                relate::super_relate_tys(self, a, b)\n             }\n         }\n     }", "previous_filename": "src/librustc/middle/ty_match.rs"}, {"sha": "cadab499c0765573225589f1b09f713ffc4e5b1e", "filename": "src/librustc/middle/ty/adjustment.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fadjustment.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::AutoAdjustment::*;\n+pub use self::AutoRef::*;\n+\n+use middle::ty::{self, Ty, TypeAndMut};\n+use middle::ty::HasTypeFlags;\n+use middle::ty::LvaluePreference::{NoPreference};\n+\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+use rustc_front::hir;\n+\n+#[derive(Copy, Clone)]\n+pub enum AutoAdjustment<'tcx> {\n+    AdjustReifyFnPointer,   // go from a fn-item type to a fn-pointer type\n+    AdjustUnsafeFnPointer,  // go from a safe fn pointer to an unsafe fn pointer\n+    AdjustDerefRef(AutoDerefRef<'tcx>),\n+}\n+\n+/// Represents coercing a pointer to a different kind of pointer - where 'kind'\n+/// here means either or both of raw vs borrowed vs unique and fat vs thin.\n+///\n+/// We transform pointers by following the following steps in order:\n+/// 1. Deref the pointer `self.autoderefs` times (may be 0).\n+/// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n+///    `&` or `*` pointer.\n+/// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n+///    which will do things like convert thin pointers to fat\n+///    pointers, or convert structs containing thin pointers to\n+///    structs containing fat pointers, or convert between fat\n+///    pointers.  We don't store the details of how the transform is\n+///    done (in fact, we don't know that, because it might depend on\n+///    the precise type parameters). We just store the target\n+///    type. Trans figures out what has to be done at monomorphization\n+///    time based on the precise source/target type at hand.\n+///\n+/// To make that more concrete, here are some common scenarios:\n+///\n+/// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n+/// Here the pointer will be dereferenced N times (where a dereference can\n+/// happen to to raw or borrowed pointers or any smart pointer which implements\n+/// Deref, including Box<_>). The number of dereferences is given by\n+/// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n+/// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n+/// None.\n+///\n+/// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n+/// with a thin pointer, deref a number of times, unsize the underlying data,\n+/// then autoref. The 'unsize' phase may change a fixed length array to a\n+/// dynamically sized one, a concrete object to a trait object, or statically\n+/// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n+/// represented by:\n+///\n+/// ```\n+/// AutoDerefRef {\n+///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n+///     autoref: Some(AutoPtr), // [i32] -> &[i32]\n+///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n+/// }\n+/// ```\n+///\n+/// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n+/// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n+/// The autoderef and -ref are the same as in the above example, but the type\n+/// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n+/// the underlying conversions from `[i32; 4]` to `[i32]`.\n+///\n+/// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n+/// that case, we have the pointer we need coming in, so there are no\n+/// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n+/// At some point, of course, `Box` should move out of the compiler, in which\n+/// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n+/// Box<[i32]> is represented by:\n+///\n+/// ```\n+/// AutoDerefRef {\n+///     autoderefs: 0,\n+///     autoref: None,\n+///     unsize: Some(Box<[i32]>),\n+/// }\n+/// ```\n+#[derive(Copy, Clone)]\n+pub struct AutoDerefRef<'tcx> {\n+    /// Step 1. Apply a number of dereferences, producing an lvalue.\n+    pub autoderefs: usize,\n+\n+    /// Step 2. Optionally produce a pointer/reference from the value.\n+    pub autoref: Option<AutoRef<'tcx>>,\n+\n+    /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n+    /// `&[T]`. The stored type is the target pointer type. Note that\n+    /// the source could be a thin or fat pointer.\n+    pub unsize: Option<Ty<'tcx>>,\n+}\n+\n+impl<'tcx> AutoAdjustment<'tcx> {\n+    pub fn is_identity(&self) -> bool {\n+        match *self {\n+            AdjustReifyFnPointer |\n+            AdjustUnsafeFnPointer => false,\n+            AdjustDerefRef(ref r) => r.is_identity(),\n+        }\n+    }\n+}\n+impl<'tcx> AutoDerefRef<'tcx> {\n+    pub fn is_identity(&self) -> bool {\n+        self.autoderefs == 0 && self.unsize.is_none() && self.autoref.is_none()\n+    }\n+}\n+\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum AutoRef<'tcx> {\n+    /// Convert from T to &T.\n+    AutoPtr(&'tcx ty::Region, hir::Mutability),\n+\n+    /// Convert from T to *T.\n+    /// Value to thin pointer.\n+    AutoUnsafe(hir::Mutability),\n+}\n+\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+pub enum CustomCoerceUnsized {\n+    /// Records the index of the field being coerced.\n+    Struct(usize)\n+}\n+\n+impl<'tcx> ty::TyS<'tcx> {\n+    /// See `expr_ty_adjusted`\n+    pub fn adjust<F>(&'tcx self, cx: &ty::ctxt<'tcx>,\n+                     span: Span,\n+                     expr_id: ast::NodeId,\n+                     adjustment: Option<&AutoAdjustment<'tcx>>,\n+                     mut method_type: F)\n+                     -> Ty<'tcx> where\n+        F: FnMut(ty::MethodCall) -> Option<Ty<'tcx>>,\n+    {\n+        if let ty::TyError = self.sty {\n+            return self;\n+        }\n+\n+        return match adjustment {\n+            Some(adjustment) => {\n+                match *adjustment {\n+                   AdjustReifyFnPointer => {\n+                        match self.sty {\n+                            ty::TyBareFn(Some(_), b) => {\n+                                cx.mk_fn(None, b)\n+                            }\n+                            _ => {\n+                                cx.sess.bug(\n+                                    &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n+                                              {:?}\", self));\n+                            }\n+                        }\n+                    }\n+\n+                   AdjustUnsafeFnPointer => {\n+                        match self.sty {\n+                            ty::TyBareFn(None, b) => cx.safe_to_unsafe_fn_ty(b),\n+                            ref b => {\n+                                cx.sess.bug(\n+                                    &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n+                                             {:?}\",\n+                                            b));\n+                            }\n+                        }\n+                   }\n+\n+                    AdjustDerefRef(ref adj) => {\n+                        let mut adjusted_ty = self;\n+\n+                        if !adjusted_ty.references_error() {\n+                            for i in 0..adj.autoderefs {\n+                                adjusted_ty =\n+                                    adjusted_ty.adjust_for_autoderef(cx,\n+                                                                     expr_id,\n+                                                                     span,\n+                                                                     i as u32,\n+                                                                     &mut method_type);\n+                            }\n+                        }\n+\n+                        if let Some(target) = adj.unsize {\n+                            target\n+                        } else {\n+                            adjusted_ty.adjust_for_autoref(cx, adj.autoref)\n+                        }\n+                    }\n+                }\n+            }\n+            None => self\n+        };\n+    }\n+\n+    pub fn adjust_for_autoderef<F>(&'tcx self,\n+                                   cx: &ty::ctxt<'tcx>,\n+                                   expr_id: ast::NodeId,\n+                                   expr_span: Span,\n+                                   autoderef: u32, // how many autoderefs so far?\n+                                   mut method_type: F)\n+                                   -> Ty<'tcx> where\n+        F: FnMut(ty::MethodCall) -> Option<Ty<'tcx>>,\n+    {\n+        let method_call = ty::MethodCall::autoderef(expr_id, autoderef);\n+        let mut adjusted_ty = self;\n+        if let Some(method_ty) = method_type(method_call) {\n+            // Method calls always have all late-bound regions\n+            // fully instantiated.\n+            let fn_ret = cx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n+            adjusted_ty = fn_ret.unwrap();\n+        }\n+        match adjusted_ty.builtin_deref(true, NoPreference) {\n+            Some(mt) => mt.ty,\n+            None => {\n+                cx.sess.span_bug(\n+                    expr_span,\n+                    &format!(\"the {}th autoderef failed: {}\",\n+                             autoderef,\n+                             adjusted_ty)\n+                        );\n+            }\n+        }\n+    }\n+\n+    pub fn adjust_for_autoref(&'tcx self, cx: &ty::ctxt<'tcx>,\n+                              autoref: Option<AutoRef<'tcx>>)\n+                              -> Ty<'tcx> {\n+        match autoref {\n+            None => self,\n+            Some(AutoPtr(r, m)) => {\n+                cx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n+            }\n+            Some(AutoUnsafe(m)) => {\n+                cx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n+            }\n+        }\n+    }\n+}"}, {"sha": "8cb4f941a2264eb8fc84a2e98c2022f6a6c76f97", "filename": "src/librustc/middle/ty/cast.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcast.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "previous_filename": "src/librustc/middle/cast.rs"}, {"sha": "bcce9e8ea54761d2f73b37728a349a2372698174", "filename": "src/librustc/middle/ty/contents.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -0,0 +1,269 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::def_id::{DefId};\n+use middle::ty::{self, Ty};\n+use util::common::{memoized};\n+use util::nodemap::FnvHashMap;\n+\n+use std::fmt;\n+use std::ops;\n+\n+use rustc_front::hir;\n+\n+/// Type contents is how the type checker reasons about kinds.\n+/// They track what kinds of things are found within a type.  You can\n+/// think of them as kind of an \"anti-kind\".  They track the kinds of values\n+/// and thinks that are contained in types.  Having a larger contents for\n+/// a type tends to rule that type *out* from various kinds.  For example,\n+/// a type that contains a reference is not sendable.\n+///\n+/// The reason we compute type contents and not kinds is that it is\n+/// easier for me (nmatsakis) to think about what is contained within\n+/// a type than to think about what is *not* contained within a type.\n+#[derive(Clone, Copy)]\n+pub struct TypeContents {\n+    pub bits: u64\n+}\n+\n+macro_rules! def_type_content_sets {\n+    (mod $mname:ident { $($name:ident = $bits:expr),+ }) => {\n+        #[allow(non_snake_case)]\n+        mod $mname {\n+            use super::TypeContents;\n+            $(\n+                #[allow(non_upper_case_globals)]\n+                pub const $name: TypeContents = TypeContents { bits: $bits };\n+             )+\n+        }\n+    }\n+}\n+\n+def_type_content_sets! {\n+    mod TC {\n+        None                                = 0b0000_0000__0000_0000__0000,\n+\n+        // Things that are interior to the value (first nibble):\n+        InteriorUnsafe                      = 0b0000_0000__0000_0000__0010,\n+        InteriorParam                       = 0b0000_0000__0000_0000__0100,\n+        // InteriorAll                         = 0b00000000__00000000__1111,\n+\n+        // Things that are owned by the value (second and third nibbles):\n+        OwnsOwned                           = 0b0000_0000__0000_0001__0000,\n+        OwnsDtor                            = 0b0000_0000__0000_0010__0000,\n+        OwnsAll                             = 0b0000_0000__1111_1111__0000,\n+\n+        // Things that mean drop glue is necessary\n+        NeedsDrop                           = 0b0000_0000__0000_0111__0000,\n+\n+        // All bits\n+        All                                 = 0b1111_1111__1111_1111__1111\n+    }\n+}\n+\n+impl TypeContents {\n+    pub fn when(&self, cond: bool) -> TypeContents {\n+        if cond {*self} else {TC::None}\n+    }\n+\n+    pub fn intersects(&self, tc: TypeContents) -> bool {\n+        (self.bits & tc.bits) != 0\n+    }\n+\n+    pub fn owns_owned(&self) -> bool {\n+        self.intersects(TC::OwnsOwned)\n+    }\n+\n+    pub fn interior_param(&self) -> bool {\n+        self.intersects(TC::InteriorParam)\n+    }\n+\n+    pub fn interior_unsafe(&self) -> bool {\n+        self.intersects(TC::InteriorUnsafe)\n+    }\n+\n+    pub fn needs_drop(&self, _: &ty::ctxt) -> bool {\n+        self.intersects(TC::NeedsDrop)\n+    }\n+\n+    /// Includes only those bits that still apply when indirected through a `Box` pointer\n+    pub fn owned_pointer(&self) -> TypeContents {\n+        TC::OwnsOwned | (*self & TC::OwnsAll)\n+    }\n+\n+    pub fn union<T, F>(v: &[T], mut f: F) -> TypeContents where\n+        F: FnMut(&T) -> TypeContents,\n+    {\n+        v.iter().fold(TC::None, |tc, ty| tc | f(ty))\n+    }\n+\n+    pub fn has_dtor(&self) -> bool {\n+        self.intersects(TC::OwnsDtor)\n+    }\n+}\n+\n+impl ops::BitOr for TypeContents {\n+    type Output = TypeContents;\n+\n+    fn bitor(self, other: TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits | other.bits}\n+    }\n+}\n+\n+impl ops::BitAnd for TypeContents {\n+    type Output = TypeContents;\n+\n+    fn bitand(self, other: TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits & other.bits}\n+    }\n+}\n+\n+impl ops::Sub for TypeContents {\n+    type Output = TypeContents;\n+\n+    fn sub(self, other: TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits & !other.bits}\n+    }\n+}\n+\n+impl fmt::Debug for TypeContents {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TypeContents({:b})\", self.bits)\n+    }\n+}\n+\n+impl<'tcx> ty::TyS<'tcx> {\n+    pub fn type_contents(&'tcx self, cx: &ty::ctxt<'tcx>) -> TypeContents {\n+        return memoized(&cx.tc_cache, self, |ty| {\n+            tc_ty(cx, ty, &mut FnvHashMap())\n+        });\n+\n+        fn tc_ty<'tcx>(cx: &ty::ctxt<'tcx>,\n+                       ty: Ty<'tcx>,\n+                       cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n+        {\n+            // Subtle: Note that we are *not* using cx.tc_cache here but rather a\n+            // private cache for this walk.  This is needed in the case of cyclic\n+            // types like:\n+            //\n+            //     struct List { next: Box<Option<List>>, ... }\n+            //\n+            // When computing the type contents of such a type, we wind up deeply\n+            // recursing as we go.  So when we encounter the recursive reference\n+            // to List, we temporarily use TC::None as its contents.  Later we'll\n+            // patch up the cache with the correct value, once we've computed it\n+            // (this is basically a co-inductive process, if that helps).  So in\n+            // the end we'll compute TC::OwnsOwned, in this case.\n+            //\n+            // The problem is, as we are doing the computation, we will also\n+            // compute an *intermediate* contents for, e.g., Option<List> of\n+            // TC::None.  This is ok during the computation of List itself, but if\n+            // we stored this intermediate value into cx.tc_cache, then later\n+            // requests for the contents of Option<List> would also yield TC::None\n+            // which is incorrect.  This value was computed based on the crutch\n+            // value for the type contents of list.  The correct value is\n+            // TC::OwnsOwned.  This manifested as issue #4821.\n+            match cache.get(&ty) {\n+                Some(tc) => { return *tc; }\n+                None => {}\n+            }\n+            match cx.tc_cache.borrow().get(&ty) {    // Must check both caches!\n+                Some(tc) => { return *tc; }\n+                None => {}\n+            }\n+            cache.insert(ty, TC::None);\n+\n+            let result = match ty.sty {\n+                // usize and isize are ffi-unsafe\n+                ty::TyUint(hir::TyUs) | ty::TyInt(hir::TyIs) => {\n+                    TC::None\n+                }\n+\n+                // Scalar and unique types are sendable, and durable\n+                ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n+                ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n+                ty::TyBareFn(..) | ty::TyChar => {\n+                    TC::None\n+                }\n+\n+                ty::TyBox(typ) => {\n+                    tc_ty(cx, typ, cache).owned_pointer()\n+                }\n+\n+                ty::TyTrait(_) => {\n+                    TC::All - TC::InteriorParam\n+                }\n+\n+                ty::TyRawPtr(_) => {\n+                    TC::None\n+                }\n+\n+                ty::TyRef(_, _) => {\n+                    TC::None\n+                }\n+\n+                ty::TyArray(ty, _) => {\n+                    tc_ty(cx, ty, cache)\n+                }\n+\n+                ty::TySlice(ty) => {\n+                    tc_ty(cx, ty, cache)\n+                }\n+                ty::TyStr => TC::None,\n+\n+                ty::TyClosure(_, ref substs) => {\n+                    TypeContents::union(&substs.upvar_tys, |ty| tc_ty(cx, &ty, cache))\n+                }\n+\n+                ty::TyTuple(ref tys) => {\n+                    TypeContents::union(&tys[..],\n+                                        |ty| tc_ty(cx, *ty, cache))\n+                }\n+\n+                ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                    let mut res =\n+                        TypeContents::union(&def.variants, |v| {\n+                            TypeContents::union(&v.fields, |f| {\n+                                tc_ty(cx, f.ty(cx, substs), cache)\n+                            })\n+                        });\n+\n+                    if def.has_dtor() {\n+                        res = res | TC::OwnsDtor;\n+                    }\n+\n+                    apply_lang_items(cx, def.did, res)\n+                }\n+\n+                ty::TyProjection(..) |\n+                ty::TyParam(_) => {\n+                    TC::All\n+                }\n+\n+                ty::TyInfer(_) |\n+                ty::TyError => {\n+                    cx.sess.bug(\"asked to compute contents of error type\");\n+                }\n+            };\n+\n+            cache.insert(ty, result);\n+            result\n+        }\n+\n+        fn apply_lang_items(cx: &ty::ctxt, did: DefId, tc: TypeContents)\n+                            -> TypeContents {\n+            if Some(did) == cx.lang_items.unsafe_cell_type() {\n+                tc | TC::InteriorUnsafe\n+            } else {\n+                tc\n+            }\n+        }\n+    }\n+}"}, {"sha": "e3b6da56680da303b5657aec0a52ecfe4cd93a81", "filename": "src/librustc/middle/ty/context.rs", "status": "added", "additions": 964, "deletions": 0, "changes": 964, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -0,0 +1,964 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! type context book-keeping\n+\n+// FIXME: (@jroesch) @eddyb should remove this when he renames ctxt\n+#![allow(non_camel_case_types)]\n+\n+use front::map as ast_map;\n+use session::Session;\n+use lint;\n+use middle;\n+use middle::def::DefMap;\n+use middle::def_id::DefId;\n+use middle::free_region::FreeRegionMap;\n+use middle::region::RegionMaps;\n+use middle::resolve_lifetime;\n+use middle::stability;\n+use middle::subst::{self, Subst, Substs};\n+use middle::traits;\n+use middle::ty::{self, TraitRef, Ty, TypeAndMut};\n+use middle::ty::{TyS, TypeVariants};\n+use middle::ty::{AdtDef, ClosureSubsts, ExistentialBounds, Region};\n+use middle::ty::{FreevarMap, GenericPredicates};\n+use middle::ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n+use middle::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n+use middle::ty::TypeVariants::*;\n+use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n+use util::nodemap::FnvHashMap;\n+\n+use arena::TypedArena;\n+use std::borrow::Borrow;\n+use std::cell::{Cell, RefCell, Ref};\n+use std::hash::{Hash, Hasher};\n+use std::rc::Rc;\n+use syntax::abi;\n+use syntax::ast::{Name, NodeId};\n+use syntax::parse::token::special_idents;\n+\n+use rustc_front::hir;\n+use rustc_front::attr;\n+\n+/// Internal storage\n+pub struct CtxtArenas<'tcx> {\n+    // internings\n+    type_: TypedArena<TyS<'tcx>>,\n+    substs: TypedArena<Substs<'tcx>>,\n+    bare_fn: TypedArena<BareFnTy<'tcx>>,\n+    region: TypedArena<Region>,\n+    stability: TypedArena<attr::Stability>,\n+\n+    // references\n+    trait_defs: TypedArena<ty::TraitDef<'tcx>>,\n+    adt_defs: TypedArena<ty::AdtDefData<'tcx, 'tcx>>,\n+}\n+\n+impl<'tcx> CtxtArenas<'tcx> {\n+    pub fn new() -> CtxtArenas<'tcx> {\n+        CtxtArenas {\n+            type_: TypedArena::new(),\n+            substs: TypedArena::new(),\n+            bare_fn: TypedArena::new(),\n+            region: TypedArena::new(),\n+            stability: TypedArena::new(),\n+\n+            trait_defs: TypedArena::new(),\n+            adt_defs: TypedArena::new()\n+        }\n+    }\n+}\n+\n+pub struct CommonTypes<'tcx> {\n+    pub bool: Ty<'tcx>,\n+    pub char: Ty<'tcx>,\n+    pub isize: Ty<'tcx>,\n+    pub i8: Ty<'tcx>,\n+    pub i16: Ty<'tcx>,\n+    pub i32: Ty<'tcx>,\n+    pub i64: Ty<'tcx>,\n+    pub usize: Ty<'tcx>,\n+    pub u8: Ty<'tcx>,\n+    pub u16: Ty<'tcx>,\n+    pub u32: Ty<'tcx>,\n+    pub u64: Ty<'tcx>,\n+    pub f32: Ty<'tcx>,\n+    pub f64: Ty<'tcx>,\n+    pub err: Ty<'tcx>,\n+}\n+\n+pub struct Tables<'tcx> {\n+    /// Stores the types for various nodes in the AST.  Note that this table\n+    /// is not guaranteed to be populated until after typeck.  See\n+    /// typeck::check::fn_ctxt for details.\n+    pub node_types: NodeMap<Ty<'tcx>>,\n+\n+    /// Stores the type parameters which were substituted to obtain the type\n+    /// of this node.  This only applies to nodes that refer to entities\n+    /// parameterized by type parameters, such as generic fns, types, or\n+    /// other items.\n+    pub item_substs: NodeMap<ty::ItemSubsts<'tcx>>,\n+\n+    pub adjustments: NodeMap<ty::adjustment::AutoAdjustment<'tcx>>,\n+\n+    pub method_map: ty::MethodMap<'tcx>,\n+\n+    /// Borrows\n+    pub upvar_capture_map: ty::UpvarCaptureMap,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_tys: DefIdMap<ty::ClosureTy<'tcx>>,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_kinds: DefIdMap<ty::ClosureKind>,\n+}\n+\n+impl<'tcx> Tables<'tcx> {\n+    pub fn empty() -> Tables<'tcx> {\n+        Tables {\n+            node_types: FnvHashMap(),\n+            item_substs: NodeMap(),\n+            adjustments: NodeMap(),\n+            method_map: FnvHashMap(),\n+            upvar_capture_map: FnvHashMap(),\n+            closure_tys: DefIdMap(),\n+            closure_kinds: DefIdMap(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> CommonTypes<'tcx> {\n+    fn new(arena: &'tcx TypedArena<TyS<'tcx>>,\n+           interner: &RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>)\n+           -> CommonTypes<'tcx>\n+    {\n+        let mk = |sty| ctxt::intern_ty(arena, interner, sty);\n+        CommonTypes {\n+            bool: mk(TyBool),\n+            char: mk(TyChar),\n+            err: mk(TyError),\n+            isize: mk(TyInt(hir::TyIs)),\n+            i8: mk(TyInt(hir::TyI8)),\n+            i16: mk(TyInt(hir::TyI16)),\n+            i32: mk(TyInt(hir::TyI32)),\n+            i64: mk(TyInt(hir::TyI64)),\n+            usize: mk(TyUint(hir::TyUs)),\n+            u8: mk(TyUint(hir::TyU8)),\n+            u16: mk(TyUint(hir::TyU16)),\n+            u32: mk(TyUint(hir::TyU32)),\n+            u64: mk(TyUint(hir::TyU64)),\n+            f32: mk(TyFloat(hir::TyF32)),\n+            f64: mk(TyFloat(hir::TyF64)),\n+        }\n+    }\n+}\n+\n+/// The data structure to keep track of all the information that typechecker\n+/// generates so that so that it can be reused and doesn't have to be redone\n+/// later on.\n+pub struct ctxt<'tcx> {\n+    /// The arenas that types etc are allocated from.\n+    arenas: &'tcx CtxtArenas<'tcx>,\n+\n+    /// Specifically use a speedy hash algorithm for this hash map, it's used\n+    /// quite often.\n+    // FIXME(eddyb) use a FnvHashSet<InternedTy<'tcx>> when equivalent keys can\n+    // queried from a HashSet.\n+    interner: RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n+\n+    // FIXME as above, use a hashset if equivalent elements can be queried.\n+    substs_interner: RefCell<FnvHashMap<&'tcx Substs<'tcx>, &'tcx Substs<'tcx>>>,\n+    bare_fn_interner: RefCell<FnvHashMap<&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>>>,\n+    region_interner: RefCell<FnvHashMap<&'tcx Region, &'tcx Region>>,\n+    stability_interner: RefCell<FnvHashMap<&'tcx attr::Stability, &'tcx attr::Stability>>,\n+\n+    /// Common types, pre-interned for your convenience.\n+    pub types: CommonTypes<'tcx>,\n+\n+    pub sess: Session,\n+    pub def_map: DefMap,\n+\n+    pub named_region_map: resolve_lifetime::NamedRegionMap,\n+\n+    pub region_maps: RegionMaps,\n+\n+    // For each fn declared in the local crate, type check stores the\n+    // free-region relationships that were deduced from its where\n+    // clauses and parameter types. These are then read-again by\n+    // borrowck. (They are not used during trans, and hence are not\n+    // serialized or needed for cross-crate fns.)\n+    free_region_maps: RefCell<NodeMap<FreeRegionMap>>,\n+    // FIXME: jroesch make this a refcell\n+\n+    pub tables: RefCell<Tables<'tcx>>,\n+\n+    /// Maps from a trait item to the trait item \"descriptor\"\n+    pub impl_or_trait_items: RefCell<DefIdMap<ty::ImplOrTraitItem<'tcx>>>,\n+\n+    /// Maps from a trait def-id to a list of the def-ids of its trait items\n+    pub trait_item_def_ids: RefCell<DefIdMap<Rc<Vec<ty::ImplOrTraitItemId>>>>,\n+\n+    /// A cache for the trait_items() routine\n+    pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ty::ImplOrTraitItem<'tcx>>>>>,\n+\n+    pub impl_trait_refs: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n+    pub trait_defs: RefCell<DefIdMap<&'tcx ty::TraitDef<'tcx>>>,\n+    pub adt_defs: RefCell<DefIdMap<ty::AdtDefMaster<'tcx>>>,\n+\n+    /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n+    /// associated predicates.\n+    pub predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n+\n+    /// Maps from the def-id of a trait to the list of\n+    /// super-predicates. This is a subset of the full list of\n+    /// predicates. We store these in a separate map because we must\n+    /// evaluate them even during type conversion, often before the\n+    /// full predicates are available (note that supertraits have\n+    /// additional acyclicity requirements).\n+    pub super_predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n+\n+    pub map: ast_map::Map<'tcx>,\n+    pub freevars: RefCell<FreevarMap>,\n+    pub tcache: RefCell<DefIdMap<ty::TypeScheme<'tcx>>>,\n+    pub rcache: RefCell<FnvHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n+    pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n+    pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n+    pub ty_param_defs: RefCell<NodeMap<ty::TypeParameterDef<'tcx>>>,\n+    pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n+    pub lang_items: middle::lang_items::LanguageItems,\n+    /// A mapping of fake provided method def_ids to the default implementation\n+    pub provided_method_sources: RefCell<DefIdMap<DefId>>,\n+\n+    /// Maps from def-id of a type or region parameter to its\n+    /// (inferred) variance.\n+    pub item_variance_map: RefCell<DefIdMap<Rc<ty::ItemVariances>>>,\n+\n+    /// True if the variance has been computed yet; false otherwise.\n+    pub variance_computed: Cell<bool>,\n+\n+    /// A method will be in this list if and only if it is a destructor.\n+    pub destructors: RefCell<DefIdSet>,\n+\n+    /// Maps a DefId of a type to a list of its inherent impls.\n+    /// Contains implementations of methods that are inherent to a type.\n+    /// Methods in these implementations don't need to be exported.\n+    pub inherent_impls: RefCell<DefIdMap<Rc<Vec<DefId>>>>,\n+\n+    /// Maps a DefId of an impl to a list of its items.\n+    /// Note that this contains all of the impls that we know about,\n+    /// including ones in other crates. It's not clear that this is the best\n+    /// way to do it.\n+    pub impl_items: RefCell<DefIdMap<Vec<ty::ImplOrTraitItemId>>>,\n+\n+    /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n+    /// present in this set can be warned about.\n+    pub used_unsafe: RefCell<NodeSet>,\n+\n+    /// Set of nodes which mark locals as mutable which end up getting used at\n+    /// some point. Local variable definitions not in this set can be warned\n+    /// about.\n+    pub used_mut_nodes: RefCell<NodeSet>,\n+\n+    /// The set of external nominal types whose implementations have been read.\n+    /// This is used for lazy resolution of methods.\n+    pub populated_external_types: RefCell<DefIdSet>,\n+    /// The set of external primitive types whose implementations have been read.\n+    /// FIXME(arielb1): why is this separate from populated_external_types?\n+    pub populated_external_primitive_impls: RefCell<DefIdSet>,\n+\n+    /// These caches are used by const_eval when decoding external constants.\n+    pub extern_const_statics: RefCell<DefIdMap<NodeId>>,\n+    pub extern_const_variants: RefCell<DefIdMap<NodeId>>,\n+    pub extern_const_fns: RefCell<DefIdMap<NodeId>>,\n+\n+    pub node_lint_levels: RefCell<FnvHashMap<(NodeId, lint::LintId),\n+                                              lint::LevelSource>>,\n+\n+    /// The types that must be asserted to be the same size for `transmute`\n+    /// to be valid. We gather up these restrictions in the intrinsicck pass\n+    /// and check them in trans.\n+    pub transmute_restrictions: RefCell<Vec<ty::TransmuteRestriction<'tcx>>>,\n+\n+    /// Maps any item's def-id to its stability index.\n+    pub stability: RefCell<stability::Index<'tcx>>,\n+\n+    /// Caches the results of trait selection. This cache is used\n+    /// for things that do not have to do with the parameters in scope.\n+    pub selection_cache: traits::SelectionCache<'tcx>,\n+\n+    /// A set of predicates that have been fulfilled *somewhere*.\n+    /// This is used to avoid duplicate work. Predicates are only\n+    /// added to this set when they mention only \"global\" names\n+    /// (i.e., no type or lifetime parameters).\n+    pub fulfilled_predicates: RefCell<traits::FulfilledPredicates<'tcx>>,\n+\n+    /// Caches the representation hints for struct definitions.\n+    pub repr_hint_cache: RefCell<DefIdMap<Rc<Vec<attr::ReprAttr>>>>,\n+\n+    /// Maps Expr NodeId's to their constant qualification.\n+    pub const_qualif_map: RefCell<NodeMap<middle::check_const::ConstQualif>>,\n+\n+    /// Caches CoerceUnsized kinds for impls on custom types.\n+    pub custom_coerce_unsized_kinds: RefCell<DefIdMap<ty::adjustment::CustomCoerceUnsized>>,\n+\n+    /// Maps a cast expression to its kind. This is keyed on the\n+    /// *from* expression of the cast, not the cast itself.\n+    pub cast_kinds: RefCell<NodeMap<ty::cast::CastKind>>,\n+\n+    /// Maps Fn items to a collection of fragment infos.\n+    ///\n+    /// The main goal is to identify data (each of which may be moved\n+    /// or assigned) whose subparts are not moved nor assigned\n+    /// (i.e. their state is *unfragmented*) and corresponding ast\n+    /// nodes where the path to that data is moved or assigned.\n+    ///\n+    /// In the long term, unfragmented values will have their\n+    /// destructor entirely driven by a single stack-local drop-flag,\n+    /// and their parents, the collections of the unfragmented values\n+    /// (or more simply, \"fragmented values\"), are mapped to the\n+    /// corresponding collections of stack-local drop-flags.\n+    ///\n+    /// (However, in the short term that is not the case; e.g. some\n+    /// unfragmented paths still need to be zeroed, namely when they\n+    /// reference parent data from an outer scope that was not\n+    /// entirely moved, and therefore that needs to be zeroed so that\n+    /// we do not get double-drop when we hit the end of the parent\n+    /// scope.)\n+    ///\n+    /// Also: currently the table solely holds keys for node-ids of\n+    /// unfragmented values (see `FragmentInfo` enum definition), but\n+    /// longer-term we will need to also store mappings from\n+    /// fragmented data to the set of unfragmented pieces that\n+    /// constitute it.\n+    pub fragment_infos: RefCell<DefIdMap<Vec<ty::FragmentInfo>>>,\n+}\n+impl<'tcx> ctxt<'tcx> {\n+    pub fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind {\n+        *self.tables.borrow().closure_kinds.get(&def_id).unwrap()\n+    }\n+\n+    pub fn closure_type(&self,\n+                        def_id: DefId,\n+                        substs: &ClosureSubsts<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n+    {\n+        self.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self, &substs.func_substs)\n+    }\n+\n+    pub fn type_parameter_def(&self,\n+                              node_id: NodeId)\n+                              -> ty::TypeParameterDef<'tcx>\n+    {\n+        self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n+    }\n+\n+    pub fn node_types(&self) -> Ref<NodeMap<Ty<'tcx>>> {\n+        fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) -> &'a NodeMap<Ty<'tcx>> {\n+            &tables.node_types\n+        }\n+\n+        Ref::map(self.tables.borrow(), projection)\n+    }\n+\n+    pub fn node_type_insert(&self, id: NodeId, ty: Ty<'tcx>) {\n+        self.tables.borrow_mut().node_types.insert(id, ty);\n+    }\n+\n+    pub fn intern_trait_def(&self, def: ty::TraitDef<'tcx>)\n+                            -> &'tcx ty::TraitDef<'tcx> {\n+        let did = def.trait_ref.def_id;\n+        let interned = self.arenas.trait_defs.alloc(def);\n+        self.trait_defs.borrow_mut().insert(did, interned);\n+        interned\n+    }\n+\n+    pub fn alloc_trait_def(&self, def: ty::TraitDef<'tcx>)\n+                           -> &'tcx ty::TraitDef<'tcx> {\n+        self.arenas.trait_defs.alloc(def)\n+    }\n+\n+    pub fn intern_adt_def(&self,\n+                          did: DefId,\n+                          kind: ty::AdtKind,\n+                          variants: Vec<ty::VariantDefData<'tcx, 'tcx>>)\n+                          -> ty::AdtDefMaster<'tcx> {\n+        let def = ty::AdtDefData::new(self, did, kind, variants);\n+        let interned = self.arenas.adt_defs.alloc(def);\n+        // this will need a transmute when reverse-variance is removed\n+        self.adt_defs.borrow_mut().insert(did, interned);\n+        interned\n+    }\n+\n+    pub fn intern_stability(&self, stab: attr::Stability) -> &'tcx attr::Stability {\n+        if let Some(st) = self.stability_interner.borrow().get(&stab) {\n+            return st;\n+        }\n+\n+        let interned = self.arenas.stability.alloc(stab);\n+        self.stability_interner.borrow_mut().insert(interned, interned);\n+        interned\n+    }\n+\n+    pub fn store_free_region_map(&self, id: NodeId, map: FreeRegionMap) {\n+        self.free_region_maps.borrow_mut()\n+                             .insert(id, map);\n+    }\n+\n+    pub fn free_region_map(&self, id: NodeId) -> FreeRegionMap {\n+        self.free_region_maps.borrow()[&id].clone()\n+    }\n+\n+    pub fn lift<T: ?Sized + Lift<'tcx>>(&self, value: &T) -> Option<T::Lifted> {\n+        value.lift_to_tcx(self)\n+    }\n+\n+    /// Create a type context and call the closure with a `&ty::ctxt` reference\n+    /// to the context. The closure enforces that the type context and any interned\n+    /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n+    /// reference to the context, to allow formatting values that need it.\n+    pub fn create_and_enter<F, R>(s: Session,\n+                                 arenas: &'tcx CtxtArenas<'tcx>,\n+                                 def_map: DefMap,\n+                                 named_region_map: resolve_lifetime::NamedRegionMap,\n+                                 map: ast_map::Map<'tcx>,\n+                                 freevars: RefCell<FreevarMap>,\n+                                 region_maps: RegionMaps,\n+                                 lang_items: middle::lang_items::LanguageItems,\n+                                 stability: stability::Index<'tcx>,\n+                                 f: F) -> (Session, R)\n+                                 where F: FnOnce(&ctxt<'tcx>) -> R\n+    {\n+        let interner = RefCell::new(FnvHashMap());\n+        let common_types = CommonTypes::new(&arenas.type_, &interner);\n+\n+        tls::enter(ctxt {\n+            arenas: arenas,\n+            interner: interner,\n+            substs_interner: RefCell::new(FnvHashMap()),\n+            bare_fn_interner: RefCell::new(FnvHashMap()),\n+            region_interner: RefCell::new(FnvHashMap()),\n+            stability_interner: RefCell::new(FnvHashMap()),\n+            types: common_types,\n+            named_region_map: named_region_map,\n+            region_maps: region_maps,\n+            free_region_maps: RefCell::new(FnvHashMap()),\n+            item_variance_map: RefCell::new(DefIdMap()),\n+            variance_computed: Cell::new(false),\n+            sess: s,\n+            def_map: def_map,\n+            tables: RefCell::new(Tables::empty()),\n+            impl_trait_refs: RefCell::new(DefIdMap()),\n+            trait_defs: RefCell::new(DefIdMap()),\n+            adt_defs: RefCell::new(DefIdMap()),\n+            predicates: RefCell::new(DefIdMap()),\n+            super_predicates: RefCell::new(DefIdMap()),\n+            fulfilled_predicates: RefCell::new(traits::FulfilledPredicates::new()),\n+            map: map,\n+            freevars: freevars,\n+            tcache: RefCell::new(DefIdMap()),\n+            rcache: RefCell::new(FnvHashMap()),\n+            tc_cache: RefCell::new(FnvHashMap()),\n+            ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n+            impl_or_trait_items: RefCell::new(DefIdMap()),\n+            trait_item_def_ids: RefCell::new(DefIdMap()),\n+            trait_items_cache: RefCell::new(DefIdMap()),\n+            ty_param_defs: RefCell::new(NodeMap()),\n+            normalized_cache: RefCell::new(FnvHashMap()),\n+            lang_items: lang_items,\n+            provided_method_sources: RefCell::new(DefIdMap()),\n+            destructors: RefCell::new(DefIdSet()),\n+            inherent_impls: RefCell::new(DefIdMap()),\n+            impl_items: RefCell::new(DefIdMap()),\n+            used_unsafe: RefCell::new(NodeSet()),\n+            used_mut_nodes: RefCell::new(NodeSet()),\n+            populated_external_types: RefCell::new(DefIdSet()),\n+            populated_external_primitive_impls: RefCell::new(DefIdSet()),\n+            extern_const_statics: RefCell::new(DefIdMap()),\n+            extern_const_variants: RefCell::new(DefIdMap()),\n+            extern_const_fns: RefCell::new(DefIdMap()),\n+            node_lint_levels: RefCell::new(FnvHashMap()),\n+            transmute_restrictions: RefCell::new(Vec::new()),\n+            stability: RefCell::new(stability),\n+            selection_cache: traits::SelectionCache::new(),\n+            repr_hint_cache: RefCell::new(DefIdMap()),\n+            const_qualif_map: RefCell::new(NodeMap()),\n+            custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n+            cast_kinds: RefCell::new(NodeMap()),\n+            fragment_infos: RefCell::new(DefIdMap()),\n+       }, f)\n+    }\n+}\n+\n+/// A trait implemented for all X<'a> types which can be safely and\n+/// efficiently converted to X<'tcx> as long as they are part of the\n+/// provided ty::ctxt<'tcx>.\n+/// This can be done, for example, for Ty<'tcx> or &'tcx Substs<'tcx>\n+/// by looking them up in their respective interners.\n+/// None is returned if the value or one of the components is not part\n+/// of the provided context.\n+/// For Ty, None can be returned if either the type interner doesn't\n+/// contain the TypeVariants key or if the address of the interned\n+/// pointer differs. The latter case is possible if a primitive type,\n+/// e.g. `()` or `u8`, was interned in a different context.\n+pub trait Lift<'tcx> {\n+    type Lifted;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted>;\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n+    type Lifted = Ty<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Ty<'tcx>> {\n+        if let Some(&ty) = tcx.interner.borrow().get(&self.sty) {\n+            if *self as *const _ == ty as *const _ {\n+                return Some(ty);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n+    type Lifted = &'tcx Substs<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<&'tcx Substs<'tcx>> {\n+        if let Some(&substs) = tcx.substs_interner.borrow().get(*self) {\n+            if *self as *const _ == substs as *const _ {\n+                return Some(substs);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+\n+pub mod tls {\n+    use middle::ty;\n+    use session::Session;\n+\n+    use std::fmt;\n+    use syntax::codemap;\n+\n+    /// Marker type used for the scoped TLS slot.\n+    /// The type context cannot be used directly because the scoped TLS\n+    /// in libstd doesn't allow types generic over lifetimes.\n+    struct ThreadLocalTyCx;\n+\n+    scoped_thread_local!(static TLS_TCX: ThreadLocalTyCx);\n+\n+    fn span_debug(span: codemap::Span, f: &mut fmt::Formatter) -> fmt::Result {\n+        with(|tcx| {\n+            write!(f, \"{}\", tcx.sess.codemap().span_to_string(span))\n+        })\n+    }\n+\n+    pub fn enter<'tcx, F: FnOnce(&ty::ctxt<'tcx>) -> R, R>(tcx: ty::ctxt<'tcx>, f: F)\n+                                                           -> (Session, R) {\n+        let result = codemap::SPAN_DEBUG.with(|span_dbg| {\n+            let original_span_debug = span_dbg.get();\n+            span_dbg.set(span_debug);\n+            let tls_ptr = &tcx as *const _ as *const ThreadLocalTyCx;\n+            let result = TLS_TCX.set(unsafe { &*tls_ptr }, || f(&tcx));\n+            span_dbg.set(original_span_debug);\n+            result\n+        });\n+        (tcx.sess, result)\n+    }\n+\n+    pub fn with<F: FnOnce(&ty::ctxt) -> R, R>(f: F) -> R {\n+        TLS_TCX.with(|tcx| f(unsafe { &*(tcx as *const _ as *const ty::ctxt) }))\n+    }\n+\n+    pub fn with_opt<F: FnOnce(Option<&ty::ctxt>) -> R, R>(f: F) -> R {\n+        if TLS_TCX.is_set() {\n+            with(|v| f(Some(v)))\n+        } else {\n+            f(None)\n+        }\n+    }\n+}\n+\n+macro_rules! sty_debug_print {\n+    ($ctxt: expr, $($variant: ident),*) => {{\n+        // curious inner module to allow variant names to be used as\n+        // variable names.\n+        #[allow(non_snake_case)]\n+        mod inner {\n+            use middle::ty;\n+            #[derive(Copy, Clone)]\n+            struct DebugStat {\n+                total: usize,\n+                region_infer: usize,\n+                ty_infer: usize,\n+                both_infer: usize,\n+            }\n+\n+            pub fn go(tcx: &ty::ctxt) {\n+                let mut total = DebugStat {\n+                    total: 0,\n+                    region_infer: 0, ty_infer: 0, both_infer: 0,\n+                };\n+                $(let mut $variant = total;)*\n+\n+\n+                for (_, t) in tcx.interner.borrow().iter() {\n+                    let variant = match t.sty {\n+                        ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n+                            ty::TyFloat(..) | ty::TyStr => continue,\n+                        ty::TyError => /* unimportant */ continue,\n+                        $(ty::$variant(..) => &mut $variant,)*\n+                    };\n+                    let region = t.flags.get().intersects(ty::TypeFlags::HAS_RE_INFER);\n+                    let ty = t.flags.get().intersects(ty::TypeFlags::HAS_TY_INFER);\n+\n+                    variant.total += 1;\n+                    total.total += 1;\n+                    if region { total.region_infer += 1; variant.region_infer += 1 }\n+                    if ty { total.ty_infer += 1; variant.ty_infer += 1 }\n+                    if region && ty { total.both_infer += 1; variant.both_infer += 1 }\n+                }\n+                println!(\"Ty interner             total           ty region  both\");\n+                $(println!(\"    {:18}: {uses:6} {usespc:4.1}%, \\\n+{ty:4.1}% {region:5.1}% {both:4.1}%\",\n+                           stringify!($variant),\n+                           uses = $variant.total,\n+                           usespc = $variant.total as f64 * 100.0 / total.total as f64,\n+                           ty = $variant.ty_infer as f64 * 100.0  / total.total as f64,\n+                           region = $variant.region_infer as f64 * 100.0  / total.total as f64,\n+                           both = $variant.both_infer as f64 * 100.0  / total.total as f64);\n+                  )*\n+                println!(\"                  total {uses:6}        \\\n+{ty:4.1}% {region:5.1}% {both:4.1}%\",\n+                         uses = total.total,\n+                         ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n+                         region = total.region_infer as f64 * 100.0  / total.total as f64,\n+                         both = total.both_infer as f64 * 100.0  / total.total as f64)\n+            }\n+        }\n+\n+        inner::go($ctxt)\n+    }}\n+}\n+\n+impl<'tcx> ctxt<'tcx> {\n+    pub fn print_debug_stats(&self) {\n+        sty_debug_print!(\n+            self,\n+            TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyBareFn, TyTrait,\n+            TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection);\n+\n+        println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n+        println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n+        println!(\"Region interner: #{}\", self.region_interner.borrow().len());\n+        println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n+    }\n+}\n+\n+\n+/// An entry in the type interner.\n+pub struct InternedTy<'tcx> {\n+    ty: Ty<'tcx>\n+}\n+\n+// NB: An InternedTy compares and hashes as a sty.\n+impl<'tcx> PartialEq for InternedTy<'tcx> {\n+    fn eq(&self, other: &InternedTy<'tcx>) -> bool {\n+        self.ty.sty == other.ty.sty\n+    }\n+}\n+\n+impl<'tcx> Eq for InternedTy<'tcx> {}\n+\n+impl<'tcx> Hash for InternedTy<'tcx> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.ty.sty.hash(s)\n+    }\n+}\n+\n+impl<'tcx> Borrow<TypeVariants<'tcx>> for InternedTy<'tcx> {\n+    fn borrow<'a>(&'a self) -> &'a TypeVariants<'tcx> {\n+        &self.ty.sty\n+    }\n+}\n+\n+fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n+    bounds.is_empty() ||\n+        bounds[1..].iter().enumerate().all(\n+            |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n+}\n+\n+impl<'tcx> ctxt<'tcx> {\n+    // Type constructors\n+    pub fn mk_substs(&self, substs: Substs<'tcx>) -> &'tcx Substs<'tcx> {\n+        if let Some(substs) = self.substs_interner.borrow().get(&substs) {\n+            return *substs;\n+        }\n+\n+        let substs = self.arenas.substs.alloc(substs);\n+        self.substs_interner.borrow_mut().insert(substs, substs);\n+        substs\n+    }\n+\n+    /// Create an unsafe fn ty based on a safe fn ty.\n+    pub fn safe_to_unsafe_fn_ty(&self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n+        assert_eq!(bare_fn.unsafety, hir::Unsafety::Normal);\n+        let unsafe_fn_ty_a = self.mk_bare_fn(ty::BareFnTy {\n+            unsafety: hir::Unsafety::Unsafe,\n+            abi: bare_fn.abi,\n+            sig: bare_fn.sig.clone()\n+        });\n+        self.mk_fn(None, unsafe_fn_ty_a)\n+    }\n+\n+    pub fn mk_bare_fn(&self, bare_fn: BareFnTy<'tcx>) -> &'tcx BareFnTy<'tcx> {\n+        if let Some(bare_fn) = self.bare_fn_interner.borrow().get(&bare_fn) {\n+            return *bare_fn;\n+        }\n+\n+        let bare_fn = self.arenas.bare_fn.alloc(bare_fn);\n+        self.bare_fn_interner.borrow_mut().insert(bare_fn, bare_fn);\n+        bare_fn\n+    }\n+\n+    pub fn mk_region(&self, region: Region) -> &'tcx Region {\n+        if let Some(region) = self.region_interner.borrow().get(&region) {\n+            return *region;\n+        }\n+\n+        let region = self.arenas.region.alloc(region);\n+        self.region_interner.borrow_mut().insert(region, region);\n+        region\n+    }\n+\n+    fn intern_ty(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n+                 interner: &RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n+                 st: TypeVariants<'tcx>)\n+                 -> Ty<'tcx> {\n+        let ty: Ty /* don't be &mut TyS */ = {\n+            let mut interner = interner.borrow_mut();\n+            match interner.get(&st) {\n+                Some(ty) => return *ty,\n+                _ => ()\n+            }\n+\n+            let flags = super::flags::FlagComputation::for_sty(&st);\n+\n+            let ty = match () {\n+                () => type_arena.alloc(TyS { sty: st,\n+                                             flags: Cell::new(flags.flags),\n+                                             region_depth: flags.depth, }),\n+            };\n+\n+            interner.insert(InternedTy { ty: ty }, ty);\n+            ty\n+        };\n+\n+        debug!(\"Interned type: {:?} Pointer: {:?}\",\n+            ty, ty as *const TyS);\n+        ty\n+    }\n+\n+    // Interns a type/name combination, stores the resulting box in cx.interner,\n+    // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n+    pub fn mk_ty(&self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n+        ctxt::intern_ty(&self.arenas.type_, &self.interner, st)\n+    }\n+\n+    pub fn mk_mach_int(&self, tm: hir::IntTy) -> Ty<'tcx> {\n+        match tm {\n+            hir::TyIs   => self.types.isize,\n+            hir::TyI8   => self.types.i8,\n+            hir::TyI16  => self.types.i16,\n+            hir::TyI32  => self.types.i32,\n+            hir::TyI64  => self.types.i64,\n+        }\n+    }\n+\n+    pub fn mk_mach_uint(&self, tm: hir::UintTy) -> Ty<'tcx> {\n+        match tm {\n+            hir::TyUs   => self.types.usize,\n+            hir::TyU8   => self.types.u8,\n+            hir::TyU16  => self.types.u16,\n+            hir::TyU32  => self.types.u32,\n+            hir::TyU64  => self.types.u64,\n+        }\n+    }\n+\n+    pub fn mk_mach_float(&self, tm: hir::FloatTy) -> Ty<'tcx> {\n+        match tm {\n+            hir::TyF32  => self.types.f32,\n+            hir::TyF64  => self.types.f64,\n+        }\n+    }\n+\n+    pub fn mk_str(&self) -> Ty<'tcx> {\n+        self.mk_ty(TyStr)\n+    }\n+\n+    pub fn mk_static_str(&self) -> Ty<'tcx> {\n+        self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n+    }\n+\n+    pub fn mk_enum(&self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        // take a copy of substs so that we own the vectors inside\n+        self.mk_ty(TyEnum(def, substs))\n+    }\n+\n+    pub fn mk_box(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyBox(ty))\n+    }\n+\n+    pub fn mk_ptr(&self, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyRawPtr(tm))\n+    }\n+\n+    pub fn mk_ref(&self, r: &'tcx Region, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyRef(r, tm))\n+    }\n+\n+    pub fn mk_mut_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n+    }\n+\n+    pub fn mk_imm_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n+    }\n+\n+    pub fn mk_mut_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n+    }\n+\n+    pub fn mk_imm_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n+    }\n+\n+    pub fn mk_nil_ptr(&self) -> Ty<'tcx> {\n+        self.mk_imm_ptr(self.mk_nil())\n+    }\n+\n+    pub fn mk_array(&self, ty: Ty<'tcx>, n: usize) -> Ty<'tcx> {\n+        self.mk_ty(TyArray(ty, n))\n+    }\n+\n+    pub fn mk_slice(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TySlice(ty))\n+    }\n+\n+    pub fn mk_tup(&self, ts: Vec<Ty<'tcx>>) -> Ty<'tcx> {\n+        self.mk_ty(TyTuple(ts))\n+    }\n+\n+    pub fn mk_nil(&self) -> Ty<'tcx> {\n+        self.mk_tup(Vec::new())\n+    }\n+\n+    pub fn mk_bool(&self) -> Ty<'tcx> {\n+        self.mk_ty(TyBool)\n+    }\n+\n+    pub fn mk_fn(&self,\n+                 opt_def_id: Option<DefId>,\n+                 fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyBareFn(opt_def_id, fty))\n+    }\n+\n+    pub fn mk_ctor_fn(&self,\n+                      def_id: DefId,\n+                      input_tys: &[Ty<'tcx>],\n+                      output: Ty<'tcx>) -> Ty<'tcx> {\n+        let input_args = input_tys.iter().cloned().collect();\n+        self.mk_fn(Some(def_id), self.mk_bare_fn(BareFnTy {\n+            unsafety: hir::Unsafety::Normal,\n+            abi: abi::Rust,\n+            sig: ty::Binder(ty::FnSig {\n+                inputs: input_args,\n+                output: ty::FnConverging(output),\n+                variadic: false\n+            })\n+        }))\n+    }\n+\n+    pub fn mk_trait(&self,\n+                    principal: ty::PolyTraitRef<'tcx>,\n+                    bounds: ExistentialBounds<'tcx>)\n+                    -> Ty<'tcx>\n+    {\n+        assert!(bound_list_is_sorted(&bounds.projection_bounds));\n+\n+        let inner = box TraitTy {\n+            principal: principal,\n+            bounds: bounds\n+        };\n+        self.mk_ty(TyTrait(inner))\n+    }\n+\n+    pub fn mk_projection(&self,\n+                         trait_ref: TraitRef<'tcx>,\n+                         item_name: Name)\n+                         -> Ty<'tcx> {\n+        // take a copy of substs so that we own the vectors inside\n+        let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n+        self.mk_ty(TyProjection(inner))\n+    }\n+\n+    pub fn mk_struct(&self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        // take a copy of substs so that we own the vectors inside\n+        self.mk_ty(TyStruct(def, substs))\n+    }\n+\n+    pub fn mk_closure(&self,\n+                      closure_id: DefId,\n+                      substs: &'tcx Substs<'tcx>,\n+                      tys: Vec<Ty<'tcx>>)\n+                      -> Ty<'tcx> {\n+        self.mk_closure_from_closure_substs(closure_id, Box::new(ClosureSubsts {\n+            func_substs: substs,\n+            upvar_tys: tys\n+        }))\n+    }\n+\n+    pub fn mk_closure_from_closure_substs(&self,\n+                                          closure_id: DefId,\n+                                          closure_substs: Box<ClosureSubsts<'tcx>>)\n+                                          -> Ty<'tcx> {\n+        self.mk_ty(TyClosure(closure_id, closure_substs))\n+    }\n+\n+    pub fn mk_var(&self, v: TyVid) -> Ty<'tcx> {\n+        self.mk_infer(TyVar(v))\n+    }\n+\n+    pub fn mk_int_var(&self, v: IntVid) -> Ty<'tcx> {\n+        self.mk_infer(IntVar(v))\n+    }\n+\n+    pub fn mk_float_var(&self, v: FloatVid) -> Ty<'tcx> {\n+        self.mk_infer(FloatVar(v))\n+    }\n+\n+    pub fn mk_infer(&self, it: InferTy) -> Ty<'tcx> {\n+        self.mk_ty(TyInfer(it))\n+    }\n+\n+    pub fn mk_param(&self,\n+                    space: subst::ParamSpace,\n+                    index: u32,\n+                    name: Name) -> Ty<'tcx> {\n+        self.mk_ty(TyParam(ParamTy { space: space, idx: index, name: name }))\n+    }\n+\n+    pub fn mk_self_type(&self) -> Ty<'tcx> {\n+        self.mk_param(subst::SelfSpace, 0, special_idents::type_self.name)\n+    }\n+\n+    pub fn mk_param_from_def(&self, def: &ty::TypeParameterDef) -> Ty<'tcx> {\n+        self.mk_param(def.space, def.index, def.name)\n+    }\n+}"}, {"sha": "72c4366c5bcd5a8f189a1fef6080eed41527de69", "filename": "src/librustc/middle/ty/error.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -0,0 +1,342 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::def_id::DefId;\n+use middle::subst;\n+use middle::infer::type_variable;\n+use middle::ty::{self, BoundRegion, Region, Ty};\n+\n+use std::fmt;\n+use syntax::abi;\n+use syntax::ast::Name;\n+use syntax::codemap::Span;\n+\n+use rustc_front::hir;\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct ExpectedFound<T> {\n+    pub expected: T,\n+    pub found: T\n+}\n+\n+// Data structures used in type unification\n+#[derive(Clone, Debug)]\n+pub enum TypeError<'tcx> {\n+    Mismatch,\n+    UnsafetyMismatch(ExpectedFound<hir::Unsafety>),\n+    AbiMismatch(ExpectedFound<abi::Abi>),\n+    Mutability,\n+    BoxMutability,\n+    PtrMutability,\n+    RefMutability,\n+    VecMutability,\n+    TupleSize(ExpectedFound<usize>),\n+    FixedArraySize(ExpectedFound<usize>),\n+    TyParamSize(ExpectedFound<usize>),\n+    ArgCount,\n+    RegionsDoesNotOutlive(Region, Region),\n+    RegionsNotSame(Region, Region),\n+    RegionsNoOverlap(Region, Region),\n+    RegionsInsufficientlyPolymorphic(BoundRegion, Region),\n+    RegionsOverlyPolymorphic(BoundRegion, Region),\n+    Sorts(ExpectedFound<Ty<'tcx>>),\n+    IntegerAsChar,\n+    IntMismatch(ExpectedFound<ty::IntVarValue>),\n+    FloatMismatch(ExpectedFound<hir::FloatTy>),\n+    Traits(ExpectedFound<DefId>),\n+    BuiltinBoundsMismatch(ExpectedFound<ty::BuiltinBounds>),\n+    VariadicMismatch(ExpectedFound<bool>),\n+    CyclicTy,\n+    ConvergenceMismatch(ExpectedFound<bool>),\n+    ProjectionNameMismatched(ExpectedFound<Name>),\n+    ProjectionBoundsLength(ExpectedFound<usize>),\n+    TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>)\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n+pub enum UnconstrainedNumeric {\n+    UnconstrainedFloat,\n+    UnconstrainedInt,\n+    Neither,\n+}\n+\n+/// Explains the source of a type err in a short, human readable way. This is meant to be placed\n+/// in parentheses after some larger message. You should also invoke `note_and_explain_type_err()`\n+/// afterwards to present additional details, particularly when it comes to lifetime-related\n+/// errors.\n+impl<'tcx> fmt::Display for TypeError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use self::TypeError::*;\n+        fn report_maybe_different(f: &mut fmt::Formatter,\n+                                  expected: String, found: String) -> fmt::Result {\n+            // A naive approach to making sure that we're not reporting silly errors such as:\n+            // (expected closure, found closure).\n+            if expected == found {\n+                write!(f, \"expected {}, found a different {}\", expected, found)\n+            } else {\n+                write!(f, \"expected {}, found {}\", expected, found)\n+            }\n+        }\n+\n+        match *self {\n+            CyclicTy => write!(f, \"cyclic type of infinite size\"),\n+            Mismatch => write!(f, \"types differ\"),\n+            UnsafetyMismatch(values) => {\n+                write!(f, \"expected {} fn, found {} fn\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            AbiMismatch(values) => {\n+                write!(f, \"expected {} fn, found {} fn\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            Mutability => write!(f, \"values differ in mutability\"),\n+            BoxMutability => {\n+                write!(f, \"boxed values differ in mutability\")\n+            }\n+            VecMutability => write!(f, \"vectors differ in mutability\"),\n+            PtrMutability => write!(f, \"pointers differ in mutability\"),\n+            RefMutability => write!(f, \"references differ in mutability\"),\n+            TyParamSize(values) => {\n+                write!(f, \"expected a type with {} type params, \\\n+                           found one with {} type params\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            FixedArraySize(values) => {\n+                write!(f, \"expected an array with a fixed size of {} elements, \\\n+                           found one with {} elements\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            TupleSize(values) => {\n+                write!(f, \"expected a tuple with {} elements, \\\n+                           found one with {} elements\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            ArgCount => {\n+                write!(f, \"incorrect number of function parameters\")\n+            }\n+            RegionsDoesNotOutlive(..) => {\n+                write!(f, \"lifetime mismatch\")\n+            }\n+            RegionsNotSame(..) => {\n+                write!(f, \"lifetimes are not the same\")\n+            }\n+            RegionsNoOverlap(..) => {\n+                write!(f, \"lifetimes do not intersect\")\n+            }\n+            RegionsInsufficientlyPolymorphic(br, _) => {\n+                write!(f, \"expected bound lifetime parameter {}, \\\n+                           found concrete lifetime\", br)\n+            }\n+            RegionsOverlyPolymorphic(br, _) => {\n+                write!(f, \"expected concrete lifetime, \\\n+                           found bound lifetime parameter {}\", br)\n+            }\n+            Sorts(values) => ty::tls::with(|tcx| {\n+                report_maybe_different(f, values.expected.sort_string(tcx),\n+                                       values.found.sort_string(tcx))\n+            }),\n+            Traits(values) => ty::tls::with(|tcx| {\n+                report_maybe_different(f,\n+                                       format!(\"trait `{}`\",\n+                                               tcx.item_path_str(values.expected)),\n+                                       format!(\"trait `{}`\",\n+                                               tcx.item_path_str(values.found)))\n+            }),\n+            BuiltinBoundsMismatch(values) => {\n+                if values.expected.is_empty() {\n+                    write!(f, \"expected no bounds, found `{}`\",\n+                           values.found)\n+                } else if values.found.is_empty() {\n+                    write!(f, \"expected bounds `{}`, found no bounds\",\n+                           values.expected)\n+                } else {\n+                    write!(f, \"expected bounds `{}`, found bounds `{}`\",\n+                           values.expected,\n+                           values.found)\n+                }\n+            }\n+            IntegerAsChar => {\n+                write!(f, \"expected an integral type, found `char`\")\n+            }\n+            IntMismatch(ref values) => {\n+                write!(f, \"expected `{:?}`, found `{:?}`\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            FloatMismatch(ref values) => {\n+                write!(f, \"expected `{:?}`, found `{:?}`\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            VariadicMismatch(ref values) => {\n+                write!(f, \"expected {} fn, found {} function\",\n+                       if values.expected { \"variadic\" } else { \"non-variadic\" },\n+                       if values.found { \"variadic\" } else { \"non-variadic\" })\n+            }\n+            ConvergenceMismatch(ref values) => {\n+                write!(f, \"expected {} fn, found {} function\",\n+                       if values.expected { \"converging\" } else { \"diverging\" },\n+                       if values.found { \"converging\" } else { \"diverging\" })\n+            }\n+            ProjectionNameMismatched(ref values) => {\n+                write!(f, \"expected {}, found {}\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            ProjectionBoundsLength(ref values) => {\n+                write!(f, \"expected {} associated type bindings, found {}\",\n+                       values.expected,\n+                       values.found)\n+            },\n+            TyParamDefaultMismatch(ref values) => {\n+                write!(f, \"conflicting type parameter defaults `{}` and `{}`\",\n+                       values.expected.ty,\n+                       values.found.ty)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> ty::TyS<'tcx> {\n+    fn sort_string(&self, cx: &ty::ctxt) -> String {\n+        match self.sty {\n+            ty::TyBool | ty::TyChar | ty::TyInt(_) |\n+            ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr => self.to_string(),\n+            ty::TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n+\n+            ty::TyEnum(def, _) => format!(\"enum `{}`\", cx.item_path_str(def.did)),\n+            ty::TyBox(_) => \"box\".to_string(),\n+            ty::TyArray(_, n) => format!(\"array of {} elements\", n),\n+            ty::TySlice(_) => \"slice\".to_string(),\n+            ty::TyRawPtr(_) => \"*-ptr\".to_string(),\n+            ty::TyRef(_, _) => \"&-ptr\".to_string(),\n+            ty::TyBareFn(Some(_), _) => format!(\"fn item\"),\n+            ty::TyBareFn(None, _) => \"fn pointer\".to_string(),\n+            ty::TyTrait(ref inner) => {\n+                format!(\"trait {}\", cx.item_path_str(inner.principal_def_id()))\n+            }\n+            ty::TyStruct(def, _) => {\n+                format!(\"struct `{}`\", cx.item_path_str(def.did))\n+            }\n+            ty::TyClosure(..) => \"closure\".to_string(),\n+            ty::TyTuple(_) => \"tuple\".to_string(),\n+            ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),\n+            ty::TyInfer(ty::IntVar(_)) => \"integral variable\".to_string(),\n+            ty::TyInfer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),\n+            ty::TyInfer(ty::FreshTy(_)) => \"skolemized type\".to_string(),\n+            ty::TyInfer(ty::FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n+            ty::TyInfer(ty::FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n+            ty::TyProjection(_) => \"associated type\".to_string(),\n+            ty::TyParam(ref p) => {\n+                if p.space == subst::SelfSpace {\n+                    \"Self\".to_string()\n+                } else {\n+                    \"type parameter\".to_string()\n+                }\n+            }\n+            ty::TyError => \"type error\".to_string(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> ty::ctxt<'tcx> {\n+    pub fn note_and_explain_type_err(&self, err: &TypeError<'tcx>, sp: Span) {\n+        use self::TypeError::*;\n+\n+        match err.clone() {\n+            RegionsDoesNotOutlive(subregion, superregion) => {\n+                self.note_and_explain_region(\"\", subregion, \"...\");\n+                self.note_and_explain_region(\"...does not necessarily outlive \",\n+                                           superregion, \"\");\n+            }\n+            RegionsNotSame(region1, region2) => {\n+                self.note_and_explain_region(\"\", region1, \"...\");\n+                self.note_and_explain_region(\"...is not the same lifetime as \",\n+                                           region2, \"\");\n+            }\n+            RegionsNoOverlap(region1, region2) => {\n+                self.note_and_explain_region(\"\", region1, \"...\");\n+                self.note_and_explain_region(\"...does not overlap \",\n+                                           region2, \"\");\n+            }\n+            RegionsInsufficientlyPolymorphic(_, conc_region) => {\n+                self.note_and_explain_region(\"concrete lifetime that was found is \",\n+                                           conc_region, \"\");\n+            }\n+            RegionsOverlyPolymorphic(_, ty::ReVar(_)) => {\n+                // don't bother to print out the message below for\n+                // inference variables, it's not very illuminating.\n+            }\n+            RegionsOverlyPolymorphic(_, conc_region) => {\n+                self.note_and_explain_region(\"expected concrete lifetime is \",\n+                                           conc_region, \"\");\n+            }\n+            Sorts(values) => {\n+                let expected_str = values.expected.sort_string(self);\n+                let found_str = values.found.sort_string(self);\n+                if expected_str == found_str && expected_str == \"closure\" {\n+                    self.sess.span_note(sp,\n+                        &format!(\"no two closures, even if identical, have the same type\"));\n+                    self.sess.span_help(sp,\n+                        &format!(\"consider boxing your closure and/or \\\n+                                  using it as a trait object\"));\n+                }\n+            },\n+            TyParamDefaultMismatch(values) => {\n+                let expected = values.expected;\n+                let found = values.found;\n+                self.sess.span_note(sp,\n+                                    &format!(\"conflicting type parameter defaults `{}` and `{}`\",\n+                                             expected.ty,\n+                                             found.ty));\n+\n+                match (expected.def_id.is_local(),\n+                       self.map.opt_span(expected.def_id.node)) {\n+                    (true, Some(span)) => {\n+                        self.sess.span_note(span,\n+                                            &format!(\"a default was defined here...\"));\n+                    }\n+                    (_, _) => {\n+                        self.sess.note(\n+                            &format!(\"a default is defined on `{}`\",\n+                                     self.item_path_str(expected.def_id)));\n+                    }\n+                }\n+\n+                self.sess.span_note(\n+                    expected.origin_span,\n+                    &format!(\"...that was applied to an unconstrained type variable here\"));\n+\n+                match (found.def_id.is_local(),\n+                       self.map.opt_span(found.def_id.node)) {\n+                    (true, Some(span)) => {\n+                        self.sess.span_note(span,\n+                                            &format!(\"a second default was defined here...\"));\n+                    }\n+                    (_, _) => {\n+                        self.sess.note(\n+                            &format!(\"a second default is defined on `{}`\",\n+                                     self.item_path_str(found.def_id)));\n+                    }\n+                }\n+\n+                self.sess.span_note(\n+                    found.origin_span,\n+                    &format!(\"...that also applies to the same type variable here\"));\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "2b81be19182e2d525e568e97d678c402481f448b", "filename": "src/librustc/middle/ty/fast_reject.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "previous_filename": "src/librustc/middle/fast_reject.rs"}, {"sha": "94a50e3cac7f75e107ca416c40aab08fa71db2ba", "filename": "src/librustc/middle/ty/flags.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fflags.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -0,0 +1,205 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::subst;\n+use middle::ty::{self, HasTypeFlags, Ty, TypeFlags};\n+\n+pub struct FlagComputation {\n+    pub flags: TypeFlags,\n+\n+    // maximum depth of any bound region that we have seen thus far\n+    pub depth: u32,\n+}\n+\n+impl FlagComputation {\n+    fn new() -> FlagComputation {\n+        FlagComputation { flags: TypeFlags::empty(), depth: 0 }\n+    }\n+\n+    pub fn for_sty(st: &ty::TypeVariants) -> FlagComputation {\n+        let mut result = FlagComputation::new();\n+        result.add_sty(st);\n+        result\n+    }\n+\n+    fn add_flags(&mut self, flags: TypeFlags) {\n+        self.flags = self.flags | (flags & TypeFlags::NOMINAL_FLAGS);\n+    }\n+\n+    fn add_depth(&mut self, depth: u32) {\n+        if depth > self.depth {\n+            self.depth = depth;\n+        }\n+    }\n+\n+    /// Adds the flags/depth from a set of types that appear within the current type, but within a\n+    /// region binder.\n+    fn add_bound_computation(&mut self, computation: &FlagComputation) {\n+        self.add_flags(computation.flags);\n+\n+        // The types that contributed to `computation` occurred within\n+        // a region binder, so subtract one from the region depth\n+        // within when adding the depth to `self`.\n+        let depth = computation.depth;\n+        if depth > 0 {\n+            self.add_depth(depth - 1);\n+        }\n+    }\n+\n+    fn add_sty(&mut self, st: &ty::TypeVariants) {\n+        match st {\n+            &ty::TyBool |\n+            &ty::TyChar |\n+            &ty::TyInt(_) |\n+            &ty::TyFloat(_) |\n+            &ty::TyUint(_) |\n+            &ty::TyStr => {\n+            }\n+\n+            // You might think that we could just return TyError for\n+            // any type containing TyError as a component, and get\n+            // rid of the TypeFlags::HAS_TY_ERR flag -- likewise for ty_bot (with\n+            // the exception of function types that return bot).\n+            // But doing so caused sporadic memory corruption, and\n+            // neither I (tjc) nor nmatsakis could figure out why,\n+            // so we're doing it this way.\n+            &ty::TyError => {\n+                self.add_flags(TypeFlags::HAS_TY_ERR)\n+            }\n+\n+            &ty::TyParam(ref p) => {\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n+                if p.space == subst::SelfSpace {\n+                    self.add_flags(TypeFlags::HAS_SELF);\n+                } else {\n+                    self.add_flags(TypeFlags::HAS_PARAMS);\n+                }\n+            }\n+\n+            &ty::TyClosure(_, ref substs) => {\n+                self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n+                self.add_substs(&substs.func_substs);\n+                self.add_tys(&substs.upvar_tys);\n+            }\n+\n+            &ty::TyInfer(_) => {\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES); // it might, right?\n+                self.add_flags(TypeFlags::HAS_TY_INFER)\n+            }\n+\n+            &ty::TyEnum(_, substs) | &ty::TyStruct(_, substs) => {\n+                self.add_substs(substs);\n+            }\n+\n+            &ty::TyProjection(ref data) => {\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n+                self.add_projection_ty(data);\n+            }\n+\n+            &ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n+                let mut computation = FlagComputation::new();\n+                computation.add_substs(principal.0.substs);\n+                for projection_bound in &bounds.projection_bounds {\n+                    let mut proj_computation = FlagComputation::new();\n+                    proj_computation.add_projection_predicate(&projection_bound.0);\n+                    self.add_bound_computation(&proj_computation);\n+                }\n+                self.add_bound_computation(&computation);\n+\n+                self.add_bounds(bounds);\n+            }\n+\n+            &ty::TyBox(tt) | &ty::TyArray(tt, _) | &ty::TySlice(tt) => {\n+                self.add_ty(tt)\n+            }\n+\n+            &ty::TyRawPtr(ref m) => {\n+                self.add_ty(m.ty);\n+            }\n+\n+            &ty::TyRef(r, ref m) => {\n+                self.add_region(*r);\n+                self.add_ty(m.ty);\n+            }\n+\n+            &ty::TyTuple(ref ts) => {\n+                self.add_tys(&ts[..]);\n+            }\n+\n+            &ty::TyBareFn(_, ref f) => {\n+                self.add_fn_sig(&f.sig);\n+            }\n+        }\n+    }\n+\n+    fn add_ty(&mut self, ty: Ty) {\n+        self.add_flags(ty.flags.get());\n+        self.add_depth(ty.region_depth);\n+    }\n+\n+    fn add_tys(&mut self, tys: &[Ty]) {\n+        for &ty in tys {\n+            self.add_ty(ty);\n+        }\n+    }\n+\n+    fn add_fn_sig(&mut self, fn_sig: &ty::PolyFnSig) {\n+        let mut computation = FlagComputation::new();\n+\n+        computation.add_tys(&fn_sig.0.inputs);\n+\n+        if let ty::FnConverging(output) = fn_sig.0.output {\n+            computation.add_ty(output);\n+        }\n+\n+        self.add_bound_computation(&computation);\n+    }\n+\n+    fn add_region(&mut self, r: ty::Region) {\n+        match r {\n+            ty::ReVar(..) |\n+            ty::ReSkolemized(..) => { self.add_flags(TypeFlags::HAS_RE_INFER); }\n+            ty::ReLateBound(debruijn, _) => { self.add_depth(debruijn.depth); }\n+            ty::ReEarlyBound(..) => { self.add_flags(TypeFlags::HAS_RE_EARLY_BOUND); }\n+            ty::ReStatic => {}\n+            _ => { self.add_flags(TypeFlags::HAS_FREE_REGIONS); }\n+        }\n+\n+        if !r.is_global() {\n+            self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n+        }\n+    }\n+\n+    fn add_projection_predicate(&mut self, projection_predicate: &ty::ProjectionPredicate) {\n+        self.add_projection_ty(&projection_predicate.projection_ty);\n+        self.add_ty(projection_predicate.ty);\n+    }\n+\n+    fn add_projection_ty(&mut self, projection_ty: &ty::ProjectionTy) {\n+        self.add_substs(projection_ty.trait_ref.substs);\n+    }\n+\n+    fn add_substs(&mut self, substs: &subst::Substs) {\n+        self.add_tys(substs.types.as_slice());\n+        match substs.regions {\n+            subst::ErasedRegions => {}\n+            subst::NonerasedRegions(ref regions) => {\n+                for &r in regions {\n+                    self.add_region(r);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn add_bounds(&mut self, bounds: &ty::ExistentialBounds) {\n+        self.add_region(bounds.region_bound);\n+    }\n+}"}, {"sha": "751bac28ce4c2aa7c0037bd897ef2a24c64bd03c", "filename": "src/librustc/middle/ty/fold.rs", "status": "renamed", "additions": 132, "deletions": 467, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -34,16 +34,12 @@\n //! If you ever *do* need an override that doesn't exist, it's not hard\n //! to convert the degenerate pattern into the proper thing.\n \n+use middle::region;\n use middle::subst;\n-use middle::subst::VecPerParamSpace;\n-use middle::ty::{self, Ty, HasTypeFlags, RegionEscape};\n-use middle::traits;\n+use middle::ty::adjustment;\n+use middle::ty::{self, Binder, Ty, HasTypeFlags, RegionEscape};\n \n use std::fmt;\n-use std::rc::Rc;\n-use syntax::abi;\n-use rustc_front::hir;\n-use syntax::owned_slice::OwnedSlice;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -74,7 +70,7 @@ pub trait TypeFolder<'tcx> : Sized {\n     /// track the Debruijn index nesting level.\n     fn exit_region_binder(&mut self) { }\n \n-    fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+    fn fold_binder<T>(&mut self, t: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>\n     {\n         // FIXME(#20526) this should replace `enter_region_binder`/`exit_region_binder`.\n@@ -133,7 +129,8 @@ pub trait TypeFolder<'tcx> : Sized {\n         super_fold_existential_bounds(self, s)\n     }\n \n-    fn fold_autoref(&mut self, ar: &ty::AutoRef<'tcx>) -> ty::AutoRef<'tcx> {\n+    fn fold_autoref(&mut self, ar: &adjustment::AutoRef<'tcx>)\n+                    -> adjustment::AutoRef<'tcx> {\n         super_fold_autoref(self, ar)\n     }\n \n@@ -142,428 +139,18 @@ pub trait TypeFolder<'tcx> : Sized {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// TypeFoldable implementations.\n-//\n-// Ideally, each type should invoke `folder.fold_foo(self)` and\n-// nothing else. In some cases, though, we haven't gotten around to\n-// adding methods on the `folder` yet, and thus the folding is\n-// hard-coded here. This is less-flexible, because folders cannot\n-// override the behavior, but there are a lot of random types and one\n-// can easily refactor the folding into the TypeFolder trait as\n-// needed.\n-\n-macro_rules! CopyImpls {\n-    ($($ty:ty),+) => {\n-        $(\n-            impl<'tcx> TypeFoldable<'tcx> for $ty {\n-                fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> $ty {\n-                    *self\n-                }\n-            }\n-        )+\n-    }\n-}\n-\n-CopyImpls! { (), hir::Unsafety, abi::Abi }\n-\n-impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n-        (self.0.fold_with(folder), self.1.fold_with(folder))\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n-        self.as_ref().map(|t| t.fold_with(folder))\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n-        Rc::new((**self).fold_with(folder))\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Box<T> {\n-        let content: T = (**self).fold_with(folder);\n-        box content\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n-        self.iter().map(|t| t.fold_with(folder)).collect()\n-    }\n-}\n-\n-impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n-        folder.fold_binder(self)\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for OwnedSlice<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n-        self.iter().map(|t| t.fold_with(folder)).collect()\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n-\n-        // Things in the Fn space take place under an additional level\n-        // of region binding relative to the other spaces. This is\n-        // because those entries are attached to a method, and methods\n-        // always introduce a level of region binding.\n-\n-        let result = self.map_enumerated(|(space, index, elem)| {\n-            if space == subst::FnSpace && index == 0 {\n-                // enter new level when/if we reach the first thing in fn space\n-                folder.enter_region_binder();\n-            }\n-            elem.fold_with(folder)\n-        });\n-        if result.len(subst::FnSpace) > 0 {\n-            // if there was anything in fn space, exit the region binding level\n-            folder.exit_region_binder();\n-        }\n-        result\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Ty<'tcx> {\n-        folder.fold_ty(*self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::BareFnTy<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::BareFnTy<'tcx> {\n-        folder.fold_bare_fn_ty(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureTy<'tcx> {\n-        folder.fold_closure_ty(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeAndMut<'tcx> {\n-        folder.fold_mt(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnOutput<'tcx> {\n-        folder.fold_output(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig<'tcx> {\n-        folder.fold_fn_sig(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n-        folder.fold_trait_ref(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n-        folder.fold_region(*self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> subst::Substs<'tcx> {\n-        folder.fold_substs(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureSubsts<'tcx> {\n-        let func_substs = self.func_substs.fold_with(folder);\n-        ty::ClosureSubsts {\n-            func_substs: folder.tcx().mk_substs(func_substs),\n-            upvar_tys: self.upvar_tys.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ItemSubsts<'tcx> {\n-        ty::ItemSubsts {\n-            substs: self.substs.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::AutoRef<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::AutoRef<'tcx> {\n-        folder.fold_autoref(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n-        *self\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds<'tcx> {\n-        folder.fold_existential_bounds(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeParameterDef<'tcx> {\n-        ty::TypeParameterDef {\n-            name: self.name,\n-            def_id: self.def_id,\n-            space: self.space,\n-            index: self.index,\n-            default: self.default.fold_with(folder),\n-            default_def_id: self.default_def_id,\n-            object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ObjectLifetimeDefault {\n-        match *self {\n-            ty::ObjectLifetimeDefault::Ambiguous =>\n-                ty::ObjectLifetimeDefault::Ambiguous,\n-\n-            ty::ObjectLifetimeDefault::BaseDefault =>\n-                ty::ObjectLifetimeDefault::BaseDefault,\n-\n-            ty::ObjectLifetimeDefault::Specific(r) =>\n-                ty::ObjectLifetimeDefault::Specific(r.fold_with(folder)),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::RegionParameterDef {\n-        ty::RegionParameterDef {\n-            name: self.name,\n-            def_id: self.def_id,\n-            space: self.space,\n-            index: self.index,\n-            bounds: self.bounds.fold_with(folder)\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Generics<'tcx> {\n-        ty::Generics {\n-            types: self.types.fold_with(folder),\n-            regions: self.regions.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericPredicates<'tcx> {\n-        ty::GenericPredicates {\n-            predicates: self.predicates.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Predicate<'tcx> {\n-        match *self {\n-            ty::Predicate::Trait(ref a) =>\n-                ty::Predicate::Trait(a.fold_with(folder)),\n-            ty::Predicate::Equate(ref binder) =>\n-                ty::Predicate::Equate(binder.fold_with(folder)),\n-            ty::Predicate::RegionOutlives(ref binder) =>\n-                ty::Predicate::RegionOutlives(binder.fold_with(folder)),\n-            ty::Predicate::TypeOutlives(ref binder) =>\n-                ty::Predicate::TypeOutlives(binder.fold_with(folder)),\n-            ty::Predicate::Projection(ref binder) =>\n-                ty::Predicate::Projection(binder.fold_with(folder)),\n-            ty::Predicate::WellFormed(data) =>\n-                ty::Predicate::WellFormed(data.fold_with(folder)),\n-            ty::Predicate::ObjectSafe(trait_def_id) =>\n-                ty::Predicate::ObjectSafe(trait_def_id),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ProjectionPredicate<'tcx> {\n-        ty::ProjectionPredicate {\n-            projection_ty: self.projection_ty.fold_with(folder),\n-            ty: self.ty.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ProjectionTy<'tcx> {\n-        ty::ProjectionTy {\n-            trait_ref: self.trait_ref.fold_with(folder),\n-            item_name: self.item_name,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::InstantiatedPredicates<'tcx> {\n-        ty::InstantiatedPredicates {\n-            predicates: self.predicates.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx,O> TypeFoldable<'tcx> for traits::Obligation<'tcx,O>\n-    where O : TypeFoldable<'tcx>\n-{\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx, O> {\n-        traits::Obligation {\n-            cause: self.cause.clone(),\n-            recursion_depth: self.recursion_depth,\n-            predicate: self.predicate.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImplData<'tcx, N> {\n-        traits::VtableImplData {\n-            impl_def_id: self.impl_def_id,\n-            substs: self.substs.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableClosureData<'tcx, N> {\n-        traits::VtableClosureData {\n-            closure_def_id: self.closure_def_id,\n-            substs: self.substs.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultImplData<N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableDefaultImplData<N> {\n-        traits::VtableDefaultImplData {\n-            trait_def_id: self.trait_def_id,\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableBuiltinData<N> {\n-        traits::VtableBuiltinData {\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<'tcx, N> {\n-        match *self {\n-            traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n-            traits::VtableDefaultImpl(ref t) => traits::VtableDefaultImpl(t.fold_with(folder)),\n-            traits::VtableClosure(ref d) => {\n-                traits::VtableClosure(d.fold_with(folder))\n-            }\n-            traits::VtableFnPointer(ref d) => {\n-                traits::VtableFnPointer(d.fold_with(folder))\n-            }\n-            traits::VtableParam(ref n) => traits::VtableParam(n.fold_with(folder)),\n-            traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n-            traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n-        traits::VtableObjectData {\n-            upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n-            vtable_base: self.vtable_base\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::EquatePredicate<'tcx> {\n-        ty::EquatePredicate(self.0.fold_with(folder),\n-                            self.1.fold_with(folder))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitPredicate<'tcx> {\n-        ty::TraitPredicate {\n-            trait_ref: self.trait_ref.fold_with(folder)\n-        }\n-    }\n-}\n-\n-impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n-    where T : TypeFoldable<'tcx>,\n-          U : TypeFoldable<'tcx>,\n-{\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::OutlivesPredicate<T,U> {\n-        ty::OutlivesPredicate(self.0.fold_with(folder),\n-                              self.1.fold_with(folder))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureUpvar<'tcx> {\n-        ty::ClosureUpvar {\n-            def: self.def,\n-            span: self.span,\n-            ty: self.ty.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where 'tcx: 'a {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ParameterEnvironment<'a, 'tcx> {\n-        ty::ParameterEnvironment {\n-            tcx: self.tcx,\n-            free_substs: self.free_substs.fold_with(folder),\n-            implicit_region_bound: self.implicit_region_bound.fold_with(folder),\n-            caller_bounds: self.caller_bounds.fold_with(folder),\n-            selection_cache: traits::SelectionCache::new(),\n-            free_id: self.free_id,\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // \"super\" routines: these are the default implementations for TypeFolder.\n //\n // They should invoke `foo.fold_with()` to do recursive folding.\n \n pub fn super_fold_binder<'tcx, T, U>(this: &mut T,\n-                                     binder: &ty::Binder<U>)\n-                                     -> ty::Binder<U>\n+                                     binder: &Binder<U>)\n+                                     -> Binder<U>\n     where T : TypeFolder<'tcx>, U : TypeFoldable<'tcx>\n {\n     this.enter_region_binder();\n-    let result = ty::Binder(binder.0.fold_with(this));\n+    let result = Binder(binder.0.fold_with(this));\n     this.exit_region_binder();\n     result\n }\n@@ -711,15 +298,15 @@ pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(\n }\n \n pub fn super_fold_autoref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                     autoref: &ty::AutoRef<'tcx>)\n-                                                     -> ty::AutoRef<'tcx>\n+                                                     autoref: &adjustment::AutoRef<'tcx>)\n+                                                     -> adjustment::AutoRef<'tcx>\n {\n     match *autoref {\n-        ty::AutoPtr(r, m) => {\n+        adjustment::AutoPtr(r, m) => {\n             let r = r.fold_with(this);\n-            ty::AutoPtr(this.tcx().mk_region(r), m)\n+            adjustment::AutoPtr(this.tcx().mk_region(r), m)\n         }\n-        ty::AutoUnsafe(m) => ty::AutoUnsafe(m)\n+        adjustment::AutoUnsafe(m) => adjustment::AutoUnsafe(m)\n     }\n }\n \n@@ -754,6 +341,36 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n ///////////////////////////////////////////////////////////////////////////\n // Region folder\n \n+impl<'tcx> ty::ctxt<'tcx> {\n+    /// Collects the free and escaping regions in `value` into `region_set`. Returns\n+    /// whether any late-bound regions were skipped\n+    pub fn collect_regions<T>(&self,\n+        value: &T,\n+        region_set: &mut FnvHashSet<ty::Region>)\n+        -> bool\n+        where T : TypeFoldable<'tcx>\n+    {\n+        let mut have_bound_regions = false;\n+        self.fold_regions(value, &mut have_bound_regions,\n+                          |r, d| { region_set.insert(r.from_depth(d)); r });\n+        have_bound_regions\n+    }\n+\n+    /// Folds the escaping and free regions in `value` using `f`, and\n+    /// sets `skipped_regions` to true if any late-bound region was found\n+    /// and skipped.\n+    pub fn fold_regions<T,F>(&self,\n+        value: &T,\n+        skipped_regions: &mut bool,\n+        mut f: F)\n+        -> T\n+        where F : FnMut(ty::Region, u32) -> ty::Region,\n+              T : TypeFoldable<'tcx>,\n+    {\n+        value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f))\n+    }\n+}\n+\n /// Folds over the substructure of a type, visiting its component\n /// types and all regions that occur *free* within it.\n ///\n@@ -785,33 +402,6 @@ impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n     }\n }\n \n-/// Collects the free and escaping regions in `value` into `region_set`. Returns\n-/// whether any late-bound regions were skipped\n-pub fn collect_regions<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n-                               value: &T,\n-                               region_set: &mut FnvHashSet<ty::Region>) -> bool\n-    where T : TypeFoldable<'tcx>\n-{\n-    let mut have_bound_regions = false;\n-    fold_regions(tcx, value, &mut have_bound_regions,\n-                 |r, d| { region_set.insert(r.from_depth(d)); r });\n-    have_bound_regions\n-}\n-\n-/// Folds the escaping and free regions in `value` using `f`, and\n-/// sets `skipped_regions` to true if any late-bound region was found\n-/// and skipped.\n-pub fn fold_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n-                              value: &T,\n-                              skipped_regions: &mut bool,\n-                              mut f: F)\n-                              -> T\n-    where F : FnMut(ty::Region, u32) -> ty::Region,\n-          T : TypeFoldable<'tcx>,\n-{\n-    value.fold_with(&mut RegionFolder::new(tcx, skipped_regions, &mut f))\n-}\n-\n impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n@@ -853,6 +443,94 @@ struct RegionReplacer<'a, 'tcx: 'a> {\n     map: FnvHashMap<ty::BoundRegion, ty::Region>\n }\n \n+impl<'tcx> ty::ctxt<'tcx> {\n+    pub fn replace_late_bound_regions<T,F>(&self,\n+        value: &Binder<T>,\n+        mut f: F)\n+        -> (T, FnvHashMap<ty::BoundRegion, ty::Region>)\n+        where F : FnMut(ty::BoundRegion) -> ty::Region,\n+              T : TypeFoldable<'tcx>,\n+    {\n+        debug!(\"replace_late_bound_regions({:?})\", value);\n+        let mut replacer = RegionReplacer::new(self, &mut f);\n+        let result = value.skip_binder().fold_with(&mut replacer);\n+        (result, replacer.map)\n+    }\n+\n+\n+    /// Replace any late-bound regions bound in `value` with free variants attached to scope-id\n+    /// `scope_id`.\n+    pub fn liberate_late_bound_regions<T>(&self,\n+        all_outlive_scope: region::CodeExtent,\n+        value: &Binder<T>)\n+        -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        self.replace_late_bound_regions(value, |br| {\n+            ty::ReFree(ty::FreeRegion{scope: all_outlive_scope, bound_region: br})\n+        }).0\n+    }\n+\n+    /// Flattens two binding levels into one. So `for<'a> for<'b> Foo`\n+    /// becomes `for<'a,'b> Foo`.\n+    pub fn flatten_late_bound_regions<T>(&self, bound2_value: &Binder<Binder<T>>)\n+                                         -> Binder<T>\n+        where T: TypeFoldable<'tcx>\n+    {\n+        let bound0_value = bound2_value.skip_binder().skip_binder();\n+        let value = self.fold_regions(bound0_value, &mut false,\n+                                      |region, current_depth| {\n+            match region {\n+                ty::ReLateBound(debruijn, br) if debruijn.depth >= current_depth => {\n+                    // should be true if no escaping regions from bound2_value\n+                    assert!(debruijn.depth - current_depth <= 1);\n+                    ty::ReLateBound(ty::DebruijnIndex::new(current_depth), br)\n+                }\n+                _ => {\n+                    region\n+                }\n+            }\n+        });\n+        Binder(value)\n+    }\n+\n+    pub fn no_late_bound_regions<T>(&self, value: &Binder<T>) -> Option<T>\n+        where T : TypeFoldable<'tcx> + RegionEscape\n+    {\n+        if value.0.has_escaping_regions() {\n+            None\n+        } else {\n+            Some(value.0.clone())\n+        }\n+    }\n+\n+    /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n+    /// method lookup and a few other places where precise region relationships are not required.\n+    pub fn erase_late_bound_regions<T>(&self, value: &Binder<T>) -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        self.replace_late_bound_regions(value, |_| ty::ReStatic).0\n+    }\n+\n+    /// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n+    /// assigned starting at 1 and increasing monotonically in the order traversed\n+    /// by the fold operation.\n+    ///\n+    /// The chief purpose of this function is to canonicalize regions so that two\n+    /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n+    /// structurally identical.  For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n+    /// `for<'a, 'b> fn(&'b isize, &'a isize)` will become identical after anonymization.\n+    pub fn anonymize_late_bound_regions<T>(&self, sig: &Binder<T>) -> Binder<T>\n+        where T : TypeFoldable<'tcx>,\n+    {\n+        let mut counter = 0;\n+        Binder(self.replace_late_bound_regions(sig, |_| {\n+            counter += 1;\n+            ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(counter))\n+        }).0)\n+    }\n+}\n+\n impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n     fn new<F>(tcx: &'a ty::ctxt<'tcx>, fld_r: &'a mut F) -> RegionReplacer<'a, 'tcx>\n         where F : FnMut(ty::BoundRegion) -> ty::Region\n@@ -866,19 +544,6 @@ impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n     }\n }\n \n-pub fn replace_late_bound_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n-                                            value: &ty::Binder<T>,\n-                                            mut f: F)\n-                                            -> (T, FnvHashMap<ty::BoundRegion, ty::Region>)\n-    where F : FnMut(ty::BoundRegion) -> ty::Region,\n-          T : TypeFoldable<'tcx>,\n-{\n-    debug!(\"replace_late_bound_regions({:?})\", value);\n-    let mut replacer = RegionReplacer::new(tcx, &mut f);\n-    let result = value.skip_binder().fold_with(&mut replacer);\n-    (result, replacer.map)\n-}\n-\n impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }", "previous_filename": "src/librustc/middle/ty_fold.rs"}, {"sha": "73d567d0acf40aeb846b8a236456e1147b0bb128", "filename": "src/librustc/middle/ty/ivar.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fivar.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty::{Ty, TyS};\n+\n+use rustc_data_structures::ivar;\n+\n+use std::fmt;\n+use std::marker::PhantomData;\n+use core::nonzero::NonZero;\n+\n+/// An IVar that contains a Ty. 'lt is a (reverse-variant) upper bound\n+/// on the lifetime of the IVar. This is required because of variance\n+/// problems: the IVar needs to be variant with respect to 'tcx (so\n+/// it can be referred to from Ty) but can only be modified if its\n+/// lifetime is exactly 'tcx.\n+///\n+/// Safety invariants:\n+///     (A) self.0, if fulfilled, is a valid Ty<'tcx>\n+///     (B) no aliases to this value with a 'tcx longer than this\n+///         value's 'lt exist\n+///\n+/// NonZero is used rather than Unique because Unique isn't Copy.\n+pub struct TyIVar<'tcx, 'lt: 'tcx>(ivar::Ivar<NonZero<*const TyS<'static>>>,\n+                                   PhantomData<fn(TyS<'lt>)->TyS<'tcx>>);\n+\n+impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n+    #[inline]\n+    pub fn new() -> Self {\n+        // Invariant (A) satisfied because the IVar is unfulfilled\n+        // Invariant (B) because 'lt : 'tcx\n+        TyIVar(ivar::Ivar::new(), PhantomData)\n+    }\n+\n+    #[inline]\n+    pub fn get(&self) -> Option<Ty<'tcx>> {\n+        match self.0.get() {\n+            None => None,\n+            // valid because of invariant (A)\n+            Some(v) => Some(unsafe { &*(*v as *const TyS<'tcx>) })\n+        }\n+    }\n+    #[inline]\n+    pub fn unwrap(&self) -> Ty<'tcx> {\n+        self.get().unwrap()\n+    }\n+\n+    pub fn fulfill(&self, value: Ty<'lt>) {\n+        // Invariant (A) is fulfilled, because by (B), every alias\n+        // of this has a 'tcx longer than 'lt.\n+        let value: *const TyS<'lt> = value;\n+        // FIXME(27214): unneeded [as *const ()]\n+        let value = value as *const () as *const TyS<'static>;\n+        self.0.fulfill(unsafe { NonZero::new(value) })\n+    }\n+}\n+\n+impl<'tcx, 'lt> fmt::Debug for TyIVar<'tcx, 'lt> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.get() {\n+            Some(val) => write!(f, \"TyIVar({:?})\", val),\n+            None => f.write_str(\"TyIVar(<unfulfilled>)\")\n+        }\n+    }\n+}"}, {"sha": "dff423b35dd0a59c5799a6aafdab8146c0adccc5", "filename": "src/librustc/middle/ty/mod.rs", "status": "added", "additions": 2828, "deletions": 0, "changes": 2828, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4"}, {"sha": "9a2570d710d387bf6d353648c53023be2ddd0deb", "filename": "src/librustc/middle/ty/outlives.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Foutlives.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "previous_filename": "src/librustc/middle/outlives.rs"}, {"sha": "ff0a9789cf1f8cad49abd0d1654c9a1a7ec40b82", "filename": "src/librustc/middle/ty/relate.rs", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -15,13 +15,14 @@\n \n use middle::def_id::DefId;\n use middle::subst::{ErasedRegions, NonerasedRegions, ParamSpace, Substs};\n-use middle::ty::{self, HasTypeFlags, Ty, TypeError};\n-use middle::ty_fold::TypeFoldable;\n+use middle::ty::{self, HasTypeFlags, Ty};\n+use middle::ty::error::{ExpectedFound, TypeError};\n+use middle::ty::fold::TypeFoldable;\n use std::rc::Rc;\n use syntax::abi;\n use rustc_front::hir as ast;\n \n-pub type RelateResult<'tcx, T> = Result<T, ty::TypeError<'tcx>>;\n+pub type RelateResult<'tcx, T> = Result<T, TypeError<'tcx>>;\n \n #[derive(Clone, Debug)]\n pub enum Cause {\n@@ -662,7 +663,7 @@ impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Box<T>\n pub fn expected_found<'a,'tcx:'a,R,T>(relation: &mut R,\n                                       a: &T,\n                                       b: &T)\n-                                      -> ty::ExpectedFound<T>\n+                                      -> ExpectedFound<T>\n     where R: TypeRelation<'a,'tcx>, T: Clone\n {\n     expected_found_bool(relation.a_is_expected(), a, b)\n@@ -671,14 +672,14 @@ pub fn expected_found<'a,'tcx:'a,R,T>(relation: &mut R,\n pub fn expected_found_bool<T>(a_is_expected: bool,\n                               a: &T,\n                               b: &T)\n-                              -> ty::ExpectedFound<T>\n+                              -> ExpectedFound<T>\n     where T: Clone\n {\n     let a = a.clone();\n     let b = b.clone();\n     if a_is_expected {\n-        ty::ExpectedFound {expected: a, found: b}\n+        ExpectedFound {expected: a, found: b}\n     } else {\n-        ty::ExpectedFound {expected: b, found: a}\n+        ExpectedFound {expected: b, found: a}\n     }\n }", "previous_filename": "src/librustc/middle/ty_relate/mod.rs"}, {"sha": "0058ccbce3b19da27543afb5f50536069dbdd490", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "added", "additions": 813, "deletions": 0, "changes": 813, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -0,0 +1,813 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::subst::{self, VecPerParamSpace};\n+use middle::traits;\n+use middle::ty::{self, TraitRef, Ty, TypeAndMut};\n+use middle::ty::{HasTypeFlags, Lift, TypeFlags, RegionEscape};\n+use middle::ty::fold::{TypeFoldable, TypeFolder};\n+\n+use std::rc::Rc;\n+use syntax::abi;\n+use syntax::owned_slice::OwnedSlice;\n+\n+use rustc_front::hir;\n+\n+// FIXME(#20298) -- all of these traits basically walk various\n+// structures to test whether types/regions are reachable with various\n+// properties. It should be possible to express them in terms of one\n+// common \"walker\" trait or something.\n+\n+impl<'tcx> RegionEscape for Ty<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.region_depth > depth\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::TraitTy<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.principal.has_regions_escaping_depth(depth) ||\n+            self.bounds.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::ExistentialBounds<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.region_bound.has_regions_escaping_depth(depth) ||\n+            self.projection_bounds.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for subst::Substs<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.types.has_regions_escaping_depth(depth) ||\n+            self.regions.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::ClosureSubsts<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.func_substs.has_regions_escaping_depth(depth) ||\n+            self.upvar_tys.iter().any(|t| t.has_regions_escaping_depth(depth))\n+    }\n+}\n+\n+impl<T:RegionEscape> RegionEscape for Vec<T> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.iter().any(|t| t.has_regions_escaping_depth(depth))\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::FnSig<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.inputs.has_regions_escaping_depth(depth) ||\n+            self.output.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx,T:RegionEscape> RegionEscape for VecPerParamSpace<T> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.iter_enumerated().any(|(space, _, t)| {\n+            if space == subst::FnSpace {\n+                t.has_regions_escaping_depth(depth+1)\n+            } else {\n+                t.has_regions_escaping_depth(depth)\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::TypeScheme<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.ty.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl RegionEscape for ty::Region {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.escapes_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::GenericPredicates<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.predicates.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::Predicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        match *self {\n+            ty::Predicate::Trait(ref data) => data.has_regions_escaping_depth(depth),\n+            ty::Predicate::Equate(ref data) => data.has_regions_escaping_depth(depth),\n+            ty::Predicate::RegionOutlives(ref data) => data.has_regions_escaping_depth(depth),\n+            ty::Predicate::TypeOutlives(ref data) => data.has_regions_escaping_depth(depth),\n+            ty::Predicate::Projection(ref data) => data.has_regions_escaping_depth(depth),\n+            ty::Predicate::WellFormed(ty) => ty.has_regions_escaping_depth(depth),\n+            ty::Predicate::ObjectSafe(_trait_def_id) => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for TraitRef<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) ||\n+            self.substs.regions.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for subst::RegionSubsts {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        match *self {\n+            subst::ErasedRegions => false,\n+            subst::NonerasedRegions(ref r) => {\n+                r.iter().any(|t| t.has_regions_escaping_depth(depth))\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx,T:RegionEscape> RegionEscape for ty::Binder<T> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.0.has_regions_escaping_depth(depth + 1)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::FnOutput<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        match *self {\n+            ty::FnConverging(t) => t.has_regions_escaping_depth(depth),\n+            ty::FnDiverging => false\n+        }\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::EquatePredicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::TraitPredicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.trait_ref.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<T:RegionEscape,U:RegionEscape> RegionEscape for ty::OutlivesPredicate<T,U> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::ProjectionPredicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.projection_ty.has_regions_escaping_depth(depth) ||\n+            self.ty.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::ProjectionTy<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.trait_ref.has_regions_escaping_depth(depth)\n+    }\n+}\n+impl<'tcx,T:HasTypeFlags> HasTypeFlags for Vec<T> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self[..].has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx,T:HasTypeFlags> HasTypeFlags for [T] {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.iter().any(|p| p.has_type_flags(flags))\n+    }\n+}\n+\n+impl<'tcx,T:HasTypeFlags> HasTypeFlags for VecPerParamSpace<T> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.iter().any(|p| p.has_type_flags(flags))\n+    }\n+}\n+\n+impl HasTypeFlags for abi::Abi {\n+    fn has_type_flags(&self, _flags: TypeFlags) -> bool {\n+        false\n+    }\n+}\n+\n+impl HasTypeFlags for hir::Unsafety {\n+    fn has_type_flags(&self, _flags: TypeFlags) -> bool {\n+        false\n+    }\n+}\n+\n+impl HasTypeFlags for ty::BuiltinBounds {\n+    fn has_type_flags(&self, _flags: TypeFlags) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::ClosureTy<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.sig.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::ClosureUpvar<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.ty.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::ExistentialBounds<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.projection_bounds.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::InstantiatedPredicates<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.predicates.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::Predicate<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        match *self {\n+            ty::Predicate::Trait(ref data) => data.has_type_flags(flags),\n+            ty::Predicate::Equate(ref data) => data.has_type_flags(flags),\n+            ty::Predicate::RegionOutlives(ref data) => data.has_type_flags(flags),\n+            ty::Predicate::TypeOutlives(ref data) => data.has_type_flags(flags),\n+            ty::Predicate::Projection(ref data) => data.has_type_flags(flags),\n+            ty::Predicate::WellFormed(data) => data.has_type_flags(flags),\n+            ty::Predicate::ObjectSafe(_trait_def_id) => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::TraitPredicate<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.trait_ref.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::EquatePredicate<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.0.has_type_flags(flags) || self.1.has_type_flags(flags)\n+    }\n+}\n+\n+impl HasTypeFlags for ty::Region {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        if flags.intersects(TypeFlags::HAS_LOCAL_NAMES) {\n+            // does this represent a region that cannot be named in a global\n+            // way? used in fulfillment caching.\n+            match *self {\n+                ty::ReStatic | ty::ReEmpty => {}\n+                _ => return true\n+            }\n+        }\n+        if flags.intersects(TypeFlags::HAS_RE_INFER) {\n+            match *self {\n+                ty::ReVar(_) | ty::ReSkolemized(..) => { return true }\n+                _ => {}\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+impl<T:HasTypeFlags,U:HasTypeFlags> HasTypeFlags for ty::OutlivesPredicate<T,U> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.0.has_type_flags(flags) || self.1.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::ProjectionPredicate<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.projection_ty.has_type_flags(flags) || self.ty.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::ProjectionTy<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.trait_ref.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for Ty<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.flags.get().intersects(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for TypeAndMut<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.ty.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for TraitRef<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.substs.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for subst::Substs<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.types.has_type_flags(flags) || match self.regions {\n+            subst::ErasedRegions => false,\n+            subst::NonerasedRegions(ref r) => r.has_type_flags(flags)\n+        }\n+    }\n+}\n+\n+impl<'tcx,T> HasTypeFlags for Option<T>\n+    where T : HasTypeFlags\n+{\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.iter().any(|t| t.has_type_flags(flags))\n+    }\n+}\n+\n+impl<'tcx,T> HasTypeFlags for Rc<T>\n+    where T : HasTypeFlags\n+{\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        (**self).has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx,T> HasTypeFlags for Box<T>\n+    where T : HasTypeFlags\n+{\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        (**self).has_type_flags(flags)\n+    }\n+}\n+\n+impl<T> HasTypeFlags for ty::Binder<T>\n+    where T : HasTypeFlags\n+{\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.0.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::FnOutput<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        match *self {\n+            ty::FnConverging(t) => t.has_type_flags(flags),\n+            ty::FnDiverging => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::FnSig<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.inputs.iter().any(|t| t.has_type_flags(flags)) ||\n+            self.output.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::BareFnTy<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.sig.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::ClosureSubsts<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.func_substs.has_type_flags(flags) ||\n+            self.upvar_tys.iter().any(|t| t.has_type_flags(flags))\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Lift implementations\n+\n+impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n+    type Lifted = (A::Lifted, B::Lifted);\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n+    type Lifted = Vec<T::Lifted>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<Self::Lifted> {\n+        let mut result = Vec::with_capacity(self.len());\n+        for x in self {\n+            if let Some(value) = tcx.lift(x) {\n+                result.push(value);\n+            } else {\n+                return None;\n+            }\n+        }\n+        Some(result)\n+    }\n+}\n+\n+impl<'tcx> Lift<'tcx> for ty::Region {\n+    type Lifted = Self;\n+    fn lift_to_tcx(&self, _: &ty::ctxt<'tcx>) -> Option<ty::Region> {\n+        Some(*self)\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n+    type Lifted = TraitRef<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<TraitRef<'tcx>> {\n+        tcx.lift(&self.substs).map(|substs| TraitRef {\n+            def_id: self.def_id,\n+            substs: substs\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n+    type Lifted = ty::TraitPredicate<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n+        tcx.lift(&self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n+            trait_ref: trait_ref\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::EquatePredicate<'a> {\n+    type Lifted = ty::EquatePredicate<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<ty::EquatePredicate<'tcx>> {\n+        tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::EquatePredicate(a, b))\n+    }\n+}\n+\n+impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n+    type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n+    type Lifted = ty::ProjectionPredicate<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n+        tcx.lift(&(self.projection_ty.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n+            ty::ProjectionPredicate {\n+                projection_ty: ty::ProjectionTy {\n+                    trait_ref: trait_ref,\n+                    item_name: self.projection_ty.item_name\n+                },\n+                ty: ty\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n+    type Lifted = ty::Binder<T::Lifted>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.0).map(|x| ty::Binder(x))\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// TypeFoldable implementations.\n+//\n+// Ideally, each type should invoke `folder.fold_foo(self)` and\n+// nothing else. In some cases, though, we haven't gotten around to\n+// adding methods on the `folder` yet, and thus the folding is\n+// hard-coded here. This is less-flexible, because folders cannot\n+// override the behavior, but there are a lot of random types and one\n+// can easily refactor the folding into the TypeFolder trait as\n+// needed.\n+\n+macro_rules! CopyImpls {\n+    ($($ty:ty),+) => {\n+        $(\n+            impl<'tcx> TypeFoldable<'tcx> for $ty {\n+                fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> $ty {\n+                    *self\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+CopyImpls! { (), hir::Unsafety, abi::Abi }\n+\n+impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n+        (self.0.fold_with(folder), self.1.fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n+        self.as_ref().map(|t| t.fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n+        Rc::new((**self).fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Box<T> {\n+        let content: T = (**self).fold_with(folder);\n+        box content\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n+        self.iter().map(|t| t.fold_with(folder)).collect()\n+    }\n+}\n+\n+impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n+        folder.fold_binder(self)\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for OwnedSlice<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n+        self.iter().map(|t| t.fold_with(folder)).collect()\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n+\n+        // Things in the Fn space take place under an additional level\n+        // of region binding relative to the other spaces. This is\n+        // because those entries are attached to a method, and methods\n+        // always introduce a level of region binding.\n+\n+        let result = self.map_enumerated(|(space, index, elem)| {\n+            if space == subst::FnSpace && index == 0 {\n+                // enter new level when/if we reach the first thing in fn space\n+                folder.enter_region_binder();\n+            }\n+            elem.fold_with(folder)\n+        });\n+        if result.len(subst::FnSpace) > 0 {\n+            // if there was anything in fn space, exit the region binding level\n+            folder.exit_region_binder();\n+        }\n+        result\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Ty<'tcx> {\n+        folder.fold_ty(*self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::BareFnTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::BareFnTy<'tcx> {\n+        folder.fold_bare_fn_ty(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureTy<'tcx> {\n+        folder.fold_closure_ty(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeAndMut<'tcx> {\n+        folder.fold_mt(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnOutput<'tcx> {\n+        folder.fold_output(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig<'tcx> {\n+        folder.fold_fn_sig(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n+        folder.fold_trait_ref(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n+        folder.fold_region(*self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> subst::Substs<'tcx> {\n+        folder.fold_substs(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureSubsts<'tcx> {\n+        let func_substs = self.func_substs.fold_with(folder);\n+        ty::ClosureSubsts {\n+            func_substs: folder.tcx().mk_substs(func_substs),\n+            upvar_tys: self.upvar_tys.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ItemSubsts<'tcx> {\n+        ty::ItemSubsts {\n+            substs: self.substs.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::adjustment::AutoRef<'tcx> {\n+        folder.fold_autoref(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n+        *self\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds<'tcx> {\n+        folder.fold_existential_bounds(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeParameterDef<'tcx> {\n+        ty::TypeParameterDef {\n+            name: self.name,\n+            def_id: self.def_id,\n+            space: self.space,\n+            index: self.index,\n+            default: self.default.fold_with(folder),\n+            default_def_id: self.default_def_id,\n+            object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ObjectLifetimeDefault {\n+        match *self {\n+            ty::ObjectLifetimeDefault::Ambiguous =>\n+                ty::ObjectLifetimeDefault::Ambiguous,\n+\n+            ty::ObjectLifetimeDefault::BaseDefault =>\n+                ty::ObjectLifetimeDefault::BaseDefault,\n+\n+            ty::ObjectLifetimeDefault::Specific(r) =>\n+                ty::ObjectLifetimeDefault::Specific(r.fold_with(folder)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::RegionParameterDef {\n+        ty::RegionParameterDef {\n+            name: self.name,\n+            def_id: self.def_id,\n+            space: self.space,\n+            index: self.index,\n+            bounds: self.bounds.fold_with(folder)\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Generics<'tcx> {\n+        ty::Generics {\n+            types: self.types.fold_with(folder),\n+            regions: self.regions.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericPredicates<'tcx> {\n+        ty::GenericPredicates {\n+            predicates: self.predicates.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Predicate<'tcx> {\n+        match *self {\n+            ty::Predicate::Trait(ref a) =>\n+                ty::Predicate::Trait(a.fold_with(folder)),\n+            ty::Predicate::Equate(ref binder) =>\n+                ty::Predicate::Equate(binder.fold_with(folder)),\n+            ty::Predicate::RegionOutlives(ref binder) =>\n+                ty::Predicate::RegionOutlives(binder.fold_with(folder)),\n+            ty::Predicate::TypeOutlives(ref binder) =>\n+                ty::Predicate::TypeOutlives(binder.fold_with(folder)),\n+            ty::Predicate::Projection(ref binder) =>\n+                ty::Predicate::Projection(binder.fold_with(folder)),\n+            ty::Predicate::WellFormed(data) =>\n+                ty::Predicate::WellFormed(data.fold_with(folder)),\n+            ty::Predicate::ObjectSafe(trait_def_id) =>\n+                ty::Predicate::ObjectSafe(trait_def_id),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ProjectionPredicate<'tcx> {\n+        ty::ProjectionPredicate {\n+            projection_ty: self.projection_ty.fold_with(folder),\n+            ty: self.ty.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ProjectionTy<'tcx> {\n+        ty::ProjectionTy {\n+            trait_ref: self.trait_ref.fold_with(folder),\n+            item_name: self.item_name,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::InstantiatedPredicates<'tcx> {\n+        ty::InstantiatedPredicates {\n+            predicates: self.predicates.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::EquatePredicate<'tcx> {\n+        ty::EquatePredicate(self.0.fold_with(folder),\n+                            self.1.fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitPredicate<'tcx> {\n+        ty::TraitPredicate {\n+            trait_ref: self.trait_ref.fold_with(folder)\n+        }\n+    }\n+}\n+\n+impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n+    where T : TypeFoldable<'tcx>,\n+          U : TypeFoldable<'tcx>,\n+{\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::OutlivesPredicate<T,U> {\n+        ty::OutlivesPredicate(self.0.fold_with(folder),\n+                              self.1.fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureUpvar<'tcx> {\n+        ty::ClosureUpvar {\n+            def: self.def,\n+            span: self.span,\n+            ty: self.ty.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where 'tcx: 'a {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ParameterEnvironment<'a, 'tcx> {\n+        ty::ParameterEnvironment {\n+            tcx: self.tcx,\n+            free_substs: self.free_substs.fold_with(folder),\n+            implicit_region_bound: self.implicit_region_bound.fold_with(folder),\n+            caller_bounds: self.caller_bounds.fold_with(folder),\n+            selection_cache: traits::SelectionCache::new(),\n+            free_id: self.free_id,\n+        }\n+    }\n+}"}, {"sha": "3969738a22e86b94278bb4042612ff9065ddd506", "filename": "src/librustc/middle/ty/sty.rs", "status": "added", "additions": 1212, "deletions": 0, "changes": 1212, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -0,0 +1,1212 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains TypeVariants and its major components\n+\n+use middle::def_id::DefId;\n+use middle::region;\n+use middle::subst::{self, Substs};\n+use middle::traits;\n+use middle::ty::{self, AdtDef, TypeFlags, Ty, TyS};\n+use middle::ty::{RegionEscape, ToPredicate};\n+use util::common::ErrorReported;\n+\n+use collections::enum_set::{self, EnumSet, CLike};\n+use std::fmt;\n+use std::ops;\n+use std::mem;\n+use syntax::abi;\n+use syntax::ast::{Name, NodeId};\n+use syntax::parse::token::special_idents;\n+\n+use rustc_front::hir;\n+\n+use self::FnOutput::*;\n+use self::InferTy::*;\n+use self::TypeVariants::*;\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub struct TypeAndMut<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub mutbl: hir::Mutability,\n+}\n+\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n+         RustcEncodable, RustcDecodable, Copy)]\n+/// A \"free\" region `fr` can be interpreted as \"some region\n+/// at least as big as the scope `fr.scope`\".\n+pub struct FreeRegion {\n+    pub scope: region::CodeExtent,\n+    pub bound_region: BoundRegion\n+}\n+\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n+         RustcEncodable, RustcDecodable, Copy)]\n+pub enum BoundRegion {\n+    /// An anonymous region parameter for a given fn (&T)\n+    BrAnon(u32),\n+\n+    /// Named region parameters for functions (a in &'a T)\n+    ///\n+    /// The def-id is needed to distinguish free regions in\n+    /// the event of shadowing.\n+    BrNamed(DefId, Name),\n+\n+    /// Fresh bound identifiers created during GLB computations.\n+    BrFresh(u32),\n+\n+    // Anonymous region for the implicit env pointer parameter\n+    // to a closure\n+    BrEnv\n+}\n+\n+// NB: If you change this, you'll probably want to change the corresponding\n+// AST structure in libsyntax/ast.rs as well.\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum TypeVariants<'tcx> {\n+    /// The primitive boolean type. Written as `bool`.\n+    TyBool,\n+\n+    /// The primitive character type; holds a Unicode scalar value\n+    /// (a non-surrogate code point).  Written as `char`.\n+    TyChar,\n+\n+    /// A primitive signed integer type. For example, `i32`.\n+    TyInt(hir::IntTy),\n+\n+    /// A primitive unsigned integer type. For example, `u32`.\n+    TyUint(hir::UintTy),\n+\n+    /// A primitive floating-point type. For example, `f64`.\n+    TyFloat(hir::FloatTy),\n+\n+    /// An enumerated type, defined with `enum`.\n+    ///\n+    /// Substs here, possibly against intuition, *may* contain `TyParam`s.\n+    /// That is, even after substitution it is possible that there are type\n+    /// variables. This happens when the `TyEnum` corresponds to an enum\n+    /// definition and not a concrete use of it. To get the correct `TyEnum`\n+    /// from the tcx, use the `NodeId` from the `hir::Ty` and look it up in\n+    /// the `ast_ty_to_ty_cache`. This is probably true for `TyStruct` as\n+    /// well.\n+    TyEnum(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n+\n+    /// A structure type, defined with `struct`.\n+    ///\n+    /// See warning about substitutions for enumerated types.\n+    TyStruct(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n+\n+    /// `Box<T>`; this is nominally a struct in the documentation, but is\n+    /// special-cased internally. For example, it is possible to implicitly\n+    /// move the contents of a box out of that box, and methods of any type\n+    /// can have type `Box<Self>`.\n+    TyBox(Ty<'tcx>),\n+\n+    /// The pointee of a string slice. Written as `str`.\n+    TyStr,\n+\n+    /// An array with the given length. Written as `[T; n]`.\n+    TyArray(Ty<'tcx>, usize),\n+\n+    /// The pointee of an array slice.  Written as `[T]`.\n+    TySlice(Ty<'tcx>),\n+\n+    /// A raw pointer. Written as `*mut T` or `*const T`\n+    TyRawPtr(TypeAndMut<'tcx>),\n+\n+    /// A reference; a pointer with an associated lifetime. Written as\n+    /// `&a mut T` or `&'a T`.\n+    TyRef(&'tcx Region, TypeAndMut<'tcx>),\n+\n+    /// If the def-id is Some(_), then this is the type of a specific\n+    /// fn item. Otherwise, if None(_), it a fn pointer type.\n+    ///\n+    /// FIXME: Conflating function pointers and the type of a\n+    /// function is probably a terrible idea; a function pointer is a\n+    /// value with a specific type, but a function can be polymorphic\n+    /// or dynamically dispatched.\n+    TyBareFn(Option<DefId>, &'tcx BareFnTy<'tcx>),\n+\n+    /// A trait, defined with `trait`.\n+    TyTrait(Box<TraitTy<'tcx>>),\n+\n+    /// The anonymous type of a closure. Used to represent the type of\n+    /// `|a| a`.\n+    TyClosure(DefId, Box<ClosureSubsts<'tcx>>),\n+\n+    /// A tuple type.  For example, `(i32, bool)`.\n+    TyTuple(Vec<Ty<'tcx>>),\n+\n+    /// The projection of an associated type.  For example,\n+    /// `<T as Trait<..>>::N`.\n+    TyProjection(ProjectionTy<'tcx>),\n+\n+    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n+    TyParam(ParamTy),\n+\n+    /// A type variable used during type-checking.\n+    TyInfer(InferTy),\n+\n+    /// A placeholder for a type which could not be computed; this is\n+    /// propagated to avoid useless error messages.\n+    TyError,\n+}\n+\n+/// A closure can be modeled as a struct that looks like:\n+///\n+///     struct Closure<'l0...'li, T0...Tj, U0...Uk> {\n+///         upvar0: U0,\n+///         ...\n+///         upvark: Uk\n+///     }\n+///\n+/// where 'l0...'li and T0...Tj are the lifetime and type parameters\n+/// in scope on the function that defined the closure, and U0...Uk are\n+/// type parameters representing the types of its upvars (borrowed, if\n+/// appropriate).\n+///\n+/// So, for example, given this function:\n+///\n+///     fn foo<'a, T>(data: &'a mut T) {\n+///          do(|| data.count += 1)\n+///     }\n+///\n+/// the type of the closure would be something like:\n+///\n+///     struct Closure<'a, T, U0> {\n+///         data: U0\n+///     }\n+///\n+/// Note that the type of the upvar is not specified in the struct.\n+/// You may wonder how the impl would then be able to use the upvar,\n+/// if it doesn't know it's type? The answer is that the impl is\n+/// (conceptually) not fully generic over Closure but rather tied to\n+/// instances with the expected upvar types:\n+///\n+///     impl<'b, 'a, T> FnMut() for Closure<'a, T, &'b mut &'a mut T> {\n+///         ...\n+///     }\n+///\n+/// You can see that the *impl* fully specified the type of the upvar\n+/// and thus knows full well that `data` has type `&'b mut &'a mut T`.\n+/// (Here, I am assuming that `data` is mut-borrowed.)\n+///\n+/// Now, the last question you may ask is: Why include the upvar types\n+/// as extra type parameters? The reason for this design is that the\n+/// upvar types can reference lifetimes that are internal to the\n+/// creating function. In my example above, for example, the lifetime\n+/// `'b` represents the extent of the closure itself; this is some\n+/// subset of `foo`, probably just the extent of the call to the to\n+/// `do()`. If we just had the lifetime/type parameters from the\n+/// enclosing function, we couldn't name this lifetime `'b`. Note that\n+/// there can also be lifetimes in the types of the upvars themselves,\n+/// if one of them happens to be a reference to something that the\n+/// creating fn owns.\n+///\n+/// OK, you say, so why not create a more minimal set of parameters\n+/// that just includes the extra lifetime parameters? The answer is\n+/// primarily that it would be hard --- we don't know at the time when\n+/// we create the closure type what the full types of the upvars are,\n+/// nor do we know which are borrowed and which are not. In this\n+/// design, we can just supply a fresh type parameter and figure that\n+/// out later.\n+///\n+/// All right, you say, but why include the type parameters from the\n+/// original function then? The answer is that trans may need them\n+/// when monomorphizing, and they may not appear in the upvars.  A\n+/// closure could capture no variables but still make use of some\n+/// in-scope type parameter with a bound (e.g., if our example above\n+/// had an extra `U: Default`, and the closure called `U::default()`).\n+///\n+/// There is another reason. This design (implicitly) prohibits\n+/// closures from capturing themselves (except via a trait\n+/// object). This simplifies closure inference considerably, since it\n+/// means that when we infer the kind of a closure or its upvars, we\n+/// don't have to handle cycles where the decisions we make for\n+/// closure C wind up influencing the decisions we ought to make for\n+/// closure C (which would then require fixed point iteration to\n+/// handle). Plus it fixes an ICE. :P\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct ClosureSubsts<'tcx> {\n+    /// Lifetime and type parameters from the enclosing function.\n+    /// These are separated out because trans wants to pass them around\n+    /// when monomorphizing.\n+    pub func_substs: &'tcx Substs<'tcx>,\n+\n+    /// The types of the upvars. The list parallels the freevars and\n+    /// `upvar_borrows` lists. These are kept distinct so that we can\n+    /// easily index into them.\n+    pub upvar_tys: Vec<Ty<'tcx>>\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct TraitTy<'tcx> {\n+    pub principal: ty::PolyTraitRef<'tcx>,\n+    pub bounds: ExistentialBounds<'tcx>,\n+}\n+\n+impl<'tcx> TraitTy<'tcx> {\n+    pub fn principal_def_id(&self) -> DefId {\n+        self.principal.0.def_id\n+    }\n+\n+    /// Object types don't have a self-type specified. Therefore, when\n+    /// we convert the principal trait-ref into a normal trait-ref,\n+    /// you must give *some* self-type. A common choice is `mk_err()`\n+    /// or some skolemized type.\n+    pub fn principal_trait_ref_with_self_ty(&self,\n+                                            tcx: &ty::ctxt<'tcx>,\n+                                            self_ty: Ty<'tcx>)\n+                                            -> ty::PolyTraitRef<'tcx>\n+    {\n+        // otherwise the escaping regions would be captured by the binder\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        ty::Binder(TraitRef {\n+            def_id: self.principal.0.def_id,\n+            substs: tcx.mk_substs(self.principal.0.substs.with_self_ty(self_ty)),\n+        })\n+    }\n+\n+    pub fn projection_bounds_with_self_ty(&self,\n+                                          tcx: &ty::ctxt<'tcx>,\n+                                          self_ty: Ty<'tcx>)\n+                                          -> Vec<ty::PolyProjectionPredicate<'tcx>>\n+    {\n+        // otherwise the escaping regions would be captured by the binders\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        self.bounds.projection_bounds.iter()\n+            .map(|in_poly_projection_predicate| {\n+                let in_projection_ty = &in_poly_projection_predicate.0.projection_ty;\n+                let substs = tcx.mk_substs(in_projection_ty.trait_ref.substs.with_self_ty(self_ty));\n+                let trait_ref = ty::TraitRef::new(in_projection_ty.trait_ref.def_id,\n+                                              substs);\n+                let projection_ty = ty::ProjectionTy {\n+                    trait_ref: trait_ref,\n+                    item_name: in_projection_ty.item_name\n+                };\n+                ty::Binder(ty::ProjectionPredicate {\n+                    projection_ty: projection_ty,\n+                    ty: in_poly_projection_predicate.0.ty\n+                })\n+            })\n+            .collect()\n+    }\n+}\n+\n+/// A complete reference to a trait. These take numerous guises in syntax,\n+/// but perhaps the most recognizable form is in a where clause:\n+///\n+///     T : Foo<U>\n+///\n+/// This would be represented by a trait-reference where the def-id is the\n+/// def-id for the trait `Foo` and the substs defines `T` as parameter 0 in the\n+/// `SelfSpace` and `U` as parameter 0 in the `TypeSpace`.\n+///\n+/// Trait references also appear in object types like `Foo<U>`, but in\n+/// that case the `Self` parameter is absent from the substitutions.\n+///\n+/// Note that a `TraitRef` introduces a level of region binding, to\n+/// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n+/// U>` or higher-ranked object types.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct TraitRef<'tcx> {\n+    pub def_id: DefId,\n+    pub substs: &'tcx Substs<'tcx>,\n+}\n+\n+pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n+\n+impl<'tcx> PolyTraitRef<'tcx> {\n+    pub fn self_ty(&self) -> Ty<'tcx> {\n+        self.0.self_ty()\n+    }\n+\n+    pub fn def_id(&self) -> DefId {\n+        self.0.def_id\n+    }\n+\n+    pub fn substs(&self) -> &'tcx Substs<'tcx> {\n+        // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n+        self.0.substs\n+    }\n+\n+    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+        // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n+        self.0.input_types()\n+    }\n+\n+    pub fn to_poly_trait_predicate(&self) -> ty::PolyTraitPredicate<'tcx> {\n+        // Note that we preserve binding levels\n+        Binder(ty::TraitPredicate { trait_ref: self.0.clone() })\n+    }\n+}\n+\n+/// Binder is a binder for higher-ranked lifetimes. It is part of the\n+/// compiler's representation for things like `for<'a> Fn(&'a isize)`\n+/// (which would be represented by the type `PolyTraitRef ==\n+/// Binder<TraitRef>`). Note that when we skolemize, instantiate,\n+/// erase, or otherwise \"discharge\" these bound regions, we change the\n+/// type from `Binder<T>` to just `T` (see\n+/// e.g. `liberate_late_bound_regions`).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct Binder<T>(pub T);\n+\n+impl<T> Binder<T> {\n+    /// Skips the binder and returns the \"bound\" value. This is a\n+    /// risky thing to do because it's easy to get confused about\n+    /// debruijn indices and the like. It is usually better to\n+    /// discharge the binder using `no_late_bound_regions` or\n+    /// `replace_late_bound_regions` or something like\n+    /// that. `skip_binder` is only valid when you are either\n+    /// extracting data that has nothing to do with bound regions, you\n+    /// are doing some sort of test that does not involve bound\n+    /// regions, or you are being very careful about your depth\n+    /// accounting.\n+    ///\n+    /// Some examples where `skip_binder` is reasonable:\n+    /// - extracting the def-id from a PolyTraitRef;\n+    /// - comparing the self type of a PolyTraitRef to see if it is equal to\n+    ///   a type parameter `X`, since the type `X`  does not reference any regions\n+    pub fn skip_binder(&self) -> &T {\n+        &self.0\n+    }\n+\n+    pub fn as_ref(&self) -> Binder<&T> {\n+        ty::Binder(&self.0)\n+    }\n+\n+    pub fn map_bound_ref<F,U>(&self, f: F) -> Binder<U>\n+        where F: FnOnce(&T) -> U\n+    {\n+        self.as_ref().map_bound(f)\n+    }\n+\n+    pub fn map_bound<F,U>(self, f: F) -> Binder<U>\n+        where F: FnOnce(T) -> U\n+    {\n+        ty::Binder(f(self.0))\n+    }\n+}\n+\n+impl fmt::Debug for TypeFlags {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.bits)\n+    }\n+}\n+\n+/// Represents the projection of an associated type. In explicit UFCS\n+/// form this would be written `<T as Trait<..>>::N`.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct ProjectionTy<'tcx> {\n+    /// The trait reference `T as Trait<..>`.\n+    pub trait_ref: ty::TraitRef<'tcx>,\n+\n+    /// The name `N` of the associated type.\n+    pub item_name: Name,\n+}\n+\n+impl<'tcx> ProjectionTy<'tcx> {\n+    pub fn sort_key(&self) -> (DefId, Name) {\n+        (self.trait_ref.def_id, self.item_name)\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct BareFnTy<'tcx> {\n+    pub unsafety: hir::Unsafety,\n+    pub abi: abi::Abi,\n+    pub sig: PolyFnSig<'tcx>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct ClosureTy<'tcx> {\n+    pub unsafety: hir::Unsafety,\n+    pub abi: abi::Abi,\n+    pub sig: PolyFnSig<'tcx>,\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum FnOutput<'tcx> {\n+    FnConverging(Ty<'tcx>),\n+    FnDiverging\n+}\n+\n+impl<'tcx> FnOutput<'tcx> {\n+    pub fn diverges(&self) -> bool {\n+        *self == FnDiverging\n+    }\n+\n+    pub fn unwrap(self) -> Ty<'tcx> {\n+        match self {\n+            ty::FnConverging(t) => t,\n+            ty::FnDiverging => unreachable!()\n+        }\n+    }\n+\n+    pub fn unwrap_or(self, def: Ty<'tcx>) -> Ty<'tcx> {\n+        match self {\n+            ty::FnConverging(t) => t,\n+            ty::FnDiverging => def\n+        }\n+    }\n+}\n+\n+pub type PolyFnOutput<'tcx> = Binder<FnOutput<'tcx>>;\n+\n+impl<'tcx> PolyFnOutput<'tcx> {\n+    pub fn diverges(&self) -> bool {\n+        self.0.diverges()\n+    }\n+}\n+\n+/// Signature of a function type, which I have arbitrarily\n+/// decided to use to refer to the input/output types.\n+///\n+/// - `inputs` is the list of arguments and their modes.\n+/// - `output` is the return type.\n+/// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct FnSig<'tcx> {\n+    pub inputs: Vec<Ty<'tcx>>,\n+    pub output: FnOutput<'tcx>,\n+    pub variadic: bool\n+}\n+\n+pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n+\n+impl<'tcx> PolyFnSig<'tcx> {\n+    pub fn inputs(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs.clone())\n+    }\n+    pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs[index])\n+    }\n+    pub fn output(&self) -> ty::Binder<FnOutput<'tcx>> {\n+        self.map_bound_ref(|fn_sig| fn_sig.output.clone())\n+    }\n+    pub fn variadic(&self) -> bool {\n+        self.skip_binder().variadic\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ParamTy {\n+    pub space: subst::ParamSpace,\n+    pub idx: u32,\n+    pub name: Name,\n+}\n+\n+impl ParamTy {\n+    pub fn new(space: subst::ParamSpace,\n+               index: u32,\n+               name: Name)\n+               -> ParamTy {\n+        ParamTy { space: space, idx: index, name: name }\n+    }\n+\n+    pub fn for_self() -> ParamTy {\n+        ParamTy::new(subst::SelfSpace, 0, special_idents::type_self.name)\n+    }\n+\n+    pub fn for_def(def: &ty::TypeParameterDef) -> ParamTy {\n+        ParamTy::new(def.space, def.index, def.name)\n+    }\n+\n+    pub fn to_ty<'tcx>(self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        tcx.mk_param(self.space, self.idx, self.name)\n+    }\n+\n+    pub fn is_self(&self) -> bool {\n+        self.space == subst::SelfSpace && self.idx == 0\n+    }\n+}\n+\n+/// A [De Bruijn index][dbi] is a standard means of representing\n+/// regions (and perhaps later types) in a higher-ranked setting. In\n+/// particular, imagine a type like this:\n+///\n+///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n+///     ^          ^            |        |         |\n+///     |          |            |        |         |\n+///     |          +------------+ 1      |         |\n+///     |                                |         |\n+///     +--------------------------------+ 2       |\n+///     |                                          |\n+///     +------------------------------------------+ 1\n+///\n+/// In this type, there are two binders (the outer fn and the inner\n+/// fn). We need to be able to determine, for any given region, which\n+/// fn type it is bound by, the inner or the outer one. There are\n+/// various ways you can do this, but a De Bruijn index is one of the\n+/// more convenient and has some nice properties. The basic idea is to\n+/// count the number of binders, inside out. Some examples should help\n+/// clarify what I mean.\n+///\n+/// Let's start with the reference type `&'b isize` that is the first\n+/// argument to the inner function. This region `'b` is assigned a De\n+/// Bruijn index of 1, meaning \"the innermost binder\" (in this case, a\n+/// fn). The region `'a` that appears in the second argument type (`&'a\n+/// isize`) would then be assigned a De Bruijn index of 2, meaning \"the\n+/// second-innermost binder\". (These indices are written on the arrays\n+/// in the diagram).\n+///\n+/// What is interesting is that De Bruijn index attached to a particular\n+/// variable will vary depending on where it appears. For example,\n+/// the final type `&'a char` also refers to the region `'a` declared on\n+/// the outermost fn. But this time, this reference is not nested within\n+/// any other binders (i.e., it is not an argument to the inner fn, but\n+/// rather the outer one). Therefore, in this case, it is assigned a\n+/// De Bruijn index of 1, because the innermost binder in that location\n+/// is the outer fn.\n+///\n+/// [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n+pub struct DebruijnIndex {\n+    // We maintain the invariant that this is never 0. So 1 indicates\n+    // the innermost binder. To ensure this, create with `DebruijnIndex::new`.\n+    pub depth: u32,\n+}\n+\n+/// Representation of regions.\n+///\n+/// Unlike types, most region variants are \"fictitious\", not concrete,\n+/// regions. Among these, `ReStatic`, `ReEmpty` and `ReScope` are the only\n+/// ones representing concrete regions.\n+///\n+/// ## Bound Regions\n+///\n+/// These are regions that are stored behind a binder and must be substituted\n+/// with some concrete region before being used. There are 2 kind of\n+/// bound regions: early-bound, which are bound in a TypeScheme/TraitDef,\n+/// and are substituted by a Substs,  and late-bound, which are part of\n+/// higher-ranked types (e.g. `for<'a> fn(&'a ())`) and are substituted by\n+/// the likes of `liberate_late_bound_regions`. The distinction exists\n+/// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n+///\n+/// Unlike TyParam-s, bound regions are not supposed to exist \"in the wild\"\n+/// outside their binder, e.g. in types passed to type inference, and\n+/// should first be substituted (by skolemized regions, free regions,\n+/// or region variables).\n+///\n+/// ## Skolemized and Free Regions\n+///\n+/// One often wants to work with bound regions without knowing their precise\n+/// identity. For example, when checking a function, the lifetime of a borrow\n+/// can end up being assigned to some region parameter. In these cases,\n+/// it must be ensured that bounds on the region can't be accidentally\n+/// assumed without being checked.\n+///\n+/// The process of doing that is called \"skolemization\". The bound regions\n+/// are replaced by skolemized markers, which don't satisfy any relation\n+/// not explicity provided.\n+///\n+/// There are 2 kinds of skolemized regions in rustc: `ReFree` and\n+/// `ReSkolemized`. When checking an item's body, `ReFree` is supposed\n+/// to be used. These also support explicit bounds: both the internally-stored\n+/// *scope*, which the region is assumed to outlive, as well as other\n+/// relations stored in the `FreeRegionMap`. Note that these relations\n+/// aren't checked when you `make_subregion` (or `mk_eqty`), only by\n+/// `resolve_regions_and_report_errors`.\n+///\n+/// When working with higher-ranked types, some region relations aren't\n+/// yet known, so you can't just call `resolve_regions_and_report_errors`.\n+/// `ReSkolemized` is designed for this purpose. In these contexts,\n+/// there's also the risk that some inference variable laying around will\n+/// get unified with your skolemized region: if you want to check whether\n+/// `for<'a> Foo<'_>: 'a`, and you substitute your bound region `'a`\n+/// with a skolemized region `'%a`, the variable `'_` would just be\n+/// instantiated to the skolemized region `'%a`, which is wrong because\n+/// the inference variable is supposed to satisfy the relation\n+/// *for every value of the skolemized region*. To ensure that doesn't\n+/// happen, you can use `leak_check`. This is more clearly explained\n+/// by infer/higher_ranked/README.md.\n+///\n+/// [1] http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n+/// [2] http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n+#[derive(Clone, PartialEq, Eq, Hash, Copy)]\n+pub enum Region {\n+    // Region bound in a type or fn declaration which will be\n+    // substituted 'early' -- that is, at the same time when type\n+    // parameters are substituted.\n+    ReEarlyBound(EarlyBoundRegion),\n+\n+    // Region bound in a function scope, which will be substituted when the\n+    // function is called.\n+    ReLateBound(DebruijnIndex, BoundRegion),\n+\n+    /// When checking a function body, the types of all arguments and so forth\n+    /// that refer to bound region parameters are modified to refer to free\n+    /// region parameters.\n+    ReFree(FreeRegion),\n+\n+    /// A concrete region naming some statically determined extent\n+    /// (e.g. an expression or sequence of statements) within the\n+    /// current function.\n+    ReScope(region::CodeExtent),\n+\n+    /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n+    ReStatic,\n+\n+    /// A region variable.  Should not exist after typeck.\n+    ReVar(RegionVid),\n+\n+    /// A skolemized region - basically the higher-ranked version of ReFree.\n+    /// Should not exist after typeck.\n+    ReSkolemized(SkolemizedRegionVid, BoundRegion),\n+\n+    /// Empty lifetime is for data that is never accessed.\n+    /// Bottom in the region lattice. We treat ReEmpty somewhat\n+    /// specially; at least right now, we do not generate instances of\n+    /// it during the GLB computations, but rather\n+    /// generate an error instead. This is to improve error messages.\n+    /// The only way to get an instance of ReEmpty is to have a region\n+    /// variable with no constraints.\n+    ReEmpty,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+pub struct EarlyBoundRegion {\n+    pub param_id: NodeId,\n+    pub space: subst::ParamSpace,\n+    pub index: u32,\n+    pub name: Name,\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TyVid {\n+    pub index: u32\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct IntVid {\n+    pub index: u32\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct FloatVid {\n+    pub index: u32\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub struct RegionVid {\n+    pub index: u32\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SkolemizedRegionVid {\n+    pub index: u32\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum InferTy {\n+    TyVar(TyVid),\n+    IntVar(IntVid),\n+    FloatVar(FloatVid),\n+\n+    /// A `FreshTy` is one that is generated as a replacement for an\n+    /// unbound type variable. This is convenient for caching etc. See\n+    /// `middle::infer::freshen` for more details.\n+    FreshTy(u32),\n+    FreshIntTy(u32),\n+    FreshFloatTy(u32)\n+}\n+\n+/// Bounds suitable for an existentially quantified type parameter\n+/// such as those that appear in object types or closure types.\n+#[derive(PartialEq, Eq, Hash, Clone)]\n+pub struct ExistentialBounds<'tcx> {\n+    pub region_bound: ty::Region,\n+    pub builtin_bounds: BuiltinBounds,\n+    pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n+}\n+\n+impl<'tcx> ExistentialBounds<'tcx> {\n+    pub fn new(region_bound: ty::Region,\n+               builtin_bounds: BuiltinBounds,\n+               projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>)\n+               -> Self {\n+        let mut projection_bounds = projection_bounds;\n+        projection_bounds.sort_by(|a, b| a.sort_key().cmp(&b.sort_key()));\n+        ExistentialBounds {\n+            region_bound: region_bound,\n+            builtin_bounds: builtin_bounds,\n+            projection_bounds: projection_bounds\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n+\n+impl BuiltinBounds {\n+    pub fn empty() -> BuiltinBounds {\n+        BuiltinBounds(EnumSet::new())\n+    }\n+\n+    pub fn iter(&self) -> enum_set::Iter<BuiltinBound> {\n+        self.into_iter()\n+    }\n+\n+    pub fn to_predicates<'tcx>(&self,\n+                               tcx: &ty::ctxt<'tcx>,\n+                               self_ty: Ty<'tcx>) -> Vec<ty::Predicate<'tcx>> {\n+        self.iter().filter_map(|builtin_bound|\n+            match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, self_ty) {\n+                Ok(trait_ref) => Some(trait_ref.to_predicate()),\n+                Err(ErrorReported) => { None }\n+            }\n+        ).collect()\n+    }\n+}\n+\n+impl ops::Deref for BuiltinBounds {\n+    type Target = EnumSet<BuiltinBound>;\n+    fn deref(&self) -> &Self::Target { &self.0 }\n+}\n+\n+impl ops::DerefMut for BuiltinBounds {\n+    fn deref_mut(&mut self) -> &mut Self::Target { &mut self.0 }\n+}\n+\n+impl<'a> IntoIterator for &'a BuiltinBounds {\n+    type Item = BuiltinBound;\n+    type IntoIter = enum_set::Iter<BuiltinBound>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        (**self).into_iter()\n+    }\n+}\n+\n+#[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n+           Debug, Copy)]\n+#[repr(usize)]\n+pub enum BuiltinBound {\n+    Send,\n+    Sized,\n+    Copy,\n+    Sync,\n+}\n+\n+impl CLike for BuiltinBound {\n+    fn to_usize(&self) -> usize {\n+        *self as usize\n+    }\n+    fn from_usize(v: usize) -> BuiltinBound {\n+        unsafe { mem::transmute(v) }\n+    }\n+}\n+\n+impl<'tcx> ty::ctxt<'tcx> {\n+    pub fn try_add_builtin_trait(&self,\n+                                 trait_def_id: DefId,\n+                                 builtin_bounds: &mut EnumSet<BuiltinBound>)\n+                                 -> bool\n+    {\n+        //! Checks whether `trait_ref` refers to one of the builtin\n+        //! traits, like `Send`, and adds the corresponding\n+        //! bound to the set `builtin_bounds` if so. Returns true if `trait_ref`\n+        //! is a builtin trait.\n+\n+        match self.lang_items.to_builtin_kind(trait_def_id) {\n+            Some(bound) => { builtin_bounds.insert(bound); true }\n+            None => false\n+        }\n+    }\n+}\n+\n+impl DebruijnIndex {\n+    pub fn new(depth: u32) -> DebruijnIndex {\n+        assert!(depth > 0);\n+        DebruijnIndex { depth: depth }\n+    }\n+\n+    pub fn shifted(&self, amount: u32) -> DebruijnIndex {\n+        DebruijnIndex { depth: self.depth + amount }\n+    }\n+}\n+\n+// Region utilities\n+impl Region {\n+    pub fn is_bound(&self) -> bool {\n+        match *self {\n+            ty::ReEarlyBound(..) => true,\n+            ty::ReLateBound(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn needs_infer(&self) -> bool {\n+        match *self {\n+            ty::ReVar(..) | ty::ReSkolemized(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn escapes_depth(&self, depth: u32) -> bool {\n+        match *self {\n+            ty::ReLateBound(debruijn, _) => debruijn.depth > depth,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns the depth of `self` from the (1-based) binding level `depth`\n+    pub fn from_depth(&self, depth: u32) -> Region {\n+        match *self {\n+            ty::ReLateBound(debruijn, r) => ty::ReLateBound(DebruijnIndex {\n+                depth: debruijn.depth - (depth - 1)\n+            }, r),\n+            r => r\n+        }\n+    }\n+}\n+\n+// Type utilities\n+impl<'tcx> TyS<'tcx> {\n+    pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n+        match self.sty {\n+            ty::TyParam(ref d) => Some(d.clone()),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn is_nil(&self) -> bool {\n+        match self.sty {\n+            TyTuple(ref tys) => tys.is_empty(),\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_empty(&self, _cx: &ty::ctxt) -> bool {\n+        // FIXME(#24885): be smarter here\n+        match self.sty {\n+            TyEnum(def, _) | TyStruct(def, _) => def.is_empty(),\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_ty_var(&self) -> bool {\n+        match self.sty {\n+            TyInfer(TyVar(_)) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_bool(&self) -> bool { self.sty == TyBool }\n+\n+    pub fn is_param(&self, space: subst::ParamSpace, index: u32) -> bool {\n+        match self.sty {\n+            ty::TyParam(ref data) => data.space == space && data.idx == index,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_self(&self) -> bool {\n+        match self.sty {\n+            TyParam(ref p) => p.space == subst::SelfSpace,\n+            _ => false\n+        }\n+    }\n+\n+    fn is_slice(&self) -> bool {\n+        match self.sty {\n+            TyRawPtr(mt) | TyRef(_, mt) => match mt.ty.sty {\n+                TySlice(_) | TyStr => true,\n+                _ => false,\n+            },\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_structural(&self) -> bool {\n+        match self.sty {\n+            TyStruct(..) | TyTuple(_) | TyEnum(..) |\n+            TyArray(..) | TyClosure(..) => true,\n+            _ => self.is_slice() | self.is_trait()\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn is_simd(&self) -> bool {\n+        match self.sty {\n+            TyStruct(def, _) => def.is_simd(),\n+            _ => false\n+        }\n+    }\n+\n+    pub fn sequence_element_type(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        match self.sty {\n+            TyArray(ty, _) | TySlice(ty) => ty,\n+            TyStr => cx.mk_mach_uint(hir::TyU8),\n+            _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n+                                      self)),\n+        }\n+    }\n+\n+    pub fn simd_type(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        match self.sty {\n+            TyStruct(def, substs) => {\n+                def.struct_variant().fields[0].ty(cx, substs)\n+            }\n+            _ => panic!(\"simd_type called on invalid type\")\n+        }\n+    }\n+\n+    pub fn simd_size(&self, _cx: &ty::ctxt) -> usize {\n+        match self.sty {\n+            TyStruct(def, _) => def.struct_variant().fields.len(),\n+            _ => panic!(\"simd_size called on invalid type\")\n+        }\n+    }\n+\n+    pub fn is_region_ptr(&self) -> bool {\n+        match self.sty {\n+            TyRef(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_unsafe_ptr(&self) -> bool {\n+        match self.sty {\n+            TyRawPtr(_) => return true,\n+            _ => return false\n+        }\n+    }\n+\n+    pub fn is_unique(&self) -> bool {\n+        match self.sty {\n+            TyBox(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /*\n+     A scalar type is one that denotes an atomic datum, with no sub-components.\n+     (A TyRawPtr is scalar because it represents a non-managed pointer, so its\n+     contents are abstract to rustc.)\n+    */\n+    pub fn is_scalar(&self) -> bool {\n+        match self.sty {\n+            TyBool | TyChar | TyInt(_) | TyFloat(_) | TyUint(_) |\n+            TyInfer(IntVar(_)) | TyInfer(FloatVar(_)) |\n+            TyBareFn(..) | TyRawPtr(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Returns true if this type is a floating point type and false otherwise.\n+    pub fn is_floating_point(&self) -> bool {\n+        match self.sty {\n+            TyFloat(_) |\n+            TyInfer(FloatVar(_)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_trait(&self) -> bool {\n+        match self.sty {\n+            TyTrait(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_integral(&self) -> bool {\n+        match self.sty {\n+            TyInfer(IntVar(_)) | TyInt(_) | TyUint(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_fresh(&self) -> bool {\n+        match self.sty {\n+            TyInfer(FreshTy(_)) => true,\n+            TyInfer(FreshIntTy(_)) => true,\n+            TyInfer(FreshFloatTy(_)) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_uint(&self) -> bool {\n+        match self.sty {\n+            TyInfer(IntVar(_)) | TyUint(hir::TyUs) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_char(&self) -> bool {\n+        match self.sty {\n+            TyChar => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_bare_fn(&self) -> bool {\n+        match self.sty {\n+            TyBareFn(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_bare_fn_item(&self) -> bool {\n+        match self.sty {\n+            TyBareFn(Some(_), _) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_fp(&self) -> bool {\n+        match self.sty {\n+            TyInfer(FloatVar(_)) | TyFloat(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_numeric(&self) -> bool {\n+        self.is_integral() || self.is_fp()\n+    }\n+\n+    pub fn is_signed(&self) -> bool {\n+        match self.sty {\n+            TyInt(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_machine(&self) -> bool {\n+        match self.sty {\n+            TyInt(hir::TyIs) | TyUint(hir::TyUs) => false,\n+            TyInt(..) | TyUint(..) | TyFloat(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    // Returns the type and mutability of *ty.\n+    //\n+    // The parameter `explicit` indicates if this is an *explicit* dereference.\n+    // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n+    pub fn builtin_deref(&self, explicit: bool, pref: ty::LvaluePreference)\n+        -> Option<TypeAndMut<'tcx>>\n+    {\n+        match self.sty {\n+            TyBox(ty) => {\n+                Some(TypeAndMut {\n+                    ty: ty,\n+                    mutbl: if pref == ty::PreferMutLvalue {\n+                        hir::MutMutable\n+                    } else {\n+                        hir::MutImmutable\n+                    },\n+                })\n+            },\n+            TyRef(_, mt) => Some(mt),\n+            TyRawPtr(mt) if explicit => Some(mt),\n+            _ => None\n+        }\n+    }\n+\n+    // Returns the type of ty[i]\n+    pub fn builtin_index(&self) -> Option<Ty<'tcx>> {\n+        match self.sty {\n+            TyArray(ty, _) | TySlice(ty) => Some(ty),\n+            _ => None\n+        }\n+    }\n+\n+    pub fn fn_sig(&self) -> &'tcx PolyFnSig<'tcx> {\n+        match self.sty {\n+            TyBareFn(_, ref f) => &f.sig,\n+            _ => panic!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n+        }\n+    }\n+\n+    /// Returns the ABI of the given function.\n+    pub fn fn_abi(&self) -> abi::Abi {\n+        match self.sty {\n+            TyBareFn(_, ref f) => f.abi,\n+            _ => panic!(\"Ty::fn_abi() called on non-fn type\"),\n+        }\n+    }\n+\n+    // Type accessors for substructures of types\n+    pub fn fn_args(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n+        self.fn_sig().inputs()\n+    }\n+\n+    pub fn fn_ret(&self) -> Binder<FnOutput<'tcx>> {\n+        self.fn_sig().output()\n+    }\n+\n+    pub fn is_fn(&self) -> bool {\n+        match self.sty {\n+            TyBareFn(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn ty_to_def_id(&self) -> Option<DefId> {\n+        match self.sty {\n+            TyTrait(ref tt) => Some(tt.principal_def_id()),\n+            TyStruct(def, _) |\n+            TyEnum(def, _) => Some(def.did),\n+            TyClosure(id, _) => Some(id),\n+            _ => None\n+        }\n+    }\n+\n+    pub fn ty_adt_def(&self) -> Option<AdtDef<'tcx>> {\n+        match self.sty {\n+            TyStruct(adt, _) | TyEnum(adt, _) => Some(adt),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns the regions directly referenced from this type (but\n+    /// not types reachable from this type via `walk_tys`). This\n+    /// ignores late-bound regions binders.\n+    pub fn regions(&self) -> Vec<ty::Region> {\n+        match self.sty {\n+            TyRef(region, _) => {\n+                vec![*region]\n+            }\n+            TyTrait(ref obj) => {\n+                let mut v = vec![obj.bounds.region_bound];\n+                v.push_all(obj.principal.skip_binder().substs.regions().as_slice());\n+                v\n+            }\n+            TyEnum(_, substs) |\n+            TyStruct(_, substs) => {\n+                substs.regions().as_slice().to_vec()\n+            }\n+            TyClosure(_, ref substs) => {\n+                substs.func_substs.regions().as_slice().to_vec()\n+            }\n+            TyProjection(ref data) => {\n+                data.trait_ref.substs.regions().as_slice().to_vec()\n+            }\n+            TyBareFn(..) |\n+            TyBool |\n+            TyChar |\n+            TyInt(_) |\n+            TyUint(_) |\n+            TyFloat(_) |\n+            TyBox(_) |\n+            TyStr |\n+            TyArray(_, _) |\n+            TySlice(_) |\n+            TyRawPtr(_) |\n+            TyTuple(_) |\n+            TyParam(_) |\n+            TyInfer(_) |\n+            TyError => {\n+                vec![]\n+            }\n+        }\n+    }\n+}"}, {"sha": "883146185357610d07635437095106548b24a59f", "filename": "src/librustc/middle/ty/util.rs", "status": "added", "additions": 891, "deletions": 0, "changes": 891, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -0,0 +1,891 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! misc. type-system utilities too small to deserve their own file\n+\n+use back::svh::Svh;\n+use middle::const_eval::{self, ConstVal, ErrKind};\n+use middle::const_eval::EvalHint::UncheckedExprHint;\n+use middle::def_id::DefId;\n+use middle::subst;\n+use middle::infer;\n+use middle::pat_util;\n+use middle::traits;\n+use middle::ty::{self, Ty, TypeAndMut, TypeFlags};\n+use middle::ty::{Disr, ParameterEnvironment};\n+use middle::ty::{HasTypeFlags, RegionEscape};\n+use middle::ty::TypeVariants::*;\n+use util::num::ToPrimitive;\n+\n+use std::cmp;\n+use std::hash::{Hash, SipHasher, Hasher};\n+use syntax::ast::Name;\n+use syntax::codemap::Span;\n+\n+use rustc_front::hir;\n+use rustc_front::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n+\n+pub trait IntTypeExt {\n+    fn to_ty<'tcx>(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n+    fn i64_to_disr(&self, val: i64) -> Option<Disr>;\n+    fn u64_to_disr(&self, val: u64) -> Option<Disr>;\n+    fn disr_incr(&self, val: Disr) -> Option<Disr>;\n+    fn disr_string(&self, val: Disr) -> String;\n+    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr;\n+}\n+\n+impl IntTypeExt for attr::IntType {\n+    fn to_ty<'tcx>(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            SignedInt(hir::TyI8)      => cx.types.i8,\n+            SignedInt(hir::TyI16)     => cx.types.i16,\n+            SignedInt(hir::TyI32)     => cx.types.i32,\n+            SignedInt(hir::TyI64)     => cx.types.i64,\n+            SignedInt(hir::TyIs)   => cx.types.isize,\n+            UnsignedInt(hir::TyU8)    => cx.types.u8,\n+            UnsignedInt(hir::TyU16)   => cx.types.u16,\n+            UnsignedInt(hir::TyU32)   => cx.types.u32,\n+            UnsignedInt(hir::TyU64)   => cx.types.u64,\n+            UnsignedInt(hir::TyUs) => cx.types.usize,\n+        }\n+    }\n+\n+    fn i64_to_disr(&self, val: i64) -> Option<Disr> {\n+        match *self {\n+            SignedInt(hir::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(hir::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(hir::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(hir::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn u64_to_disr(&self, val: u64) -> Option<Disr> {\n+        match *self {\n+            SignedInt(hir::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(hir::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(hir::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(hir::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn disr_incr(&self, val: Disr) -> Option<Disr> {\n+        macro_rules! add1 {\n+            ($e:expr) => { $e.and_then(|v|v.checked_add(1)).map(|v| v as Disr) }\n+        }\n+        match *self {\n+            // SignedInt repr means we *want* to reinterpret the bits\n+            // treating the highest bit of Disr as a sign-bit, so\n+            // cast to i64 before range-checking.\n+            SignedInt(hir::TyI8)    => add1!((val as i64).to_i8()),\n+            SignedInt(hir::TyI16)   => add1!((val as i64).to_i16()),\n+            SignedInt(hir::TyI32)   => add1!((val as i64).to_i32()),\n+            SignedInt(hir::TyI64)   => add1!(Some(val as i64)),\n+\n+            UnsignedInt(hir::TyU8)  => add1!(val.to_u8()),\n+            UnsignedInt(hir::TyU16) => add1!(val.to_u16()),\n+            UnsignedInt(hir::TyU32) => add1!(val.to_u32()),\n+            UnsignedInt(hir::TyU64) => add1!(Some(val)),\n+\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    // This returns a String because (1.) it is only used for\n+    // rendering an error message and (2.) a string can represent the\n+    // full range from `i64::MIN` through `u64::MAX`.\n+    fn disr_string(&self, val: Disr) -> String {\n+        match *self {\n+            SignedInt(hir::TyI8)    => format!(\"{}\", val as i8 ),\n+            SignedInt(hir::TyI16)   => format!(\"{}\", val as i16),\n+            SignedInt(hir::TyI32)   => format!(\"{}\", val as i32),\n+            SignedInt(hir::TyI64)   => format!(\"{}\", val as i64),\n+            UnsignedInt(hir::TyU8)  => format!(\"{}\", val as u8 ),\n+            UnsignedInt(hir::TyU16) => format!(\"{}\", val as u16),\n+            UnsignedInt(hir::TyU32) => format!(\"{}\", val as u32),\n+            UnsignedInt(hir::TyU64) => format!(\"{}\", val as u64),\n+\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr {\n+        macro_rules! add1 {\n+            ($e:expr) => { ($e).wrapping_add(1) as Disr }\n+        }\n+        let val = val.unwrap_or(ty::INITIAL_DISCRIMINANT_VALUE);\n+        match *self {\n+            SignedInt(hir::TyI8)    => add1!(val as i8 ),\n+            SignedInt(hir::TyI16)   => add1!(val as i16),\n+            SignedInt(hir::TyI32)   => add1!(val as i32),\n+            SignedInt(hir::TyI64)   => add1!(val as i64),\n+            UnsignedInt(hir::TyU8)  => add1!(val as u8 ),\n+            UnsignedInt(hir::TyU16) => add1!(val as u16),\n+            UnsignedInt(hir::TyU32) => add1!(val as u32),\n+            UnsignedInt(hir::TyU64) => add1!(val as u64),\n+\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n+        }\n+    }\n+}\n+\n+\n+#[derive(Copy, Clone)]\n+pub enum CopyImplementationError {\n+    InfrigingField(Name),\n+    InfrigingVariant(Name),\n+    NotAnAdt,\n+    HasDestructor\n+}\n+\n+/// Describes whether a type is representable. For types that are not\n+/// representable, 'SelfRecursive' and 'ContainsRecursive' are used to\n+/// distinguish between types that are recursive with themselves and types that\n+/// contain a different recursive type. These cases can therefore be treated\n+/// differently when reporting errors.\n+///\n+/// The ordering of the cases is significant. They are sorted so that cmp::max\n+/// will keep the \"more erroneous\" of two values.\n+#[derive(Copy, Clone, PartialOrd, Ord, Eq, PartialEq, Debug)]\n+pub enum Representability {\n+    Representable,\n+    ContainsRecursive,\n+    SelfRecursive,\n+}\n+\n+impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n+    pub fn can_type_implement_copy(&self, self_type: Ty<'tcx>, span: Span)\n+                                   -> Result<(),CopyImplementationError> {\n+        let tcx = self.tcx;\n+\n+        // FIXME: (@jroesch) float this code up\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(self.clone()), false);\n+\n+        let adt = match self_type.sty {\n+            ty::TyStruct(struct_def, substs) => {\n+                for field in struct_def.all_fields() {\n+                    let field_ty = field.ty(tcx, substs);\n+                    if infcx.type_moves_by_default(field_ty, span) {\n+                        return Err(CopyImplementationError::InfrigingField(\n+                            field.name))\n+                    }\n+                }\n+                struct_def\n+            }\n+            ty::TyEnum(enum_def, substs) => {\n+                for variant in &enum_def.variants {\n+                    for field in &variant.fields {\n+                        let field_ty = field.ty(tcx, substs);\n+                        if infcx.type_moves_by_default(field_ty, span) {\n+                            return Err(CopyImplementationError::InfrigingVariant(\n+                                variant.name))\n+                        }\n+                    }\n+                }\n+                enum_def\n+            }\n+            _ => return Err(CopyImplementationError::NotAnAdt),\n+        };\n+\n+        if adt.has_dtor() {\n+            return Err(CopyImplementationError::HasDestructor)\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<'tcx> ty::ctxt<'tcx> {\n+    pub fn pat_contains_ref_binding(&self, pat: &hir::Pat) -> Option<hir::Mutability> {\n+        pat_util::pat_contains_ref_binding(&self.def_map, pat)\n+    }\n+\n+    pub fn arm_contains_ref_binding(&self, arm: &hir::Arm) -> Option<hir::Mutability> {\n+        pat_util::arm_contains_ref_binding(&self.def_map, arm)\n+    }\n+\n+    /// Returns the type of element at index `i` in tuple or tuple-like type `t`.\n+    /// For an enum `t`, `variant` is None only if `t` is a univariant enum.\n+    pub fn positional_element_ty(&self,\n+                                 ty: Ty<'tcx>,\n+                                 i: usize,\n+                                 variant: Option<DefId>) -> Option<Ty<'tcx>> {\n+        match (&ty.sty, variant) {\n+            (&TyStruct(def, substs), None) => {\n+                def.struct_variant().fields.get(i).map(|f| f.ty(self, substs))\n+            }\n+            (&TyEnum(def, substs), Some(vid)) => {\n+                def.variant_with_id(vid).fields.get(i).map(|f| f.ty(self, substs))\n+            }\n+            (&TyEnum(def, substs), None) => {\n+                assert!(def.is_univariant());\n+                def.variants[0].fields.get(i).map(|f| f.ty(self, substs))\n+            }\n+            (&TyTuple(ref v), None) => v.get(i).cloned(),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns the type of element at field `n` in struct or struct-like type `t`.\n+    /// For an enum `t`, `variant` must be some def id.\n+    pub fn named_element_ty(&self,\n+                            ty: Ty<'tcx>,\n+                            n: Name,\n+                            variant: Option<DefId>) -> Option<Ty<'tcx>> {\n+        match (&ty.sty, variant) {\n+            (&TyStruct(def, substs), None) => {\n+                def.struct_variant().find_field_named(n).map(|f| f.ty(self, substs))\n+            }\n+            (&TyEnum(def, substs), Some(vid)) => {\n+                def.variant_with_id(vid).find_field_named(n).map(|f| f.ty(self, substs))\n+            }\n+            _ => return None\n+        }\n+    }\n+\n+    /// Returns `(normalized_type, ty)`, where `normalized_type` is the\n+    /// IntType representation of one of {i64,i32,i16,i8,u64,u32,u16,u8},\n+    /// and `ty` is the original type (i.e. may include `isize` or\n+    /// `usize`).\n+    pub fn enum_repr_type(&self, opt_hint: Option<&attr::ReprAttr>)\n+                          -> (attr::IntType, Ty<'tcx>) {\n+        let repr_type = match opt_hint {\n+            // Feed in the given type\n+            Some(&attr::ReprInt(_, int_t)) => int_t,\n+            // ... but provide sensible default if none provided\n+            //\n+            // NB. Historically `fn enum_variants` generate i64 here, while\n+            // rustc_typeck::check would generate isize.\n+            _ => SignedInt(hir::TyIs),\n+        };\n+\n+        let repr_type_ty = repr_type.to_ty(self);\n+        let repr_type = match repr_type {\n+            SignedInt(hir::TyIs) =>\n+                SignedInt(self.sess.target.int_type),\n+            UnsignedInt(hir::TyUs) =>\n+                UnsignedInt(self.sess.target.uint_type),\n+            other => other\n+        };\n+\n+        (repr_type, repr_type_ty)\n+    }\n+\n+    /// Returns the deeply last field of nested structures, or the same type,\n+    /// if not a structure at all. Corresponds to the only possible unsized\n+    /// field, and its type can be used to determine unsizing strategy.\n+    pub fn struct_tail(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+        while let TyStruct(def, substs) = ty.sty {\n+            match def.struct_variant().fields.last() {\n+                Some(f) => ty = f.ty(self, substs),\n+                None => break\n+            }\n+        }\n+        ty\n+    }\n+\n+    /// Same as applying struct_tail on `source` and `target`, but only\n+    /// keeps going as long as the two types are instances of the same\n+    /// structure definitions.\n+    /// For `(Foo<Foo<T>>, Foo<Trait>)`, the result will be `(Foo<T>, Trait)`,\n+    /// whereas struct_tail produces `T`, and `Trait`, respectively.\n+    pub fn struct_lockstep_tails(&self,\n+                                 source: Ty<'tcx>,\n+                                 target: Ty<'tcx>)\n+                                 -> (Ty<'tcx>, Ty<'tcx>) {\n+        let (mut a, mut b) = (source, target);\n+        while let (&TyStruct(a_def, a_substs), &TyStruct(b_def, b_substs)) = (&a.sty, &b.sty) {\n+            if a_def != b_def {\n+                break;\n+            }\n+            if let Some(f) = a_def.struct_variant().fields.last() {\n+                a = f.ty(self, a_substs);\n+                b = f.ty(self, b_substs);\n+            } else {\n+                break;\n+            }\n+        }\n+        (a, b)\n+    }\n+\n+    /// Returns the repeat count for a repeating vector expression.\n+    pub fn eval_repeat_count(&self, count_expr: &hir::Expr) -> usize {\n+        let hint = UncheckedExprHint(self.types.usize);\n+        match const_eval::eval_const_expr_partial(self, count_expr, hint) {\n+            Ok(val) => {\n+                let found = match val {\n+                    ConstVal::Uint(count) => return count as usize,\n+                    ConstVal::Int(count) if count >= 0 => return count as usize,\n+                    const_val => const_val.description(),\n+                };\n+                span_err!(self.sess, count_expr.span, E0306,\n+                    \"expected positive integer for repeat count, found {}\",\n+                    found);\n+            }\n+            Err(err) => {\n+                let err_msg = match count_expr.node {\n+                    hir::ExprPath(None, hir::Path {\n+                        global: false,\n+                        ref segments,\n+                        ..\n+                    }) if segments.len() == 1 =>\n+                        format!(\"found variable\"),\n+                    _ => match err.kind {\n+                        ErrKind::MiscCatchAll => format!(\"but found {}\", err.description()),\n+                        _ => format!(\"but {}\", err.description())\n+                    }\n+                };\n+                span_err!(self.sess, count_expr.span, E0307,\n+                    \"expected constant integer for repeat count, {}\", err_msg);\n+            }\n+        }\n+        0\n+    }\n+\n+    /// Given a set of predicates that apply to an object type, returns\n+    /// the region bounds that the (erased) `Self` type must\n+    /// outlive. Precisely *because* the `Self` type is erased, the\n+    /// parameter `erased_self_ty` must be supplied to indicate what type\n+    /// has been used to represent `Self` in the predicates\n+    /// themselves. This should really be a unique type; `FreshTy(0)` is a\n+    /// popular choice.\n+    ///\n+    /// NB: in some cases, particularly around higher-ranked bounds,\n+    /// this function returns a kind of conservative approximation.\n+    /// That is, all regions returned by this function are definitely\n+    /// required, but there may be other region bounds that are not\n+    /// returned, as well as requirements like `for<'a> T: 'a`.\n+    ///\n+    /// Requires that trait definitions have been processed so that we can\n+    /// elaborate predicates and walk supertraits.\n+    pub fn required_region_bounds(&self,\n+                                  erased_self_ty: Ty<'tcx>,\n+                                  predicates: Vec<ty::Predicate<'tcx>>)\n+                                  -> Vec<ty::Region>    {\n+        debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n+               erased_self_ty,\n+               predicates);\n+\n+        assert!(!erased_self_ty.has_escaping_regions());\n+\n+        traits::elaborate_predicates(self, predicates)\n+            .filter_map(|predicate| {\n+                match predicate {\n+                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::Trait(..) |\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n+                    ty::Predicate::RegionOutlives(..) => {\n+                        None\n+                    }\n+                    ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t, r))) => {\n+                        // Search for a bound of the form `erased_self_ty\n+                        // : 'a`, but be wary of something like `for<'a>\n+                        // erased_self_ty : 'a` (we interpret a\n+                        // higher-ranked bound like that as 'static,\n+                        // though at present the code in `fulfill.rs`\n+                        // considers such bounds to be unsatisfiable, so\n+                        // it's kind of a moot point since you could never\n+                        // construct such an object, but this seems\n+                        // correct even if that code changes).\n+                        if t == erased_self_ty && !r.has_escaping_regions() {\n+                            Some(r)\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    /// Creates a hash of the type `Ty` which will be the same no matter what crate\n+    /// context it's calculated within. This is used by the `type_id` intrinsic.\n+    pub fn hash_crate_independent(&self, ty: Ty<'tcx>, svh: &Svh) -> u64 {\n+        let mut state = SipHasher::new();\n+        helper(self, ty, svh, &mut state);\n+        return state.finish();\n+\n+        fn helper<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh,\n+                        state: &mut SipHasher) {\n+            macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n+            macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n+\n+            let region = |state: &mut SipHasher, r: ty::Region| {\n+                match r {\n+                    ty::ReStatic => {}\n+                    ty::ReLateBound(db, ty::BrAnon(i)) => {\n+                        db.hash(state);\n+                        i.hash(state);\n+                    }\n+                    ty::ReEmpty |\n+                    ty::ReEarlyBound(..) |\n+                    ty::ReLateBound(..) |\n+                    ty::ReFree(..) |\n+                    ty::ReScope(..) |\n+                    ty::ReVar(..) |\n+                    ty::ReSkolemized(..) => {\n+                        tcx.sess.bug(\"unexpected region found when hashing a type\")\n+                    }\n+                }\n+            };\n+            let did = |state: &mut SipHasher, did: DefId| {\n+                let h = if did.is_local() {\n+                    svh.clone()\n+                } else {\n+                    tcx.sess.cstore.get_crate_hash(did.krate)\n+                };\n+                h.as_str().hash(state);\n+                did.node.hash(state);\n+            };\n+            let mt = |state: &mut SipHasher, mt: TypeAndMut| {\n+                mt.mutbl.hash(state);\n+            };\n+            let fn_sig = |state: &mut SipHasher, sig: &ty::Binder<ty::FnSig<'tcx>>| {\n+                let sig = tcx.anonymize_late_bound_regions(sig).0;\n+                for a in &sig.inputs { helper(tcx, *a, svh, state); }\n+                if let ty::FnConverging(output) = sig.output {\n+                    helper(tcx, output, svh, state);\n+                }\n+            };\n+            ty.maybe_walk(|ty| {\n+                match ty.sty {\n+                    TyBool => byte!(2),\n+                    TyChar => byte!(3),\n+                    TyInt(i) => {\n+                        byte!(4);\n+                        hash!(i);\n+                    }\n+                    TyUint(u) => {\n+                        byte!(5);\n+                        hash!(u);\n+                    }\n+                    TyFloat(f) => {\n+                        byte!(6);\n+                        hash!(f);\n+                    }\n+                    TyStr => {\n+                        byte!(7);\n+                    }\n+                    TyEnum(d, _) => {\n+                        byte!(8);\n+                        did(state, d.did);\n+                    }\n+                    TyBox(_) => {\n+                        byte!(9);\n+                    }\n+                    TyArray(_, n) => {\n+                        byte!(10);\n+                        n.hash(state);\n+                    }\n+                    TySlice(_) => {\n+                        byte!(11);\n+                    }\n+                    TyRawPtr(m) => {\n+                        byte!(12);\n+                        mt(state, m);\n+                    }\n+                    TyRef(r, m) => {\n+                        byte!(13);\n+                        region(state, *r);\n+                        mt(state, m);\n+                    }\n+                    TyBareFn(opt_def_id, ref b) => {\n+                        byte!(14);\n+                        hash!(opt_def_id);\n+                        hash!(b.unsafety);\n+                        hash!(b.abi);\n+                        fn_sig(state, &b.sig);\n+                        return false;\n+                    }\n+                    TyTrait(ref data) => {\n+                        byte!(17);\n+                        did(state, data.principal_def_id());\n+                        hash!(data.bounds);\n+\n+                        let principal = tcx.anonymize_late_bound_regions(&data.principal).0;\n+                        for subty in &principal.substs.types {\n+                            helper(tcx, subty, svh, state);\n+                        }\n+\n+                        return false;\n+                    }\n+                    TyStruct(d, _) => {\n+                        byte!(18);\n+                        did(state, d.did);\n+                    }\n+                    TyTuple(ref inner) => {\n+                        byte!(19);\n+                        hash!(inner.len());\n+                    }\n+                    TyParam(p) => {\n+                        byte!(20);\n+                        hash!(p.space);\n+                        hash!(p.idx);\n+                        hash!(p.name.as_str());\n+                    }\n+                    TyInfer(_) => unreachable!(),\n+                    TyError => byte!(21),\n+                    TyClosure(d, _) => {\n+                        byte!(22);\n+                        did(state, d);\n+                    }\n+                    TyProjection(ref data) => {\n+                        byte!(23);\n+                        did(state, data.trait_ref.def_id);\n+                        hash!(data.item_name.as_str());\n+                    }\n+                }\n+                true\n+            });\n+        }\n+    }\n+\n+    /// Returns true if this ADT is a dtorck type, i.e. whether it being\n+    /// safe for destruction requires it to be alive\n+    pub fn is_adt_dtorck(&self, adt: ty::AdtDef<'tcx>) -> bool {\n+        let dtor_method = match adt.destructor() {\n+            Some(dtor) => dtor,\n+            None => return false\n+        };\n+        let impl_did = self.impl_of_method(dtor_method).unwrap_or_else(|| {\n+            self.sess.bug(&format!(\"no Drop impl for the dtor of `{:?}`\", adt))\n+        });\n+        let generics = adt.type_scheme(self).generics;\n+\n+        // In `impl<'a> Drop ...`, we automatically assume\n+        // `'a` is meaningful and thus represents a bound\n+        // through which we could reach borrowed data.\n+        //\n+        // FIXME (pnkfelix): In the future it would be good to\n+        // extend the language to allow the user to express,\n+        // in the impl signature, that a lifetime is not\n+        // actually used (something like `where 'a: ?Live`).\n+        if generics.has_region_params(subst::TypeSpace) {\n+            debug!(\"typ: {:?} has interesting dtor due to region params\",\n+                   adt);\n+            return true;\n+        }\n+\n+        let mut seen_items = Vec::new();\n+        let mut items_to_inspect = vec![impl_did];\n+        while let Some(item_def_id) = items_to_inspect.pop() {\n+            if seen_items.contains(&item_def_id) {\n+                continue;\n+            }\n+\n+            for pred in self.lookup_predicates(item_def_id).predicates {\n+                let result = match pred {\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n+                    ty::Predicate::Projection(..) => {\n+                        // For now, assume all these where-clauses\n+                        // may give drop implementation capabilty\n+                        // to access borrowed data.\n+                        true\n+                    }\n+\n+                    ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n+                        let def_id = t_pred.trait_ref.def_id;\n+                        if self.trait_items(def_id).len() != 0 {\n+                            // If trait has items, assume it adds\n+                            // capability to access borrowed data.\n+                            true\n+                        } else {\n+                            // Trait without items is itself\n+                            // uninteresting from POV of dropck.\n+                            //\n+                            // However, may have parent w/ items;\n+                            // so schedule checking of predicates,\n+                            items_to_inspect.push(def_id);\n+                            // and say \"no capability found\" for now.\n+                            false\n+                        }\n+                    }\n+                };\n+\n+                if result {\n+                    debug!(\"typ: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n+                           adt, pred);\n+                    return true;\n+                }\n+            }\n+\n+            seen_items.push(item_def_id);\n+        }\n+\n+        debug!(\"typ: {:?} is dtorck-safe\", adt);\n+        false\n+    }\n+}\n+\n+impl<'tcx> ty::TyS<'tcx> {\n+    fn impls_bound<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n+                       bound: ty::BuiltinBound,\n+                       span: Span)\n+                       -> bool\n+    {\n+        let tcx = param_env.tcx;\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()), false);\n+\n+        let is_impld = traits::type_known_to_meet_builtin_bound(&infcx,\n+                                                                self, bound, span);\n+\n+        debug!(\"Ty::impls_bound({:?}, {:?}) = {:?}\",\n+               self, bound, is_impld);\n+\n+        is_impld\n+    }\n+\n+    // FIXME (@jroesch): I made this public to use it, not sure if should be private\n+    pub fn moves_by_default<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n+                           span: Span) -> bool {\n+        if self.flags.get().intersects(TypeFlags::MOVENESS_CACHED) {\n+            return self.flags.get().intersects(TypeFlags::MOVES_BY_DEFAULT);\n+        }\n+\n+        assert!(!self.needs_infer());\n+\n+        // Fast-path for primitive types\n+        let result = match self.sty {\n+            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+            TyRawPtr(..) | TyBareFn(..) | TyRef(_, TypeAndMut {\n+                mutbl: hir::MutImmutable, ..\n+            }) => Some(false),\n+\n+            TyStr | TyBox(..) | TyRef(_, TypeAndMut {\n+                mutbl: hir::MutMutable, ..\n+            }) => Some(true),\n+\n+            TyArray(..) | TySlice(_) | TyTrait(..) | TyTuple(..) |\n+            TyClosure(..) | TyEnum(..) | TyStruct(..) |\n+            TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n+        }.unwrap_or_else(|| !self.impls_bound(param_env, ty::BoundCopy, span));\n+\n+        if !self.has_param_types() && !self.has_self_ty() {\n+            self.flags.set(self.flags.get() | if result {\n+                TypeFlags::MOVENESS_CACHED | TypeFlags::MOVES_BY_DEFAULT\n+            } else {\n+                TypeFlags::MOVENESS_CACHED\n+            });\n+        }\n+\n+        result\n+    }\n+\n+    #[inline]\n+    pub fn is_sized<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n+                        span: Span) -> bool\n+    {\n+        if self.flags.get().intersects(TypeFlags::SIZEDNESS_CACHED) {\n+            return self.flags.get().intersects(TypeFlags::IS_SIZED);\n+        }\n+\n+        self.is_sized_uncached(param_env, span)\n+    }\n+\n+    fn is_sized_uncached<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n+                             span: Span) -> bool {\n+        assert!(!self.needs_infer());\n+\n+        // Fast-path for primitive types\n+        let result = match self.sty {\n+            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+            TyBox(..) | TyRawPtr(..) | TyRef(..) | TyBareFn(..) |\n+            TyArray(..) | TyTuple(..) | TyClosure(..) => Some(true),\n+\n+            TyStr | TyTrait(..) | TySlice(_) => Some(false),\n+\n+            TyEnum(..) | TyStruct(..) | TyProjection(..) | TyParam(..) |\n+            TyInfer(..) | TyError => None\n+        }.unwrap_or_else(|| self.impls_bound(param_env, ty::BoundSized, span));\n+\n+        if !self.has_param_types() && !self.has_self_ty() {\n+            self.flags.set(self.flags.get() | if result {\n+                TypeFlags::SIZEDNESS_CACHED | TypeFlags::IS_SIZED\n+            } else {\n+                TypeFlags::SIZEDNESS_CACHED\n+            });\n+        }\n+\n+        result\n+    }\n+\n+\n+    /// Check whether a type is representable. This means it cannot contain unboxed\n+    /// structural recursion. This check is needed for structs and enums.\n+    pub fn is_representable(&'tcx self, cx: &ty::ctxt<'tcx>, sp: Span) -> Representability {\n+\n+        // Iterate until something non-representable is found\n+        fn find_nonrepresentable<'tcx, It: Iterator<Item=Ty<'tcx>>>(cx: &ty::ctxt<'tcx>,\n+                                                                    sp: Span,\n+                                                                    seen: &mut Vec<Ty<'tcx>>,\n+                                                                    iter: It)\n+                                                                    -> Representability {\n+            iter.fold(Representability::Representable,\n+                      |r, ty| cmp::max(r, is_type_structurally_recursive(cx, sp, seen, ty)))\n+        }\n+\n+        fn are_inner_types_recursive<'tcx>(cx: &ty::ctxt<'tcx>, sp: Span,\n+                                           seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n+                                           -> Representability {\n+            match ty.sty {\n+                TyTuple(ref ts) => {\n+                    find_nonrepresentable(cx, sp, seen, ts.iter().cloned())\n+                }\n+                // Fixed-length vectors.\n+                // FIXME(#11924) Behavior undecided for zero-length vectors.\n+                TyArray(ty, _) => {\n+                    is_type_structurally_recursive(cx, sp, seen, ty)\n+                }\n+                TyStruct(def, substs) | TyEnum(def, substs) => {\n+                    find_nonrepresentable(cx,\n+                                          sp,\n+                                          seen,\n+                                          def.all_fields().map(|f| f.ty(cx, substs)))\n+                }\n+                TyClosure(..) => {\n+                    // this check is run on type definitions, so we don't expect\n+                    // to see closure types\n+                    cx.sess.bug(&format!(\"requires check invoked on inapplicable type: {:?}\", ty))\n+                }\n+                _ => Representability::Representable,\n+            }\n+        }\n+\n+        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n+            match ty.sty {\n+                TyStruct(ty_def, _) | TyEnum(ty_def, _) => {\n+                     ty_def == def\n+                }\n+                _ => false\n+            }\n+        }\n+\n+        fn same_type<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+            match (&a.sty, &b.sty) {\n+                (&TyStruct(did_a, ref substs_a), &TyStruct(did_b, ref substs_b)) |\n+                (&TyEnum(did_a, ref substs_a), &TyEnum(did_b, ref substs_b)) => {\n+                    if did_a != did_b {\n+                        return false;\n+                    }\n+\n+                    let types_a = substs_a.types.get_slice(subst::TypeSpace);\n+                    let types_b = substs_b.types.get_slice(subst::TypeSpace);\n+\n+                    let mut pairs = types_a.iter().zip(types_b);\n+\n+                    pairs.all(|(&a, &b)| same_type(a, b))\n+                }\n+                _ => {\n+                    a == b\n+                }\n+            }\n+        }\n+\n+        // Does the type `ty` directly (without indirection through a pointer)\n+        // contain any types on stack `seen`?\n+        fn is_type_structurally_recursive<'tcx>(cx: &ty::ctxt<'tcx>,\n+                                                sp: Span,\n+                                                seen: &mut Vec<Ty<'tcx>>,\n+                                                ty: Ty<'tcx>) -> Representability {\n+            debug!(\"is_type_structurally_recursive: {:?}\", ty);\n+\n+            match ty.sty {\n+                TyStruct(def, _) | TyEnum(def, _) => {\n+                    {\n+                        // Iterate through stack of previously seen types.\n+                        let mut iter = seen.iter();\n+\n+                        // The first item in `seen` is the type we are actually curious about.\n+                        // We want to return SelfRecursive if this type contains itself.\n+                        // It is important that we DON'T take generic parameters into account\n+                        // for this check, so that Bar<T> in this example counts as SelfRecursive:\n+                        //\n+                        // struct Foo;\n+                        // struct Bar<T> { x: Bar<Foo> }\n+\n+                        match iter.next() {\n+                            Some(&seen_type) => {\n+                                if same_struct_or_enum(seen_type, def) {\n+                                    debug!(\"SelfRecursive: {:?} contains {:?}\",\n+                                           seen_type,\n+                                           ty);\n+                                    return Representability::SelfRecursive;\n+                                }\n+                            }\n+                            None => {}\n+                        }\n+\n+                        // We also need to know whether the first item contains other types\n+                        // that are structurally recursive. If we don't catch this case, we\n+                        // will recurse infinitely for some inputs.\n+                        //\n+                        // It is important that we DO take generic parameters into account\n+                        // here, so that code like this is considered SelfRecursive, not\n+                        // ContainsRecursive:\n+                        //\n+                        // struct Foo { Option<Option<Foo>> }\n+\n+                        for &seen_type in iter {\n+                            if same_type(ty, seen_type) {\n+                                debug!(\"ContainsRecursive: {:?} contains {:?}\",\n+                                       seen_type,\n+                                       ty);\n+                                return Representability::ContainsRecursive;\n+                            }\n+                        }\n+                    }\n+\n+                    // For structs and enums, track all previously seen types by pushing them\n+                    // onto the 'seen' stack.\n+                    seen.push(ty);\n+                    let out = are_inner_types_recursive(cx, sp, seen, ty);\n+                    seen.pop();\n+                    out\n+                }\n+                _ => {\n+                    // No need to push in other cases.\n+                    are_inner_types_recursive(cx, sp, seen, ty)\n+                }\n+            }\n+        }\n+\n+        debug!(\"is_type_representable: {:?}\", self);\n+\n+        // To avoid a stack overflow when checking an enum variant or struct that\n+        // contains a different, structurally recursive type, maintain a stack\n+        // of seen types and check recursion for each of them (issues #3008, #3779).\n+        let mut seen: Vec<Ty> = Vec::new();\n+        let r = is_type_structurally_recursive(cx, sp, &mut seen, self);\n+        debug!(\"is_type_representable: {:?} is {:?}\", self, r);\n+        r\n+    }\n+}"}, {"sha": "81cad4486904b7e6e7ee946bbd2a2ebc53ca540a", "filename": "src/librustc/middle/ty/walk.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fwalk.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "previous_filename": "src/librustc/middle/ty_walk.rs"}, {"sha": "20534f72666db656f244e7282ce0e4000429efbd", "filename": "src/librustc/middle/ty/wf.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Fmiddle%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fwf.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -10,7 +10,7 @@\n \n use middle::def_id::DefId;\n use middle::infer::InferCtxt;\n-use middle::outlives::{self, Component};\n+use middle::ty::outlives::{self, Component};\n use middle::subst::Substs;\n use middle::traits;\n use middle::ty::{self, RegionEscape, ToPredicate, Ty};\n@@ -544,4 +544,3 @@ pub fn object_region_bounds<'tcx>(\n \n     tcx.required_region_bounds(open_ty, predicates)\n }\n-", "previous_filename": "src/librustc/middle/wf.rs"}, {"sha": "fee60d46dc0019b7436f4986015124092c2e74d8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 152, "deletions": 3, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -21,7 +21,7 @@ use middle::ty::{TyParam, TyRawPtr, TyRef, TyTuple};\n use middle::ty::TyClosure;\n use middle::ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n use middle::ty::{self, TypeAndMut, Ty, HasTypeFlags};\n-use middle::ty_fold::{self, TypeFoldable};\n+use middle::ty::fold::TypeFoldable;\n \n use std::fmt;\n use syntax::abi;\n@@ -219,7 +219,7 @@ fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n         }\n     };\n \n-    let new_value = ty_fold::replace_late_bound_regions(tcx, &value, |br| {\n+    let new_value = tcx.replace_late_bound_regions(&value, |br| {\n         let _ = start_or_continue(f, \"for<\", \", \");\n         ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n             ty::BrNamed(_, name) => {\n@@ -255,7 +255,7 @@ fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n \n impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n-    fn fold_with<F:ty_fold::TypeFolder<'tcx>>(&self, folder: &mut F)\n+    fn fold_with<F:ty::fold::TypeFolder<'tcx>>(&self, folder: &mut F)\n                                               -> TraitAndProjections<'tcx> {\n         TraitAndProjections(self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n@@ -388,6 +388,53 @@ impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n     }\n }\n \n+impl<'tcx> fmt::Debug for ty::adjustment::AutoAdjustment<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ty::adjustment::AdjustReifyFnPointer => {\n+                write!(f, \"AdjustReifyFnPointer\")\n+            }\n+            ty::adjustment::AdjustUnsafeFnPointer => {\n+                write!(f, \"AdjustUnsafeFnPointer\")\n+            }\n+            ty::adjustment::AdjustDerefRef(ref data) => {\n+                write!(f, \"{:?}\", data)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::adjustment::AutoDerefRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"AutoDerefRef({}, unsize={:?}, {:?})\",\n+               self.autoderefs, self.unsize, self.autoref)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::TraitTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TraitTy({:?},{:?})\",\n+               self.principal,\n+               self.bounds)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ty::Predicate::Trait(ref a) => write!(f, \"{:?}\", a),\n+            ty::Predicate::Equate(ref pair) => write!(f, \"{:?}\", pair),\n+            ty::Predicate::RegionOutlives(ref pair) => write!(f, \"{:?}\", pair),\n+            ty::Predicate::TypeOutlives(ref pair) => write!(f, \"{:?}\", pair),\n+            ty::Predicate::Projection(ref pair) => write!(f, \"{:?}\", pair),\n+            ty::Predicate::WellFormed(ty) => write!(f, \"WF({:?})\", ty),\n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+            }\n+        }\n+    }\n+}\n+\n impl fmt::Display for ty::BoundRegion {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n@@ -452,6 +499,45 @@ impl fmt::Debug for ty::Region {\n     }\n }\n \n+impl<'tcx> fmt::Debug for ty::ClosureTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ClosureTy({},{:?},{})\",\n+               self.unsafety,\n+               self.sig,\n+               self.abi)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ClosureUpvar({:?},{:?})\",\n+               self.def,\n+               self.ty)\n+    }\n+}\n+\n+impl<'a, 'tcx> fmt::Debug for ty::ParameterEnvironment<'a, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ParameterEnvironment(\\\n+            free_substs={:?}, \\\n+            implicit_region_bound={:?}, \\\n+            caller_bounds={:?})\",\n+            self.free_substs,\n+            self.implicit_region_bound,\n+            self.caller_bounds)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::ObjectLifetimeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ty::ObjectLifetimeDefault::Ambiguous => write!(f, \"Ambiguous\"),\n+            ty::ObjectLifetimeDefault::BaseDefault => write!(f, \"BaseDefault\"),\n+            ty::ObjectLifetimeDefault::Specific(ref r) => write!(f, \"{:?}\", r),\n+        }\n+    }\n+}\n+\n impl fmt::Display for ty::Region {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n@@ -486,6 +572,17 @@ impl fmt::Debug for ty::FreeRegion {\n     }\n }\n \n+impl fmt::Debug for ty::Variance {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(match *self {\n+            ty::Covariant => \"+\",\n+            ty::Contravariant => \"-\",\n+            ty::Invariant => \"o\",\n+            ty::Bivariant => \"*\",\n+        })\n+    }\n+}\n+\n impl fmt::Debug for ty::ItemVariances {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ItemVariances(types={:?}, regions={:?})\",\n@@ -570,6 +667,58 @@ impl fmt::Display for ty::BuiltinBounds {\n     }\n }\n \n+impl fmt::Debug for ty::TyVid {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"_#{}t\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::IntVid {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"_#{}i\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::FloatVid {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"_#{}f\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::RegionVid {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"'_#{}r\", self.index)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::FnSig<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs, self.variadic, self.output)\n+    }\n+}\n+\n+impl fmt::Debug for ty::InferTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ty::TyVar(ref v) => v.fmt(f),\n+            ty::IntVar(ref v) => v.fmt(f),\n+            ty::FloatVar(ref v) => v.fmt(f),\n+            ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n+            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::IntVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ty::IntType(ref v) => v.fmt(f),\n+            ty::UintType(ref v) => v.fmt(f),\n+        }\n+    }\n+}\n+\n // The generic impl doesn't work yet because projections are not\n // normalized under HRTB.\n /*impl<T> fmt::Display for ty::Binder<T>"}, {"sha": "96d9572b4859178854dde6ce2eefa11371385904", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -24,7 +24,7 @@ use rustc_typeck::middle::stability;\n use rustc_typeck::middle::subst;\n use rustc_typeck::middle::subst::Subst;\n use rustc_typeck::middle::ty::{self, Ty, RegionEscape};\n-use rustc_typeck::middle::ty_relate::TypeRelation;\n+use rustc_typeck::middle::ty::relate::TypeRelation;\n use rustc_typeck::middle::infer;\n use rustc_typeck::middle::infer::lub::Lub;\n use rustc_typeck::middle::infer::glb::Glb;"}, {"sha": "4084f13e818f226fe0b8d965f62f1340b7edefae", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -33,6 +33,7 @@ use middle::{cfg, def, infer, pat_util, stability, traits};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n+use middle::ty::adjustment;\n use middle::const_eval::{eval_const_expr_partial, ConstVal};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use rustc::front::map as hir_map;\n@@ -1722,13 +1723,15 @@ impl LintPass for UnusedAllocation {\n         }\n \n         if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n-            if let ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) = *adjustment {\n+            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n+                ref autoref, ..\n+            }) = *adjustment {\n                 match autoref {\n-                    &Some(ty::AutoPtr(_, hir::MutImmutable)) => {\n+                    &Some(adjustment::AutoPtr(_, hir::MutImmutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION, e.span,\n                                      \"unnecessary allocation, use & instead\");\n                     }\n-                    &Some(ty::AutoPtr(_, hir::MutMutable)) => {\n+                    &Some(adjustment::AutoPtr(_, hir::MutMutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION, e.span,\n                                      \"unnecessary allocation, use &mut instead\");\n                     }\n@@ -2297,7 +2300,7 @@ impl LintPass for UnconditionalRecursion {\n             }\n \n             // Check for overloaded autoderef method calls.\n-            if let Some(&ty::AdjustDerefRef(ref adj)) = tables.adjustments.get(&id) {\n+            if let Some(&adjustment::AdjustDerefRef(ref adj)) = tables.adjustments.get(&id) {\n                 for i in 0..adj.autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n                     if let Some(m) = tables.method_map.get(&method_call) {"}, {"sha": "f15470e7851d41b133e5470748154e94506888ab", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -320,7 +320,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n         // Now apply adjustments, if any.\n         match cx.tcx.tables.borrow().adjustments.get(&self.id) {\n             None => { }\n-            Some(&ty::AdjustReifyFnPointer) => {\n+            Some(&ty::adjustment::AdjustReifyFnPointer) => {\n                 let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n@@ -329,7 +329,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n                     kind: ExprKind::ReifyFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::AdjustUnsafeFnPointer) => {\n+            Some(&ty::adjustment::AdjustUnsafeFnPointer) => {\n                 let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n@@ -338,7 +338,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n                     kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::AdjustDerefRef(ref adj)) => {\n+            Some(&ty::adjustment::AdjustDerefRef(ref adj)) => {\n                 for i in 0..adj.autoderefs {\n                     let i = i as u32;\n                     let adjusted_ty =\n@@ -372,7 +372,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n                 } else if let Some(autoref) = adj.autoref {\n                     let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n                     match autoref {\n-                        ty::AutoPtr(r, m) => {\n+                        ty::adjustment::AutoPtr(r, m) => {\n                             expr = Expr {\n                                 temp_lifetime: temp_lifetime,\n                                 ty: adjusted_ty,\n@@ -382,7 +382,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n                                                          arg: expr.to_ref() }\n                             };\n                         }\n-                        ty::AutoUnsafe(m) => {\n+                        ty::adjustment::AutoUnsafe(m) => {\n                             // Convert this to a suitable `&foo` and\n                             // then an unsafe coercion. Limit the region to be just this\n                             // expression."}, {"sha": "044e96db04de5cd97bbc5b1ae158510ced41609c", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -38,8 +38,7 @@ use trans::type_::Type;\n use trans::type_of;\n use middle::traits;\n use middle::ty::{self, HasTypeFlags, Ty};\n-use middle::ty_fold;\n-use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::ty::fold::{TypeFolder, TypeFoldable};\n use rustc::front::map::{PathElem, PathName};\n use rustc_front::hir;\n use util::nodemap::{FnvHashMap, NodeMap};\n@@ -60,7 +59,7 @@ pub use trans::context::CrateContext;\n /// Returns an equivalent value with all free regions removed (note\n /// that late-bound regions remain, because they are important for\n /// subtyping, but they are anonymized and normalized as well). This\n-/// is a stronger, caching version of `ty_fold::erase_regions`.\n+/// is a stronger, caching version of `ty::fold::erase_regions`.\n pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n     where T : TypeFoldable<'tcx>\n {\n@@ -80,7 +79,7 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n                 Some(u) => return u\n             }\n \n-            let t_norm = ty_fold::super_fold_ty(self, ty);\n+            let t_norm = ty::fold::super_fold_ty(self, ty);\n             self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n             return t_norm;\n         }\n@@ -89,7 +88,7 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n             where T : TypeFoldable<'tcx>\n         {\n             let u = self.tcx().anonymize_late_bound_regions(t);\n-            ty_fold::super_fold_binder(self, &u)\n+            ty::fold::super_fold_binder(self, &u)\n         }\n \n         fn fold_region(&mut self, r: ty::Region) -> ty::Region {"}, {"sha": "a2d74635b5e1ce6f2a54ae350fde781565392256", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -33,9 +33,11 @@ use trans::declare;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n-use middle::cast::{CastTy,IntTy};\n use middle::subst::Substs;\n+use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n+use middle::ty::adjustment::AdjustUnsafeFnPointer;\n use middle::ty::{self, Ty};\n+use middle::ty::cast::{CastTy,IntTy};\n use util::nodemap::NodeMap;\n \n use rustc_front::hir;\n@@ -289,14 +291,14 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                             &cx.tcx().expr_ty_adjusted(e));\n     let opt_adj = cx.tcx().tables.borrow().adjustments.get(&e.id).cloned();\n     match opt_adj {\n-        Some(ty::AdjustReifyFnPointer) => {\n+        Some(AdjustReifyFnPointer) => {\n             // FIXME(#19925) once fn item types are\n             // zero-sized, we'll need to do something here\n         }\n-        Some(ty::AdjustUnsafeFnPointer) => {\n+        Some(AdjustUnsafeFnPointer) => {\n             // purely a type-level thing\n         }\n-        Some(ty::AdjustDerefRef(adj)) => {\n+        Some(AdjustDerefRef(adj)) => {\n             let mut ty = ety;\n             // Save the last autoderef in case we can avoid it.\n             if adj.autoderefs > 0 {"}, {"sha": "7d8996867c016ff4138ec8425502ad2d6f49aeab", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -71,10 +71,11 @@ use trans::machine;\n use trans::meth;\n use trans::tvec;\n use trans::type_of;\n-use middle::cast::{CastKind, CastTy};\n-use middle::ty::{AdjustDerefRef, AdjustReifyFnPointer, AdjustUnsafeFnPointer};\n+use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n+use middle::ty::adjustment::{AdjustUnsafeFnPointer, CustomCoerceUnsized};\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n+use middle::ty::cast::{CastKind, CastTy};\n use util::common::indenter;\n use trans::machine::{llsize_of, llsize_of_alloc};\n use trans::type_::Type;\n@@ -514,7 +515,7 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n \n             let coerce_index = match kind {\n-                ty::CustomCoerceUnsized::Struct(i) => i\n+                CustomCoerceUnsized::Struct(i) => i\n             };\n             assert!(coerce_index < src_fields.len() && src_fields.len() == target_fields.len());\n \n@@ -2045,8 +2046,8 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               id: ast::NodeId)\n                               -> DatumBlock<'blk, 'tcx, Expr>\n {\n-    use middle::cast::CastTy::*;\n-    use middle::cast::IntTy::*;\n+    use middle::ty::cast::CastTy::*;\n+    use middle::ty::cast::IntTy::*;\n \n     fn int_cast(bcx: Block,\n                 lldsttype: Type,"}, {"sha": "1ef9981a0a46a0b609603836a4217f6847810c11", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -17,7 +17,7 @@ use middle::infer;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n use middle::traits;\n-use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::ty::fold::{TypeFolder, TypeFoldable};\n use trans::attributes;\n use trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n use trans::base::trans_fn;"}, {"sha": "80994632c527da927706216096d4079a0f5129c8", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -53,13 +53,12 @@ use middle::const_eval::{self, ConstVal};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def;\n use middle::def_id::{DefId, LOCAL_CRATE};\n-use middle::wf::object_region_bounds;\n use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n use middle::traits;\n use middle::ty::{self, RegionEscape, Ty, ToPredicate, HasTypeFlags};\n-use middle::ty_fold;\n+use middle::ty::wf::object_region_bounds;\n use require_c_abi_if_variadic;\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope,\n@@ -535,9 +534,7 @@ fn find_implied_output_region<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     for (input_type, input_pat) in input_tys.iter().zip(input_pats) {\n         let mut regions = FnvHashSet();\n-        let have_bound_regions = ty_fold::collect_regions(tcx,\n-                                                          input_type,\n-                                                          &mut regions);\n+        let have_bound_regions = tcx.collect_regions(input_type, &mut regions);\n \n         debug!(\"find_implied_output_regions: collected {:?} from {:?} \\\n                 have_bound_regions={:?}\", &regions, input_type, have_bound_regions);\n@@ -2248,7 +2245,7 @@ impl<'tcx> Bounds<'tcx> {\n         for &region_bound in &self.region_bounds {\n             // account for the binder being introduced below; no need to shift `param_ty`\n             // because, at present at least, it can only refer to early-bound regions\n-            let region_bound = ty_fold::shift_region(region_bound, 1);\n+            let region_bound = ty::fold::shift_region(region_bound, 1);\n             vec.push(ty::Binder(ty::OutlivesPredicate(param_ty, region_bound)).to_predicate());\n         }\n "}, {"sha": "8dc95562e44afabc536ab9faa05c9ef2ea58a41f", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -12,7 +12,7 @@ use middle::infer::InferCtxt;\n use middle::traits::{self, FulfillmentContext, Normalized, MiscObligation,\n                      SelectionContext, ObligationCause};\n use middle::ty::HasTypeFlags;\n-use middle::ty_fold::TypeFoldable;\n+use middle::ty::fold::TypeFoldable;\n use syntax::ast;\n use syntax::codemap::Span;\n "}, {"sha": "98c8c0a319946ce04ded756353d81b43f05ded8b", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -44,9 +44,9 @@ use super::FnCtxt;\n use super::structurally_resolved_type;\n \n use lint;\n-use middle::cast::{CastKind, CastTy};\n use middle::def_id::DefId;\n use middle::ty::{self, Ty, HasTypeFlags};\n+use middle::ty::cast::{CastKind, CastTy};\n use syntax::codemap::Span;\n use rustc_front::hir;\n use rustc_front::hir::UintTy::TyU8;\n@@ -226,8 +226,8 @@ impl<'tcx> CastCheck<'tcx> {\n     /// can return Ok and create type errors in the fcx rather than returning\n     /// directly. coercion-cast is handled in check instead of here.\n     fn do_check<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> {\n-        use middle::cast::IntTy::*;\n-        use middle::cast::CastTy::*;\n+        use middle::ty::cast::IntTy::*;\n+        use middle::ty::cast::CastTy::*;\n \n         let (t_from, t_cast) = match (CastTy::from_ty(self.expr_ty),\n                                       CastTy::from_ty(self.cast_ty)) {"}, {"sha": "69efaa792fe053e7356d0ccddea67aeb8bcebdc0", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -65,9 +65,12 @@ use check::{autoderef, FnCtxt, UnresolvedTypeAction};\n use middle::infer::{self, Coercion};\n use middle::traits::{self, ObligationCause};\n use middle::traits::{predicate_for_trait_def, report_selection_error};\n-use middle::ty::{AutoDerefRef, AdjustDerefRef};\n-use middle::ty::{self, LvaluePreference, TypeAndMut, Ty, TypeError};\n-use middle::ty_relate::RelateResult;\n+use middle::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n+use middle::ty::adjustment::{AutoPtr, AutoUnsafe, AdjustReifyFnPointer};\n+use middle::ty::adjustment::{AdjustUnsafeFnPointer};\n+use middle::ty::{self, LvaluePreference, TypeAndMut, Ty};\n+use middle::ty::error::TypeError;\n+use middle::ty::relate::RelateResult;\n use util::common::indent;\n \n use std::cell::RefCell;\n@@ -80,7 +83,7 @@ struct Coerce<'a, 'tcx: 'a> {\n     unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n }\n \n-type CoerceResult<'tcx> = RelateResult<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n+type CoerceResult<'tcx> = RelateResult<'tcx, Option<AutoAdjustment<'tcx>>>;\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n@@ -185,7 +188,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let coercion = Coercion(self.origin.span());\n         let r_borrow = self.fcx.infcx().next_region_var(coercion);\n         let r_borrow = self.tcx().mk_region(r_borrow);\n-        let autoref = Some(ty::AutoPtr(r_borrow, mutbl_b));\n+        let autoref = Some(AutoPtr(r_borrow, mutbl_b));\n \n         let lvalue_pref = LvaluePreference::from_mutbl(mutbl_b);\n         let mut first_error = None;\n@@ -263,11 +266,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 let coercion = Coercion(self.origin.span());\n                 let r_borrow = self.fcx.infcx().next_region_var(coercion);\n                 let region = self.tcx().mk_region(r_borrow);\n-                (mt_a.ty, Some(ty::AutoPtr(region, mt_b.mutbl)))\n+                (mt_a.ty, Some(AutoPtr(region, mt_b.mutbl)))\n             }\n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n                 try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n-                (mt_a.ty, Some(ty::AutoUnsafe(mt_b.mutbl)))\n+                (mt_a.ty, Some(AutoUnsafe(mt_b.mutbl)))\n             }\n             _ => (source, None)\n         };\n@@ -359,7 +362,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                         let unsafe_a = self.tcx().safe_to_unsafe_fn_ty(fn_ty_a);\n                         try!(self.subtype(unsafe_a, b));\n-                        return Ok(Some(ty::AdjustUnsafeFnPointer));\n+                        return Ok(Some(AdjustUnsafeFnPointer));\n                     }\n                     _ => {}\n                 }\n@@ -386,7 +389,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 ty::TyBareFn(None, _) => {\n                     let a_fn_pointer = self.tcx().mk_fn(None, fn_ty_a);\n                     try!(self.subtype(a_fn_pointer, b));\n-                    Ok(Some(ty::AdjustReifyFnPointer))\n+                    Ok(Some(AdjustReifyFnPointer))\n                 }\n                 _ => self.subtype(a, b)\n             }\n@@ -421,7 +424,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         if is_ref {\n             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                 autoderefs: 1,\n-                autoref: Some(ty::AutoUnsafe(mutbl_b)),\n+                autoref: Some(AutoUnsafe(mutbl_b)),\n                 unsize: None\n             })))\n         } else {"}, {"sha": "fe822138c9b5be3eb958110350190b26affd44fe", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -32,7 +32,7 @@ pub fn suptype_with_fn<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                     ty_a: Ty<'tcx>,\n                                     ty_b: Ty<'tcx>,\n                                     handle_err: F) where\n-    F: FnOnce(Span, Ty<'tcx>, Ty<'tcx>, &ty::TypeError<'tcx>),\n+    F: FnOnce(Span, Ty<'tcx>, Ty<'tcx>, &ty::error::TypeError<'tcx>),\n {\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),"}, {"sha": "e7c7b5831d0fc97c20bf9c1fd3f681c7d25e80eb", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -17,7 +17,7 @@ use middle::def_id::DefId;\n use middle::subst;\n use middle::ty::FnSig;\n use middle::ty::{self, Ty};\n-use middle::ty_fold::TypeFolder;\n+use middle::ty::fold::TypeFolder;\n use {CrateCtxt, require_same_types};\n \n use std::collections::{HashMap};"}, {"sha": "572ba7a84871354ea543d78db2de580dfa62dc5b", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -16,7 +16,8 @@ use middle::def_id::DefId;\n use middle::subst::{self};\n use middle::traits;\n use middle::ty::{self, NoPreference, PreferMutLvalue, Ty};\n-use middle::ty_fold::TypeFoldable;\n+use middle::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n+use middle::ty::fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n use syntax::codemap::Span;\n@@ -136,7 +137,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     {\n         let (autoref, unsize) = if let Some(mutbl) = pick.autoref {\n             let region = self.infcx().next_region_var(infer::Autoref(self.span));\n-            let autoref = ty::AutoPtr(self.tcx().mk_region(region), mutbl);\n+            let autoref = AutoPtr(self.tcx().mk_region(region), mutbl);\n             (Some(autoref), pick.unsize.map(|target| {\n                 target.adjust_for_autoref(self.tcx(), Some(autoref))\n             }))\n@@ -169,7 +170,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Write out the final adjustment.\n         self.fcx.write_adjustment(self.self_expr.id,\n-                                  ty::AdjustDerefRef(ty::AutoDerefRef {\n+                                  AdjustDerefRef(AutoDerefRef {\n             autoderefs: pick.autoderefs,\n             autoref: autoref,\n             unsize: unsize\n@@ -488,7 +489,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                             .borrow()\n                                             .adjustments\n                                             .get(&expr.id) {\n-                Some(&ty::AdjustDerefRef(ref adj)) => adj.autoderefs,\n+                Some(&AdjustDerefRef(ref adj)) => adj.autoderefs,\n                 Some(_) | None => 0,\n             };\n \n@@ -527,12 +528,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         let adj = self.fcx.inh.tables.borrow().adjustments.get(&base_expr.id)\n                                                                           .cloned();\n                         let (autoderefs, unsize) = match adj {\n-                            Some(ty::AdjustDerefRef(adr)) => match adr.autoref {\n+                            Some(AdjustDerefRef(adr)) => match adr.autoref {\n                                 None => {\n                                     assert!(adr.unsize.is_none());\n                                     (adr.autoderefs, None)\n                                 }\n-                                Some(ty::AutoPtr(_, _)) => {\n+                                Some(AutoPtr(_, _)) => {\n                                     (adr.autoderefs, adr.unsize.map(|target| {\n                                         target.builtin_deref(false, NoPreference)\n                                               .expect(\"fixup: AutoPtr is not &T\").ty\n@@ -557,7 +558,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                             (target, true)\n                         } else {\n                             (self.fcx.adjust_expr_ty(base_expr,\n-                                Some(&ty::AdjustDerefRef(ty::AutoDerefRef {\n+                                Some(&AdjustDerefRef(AutoDerefRef {\n                                     autoderefs: autoderefs,\n                                     autoref: None,\n                                     unsize: None"}, {"sha": "1cfb495b36ed75a9e6dfb1b2c5384728e870e8e7", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -18,6 +18,7 @@ use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n use middle::traits;\n use middle::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef};\n+use middle::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use middle::infer;\n \n use syntax::ast;\n@@ -282,9 +283,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     match transformed_self_ty.sty {\n                         ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ }) => {\n                             fcx.write_adjustment(self_expr.id,\n-                                ty::AdjustDerefRef(ty::AutoDerefRef {\n+                                AdjustDerefRef(AutoDerefRef {\n                                     autoderefs: autoderefs,\n-                                    autoref: Some(ty::AutoPtr(region, mutbl)),\n+                                    autoref: Some(AutoPtr(region, mutbl)),\n                                     unsize: if unsize {\n                                         Some(transformed_self_ty)\n                                     } else {"}, {"sha": "f65602d9aaccb0d9e9d1a348fd709cf79f9e32a3", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -16,13 +16,12 @@ use super::suggest;\n use check;\n use check::{FnCtxt, UnresolvedTypeAction};\n use middle::def_id::DefId;\n-use middle::fast_reject;\n use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n use middle::ty::{self, NoPreference, RegionEscape, Ty, ToPolyTraitRef, TraitRef};\n use middle::ty::HasTypeFlags;\n-use middle::ty_fold::TypeFoldable;\n+use middle::ty::fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n use syntax::ast;\n@@ -41,7 +40,7 @@ struct ProbeContext<'a, 'tcx:'a> {\n     mode: Mode,\n     item_name: ast::Name,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n-    opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>,\n+    opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: HashSet<DefId>,\n@@ -163,7 +162,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Create a list of simplified self types, if we can.\n     let mut simplified_steps = Vec::new();\n     for step in &steps {\n-        match fast_reject::simplify_type(fcx.tcx(), step.self_ty, true) {\n+        match ty::fast_reject::simplify_type(fcx.tcx(), step.self_ty, true) {\n             None => { break; }\n             Some(simplified_type) => { simplified_steps.push(simplified_type); }\n         }\n@@ -236,7 +235,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n            mode: Mode,\n            item_name: ast::Name,\n            steps: Vec<CandidateStep<'tcx>>,\n-           opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>)\n+           opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>)\n            -> ProbeContext<'a,'tcx>\n     {\n         ProbeContext {\n@@ -684,7 +683,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         let impl_type = self.tcx().lookup_item_type(impl_def_id);\n         let impl_simplified_type =\n-            match fast_reject::simplify_type(self.tcx(), impl_type.ty, false) {\n+            match ty::fast_reject::simplify_type(self.tcx(), impl_type.ty, false) {\n                 Some(simplified_type) => simplified_type,\n                 None => { return true; }\n             };"}, {"sha": "9dd7cfea43f6901869aada381e36fa79a1d28087", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -97,7 +97,10 @@ use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use middle::ty::{self, HasTypeFlags, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty::{MethodCall, MethodCallee};\n-use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::ty::adjustment;\n+use middle::ty::error::TypeError;\n+use middle::ty::fold::{TypeFolder, TypeFoldable};\n+use middle::ty::util::Representability;\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n use session::Session;\n@@ -1336,7 +1339,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                       derefs: usize) {\n         self.write_adjustment(\n             node_id,\n-            ty::AdjustDerefRef(ty::AutoDerefRef {\n+            adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n                 autoderefs: derefs,\n                 autoref: None,\n                 unsize: None\n@@ -1346,7 +1349,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n-                            adj: ty::AutoAdjustment<'tcx>) {\n+                            adj: adjustment::AutoAdjustment<'tcx>) {\n         debug!(\"write_adjustment(node_id={}, adj={:?})\", node_id, adj);\n \n         if adj.is_identity() {\n@@ -1575,7 +1578,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Apply `adjustment` to the type of `expr`\n     pub fn adjust_expr_ty(&self,\n                           expr: &hir::Expr,\n-                          adjustment: Option<&ty::AutoAdjustment<'tcx>>)\n+                          adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n                           -> Ty<'tcx>\n     {\n         let raw_ty = self.expr_ty(expr);\n@@ -1627,7 +1630,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     origin: infer::TypeOrigin,\n                     sub: Ty<'tcx>,\n                     sup: Ty<'tcx>)\n-                    -> Result<(), ty::TypeError<'tcx>> {\n+                    -> Result<(), TypeError<'tcx>> {\n         infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n@@ -1636,7 +1639,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                    origin: infer::TypeOrigin,\n                    sub: Ty<'tcx>,\n                    sup: Ty<'tcx>)\n-                   -> Result<(), ty::TypeError<'tcx>> {\n+                   -> Result<(), TypeError<'tcx>> {\n         infer::mk_eqty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n@@ -1651,7 +1654,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                  sp: Span,\n                                  mk_msg: M,\n                                  actual_ty: Ty<'tcx>,\n-                                 err: Option<&ty::TypeError<'tcx>>) where\n+                                 err: Option<&TypeError<'tcx>>) where\n         M: FnOnce(String) -> String,\n     {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n@@ -1661,7 +1664,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                    sp: Span,\n                                    e: Ty<'tcx>,\n                                    a: Ty<'tcx>,\n-                                   err: &ty::TypeError<'tcx>) {\n+                                   err: &TypeError<'tcx>) {\n         self.infcx().report_mismatched_types(sp, e, a, err)\n     }\n \n@@ -1766,7 +1769,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Apply \"fallbacks\" to some types\n     /// ! gets replaced with (), unconstrained ints with i32, and unconstrained floats with f64.\n     fn default_type_parameters(&self) {\n-        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n+        use middle::ty::error::UnconstrainedNumeric::Neither;\n+        use middle::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n         for ty in &self.infcx().unsolved_variables() {\n             let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n             if self.infcx().type_var_diverges(resolved) {\n@@ -1801,9 +1805,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn new_select_all_obligations_and_apply_defaults(&self) {\n-        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n+        use middle::ty::error::UnconstrainedNumeric::Neither;\n+        use middle::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n \n-            // For the time being this errs on the side of being memory wasteful but provides better\n+        // For the time being this errs on the side of being memory wasteful but provides better\n         // error reporting.\n         // let type_variables = self.infcx().type_variables.clone();\n \n@@ -1973,7 +1978,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 default_map: &FnvHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n                                 conflict: Ty<'tcx>)\n                                 -> Option<type_variable::Default<'tcx>> {\n-        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n+        use middle::ty::error::UnconstrainedNumeric::Neither;\n+        use middle::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n \n         // Ensure that we apply the conflicting default first\n         let mut unbound_tyvars = Vec::with_capacity(unbound_vars.len() + 1);\n@@ -4166,12 +4172,13 @@ pub fn check_representable(tcx: &ty::ctxt,\n     // contain themselves. For case 2, there must be an inner type that will be\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n-      ty::SelfRecursive => {\n-        span_err!(tcx.sess, sp, E0072, \"invalid recursive {} type\", designation);\n-        tcx.sess.fileline_help(sp, \"wrap the inner value in a box to make it representable\");\n-        return false\n-      }\n-      ty::Representable | ty::ContainsRecursive => (),\n+        Representability::SelfRecursive => {\n+            span_err!(tcx.sess, sp, E0072, \"invalid recursive {} type\", designation);\n+            tcx.sess.fileline_help(\n+                sp, \"wrap the inner value in a box to make it representable\");\n+            return false\n+        }\n+        Representability::Representable | Representability::ContainsRecursive => (),\n     }\n     return true\n }"}, {"sha": "155caaa8cb0fe2a7f4f1fac3b1d6bb3bde5540a2", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -88,14 +88,14 @@ use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n use middle::implicator::{self, Implication};\n use middle::mem_categorization as mc;\n-use middle::outlives;\n use middle::region::CodeExtent;\n use middle::subst::Substs;\n use middle::traits;\n use middle::ty::{self, RegionEscape, ReScope, Ty, MethodCall, HasTypeFlags};\n use middle::infer::{self, GenericKind, InferCtxt, SubregionOrigin, VerifyBound};\n use middle::pat_util;\n-use middle::wf::{self, ImpliedBound};\n+use middle::ty::adjustment;\n+use middle::ty::wf::ImpliedBound;\n \n use std::mem;\n use std::rc::Rc;\n@@ -420,7 +420,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n             debug!(\"relate_free_regions(t={:?})\", ty);\n-            let implied_bounds = wf::implied_bounds(self.fcx.infcx(), body_id, ty, span);\n+            let implied_bounds = ty::wf::implied_bounds(self.fcx.infcx(), body_id, ty, span);\n \n             // Record any relations between free regions that we observe into the free-region-map.\n             self.free_region_map.relate_free_regions_from_implied_bounds(&implied_bounds);\n@@ -599,7 +599,9 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n     if let Some(adjustment) = adjustment {\n         debug!(\"adjustment={:?}\", adjustment);\n         match adjustment {\n-            ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, ref autoref, ..}) => {\n+            adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n+                autoderefs, ref autoref, ..\n+            }) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n                 if let Some(ref autoref) = *autoref {\n@@ -615,7 +617,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n                 }\n             }\n             /*\n-            ty::AutoObject(_, ref bounds, _, _) => {\n+            adjustment::AutoObject(_, ref bounds, _, _) => {\n                 // Determine if we are casting `expr` to a trait\n                 // instance. If so, we have to be sure that the type\n                 // of the source obeys the new region bound.\n@@ -1222,20 +1224,20 @@ fn link_pattern<'t, 'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n fn link_autoref(rcx: &Rcx,\n                 expr: &hir::Expr,\n                 autoderefs: usize,\n-                autoref: &ty::AutoRef)\n+                autoref: &adjustment::AutoRef)\n {\n     debug!(\"link_autoref(autoref={:?})\", autoref);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={:?}\", expr_cmt);\n \n     match *autoref {\n-        ty::AutoPtr(r, m) => {\n+        adjustment::AutoPtr(r, m) => {\n             link_region(rcx, expr.span, r,\n                 ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n \n-        ty::AutoUnsafe(m) => {\n+        adjustment::AutoUnsafe(m) => {\n             let r = ty::ReScope(rcx.tcx().region_maps.node_extent(expr.id));\n             link_region(rcx, expr.span, &r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n@@ -1527,39 +1529,39 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n     assert!(!ty.has_escaping_regions());\n \n-    let components = outlives::components(rcx.infcx(), ty);\n+    let components = ty::outlives::components(rcx.infcx(), ty);\n     components_must_outlive(rcx, origin, components, region);\n }\n \n fn components_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                      origin: infer::SubregionOrigin<'tcx>,\n-                                     components: Vec<outlives::Component<'tcx>>,\n+                                     components: Vec<ty::outlives::Component<'tcx>>,\n                                      region: ty::Region)\n {\n     for component in components {\n         let origin = origin.clone();\n         match component {\n-            outlives::Component::Region(region1) => {\n+            ty::outlives::Component::Region(region1) => {\n                 rcx.fcx.mk_subr(origin, region, region1);\n             }\n-            outlives::Component::Param(param_ty) => {\n+            ty::outlives::Component::Param(param_ty) => {\n                 param_ty_must_outlive(rcx, origin, region, param_ty);\n             }\n-            outlives::Component::Projection(projection_ty) => {\n+            ty::outlives::Component::Projection(projection_ty) => {\n                 projection_must_outlive(rcx, origin, region, projection_ty);\n             }\n-            outlives::Component::EscapingProjection(subcomponents) => {\n+            ty::outlives::Component::EscapingProjection(subcomponents) => {\n                 components_must_outlive(rcx, origin, subcomponents, region);\n             }\n-            outlives::Component::UnresolvedInferenceVariable(v) => {\n+            ty::outlives::Component::UnresolvedInferenceVariable(v) => {\n                 // ignore this, we presume it will yield an error\n                 // later, since if a type variable is not resolved by\n                 // this point it never will be\n                 rcx.tcx().sess.delay_span_bug(\n                     origin.span(),\n                     &format!(\"unresolved inference variable in outlives: {:?}\", v));\n             }\n-            outlives::Component::RFC1214(subcomponents) => {\n+            ty::outlives::Component::RFC1214(subcomponents) => {\n                 let suborigin = infer::RFC1214Subregion(Rc::new(origin));\n                 components_must_outlive(rcx, suborigin, subcomponents, region);\n             }"}, {"sha": "2c931e7830d59ba04b9f1eb28899acda39865738", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -17,7 +17,7 @@ use middle::region;\n use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n use middle::ty::{self, Ty};\n-use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n+use middle::ty::fold::{TypeFolder, TypeFoldable, super_fold_ty};\n \n use std::cell::RefCell;\n use std::collections::HashSet;"}, {"sha": "06dd80c57ada8132094e6880f044dd65c3c43d19", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -16,8 +16,7 @@ use middle::def_id::DefId;\n use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n use middle::ty::{self, Ty};\n-use middle::ty_fold::{TypeFolder};\n-use middle::wf;\n+use middle::ty::fold::{TypeFolder};\n \n use std::cell::RefCell;\n use std::collections::HashSet;\n@@ -309,11 +308,11 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                         fcx.instantiate_type_scheme(\n                             ast_trait_ref.path.span, free_substs, &trait_ref);\n                     let obligations =\n-                        wf::trait_obligations(fcx.infcx(),\n-                                              fcx.body_id,\n-                                              &trait_ref,\n-                                              ast_trait_ref.path.span,\n-                                              true);\n+                        ty::wf::trait_obligations(fcx.infcx(),\n+                                                  fcx.body_id,\n+                                                  &trait_ref,\n+                                                  ast_trait_ref.path.span,\n+                                                  true);\n                     for obligation in obligations {\n                         fcx.register_predicate(obligation);\n                     }\n@@ -341,11 +340,11 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let obligations =\n             predicates.predicates\n                       .iter()\n-                      .flat_map(|p| wf::predicate_obligations(fcx.infcx(),\n-                                                              fcx.body_id,\n-                                                              p,\n-                                                              span,\n-                                                              true));\n+                      .flat_map(|p| ty::wf::predicate_obligations(fcx.infcx(),\n+                                                                  fcx.body_id,\n+                                                                  p,\n+                                                                  span,\n+                                                                  true));\n \n         for obligation in obligations {\n             fcx.register_predicate(obligation);"}, {"sha": "6f8e064c9d8195c3e98c83affec70b55b00a031c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -18,7 +18,8 @@ use check::FnCtxt;\n use middle::def_id::DefId;\n use middle::pat_util;\n use middle::ty::{self, Ty, MethodCall, MethodCallee};\n-use middle::ty_fold::{TypeFolder,TypeFoldable};\n+use middle::ty::adjustment;\n+use middle::ty::fold::{TypeFolder,TypeFoldable};\n use middle::infer;\n use write_substs_to_tcx;\n use write_ty_to_tcx;\n@@ -268,19 +269,21 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n             Some(adjustment) => {\n                 let resolved_adjustment = match adjustment {\n-                    ty::AdjustReifyFnPointer => ty::AdjustReifyFnPointer,\n+                    adjustment::AdjustReifyFnPointer => {\n+                        adjustment::AdjustReifyFnPointer\n+                    }\n \n-                    ty::AdjustUnsafeFnPointer => {\n-                        ty::AdjustUnsafeFnPointer\n+                    adjustment::AdjustUnsafeFnPointer => {\n+                        adjustment::AdjustUnsafeFnPointer\n                     }\n \n-                    ty::AdjustDerefRef(adj) => {\n+                    adjustment::AdjustDerefRef(adj) => {\n                         for autoderef in 0..adj.autoderefs {\n                             let method_call = MethodCall::autoderef(id, autoderef as u32);\n                             self.visit_method_map_entry(reason, method_call);\n                         }\n \n-                        ty::AdjustDerefRef(ty::AutoDerefRef {\n+                        adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n                             autoderefs: adj.autoderefs,\n                             autoref: self.resolve(&adj.autoref, reason),\n                             unsize: self.resolve(&adj.unsize, reason),"}, {"sha": "9ba6f1398e47118fb84c708cbe83c80fcf12fde9", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -20,6 +20,7 @@ use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::UnsizeTraitLangItem;\n use middle::subst::{self, Subst};\n use middle::traits;\n+use middle::ty;\n use middle::ty::RegionEscape;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, ConstTraitItemId};\n use middle::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n@@ -29,7 +30,7 @@ use middle::ty::{TyRef, TyStruct, TyTrait, TyTuple};\n use middle::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use middle::ty::{TyUint, TyClosure, TyBox, TyBareFn};\n use middle::ty::TyProjection;\n-use middle::ty;\n+use middle::ty::util::CopyImplementationError;\n use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n use middle::infer::{self, InferCtxt, new_infer_ctxt};\n@@ -370,27 +371,27 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n             match param_env.can_type_implement_copy(self_type, span) {\n                 Ok(()) => {}\n-                Err(ty::FieldDoesNotImplementCopy(name)) => {\n+                Err(CopyImplementationError::InfrigingField(name)) => {\n                        span_err!(tcx.sess, span, E0204,\n                                  \"the trait `Copy` may not be \\\n                                           implemented for this type; field \\\n                                           `{}` does not implement `Copy`\",\n                                          name)\n                 }\n-                Err(ty::VariantDoesNotImplementCopy(name)) => {\n+                Err(CopyImplementationError::InfrigingVariant(name)) => {\n                        span_err!(tcx.sess, span, E0205,\n                                  \"the trait `Copy` may not be \\\n                                           implemented for this type; variant \\\n                                           `{}` does not implement `Copy`\",\n                                          name)\n                 }\n-                Err(ty::TypeIsStructural) => {\n+                Err(CopyImplementationError::NotAnAdt) => {\n                        span_err!(tcx.sess, span, E0206,\n                                  \"the trait `Copy` may not be implemented \\\n                                   for this type; type is not a structure or \\\n                                   enumeration\")\n                 }\n-                Err(ty::TypeHasDestructor) => {\n+                Err(CopyImplementationError::HasDestructor) => {\n                     span_err!(tcx.sess, span, E0184,\n                               \"the trait `Copy` may not be implemented for this type; \\\n                                the type has a destructor\");\n@@ -446,7 +447,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n                 if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n                     infcx.report_mismatched_types(span, mk_ptr(mt_b.ty),\n-                                                  target, &ty::TypeError::Mutability);\n+                                                  target, &ty::error::TypeError::Mutability);\n                 }\n                 (mt_a.ty, mt_b.ty, unsize_trait, None)\n             };\n@@ -510,7 +511,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n \n                     let (i, a, b) = diff_fields[0];\n-                    let kind = ty::CustomCoerceUnsized::Struct(i);\n+                    let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n                     (a, b, coerce_unsized_trait, Some(kind))\n                 }\n "}, {"sha": "f7520ed54b77e3f153d8782fb9c1c29ccf29a190", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -76,9 +76,10 @@ use middle::const_eval::{self, ConstVal};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n use middle::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty, TypeScheme, IntTypeExt};\n+use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty, TypeScheme};\n use middle::ty::{VariantKind};\n-use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n+use middle::ty::fold::{TypeFolder, TypeFoldable};\n+use middle::ty::util::IntTypeExt;\n use middle::infer;\n use rscope::*;\n use rustc::front::map as hir_map;\n@@ -2374,7 +2375,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n          * before we really have a `ParameterEnvironment` to check.\n          */\n \n-        ty_fold::fold_regions(tcx, value, &mut false, |region, _| {\n+        tcx.fold_regions(value, &mut false, |region, _| {\n             match region {\n                 ty::ReEarlyBound(data) => {\n                     let def_id = DefId::local(data.param_id);"}, {"sha": "1b02c736dce3b6e3a0e932afd947bee65784bb41", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c96168821d70992157f55ee9f06190bf299ba4/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=b1c96168821d70992157f55ee9f06190bf299ba4", "patch": "@@ -10,7 +10,6 @@\n \n \n use middle::ty;\n-use middle::ty_fold;\n \n use std::cell::Cell;\n use syntax::codemap::Span;\n@@ -239,11 +238,11 @@ impl<'r> ShiftedRscope<'r> {\n impl<'r> RegionScope for ShiftedRscope<'r> {\n     fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n         self.base_scope.object_lifetime_default(span)\n-            .map(|r| ty_fold::shift_region(r, 1))\n+            .map(|r| ty::fold::shift_region(r, 1))\n     }\n \n     fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        ty_fold::shift_region(self.base_scope.base_object_lifetime_default(span), 1)\n+        ty::fold::shift_region(self.base_scope.base_object_lifetime_default(span), 1)\n     }\n \n     fn anon_regions(&self,\n@@ -254,7 +253,7 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n         match self.base_scope.anon_regions(span, count) {\n             Ok(mut v) => {\n                 for r in &mut v {\n-                    *r = ty_fold::shift_region(*r, 1);\n+                    *r = ty::fold::shift_region(*r, 1);\n                 }\n                 Ok(v)\n             }"}]}