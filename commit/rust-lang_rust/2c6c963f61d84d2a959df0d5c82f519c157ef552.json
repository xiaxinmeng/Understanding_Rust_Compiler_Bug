{"sha": "2c6c963f61d84d2a959df0d5c82f519c157ef552", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNmM5NjNmNjFkODRkMmE5NTlkZjBkNWM4MmY1MTljMTU3ZWY1NTI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-12T02:37:29Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-12T02:41:07Z"}, "message": "Convert core::extfmt to camel case", "tree": {"sha": "39e1e9cd24b8db28302db9a0018192b097b77b75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39e1e9cd24b8db28302db9a0018192b097b77b75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c6c963f61d84d2a959df0d5c82f519c157ef552", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c6c963f61d84d2a959df0d5c82f519c157ef552", "html_url": "https://github.com/rust-lang/rust/commit/2c6c963f61d84d2a959df0d5c82f519c157ef552", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c6c963f61d84d2a959df0d5c82f519c157ef552/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec225166cd73398052dcf4a2135cd1110856f4d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec225166cd73398052dcf4a2135cd1110856f4d1", "html_url": "https://github.com/rust-lang/rust/commit/ec225166cd73398052dcf4a2135cd1110856f4d1"}], "stats": {"total": 489, "additions": 341, "deletions": 148}, "files": [{"sha": "e7b1ec517ec432da9ddc2bd2f42216eee50cf9a6", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 266, "deletions": 73, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/2c6c963f61d84d2a959df0d5c82f519c157ef552/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6c963f61d84d2a959df0d5c82f519c157ef552/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=2c6c963f61d84d2a959df0d5c82f519c157ef552", "patch": "@@ -1,5 +1,4 @@\n #[doc(hidden)];\n-#[allow(non_camel_case_types)];\n \n /*\n Syntax Extension: fmt\n@@ -43,53 +42,53 @@ use option::{Some, None};\n \n // Functions used by the fmt extension at compile time\n mod ct {\n-    enum signedness { signed, unsigned, }\n-    enum caseness { case_upper, case_lower, }\n-    enum ty {\n-        ty_bool,\n-        ty_str,\n-        ty_char,\n-        ty_int(signedness),\n-        ty_bits,\n-        ty_hex(caseness),\n-        ty_octal,\n-        ty_float,\n-        ty_poly,\n-    }\n-    enum flag {\n-        flag_left_justify,\n-        flag_left_zero_pad,\n-        flag_space_for_sign,\n-        flag_sign_always,\n-        flag_alternate,\n-    }\n-    enum count {\n-        count_is(int),\n-        count_is_param(int),\n-        count_is_next_param,\n-        count_implied,\n+    enum Signedness { Signed, Unsigned, }\n+    enum Caseness { CaseUpper, CaseLower, }\n+    enum Ty {\n+        TyBool,\n+        TyStr,\n+        TyChar,\n+        TyInt(Signedness),\n+        TyBits,\n+        TyHex(Caseness),\n+        TyOctal,\n+        TyFloat,\n+        TyPoly,\n+    }\n+    enum Flag {\n+        FlagLeftJustify,\n+        FlagLeftZeroPad,\n+        FlagSpaceForSign,\n+        FlagSignAlways,\n+        FlagAlternate,\n+    }\n+    enum Count {\n+        CountIs(int),\n+        CountIsParam(int),\n+        CountIsNextParam,\n+        CountImplied,\n     }\n \n     // A formatted conversion from an expression to a string\n-    type conv =\n+    type Conv =\n         {param: Option<int>,\n-         flags: ~[flag],\n-         width: count,\n-         precision: count,\n-         ty: ty};\n+         flags: ~[Flag],\n+         width: Count,\n+         precision: Count,\n+         ty: Ty};\n \n \n     // A fragment of the output sequence\n-    enum piece { piece_string(~str), piece_conv(conv), }\n-    type error_fn = fn@(~str) -> ! ;\n+    enum Piece { PieceString(~str), PieceConv(Conv), }\n+    type ErrorFn = fn@(~str) -> ! ;\n \n-    fn parse_fmt_string(s: ~str, error: error_fn) -> ~[piece] {\n-        let mut pieces: ~[piece] = ~[];\n+    fn parse_fmt_string(s: ~str, error: ErrorFn) -> ~[Piece] {\n+        let mut pieces: ~[Piece] = ~[];\n         let lim = str::len(s);\n         let mut buf = ~\"\";\n-        fn flush_buf(+buf: ~str, &pieces: ~[piece]) -> ~str {\n+        fn flush_buf(+buf: ~str, &pieces: ~[Piece]) -> ~str {\n             if str::len(buf) > 0 {\n-                let piece = piece_string(move buf);\n+                let piece = PieceString(move buf);\n                 vec::push(pieces, move piece);\n             }\n             return ~\"\";\n@@ -140,15 +139,15 @@ mod ct {\n             None\n         }\n     }\n-    fn parse_conversion(s: ~str, i: uint, lim: uint, error: error_fn) ->\n-       {piece: piece, next: uint} {\n+    fn parse_conversion(s: ~str, i: uint, lim: uint, error: ErrorFn) ->\n+       {piece: Piece, next: uint} {\n         let parm = parse_parameter(s, i, lim);\n         let flags = parse_flags(s, parm.next, lim);\n         let width = parse_count(s, flags.next, lim);\n         let prec = parse_precision(s, width.next, lim);\n         let ty = parse_type(s, prec.next, lim, error);\n         return {piece:\n-                 piece_conv({param: parm.param,\n+                 PieceConv({param: parm.param,\n                              flags: copy flags.flags,\n                              width: width.count,\n                              precision: prec.count,\n@@ -171,99 +170,99 @@ mod ct {\n             };\n     }\n     fn parse_flags(s: ~str, i: uint, lim: uint) ->\n-       {flags: ~[flag], next: uint} {\n-        let noflags: ~[flag] = ~[];\n+       {flags: ~[Flag], next: uint} {\n+        let noflags: ~[Flag] = ~[];\n         if i >= lim { return {flags: move noflags, next: i}; }\n \n-        fn more_(f: flag, s: ~str, i: uint, lim: uint) ->\n-           {flags: ~[flag], next: uint} {\n+        fn more_(f: Flag, s: ~str, i: uint, lim: uint) ->\n+           {flags: ~[Flag], next: uint} {\n             let next = parse_flags(s, i + 1u, lim);\n             let rest = copy next.flags;\n             let j = next.next;\n-            let curr: ~[flag] = ~[f];\n+            let curr: ~[Flag] = ~[f];\n             return {flags: vec::append(move curr, rest), next: j};\n         }\n         let more = |x, copy s| more_(x, copy s, i, lim);\n         let f = s[i];\n         return if f == '-' as u8 {\n-                more(flag_left_justify)\n+                more(FlagLeftJustify)\n             } else if f == '0' as u8 {\n-                more(flag_left_zero_pad)\n+                more(FlagLeftZeroPad)\n             } else if f == ' ' as u8 {\n-                more(flag_space_for_sign)\n+                more(FlagSpaceForSign)\n             } else if f == '+' as u8 {\n-                more(flag_sign_always)\n+                more(FlagSignAlways)\n             } else if f == '#' as u8 {\n-                more(flag_alternate)\n+                more(FlagAlternate)\n             } else { {flags: move noflags, next: i} };\n     }\n     fn parse_count(s: ~str, i: uint, lim: uint)\n-        -> {count: count, next: uint} {\n+        -> {count: Count, next: uint} {\n         return if i >= lim {\n-                {count: count_implied, next: i}\n+                {count: CountImplied, next: i}\n             } else if s[i] == '*' as u8 {\n                 let param = parse_parameter(s, i + 1u, lim);\n                 let j = param.next;\n                 match param.param {\n-                  None => {count: count_is_next_param, next: j},\n-                  Some(n) => {count: count_is_param(n), next: j}\n+                  None => {count: CountIsNextParam, next: j},\n+                  Some(n) => {count: CountIsParam(n), next: j}\n                 }\n             } else {\n                 let num = peek_num(s, i, lim);\n                 match num {\n-                  None => {count: count_implied, next: i},\n+                  None => {count: CountImplied, next: i},\n                   Some(num) => {\n-                    count: count_is(num.num as int),\n+                    count: CountIs(num.num as int),\n                     next: num.next\n                   }\n                 }\n             };\n     }\n     fn parse_precision(s: ~str, i: uint, lim: uint) ->\n-       {count: count, next: uint} {\n+       {count: Count, next: uint} {\n         return if i >= lim {\n-                {count: count_implied, next: i}\n+                {count: CountImplied, next: i}\n             } else if s[i] == '.' as u8 {\n                 let count = parse_count(s, i + 1u, lim);\n \n \n                 // If there were no digits specified, i.e. the precision\n                 // was \".\", then the precision is 0\n                 match count.count {\n-                  count_implied => {count: count_is(0), next: count.next},\n+                  CountImplied => {count: CountIs(0), next: count.next},\n                   _ => count\n                 }\n-            } else { {count: count_implied, next: i} };\n+            } else { {count: CountImplied, next: i} };\n     }\n-    fn parse_type(s: ~str, i: uint, lim: uint, error: error_fn) ->\n-       {ty: ty, next: uint} {\n+    fn parse_type(s: ~str, i: uint, lim: uint, error: ErrorFn) ->\n+       {ty: Ty, next: uint} {\n         if i >= lim { error(~\"missing type in conversion\"); }\n         let tstr = str::slice(s, i, i+1u);\n         // FIXME (#2249): Do we really want two signed types here?\n         // How important is it to be printf compatible?\n         let t =\n             if tstr == ~\"b\" {\n-                ty_bool\n+                TyBool\n             } else if tstr == ~\"s\" {\n-                ty_str\n+                TyStr\n             } else if tstr == ~\"c\" {\n-                ty_char\n+                TyChar\n             } else if tstr == ~\"d\" || tstr == ~\"i\" {\n-                ty_int(signed)\n+                TyInt(Signed)\n             } else if tstr == ~\"u\" {\n-                ty_int(unsigned)\n+                TyInt(Unsigned)\n             } else if tstr == ~\"x\" {\n-                ty_hex(case_lower)\n+                TyHex(CaseLower)\n             } else if tstr == ~\"X\" {\n-                ty_hex(case_upper)\n+                TyHex(CaseUpper)\n             } else if tstr == ~\"t\" {\n-                ty_bits\n+                TyBits\n             } else if tstr == ~\"o\" {\n-                ty_octal\n+                TyOctal\n             } else if tstr == ~\"f\" {\n-                ty_float\n+                TyFloat\n             } else if tstr == ~\"?\" {\n-                ty_poly\n+                TyPoly\n             } else { error(~\"unknown type in conversion: \" + tstr) };\n         return {ty: t, next: i + 1u};\n     }\n@@ -274,6 +273,199 @@ mod ct {\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it 0this way, I think.\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+mod rt {\n+    const flag_none : u32 = 0u32;\n+    const flag_left_justify   : u32 = 0b00000000000000000000000000000001u32;\n+    const flag_left_zero_pad  : u32 = 0b00000000000000000000000000000010u32;\n+    const flag_space_for_sign : u32 = 0b00000000000000000000000000000100u32;\n+    const flag_sign_always    : u32 = 0b00000000000000000000000000001000u32;\n+    const flag_alternate      : u32 = 0b00000000000000000000000000010000u32;\n+\n+    enum Count { CountIs(int), CountImplied, }\n+    enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n+\n+    type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n+\n+    pure fn conv_int(cv: Conv, i: int) -> ~str {\n+        let radix = 10u;\n+        let prec = get_int_precision(cv);\n+        let mut s : ~str = int_to_str_prec(i, radix, prec);\n+        if 0 <= i {\n+            if have_flag(cv.flags, flag_sign_always) {\n+                unchecked { str::unshift_char(s, '+') };\n+            } else if have_flag(cv.flags, flag_space_for_sign) {\n+                unchecked { str::unshift_char(s, ' ') };\n+            }\n+        }\n+        return unchecked { pad(cv, s, PadSigned) };\n+    }\n+    pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n+        let prec = get_int_precision(cv);\n+        let mut rs =\n+            match cv.ty {\n+              TyDefault => uint_to_str_prec(u, 10u, prec),\n+              TyHexLower => uint_to_str_prec(u, 16u, prec),\n+              TyHexUpper => str::to_upper(uint_to_str_prec(u, 16u, prec)),\n+              TyBits => uint_to_str_prec(u, 2u, prec),\n+              TyOctal => uint_to_str_prec(u, 8u, prec)\n+            };\n+        return unchecked { pad(cv, rs, PadUnsigned) };\n+    }\n+    pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n+        let s = if b { ~\"true\" } else { ~\"false\" };\n+        // run the boolean conversion through the string conversion logic,\n+        // giving it the same rules for precision, etc.\n+        return conv_str(cv, s);\n+    }\n+    pure fn conv_char(cv: Conv, c: char) -> ~str {\n+        let mut s = str::from_char(c);\n+        return unchecked { pad(cv, s, PadNozero) };\n+    }\n+    pure fn conv_str(cv: Conv, s: &str) -> ~str {\n+        // For strings, precision is the maximum characters\n+        // displayed\n+        let mut unpadded = match cv.precision {\n+          CountImplied => s.to_unique(),\n+          CountIs(max) => if max as uint < str::char_len(s) {\n+            str::substr(s, 0u, max as uint)\n+          } else {\n+            s.to_unique()\n+          }\n+        };\n+        return unchecked { pad(cv, unpadded, PadNozero) };\n+    }\n+    pure fn conv_float(cv: Conv, f: float) -> ~str {\n+        let (to_str, digits) = match cv.precision {\n+              CountIs(c) => (float::to_str_exact, c as uint),\n+              CountImplied => (float::to_str, 6u)\n+        };\n+        let mut s = unchecked { to_str(f, digits) };\n+        if 0.0 <= f {\n+            if have_flag(cv.flags, flag_sign_always) {\n+                s = ~\"+\" + s;\n+            } else if have_flag(cv.flags, flag_space_for_sign) {\n+                s = ~\" \" + s;\n+            }\n+        }\n+        return unchecked { pad(cv, s, PadFloat) };\n+    }\n+    pure fn conv_poly<T>(cv: Conv, v: T) -> ~str {\n+        let s = sys::log_str(v);\n+        return conv_str(cv, s);\n+    }\n+\n+    // Convert an int to string with minimum number of digits. If precision is\n+    // 0 and num is 0 then the result is the empty string.\n+    pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n+        return if num < 0 {\n+                ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n+            } else { uint_to_str_prec(num as uint, radix, prec) };\n+    }\n+\n+    // Convert a uint to string with a minimum number of digits.  If precision\n+    // is 0 and num is 0 then the result is the empty string. Could move this\n+    // to uint: but it doesn't seem all that useful.\n+    pure fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n+        return if prec == 0u && num == 0u {\n+                ~\"\"\n+            } else {\n+                let s = uint::to_str(num, radix);\n+                let len = str::char_len(s);\n+                if len < prec {\n+                    let diff = prec - len;\n+                    let pad = str::from_chars(vec::from_elem(diff, '0'));\n+                    pad + s\n+                } else { move s }\n+            };\n+    }\n+    pure fn get_int_precision(cv: Conv) -> uint {\n+        return match cv.precision {\n+              CountIs(c) => c as uint,\n+              CountImplied => 1u\n+            };\n+    }\n+\n+    enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n+\n+    impl PadMode: Eq {\n+        pure fn eq(&&other: PadMode) -> bool {\n+            match (self, other) {\n+                (PadSigned, PadSigned) => true,\n+                (PadUnsigned, PadUnsigned) => true,\n+                (PadNozero, PadNozero) => true,\n+                (PadFloat, PadFloat) => true,\n+                (PadSigned, _) => false,\n+                (PadUnsigned, _) => false,\n+                (PadNozero, _) => false,\n+                (PadFloat, _) => false\n+            }\n+        }\n+        pure fn ne(&&other: PadMode) -> bool { !self.eq(other) }\n+    }\n+\n+    fn pad(cv: Conv, &s: ~str, mode: PadMode) -> ~str {\n+        let uwidth : uint = match cv.width {\n+          CountImplied => return copy s,\n+          CountIs(width) => {\n+              // FIXME: width should probably be uint (see Issue #1996)\n+              width as uint\n+          }\n+        };\n+        let strlen = str::char_len(s);\n+        if uwidth <= strlen { return copy s; }\n+        let mut padchar = ' ';\n+        let diff = uwidth - strlen;\n+        if have_flag(cv.flags, flag_left_justify) {\n+            let padstr = str::from_chars(vec::from_elem(diff, padchar));\n+            return s + padstr;\n+        }\n+        let {might_zero_pad, signed} = match mode {\n+          PadNozero => {might_zero_pad:false, signed:false},\n+          PadSigned => {might_zero_pad:true,  signed:true },\n+          PadFloat => {might_zero_pad:true,  signed:true},\n+          PadUnsigned => {might_zero_pad:true,  signed:false}\n+        };\n+        pure fn have_precision(cv: Conv) -> bool {\n+            return match cv.precision { CountImplied => false, _ => true };\n+        }\n+        let zero_padding = {\n+            if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n+                (!have_precision(cv) || mode == PadFloat) {\n+                padchar = '0';\n+                true\n+            } else {\n+                false\n+            }\n+        };\n+        let padstr = str::from_chars(vec::from_elem(diff, padchar));\n+        // This is completely heinous. If we have a signed value then\n+        // potentially rip apart the intermediate result and insert some\n+        // zeros. It may make sense to convert zero padding to a precision\n+        // instead.\n+\n+        if signed && zero_padding && str::len(s) > 0u {\n+            let head = str::shift_char(s);\n+            if head == '+' || head == '-' || head == ' ' {\n+                let headstr = str::from_chars(vec::from_elem(1u, head));\n+                return headstr + padstr + s;\n+            }\n+            else {\n+                str::unshift_char(s, head);\n+            }\n+        }\n+        return padstr + s;\n+    }\n+    pure fn have_flag(flags: u32, f: u32) -> bool {\n+        flags & f != 0\n+    }\n+}\n+\n+// XXX remove after snappies\n+#[cfg(stage0)]\n+#[allow(non_camel_case_types)]\n mod rt {\n     const flag_none : u32 = 0u32;\n     const flag_left_justify   : u32 = 0b00000000000000000000000000000001u32;\n@@ -461,6 +653,7 @@ mod rt {\n     }\n }\n \n+\n #[cfg(test)]\n mod test {\n     #[test]"}, {"sha": "4c5435d11236fbe8bc906f9b6059e9fd44133342", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/2c6c963f61d84d2a959df0d5c82f519c157ef552/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6c963f61d84d2a959df0d5c82f519c157ef552/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=2c6c963f61d84d2a959df0d5c82f519c157ef552", "patch": "@@ -35,7 +35,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n // expressions.  Also: Cleanup the naming of these functions.\n // NOTE: Moved many of the common ones to build.rs --kevina\n fn pieces_to_expr(cx: ext_ctxt, sp: span,\n-                  pieces: ~[piece], args: ~[@ast::expr])\n+                  pieces: ~[Piece], args: ~[@ast::expr])\n    -> @ast::expr {\n     fn make_path_vec(_cx: ext_ctxt, ident: @~str) -> ~[ast::ident] {\n         let intr = _cx.parse_sess().interner;\n@@ -49,46 +49,46 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n \n-    fn make_rt_conv_expr(cx: ext_ctxt, sp: span, cnv: conv) -> @ast::expr {\n-        fn make_flags(cx: ext_ctxt, sp: span, flags: ~[flag]) -> @ast::expr {\n+    fn make_rt_conv_expr(cx: ext_ctxt, sp: span, cnv: Conv) -> @ast::expr {\n+        fn make_flags(cx: ext_ctxt, sp: span, flags: ~[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, @~\"flag_none\");\n             for flags.each |f| {\n                 let fstr = match f {\n-                  flag_left_justify => ~\"flag_left_justify\",\n-                  flag_left_zero_pad => ~\"flag_left_zero_pad\",\n-                  flag_space_for_sign => ~\"flag_space_for_sign\",\n-                  flag_sign_always => ~\"flag_sign_always\",\n-                  flag_alternate => ~\"flag_alternate\"\n+                  FlagLeftJustify => ~\"flag_left_justify\",\n+                  FlagLeftZeroPad => ~\"flag_left_zero_pad\",\n+                  FlagSpaceForSign => ~\"flag_space_for_sign\",\n+                  FlagSignAlways => ~\"flag_sign_always\",\n+                  FlagAlternate => ~\"flag_alternate\"\n                 };\n                 tmp_expr = mk_binary(cx, sp, ast::bitor, tmp_expr,\n                                      make_rt_path_expr(cx, sp, @fstr));\n             }\n             return tmp_expr;\n         }\n-        fn make_count(cx: ext_ctxt, sp: span, cnt: count) -> @ast::expr {\n+        fn make_count(cx: ext_ctxt, sp: span, cnt: Count) -> @ast::expr {\n             match cnt {\n-              count_implied => {\n-                return make_rt_path_expr(cx, sp, @~\"count_implied\");\n+              CountImplied => {\n+                return make_rt_path_expr(cx, sp, @~\"CountImplied\");\n               }\n-              count_is(c) => {\n+              CountIs(c) => {\n                 let count_lit = mk_int(cx, sp, c);\n-                let count_is_path = make_path_vec(cx, @~\"count_is\");\n+                let count_is_path = make_path_vec(cx, @~\"CountIs\");\n                 let count_is_args = ~[count_lit];\n                 return mk_call(cx, sp, count_is_path, count_is_args);\n               }\n               _ => cx.span_unimpl(sp, ~\"unimplemented #fmt conversion\")\n             }\n         }\n-        fn make_ty(cx: ext_ctxt, sp: span, t: ty) -> @ast::expr {\n+        fn make_ty(cx: ext_ctxt, sp: span, t: Ty) -> @ast::expr {\n             let mut rt_type;\n             match t {\n-              ty_hex(c) => match c {\n-                case_upper => rt_type = ~\"ty_hex_upper\",\n-                case_lower => rt_type = ~\"ty_hex_lower\"\n+              TyHex(c) => match c {\n+                CaseUpper => rt_type = ~\"TyHexUpper\",\n+                CaseLower => rt_type = ~\"TyHexLower\"\n               },\n-              ty_bits => rt_type = ~\"ty_bits\",\n-              ty_octal => rt_type = ~\"ty_octal\",\n-              _ => rt_type = ~\"ty_default\"\n+              TyBits => rt_type = ~\"TyBits\",\n+              TyOctal => rt_type = ~\"TyOctal\",\n+              _ => rt_type = ~\"TyDefault\"\n             }\n             return make_rt_path_expr(cx, sp, @rt_type);\n         }\n@@ -110,7 +110,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         return make_conv_rec(cx, sp, rt_conv_flags, rt_conv_width,\n                           rt_conv_precision, rt_conv_ty);\n     }\n-    fn make_conv_call(cx: ext_ctxt, sp: span, conv_type: ~str, cnv: conv,\n+    fn make_conv_call(cx: ext_ctxt, sp: span, conv_type: ~str, cnv: Conv,\n                       arg: @ast::expr) -> @ast::expr {\n         let fname = ~\"conv_\" + conv_type;\n         let path = make_path_vec(cx, @fname);\n@@ -119,17 +119,17 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         return mk_call(cx, arg.span, path, args);\n     }\n \n-    fn make_new_conv(cx: ext_ctxt, sp: span, cnv: conv, arg: @ast::expr) ->\n+    fn make_new_conv(cx: ext_ctxt, sp: span, cnv: Conv, arg: @ast::expr) ->\n        @ast::expr {\n         // FIXME: Move validation code into core::extfmt (Issue #2249)\n \n-        fn is_signed_type(cnv: conv) -> bool {\n+        fn is_signed_type(cnv: Conv) -> bool {\n             match cnv.ty {\n-              ty_int(s) => match s {\n-                signed => return true,\n-                unsigned => return false\n+              TyInt(s) => match s {\n+                Signed => return true,\n+                Unsigned => return false\n               },\n-              ty_float => return true,\n+              TyFloat => return true,\n               _ => return false\n             }\n         }\n@@ -140,102 +140,102 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         }\n         for cnv.flags.each |f| {\n             match f {\n-              flag_left_justify => (),\n-              flag_sign_always => {\n+              FlagLeftJustify => (),\n+              FlagSignAlways => {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n                                   ~\"+ flag only valid in \" +\n                                       ~\"signed #fmt conversion\");\n                 }\n               }\n-              flag_space_for_sign => {\n+              FlagSpaceForSign => {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n                                   ~\"space flag only valid in \" +\n                                       ~\"signed #fmt conversions\");\n                 }\n               }\n-              flag_left_zero_pad => (),\n+              FlagLeftZeroPad => (),\n               _ => cx.span_unimpl(sp, unsupported)\n             }\n         }\n         match cnv.width {\n-          count_implied => (),\n-          count_is(_) => (),\n+          CountImplied => (),\n+          CountIs(_) => (),\n           _ => cx.span_unimpl(sp, unsupported)\n         }\n         match cnv.precision {\n-          count_implied => (),\n-          count_is(_) => (),\n+          CountImplied => (),\n+          CountIs(_) => (),\n           _ => cx.span_unimpl(sp, unsupported)\n         }\n         match cnv.ty {\n-          ty_str => return make_conv_call(cx, arg.span, ~\"str\", cnv, arg),\n-          ty_int(sign) => match sign {\n-            signed => return make_conv_call(cx, arg.span, ~\"int\", cnv, arg),\n-            unsigned => {\n+          TyStr => return make_conv_call(cx, arg.span, ~\"str\", cnv, arg),\n+          TyInt(sign) => match sign {\n+            Signed => return make_conv_call(cx, arg.span, ~\"int\", cnv, arg),\n+            Unsigned => {\n                 return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg)\n             }\n           },\n-          ty_bool => return make_conv_call(cx, arg.span, ~\"bool\", cnv, arg),\n-          ty_char => return make_conv_call(cx, arg.span, ~\"char\", cnv, arg),\n-          ty_hex(_) => {\n+          TyBool => return make_conv_call(cx, arg.span, ~\"bool\", cnv, arg),\n+          TyChar => return make_conv_call(cx, arg.span, ~\"char\", cnv, arg),\n+          TyHex(_) => {\n             return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg);\n           }\n-          ty_bits => return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg),\n-          ty_octal => return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg),\n-          ty_float => {\n+          TyBits => return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg),\n+          TyOctal => return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg),\n+          TyFloat => {\n             return make_conv_call(cx, arg.span, ~\"float\", cnv, arg);\n           }\n-          ty_poly => return make_conv_call(cx, arg.span, ~\"poly\", cnv, arg)\n+          TyPoly => return make_conv_call(cx, arg.span, ~\"poly\", cnv, arg)\n         }\n     }\n-    fn log_conv(c: conv) {\n+    fn log_conv(c: Conv) {\n         match c.param {\n           Some(p) => { log(debug, ~\"param: \" + int::to_str(p, 10u)); }\n           _ => debug!(\"param: none\")\n         }\n         for c.flags.each |f| {\n             match f {\n-              flag_left_justify => debug!(\"flag: left justify\"),\n-              flag_left_zero_pad => debug!(\"flag: left zero pad\"),\n-              flag_space_for_sign => debug!(\"flag: left space pad\"),\n-              flag_sign_always => debug!(\"flag: sign always\"),\n-              flag_alternate => debug!(\"flag: alternate\")\n+              FlagLeftJustify => debug!(\"flag: left justify\"),\n+              FlagLeftZeroPad => debug!(\"flag: left zero pad\"),\n+              FlagSpaceForSign => debug!(\"flag: left space pad\"),\n+              FlagSignAlways => debug!(\"flag: sign always\"),\n+              FlagAlternate => debug!(\"flag: alternate\")\n             }\n         }\n         match c.width {\n-          count_is(i) => log(\n+          CountIs(i) => log(\n               debug, ~\"width: count is \" + int::to_str(i, 10u)),\n-          count_is_param(i) => log(\n+          CountIsParam(i) => log(\n               debug, ~\"width: count is param \" + int::to_str(i, 10u)),\n-          count_is_next_param => debug!(\"width: count is next param\"),\n-          count_implied => debug!(\"width: count is implied\")\n+          CountIsNextParam => debug!(\"width: count is next param\"),\n+          CountImplied => debug!(\"width: count is implied\")\n         }\n         match c.precision {\n-          count_is(i) => log(\n+          CountIs(i) => log(\n               debug, ~\"prec: count is \" + int::to_str(i, 10u)),\n-          count_is_param(i) => log(\n+          CountIsParam(i) => log(\n               debug, ~\"prec: count is param \" + int::to_str(i, 10u)),\n-          count_is_next_param => debug!(\"prec: count is next param\"),\n-          count_implied => debug!(\"prec: count is implied\")\n+          CountIsNextParam => debug!(\"prec: count is next param\"),\n+          CountImplied => debug!(\"prec: count is implied\")\n         }\n         match c.ty {\n-          ty_bool => debug!(\"type: bool\"),\n-          ty_str => debug!(\"type: str\"),\n-          ty_char => debug!(\"type: char\"),\n-          ty_int(s) => match s {\n-            signed => debug!(\"type: signed\"),\n-            unsigned => debug!(\"type: unsigned\")\n+          TyBool => debug!(\"type: bool\"),\n+          TyStr => debug!(\"type: str\"),\n+          TyChar => debug!(\"type: char\"),\n+          TyInt(s) => match s {\n+            Signed => debug!(\"type: signed\"),\n+            Unsigned => debug!(\"type: unsigned\")\n           },\n-          ty_bits => debug!(\"type: bits\"),\n-          ty_hex(cs) => match cs {\n-            case_upper => debug!(\"type: uhex\"),\n-            case_lower => debug!(\"type: lhex\"),\n+          TyBits => debug!(\"type: bits\"),\n+          TyHex(cs) => match cs {\n+            CaseUpper => debug!(\"type: uhex\"),\n+            CaseLower => debug!(\"type: lhex\"),\n           },\n-          ty_octal => debug!(\"type: octal\"),\n-          ty_float => debug!(\"type: float\"),\n-          ty_poly => debug!(\"type: poly\")\n+          TyOctal => debug!(\"type: octal\"),\n+          TyFloat => debug!(\"type: float\"),\n+          TyPoly => debug!(\"type: poly\")\n         }\n     }\n     let fmt_sp = args[0].span;\n@@ -244,10 +244,10 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     let nargs = args.len();\n     for pieces.each |pc| {\n         match pc {\n-          piece_string(s) => {\n+          PieceString(s) => {\n             vec::push(piece_exprs, mk_uniq_str(cx, fmt_sp, s))\n           }\n-          piece_conv(conv) => {\n+          PieceConv(conv) => {\n             n += 1u;\n             if n >= nargs {\n                 cx.span_fatal(sp,"}]}