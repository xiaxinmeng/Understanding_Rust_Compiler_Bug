{"sha": "7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYmNjMTQyZTVkYTFiODdjNTlhMTUxMGZhODdhZWZjNDEyMmJkNmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-21T04:40:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-21T04:40:27Z"}, "message": "auto merge of #6626 : brson/rust/io-upstream, r=graydon\n\nr?\r\n\r\nMostly refactoring, and adding some of the remaining types described in #4419.\r\n\r\nThe [`Local`](https://github.com/brson/rust/blob/3b4ff41511cfaa5e311b03d16b47bf40c117fa2f/src/libcore/rt/local.rs#L17) trait collects some common, often unsafe patterns around task-local and thread-local values. Making all these types safe is largely the aim of #6210.", "tree": {"sha": "e069fcc7e3da94e50e678fcc723eb59b87123b3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e069fcc7e3da94e50e678fcc723eb59b87123b3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "html_url": "https://github.com/rust-lang/rust/commit/7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adaae45c3e15f95b052648f3511a1097155296b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/adaae45c3e15f95b052648f3511a1097155296b9", "html_url": "https://github.com/rust-lang/rust/commit/adaae45c3e15f95b052648f3511a1097155296b9"}, {"sha": "a246e8faf362a1615b5bb4938455dd70642e0f4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a246e8faf362a1615b5bb4938455dd70642e0f4b", "html_url": "https://github.com/rust-lang/rust/commit/a246e8faf362a1615b5bb4938455dd70642e0f4b"}], "stats": {"total": 787, "additions": 466, "deletions": 321}, "files": [{"sha": "be71714a048e334be3006dc4a03d970dd615a7ea", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -66,8 +66,11 @@ pub fn log_type<T>(level: u32, object: &T) {\n }\n \n fn newsched_log_str(msg: ~str) {\n+    use rt::task::Task;\n+    use rt::local::Local;\n+\n     unsafe {\n-        match rt::local_services::unsafe_try_borrow_local_services() {\n+        match Local::try_unsafe_borrow::<Task>() {\n             Some(local) => {\n                 // Use the available logger\n                 (*local).logger.log(Left(msg));"}, {"sha": "576a402b70919f88e52750473b854b6a8a04595a", "filename": "src/libcore/rt/comm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcomm.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -20,8 +20,8 @@ use cast;\n use util;\n use ops::Drop;\n use kinds::Owned;\n-use rt::sched::Coroutine;\n-use rt::local_sched;\n+use rt::sched::{Scheduler, Coroutine};\n+use rt::local::Local;\n use unstable::intrinsics::{atomic_xchg, atomic_load};\n use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n@@ -127,7 +127,7 @@ impl<T> ChanOne<T> {\n                 task_as_state => {\n                     // Port is blocked. Wake it up.\n                     let recvr: ~Coroutine = cast::transmute(task_as_state);\n-                    let sched = local_sched::take();\n+                    let sched = Local::take::<Scheduler>();\n                     sched.schedule_task(recvr);\n                 }\n             }\n@@ -157,7 +157,7 @@ impl<T> PortOne<T> {\n         // XXX: Optimize this to not require the two context switches when data is available\n \n         // Switch to the scheduler to put the ~Task into the Packet state.\n-        let sched = local_sched::take();\n+        let sched = Local::take::<Scheduler>();\n         do sched.deschedule_running_task_and_then |task| {\n             unsafe {\n                 // Atomically swap the task pointer into the Packet state, issuing\n@@ -173,7 +173,7 @@ impl<T> PortOne<T> {\n                     STATE_ONE => {\n                         // Channel is closed. Switch back and check the data.\n                         let task: ~Coroutine = cast::transmute(task_as_state);\n-                        let sched = local_sched::take();\n+                        let sched = Local::take::<Scheduler>();\n                         sched.resume_task_immediately(task);\n                     }\n                     _ => util::unreachable()\n@@ -239,7 +239,7 @@ impl<T> Drop for ChanOneHack<T> {\n                     // The port is blocked waiting for a message we will never send. Wake it.\n                     assert!((*this.packet()).payload.is_none());\n                     let recvr: ~Coroutine = cast::transmute(task_as_state);\n-                    let sched = local_sched::take();\n+                    let sched = Local::take::<Scheduler>();\n                     sched.schedule_task(recvr);\n                 }\n             }"}, {"sha": "f7c03c13a58126382738b50babb82f3cec0f63f9", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -10,13 +10,13 @@\n \n use option::{Option, Some, None};\n use result::{Ok, Err};\n-use rt::sched::local_sched::unsafe_borrow_io;\n use rt::io::net::ip::IpAddr;\n use rt::io::{Reader, Writer, Listener};\n use rt::io::{io_error, read_error, EndOfFile};\n-use rt::rtio::{IoFactory,\n+use rt::rtio::{IoFactory, IoFactoryObject,\n                RtioTcpListener, RtioTcpListenerObject,\n                RtioTcpStream, RtioTcpStreamObject};\n+use rt::local::Local;\n \n pub struct TcpStream {\n     rtstream: ~RtioTcpStreamObject\n@@ -32,7 +32,7 @@ impl TcpStream {\n     pub fn connect(addr: IpAddr) -> Option<TcpStream> {\n         let stream = unsafe {\n             rtdebug!(\"borrowing io to connect\");\n-            let io = unsafe_borrow_io();\n+            let io = Local::unsafe_borrow::<IoFactoryObject>();\n             rtdebug!(\"about to connect\");\n             (*io).tcp_connect(addr)\n         };\n@@ -88,7 +88,10 @@ pub struct TcpListener {\n \n impl TcpListener {\n     pub fn bind(addr: IpAddr) -> Option<TcpListener> {\n-        let listener = unsafe { (*unsafe_borrow_io()).tcp_bind(addr) };\n+        let listener = unsafe {\n+            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            (*io).tcp_bind(addr)\n+        };\n         match listener {\n             Ok(l) => {\n                 Some(TcpListener {"}, {"sha": "64a384ddff0b90e01f40be6fda577a35dea13d3c", "filename": "src/libcore/rt/local.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -0,0 +1,118 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::{Option, Some, None};\n+use rt::sched::Scheduler;\n+use rt::task::Task;\n+use rt::local_ptr;\n+use rt::rtio::{EventLoop, IoFactoryObject};\n+\n+pub trait Local {\n+    fn put(value: ~Self);\n+    fn take() -> ~Self;\n+    fn exists() -> bool;\n+    fn borrow(f: &fn(&mut Self));\n+    unsafe fn unsafe_borrow() -> *mut Self;\n+    unsafe fn try_unsafe_borrow() -> Option<*mut Self>;\n+}\n+\n+impl Local for Scheduler {\n+    fn put(value: ~Scheduler) { unsafe { local_ptr::put(value) }}\n+    fn take() -> ~Scheduler { unsafe { local_ptr::take() } }\n+    fn exists() -> bool { local_ptr::exists() }\n+    fn borrow(f: &fn(&mut Scheduler)) { unsafe { local_ptr::borrow(f) } }\n+    unsafe fn unsafe_borrow() -> *mut Scheduler { local_ptr::unsafe_borrow() }\n+    unsafe fn try_unsafe_borrow() -> Option<*mut Scheduler> { abort!(\"unimpl\") }\n+}\n+\n+impl Local for Task {\n+    fn put(value: ~Task) { abort!(\"unimpl\") }\n+    fn take() -> ~Task { abort!(\"unimpl\") }\n+    fn exists() -> bool { abort!(\"unimpl\") }\n+    fn borrow(f: &fn(&mut Task)) {\n+        do Local::borrow::<Scheduler> |sched| {\n+            match sched.current_task {\n+                Some(~ref mut task) => {\n+                    f(&mut *task.task)\n+                }\n+                None => {\n+                    abort!(\"no scheduler\")\n+                }\n+            }\n+        }\n+    }\n+    unsafe fn unsafe_borrow() -> *mut Task {\n+        match (*Local::unsafe_borrow::<Scheduler>()).current_task {\n+            Some(~ref mut task) => {\n+                let s: *mut Task = &mut *task.task;\n+                return s;\n+            }\n+            None => {\n+                // Don't fail. Infinite recursion\n+                abort!(\"no scheduler\")\n+            }\n+        }\n+    }\n+    unsafe fn try_unsafe_borrow() -> Option<*mut Task> {\n+        if Local::exists::<Scheduler>() {\n+            Some(Local::unsafe_borrow())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+// XXX: This formulation won't work once ~IoFactoryObject is a real trait pointer\n+impl Local for IoFactoryObject {\n+    fn put(value: ~IoFactoryObject) { abort!(\"unimpl\") }\n+    fn take() -> ~IoFactoryObject { abort!(\"unimpl\") }\n+    fn exists() -> bool { abort!(\"unimpl\") }\n+    fn borrow(f: &fn(&mut IoFactoryObject)) { abort!(\"unimpl\") }\n+    unsafe fn unsafe_borrow() -> *mut IoFactoryObject {\n+        let sched = Local::unsafe_borrow::<Scheduler>();\n+        let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n+        return io;\n+    }\n+    unsafe fn try_unsafe_borrow() -> Option<*mut IoFactoryObject> { abort!(\"unimpl\") }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use rt::sched::Scheduler;\n+    use rt::uv::uvio::UvEventLoop;\n+    use super::*;\n+\n+    #[test]\n+    fn thread_local_scheduler_smoke_test() {\n+        let scheduler = ~UvEventLoop::new_scheduler();\n+        Local::put(scheduler);\n+        let _scheduler: ~Scheduler = Local::take();\n+    }\n+\n+    #[test]\n+    fn thread_local_scheduler_two_instances() {\n+        let scheduler = ~UvEventLoop::new_scheduler();\n+        Local::put(scheduler);\n+        let _scheduler: ~Scheduler = Local::take();\n+        let scheduler = ~UvEventLoop::new_scheduler();\n+        Local::put(scheduler);\n+        let _scheduler: ~Scheduler = Local::take();\n+    }\n+\n+    #[test]\n+    fn borrow_smoke_test() {\n+        let scheduler = ~UvEventLoop::new_scheduler();\n+        Local::put(scheduler);\n+        unsafe {\n+            let _scheduler: *mut Scheduler = Local::unsafe_borrow();\n+        }\n+        let _scheduler: ~Scheduler = Local::take();\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "80d797e8c65434ae89b0803ec0152a395734bfe5", "filename": "src/libcore/rt/local_ptr.rs", "status": "renamed", "additions": 58, "deletions": 74, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_ptr.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -8,43 +8,57 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Access to the thread-local Scheduler\n+//! Access to a single thread-local pointer.\n+//!\n+//! The runtime will use this for storing ~Task.\n+//!\n+//! XXX: Add runtime checks for usage of inconsistent pointer types.\n+//! and for overwriting an existing pointer.\n \n-use prelude::*;\n-use ptr::mut_null;\n use libc::c_void;\n use cast;\n+use ptr;\n use cell::Cell;\n-\n-use rt::sched::Scheduler;\n-use rt::rtio::{EventLoop, IoFactoryObject};\n-use tls = rt::thread_local_storage;\n+use option::{Option, Some, None};\n use unstable::finally::Finally;\n+use tls = rt::thread_local_storage;\n \n-#[cfg(test)] use rt::uv::uvio::UvEventLoop;\n-\n-/// Give the Scheduler to thread-local storage\n-pub fn put(sched: ~Scheduler) {\n+/// Initialize the TLS key. Other ops will fail if this isn't executed first.\n+pub fn init_tls_key() {\n     unsafe {\n-        let key = tls_key();\n-        let void_sched: *mut c_void = cast::transmute(sched);\n-        tls::set(key, void_sched);\n+        rust_initialize_rt_tls_key();\n+        extern {\n+            fn rust_initialize_rt_tls_key();\n+        }\n     }\n }\n \n-/// Take ownership of the Scheduler from thread-local storage\n-pub fn take() -> ~Scheduler {\n-    unsafe {\n-        let key = tls_key();\n-        let void_sched: *mut c_void = tls::get(key);\n-        rtassert!(void_sched.is_not_null());\n-        let sched: ~Scheduler = cast::transmute(void_sched);\n-        tls::set(key, mut_null());\n-        return sched;\n-    }\n+/// Give a pointer to thread-local storage.\n+///\n+/// # Safety note\n+///\n+/// Does not validate the pointer type.\n+pub unsafe fn put<T>(sched: ~T) {\n+    let key = tls_key();\n+    let void_ptr: *mut c_void = cast::transmute(sched);\n+    tls::set(key, void_ptr);\n+}\n+\n+/// Take ownership of a pointer from thread-local storage.\n+///\n+/// # Safety note\n+///\n+/// Does not validate the pointer type.\n+pub unsafe fn take<T>() -> ~T {\n+    let key = tls_key();\n+    let void_ptr: *mut c_void = tls::get(key);\n+    rtassert!(void_ptr.is_not_null());\n+    let ptr: ~T = cast::transmute(void_ptr);\n+    tls::set(key, ptr::mut_null());\n+    return ptr;\n }\n \n-/// Check whether there is a thread-local Scheduler attached to the running thread\n+/// Check whether there is a thread-local pointer installed.\n pub fn exists() -> bool {\n     unsafe {\n         match maybe_tls_key() {\n@@ -56,19 +70,21 @@ pub fn exists() -> bool {\n \n /// Borrow the thread-local scheduler from thread-local storage.\n /// While the scheduler is borrowed it is not available in TLS.\n-pub fn borrow(f: &fn(&mut Scheduler)) {\n-    let mut sched = take();\n+///\n+/// # Safety note\n+///\n+/// Does not validate the pointer type.\n+pub unsafe fn borrow<T>(f: &fn(&mut T)) {\n+    let mut value = take();\n \n     // XXX: Need a different abstraction from 'finally' here to avoid unsafety\n-    unsafe {\n-        let unsafe_sched = cast::transmute_mut_region(&mut *sched);\n-        let sched = Cell(sched);\n+    let unsafe_ptr = cast::transmute_mut_region(&mut *value);\n+    let value_cell = Cell(value);\n \n-        do (|| {\n-            f(unsafe_sched);\n-        }).finally {\n-            put(sched.take());\n-        }\n+    do (|| {\n+        f(unsafe_ptr);\n+    }).finally {\n+        put(value_cell.take());\n     }\n }\n \n@@ -78,24 +94,18 @@ pub fn borrow(f: &fn(&mut Scheduler)) {\n ///\n /// Because this leaves the Scheduler in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n-pub unsafe fn unsafe_borrow() -> *mut Scheduler {\n+pub unsafe fn unsafe_borrow<T>() -> *mut T {\n     let key = tls_key();\n     let mut void_sched: *mut c_void = tls::get(key);\n     rtassert!(void_sched.is_not_null());\n     {\n         let sched: *mut *mut c_void = &mut void_sched;\n-        let sched: *mut ~Scheduler = sched as *mut ~Scheduler;\n-        let sched: *mut Scheduler = &mut **sched;\n+        let sched: *mut ~T = sched as *mut ~T;\n+        let sched: *mut T = &mut **sched;\n         return sched;\n     }\n }\n \n-pub unsafe fn unsafe_borrow_io() -> *mut IoFactoryObject {\n-    let sched = unsafe_borrow();\n-    let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n-    return io;\n-}\n-\n fn tls_key() -> tls::Key {\n     match maybe_tls_key() {\n         Some(key) => key,\n@@ -126,36 +136,10 @@ fn maybe_tls_key() -> Option<tls::Key> {\n             return None;\n         }\n     }\n-}\n \n-extern {\n-    #[fast_ffi]\n-    fn rust_get_rt_tls_key() -> *mut c_void;\n-}\n-\n-#[test]\n-fn thread_local_scheduler_smoke_test() {\n-    let scheduler = ~UvEventLoop::new_scheduler();\n-    put(scheduler);\n-    let _scheduler = take();\n-}\n-\n-#[test]\n-fn thread_local_scheduler_two_instances() {\n-    let scheduler = ~UvEventLoop::new_scheduler();\n-    put(scheduler);\n-    let _scheduler = take();\n-    let scheduler = ~UvEventLoop::new_scheduler();\n-    put(scheduler);\n-    let _scheduler = take();\n-}\n-\n-#[test]\n-fn borrow_smoke_test() {\n-    let scheduler = ~UvEventLoop::new_scheduler();\n-    put(scheduler);\n-    unsafe {\n-        let _scheduler = unsafe_borrow();\n+    extern {\n+        #[fast_ffi]\n+        fn rust_get_rt_tls_key() -> *mut c_void;\n     }\n-    let _scheduler = take();\n+\n }", "previous_filename": "src/libcore/rt/local_sched.rs"}, {"sha": "eaab9288ac8d00f34b7cab9d14455248acff0f70", "filename": "src/libcore/rt/message_queue.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmessage_queue.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use container::Container;\n+use kinds::Owned;\n+use vec::OwnedVector;\n+use cell::Cell;\n+use option::*;\n+use unstable::sync::{Exclusive, exclusive};\n+use clone::Clone;\n+\n+pub struct MessageQueue<T> {\n+    // XXX: Another mystery bug fixed by boxing this lock\n+    priv queue: ~Exclusive<~[T]>\n+}\n+\n+impl<T: Owned> MessageQueue<T> {\n+    pub fn new() -> MessageQueue<T> {\n+        MessageQueue {\n+            queue: ~exclusive(~[])\n+        }\n+    }\n+\n+    pub fn push(&mut self, value: T) {\n+        let value = Cell(value);\n+        self.queue.with(|q| q.push(value.take()) );\n+    }\n+\n+    pub fn pop(&mut self) -> Option<T> {\n+        do self.queue.with |q| {\n+            if !q.is_empty() {\n+                Some(q.shift())\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for MessageQueue<T> {\n+    fn clone(&self) -> MessageQueue<T> {\n+        MessageQueue {\n+            queue: self.queue.clone()\n+        }\n+    }\n+}"}, {"sha": "2fac1df01a495c056810e57e9a0d16debd13d607", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -31,14 +31,8 @@ access to the global heap. Unlike most of `rt` the global heap is\n truly a global resource and generally operates independently of the\n rest of the runtime.\n \n-All other runtime features are 'local', either thread-local or\n-task-local.  Those critical to the functioning of the language are\n-defined in the module `local_services`. Local services are those which\n-are expected to be available to Rust code generally but rely on\n-thread- or task-local state. These currently include the local heap,\n+All other runtime features are task-local, including the local heap,\n the garbage collector, local storage, logging and the stack unwinder.\n-Local services are primarily implemented for tasks, but may also\n-be implemented for use outside of tasks.\n \n The relationship between `rt` and the rest of the core library is\n not entirely clear yet and some modules will be moving into or\n@@ -67,33 +61,33 @@ use ptr::Ptr;\n /// The global (exchange) heap.\n pub mod global_heap;\n \n-/// The Scheduler and Coroutine types.\n-mod sched;\n+/// Implementations of language-critical runtime features like @.\n+pub mod task;\n \n-/// Thread-local access to the current Scheduler.\n-pub mod local_sched;\n+/// The coroutine task scheduler, built on the `io` event loop.\n+mod sched;\n \n /// Synchronous I/O.\n #[path = \"io/mod.rs\"]\n pub mod io;\n \n-/// Thread-local implementations of language-critical runtime features like @.\n-pub mod local_services;\n-\n /// The EventLoop and internal synchronous I/O interface.\n mod rtio;\n \n /// libuv and default rtio implementation.\n #[path = \"uv/mod.rs\"]\n pub mod uv;\n \n-// FIXME #5248: The import in `sched` doesn't resolve unless this is pub!\n-/// Bindings to pthread/windows thread-local storage.\n-pub mod thread_local_storage;\n+/// The Local trait for types that are accessible via thread-local\n+/// or task-local storage.\n+pub mod local;\n \n-/// A parallel work-stealing dequeue.\n+/// A parallel work-stealing deque.\n mod work_queue;\n \n+/// A parallel queue.\n+mod message_queue;\n+\n /// Stack segments and caching.\n mod stack;\n \n@@ -125,6 +119,15 @@ pub mod tube;\n /// Simple reimplementation of core::comm\n pub mod comm;\n \n+// FIXME #5248 shouldn't be pub\n+/// The runtime needs to be able to put a pointer into thread-local storage.\n+pub mod local_ptr;\n+\n+// FIXME #5248: The import in `sched` doesn't resolve unless this is pub!\n+/// Bindings to pthread/windows thread-local storage.\n+pub mod thread_local_storage;\n+\n+\n /// Set up a default runtime configuration, given compiler-supplied arguments.\n ///\n /// This is invoked by the `start` _language item_ (unstable::lang) to\n@@ -182,16 +185,17 @@ pub enum RuntimeContext {\n pub fn context() -> RuntimeContext {\n \n     use task::rt::rust_task;\n-    use self::sched::local_sched;\n+    use self::local::Local;\n+    use self::sched::Scheduler;\n \n     // XXX: Hitting TLS twice to check if the scheduler exists\n     // then to check for the task is not good for perf\n     if unsafe { rust_try_get_task().is_not_null() } {\n         return OldTaskContext;\n     } else {\n-        if local_sched::exists() {\n+        if Local::exists::<Scheduler>() {\n             let context = ::cell::empty_cell();\n-            do local_sched::borrow |sched| {\n+            do Local::borrow::<Scheduler> |sched| {\n                 if sched.in_task_context() {\n                     context.put_back(TaskContext);\n                 } else {\n@@ -213,21 +217,22 @@ pub fn context() -> RuntimeContext {\n #[test]\n fn test_context() {\n     use unstable::run_in_bare_thread;\n-    use self::sched::{local_sched, Coroutine};\n+    use self::sched::{Scheduler, Coroutine};\n     use rt::uv::uvio::UvEventLoop;\n     use cell::Cell;\n+    use rt::local::Local;\n \n     assert_eq!(context(), OldTaskContext);\n     do run_in_bare_thread {\n         assert_eq!(context(), GlobalContext);\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task = ~do Coroutine::new(&mut sched.stack_pool) {\n             assert_eq!(context(), TaskContext);\n-            let sched = local_sched::take();\n+            let sched = Local::take::<Scheduler>();\n             do sched.deschedule_running_task_and_then() |task| {\n                 assert_eq!(context(), SchedulerContext);\n                 let task = Cell(task);\n-                do local_sched::borrow |sched| {\n+                do Local::borrow::<Scheduler> |sched| {\n                     sched.enqueue_task(task.take());\n                 }\n             }"}, {"sha": "50c6a894093f3b1d6b05501fce48fe302e9c1794", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -11,16 +11,16 @@\n use option::*;\n use sys;\n use cast::transmute;\n+use cell::Cell;\n \n use super::work_queue::WorkQueue;\n use super::stack::{StackPool, StackSegment};\n use super::rtio::{EventLoop, EventLoopObject};\n use super::context::Context;\n-use super::local_services::LocalServices;\n-use cell::Cell;\n-\n-// A more convenient name for external callers, e.g. `local_sched::take()`\n-pub mod local_sched;\n+use super::task::Task;\n+use rt::local_ptr;\n+use rt::local::Local;\n+use rt::rtio::IoFactoryObject;\n \n /// The Scheduler is responsible for coordinating execution of Coroutines\n /// on a single thread. When the scheduler is running it is owned by\n@@ -64,11 +64,8 @@ pub impl Scheduler {\n \n     fn new(event_loop: ~EventLoopObject) -> Scheduler {\n \n-        // Lazily initialize the global state, currently the scheduler TLS key\n-        unsafe { rust_initialize_global_state(); }\n-        extern {\n-            fn rust_initialize_global_state();\n-        }\n+        // Lazily initialize the runtime TLS key\n+        local_ptr::init_tls_key();\n \n         Scheduler {\n             event_loop: event_loop,\n@@ -96,12 +93,12 @@ pub impl Scheduler {\n             };\n \n             // Give ownership of the scheduler (self) to the thread\n-            local_sched::put(self_sched);\n+            Local::put(self_sched);\n \n             (*event_loop).run();\n         }\n \n-        let sched = local_sched::take();\n+        let sched = Local::take::<Scheduler>();\n         assert!(sched.work_queue.is_empty());\n         return sched;\n     }\n@@ -112,11 +109,11 @@ pub impl Scheduler {\n     /// to run it later. Always use this instead of pushing to the work queue\n     /// directly.\n     fn enqueue_task(&mut self, task: ~Coroutine) {\n-        self.work_queue.push_front(task);\n+        self.work_queue.push(task);\n         self.event_loop.callback(resume_task_from_queue);\n \n         fn resume_task_from_queue() {\n-            let scheduler = local_sched::take();\n+            let scheduler = Local::take::<Scheduler>();\n             scheduler.resume_task_from_queue();\n         }\n     }\n@@ -129,14 +126,14 @@ pub impl Scheduler {\n         rtdebug!(\"looking in work queue for task to schedule\");\n \n         let mut this = self;\n-        match this.work_queue.pop_front() {\n+        match this.work_queue.pop() {\n             Some(task) => {\n                 rtdebug!(\"resuming task from work queue\");\n                 this.resume_task_immediately(task);\n             }\n             None => {\n                 rtdebug!(\"no tasks in queue\");\n-                local_sched::put(this);\n+                Local::put(this);\n             }\n         }\n     }\n@@ -152,7 +149,7 @@ pub impl Scheduler {\n \n         do self.deschedule_running_task_and_then |dead_task| {\n             let dead_task = Cell(dead_task);\n-            do local_sched::borrow |sched| {\n+            do Local::borrow::<Scheduler> |sched| {\n                 dead_task.take().recycle(&mut sched.stack_pool);\n             }\n         }\n@@ -165,7 +162,7 @@ pub impl Scheduler {\n \n         do self.switch_running_tasks_and_then(task) |last_task| {\n             let last_task = Cell(last_task);\n-            do local_sched::borrow |sched| {\n+            do Local::borrow::<Scheduler> |sched| {\n                 sched.enqueue_task(last_task.take());\n             }\n         }\n@@ -176,7 +173,7 @@ pub impl Scheduler {\n \n         do self.switch_running_tasks_and_then(task) |last_task| {\n             let last_task = Cell(last_task);\n-            do local_sched::borrow |sched| {\n+            do Local::borrow::<Scheduler> |sched| {\n                 sched.enqueue_task(last_task.take());\n             }\n         }\n@@ -194,18 +191,18 @@ pub impl Scheduler {\n         this.current_task = Some(task);\n         this.enqueue_cleanup_job(DoNothing);\n \n-        local_sched::put(this);\n+        Local::put(this);\n \n         // Take pointers to both the task and scheduler's saved registers.\n         unsafe {\n-            let sched = local_sched::unsafe_borrow();\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             let (sched_context, _, next_task_context) = (*sched).get_contexts();\n             let next_task_context = next_task_context.unwrap();\n             // Context switch to the task, restoring it's registers\n             // and saving the scheduler's\n             Context::swap(sched_context, next_task_context);\n \n-            let sched = local_sched::unsafe_borrow();\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             // The running task should have passed ownership elsewhere\n             assert!((*sched).current_task.is_none());\n \n@@ -235,16 +232,16 @@ pub impl Scheduler {\n             this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n         }\n \n-        local_sched::put(this);\n+        Local::put(this);\n \n         unsafe {\n-            let sched = local_sched::unsafe_borrow();\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             let (sched_context, last_task_context, _) = (*sched).get_contexts();\n             let last_task_context = last_task_context.unwrap();\n             Context::swap(last_task_context, sched_context);\n \n             // We could be executing in a different thread now\n-            let sched = local_sched::unsafe_borrow();\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             (*sched).run_cleanup_job();\n         }\n     }\n@@ -264,17 +261,17 @@ pub impl Scheduler {\n         this.enqueue_cleanup_job(GiveTask(old_running_task, f_opaque));\n         this.current_task = Some(next_task);\n \n-        local_sched::put(this);\n+        Local::put(this);\n \n         unsafe {\n-            let sched = local_sched::unsafe_borrow();\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             let (_, last_task_context, next_task_context) = (*sched).get_contexts();\n             let last_task_context = last_task_context.unwrap();\n             let next_task_context = next_task_context.unwrap();\n             Context::swap(last_task_context, next_task_context);\n \n             // We could be executing in a different thread now\n-            let sched = local_sched::unsafe_borrow();\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             (*sched).run_cleanup_job();\n         }\n     }\n@@ -350,16 +347,16 @@ pub struct Coroutine {\n     /// the task is dead\n     priv saved_context: Context,\n     /// The heap, GC, unwinding, local storage, logging\n-    local_services: LocalServices\n+    task: ~Task\n }\n \n pub impl Coroutine {\n     fn new(stack_pool: &mut StackPool, start: ~fn()) -> Coroutine {\n-        Coroutine::with_local(stack_pool, LocalServices::new(), start)\n+        Coroutine::with_task(stack_pool, ~Task::new(), start)\n     }\n \n-    fn with_local(stack_pool: &mut StackPool,\n-                  local_services: LocalServices,\n+    fn with_task(stack_pool: &mut StackPool,\n+                  task: ~Task,\n                   start: ~fn()) -> Coroutine {\n         let start = Coroutine::build_start_wrapper(start);\n         let mut stack = stack_pool.take_segment(MIN_STACK_SIZE);\n@@ -368,7 +365,7 @@ pub impl Coroutine {\n         return Coroutine {\n             current_stack_segment: stack,\n             saved_context: initial_context,\n-            local_services: local_services\n+            task: task\n         };\n     }\n \n@@ -379,16 +376,16 @@ pub impl Coroutine {\n             // context switch to the task. The previous context may\n             // have asked us to do some cleanup.\n             unsafe {\n-                let sched = local_sched::unsafe_borrow();\n+                let sched = Local::unsafe_borrow::<Scheduler>();\n                 (*sched).run_cleanup_job();\n \n-                let sched = local_sched::unsafe_borrow();\n+                let sched = Local::unsafe_borrow::<Scheduler>();\n                 let task = (*sched).current_task.get_mut_ref();\n                 // FIXME #6141: shouldn't neet to put `start()` in another closure\n-                task.local_services.run(||start());\n+                task.task.run(||start());\n             }\n \n-            let sched = local_sched::take();\n+            let sched = Local::take::<Scheduler>();\n             sched.terminate_current_task();\n         };\n         return wrapper;\n@@ -411,6 +408,7 @@ mod test {\n     use rt::uv::uvio::UvEventLoop;\n     use unstable::run_in_bare_thread;\n     use task::spawn;\n+    use rt::local::Local;\n     use rt::test::*;\n     use super::*;\n \n@@ -458,14 +456,14 @@ mod test {\n             let mut sched = ~UvEventLoop::new_scheduler();\n             let task1 = ~do Coroutine::new(&mut sched.stack_pool) {\n                 unsafe { *count_ptr = *count_ptr + 1; }\n-                let mut sched = local_sched::take();\n+                let mut sched = Local::take::<Scheduler>();\n                 let task2 = ~do Coroutine::new(&mut sched.stack_pool) {\n                     unsafe { *count_ptr = *count_ptr + 1; }\n                 };\n                 // Context switch directly to the new task\n                 do sched.switch_running_tasks_and_then(task2) |task1| {\n                     let task1 = Cell(task1);\n-                    do local_sched::borrow |sched| {\n+                    do Local::borrow::<Scheduler> |sched| {\n                         sched.enqueue_task(task1.take());\n                     }\n                 }\n@@ -495,7 +493,7 @@ mod test {\n             assert_eq!(count, MAX);\n \n             fn run_task(count_ptr: *mut int) {\n-                do local_sched::borrow |sched| {\n+                do Local::borrow::<Scheduler> |sched| {\n                     let task = ~do Coroutine::new(&mut sched.stack_pool) {\n                         unsafe {\n                             *count_ptr = *count_ptr + 1;\n@@ -515,11 +513,11 @@ mod test {\n         do run_in_bare_thread {\n             let mut sched = ~UvEventLoop::new_scheduler();\n             let task = ~do Coroutine::new(&mut sched.stack_pool) {\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 assert!(sched.in_task_context());\n                 do sched.deschedule_running_task_and_then() |task| {\n                     let task = Cell(task);\n-                    do local_sched::borrow |sched| {\n+                    do Local::borrow::<Scheduler> |sched| {\n                         assert!(!sched.in_task_context());\n                         sched.enqueue_task(task.take());\n                     }\n@@ -538,17 +536,17 @@ mod test {\n         // exit before emptying the work queue\n         do run_in_newsched_task {\n             do spawn {\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 do sched.deschedule_running_task_and_then |task| {\n-                    let mut sched = local_sched::take();\n+                    let mut sched = Local::take::<Scheduler>();\n                     let task = Cell(task);\n                     do sched.event_loop.callback_ms(10) {\n                         rtdebug!(\"in callback\");\n-                        let mut sched = local_sched::take();\n+                        let mut sched = Local::take::<Scheduler>();\n                         sched.enqueue_task(task.take());\n-                        local_sched::put(sched);\n+                        Local::put(sched);\n                     }\n-                    local_sched::put(sched);\n+                    Local::put(sched);\n                 }\n             }\n         }"}, {"sha": "0314137fc7f9271151b7765aa590e7ceea118fe9", "filename": "src/libcore/rt/task.rs", "status": "renamed", "additions": 17, "deletions": 57, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftask.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -13,19 +13,15 @@\n //! local storage, and logging. Even a 'freestanding' Rust would likely want\n //! to implement this.\n \n-//! Local services may exist in at least three different contexts:\n-//! when running as a task, when running in the scheduler's context,\n-//! or when running outside of a scheduler but with local services\n-//! (freestanding rust with local services?).\n-\n use prelude::*;\n use libc::{c_void, uintptr_t};\n use cast::transmute;\n-use super::sched::local_sched;\n+use super::sched::Scheduler;\n+use rt::local::Local;\n use super::local_heap::LocalHeap;\n use rt::logging::StdErrLogger;\n \n-pub struct LocalServices {\n+pub struct Task {\n     heap: LocalHeap,\n     gc: GarbageCollector,\n     storage: LocalStorage,\n@@ -41,9 +37,9 @@ pub struct Unwinder {\n     unwinding: bool,\n }\n \n-impl LocalServices {\n-    pub fn new() -> LocalServices {\n-        LocalServices {\n+impl Task {\n+    pub fn new() -> Task {\n+        Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n@@ -53,8 +49,8 @@ impl LocalServices {\n         }\n     }\n \n-    pub fn without_unwinding() -> LocalServices {\n-        LocalServices {\n+    pub fn without_unwinding() -> Task {\n+        Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n@@ -66,9 +62,9 @@ impl LocalServices {\n \n     pub fn run(&mut self, f: &fn()) {\n         // This is just an assertion that `run` was called unsafely\n-        // and this instance of LocalServices is still accessible.\n-        do borrow_local_services |sched| {\n-            assert!(ptr::ref_eq(sched, self));\n+        // and this instance of Task is still accessible.\n+        do Local::borrow::<Task> |task| {\n+            assert!(ptr::ref_eq(task, self));\n         }\n \n         match self.unwinder {\n@@ -86,14 +82,14 @@ impl LocalServices {\n \n     /// Must be called manually before finalization to clean up\n     /// thread-local resources. Some of the routines here expect\n-    /// LocalServices to be available recursively so this must be\n-    /// called unsafely, without removing LocalServices from\n+    /// Task to be available recursively so this must be\n+    /// called unsafely, without removing Task from\n     /// thread-local-storage.\n     fn destroy(&mut self) {\n         // This is just an assertion that `destroy` was called unsafely\n-        // and this instance of LocalServices is still accessible.\n-        do borrow_local_services |sched| {\n-            assert!(ptr::ref_eq(sched, self));\n+        // and this instance of Task is still accessible.\n+        do Local::borrow::<Task> |task| {\n+            assert!(ptr::ref_eq(task, self));\n         }\n         match self.storage {\n             LocalStorage(ptr, Some(ref dtor)) => {\n@@ -105,7 +101,7 @@ impl LocalServices {\n     }\n }\n \n-impl Drop for LocalServices {\n+impl Drop for Task {\n     fn finalize(&self) { assert!(self.destroyed) }\n }\n \n@@ -154,42 +150,6 @@ impl Unwinder {\n     }\n }\n \n-/// Borrow a pointer to the installed local services.\n-/// Fails (likely aborting the process) if local services are not available.\n-pub fn borrow_local_services(f: &fn(&mut LocalServices)) {\n-    do local_sched::borrow |sched| {\n-        match sched.current_task {\n-            Some(~ref mut task) => {\n-                f(&mut task.local_services)\n-            }\n-            None => {\n-                fail!(\"no local services for schedulers yet\")\n-            }\n-        }\n-    }\n-}\n-\n-pub unsafe fn unsafe_borrow_local_services() -> *mut LocalServices {\n-    match (*local_sched::unsafe_borrow()).current_task {\n-        Some(~ref mut task) => {\n-            let s: *mut LocalServices = &mut task.local_services;\n-            return s;\n-        }\n-        None => {\n-            // Don't fail. Infinite recursion\n-            abort!(\"no local services for schedulers yet\")\n-        }\n-    }\n-}\n-\n-pub unsafe fn unsafe_try_borrow_local_services() -> Option<*mut LocalServices> {\n-    if local_sched::exists() {\n-        Some(unsafe_borrow_local_services())\n-    } else {\n-        None\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use rt::test::*;", "previous_filename": "src/libcore/rt/local_services.rs"}, {"sha": "c60ae2bfeffc8bb06500750dd2dc98a7fdbfd444", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -13,8 +13,9 @@ use option::*;\n use cell::Cell;\n use result::{Result, Ok, Err};\n use super::io::net::ip::{IpAddr, Ipv4};\n-use rt::local_services::LocalServices;\n+use rt::task::Task;\n use rt::thread::Thread;\n+use rt::local::Local;\n \n /// Creates a new scheduler in a new thread and runs a task in it,\n /// then waits for the scheduler to exit. Failure of the task\n@@ -28,9 +29,9 @@ pub fn run_in_newsched_task(f: ~fn()) {\n \n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~Coroutine::with_local(&mut sched.stack_pool,\n-                                          LocalServices::without_unwinding(),\n-                                          f.take());\n+        let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                         ~Task::without_unwinding(),\n+                                         f.take());\n         sched.enqueue_task(task);\n         sched.run();\n     }\n@@ -40,13 +41,13 @@ pub fn run_in_newsched_task(f: ~fn()) {\n pub fn spawntask(f: ~fn()) {\n     use super::sched::*;\n \n-    let mut sched = local_sched::take();\n-    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n-                                      LocalServices::without_unwinding(),\n-                                      f);\n+    let mut sched = Local::take::<Scheduler>();\n+    let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                     ~Task::without_unwinding(),\n+                                     f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n-        let sched = local_sched::take();\n+        let sched = Local::take::<Scheduler>();\n         sched.schedule_new_task(task.take());\n     }\n }\n@@ -55,13 +56,13 @@ pub fn spawntask(f: ~fn()) {\n pub fn spawntask_immediately(f: ~fn()) {\n     use super::sched::*;\n \n-    let mut sched = local_sched::take();\n-    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n-                                      LocalServices::without_unwinding(),\n-                                      f);\n+    let mut sched = Local::take::<Scheduler>();\n+    let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                     ~Task::without_unwinding(),\n+                                     f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n-        do local_sched::borrow |sched| {\n+        do Local::borrow::<Scheduler> |sched| {\n             sched.enqueue_task(task.take());\n         }\n     }\n@@ -71,13 +72,13 @@ pub fn spawntask_immediately(f: ~fn()) {\n pub fn spawntask_later(f: ~fn()) {\n     use super::sched::*;\n \n-    let mut sched = local_sched::take();\n-    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n-                                      LocalServices::without_unwinding(),\n-                                      f);\n+    let mut sched = Local::take::<Scheduler>();\n+    let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                     ~Task::without_unwinding(),\n+                                     f);\n \n     sched.enqueue_task(task);\n-    local_sched::put(sched);\n+    Local::put(sched);\n }\n \n /// Spawn a task and either run it immediately or run it later\n@@ -88,21 +89,21 @@ pub fn spawntask_random(f: ~fn()) {\n     let mut rng = rng();\n     let run_now: bool = Rand::rand(&mut rng);\n \n-    let mut sched = local_sched::take();\n-    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n-                                      LocalServices::without_unwinding(),\n-                                      f);\n+    let mut sched = Local::take::<Scheduler>();\n+    let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                     ~Task::without_unwinding(),\n+                                     f);\n \n     if run_now {\n         do sched.switch_running_tasks_and_then(task) |task| {\n             let task = Cell(task);\n-            do local_sched::borrow |sched| {\n+            do Local::borrow::<Scheduler> |sched| {\n                 sched.enqueue_task(task.take());\n             }\n         }\n     } else {\n         sched.enqueue_task(task);\n-        local_sched::put(sched);\n+        Local::put(sched);\n     }\n }\n \n@@ -120,21 +121,21 @@ pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n \n     // Switch to the scheduler\n     let f = Cell(Cell(f));\n-    let sched = local_sched::take();\n+    let sched = Local::take::<Scheduler>();\n     do sched.deschedule_running_task_and_then() |old_task| {\n         let old_task = Cell(old_task);\n         let f = f.take();\n-        let mut sched = local_sched::take();\n+        let mut sched = Local::take::<Scheduler>();\n         let new_task = ~do Coroutine::new(&mut sched.stack_pool) {\n             do (|| {\n                 (f.take())()\n             }).finally {\n                 // Check for failure then resume the parent task\n                 unsafe { *failed_ptr = task::failing(); }\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 do sched.switch_running_tasks_and_then(old_task.take()) |new_task| {\n                     let new_task = Cell(new_task);\n-                    do local_sched::borrow |sched| {\n+                    do Local::borrow::<Scheduler> |sched| {\n                         sched.enqueue_task(new_task.take());\n                     }\n                 }\n@@ -155,9 +156,9 @@ pub fn spawntask_thread(f: ~fn()) -> Thread {\n     let f = Cell(f);\n     let thread = do Thread::start {\n         let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~Coroutine::with_local(&mut sched.stack_pool,\n-                                          LocalServices::without_unwinding(),\n-                                          f.take());\n+        let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                         ~Task::without_unwinding(),\n+                                         f.take());\n         sched.enqueue_task(task);\n         sched.run();\n     };"}, {"sha": "b2f475a69660573b20924fa5bf44e54868d45064", "filename": "src/libcore/rt/tube.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftube.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -16,9 +16,9 @@\n use option::*;\n use clone::Clone;\n use super::rc::RC;\n-use rt::sched::Coroutine;\n+use rt::sched::{Scheduler, Coroutine};\n use rt::{context, TaskContext, SchedulerContext};\n-use rt::local_sched;\n+use rt::local::Local;\n use vec::OwnedVector;\n use container::Container;\n \n@@ -53,7 +53,7 @@ impl<T> Tube<T> {\n                 // There's a waiting task. Wake it up\n                 rtdebug!(\"waking blocked tube\");\n                 let task = (*state).blocked_task.swap_unwrap();\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 sched.resume_task_immediately(task);\n             }\n         }\n@@ -71,7 +71,7 @@ impl<T> Tube<T> {\n                 rtdebug!(\"blocking on tube recv\");\n                 assert!(self.p.refcount() > 1); // There better be somebody to wake us up\n                 assert!((*state).blocked_task.is_none());\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 do sched.deschedule_running_task_and_then |task| {\n                     (*state).blocked_task = Some(task);\n                 }\n@@ -94,9 +94,10 @@ impl<T> Clone for Tube<T> {\n mod test {\n     use int;\n     use cell::Cell;\n-    use rt::local_sched;\n     use rt::test::*;\n     use rt::rtio::EventLoop;\n+    use rt::sched::Scheduler;\n+    use rt::local::Local;\n     use super::*;\n \n     #[test]\n@@ -105,11 +106,11 @@ mod test {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n             let tube_clone_cell = Cell(tube_clone);\n-            let sched = local_sched::take();\n+            let sched = Local::take::<Scheduler>();\n             do sched.deschedule_running_task_and_then |task| {\n                 let mut tube_clone = tube_clone_cell.take();\n                 tube_clone.send(1);\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 sched.resume_task_immediately(task);\n             }\n \n@@ -123,10 +124,10 @@ mod test {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n             let tube_clone = Cell(Cell(Cell(tube_clone)));\n-            let sched = local_sched::take();\n+            let sched = Local::take::<Scheduler>();\n             do sched.deschedule_running_task_and_then |task| {\n                 let tube_clone = tube_clone.take();\n-                do local_sched::borrow |sched| {\n+                do Local::borrow::<Scheduler> |sched| {\n                     let tube_clone = tube_clone.take();\n                     do sched.event_loop.callback {\n                         let mut tube_clone = tube_clone.take();\n@@ -135,7 +136,7 @@ mod test {\n                         tube_clone.send(1);\n                     }\n                 }\n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 sched.resume_task_immediately(task);\n             }\n \n@@ -151,15 +152,15 @@ mod test {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n             let tube_clone = Cell(tube_clone);\n-            let sched = local_sched::take();\n+            let sched = Local::take::<Scheduler>();\n             do sched.deschedule_running_task_and_then |task| {\n                 callback_send(tube_clone.take(), 0);\n \n                 fn callback_send(tube: Tube<int>, i: int) {\n                     if i == 100 { return; }\n \n                     let tube = Cell(Cell(tube));\n-                    do local_sched::borrow |sched| {\n+                    do Local::borrow::<Scheduler> |sched| {\n                         let tube = tube.take();\n                         do sched.event_loop.callback {\n                             let mut tube = tube.take();\n@@ -171,7 +172,7 @@ mod test {\n                     }\n                 }\n \n-                let sched = local_sched::take();\n+                let sched = Local::take::<Scheduler>();\n                 sched.resume_task_immediately(task);\n             }\n "}, {"sha": "cacd67314ebac9a0dde6ac6ca540120cc79b6cd5", "filename": "src/libcore/rt/uv/uvio.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -19,9 +19,10 @@ use rt::io::net::ip::IpAddr;\n use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n use rt::rtio::*;\n-use rt::sched::{Scheduler, local_sched};\n+use rt::sched::Scheduler;\n use rt::io::{standard_error, OtherIoError};\n use rt::tube::Tube;\n+use rt::local::Local;\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use uint;\n@@ -118,14 +119,14 @@ impl IoFactory for UvIoFactory {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n \n-        let scheduler = local_sched::take();\n+        let scheduler = Local::take::<Scheduler>();\n         assert!(scheduler.in_task_context());\n \n         // Block this task and take ownership, switch to scheduler context\n         do scheduler.deschedule_running_task_and_then |task| {\n \n             rtdebug!(\"connect: entered scheduler context\");\n-            do local_sched::borrow |scheduler| {\n+            do Local::borrow::<Scheduler> |scheduler| {\n                 assert!(!scheduler.in_task_context());\n             }\n             let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n@@ -142,15 +143,15 @@ impl IoFactory for UvIoFactory {\n                     unsafe { (*result_cell_ptr).put_back(res); }\n \n                     // Context switch\n-                    let scheduler = local_sched::take();\n+                    let scheduler = Local::take::<Scheduler>();\n                     scheduler.resume_task_immediately(task_cell.take());\n                 } else {\n                     rtdebug!(\"status is some\");\n                     let task_cell = Cell(task_cell.take());\n                     do stream_watcher.close {\n                         let res = Err(uv_error_to_io_error(status.get()));\n                         unsafe { (*result_cell_ptr).put_back(res); }\n-                        let scheduler = local_sched::take();\n+                        let scheduler = Local::take::<Scheduler>();\n                         scheduler.resume_task_immediately(task_cell.take());\n                     }\n                 };\n@@ -166,11 +167,11 @@ impl IoFactory for UvIoFactory {\n         match watcher.bind(addr) {\n             Ok(_) => Ok(~UvTcpListener::new(watcher)),\n             Err(uverr) => {\n-                let scheduler = local_sched::take();\n+                let scheduler = Local::take::<Scheduler>();\n                 do scheduler.deschedule_running_task_and_then |task| {\n                     let task_cell = Cell(task);\n                     do watcher.as_stream().close {\n-                        let scheduler = local_sched::take();\n+                        let scheduler = Local::take::<Scheduler>();\n                         scheduler.resume_task_immediately(task_cell.take());\n                     }\n                 }\n@@ -202,11 +203,11 @@ impl UvTcpListener {\n impl Drop for UvTcpListener {\n     fn finalize(&self) {\n         let watcher = self.watcher();\n-        let scheduler = local_sched::take();\n+        let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |task| {\n             let task_cell = Cell(task);\n             do watcher.as_stream().close {\n-                let scheduler = local_sched::take();\n+                let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -264,11 +265,11 @@ impl Drop for UvTcpStream {\n     fn finalize(&self) {\n         rtdebug!(\"closing tcp stream\");\n         let watcher = self.watcher();\n-        let scheduler = local_sched::take();\n+        let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |task| {\n             let task_cell = Cell(task);\n             do watcher.close {\n-                let scheduler = local_sched::take();\n+                let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -280,13 +281,13 @@ impl RtioTcpStream for UvTcpStream {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n-        let scheduler = local_sched::take();\n+        let scheduler = Local::take::<Scheduler>();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&mut [u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |task| {\n             rtdebug!(\"read: entered scheduler context\");\n-            do local_sched::borrow |scheduler| {\n+            do Local::borrow::<Scheduler> |scheduler| {\n                 assert!(!scheduler.in_task_context());\n             }\n             let mut watcher = watcher;\n@@ -314,7 +315,7 @@ impl RtioTcpStream for UvTcpStream {\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let scheduler = local_sched::take();\n+                let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -326,7 +327,7 @@ impl RtioTcpStream for UvTcpStream {\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let scheduler = local_sched::take();\n+        let scheduler = Local::take::<Scheduler>();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&[u8] = &buf;\n@@ -343,7 +344,7 @@ impl RtioTcpStream for UvTcpStream {\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let scheduler = local_sched::take();\n+                let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -357,7 +358,7 @@ impl RtioTcpStream for UvTcpStream {\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {\n         unsafe {\n-            let io = local_sched::unsafe_borrow_io();\n+            let io = Local::unsafe_borrow::<IoFactoryObject>();\n             let addr = next_test_ip4();\n             let maybe_chan = (*io).tcp_connect(addr);\n             assert!(maybe_chan.is_err());\n@@ -373,7 +374,7 @@ fn test_simple_tcp_server_and_client() {\n         // Start the server first so it's listening when we connect\n         do spawntask_immediately {\n             unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n                 let mut stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n@@ -388,7 +389,7 @@ fn test_simple_tcp_server_and_client() {\n \n         do spawntask_immediately {\n             unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             }\n@@ -402,7 +403,7 @@ fn test_read_and_block() {\n         let addr = next_test_ip4();\n \n         do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n+            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n             let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n             let mut stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n@@ -420,13 +421,13 @@ fn test_read_and_block() {\n                 }\n                 reads += 1;\n \n-                let scheduler = local_sched::take();\n+                let scheduler = Local::take::<Scheduler>();\n                 // Yield to the other task in hopes that it\n                 // will trigger a read callback while we are\n                 // not ready for it\n                 do scheduler.deschedule_running_task_and_then |task| {\n                     let task = Cell(task);\n-                    do local_sched::borrow |scheduler| {\n+                    do Local::borrow::<Scheduler> |scheduler| {\n                         scheduler.enqueue_task(task.take());\n                     }\n                 }\n@@ -438,7 +439,7 @@ fn test_read_and_block() {\n \n         do spawntask_immediately {\n             unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -458,7 +459,7 @@ fn test_read_read_read() {\n \n         do spawntask_immediately {\n             unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n                 let mut stream = listener.accept().unwrap();\n                 let buf = [1, .. 2048];\n@@ -472,7 +473,7 @@ fn test_read_read_read() {\n \n         do spawntask_immediately {\n             unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut stream = (*io).tcp_connect(addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let mut total_bytes_read = 0;"}, {"sha": "e9eb663392b2453bd3cdca5e179c774579bd9567", "filename": "src/libcore/rt/work_queue.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fwork_queue.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -11,43 +11,57 @@\n use container::Container;\n use option::*;\n use vec::OwnedVector;\n+use unstable::sync::{Exclusive, exclusive};\n+use cell::Cell;\n+use kinds::Owned;\n+use clone::Clone;\n \n pub struct WorkQueue<T> {\n-    priv queue: ~[T]\n+    // XXX: Another mystery bug fixed by boxing this lock\n+    priv queue: ~Exclusive<~[T]>\n }\n \n-pub impl<T> WorkQueue<T> {\n+pub impl<T: Owned> WorkQueue<T> {\n     fn new() -> WorkQueue<T> {\n         WorkQueue {\n-            queue: ~[]\n+            queue: ~exclusive(~[])\n         }\n     }\n \n-    fn push_back(&mut self, value: T) {\n-        self.queue.push(value)\n+    fn push(&mut self, value: T) {\n+        let value = Cell(value);\n+        self.queue.with(|q| q.unshift(value.take()) );\n     }\n \n-    fn pop_back(&mut self) -> Option<T> {\n-        if !self.queue.is_empty() {\n-            Some(self.queue.pop())\n-        } else {\n-            None\n+    fn pop(&mut self) -> Option<T> {\n+        do self.queue.with |q| {\n+            if !q.is_empty() {\n+                Some(q.shift())\n+            } else {\n+                None\n+            }\n         }\n     }\n \n-    fn push_front(&mut self, value: T) {\n-        self.queue.unshift(value)\n-    }\n-\n-    fn pop_front(&mut self) -> Option<T> {\n-        if !self.queue.is_empty() {\n-            Some(self.queue.shift())\n-        } else {\n-            None\n+    fn steal(&mut self) -> Option<T> {\n+        do self.queue.with |q| {\n+            if !q.is_empty() {\n+                Some(q.pop())\n+            } else {\n+                None\n+            }\n         }\n     }\n \n     fn is_empty(&self) -> bool {\n-        return self.queue.is_empty();\n+        self.queue.with_imm(|q| q.is_empty() )\n+    }\n+}\n+\n+impl<T> Clone for WorkQueue<T> {\n+    fn clone(&self) -> WorkQueue<T> {\n+        WorkQueue {\n+            queue: self.queue.clone()\n+        }\n     }\n }"}, {"sha": "137070ce20211a4a4e372ad4aff6efe66c590a6b", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -195,7 +195,8 @@ impl FailWithCause for &'static str {\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     use option::Option;\n     use rt::{context, OldTaskContext, TaskContext};\n-    use rt::local_services::{unsafe_borrow_local_services, Unwinder};\n+    use rt::task::{Task, Unwinder};\n+    use rt::local::Local;\n \n     let context = context();\n     match context {\n@@ -224,8 +225,8 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n \n                 gc::cleanup_stack_for_failure();\n \n-                let local_services = unsafe_borrow_local_services();\n-                let unwinder: &mut Option<Unwinder> = &mut (*local_services).unwinder;\n+                let task = Local::unsafe_borrow::<Task>();\n+                let unwinder: &mut Option<Unwinder> = &mut (*task).unwinder;\n                 match *unwinder {\n                     Some(ref mut unwinder) => unwinder.begin_unwind(),\n                     None => abort!(\"failure without unwinder. aborting process\")"}, {"sha": "2f97eaacf4be2ab0bc1246d711d5a51a6e55b6bd", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -18,7 +18,7 @@ use task::rt;\n use local_data::LocalDataKey;\n \n use super::rt::rust_task;\n-use rt::local_services::LocalStorage;\n+use rt::task::{Task, LocalStorage};\n \n pub enum Handle {\n     OldHandle(*rust_task),\n@@ -28,15 +28,15 @@ pub enum Handle {\n impl Handle {\n     pub fn new() -> Handle {\n         use rt::{context, OldTaskContext};\n-        use rt::local_services::unsafe_borrow_local_services;\n+        use rt::local::Local;\n         unsafe {\n             match context() {\n                 OldTaskContext => {\n                     OldHandle(rt::rust_get_task())\n                 }\n                 _ => {\n-                    let local_services = unsafe_borrow_local_services();\n-                    NewHandle(&mut (*local_services).storage)\n+                    let task = Local::unsafe_borrow::<Task>();\n+                    NewHandle(&mut (*task).storage)\n                 }\n             }\n         }"}, {"sha": "490a69248eecb074812f72d11ce3ca59eff83706", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -504,7 +504,8 @@ pub fn failing() -> bool {\n     //! True if the running task has failed\n \n     use rt::{context, OldTaskContext};\n-    use rt::local_services::borrow_local_services;\n+    use rt::local::Local;\n+    use rt::task::Task;\n \n     match context() {\n         OldTaskContext => {\n@@ -514,7 +515,7 @@ pub fn failing() -> bool {\n         }\n         _ => {\n             let mut unwinding = false;\n-            do borrow_local_services |local| {\n+            do Local::borrow::<Task> |local| {\n                 unwinding = match local.unwinder {\n                     Some(unwinder) => {\n                         unwinder.unwinding"}, {"sha": "81e5af5caab111a756fd06dd7b774b0cdb777512", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -90,6 +90,7 @@ use task::unkillable;\n use uint;\n use util;\n use unstable::sync::{Exclusive, exclusive};\n+use rt::local::Local;\n \n #[cfg(test)] use task::default_task_opts;\n \n@@ -575,7 +576,7 @@ pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n fn spawn_raw_newsched(_opts: TaskOpts, f: ~fn()) {\n     use rt::sched::*;\n \n-    let mut sched = local_sched::take();\n+    let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::new(&mut sched.stack_pool, f);\n     sched.schedule_new_task(task);\n }"}, {"sha": "350b18d4541698a48b704340249faad1fa3d057b", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -17,7 +17,8 @@ use managed::raw::BoxRepr;\n use str;\n use sys;\n use rt::{context, OldTaskContext};\n-use rt::local_services::borrow_local_services;\n+use rt::task::Task;\n+use rt::local::Local;\n use option::{Option, Some, None};\n use io;\n use rt::global_heap;\n@@ -243,8 +244,8 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n         }\n         _ => {\n             let mut alloc = ::ptr::null();\n-            do borrow_local_services |srv| {\n-                alloc = srv.heap.alloc(td as *c_void, size as uint) as *c_char;\n+            do Local::borrow::<Task> |task| {\n+                alloc = task.heap.alloc(td as *c_void, size as uint) as *c_char;\n             }\n             return alloc;\n         }\n@@ -261,8 +262,8 @@ pub unsafe fn local_free(ptr: *c_char) {\n             rustrt::rust_upcall_free_noswitch(ptr);\n         }\n         _ => {\n-            do borrow_local_services |srv| {\n-                srv.heap.free(ptr as *c_void);\n+            do Local::borrow::<Task> |task| {\n+                task.heap.free(ptr as *c_void);\n             }\n         }\n     }"}, {"sha": "a2f253550af1614a0e784602a8f6566ef8dcdbd9", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -840,9 +840,9 @@ rust_get_rt_tls_key() {\n     return &rt_key;\n }\n \n-// Initialize the global state required by the new scheduler\n+// Initialize the TLS key used by the new scheduler\n extern \"C\" CDECL void\n-rust_initialize_global_state() {\n+rust_initialize_rt_tls_key() {\n \n     static lock_and_signal init_lock;\n     static bool initialized = false;"}, {"sha": "e3e522aa7ceec6d5dfa1a72431b3ff42a5ae86ae", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/7abcc142e5da1b87c59a1510fa87aefc4122bd6d/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=7abcc142e5da1b87c59a1510fa87aefc4122bd6d", "patch": "@@ -222,7 +222,7 @@ rust_uv_ip4_addrp\n rust_uv_ip6_addrp\n rust_uv_free_ip4_addr\n rust_uv_free_ip6_addr\n-rust_initialize_global_state\n+rust_initialize_rt_tls_key\n rust_dbg_next_port\n rust_new_memory_region\n rust_delete_memory_region"}]}