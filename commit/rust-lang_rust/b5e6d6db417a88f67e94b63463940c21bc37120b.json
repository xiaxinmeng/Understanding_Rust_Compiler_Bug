{"sha": "b5e6d6db417a88f67e94b63463940c21bc37120b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZTZkNmRiNDE3YTg4ZjY3ZTk0YjYzNDYzOTQwYzIxYmMzNzEyMGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-06T21:41:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-06T21:41:50Z"}, "message": "Auto merge of #5134 - flip1995:snippet_block, r=phansch\n\nMake it possible to correctly indent snippet_block snippets\n\nThis adds a `indent_relative_to` arg to the `{snippet,expr}_block` functions. This makes it possible to keep the correct indentation of block like suggestions.\n\nIn addition, this makes the `trim_multiline` function private and adds a `indent_of` function, to get the indentation of the first line of a span.\n\nThe suggestion of `needless_continue` cannot be made auto applicable, since it would be also necessary to remove code following the linted expression. (Well, maybe it is possible, but I don't know how to do it. Expanding the suggestion span to the last expression, that should be removed didn't work)\n\nchangelog: Improve suggestions, when blocks of code are involved", "tree": {"sha": "87ebcb0f8d59c8a2c75ccf817ca01699de05fd52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87ebcb0f8d59c8a2c75ccf817ca01699de05fd52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5e6d6db417a88f67e94b63463940c21bc37120b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5e6d6db417a88f67e94b63463940c21bc37120b", "html_url": "https://github.com/rust-lang/rust/commit/b5e6d6db417a88f67e94b63463940c21bc37120b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5e6d6db417a88f67e94b63463940c21bc37120b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee842df61df91f3ed3e33a23f8393c47d384ef40", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee842df61df91f3ed3e33a23f8393c47d384ef40", "html_url": "https://github.com/rust-lang/rust/commit/ee842df61df91f3ed3e33a23f8393c47d384ef40"}, {"sha": "e23881e1310f7fe02aeeecf3510a80cbac5aa808", "url": "https://api.github.com/repos/rust-lang/rust/commits/e23881e1310f7fe02aeeecf3510a80cbac5aa808", "html_url": "https://github.com/rust-lang/rust/commit/e23881e1310f7fe02aeeecf3510a80cbac5aa808"}], "stats": {"total": 1300, "additions": 700, "deletions": 600}, "files": [{"sha": "6f67acb29219e806c2e04bcbb5e9d0033458c68e", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -2,7 +2,7 @@\n \n use crate::reexport::*;\n use crate::utils::{\n-    is_present_in_source, last_line_of_span, match_def_path, paths, snippet_opt, span_lint, span_lint_and_sugg,\n+    first_line_of_span, is_present_in_source, match_def_path, paths, snippet_opt, span_lint, span_lint_and_sugg,\n     span_lint_and_then, without_block_comments,\n };\n use if_chain::if_chain;\n@@ -261,7 +261,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Attributes {\n                                             _ => {},\n                                         }\n                                     }\n-                                    let line_span = last_line_of_span(cx, attr.span);\n+                                    let line_span = first_line_of_span(cx, attr.span);\n \n                                     if let Some(mut sugg) = snippet_opt(cx, line_span) {\n                                         if sugg.contains(\"#[\") {"}, {"sha": "325e12617142c7e76e1cd2631edfe2a20cab88f4", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -2,6 +2,7 @@ use crate::utils::*;\n use matches::matches;\n use rustc::hir::map::Map;\n use rustc::lint::in_external_macro;\n+use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::*;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -79,8 +80,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        if let Some((check, then, _)) = higher::if_block(&expr) {\n-            if let ExprKind::Block(block, _) = &check.kind {\n+        if let Some((cond, _, _)) = higher::if_block(&expr) {\n+            if let ExprKind::Block(block, _) = &cond.kind {\n                 if block.rules == BlockCheckMode::DefaultBlock {\n                     if block.stmts.is_empty() {\n                         if let Some(ex) = &block.expr {\n@@ -89,16 +90,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                             if expr.span.from_expansion() || differing_macro_contexts(expr.span, ex.span) {\n                                 return;\n                             }\n-                            span_lint_and_help(\n+                            let mut applicability = Applicability::MachineApplicable;\n+                            span_lint_and_sugg(\n                                 cx,\n                                 BLOCK_IN_IF_CONDITION_EXPR,\n-                                check.span,\n+                                cond.span,\n                                 BRACED_EXPR_MESSAGE,\n-                                &format!(\n-                                    \"try\\nif {} {} ... \",\n-                                    snippet_block(cx, ex.span, \"..\"),\n-                                    snippet_block(cx, then.span, \"..\")\n+                                \"try\",\n+                                format!(\n+                                    \"{}\",\n+                                    snippet_block_with_applicability(\n+                                        cx,\n+                                        ex.span,\n+                                        \"..\",\n+                                        Some(expr.span),\n+                                        &mut applicability\n+                                    )\n                                 ),\n+                                applicability,\n                             );\n                         }\n                     } else {\n@@ -107,22 +116,30 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                             return;\n                         }\n                         // move block higher\n-                        span_lint_and_help(\n+                        let mut applicability = Applicability::MachineApplicable;\n+                        span_lint_and_sugg(\n                             cx,\n                             BLOCK_IN_IF_CONDITION_STMT,\n-                            check.span,\n+                            expr.span.with_hi(cond.span.hi()),\n                             COMPLEX_BLOCK_MESSAGE,\n-                            &format!(\n-                                \"try\\nlet res = {};\\nif res {} ... \",\n-                                snippet_block(cx, block.span, \"..\"),\n-                                snippet_block(cx, then.span, \"..\")\n+                            \"try\",\n+                            format!(\n+                                \"let res = {}; if res\",\n+                                snippet_block_with_applicability(\n+                                    cx,\n+                                    block.span,\n+                                    \"..\",\n+                                    Some(expr.span),\n+                                    &mut applicability\n+                                ),\n                             ),\n+                            applicability,\n                         );\n                     }\n                 }\n             } else {\n                 let mut visitor = ExVisitor { found_block: None, cx };\n-                walk_expr(&mut visitor, check);\n+                walk_expr(&mut visitor, cond);\n                 if let Some(block) = visitor.found_block {\n                     span_lint(cx, BLOCK_IN_IF_CONDITION_STMT, block.span, COMPLEX_BLOCK_MESSAGE);\n                 }"}, {"sha": "c6ca85b0cdf43a2fcded6ace944c25278ee10076", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -95,7 +95,7 @@ fn check_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n \n fn block_starts_with_comment(cx: &EarlyContext<'_>, expr: &ast::Block) -> bool {\n     // We trim all opening braces and whitespaces and then check if the next string is a comment.\n-    let trimmed_block_text = snippet_block(cx, expr.span, \"..\")\n+    let trimmed_block_text = snippet_block(cx, expr.span, \"..\", None)\n         .trim_start_matches(|c: char| c.is_whitespace() || c == '{')\n         .to_owned();\n     trimmed_block_text.starts_with(\"//\") || trimmed_block_text.starts_with(\"/*\")\n@@ -116,7 +116,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n                 block.span,\n                 \"this `else { if .. }` block can be collapsed\",\n                 \"try\",\n-                snippet_block_with_applicability(cx, else_.span, \"..\", &mut applicability).into_owned(),\n+                snippet_block_with_applicability(cx, else_.span, \"..\", Some(block.span), &mut applicability).into_owned(),\n                 applicability,\n             );\n         }\n@@ -146,7 +146,7 @@ fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &\n                     format!(\n                         \"if {} {}\",\n                         lhs.and(&rhs),\n-                        snippet_block(cx, content.span, \"..\"),\n+                        snippet_block(cx, content.span, \"..\", Some(expr.span)),\n                     ),\n                     Applicability::MachineApplicable, // snippet\n                 );"}, {"sha": "d753b664045d80b10fe4a7ee9a66b1b9a5cf5a4a", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -3,9 +3,9 @@ use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::is_unused;\n use crate::utils::{\n-    expr_block, get_arg_name, in_macro, is_allowed, is_expn_of, is_refutable, is_wild, match_qpath, match_type,\n-    match_var, multispan_sugg, remove_blocks, snippet, snippet_block, snippet_with_applicability, span_lint_and_help,\n-    span_lint_and_note, span_lint_and_sugg, span_lint_and_then, walk_ptrs_ty,\n+    expr_block, get_arg_name, in_macro, indent_of, is_allowed, is_expn_of, is_refutable, is_wild, match_qpath,\n+    match_type, match_var, multispan_sugg, remove_blocks, snippet, snippet_block, snippet_with_applicability,\n+    span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then, walk_ptrs_ty,\n };\n use if_chain::if_chain;\n use rustc::lint::in_external_macro;\n@@ -434,7 +434,7 @@ fn report_single_match_single_pattern(\n ) {\n     let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n     let els_str = els.map_or(String::new(), |els| {\n-        format!(\" else {}\", expr_block(cx, els, None, \"..\"))\n+        format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n     });\n     span_lint_and_sugg(\n         cx,\n@@ -447,7 +447,7 @@ fn report_single_match_single_pattern(\n             \"if let {} = {} {}{}\",\n             snippet(cx, arms[0].pat.span, \"..\"),\n             snippet(cx, ex.span, \"..\"),\n-            expr_block(cx, &arms[0].body, None, \"..\"),\n+            expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n             els_str,\n         ),\n         Applicability::HasPlaceholders,\n@@ -523,17 +523,21 @@ fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], e\n                             (false, false) => Some(format!(\n                                 \"if {} {} else {}\",\n                                 snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\"),\n-                                expr_block(cx, false_expr, None, \"..\")\n+                                expr_block(cx, true_expr, None, \"..\", Some(expr.span)),\n+                                expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n                             )),\n                             (false, true) => Some(format!(\n                                 \"if {} {}\",\n                                 snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\")\n+                                expr_block(cx, true_expr, None, \"..\", Some(expr.span))\n                             )),\n                             (true, false) => {\n                                 let test = Sugg::hir(cx, ex, \"..\");\n-                                Some(format!(\"if {} {}\", !test, expr_block(cx, false_expr, None, \"..\")))\n+                                Some(format!(\n+                                    \"if {} {}\",\n+                                    !test,\n+                                    expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n+                                ))\n                             },\n                             (true, true) => None,\n                         };\n@@ -832,7 +836,7 @@ fn check_match_single_binding(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[A\n     let mut snippet_body = if match_body.span.from_expansion() {\n         Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n     } else {\n-        snippet_block(cx, match_body.span, \"..\").to_owned().to_string()\n+        snippet_block(cx, match_body.span, \"..\", Some(expr.span)).to_string()\n     };\n \n     // Do we need to add ';' to suggestion ?\n@@ -861,10 +865,11 @@ fn check_match_single_binding(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[A\n                 \"this match could be written as a `let` statement\",\n                 \"consider using `let` statement\",\n                 format!(\n-                    \"let {} = {};\\n{}\",\n+                    \"let {} = {};\\n{}{}\",\n                     snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n                     snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n-                    snippet_body\n+                    \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n+                    snippet_body,\n                 ),\n                 applicability,\n             );"}, {"sha": "660aae25f557d829565786241b81f892df65ab4d", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 105, "deletions": 98, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -36,10 +36,10 @@\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{original_sp, DUMMY_SP};\n-use std::borrow::Cow;\n+use rustc_span::Span;\n use syntax::ast;\n \n-use crate::utils::{snippet, snippet_block, span_lint_and_help, trim_multiline};\n+use crate::utils::{indent_of, snippet, snippet_block, span_lint_and_help};\n \n declare_clippy_lint! {\n     /// **What it does:** The lint checks for `if`-statements appearing in loops\n@@ -119,9 +119,9 @@ declare_clippy_lint! {\n declare_lint_pass!(NeedlessContinue => [NEEDLESS_CONTINUE]);\n \n impl EarlyLintPass for NeedlessContinue {\n-    fn check_expr(&mut self, ctx: &EarlyContext<'_>, expr: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n         if !expr.span.from_expansion() {\n-            check_and_warn(ctx, expr);\n+            check_and_warn(cx, expr);\n         }\n     }\n }\n@@ -273,93 +273,96 @@ struct LintData<'a> {\n     block_stmts: &'a [ast::Stmt],\n }\n \n-const MSG_REDUNDANT_ELSE_BLOCK: &str = \"This `else` block is redundant.\\n\";\n+const MSG_REDUNDANT_ELSE_BLOCK: &str = \"this `else` block is redundant\";\n \n-const MSG_ELSE_BLOCK_NOT_NEEDED: &str = \"There is no need for an explicit `else` block for this `if` \\\n-                                         expression\\n\";\n+const MSG_ELSE_BLOCK_NOT_NEEDED: &str = \"there is no need for an explicit `else` block for this `if` \\\n+                                         expression\";\n \n-const DROP_ELSE_BLOCK_AND_MERGE_MSG: &str = \"Consider dropping the `else` clause and merging the code that \\\n-                                             follows (in the loop) with the `if` block, like so:\\n\";\n+const DROP_ELSE_BLOCK_AND_MERGE_MSG: &str = \"consider dropping the `else` clause and merging the code that \\\n+                                             follows (in the loop) with the `if` block\";\n \n-const DROP_ELSE_BLOCK_MSG: &str = \"Consider dropping the `else` clause, and moving out the code in the `else` \\\n-                                   block, like so:\\n\";\n+const DROP_ELSE_BLOCK_MSG: &str = \"consider dropping the `else` clause\";\n \n-fn emit_warning<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str, typ: LintType) {\n+fn emit_warning<'a>(cx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str, typ: LintType) {\n     // snip    is the whole *help* message that appears after the warning.\n     // message is the warning message.\n     // expr    is the expression which the lint warning message refers to.\n     let (snip, message, expr) = match typ {\n         LintType::ContinueInsideElseBlock => (\n-            suggestion_snippet_for_continue_inside_else(ctx, data, header),\n+            suggestion_snippet_for_continue_inside_else(cx, data),\n             MSG_REDUNDANT_ELSE_BLOCK,\n             data.else_expr,\n         ),\n         LintType::ContinueInsideThenBlock => (\n-            suggestion_snippet_for_continue_inside_if(ctx, data, header),\n+            suggestion_snippet_for_continue_inside_if(cx, data),\n             MSG_ELSE_BLOCK_NOT_NEEDED,\n             data.if_expr,\n         ),\n     };\n-    span_lint_and_help(ctx, NEEDLESS_CONTINUE, expr.span, message, &snip);\n+    span_lint_and_help(\n+        cx,\n+        NEEDLESS_CONTINUE,\n+        expr.span,\n+        message,\n+        &format!(\"{}\\n{}\", header, snip),\n+    );\n }\n \n-fn suggestion_snippet_for_continue_inside_if<'a>(\n-    ctx: &EarlyContext<'_>,\n-    data: &'a LintData<'_>,\n-    header: &str,\n-) -> String {\n-    let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n-\n-    let if_code = format!(\"if {} {{\\n    continue;\\n}}\\n\", cond_code);\n-    /* ^^^^--- Four spaces of indentation. */\n-    // region B\n-    let else_code = snippet(ctx, data.else_expr.span, \"..\").into_owned();\n-    let else_code = erode_block(&else_code);\n-    let else_code = trim_multiline(Cow::from(else_code), false);\n-\n-    let mut ret = String::from(header);\n-    ret.push_str(&if_code);\n-    ret.push_str(&else_code);\n-    ret.push_str(\"\\n...\");\n-    ret\n+fn suggestion_snippet_for_continue_inside_if<'a>(cx: &EarlyContext<'_>, data: &'a LintData<'_>) -> String {\n+    let cond_code = snippet(cx, data.if_cond.span, \"..\");\n+\n+    let continue_code = snippet_block(cx, data.if_block.span, \"..\", Some(data.if_expr.span));\n+\n+    let else_code = snippet_block(cx, data.else_expr.span, \"..\", Some(data.if_expr.span));\n+\n+    let indent_if = indent_of(cx, data.if_expr.span).unwrap_or(0);\n+    format!(\n+        \"{indent}if {} {}\\n{indent}{}\",\n+        cond_code,\n+        continue_code,\n+        else_code,\n+        indent = \" \".repeat(indent_if),\n+    )\n }\n \n-fn suggestion_snippet_for_continue_inside_else<'a>(\n-    ctx: &EarlyContext<'_>,\n-    data: &'a LintData<'_>,\n-    header: &str,\n-) -> String {\n-    let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n-    let mut if_code = format!(\"if {} {{\\n\", cond_code);\n+fn suggestion_snippet_for_continue_inside_else<'a>(cx: &EarlyContext<'_>, data: &'a LintData<'_>) -> String {\n+    let cond_code = snippet(cx, data.if_cond.span, \"..\");\n \n     // Region B\n-    let block_code = &snippet(ctx, data.if_block.span, \"..\").into_owned();\n-    let block_code = erode_block(block_code);\n-    let block_code = trim_multiline(Cow::from(block_code), false);\n-\n-    if_code.push_str(&block_code);\n+    let block_code = erode_from_back(&snippet_block(cx, data.if_block.span, \"..\", Some(data.if_expr.span)));\n \n     // Region C\n     // These is the code in the loop block that follows the if/else construction\n     // we are complaining about. We want to pull all of this code into the\n     // `then` block of the `if` statement.\n+    let indent = span_of_first_expr_in_block(data.if_block)\n+        .and_then(|span| indent_of(cx, span))\n+        .unwrap_or(0);\n     let to_annex = data.block_stmts[data.stmt_idx + 1..]\n         .iter()\n         .map(|stmt| original_sp(stmt.span, DUMMY_SP))\n-        .map(|span| snippet_block(ctx, span, \"..\").into_owned())\n+        .map(|span| {\n+            let snip = snippet_block(cx, span, \"..\", None).into_owned();\n+            snip.lines()\n+                .map(|line| format!(\"{}{}\", \" \".repeat(indent), line))\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\")\n+        })\n         .collect::<Vec<_>>()\n         .join(\"\\n\");\n \n-    let mut ret = String::from(header);\n-\n-    ret.push_str(&if_code);\n-    ret.push_str(\"\\n// Merged code follows...\");\n-    ret.push_str(&to_annex);\n-    ret.push_str(\"\\n}\\n\");\n-    ret\n+    let indent_if = indent_of(cx, data.if_expr.span).unwrap_or(0);\n+    format!(\n+        \"{indent_if}if {} {}\\n{indent}// merged code follows:\\n{}\\n{indent_if}}}\",\n+        cond_code,\n+        block_code,\n+        to_annex,\n+        indent = \" \".repeat(indent),\n+        indent_if = \" \".repeat(indent_if),\n+    )\n }\n \n-fn check_and_warn<'a>(ctx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n+fn check_and_warn<'a>(cx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n     with_loop_block(expr, |loop_block, label| {\n         for (i, stmt) in loop_block.stmts.iter().enumerate() {\n             with_if_expr(stmt, |if_expr, cond, then_block, else_expr| {\n@@ -373,22 +376,22 @@ fn check_and_warn<'a>(ctx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n                 };\n                 if needless_continue_in_else(else_expr, label) {\n                     emit_warning(\n-                        ctx,\n+                        cx,\n                         data,\n                         DROP_ELSE_BLOCK_AND_MERGE_MSG,\n                         LintType::ContinueInsideElseBlock,\n                     );\n                 } else if is_first_block_stmt_continue(then_block, label) {\n-                    emit_warning(ctx, data, DROP_ELSE_BLOCK_MSG, LintType::ContinueInsideThenBlock);\n+                    emit_warning(cx, data, DROP_ELSE_BLOCK_MSG, LintType::ContinueInsideThenBlock);\n                 }\n             });\n         }\n     });\n }\n \n-/// Eats at `s` from the end till a closing brace `}` is encountered, and then\n-/// continues eating till a non-whitespace character is found.\n-/// e.g., the string\n+/// Eats at `s` from the end till a closing brace `}` is encountered, and then continues eating\n+/// till a non-whitespace character is found.  e.g., the string. If no closing `}` is present, the\n+/// string will be preserved.\n ///\n /// ```rust\n /// {\n@@ -402,54 +405,58 @@ fn check_and_warn<'a>(ctx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n ///     {\n ///         let x = 5;\n /// ```\n-///\n-/// NOTE: when there is no closing brace in `s`, `s` is _not_ preserved, i.e.,\n-/// an empty string will be returned in that case.\n #[must_use]\n-pub fn erode_from_back(s: &str) -> String {\n-    let mut ret = String::from(s);\n+fn erode_from_back(s: &str) -> String {\n+    let mut ret = s.to_string();\n     while ret.pop().map_or(false, |c| c != '}') {}\n     while let Some(c) = ret.pop() {\n         if !c.is_whitespace() {\n             ret.push(c);\n             break;\n         }\n     }\n-    ret\n+    if ret.is_empty() {\n+        s.to_string()\n+    } else {\n+        ret\n+    }\n }\n \n-/// Eats at `s` from the front by first skipping all leading whitespace. Then,\n-/// any number of opening braces are eaten, followed by any number of newlines.\n-/// e.g.,  the string\n-///\n-/// ```ignore\n-///         {\n-///             something();\n-///             inside_a_block();\n-///         }\n-/// ```\n-///\n-/// is transformed to\n-///\n-/// ```ignore\n-///             something();\n-///             inside_a_block();\n-///         }\n-/// ```\n-#[must_use]\n-pub fn erode_from_front(s: &str) -> String {\n-    s.chars()\n-        .skip_while(|c| c.is_whitespace())\n-        .skip_while(|c| *c == '{')\n-        .skip_while(|c| *c == '\\n')\n-        .collect::<String>()\n+fn span_of_first_expr_in_block(block: &ast::Block) -> Option<Span> {\n+    block.stmts.iter().next().map(|stmt| stmt.span)\n }\n \n-/// If `s` contains the code for a block, delimited by braces, this function\n-/// tries to get the contents of the block. If there is no closing brace\n-/// present,\n-/// an empty string is returned.\n-#[must_use]\n-pub fn erode_block(s: &str) -> String {\n-    erode_from_back(&erode_from_front(s))\n+#[cfg(test)]\n+mod test {\n+    use super::erode_from_back;\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_erode_from_back() {\n+        let input = \"\\\n+{\n+    let x = 5;\n+    let y = format!(\\\"{}\\\", 42);\n+}\";\n+\n+        let expected = \"\\\n+{\n+    let x = 5;\n+    let y = format!(\\\"{}\\\", 42);\";\n+\n+        let got = erode_from_back(input);\n+        assert_eq!(expected, got);\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_erode_from_back_no_brace() {\n+        let input = \"\\\n+let x = 5;\n+let y = something();\n+\";\n+        let expected = input;\n+        let got = erode_from_back(input);\n+        assert_eq!(expected, got);\n+    }\n }"}, {"sha": "ed6d9f81cc9f5a482acc251c267f07064bffc36f", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 190, "deletions": 109, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -44,6 +44,7 @@ use rustc_hir::Node;\n use rustc_hir::*;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n+use rustc_span::source_map::original_sp;\n use rustc_span::symbol::{self, kw, Symbol};\n use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n use smallvec::SmallVec;\n@@ -533,19 +534,49 @@ pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n     cx.sess().source_map().span_to_snippet(span).ok()\n }\n \n-/// Converts a span (from a block) to a code snippet if available, otherwise use\n-/// default.\n-/// This trims the code of indentation, except for the first line. Use it for\n-/// blocks or block-like\n+/// Converts a span (from a block) to a code snippet if available, otherwise use default.\n+///\n+/// This trims the code of indentation, except for the first line. Use it for blocks or block-like\n /// things which need to be printed as such.\n ///\n+/// The `indent_relative_to` arg can be used, to provide a span, where the indentation of the\n+/// resulting snippet of the given span.\n+///\n /// # Example\n+///\n+/// ```rust,ignore\n+/// snippet_block(cx, block.span, \"..\", None)\n+/// // where, `block` is the block of the if expr\n+///     if x {\n+///         y;\n+///     }\n+/// // will return the snippet\n+/// {\n+///     y;\n+/// }\n+/// ```\n+///\n /// ```rust,ignore\n-/// snippet_block(cx, expr.span, \"..\")\n+/// snippet_block(cx, block.span, \"..\", Some(if_expr.span))\n+/// // where, `block` is the block of the if expr\n+///     if x {\n+///         y;\n+///     }\n+/// // will return the snippet\n+/// {\n+///         y;\n+///     } // aligned with `if`\n /// ```\n-pub fn snippet_block<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+/// Note that the first line of the snippet always has 0 indentation.\n+pub fn snippet_block<'a, T: LintContext>(\n+    cx: &T,\n+    span: Span,\n+    default: &'a str,\n+    indent_relative_to: Option<Span>,\n+) -> Cow<'a, str> {\n     let snip = snippet(cx, span, default);\n-    trim_multiline(snip, true)\n+    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n+    trim_multiline(snip, true, indent)\n }\n \n /// Same as `snippet_block`, but adapts the applicability level by the rules of\n@@ -554,27 +585,73 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n     cx: &T,\n     span: Span,\n     default: &'a str,\n+    indent_relative_to: Option<Span>,\n     applicability: &mut Applicability,\n ) -> Cow<'a, str> {\n     let snip = snippet_with_applicability(cx, span, default, applicability);\n-    trim_multiline(snip, true)\n+    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n+    trim_multiline(snip, true, indent)\n+}\n+\n+/// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n+/// line.\n+///\n+/// ```rust,ignore\n+///     let x = ();\n+/// //          ^^\n+/// // will be converted to\n+///     let x = ();\n+/// //  ^^^^^^^^^^\n+/// ```\n+pub fn first_line_of_span<T: LintContext>(cx: &T, span: Span) -> Span {\n+    if let Some(first_char_pos) = first_char_in_first_line(cx, span) {\n+        span.with_lo(first_char_pos)\n+    } else {\n+        span\n+    }\n }\n \n-/// Returns a new Span that covers the full last line of the given Span\n-pub fn last_line_of_span<T: LintContext>(cx: &T, span: Span) -> Span {\n+fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePos> {\n+    let line_span = line_span(cx, span);\n+    if let Some(snip) = snippet_opt(cx, line_span) {\n+        snip.find(|c: char| !c.is_whitespace())\n+            .map(|pos| line_span.lo() + BytePos::from_usize(pos))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Returns the indentation of the line of a span\n+///\n+/// ```rust,ignore\n+/// let x = ();\n+/// //      ^^ -- will return 0\n+///     let x = ();\n+/// //          ^^ -- will return 4\n+/// ```\n+pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n+    if let Some(snip) = snippet_opt(cx, line_span(cx, span)) {\n+        snip.find(|c: char| !c.is_whitespace())\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Extends the span to the beginning of the spans line, incl. whitespaces.\n+///\n+/// ```rust,ignore\n+///        let x = ();\n+/// //             ^^\n+/// // will be converted to\n+///        let x = ();\n+/// // ^^^^^^^^^^^^^^\n+/// ```\n+fn line_span<T: LintContext>(cx: &T, span: Span) -> Span {\n+    let span = original_sp(span, DUMMY_SP);\n     let source_map_and_line = cx.sess().source_map().lookup_line(span.lo()).unwrap();\n     let line_no = source_map_and_line.line;\n-    let line_start = &source_map_and_line.sf.lines[line_no];\n-    let span = Span::new(*line_start, span.hi(), span.ctxt());\n-    if_chain! {\n-        if let Some(snip) = snippet_opt(cx, span);\n-        if let Some(first_ch_pos) = snip.find(|c: char| !c.is_whitespace());\n-        then {\n-            span.with_lo(span.lo() + BytePos::from_usize(first_ch_pos))\n-        } else {\n-            span\n-        }\n-    }\n+    let line_start = source_map_and_line.sf.lines[line_no];\n+    Span::new(line_start, span.hi(), span.ctxt())\n }\n \n /// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n@@ -584,8 +661,9 @@ pub fn expr_block<'a, T: LintContext>(\n     expr: &Expr<'_>,\n     option: Option<String>,\n     default: &'a str,\n+    indent_relative_to: Option<Span>,\n ) -> Cow<'a, str> {\n-    let code = snippet_block(cx, expr.span, default);\n+    let code = snippet_block(cx, expr.span, default, indent_relative_to);\n     let string = option.unwrap_or_default();\n     if expr.span.from_expansion() {\n         Cow::Owned(format!(\"{{ {} }}\", snippet_with_macro_callsite(cx, expr.span, default)))\n@@ -600,14 +678,14 @@ pub fn expr_block<'a, T: LintContext>(\n \n /// Trim indentation from a multiline string with possibility of ignoring the\n /// first line.\n-pub fn trim_multiline(s: Cow<'_, str>, ignore_first: bool) -> Cow<'_, str> {\n-    let s_space = trim_multiline_inner(s, ignore_first, ' ');\n-    let s_tab = trim_multiline_inner(s_space, ignore_first, '\\t');\n-    trim_multiline_inner(s_tab, ignore_first, ' ')\n+fn trim_multiline(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>) -> Cow<'_, str> {\n+    let s_space = trim_multiline_inner(s, ignore_first, indent, ' ');\n+    let s_tab = trim_multiline_inner(s_space, ignore_first, indent, '\\t');\n+    trim_multiline_inner(s_tab, ignore_first, indent, ' ')\n }\n \n-fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_, str> {\n-    let x = s\n+fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>, ch: char) -> Cow<'_, str> {\n+    let mut x = s\n         .lines()\n         .skip(ignore_first as usize)\n         .filter_map(|l| {\n@@ -620,6 +698,9 @@ fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_\n         })\n         .min()\n         .unwrap_or(0);\n+    if let Some(indent) = indent {\n+        x = x.saturating_sub(indent);\n+    }\n     if x > 0 {\n         Cow::Owned(\n             s.lines()\n@@ -1141,87 +1222,6 @@ pub fn is_normalizable<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, param_env: ty::Para\n     })\n }\n \n-#[cfg(test)]\n-mod test {\n-    use super::{trim_multiline, without_block_comments};\n-\n-    #[test]\n-    fn test_trim_multiline_single_line() {\n-        assert_eq!(\"\", trim_multiline(\"\".into(), false));\n-        assert_eq!(\"...\", trim_multiline(\"...\".into(), false));\n-        assert_eq!(\"...\", trim_multiline(\"    ...\".into(), false));\n-        assert_eq!(\"...\", trim_multiline(\"\\t...\".into(), false));\n-        assert_eq!(\"...\", trim_multiline(\"\\t\\t...\".into(), false));\n-    }\n-\n-    #[test]\n-    #[rustfmt::skip]\n-    fn test_trim_multiline_block() {\n-        assert_eq!(\"\\\n-    if x {\n-        y\n-    } else {\n-        z\n-    }\", trim_multiline(\"    if x {\n-            y\n-        } else {\n-            z\n-        }\".into(), false));\n-        assert_eq!(\"\\\n-    if x {\n-    \\ty\n-    } else {\n-    \\tz\n-    }\", trim_multiline(\"    if x {\n-        \\ty\n-        } else {\n-        \\tz\n-        }\".into(), false));\n-    }\n-\n-    #[test]\n-    #[rustfmt::skip]\n-    fn test_trim_multiline_empty_line() {\n-        assert_eq!(\"\\\n-    if x {\n-        y\n-\n-    } else {\n-        z\n-    }\", trim_multiline(\"    if x {\n-            y\n-\n-        } else {\n-            z\n-        }\".into(), false));\n-    }\n-\n-    #[test]\n-    fn test_without_block_comments_lines_without_block_comments() {\n-        let result = without_block_comments(vec![\"/*\", \"\", \"*/\"]);\n-        println!(\"result: {:?}\", result);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"\", \"/*\", \"\", \"*/\", \"#[crate_type = \\\"lib\\\"]\", \"/*\", \"\", \"*/\", \"\"]);\n-        assert_eq!(result, vec![\"\", \"#[crate_type = \\\"lib\\\"]\", \"\"]);\n-\n-        let result = without_block_comments(vec![\"/* rust\", \"\", \"*/\"]);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"/* one-line comment */\"]);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"/* nested\", \"/* multi-line\", \"comment\", \"*/\", \"test\", \"*/\"]);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"/* nested /* inline /* comment */ test */ */\"]);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"foo\", \"bar\", \"baz\"]);\n-        assert_eq!(result, vec![\"foo\", \"bar\", \"baz\"]);\n-    }\n-}\n-\n pub fn match_def_path<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, did: DefId, syms: &[&str]) -> bool {\n     let path = cx.get_def_path(did);\n     path.len() == syms.len() && path.into_iter().zip(syms.iter()).all(|(a, &b)| a.as_str() == b)\n@@ -1369,3 +1369,84 @@ pub fn is_trait_impl_item(cx: &LateContext<'_, '_>, hir_id: HirId) -> bool {\n         false\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{trim_multiline, without_block_comments};\n+\n+    #[test]\n+    fn test_trim_multiline_single_line() {\n+        assert_eq!(\"\", trim_multiline(\"\".into(), false, None));\n+        assert_eq!(\"...\", trim_multiline(\"...\".into(), false, None));\n+        assert_eq!(\"...\", trim_multiline(\"    ...\".into(), false, None));\n+        assert_eq!(\"...\", trim_multiline(\"\\t...\".into(), false, None));\n+        assert_eq!(\"...\", trim_multiline(\"\\t\\t...\".into(), false, None));\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_trim_multiline_block() {\n+        assert_eq!(\"\\\n+    if x {\n+        y\n+    } else {\n+        z\n+    }\", trim_multiline(\"    if x {\n+            y\n+        } else {\n+            z\n+        }\".into(), false, None));\n+        assert_eq!(\"\\\n+    if x {\n+    \\ty\n+    } else {\n+    \\tz\n+    }\", trim_multiline(\"    if x {\n+        \\ty\n+        } else {\n+        \\tz\n+        }\".into(), false, None));\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_trim_multiline_empty_line() {\n+        assert_eq!(\"\\\n+    if x {\n+        y\n+\n+    } else {\n+        z\n+    }\", trim_multiline(\"    if x {\n+            y\n+\n+        } else {\n+            z\n+        }\".into(), false, None));\n+    }\n+\n+    #[test]\n+    fn test_without_block_comments_lines_without_block_comments() {\n+        let result = without_block_comments(vec![\"/*\", \"\", \"*/\"]);\n+        println!(\"result: {:?}\", result);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"\", \"/*\", \"\", \"*/\", \"#[crate_type = \\\"lib\\\"]\", \"/*\", \"\", \"*/\", \"\"]);\n+        assert_eq!(result, vec![\"\", \"#[crate_type = \\\"lib\\\"]\", \"\"]);\n+\n+        let result = without_block_comments(vec![\"/* rust\", \"\", \"*/\"]);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"/* one-line comment */\"]);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"/* nested\", \"/* multi-line\", \"comment\", \"*/\", \"test\", \"*/\"]);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"/* nested /* inline /* comment */ test */ */\"]);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"foo\", \"bar\", \"baz\"]);\n+        assert_eq!(result, vec![\"foo\", \"bar\", \"baz\"]);\n+    }\n+}"}, {"sha": "255653b4737d3453ec371d76c8c6482deea897e4", "filename": "tests/needless_continue_helpers.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ee842df61df91f3ed3e33a23f8393c47d384ef40/tests%2Fneedless_continue_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee842df61df91f3ed3e33a23f8393c47d384ef40/tests%2Fneedless_continue_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fneedless_continue_helpers.rs?ref=ee842df61df91f3ed3e33a23f8393c47d384ef40", "patch": "@@ -1,87 +0,0 @@\n-// Tests for the various helper functions used by the needless_continue\n-// lint that don't belong in utils.\n-\n-use clippy_lints::needless_continue::{erode_block, erode_from_back, erode_from_front};\n-\n-#[test]\n-#[rustfmt::skip]\n-fn test_erode_from_back() {\n-    let input = \"\\\n-{\n-    let x = 5;\n-    let y = format!(\\\"{}\\\", 42);\n-}\";\n-\n-    let expected = \"\\\n-{\n-    let x = 5;\n-    let y = format!(\\\"{}\\\", 42);\";\n-\n-    let got = erode_from_back(input);\n-    assert_eq!(expected, got);\n-}\n-\n-#[test]\n-#[rustfmt::skip]\n-fn test_erode_from_back_no_brace() {\n-    let input = \"\\\n-let x = 5;\n-let y = something();\n-\";\n-    let expected = \"\";\n-    let got = erode_from_back(input);\n-    assert_eq!(expected, got);\n-}\n-\n-#[test]\n-#[rustfmt::skip]\n-fn test_erode_from_front() {\n-    let input = \"\n-        {\n-            something();\n-            inside_a_block();\n-        }\n-    \";\n-    let expected =\n-\"            something();\n-            inside_a_block();\n-        }\n-    \";\n-    let got = erode_from_front(input);\n-    println!(\"input: {}\\nexpected:\\n{}\\ngot:\\n{}\", input, expected, got);\n-    assert_eq!(expected, got);\n-}\n-\n-#[test]\n-#[rustfmt::skip]\n-fn test_erode_from_front_no_brace() {\n-    let input = \"\n-            something();\n-            inside_a_block();\n-    \";\n-    let expected =\n-\"something();\n-            inside_a_block();\n-    \";\n-    let got = erode_from_front(input);\n-    println!(\"input: {}\\nexpected:\\n{}\\ngot:\\n{}\", input, expected, got);\n-    assert_eq!(expected, got);\n-}\n-\n-#[test]\n-#[rustfmt::skip]\n-fn test_erode_block() {\n-\n-    let input = \"\n-        {\n-            something();\n-            inside_a_block();\n-        }\n-    \";\n-    let expected =\n-\"            something();\n-            inside_a_block();\";\n-    let got = erode_block(input);\n-    println!(\"input: {}\\nexpected:\\n{}\\ngot:\\n{}\", input, expected, got);\n-    assert_eq!(expected, got);\n-}"}, {"sha": "955801e40f9b7659d15336a93ecfeb27d71f2545", "filename": "tests/ui/block_in_if_condition.fixed", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fblock_in_if_condition.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fblock_in_if_condition.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblock_in_if_condition.fixed?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -0,0 +1,75 @@\n+// run-rustfix\n+#![warn(clippy::block_in_if_condition_expr)]\n+#![warn(clippy::block_in_if_condition_stmt)]\n+#![allow(unused, clippy::let_and_return)]\n+#![warn(clippy::nonminimal_bool)]\n+\n+macro_rules! blocky {\n+    () => {{\n+        true\n+    }};\n+}\n+\n+macro_rules! blocky_too {\n+    () => {{\n+        let r = true;\n+        r\n+    }};\n+}\n+\n+fn macro_if() {\n+    if blocky!() {}\n+\n+    if blocky_too!() {}\n+}\n+\n+fn condition_has_block() -> i32 {\n+    let res = {\n+        let x = 3;\n+        x == 3\n+    }; if res {\n+        6\n+    } else {\n+        10\n+    }\n+}\n+\n+fn condition_has_block_with_single_expression() -> i32 {\n+    if true {\n+        6\n+    } else {\n+        10\n+    }\n+}\n+\n+fn condition_is_normal() -> i32 {\n+    let x = 3;\n+    if x == 3 {\n+        6\n+    } else {\n+        10\n+    }\n+}\n+\n+fn condition_is_unsafe_block() {\n+    let a: i32 = 1;\n+\n+    // this should not warn because the condition is an unsafe block\n+    if unsafe { 1u32 == std::mem::transmute(a) } {\n+        println!(\"1u32 == a\");\n+    }\n+}\n+\n+fn block_in_assert() {\n+    let opt = Some(42);\n+    assert!(opt\n+        .as_ref()\n+        .and_then(|val| {\n+            let mut v = val * 2;\n+            v -= 1;\n+            Some(v * 3)\n+        })\n+        .is_some());\n+}\n+\n+fn main() {}"}, {"sha": "a6ea01d5fc5f901a7e49e593dab65c514c6e7c7e", "filename": "tests/ui/block_in_if_condition.rs", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblock_in_if_condition.rs?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n #![warn(clippy::block_in_if_condition_expr)]\n #![warn(clippy::block_in_if_condition_stmt)]\n #![allow(unused, clippy::let_and_return)]\n@@ -41,37 +42,6 @@ fn condition_has_block_with_single_expression() -> i32 {\n     }\n }\n \n-fn predicate<F: FnOnce(T) -> bool, T>(pfn: F, val: T) -> bool {\n-    pfn(val)\n-}\n-\n-fn pred_test() {\n-    let v = 3;\n-    let sky = \"blue\";\n-    // This is a sneaky case, where the block isn't directly in the condition,\n-    // but is actually nside a closure that the condition is using.\n-    // The same principle applies -- add some extra expressions to make sure\n-    // linter isn't confused by them.\n-    if v == 3\n-        && sky == \"blue\"\n-        && predicate(\n-            |x| {\n-                let target = 3;\n-                x == target\n-            },\n-            v,\n-        )\n-    {}\n-\n-    if predicate(\n-        |x| {\n-            let target = 3;\n-            x == target\n-        },\n-        v,\n-    ) {}\n-}\n-\n fn condition_is_normal() -> i32 {\n     let x = 3;\n     if true && x == 3 {\n@@ -81,10 +51,6 @@ fn condition_is_normal() -> i32 {\n     }\n }\n \n-fn closure_without_block() {\n-    if predicate(|x| x == 3, 6) {}\n-}\n-\n fn condition_is_unsafe_block() {\n     let a: i32 = 1;\n \n@@ -94,16 +60,6 @@ fn condition_is_unsafe_block() {\n     }\n }\n \n-fn main() {}\n-\n-fn macro_in_closure() {\n-    let option = Some(true);\n-\n-    if option.unwrap_or_else(|| unimplemented!()) {\n-        unimplemented!()\n-    }\n-}\n-\n fn block_in_assert() {\n     let opt = Some(42);\n     assert!(opt\n@@ -115,3 +71,5 @@ fn block_in_assert() {\n         })\n         .is_some());\n }\n+\n+fn main() {}"}, {"sha": "b0a0a276c89088eb6061c4603989a0463a07ed43", "filename": "tests/ui/block_in_if_condition.stderr", "status": "modified", "additions": 13, "deletions": 39, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fblock_in_if_condition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fblock_in_if_condition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblock_in_if_condition.stderr?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -1,62 +1,36 @@\n error: in an `if` condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a `let`\n-  --> $DIR/block_in_if_condition.rs:26:8\n+  --> $DIR/block_in_if_condition.rs:27:5\n    |\n-LL |       if {\n-   |  ________^\n+LL | /     if {\n LL | |         let x = 3;\n LL | |         x == 3\n LL | |     } {\n    | |_____^\n    |\n    = note: `-D clippy::block-in-if-condition-stmt` implied by `-D warnings`\n-   = help: try\n-           let res = {\n-               let x = 3;\n-               x == 3\n-           };\n-           if res {\n-               6\n-           } ... \n+help: try\n+   |\n+LL |     let res = {\n+LL |         let x = 3;\n+LL |         x == 3\n+LL |     }; if res {\n+   |\n \n error: omit braces around single expression condition\n-  --> $DIR/block_in_if_condition.rs:37:8\n+  --> $DIR/block_in_if_condition.rs:38:8\n    |\n LL |     if { true } {\n-   |        ^^^^^^^^\n+   |        ^^^^^^^^ help: try: `true`\n    |\n    = note: `-D clippy::block-in-if-condition-expr` implied by `-D warnings`\n-   = help: try\n-           if true {\n-               6\n-           } ... \n-\n-error: in an `if` condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a `let`\n-  --> $DIR/block_in_if_condition.rs:58:17\n-   |\n-LL |               |x| {\n-   |  _________________^\n-LL | |                 let target = 3;\n-LL | |                 x == target\n-LL | |             },\n-   | |_____________^\n-\n-error: in an `if` condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a `let`\n-  --> $DIR/block_in_if_condition.rs:67:13\n-   |\n-LL |           |x| {\n-   |  _____________^\n-LL | |             let target = 3;\n-LL | |             x == target\n-LL | |         },\n-   | |_________^\n \n error: this boolean expression can be simplified\n-  --> $DIR/block_in_if_condition.rs:77:8\n+  --> $DIR/block_in_if_condition.rs:47:8\n    |\n LL |     if true && x == 3 {\n    |        ^^^^^^^^^^^^^^ help: try: `x == 3`\n    |\n    = note: `-D clippy::nonminimal-bool` implied by `-D warnings`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "bac3eda5e7f37b505a3c1f44465484ed14a5f7e1", "filename": "tests/ui/block_in_if_condition_closure.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fblock_in_if_condition_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fblock_in_if_condition_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblock_in_if_condition_closure.rs?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -0,0 +1,48 @@\n+#![warn(clippy::block_in_if_condition_expr)]\n+#![warn(clippy::block_in_if_condition_stmt)]\n+#![allow(unused, clippy::let_and_return)]\n+\n+fn predicate<F: FnOnce(T) -> bool, T>(pfn: F, val: T) -> bool {\n+    pfn(val)\n+}\n+\n+fn pred_test() {\n+    let v = 3;\n+    let sky = \"blue\";\n+    // This is a sneaky case, where the block isn't directly in the condition,\n+    // but is actually nside a closure that the condition is using.\n+    // The same principle applies -- add some extra expressions to make sure\n+    // linter isn't confused by them.\n+    if v == 3\n+        && sky == \"blue\"\n+        && predicate(\n+            |x| {\n+                let target = 3;\n+                x == target\n+            },\n+            v,\n+        )\n+    {}\n+\n+    if predicate(\n+        |x| {\n+            let target = 3;\n+            x == target\n+        },\n+        v,\n+    ) {}\n+}\n+\n+fn closure_without_block() {\n+    if predicate(|x| x == 3, 6) {}\n+}\n+\n+fn macro_in_closure() {\n+    let option = Some(true);\n+\n+    if option.unwrap_or_else(|| unimplemented!()) {\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "86cd24fe76321b0813813f0eb34b9765b5d9d126", "filename": "tests/ui/block_in_if_condition_closure.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fblock_in_if_condition_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fblock_in_if_condition_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblock_in_if_condition_closure.stderr?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -0,0 +1,24 @@\n+error: in an `if` condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a `let`\n+  --> $DIR/block_in_if_condition_closure.rs:19:17\n+   |\n+LL |               |x| {\n+   |  _________________^\n+LL | |                 let target = 3;\n+LL | |                 x == target\n+LL | |             },\n+   | |_____________^\n+   |\n+   = note: `-D clippy::block-in-if-condition-stmt` implied by `-D warnings`\n+\n+error: in an `if` condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a `let`\n+  --> $DIR/block_in_if_condition_closure.rs:28:13\n+   |\n+LL |           |x| {\n+   |  _____________^\n+LL | |             let target = 3;\n+LL | |             x == target\n+LL | |         },\n+   | |_________^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "c4149ad19c1e9b677c95f6f2b32d987a17d154d7", "filename": "tests/ui/collapsible_else_if.fixed", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fcollapsible_else_if.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fcollapsible_else_if.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_else_if.fixed?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -10,57 +10,57 @@ fn main() {\n     if x == \"hello\" {\n         print!(\"Hello \");\n     } else if y == \"world\" {\n-    println!(\"world!\")\n-}\n+        println!(\"world!\")\n+    }\n \n     if x == \"hello\" {\n         print!(\"Hello \");\n     } else if let Some(42) = Some(42) {\n-    println!(\"world!\")\n-}\n+        println!(\"world!\")\n+    }\n \n     if x == \"hello\" {\n         print!(\"Hello \");\n     } else if y == \"world\" {\n-    println!(\"world\")\n-}\n-else {\n-    println!(\"!\")\n-}\n+        println!(\"world\")\n+    }\n+    else {\n+        println!(\"!\")\n+    }\n \n     if x == \"hello\" {\n         print!(\"Hello \");\n     } else if let Some(42) = Some(42) {\n-    println!(\"world\")\n-}\n-else {\n-    println!(\"!\")\n-}\n+        println!(\"world\")\n+    }\n+    else {\n+        println!(\"!\")\n+    }\n \n     if let Some(42) = Some(42) {\n         print!(\"Hello \");\n     } else if let Some(42) = Some(42) {\n-    println!(\"world\")\n-}\n-else {\n-    println!(\"!\")\n-}\n+        println!(\"world\")\n+    }\n+    else {\n+        println!(\"!\")\n+    }\n \n     if let Some(42) = Some(42) {\n         print!(\"Hello \");\n     } else if x == \"hello\" {\n-    println!(\"world\")\n-}\n-else {\n-    println!(\"!\")\n-}\n+        println!(\"world\")\n+    }\n+    else {\n+        println!(\"!\")\n+    }\n \n     if let Some(42) = Some(42) {\n         print!(\"Hello \");\n     } else if let Some(42) = Some(42) {\n-    println!(\"world\")\n-}\n-else {\n-    println!(\"!\")\n-}\n+        println!(\"world\")\n+    }\n+    else {\n+        println!(\"!\")\n+    }\n }"}, {"sha": "28048999e8ec9568a8071135f2e3612bccddae43", "filename": "tests/ui/collapsible_else_if.stderr", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fcollapsible_else_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fcollapsible_else_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_else_if.stderr?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -13,8 +13,8 @@ LL | |     }\n help: try\n    |\n LL |     } else if y == \"world\" {\n-LL |     println!(\"world!\")\n-LL | }\n+LL |         println!(\"world!\")\n+LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n@@ -31,8 +31,8 @@ LL | |     }\n help: try\n    |\n LL |     } else if let Some(42) = Some(42) {\n-LL |     println!(\"world!\")\n-LL | }\n+LL |         println!(\"world!\")\n+LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n@@ -51,11 +51,11 @@ LL | |     }\n help: try\n    |\n LL |     } else if y == \"world\" {\n-LL |     println!(\"world\")\n-LL | }\n-LL | else {\n-LL |     println!(\"!\")\n-LL | }\n+LL |         println!(\"world\")\n+LL |     }\n+LL |     else {\n+LL |         println!(\"!\")\n+LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n@@ -74,11 +74,11 @@ LL | |     }\n help: try\n    |\n LL |     } else if let Some(42) = Some(42) {\n-LL |     println!(\"world\")\n-LL | }\n-LL | else {\n-LL |     println!(\"!\")\n-LL | }\n+LL |         println!(\"world\")\n+LL |     }\n+LL |     else {\n+LL |         println!(\"!\")\n+LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n@@ -97,11 +97,11 @@ LL | |     }\n help: try\n    |\n LL |     } else if let Some(42) = Some(42) {\n-LL |     println!(\"world\")\n-LL | }\n-LL | else {\n-LL |     println!(\"!\")\n-LL | }\n+LL |         println!(\"world\")\n+LL |     }\n+LL |     else {\n+LL |         println!(\"!\")\n+LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n@@ -120,11 +120,11 @@ LL | |     }\n help: try\n    |\n LL |     } else if x == \"hello\" {\n-LL |     println!(\"world\")\n-LL | }\n-LL | else {\n-LL |     println!(\"!\")\n-LL | }\n+LL |         println!(\"world\")\n+LL |     }\n+LL |     else {\n+LL |         println!(\"!\")\n+LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n@@ -143,11 +143,11 @@ LL | |     }\n help: try\n    |\n LL |     } else if let Some(42) = Some(42) {\n-LL |     println!(\"world\")\n-LL | }\n-LL | else {\n-LL |     println!(\"!\")\n-LL | }\n+LL |         println!(\"world\")\n+LL |     }\n+LL |     else {\n+LL |         println!(\"!\")\n+LL |     }\n    |\n \n error: aborting due to 7 previous errors"}, {"sha": "076771f5c57e1f0cfc031cda29c5a71c05e71c8f", "filename": "tests/ui/collapsible_if.fixed", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fcollapsible_if.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fcollapsible_if.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_if.fixed?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -7,28 +7,28 @@ fn main() {\n     let x = \"hello\";\n     let y = \"world\";\n     if x == \"hello\" && y == \"world\" {\n-    println!(\"Hello world!\");\n-}\n+        println!(\"Hello world!\");\n+    }\n \n     if (x == \"hello\" || x == \"world\") && (y == \"world\" || y == \"hello\") {\n-    println!(\"Hello world!\");\n-}\n+        println!(\"Hello world!\");\n+    }\n \n     if x == \"hello\" && x == \"world\" && (y == \"world\" || y == \"hello\") {\n-    println!(\"Hello world!\");\n-}\n+        println!(\"Hello world!\");\n+    }\n \n     if (x == \"hello\" || x == \"world\") && y == \"world\" && y == \"hello\" {\n-    println!(\"Hello world!\");\n-}\n+        println!(\"Hello world!\");\n+    }\n \n     if x == \"hello\" && x == \"world\" && y == \"world\" && y == \"hello\" {\n-    println!(\"Hello world!\");\n-}\n+        println!(\"Hello world!\");\n+    }\n \n     if 42 == 1337 && 'a' != 'A' {\n-    println!(\"world!\")\n-}\n+        println!(\"world!\")\n+    }\n \n     // Works because any if with an else statement cannot be collapsed.\n     if x == \"hello\" {\n@@ -81,8 +81,8 @@ fn main() {\n     }\n \n     if x == \"hello\" && y == \"world\" { // Collapsible\n-    println!(\"Hello world!\");\n-}\n+        println!(\"Hello world!\");\n+    }\n \n     if x == \"hello\" {\n         print!(\"Hello \");"}, {"sha": "6440ff41be81e243da433c4ac3ac7ec67b6bf55a", "filename": "tests/ui/collapsible_if.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fcollapsible_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fcollapsible_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_if.stderr?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -12,8 +12,8 @@ LL | |     }\n help: try\n    |\n LL |     if x == \"hello\" && y == \"world\" {\n-LL |     println!(\"Hello world!\");\n-LL | }\n+LL |         println!(\"Hello world!\");\n+LL |     }\n    |\n \n error: this `if` statement can be collapsed\n@@ -29,8 +29,8 @@ LL | |     }\n help: try\n    |\n LL |     if (x == \"hello\" || x == \"world\") && (y == \"world\" || y == \"hello\") {\n-LL |     println!(\"Hello world!\");\n-LL | }\n+LL |         println!(\"Hello world!\");\n+LL |     }\n    |\n \n error: this `if` statement can be collapsed\n@@ -46,8 +46,8 @@ LL | |     }\n help: try\n    |\n LL |     if x == \"hello\" && x == \"world\" && (y == \"world\" || y == \"hello\") {\n-LL |     println!(\"Hello world!\");\n-LL | }\n+LL |         println!(\"Hello world!\");\n+LL |     }\n    |\n \n error: this `if` statement can be collapsed\n@@ -63,8 +63,8 @@ LL | |     }\n help: try\n    |\n LL |     if (x == \"hello\" || x == \"world\") && y == \"world\" && y == \"hello\" {\n-LL |     println!(\"Hello world!\");\n-LL | }\n+LL |         println!(\"Hello world!\");\n+LL |     }\n    |\n \n error: this `if` statement can be collapsed\n@@ -80,8 +80,8 @@ LL | |     }\n help: try\n    |\n LL |     if x == \"hello\" && x == \"world\" && y == \"world\" && y == \"hello\" {\n-LL |     println!(\"Hello world!\");\n-LL | }\n+LL |         println!(\"Hello world!\");\n+LL |     }\n    |\n \n error: this `if` statement can be collapsed\n@@ -97,8 +97,8 @@ LL | |     }\n help: try\n    |\n LL |     if 42 == 1337 && 'a' != 'A' {\n-LL |     println!(\"world!\")\n-LL | }\n+LL |         println!(\"world!\")\n+LL |     }\n    |\n \n error: this `if` statement can be collapsed\n@@ -114,8 +114,8 @@ LL | |     }\n help: try\n    |\n LL |     if x == \"hello\" && y == \"world\" { // Collapsible\n-LL |     println!(\"Hello world!\");\n-LL | }\n+LL |         println!(\"Hello world!\");\n+LL |     }\n    |\n \n error: aborting due to 7 previous errors"}, {"sha": "d0c20eb2696b93804a982c065df56cc239c70814", "filename": "tests/ui/match_bool.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fmatch_bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fmatch_bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_bool.stderr?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -40,8 +40,8 @@ LL | |     };\n help: consider using an `if`/`else` expression\n    |\n LL |     if !test {\n-LL |     println!(\"Noooo!\");\n-LL | };\n+LL |         println!(\"Noooo!\");\n+LL |     };\n    |\n \n error: you seem to be trying to match on a boolean expression\n@@ -58,8 +58,8 @@ LL | |     };\n help: consider using an `if`/`else` expression\n    |\n LL |     if !test {\n-LL |     println!(\"Noooo!\");\n-LL | };\n+LL |         println!(\"Noooo!\");\n+LL |     };\n    |\n \n error: you seem to be trying to match on a boolean expression\n@@ -76,8 +76,8 @@ LL | |     };\n help: consider using an `if`/`else` expression\n    |\n LL |     if !(test && test) {\n-LL |     println!(\"Noooo!\");\n-LL | };\n+LL |         println!(\"Noooo!\");\n+LL |     };\n    |\n \n error: equal expressions as operands to `&&`\n@@ -103,10 +103,10 @@ LL | |     };\n help: consider using an `if`/`else` expression\n    |\n LL |     if test {\n-LL |     println!(\"Yes!\");\n-LL | } else {\n-LL |     println!(\"Noooo!\");\n-LL | };\n+LL |         println!(\"Yes!\");\n+LL |     } else {\n+LL |         println!(\"Noooo!\");\n+LL |     };\n    |\n \n error: aborting due to 8 previous errors"}, {"sha": "932bd6783a15cd12d83433664eee17aded6a3b78", "filename": "tests/ui/match_single_binding.fixed", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.fixed?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -14,12 +14,12 @@ fn main() {\n     let c = 3;\n     // Lint\n     let (x, y, z) = (a, b, c);\n-{\n-    println!(\"{} {} {}\", x, y, z);\n-}\n+    {\n+        println!(\"{} {} {}\", x, y, z);\n+    }\n     // Lint\n     let (x, y, z) = (a, b, c);\n-println!(\"{} {} {}\", x, y, z);\n+    println!(\"{} {} {}\", x, y, z);\n     // Ok\n     match a {\n         2 => println!(\"2\"),\n@@ -35,29 +35,29 @@ println!(\"{} {} {}\", x, y, z);\n     println!(\"whatever\");\n     // Lint\n     {\n-    let x = 29;\n-    println!(\"x has a value of {}\", x);\n-}\n+        let x = 29;\n+        println!(\"x has a value of {}\", x);\n+    }\n     // Lint\n     {\n-    let e = 5 * a;\n-    if e >= 5 {\n-        println!(\"e is superior to 5\");\n+        let e = 5 * a;\n+        if e >= 5 {\n+            println!(\"e is superior to 5\");\n+        }\n     }\n-}\n     // Lint\n     let p = Point { x: 0, y: 7 };\n     let Point { x, y } = p;\n-println!(\"Coords: ({}, {})\", x, y);\n+    println!(\"Coords: ({}, {})\", x, y);\n     // Lint\n     let Point { x: x1, y: y1 } = p;\n-println!(\"Coords: ({}, {})\", x1, y1);\n+    println!(\"Coords: ({}, {})\", x1, y1);\n     // Lint\n     let x = 5;\n     let ref r = x;\n-println!(\"Got a reference to {}\", r);\n+    println!(\"Got a reference to {}\", r);\n     // Lint\n     let mut x = 5;\n     let ref mut mr = x;\n-println!(\"Got a mutable reference to {}\", mr);\n+    println!(\"Got a mutable reference to {}\", mr);\n }"}, {"sha": "471aec780d23affe72d65f21798d917cc2881738", "filename": "tests/ui/match_single_binding.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fmatch_single_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fmatch_single_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.stderr?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -12,9 +12,9 @@ LL | |     }\n help: consider using `let` statement\n    |\n LL |     let (x, y, z) = (a, b, c);\n-LL | {\n-LL |     println!(\"{} {} {}\", x, y, z);\n-LL | }\n+LL |     {\n+LL |         println!(\"{} {} {}\", x, y, z);\n+LL |     }\n    |\n \n error: this match could be written as a `let` statement\n@@ -28,7 +28,7 @@ LL | |     }\n help: consider using `let` statement\n    |\n LL |     let (x, y, z) = (a, b, c);\n-LL | println!(\"{} {} {}\", x, y, z);\n+LL |     println!(\"{} {} {}\", x, y, z);\n    |\n \n error: this match could be replaced by its body itself\n@@ -53,9 +53,9 @@ LL | |     }\n help: consider using the match body instead\n    |\n LL |     {\n-LL |     let x = 29;\n-LL |     println!(\"x has a value of {}\", x);\n-LL | }\n+LL |         let x = 29;\n+LL |         println!(\"x has a value of {}\", x);\n+LL |     }\n    |\n \n error: this match could be replaced by its body itself\n@@ -73,11 +73,11 @@ LL | |     }\n help: consider using the match body instead\n    |\n LL |     {\n-LL |     let e = 5 * a;\n-LL |     if e >= 5 {\n-LL |         println!(\"e is superior to 5\");\n+LL |         let e = 5 * a;\n+LL |         if e >= 5 {\n+LL |             println!(\"e is superior to 5\");\n+LL |         }\n LL |     }\n-LL | }\n    |\n \n error: this match could be written as a `let` statement\n@@ -91,7 +91,7 @@ LL | |     }\n help: consider using `let` statement\n    |\n LL |     let Point { x, y } = p;\n-LL | println!(\"Coords: ({}, {})\", x, y);\n+LL |     println!(\"Coords: ({}, {})\", x, y);\n    |\n \n error: this match could be written as a `let` statement\n@@ -105,7 +105,7 @@ LL | |     }\n help: consider using `let` statement\n    |\n LL |     let Point { x: x1, y: y1 } = p;\n-LL | println!(\"Coords: ({}, {})\", x1, y1);\n+LL |     println!(\"Coords: ({}, {})\", x1, y1);\n    |\n \n error: this match could be written as a `let` statement\n@@ -119,7 +119,7 @@ LL | |     }\n help: consider using `let` statement\n    |\n LL |     let ref r = x;\n-LL | println!(\"Got a reference to {}\", r);\n+LL |     println!(\"Got a reference to {}\", r);\n    |\n \n error: this match could be written as a `let` statement\n@@ -133,7 +133,7 @@ LL | |     }\n help: consider using `let` statement\n    |\n LL |     let ref mut mr = x;\n-LL | println!(\"Got a mutable reference to {}\", mr);\n+LL |     println!(\"Got a mutable reference to {}\", mr);\n    |\n \n error: aborting due to 9 previous errors"}, {"sha": "8d6a37df9601afcd1fdf9094a442b4422cf0c6fc", "filename": "tests/ui/needless_continue.stderr", "status": "modified", "additions": 57, "deletions": 59, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fneedless_continue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fneedless_continue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_continue.stderr?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -1,5 +1,4 @@\n-error: This `else` block is redundant.\n-\n+error: this `else` block is redundant\n   --> $DIR/needless_continue.rs:28:16\n    |\n LL |           } else {\n@@ -9,34 +8,33 @@ LL | |         }\n    | |_________^\n    |\n    = note: `-D clippy::needless-continue` implied by `-D warnings`\n-   = help: Consider dropping the `else` clause and merging the code that follows (in the loop) with the `if` block, like so:\n-           if i % 2 == 0 && i % 3 == 0 {\n-           println!(\"{}\", i);\n-           println!(\"{}\", i + 1);\n-           if i % 5 == 0 {\n-               println!(\"{}\", i + 2);\n-           }\n-           let i = 0;\n-           println!(\"bar {} \", i);\n-           // Merged code follows...println!(\"bleh\");\n-           {\n-               println!(\"blah\");\n-           }\n-           if !(!(i == 2) || !(i == 5)) {\n-               println!(\"lama\");\n-           }\n-           if (zero!(i % 2) || nonzero!(i % 5)) && i % 3 != 0 {\n-               continue;\n-           } else {\n-               println!(\"Blabber\");\n-               println!(\"Jabber\");\n-           }\n-           println!(\"bleh\");\n-           }\n-           \n-\n-error: There is no need for an explicit `else` block for this `if` expression\n+   = help: consider dropping the `else` clause and merging the code that follows (in the loop) with the `if` block\n+                   if i % 2 == 0 && i % 3 == 0 {\n+                       println!(\"{}\", i);\n+                       println!(\"{}\", i + 1);\n+                       if i % 5 == 0 {\n+                           println!(\"{}\", i + 2);\n+                       }\n+                       let i = 0;\n+                       println!(\"bar {} \", i);\n+                       // merged code follows:\n+                       println!(\"bleh\");\n+                       {\n+                           println!(\"blah\");\n+                       }\n+                       if !(!(i == 2) || !(i == 5)) {\n+                           println!(\"lama\");\n+                       }\n+                       if (zero!(i % 2) || nonzero!(i % 5)) && i % 3 != 0 {\n+                           continue;\n+                       } else {\n+                           println!(\"Blabber\");\n+                           println!(\"Jabber\");\n+                       }\n+                       println!(\"bleh\");\n+                   }\n \n+error: there is no need for an explicit `else` block for this `if` expression\n   --> $DIR/needless_continue.rs:43:9\n    |\n LL | /         if (zero!(i % 2) || nonzero!(i % 5)) && i % 3 != 0 {\n@@ -47,16 +45,16 @@ LL | |             println!(\"Jabber\");\n LL | |         }\n    | |_________^\n    |\n-   = help: Consider dropping the `else` clause, and moving out the code in the `else` block, like so:\n-           if (zero!(i % 2) || nonzero!(i % 5)) && i % 3 != 0 {\n-               continue;\n-           }\n-           println!(\"Blabber\");\n-           println!(\"Jabber\");\n-           ...\n-\n-error: This `else` block is redundant.\n+   = help: consider dropping the `else` clause\n+                   if (zero!(i % 2) || nonzero!(i % 5)) && i % 3 != 0 {\n+                       continue;\n+                   }\n+                   {\n+                       println!(\"Blabber\");\n+                       println!(\"Jabber\");\n+                   }\n \n+error: this `else` block is redundant\n   --> $DIR/needless_continue.rs:100:24\n    |\n LL |                   } else {\n@@ -65,22 +63,21 @@ LL | |                     continue 'inner; // should lint here\n LL | |                 }\n    | |_________________^\n    |\n-   = help: Consider dropping the `else` clause and merging the code that follows (in the loop) with the `if` block, like so:\n-           if condition() {\n-           println!(\"bar-3\");\n-           // Merged code follows...println!(\"bar-4\");\n-           update_condition();\n-           if condition() {\n-               continue; // should lint here\n-           } else {\n-               println!(\"bar-5\");\n-           }\n-           println!(\"bar-6\");\n-           }\n-           \n-\n-error: There is no need for an explicit `else` block for this `if` expression\n+   = help: consider dropping the `else` clause and merging the code that follows (in the loop) with the `if` block\n+                           if condition() {\n+                               println!(\"bar-3\");\n+                               // merged code follows:\n+                               println!(\"bar-4\");\n+                               update_condition();\n+                               if condition() {\n+                                   continue; // should lint here\n+                               } else {\n+                                   println!(\"bar-5\");\n+                               }\n+                               println!(\"bar-6\");\n+                           }\n \n+error: there is no need for an explicit `else` block for this `if` expression\n   --> $DIR/needless_continue.rs:106:17\n    |\n LL | /                 if condition() {\n@@ -90,12 +87,13 @@ LL | |                     println!(\"bar-5\");\n LL | |                 }\n    | |_________________^\n    |\n-   = help: Consider dropping the `else` clause, and moving out the code in the `else` block, like so:\n-           if condition() {\n-               continue;\n-           }\n-           println!(\"bar-5\");\n-           ...\n+   = help: consider dropping the `else` clause\n+                           if condition() {\n+                               continue; // should lint here\n+                           }\n+                           {\n+                               println!(\"bar-5\");\n+                           }\n \n error: aborting due to 4 previous errors\n "}, {"sha": "f69554d75f9bf7aa1f08f4e0bfb3fc3d5d4bb89a", "filename": "tests/ui/single_match.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.stderr?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -13,8 +13,8 @@ LL | |     };\n help: try this\n    |\n LL |     if let Some(y) = x {\n-LL |     println!(\"{:?}\", y);\n-LL | };\n+LL |         println!(\"{:?}\", y);\n+LL |     };\n    |\n \n error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`"}, {"sha": "59861d46eb34cf5383bec85151672e023308e719", "filename": "tests/ui/single_match_else.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5e6d6db417a88f67e94b63463940c21bc37120b/tests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.stderr?ref=b5e6d6db417a88f67e94b63463940c21bc37120b", "patch": "@@ -14,9 +14,9 @@ LL | |     }\n help: try this\n    |\n LL |     if let ExprNode::ExprAddrOf = ExprNode::Butterflies { Some(&NODE) } else {\n-LL |     let x = 5;\n-LL |     None\n-LL | }\n+LL |         let x = 5;\n+LL |         None\n+LL |     }\n    |\n \n error: aborting due to previous error"}]}