{"sha": "5f64d5df339a4794d19d5be0f5291f6bfef38ec1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNjRkNWRmMzM5YTQ3OTRkMTlkNWJlMGY1MjkxZjZiZmVmMzhlYzE=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-15T17:55:20Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-15T17:55:43Z"}, "message": "sync+arc - comments and attributes only", "tree": {"sha": "ba2229eb50ba8c245c4741284b55952876f09423", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba2229eb50ba8c245c4741284b55952876f09423"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f64d5df339a4794d19d5be0f5291f6bfef38ec1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f64d5df339a4794d19d5be0f5291f6bfef38ec1", "html_url": "https://github.com/rust-lang/rust/commit/5f64d5df339a4794d19d5be0f5291f6bfef38ec1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f64d5df339a4794d19d5be0f5291f6bfef38ec1/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f29f308c1c7c611cda6e1fc8a56179296868d144", "url": "https://api.github.com/repos/rust-lang/rust/commits/f29f308c1c7c611cda6e1fc8a56179296868d144", "html_url": "https://github.com/rust-lang/rust/commit/f29f308c1c7c611cda6e1fc8a56179296868d144"}], "stats": {"total": 52, "additions": 45, "deletions": 7}, "files": [{"sha": "b6139e93723f306258959a6c1deb9e9885d3bdc4", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f64d5df339a4794d19d5be0f5291f6bfef38ec1/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f64d5df339a4794d19d5be0f5291f6bfef38ec1/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=5f64d5df339a4794d19d5be0f5291f6bfef38ec1", "patch": "@@ -97,6 +97,7 @@ fn clone<T: const send>(rc: &arc<T>) -> arc<T> {\n  * Mutex protected ARC (unsafe)\n  ****************************************************************************/\n \n+#[doc(hidden)]\n struct mutex_arc_inner<T: send> { lock: mutex; failed: bool; data: T; }\n /// An ARC with mutable data protected by a blocking mutex.\n struct mutex_arc<T: send> { x: SharedMutableState<mutex_arc_inner<T>>; }\n@@ -182,6 +183,7 @@ impl<T: send> &mutex_arc<T> {\n \n // Common code for {mutex.access,rwlock.write}{,_cond}.\n #[inline(always)]\n+#[doc(hidden)]\n fn check_poison(is_mutex: bool, failed: bool) {\n     if failed {\n         if is_mutex {\n@@ -192,6 +194,7 @@ fn check_poison(is_mutex: bool, failed: bool) {\n     }\n }\n \n+#[doc(hidden)]\n struct poison_on_fail {\n     failed: &mut bool;\n     new(failed: &mut bool) { self.failed = failed; }\n@@ -205,6 +208,7 @@ struct poison_on_fail {\n  * R/W lock protected ARC\n  ****************************************************************************/\n \n+#[doc(hidden)]\n struct rw_arc_inner<T: const send> { lock: rwlock; failed: bool; data: T; }\n /**\n  * A dual-mode ARC protected by a reader-writer lock. The data can be accessed\n@@ -346,6 +350,7 @@ impl<T: const send> &rw_arc<T> {\n // Borrowck rightly complains about immutably aliasing the rwlock in order to\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n+#[doc(hidden)]\n fn borrow_rwlock<T: const send>(state: &mut rw_arc_inner<T>) -> &rwlock {\n     unsafe { unsafe::reinterpret_cast(&state.lock) }\n }"}, {"sha": "a1ac6bb894534acfd58f4ba2a04517ee84c8011d", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5f64d5df339a4794d19d5be0f5291f6bfef38ec1/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f64d5df339a4794d19d5be0f5291f6bfef38ec1/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=5f64d5df339a4794d19d5be0f5291f6bfef38ec1", "patch": "@@ -18,14 +18,18 @@ import unsafe::{Exclusive, exclusive};\n  * Internals\n  ****************************************************************************/\n \n-// Each waiting task receives on one of these. FIXME #3125 make these oneshot.\n+// Each waiting task receives on one of these.\n+#[doc(hidden)]\n type wait_end = pipes::port_one<()>;\n+#[doc(hidden)]\n type signal_end = pipes::chan_one<()>;\n // A doubly-ended queue of waiting tasks.\n+#[doc(hidden)]\n struct waitqueue { head: pipes::port<signal_end>;\n                    tail: pipes::chan<signal_end>; }\n \n // Signals one live task from the queue.\n+#[doc(hidden)]\n fn signal_waitqueue(q: &waitqueue) -> bool {\n     // The peek is mandatory to make sure recv doesn't block.\n     if q.head.peek() {\n@@ -41,6 +45,7 @@ fn signal_waitqueue(q: &waitqueue) -> bool {\n     }\n }\n \n+#[doc(hidden)]\n fn broadcast_waitqueue(q: &waitqueue) -> uint {\n     let mut count = 0;\n     while q.head.peek() {\n@@ -52,22 +57,26 @@ fn broadcast_waitqueue(q: &waitqueue) -> uint {\n }\n \n // The building-block used to make semaphores, mutexes, and rwlocks.\n+#[doc(hidden)]\n struct sem_inner<Q> {\n     mut count: int;\n     waiters:   waitqueue;\n     // Can be either unit or another waitqueue. Some sems shouldn't come with\n     // a condition variable attached, others should.\n     blocked:   Q;\n }\n+#[doc(hidden)]\n enum sem<Q: send> = Exclusive<sem_inner<Q>>;\n \n+#[doc(hidden)]\n fn new_sem<Q: send>(count: int, +q: Q) -> sem<Q> {\n     let (wait_tail, wait_head)  = pipes::stream();\n     sem(exclusive(sem_inner {\n         mut count: count,\n         waiters: waitqueue { head: wait_head, tail: wait_tail },\n         blocked: q }))\n }\n+#[doc(hidden)]\n fn new_sem_and_signal(count: int, num_condvars: uint) -> sem<~[waitqueue]> {\n     let mut queues = ~[];\n     for num_condvars.times {\n@@ -77,6 +86,7 @@ fn new_sem_and_signal(count: int, num_condvars: uint) -> sem<~[waitqueue]> {\n     new_sem(count, queues)\n }\n \n+#[doc(hidden)]\n impl<Q: send> &sem<Q> {\n     fn acquire() {\n         let mut waiter_nobe = none;\n@@ -112,6 +122,7 @@ impl<Q: send> &sem<Q> {\n     }\n }\n // FIXME(#3154) move both copies of this into sem<Q>, and unify the 2 structs\n+#[doc(hidden)]\n impl &sem<()> {\n     fn access<U>(blk: fn() -> U) -> U {\n         let mut release = none;\n@@ -124,6 +135,7 @@ impl &sem<()> {\n         blk()\n     }\n }\n+#[doc(hidden)]\n impl &sem<~[waitqueue]> {\n     fn access<U>(blk: fn() -> U) -> U {\n         let mut release = none;\n@@ -138,11 +150,13 @@ impl &sem<~[waitqueue]> {\n }\n \n // FIXME(#3136) should go inside of access()\n+#[doc(hidden)]\n struct sem_release {\n     sem: &sem<()>;\n     new(sem: &sem<()>) { self.sem = sem; }\n     drop { self.sem.release(); }\n }\n+#[doc(hidden)]\n struct sem_and_signal_release {\n     sem: &sem<~[waitqueue]>;\n     new(sem: &sem<~[waitqueue]>) { self.sem = sem; }\n@@ -153,7 +167,14 @@ struct sem_and_signal_release {\n struct condvar { priv sem: &sem<~[waitqueue]>; drop { } }\n \n impl &condvar {\n-    /// Atomically drop the associated lock, and block until a signal is sent.\n+    /**\n+     * Atomically drop the associated lock, and block until a signal is sent.\n+     *\n+     * # Failure\n+     * A task which is killed (i.e., by linked failure with another task)\n+     * while waiting on a condition variable will wake up, fail, and unlock\n+     * the associated lock as it unwinds.\n+     */\n     fn wait() { self.wait_on(0) }\n     /**\n      * As wait(), but can specify which of multiple condition variables to\n@@ -267,6 +288,7 @@ impl &condvar {\n // Checks whether a condvar ID was out of bounds, and fails if so, or does\n // something else next on success.\n #[inline(always)]\n+#[doc(hidden)]\n fn check_cvar_bounds<U>(out_of_bounds: option<uint>, id: uint, act: &str,\n                         blk: fn() -> U) -> U {\n     match out_of_bounds {\n@@ -280,6 +302,7 @@ fn check_cvar_bounds<U>(out_of_bounds: option<uint>, id: uint, act: &str,\n     }\n }\n \n+#[doc(hidden)]\n impl &sem<~[waitqueue]> {\n     // The only other place that condvars get built is rwlock_write_mode.\n     fn access_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n@@ -316,7 +339,6 @@ impl &semaphore {\n     fn release() { (&self.sem).release() }\n \n     /// Run a function with ownership of one of the semaphore's resources.\n-    // FIXME(#3145): figure out whether or not this should get exported.\n     fn access<U>(blk: fn() -> U) -> U { (&self.sem).access(blk) }\n }\n \n@@ -327,7 +349,10 @@ impl &semaphore {\n /**\n  * A blocking, bounded-waiting, mutual exclusion lock with an associated\n  * FIFO condition variable.\n- * FIXME(#3145): document killability\n+ *\n+ * # Failure\n+ * A task which fails while holding a mutex will unlock the mutex as it\n+ * unwinds.\n  */\n struct mutex { priv sem: sem<~[waitqueue]>; }\n \n@@ -362,12 +387,19 @@ impl &mutex {\n \n // NB: Wikipedia - Readers-writers_problem#The_third_readers-writers_problem\n \n+#[doc(hidden)]\n struct rwlock_inner {\n     read_mode:  bool;\n     read_count: uint;\n }\n \n-/// A blocking, no-starvation, reader-writer lock with an associated condvar.\n+/**\n+ * A blocking, no-starvation, reader-writer lock with an associated condvar.\n+ *\n+ * # Failure\n+ * A task which fails while holding an rwlock will unlock the rwlock as it\n+ * unwinds.\n+ */\n struct rwlock {\n     /* priv */ order_lock:  semaphore;\n     /* priv */ access_lock: sem<~[waitqueue]>;\n@@ -527,6 +559,7 @@ impl &rwlock {\n }\n \n // FIXME(#3136) should go inside of read()\n+#[doc(hidden)]\n struct rwlock_release_read {\n     lock: &rwlock;\n     new(lock: &rwlock) { self.lock = lock; }\n@@ -550,6 +583,7 @@ struct rwlock_release_read {\n }\n \n // FIXME(#3136) should go inside of downgrade()\n+#[doc(hidden)]\n struct rwlock_release_downgrade {\n     lock: &rwlock;\n     new(lock: &rwlock) { self.lock = lock; }\n@@ -580,8 +614,7 @@ struct rwlock_release_downgrade {\n }\n \n /// The \"write permission\" token used for rwlock.write_downgrade().\n-// FIXME(#3145): make lock priv somehow\n-struct rwlock_write_mode { lock: &rwlock; drop { } }\n+struct rwlock_write_mode { /* priv */ lock: &rwlock; drop { } }\n /// The \"read permission\" token used for rwlock.write_downgrade().\n struct rwlock_read_mode  { priv lock: &rwlock; drop { } }\n "}]}