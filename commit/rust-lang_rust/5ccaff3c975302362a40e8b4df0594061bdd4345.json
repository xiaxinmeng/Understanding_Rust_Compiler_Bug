{"sha": "5ccaff3c975302362a40e8b4df0594061bdd4345", "node_id": "C_kwDOAAsO6NoAKDVjY2FmZjNjOTc1MzAyMzYyYTQwZThiNGRmMDU5NDA2MWJkZDQzNDU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-11T19:49:39Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-11T19:49:50Z"}, "message": "Simplify", "tree": {"sha": "4844a461b4b269f04c2e8c4472c3c0762dc4983b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4844a461b4b269f04c2e8c4472c3c0762dc4983b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ccaff3c975302362a40e8b4df0594061bdd4345", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ccaff3c975302362a40e8b4df0594061bdd4345", "html_url": "https://github.com/rust-lang/rust/commit/5ccaff3c975302362a40e8b4df0594061bdd4345", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ccaff3c975302362a40e8b4df0594061bdd4345/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e9ecb9f5859afcca31b0c130b0b81325036e5a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e9ecb9f5859afcca31b0c130b0b81325036e5a6", "html_url": "https://github.com/rust-lang/rust/commit/1e9ecb9f5859afcca31b0c130b0b81325036e5a6"}], "stats": {"total": 107, "additions": 63, "deletions": 44}, "files": [{"sha": "b35d97e425211ac844b985d2dbd2de2f0f8f75c4", "filename": "crates/ide_completion/src/completions/postfix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=5ccaff3c975302362a40e8b4df0594061bdd4345", "patch": "@@ -19,7 +19,7 @@ use crate::{\n     context::CompletionContext,\n     item::{Builder, CompletionKind},\n     patterns::ImmediateLocation,\n-    CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n+    CompletionItem, CompletionItemKind, CompletionRelevance, Completions, SnippetScope,\n };\n \n pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -231,7 +231,7 @@ fn add_custom_postfix_completions(\n ) -> Option<()> {\n     let import_scope =\n         ImportScope::find_insert_use_container_with_macros(&ctx.token.parent()?, &ctx.sema)?;\n-    ctx.config.postfix_snippets().filter(|(_, snip)| snip.is_expr()).for_each(\n+    ctx.config.postfix_snippets().filter(|(_, snip)| snip.scope == SnippetScope::Expr).for_each(\n         |(trigger, snippet)| {\n             let imports = match snippet.imports(ctx, &import_scope) {\n                 Some(imports) => imports,"}, {"sha": "5e5c7efdfb924885df26b5e6d5a0bbee74100d84", "filename": "crates/ide_completion/src/config.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fconfig.rs?ref=5ccaff3c975302362a40e8b4df0594061bdd4345", "patch": "@@ -22,13 +22,14 @@ pub struct CompletionConfig {\n \n impl CompletionConfig {\n     pub fn postfix_snippets(&self) -> impl Iterator<Item = (&str, &Snippet)> {\n-        self.snippets.iter().flat_map(|snip| {\n-            snip.postfix_triggers.iter().map(move |trigger| (trigger.as_str(), snip))\n-        })\n+        self.snippets\n+            .iter()\n+            .flat_map(|snip| snip.postfix_triggers.iter().map(move |trigger| (&**trigger, snip)))\n     }\n+\n     pub fn prefix_snippets(&self) -> impl Iterator<Item = (&str, &Snippet)> {\n-        self.snippets.iter().flat_map(|snip| {\n-            snip.prefix_triggers.iter().map(move |trigger| (trigger.as_str(), snip))\n-        })\n+        self.snippets\n+            .iter()\n+            .flat_map(|snip| snip.prefix_triggers.iter().map(move |trigger| (&**trigger, snip)))\n     }\n }"}, {"sha": "11ae139bb7395007961131d6561f1bce0992c9bf", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=5ccaff3c975302362a40e8b4df0594061bdd4345", "patch": "@@ -85,6 +85,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) original_token: SyntaxToken,\n     /// The token before the cursor, in the macro-expanded file.\n     pub(super) token: SyntaxToken,\n+    /// The crate of the current file.\n     pub(super) krate: Option<hir::Crate>,\n     pub(super) expected_name: Option<NameOrNameRef>,\n     pub(super) expected_type: Option<Type>,\n@@ -135,11 +136,11 @@ impl<'a> CompletionContext<'a> {\n         let fake_ident_token =\n             file_with_fake_ident.syntax().token_at_offset(position.offset).right_biased().unwrap();\n \n-        let krate = sema.to_module_def(position.file_id).map(|m| m.krate());\n         let original_token =\n             original_file.syntax().token_at_offset(position.offset).left_biased()?;\n         let token = sema.descend_into_macros(original_token.clone());\n         let scope = sema.scope_at_offset(&token, position.offset);\n+        let krate = scope.krate();\n         let mut locals = vec![];\n         scope.process_all_names(&mut |name, scope| {\n             if let ScopeDef::Local(local) = scope {\n@@ -182,6 +183,8 @@ impl<'a> CompletionContext<'a> {\n         Some(ctx)\n     }\n \n+    /// Do the attribute expansion at the current cursor position for both original file and fake file\n+    /// as long as possible. As soon as one of the two expansions fail we stop to stay in sync.\n     fn expand_and_fill(\n         &mut self,\n         mut original_file: SyntaxNode,\n@@ -428,6 +431,7 @@ impl<'a> CompletionContext<'a> {\n         false\n     }\n \n+    /// Check if an item is `#[doc(hidden)]`.\n     pub(crate) fn is_item_hidden(&self, item: &hir::ItemInNs) -> bool {\n         let attrs = item.attrs(self.db);\n         let krate = item.krate(self.db);\n@@ -474,11 +478,11 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn is_doc_hidden(&self, attrs: &hir::Attrs, defining_crate: hir::Crate) -> bool {\n-        let module = match self.scope.module() {\n+        let krate = match self.krate {\n             Some(it) => it,\n             None => return true,\n         };\n-        if module.krate() != defining_crate && attrs.has_doc_hidden() {\n+        if krate != defining_crate && attrs.has_doc_hidden() {\n             // `doc(hidden)` items are only completed within the defining crate.\n             return true;\n         }"}, {"sha": "a9eec472caf60d2c5c8e233a5e71e21db6b82b24", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=5ccaff3c975302362a40e8b4df0594061bdd4345", "patch": "@@ -218,6 +218,7 @@ impl CompletionRelevance {\n     }\n }\n \n+/// The type of the completion item.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum CompletionItemKind {\n     SymbolKind(SymbolKind),\n@@ -269,6 +270,8 @@ impl CompletionItemKind {\n     }\n }\n \n+// FIXME remove this?\n+/// Like [`CompletionItemKind`] but solely used for filtering test results.\n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub(crate) enum CompletionKind {\n     /// Parser-based keyword completion.\n@@ -477,9 +480,10 @@ impl Builder {\n     }\n     pub(crate) fn insert_snippet(\n         &mut self,\n-        _cap: SnippetCap,\n+        cap: SnippetCap,\n         snippet: impl Into<String>,\n     ) -> &mut Builder {\n+        let _ = cap;\n         self.is_snippet = true;\n         self.insert_text(snippet)\n     }"}, {"sha": "6680e66c6062ad89ebe2af96455b33beca44f180", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=5ccaff3c975302362a40e8b4df0594061bdd4345", "patch": "@@ -173,6 +173,7 @@ pub fn completions(\n }\n \n /// Resolves additional completion data at the position given.\n+/// This is used for import insertion done via completions like flyimport and custom user snippets.\n pub fn resolve_completion_edits(\n     db: &RootDatabase,\n     config: &CompletionConfig,"}, {"sha": "4c2e704a7fbd6ce6bd6ba1b715cf25f8989c40e6", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=5ccaff3c975302362a40e8b4df0594061bdd4345", "patch": "@@ -28,6 +28,9 @@ pub(crate) enum ImmediatePrevSibling {\n }\n \n /// Direct parent \"thing\" of what we are currently completing.\n+///\n+/// This may contain nodes of the fake file as well as the original, comments on the variants specify\n+/// from which file the nodes are.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum ImmediateLocation {\n     Use,\n@@ -42,32 +45,35 @@ pub(crate) enum ImmediateLocation {\n     StmtList,\n     ItemList,\n     TypeBound,\n-    // Fake file ast node\n+    /// Fake file ast node\n     Attribute(ast::Attr),\n-    // Fake file ast node\n+    /// Fake file ast node\n     ModDeclaration(ast::Module),\n     Visibility(ast::Visibility),\n-    // Original file ast node\n+    /// Original file ast node\n     MethodCall {\n         receiver: Option<ast::Expr>,\n         has_parens: bool,\n     },\n-    // Original file ast node\n+    /// Original file ast node\n     FieldAccess {\n         receiver: Option<ast::Expr>,\n         receiver_is_ambiguous_float_literal: bool,\n     },\n-    // Original file ast node\n     // Only set from a type arg\n+    /// Original file ast node\n     GenericArgList(ast::GenericArgList),\n-    // Original file ast node\n     /// The record expr of the field name we are completing\n+    ///\n+    /// Original file ast node\n     RecordExpr(ast::RecordExpr),\n-    // Original file ast node\n     /// The record expr of the functional update syntax we are completing\n+    ///\n+    /// Original file ast node\n     RecordExprUpdate(ast::RecordExpr),\n-    // Original file ast node\n     /// The record pat of the field name we are completing\n+    ///\n+    /// Original file ast node\n     RecordPat(ast::RecordPat),\n }\n \n@@ -268,17 +274,20 @@ pub(crate) fn determine_location(\n     Some(res)\n }\n \n+/// Maximize a nameref to its enclosing path if its the last segment of said path.\n+/// That is, when completing a [`NameRef`] we actually handle it as the path it is part of when determining\n+/// its location.\n fn maximize_name_ref(name_ref: &ast::NameRef) -> SyntaxNode {\n-    // Maximize a nameref to its enclosing path if its the last segment of said path\n     if let Some(segment) = name_ref.syntax().parent().and_then(ast::PathSegment::cast) {\n         let p = segment.parent_path();\n         if p.parent_path().is_none() {\n-            if let Some(it) = p\n+            // Get rid of PathExpr, PathType, etc...\n+            let path = p\n                 .syntax()\n                 .ancestors()\n                 .take_while(|it| it.text_range() == p.syntax().text_range())\n-                .last()\n-            {\n+                .last();\n+            if let Some(it) = path {\n                 return it;\n             }\n         }"}, {"sha": "53ed7de2d6f469f9a469f5ddacb238f1743188e3", "filename": "crates/ide_completion/src/snippet.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ccaff3c975302362a40e8b4df0594061bdd4345/crates%2Fide_completion%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fsnippet.rs?ref=5ccaff3c975302362a40e8b4df0594061bdd4345", "patch": "@@ -1,6 +1,8 @@\n //! User (postfix)-snippet definitions.\n //!\n-//! Actual logic is implemented in [`crate::completions::postfix`] and [`crate::completions::snippet`].\n+//! Actual logic is implemented in [`crate::completions::postfix`] and [`crate::completions::snippet`] respectively.\n+\n+use std::ops::Deref;\n \n // Feature: User Snippet Completions\n //\n@@ -58,21 +60,24 @@ use syntax::ast;\n \n use crate::{context::CompletionContext, ImportEdit};\n \n+/// A snippet scope describing where a snippet may apply to.\n+/// These may differ slightly in meaning depending on the snippet trigger.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum SnippetScope {\n     Item,\n     Expr,\n     Type,\n }\n \n+/// A user supplied snippet.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct Snippet {\n-    pub postfix_triggers: Box<[String]>,\n-    pub prefix_triggers: Box<[String]>,\n+    pub postfix_triggers: Box<[Box<str>]>,\n+    pub prefix_triggers: Box<[Box<str>]>,\n     pub scope: SnippetScope,\n     snippet: String,\n-    pub description: Option<String>,\n-    pub requires: Box<[String]>,\n+    pub description: Option<Box<str>>,\n+    pub requires: Box<[Box<str>]>,\n }\n \n impl Snippet {\n@@ -84,19 +89,22 @@ impl Snippet {\n         requires: &[String],\n         scope: SnippetScope,\n     ) -> Option<Self> {\n+        if prefix_triggers.is_empty() && postfix_triggers.is_empty() {\n+            return None;\n+        }\n         let (snippet, description) = validate_snippet(snippet, description, requires)?;\n         Some(Snippet {\n             // Box::into doesn't work as that has a Copy bound \ud83d\ude12\n-            postfix_triggers: postfix_triggers.iter().cloned().collect(),\n-            prefix_triggers: prefix_triggers.iter().cloned().collect(),\n+            postfix_triggers: postfix_triggers.iter().map(Deref::deref).map(Into::into).collect(),\n+            prefix_triggers: prefix_triggers.iter().map(Deref::deref).map(Into::into).collect(),\n             scope,\n             snippet,\n             description,\n-            requires: requires.iter().cloned().collect(),\n+            requires: requires.iter().map(Deref::deref).map(Into::into).collect(),\n         })\n     }\n \n-    /// Returns None if the required items do not resolve.\n+    /// Returns [`None`] if the required items do not resolve.\n     pub(crate) fn imports(\n         &self,\n         ctx: &CompletionContext,\n@@ -112,20 +120,12 @@ impl Snippet {\n     pub fn postfix_snippet(&self, receiver: &str) -> String {\n         self.snippet.replace(\"${receiver}\", receiver)\n     }\n-\n-    pub fn is_item(&self) -> bool {\n-        self.scope == SnippetScope::Item\n-    }\n-\n-    pub fn is_expr(&self) -> bool {\n-        self.scope == SnippetScope::Expr\n-    }\n }\n \n fn import_edits(\n     ctx: &CompletionContext,\n     import_scope: &ImportScope,\n-    requires: &[String],\n+    requires: &[Box<str>],\n ) -> Option<Vec<ImportEdit>> {\n     let resolve = |import| {\n         let path = ast::Path::parse(import).ok()?;\n@@ -158,7 +158,7 @@ fn validate_snippet(\n     snippet: &[String],\n     description: &str,\n     requires: &[String],\n-) -> Option<(String, Option<String>)> {\n+) -> Option<(String, Option<Box<str>>)> {\n     // validate that these are indeed simple paths\n     // we can't save the paths unfortunately due to them not being Send+Sync\n     if requires.iter().any(|path| match ast::Path::parse(path) {\n@@ -171,6 +171,6 @@ fn validate_snippet(\n         return None;\n     }\n     let snippet = snippet.iter().join(\"\\n\");\n-    let description = if description.is_empty() { None } else { Some(description.to_owned()) };\n+    let description = if description.is_empty() { None } else { Some(description.into()) };\n     Some((snippet, description))\n }"}]}