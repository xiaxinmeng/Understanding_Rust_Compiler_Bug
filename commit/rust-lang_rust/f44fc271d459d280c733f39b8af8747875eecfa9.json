{"sha": "f44fc271d459d280c733f39b8af8747875eecfa9", "node_id": "C_kwDOAAsO6NoAKGY0NGZjMjcxZDQ1OWQyODBjNzMzZjM5YjhhZjg3NDc4NzVlZWNmYTk", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-06-03T13:54:10Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-06-03T13:54:10Z"}, "message": "Remove unnecessary `StorageDead`", "tree": {"sha": "8cfc173a49a25008440e3591226da9682c486304", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cfc173a49a25008440e3591226da9682c486304"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f44fc271d459d280c733f39b8af8747875eecfa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f44fc271d459d280c733f39b8af8747875eecfa9", "html_url": "https://github.com/rust-lang/rust/commit/f44fc271d459d280c733f39b8af8747875eecfa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f44fc271d459d280c733f39b8af8747875eecfa9/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aab7589c401817d00859f76424508fd11a66d974", "url": "https://api.github.com/repos/rust-lang/rust/commits/aab7589c401817d00859f76424508fd11a66d974", "html_url": "https://github.com/rust-lang/rust/commit/aab7589c401817d00859f76424508fd11a66d974"}], "stats": {"total": 539, "additions": 238, "deletions": 301}, "files": [{"sha": "754ac88bb50ce42805b78e9212678f373194b069", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 31, "deletions": 74, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f44fc271d459d280c733f39b8af8747875eecfa9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44fc271d459d280c733f39b8af8747875eecfa9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=f44fc271d459d280c733f39b8af8747875eecfa9", "patch": "@@ -9,10 +9,7 @@ use chalk_ir::{\n };\n use hir_def::{\n     data::adt::VariantData,\n-    hir::{\n-        Array, BinaryOp, BindingAnnotation, BindingId, CaptureBy, Expr, ExprId, Pat, PatId,\n-        Statement, UnaryOp,\n-    },\n+    hir::{Array, BinaryOp, BindingId, CaptureBy, Expr, ExprId, Pat, PatId, Statement, UnaryOp},\n     lang_item::LangItem,\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n     DefWithBodyId, FieldId, HasModule, VariantId,\n@@ -28,9 +25,9 @@ use crate::{\n     mir::{BorrowKind, MirSpan, ProjectionElem},\n     static_lifetime, to_chalk_trait_id,\n     traits::FnTrait,\n-    utils::{self, generics, pattern_matching_dereference_count, Generics},\n-    Adjust, Adjustment, Binders, ChalkTraitId, ClosureId, ConstValue, DynTy, FnPointer, FnSig,\n-    Interner, Substitution, Ty, TyExt,\n+    utils::{self, generics, Generics},\n+    Adjust, Adjustment, Binders, BindingMode, ChalkTraitId, ClosureId, ConstValue, DynTy,\n+    FnPointer, FnSig, Interner, Substitution, Ty, TyExt,\n };\n \n use super::{Expectation, InferenceContext};\n@@ -488,13 +485,7 @@ impl InferenceContext<'_> {\n                             if let Some(initializer) = initializer {\n                                 self.walk_expr(*initializer);\n                                 if let Some(place) = self.place_of_expr(*initializer) {\n-                                    let ty = self.expr_ty(*initializer);\n-                                    self.consume_with_pat(\n-                                        place,\n-                                        ty,\n-                                        BindingAnnotation::Unannotated,\n-                                        *pat,\n-                                    );\n+                                    self.consume_with_pat(place, *pat);\n                                 }\n                             }\n                         }\n@@ -799,41 +790,37 @@ impl InferenceContext<'_> {\n         }\n     }\n \n-    fn consume_with_pat(\n-        &mut self,\n-        mut place: HirPlace,\n-        mut ty: Ty,\n-        mut bm: BindingAnnotation,\n-        pat: PatId,\n-    ) {\n+    fn consume_with_pat(&mut self, mut place: HirPlace, pat: PatId) {\n+        let cnt = self.result.pat_adjustments.get(&pat).map(|x| x.len()).unwrap_or_default();\n+        place.projections = place\n+            .projections\n+            .iter()\n+            .cloned()\n+            .chain((0..cnt).map(|_| ProjectionElem::Deref))\n+            .collect::<Vec<_>>()\n+            .into();\n         match &self.body[pat] {\n             Pat::Missing | Pat::Wild => (),\n             Pat::Tuple { args, ellipsis } => {\n-                pattern_matching_dereference(&mut ty, &mut bm, &mut place);\n                 let (al, ar) = args.split_at(ellipsis.unwrap_or(args.len()));\n-                let subst = match ty.kind(Interner) {\n-                    TyKind::Tuple(_, s) => s,\n+                let field_count = match self.result[pat].kind(Interner) {\n+                    TyKind::Tuple(_, s) => s.len(Interner),\n                     _ => return,\n                 };\n-                let fields = subst.iter(Interner).map(|x| x.assert_ty_ref(Interner)).enumerate();\n+                let fields = 0..field_count;\n                 let it = al.iter().zip(fields.clone()).chain(ar.iter().rev().zip(fields.rev()));\n-                for (arg, (i, ty)) in it {\n+                for (arg, i) in it {\n                     let mut p = place.clone();\n                     p.projections.push(ProjectionElem::TupleOrClosureField(i));\n-                    self.consume_with_pat(p, ty.clone(), bm, *arg);\n+                    self.consume_with_pat(p, *arg);\n                 }\n             }\n             Pat::Or(pats) => {\n                 for pat in pats.iter() {\n-                    self.consume_with_pat(place.clone(), ty.clone(), bm, *pat);\n+                    self.consume_with_pat(place.clone(), *pat);\n                 }\n             }\n             Pat::Record { args, .. } => {\n-                pattern_matching_dereference(&mut ty, &mut bm, &mut place);\n-                let subst = match ty.kind(Interner) {\n-                    TyKind::Adt(_, s) => s,\n-                    _ => return,\n-                };\n                 let Some(variant) = self.result.variant_resolution_for_pat(pat) else {\n                     return;\n                 };\n@@ -843,7 +830,6 @@ impl InferenceContext<'_> {\n                     }\n                     VariantId::StructId(s) => {\n                         let vd = &*self.db.struct_data(s).variant_data;\n-                        let field_types = self.db.field_types(variant);\n                         for field_pat in args.iter() {\n                             let arg = field_pat.pat;\n                             let Some(local_id) = vd.field(&field_pat.name) else {\n@@ -854,12 +840,7 @@ impl InferenceContext<'_> {\n                                 parent: variant.into(),\n                                 local_id,\n                             }));\n-                            self.consume_with_pat(\n-                                p,\n-                                field_types[local_id].clone().substitute(Interner, subst),\n-                                bm,\n-                                arg,\n-                            );\n+                            self.consume_with_pat(p, arg);\n                         }\n                     }\n                 }\n@@ -870,26 +851,20 @@ impl InferenceContext<'_> {\n             | Pat::Path(_)\n             | Pat::Lit(_) => self.consume_place(place, pat.into()),\n             Pat::Bind { id, subpat: _ } => {\n-                let mode = self.body.bindings[*id].mode;\n-                if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n-                    bm = mode;\n-                }\n-                let capture_kind = match bm {\n-                    BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n+                let mode = self.result.binding_modes[*id];\n+                let capture_kind = match mode {\n+                    BindingMode::Move => {\n                         self.consume_place(place, pat.into());\n                         return;\n                     }\n-                    BindingAnnotation::Ref => BorrowKind::Shared,\n-                    BindingAnnotation::RefMut => BorrowKind::Mut { allow_two_phase_borrow: false },\n+                    BindingMode::Ref(Mutability::Not) => BorrowKind::Shared,\n+                    BindingMode::Ref(Mutability::Mut) => {\n+                        BorrowKind::Mut { allow_two_phase_borrow: false }\n+                    }\n                 };\n                 self.add_capture(place, CaptureKind::ByRef(capture_kind), pat.into());\n             }\n             Pat::TupleStruct { path: _, args, ellipsis } => {\n-                pattern_matching_dereference(&mut ty, &mut bm, &mut place);\n-                let subst = match ty.kind(Interner) {\n-                    TyKind::Adt(_, s) => s,\n-                    _ => return,\n-                };\n                 let Some(variant) = self.result.variant_resolution_for_pat(pat) else {\n                     return;\n                 };\n@@ -903,29 +878,20 @@ impl InferenceContext<'_> {\n                         let fields = vd.fields().iter();\n                         let it =\n                             al.iter().zip(fields.clone()).chain(ar.iter().rev().zip(fields.rev()));\n-                        let field_types = self.db.field_types(variant);\n                         for (arg, (i, _)) in it {\n                             let mut p = place.clone();\n                             p.projections.push(ProjectionElem::Field(FieldId {\n                                 parent: variant.into(),\n                                 local_id: i,\n                             }));\n-                            self.consume_with_pat(\n-                                p,\n-                                field_types[i].clone().substitute(Interner, subst),\n-                                bm,\n-                                *arg,\n-                            );\n+                            self.consume_with_pat(p, *arg);\n                         }\n                     }\n                 }\n             }\n             Pat::Ref { pat, mutability: _ } => {\n-                if let Some((inner, _, _)) = ty.as_reference() {\n-                    ty = inner.clone();\n-                    place.projections.push(ProjectionElem::Deref);\n-                    self.consume_with_pat(place, ty, bm, *pat)\n-                }\n+                place.projections.push(ProjectionElem::Deref);\n+                self.consume_with_pat(place, *pat)\n             }\n             Pat::Box { .. } => (), // not supported\n         }\n@@ -1054,12 +1020,3 @@ fn apply_adjusts_to_place(mut r: HirPlace, adjustments: &[Adjustment]) -> Option\n     }\n     Some(r)\n }\n-\n-fn pattern_matching_dereference(\n-    cond_ty: &mut Ty,\n-    binding_mode: &mut BindingAnnotation,\n-    cond_place: &mut HirPlace,\n-) {\n-    let cnt = pattern_matching_dereference_count(cond_ty, binding_mode);\n-    cond_place.projections.extend((0..cnt).map(|_| ProjectionElem::Deref));\n-}"}, {"sha": "ef94b3650bce4c7020040f3c21de27823b16cd4c", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f44fc271d459d280c733f39b8af8747875eecfa9/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44fc271d459d280c733f39b8af8747875eecfa9/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=f44fc271d459d280c733f39b8af8747875eecfa9", "patch": "@@ -478,9 +478,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     current,\n                     None,\n                     cond_place,\n-                    self.expr_ty_after_adjustments(*expr),\n                     *pat,\n-                    BindingAnnotation::Unannotated,\n                 )?;\n                 self.write_bytes_to_place(\n                     then_target,\n@@ -598,16 +596,13 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 else {\n                     return Ok(None);\n                 };\n-                let cond_ty = self.expr_ty_after_adjustments(*expr);\n                 let mut end = None;\n                 for MatchArm { pat, guard, expr } in arms.iter() {\n                     let (then, mut otherwise) = self.pattern_match(\n                         current,\n                         None,\n                         cond_place.clone(),\n-                        cond_ty.clone(),\n                         *pat,\n-                        BindingAnnotation::Unannotated,\n                     )?;\n                     let then = if let &Some(guard) = guard {\n                         let next = self.new_basic_block();\n@@ -1477,9 +1472,6 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         span: MirSpan,\n     ) -> Result<()> {\n         self.drop_scopes.last_mut().unwrap().locals.push(l);\n-        // FIXME: this storage dead is not neccessary, but since drop scope handling is broken, we need\n-        // it to avoid falso positives in mutability errors\n-        self.push_statement(current, StatementKind::StorageDead(l).with_span(span));\n         self.push_statement(current, StatementKind::StorageLive(l).with_span(span));\n         Ok(())\n     }\n@@ -1508,14 +1500,8 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                             return Ok(None);\n                         };\n                         current = c;\n-                        (current, else_block) = self.pattern_match(\n-                            current,\n-                            None,\n-                            init_place,\n-                            self.expr_ty_after_adjustments(*expr_id),\n-                            *pat,\n-                            BindingAnnotation::Unannotated,\n-                        )?;\n+                        (current, else_block) =\n+                            self.pattern_match(current, None, init_place, *pat)?;\n                         match (else_block, else_branch) {\n                             (None, _) => (),\n                             (Some(else_block), None) => {\n@@ -1595,14 +1581,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     continue;\n                 }\n             }\n-            let r = self.pattern_match(\n-                current,\n-                None,\n-                local.into(),\n-                self.result.locals[local].ty.clone(),\n-                param,\n-                BindingAnnotation::Unannotated,\n-            )?;\n+            let r = self.pattern_match(current, None, local.into(), param)?;\n             if let Some(b) = r.1 {\n                 self.set_terminator(b, TerminatorKind::Unreachable, param.into());\n             }"}, {"sha": "5cd1be6842439d4145c9b7d9d19aecd3a641c4dc", "filename": "crates/hir-ty/src/mir/lower/pattern_matching.rs", "status": "modified", "additions": 202, "deletions": 183, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/f44fc271d459d280c733f39b8af8747875eecfa9/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44fc271d459d280c733f39b8af8747875eecfa9/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs?ref=f44fc271d459d280c733f39b8af8747875eecfa9", "patch": "@@ -2,7 +2,7 @@\n \n use hir_def::{hir::LiteralOrConst, resolver::HasResolver, AssocItemId};\n \n-use crate::utils::pattern_matching_dereference_count;\n+use crate::BindingMode;\n \n use super::*;\n \n@@ -18,6 +18,26 @@ pub(super) enum AdtPatternShape<'a> {\n     Unit,\n }\n \n+/// We need to do pattern matching in two phases: One to check if the pattern matches, and one to fill the bindings\n+/// of patterns. This is necessary to prevent double moves and similar problems. For example:\n+/// ```ignore\n+/// struct X;\n+/// match (X, 3) {\n+///     (b, 2) | (b, 3) => {},\n+///     _ => {}\n+/// }\n+/// ```\n+/// If we do everything in one pass, we will move `X` to the first `b`, then we see that the second field of tuple\n+/// doesn't match and we should move the `X` to the second `b` (which here is the same thing, but doesn't need to be) and\n+/// it might even doesn't match the second pattern and we may want to not move `X` at all.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum MatchingMode {\n+    /// Check that if this pattern matches\n+    Check,\n+    /// Assume that this pattern matches, fill bindings\n+    Bind,\n+}\n+\n impl MirLowerCtx<'_> {\n     /// It gets a `current` unterminated block, appends some statements and possibly a terminator to it to check if\n     /// the pattern matches and write bindings, and returns two unterminated blocks, one for the matched path (which\n@@ -29,20 +49,50 @@ impl MirLowerCtx<'_> {\n     /// wouldn't be `None` as well. Note that this function will add jumps to the beginning of the `current_else` block,\n     /// so it should be an empty block.\n     pub(super) fn pattern_match(\n+        &mut self,\n+        current: BasicBlockId,\n+        current_else: Option<BasicBlockId>,\n+        cond_place: Place,\n+        pattern: PatId,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        let (current, current_else) = self.pattern_match_inner(\n+            current,\n+            current_else,\n+            cond_place.clone(),\n+            pattern,\n+            MatchingMode::Check,\n+        )?;\n+        let (current, current_else) = self.pattern_match_inner(\n+            current,\n+            current_else,\n+            cond_place,\n+            pattern,\n+            MatchingMode::Bind,\n+        )?;\n+        Ok((current, current_else))\n+    }\n+\n+    fn pattern_match_inner(\n         &mut self,\n         mut current: BasicBlockId,\n         mut current_else: Option<BasicBlockId>,\n         mut cond_place: Place,\n-        mut cond_ty: Ty,\n         pattern: PatId,\n-        mut binding_mode: BindingAnnotation,\n+        mode: MatchingMode,\n     ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        let cnt = self.infer.pat_adjustments.get(&pattern).map(|x| x.len()).unwrap_or_default();\n+        cond_place.projection = cond_place\n+            .projection\n+            .iter()\n+            .cloned()\n+            .chain((0..cnt).map(|_| ProjectionElem::Deref))\n+            .collect::<Vec<_>>()\n+            .into();\n         Ok(match &self.body.pats[pattern] {\n             Pat::Missing => return Err(MirLowerError::IncompletePattern),\n             Pat::Wild => (current, current_else),\n             Pat::Tuple { args, ellipsis } => {\n-                pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n-                let subst = match cond_ty.kind(Interner) {\n+                let subst = match self.infer[pattern].kind(Interner) {\n                     TyKind::Tuple(_, s) => s,\n                     _ => {\n                         return Err(MirLowerError::TypeError(\n@@ -55,25 +105,31 @@ impl MirLowerCtx<'_> {\n                     current_else,\n                     args,\n                     *ellipsis,\n-                    subst.iter(Interner).enumerate().map(|(i, x)| {\n-                        (PlaceElem::TupleOrClosureField(i), x.assert_ty_ref(Interner).clone())\n-                    }),\n-                    &cond_place,\n-                    binding_mode,\n+                    (0..subst.len(Interner)).map(|i| PlaceElem::TupleOrClosureField(i)),\n+                    &(&mut cond_place),\n+                    mode,\n                 )?\n             }\n             Pat::Or(pats) => {\n                 let then_target = self.new_basic_block();\n                 let mut finished = false;\n                 for pat in &**pats {\n-                    let (next, next_else) = self.pattern_match(\n+                    let (mut next, next_else) = self.pattern_match_inner(\n                         current,\n                         None,\n-                        cond_place.clone(),\n-                        cond_ty.clone(),\n+                        (&mut cond_place).clone(),\n                         *pat,\n-                        binding_mode,\n+                        MatchingMode::Check,\n                     )?;\n+                    if mode == MatchingMode::Bind {\n+                        (next, _) = self.pattern_match_inner(\n+                            next,\n+                            None,\n+                            (&mut cond_place).clone(),\n+                            *pat,\n+                            MatchingMode::Bind,\n+                        )?;\n+                    }\n                     self.set_goto(next, then_target, pattern.into());\n                     match next_else {\n                         Some(t) => {\n@@ -86,8 +142,12 @@ impl MirLowerCtx<'_> {\n                     }\n                 }\n                 if !finished {\n-                    let ce = *current_else.get_or_insert_with(|| self.new_basic_block());\n-                    self.set_goto(current, ce, pattern.into());\n+                    if mode == MatchingMode::Bind {\n+                        self.set_terminator(current, TerminatorKind::Unreachable, pattern.into());\n+                    } else {\n+                        let ce = *current_else.get_or_insert_with(|| self.new_basic_block());\n+                        self.set_goto(current, ce, pattern.into());\n+                    }\n                 }\n                 (then_target, current_else)\n             }\n@@ -96,27 +156,31 @@ impl MirLowerCtx<'_> {\n                     not_supported!(\"unresolved variant for record\");\n                 };\n                 self.pattern_matching_variant(\n-                    cond_ty,\n-                    binding_mode,\n                     cond_place,\n                     variant,\n                     current,\n                     pattern.into(),\n                     current_else,\n                     AdtPatternShape::Record { args: &*args },\n+                    mode,\n                 )?\n             }\n             Pat::Range { start, end } => {\n                 let mut add_check = |l: &LiteralOrConst, binop| -> Result<()> {\n-                    let lv = self.lower_literal_or_const_to_operand(cond_ty.clone(), l)?;\n+                    let lv =\n+                        self.lower_literal_or_const_to_operand(self.infer[pattern].clone(), l)?;\n                     let else_target = *current_else.get_or_insert_with(|| self.new_basic_block());\n                     let next = self.new_basic_block();\n                     let discr: Place =\n                         self.temp(TyBuilder::bool(), current, pattern.into())?.into();\n                     self.push_assignment(\n                         current,\n                         discr.clone(),\n-                        Rvalue::CheckedBinaryOp(binop, lv, Operand::Copy(cond_place.clone())),\n+                        Rvalue::CheckedBinaryOp(\n+                            binop,\n+                            lv,\n+                            Operand::Copy((&mut cond_place).clone()),\n+                        ),\n                         pattern.into(),\n                     );\n                     let discr = Operand::Copy(discr);\n@@ -131,24 +195,25 @@ impl MirLowerCtx<'_> {\n                     current = next;\n                     Ok(())\n                 };\n-                if let Some(start) = start {\n-                    add_check(start, BinOp::Le)?;\n-                }\n-                if let Some(end) = end {\n-                    add_check(end, BinOp::Ge)?;\n+                if mode == MatchingMode::Check {\n+                    if let Some(start) = start {\n+                        add_check(start, BinOp::Le)?;\n+                    }\n+                    if let Some(end) = end {\n+                        add_check(end, BinOp::Ge)?;\n+                    }\n                 }\n                 (current, current_else)\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n-                pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n-                if let TyKind::Slice(_) = cond_ty.kind(Interner) {\n+                if let TyKind::Slice(_) = self.infer[pattern].kind(Interner) {\n                     let pattern_len = prefix.len() + suffix.len();\n                     let place_len: Place =\n                         self.temp(TyBuilder::usize(), current, pattern.into())?.into();\n                     self.push_assignment(\n                         current,\n                         place_len.clone(),\n-                        Rvalue::Len(cond_place.clone()),\n+                        Rvalue::Len((&mut cond_place).clone()),\n                         pattern.into(),\n                     );\n                     let else_target = *current_else.get_or_insert_with(|| self.new_basic_block());\n@@ -193,63 +258,49 @@ impl MirLowerCtx<'_> {\n                     current = next;\n                 }\n                 for (i, &pat) in prefix.iter().enumerate() {\n-                    let next_place = cond_place.project(ProjectionElem::ConstantIndex {\n+                    let next_place = (&mut cond_place).project(ProjectionElem::ConstantIndex {\n                         offset: i as u64,\n                         from_end: false,\n                     });\n-                    let cond_ty = self.infer[pat].clone();\n-                    (current, current_else) = self.pattern_match(\n-                        current,\n-                        current_else,\n-                        next_place,\n-                        cond_ty,\n-                        pat,\n-                        binding_mode,\n-                    )?;\n+                    (current, current_else) =\n+                        self.pattern_match_inner(current, current_else, next_place, pat, mode)?;\n                 }\n                 if let Some(slice) = slice {\n-                    if let Pat::Bind { id, subpat: _ } = self.body[*slice] {\n-                        let next_place = cond_place.project(ProjectionElem::Subslice {\n-                            from: prefix.len() as u64,\n-                            to: suffix.len() as u64,\n-                        });\n-                        (current, current_else) = self.pattern_match_binding(\n-                            id,\n-                            &mut binding_mode,\n-                            next_place,\n-                            (*slice).into(),\n-                            current,\n-                            current_else,\n-                        )?;\n+                    if mode == MatchingMode::Bind {\n+                        if let Pat::Bind { id, subpat: _ } = self.body[*slice] {\n+                            let next_place = (&mut cond_place).project(ProjectionElem::Subslice {\n+                                from: prefix.len() as u64,\n+                                to: suffix.len() as u64,\n+                            });\n+                            (current, current_else) = self.pattern_match_binding(\n+                                id,\n+                                next_place,\n+                                (*slice).into(),\n+                                current,\n+                                current_else,\n+                            )?;\n+                        }\n                     }\n                 }\n                 for (i, &pat) in suffix.iter().enumerate() {\n-                    let next_place = cond_place.project(ProjectionElem::ConstantIndex {\n+                    let next_place = (&mut cond_place).project(ProjectionElem::ConstantIndex {\n                         offset: i as u64,\n                         from_end: true,\n                     });\n-                    let cond_ty = self.infer[pat].clone();\n-                    (current, current_else) = self.pattern_match(\n-                        current,\n-                        current_else,\n-                        next_place,\n-                        cond_ty,\n-                        pat,\n-                        binding_mode,\n-                    )?;\n+                    (current, current_else) =\n+                        self.pattern_match_inner(current, current_else, next_place, pat, mode)?;\n                 }\n                 (current, current_else)\n             }\n             Pat::Path(p) => match self.infer.variant_resolution_for_pat(pattern) {\n                 Some(variant) => self.pattern_matching_variant(\n-                    cond_ty,\n-                    binding_mode,\n                     cond_place,\n                     variant,\n                     current,\n                     pattern.into(),\n                     current_else,\n                     AdtPatternShape::Unit,\n+                    mode,\n                 )?,\n                 None => {\n                     let unresolved_name = || MirLowerError::unresolved_path(self.db, p);\n@@ -270,9 +321,17 @@ impl MirLowerCtx<'_> {\n                         }\n                         not_supported!(\"path in pattern position that is not const or variant\")\n                     };\n-                    let tmp: Place = self.temp(cond_ty.clone(), current, pattern.into())?.into();\n+                    let tmp: Place =\n+                        self.temp(self.infer[pattern].clone(), current, pattern.into())?.into();\n                     let span = pattern.into();\n-                    self.lower_const(c.into(), current, tmp.clone(), subst, span, cond_ty.clone())?;\n+                    self.lower_const(\n+                        c.into(),\n+                        current,\n+                        tmp.clone(),\n+                        subst,\n+                        span,\n+                        self.infer[pattern].clone(),\n+                    )?;\n                     let tmp2: Place = self.temp(TyBuilder::bool(), current, pattern.into())?.into();\n                     self.push_assignment(\n                         current,\n@@ -299,61 +358,58 @@ impl MirLowerCtx<'_> {\n             },\n             Pat::Lit(l) => match &self.body.exprs[*l] {\n                 Expr::Literal(l) => {\n-                    let c = self.lower_literal_to_operand(cond_ty, l)?;\n-                    self.pattern_match_const(current_else, current, c, cond_place, pattern)?\n+                    let c = self.lower_literal_to_operand(self.infer[pattern].clone(), l)?;\n+                    if mode == MatchingMode::Check {\n+                        self.pattern_match_const(current_else, current, c, cond_place, pattern)?\n+                    } else {\n+                        (current, current_else)\n+                    }\n                 }\n                 _ => not_supported!(\"expression path literal\"),\n             },\n             Pat::Bind { id, subpat } => {\n                 if let Some(subpat) = subpat {\n-                    (current, current_else) = self.pattern_match(\n+                    (current, current_else) = self.pattern_match_inner(\n                         current,\n                         current_else,\n-                        cond_place.clone(),\n-                        cond_ty,\n+                        (&mut cond_place).clone(),\n                         *subpat,\n-                        binding_mode,\n+                        mode,\n                     )?\n                 }\n-                self.pattern_match_binding(\n-                    *id,\n-                    &mut binding_mode,\n-                    cond_place,\n-                    pattern.into(),\n-                    current,\n-                    current_else,\n-                )?\n+                if mode == MatchingMode::Bind {\n+                    self.pattern_match_binding(\n+                        *id,\n+                        cond_place,\n+                        pattern.into(),\n+                        current,\n+                        current_else,\n+                    )?\n+                } else {\n+                    (current, current_else)\n+                }\n             }\n             Pat::TupleStruct { path: _, args, ellipsis } => {\n                 let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n                     not_supported!(\"unresolved variant\");\n                 };\n                 self.pattern_matching_variant(\n-                    cond_ty,\n-                    binding_mode,\n                     cond_place,\n                     variant,\n                     current,\n                     pattern.into(),\n                     current_else,\n                     AdtPatternShape::Tuple { args, ellipsis: *ellipsis },\n+                    mode,\n                 )?\n             }\n-            Pat::Ref { pat, mutability: _ } => {\n-                if let Some((ty, _, _)) = cond_ty.as_reference() {\n-                    cond_ty = ty.clone();\n-                    self.pattern_match(\n-                        current,\n-                        current_else,\n-                        cond_place.project(ProjectionElem::Deref),\n-                        cond_ty,\n-                        *pat,\n-                        binding_mode,\n-                    )?\n-                } else {\n-                    return Err(MirLowerError::TypeError(\"& pattern for non reference\"));\n-                }\n-            }\n+            Pat::Ref { pat, mutability: _ } => self.pattern_match_inner(\n+                current,\n+                current_else,\n+                cond_place.project(ProjectionElem::Deref),\n+                *pat,\n+                mode,\n+            )?,\n             Pat::Box { .. } => not_supported!(\"box pattern\"),\n             Pat::ConstBlock(_) => not_supported!(\"const block pattern\"),\n         })\n@@ -362,27 +418,21 @@ impl MirLowerCtx<'_> {\n     fn pattern_match_binding(\n         &mut self,\n         id: BindingId,\n-        binding_mode: &mut BindingAnnotation,\n         cond_place: Place,\n         span: MirSpan,\n         current: BasicBlockId,\n         current_else: Option<BasicBlockId>,\n     ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n         let target_place = self.binding_local(id)?;\n-        let mode = self.body.bindings[id].mode;\n-        if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n-            *binding_mode = mode;\n-        }\n+        let mode = self.infer.binding_modes[id];\n         self.push_storage_live(id, current)?;\n         self.push_assignment(\n             current,\n             target_place.into(),\n-            match *binding_mode {\n-                BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n-                    Operand::Copy(cond_place).into()\n-                }\n-                BindingAnnotation::Ref => Rvalue::Ref(BorrowKind::Shared, cond_place),\n-                BindingAnnotation::RefMut => {\n+            match mode {\n+                BindingMode::Move => Operand::Copy(cond_place).into(),\n+                BindingMode::Ref(Mutability::Not) => Rvalue::Ref(BorrowKind::Shared, cond_place),\n+                BindingMode::Ref(Mutability::Mut) => {\n                     Rvalue::Ref(BorrowKind::Mut { allow_two_phase_borrow: false }, cond_place)\n                 }\n             },\n@@ -420,52 +470,48 @@ impl MirLowerCtx<'_> {\n         Ok((then_target, Some(else_target)))\n     }\n \n-    pub(super) fn pattern_matching_variant(\n+    fn pattern_matching_variant(\n         &mut self,\n-        mut cond_ty: Ty,\n-        mut binding_mode: BindingAnnotation,\n-        mut cond_place: Place,\n+        cond_place: Place,\n         variant: VariantId,\n-        current: BasicBlockId,\n+        mut current: BasicBlockId,\n         span: MirSpan,\n-        current_else: Option<BasicBlockId>,\n+        mut current_else: Option<BasicBlockId>,\n         shape: AdtPatternShape<'_>,\n+        mode: MatchingMode,\n     ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n-        pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n-        let subst = match cond_ty.kind(Interner) {\n-            TyKind::Adt(_, s) => s,\n-            _ => return Err(MirLowerError::TypeError(\"non adt type matched with tuple struct\")),\n-        };\n         Ok(match variant {\n             VariantId::EnumVariantId(v) => {\n-                let e = self.const_eval_discriminant(v)? as u128;\n-                let tmp = self.discr_temp_place(current);\n-                self.push_assignment(\n-                    current,\n-                    tmp.clone(),\n-                    Rvalue::Discriminant(cond_place.clone()),\n-                    span,\n-                );\n-                let next = self.new_basic_block();\n-                let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n-                self.set_terminator(\n-                    current,\n-                    TerminatorKind::SwitchInt {\n-                        discr: Operand::Copy(tmp),\n-                        targets: SwitchTargets::static_if(e, next, else_target),\n-                    },\n-                    span,\n-                );\n+                if mode == MatchingMode::Check {\n+                    let e = self.const_eval_discriminant(v)? as u128;\n+                    let tmp = self.discr_temp_place(current);\n+                    self.push_assignment(\n+                        current,\n+                        tmp.clone(),\n+                        Rvalue::Discriminant(cond_place.clone()),\n+                        span,\n+                    );\n+                    let next = self.new_basic_block();\n+                    let else_target = current_else.get_or_insert_with(|| self.new_basic_block());\n+                    self.set_terminator(\n+                        current,\n+                        TerminatorKind::SwitchInt {\n+                            discr: Operand::Copy(tmp),\n+                            targets: SwitchTargets::static_if(e, next, *else_target),\n+                        },\n+                        span,\n+                    );\n+                    current = next;\n+                }\n                 let enum_data = self.db.enum_data(v.parent);\n                 self.pattern_matching_variant_fields(\n                     shape,\n                     &enum_data.variants[v.local_id].variant_data,\n                     variant,\n-                    subst,\n-                    next,\n-                    Some(else_target),\n+                    current,\n+                    current_else,\n                     &cond_place,\n-                    binding_mode,\n+                    mode,\n                 )?\n             }\n             VariantId::StructId(s) => {\n@@ -474,11 +520,10 @@ impl MirLowerCtx<'_> {\n                     shape,\n                     &struct_data.variant_data,\n                     variant,\n-                    subst,\n                     current,\n                     current_else,\n                     &cond_place,\n-                    binding_mode,\n+                    mode,\n                 )?\n             }\n             VariantId::UnionId(_) => {\n@@ -492,13 +537,11 @@ impl MirLowerCtx<'_> {\n         shape: AdtPatternShape<'_>,\n         variant_data: &VariantData,\n         v: VariantId,\n-        subst: &Substitution,\n         current: BasicBlockId,\n         current_else: Option<BasicBlockId>,\n         cond_place: &Place,\n-        binding_mode: BindingAnnotation,\n+        mode: MatchingMode,\n     ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n-        let fields_type = self.db.field_types(v);\n         Ok(match shape {\n             AdtPatternShape::Record { args } => {\n                 let it = args\n@@ -509,33 +552,24 @@ impl MirLowerCtx<'_> {\n                         Ok((\n                             PlaceElem::Field(FieldId { parent: v.into(), local_id: field_id }),\n                             x.pat,\n-                            fields_type[field_id].clone().substitute(Interner, subst),\n                         ))\n                     })\n                     .collect::<Result<Vec<_>>>()?;\n-                self.pattern_match_adt(\n-                    current,\n-                    current_else,\n-                    it.into_iter(),\n-                    cond_place,\n-                    binding_mode,\n-                )?\n+                self.pattern_match_adt(current, current_else, it.into_iter(), cond_place, mode)?\n             }\n             AdtPatternShape::Tuple { args, ellipsis } => {\n-                let fields = variant_data.fields().iter().map(|(x, _)| {\n-                    (\n-                        PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n-                        fields_type[x].clone().substitute(Interner, subst),\n-                    )\n-                });\n+                let fields = variant_data\n+                    .fields()\n+                    .iter()\n+                    .map(|(x, _)| PlaceElem::Field(FieldId { parent: v.into(), local_id: x }));\n                 self.pattern_match_tuple_like(\n                     current,\n                     current_else,\n                     args,\n                     ellipsis,\n                     fields,\n                     cond_place,\n-                    binding_mode,\n+                    mode,\n                 )?\n             }\n             AdtPatternShape::Unit => (current, current_else),\n@@ -546,14 +580,14 @@ impl MirLowerCtx<'_> {\n         &mut self,\n         mut current: BasicBlockId,\n         mut current_else: Option<BasicBlockId>,\n-        args: impl Iterator<Item = (PlaceElem, PatId, Ty)>,\n+        args: impl Iterator<Item = (PlaceElem, PatId)>,\n         cond_place: &Place,\n-        binding_mode: BindingAnnotation,\n+        mode: MatchingMode,\n     ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n-        for (proj, arg, ty) in args {\n+        for (proj, arg) in args {\n             let cond_place = cond_place.project(proj);\n             (current, current_else) =\n-                self.pattern_match(current, current_else, cond_place, ty, arg, binding_mode)?;\n+                self.pattern_match_inner(current, current_else, cond_place, arg, mode)?;\n         }\n         Ok((current, current_else))\n     }\n@@ -564,31 +598,16 @@ impl MirLowerCtx<'_> {\n         current_else: Option<BasicBlockId>,\n         args: &[PatId],\n         ellipsis: Option<usize>,\n-        fields: impl DoubleEndedIterator<Item = (PlaceElem, Ty)> + Clone,\n+        fields: impl DoubleEndedIterator<Item = PlaceElem> + Clone,\n         cond_place: &Place,\n-        binding_mode: BindingAnnotation,\n+        mode: MatchingMode,\n     ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n         let (al, ar) = args.split_at(ellipsis.unwrap_or(args.len()));\n         let it = al\n             .iter()\n             .zip(fields.clone())\n             .chain(ar.iter().rev().zip(fields.rev()))\n-            .map(|(x, y)| (y.0, *x, y.1));\n-        self.pattern_match_adt(current, current_else, it, cond_place, binding_mode)\n+            .map(|(x, y)| (y, *x));\n+        self.pattern_match_adt(current, current_else, it, cond_place, mode)\n     }\n }\n-\n-fn pattern_matching_dereference(\n-    cond_ty: &mut Ty,\n-    binding_mode: &mut BindingAnnotation,\n-    cond_place: &mut Place,\n-) {\n-    let cnt = pattern_matching_dereference_count(cond_ty, binding_mode);\n-    cond_place.projection = cond_place\n-        .projection\n-        .iter()\n-        .cloned()\n-        .chain((0..cnt).map(|_| ProjectionElem::Deref))\n-        .collect::<Vec<_>>()\n-        .into();\n-}"}, {"sha": "681d087ede6eaf9d1e4e8a294e2400b29a86156f", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f44fc271d459d280c733f39b8af8747875eecfa9/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44fc271d459d280c733f39b8af8747875eecfa9/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=f44fc271d459d280c733f39b8af8747875eecfa9", "patch": "@@ -7,7 +7,7 @@ use base_db::CrateId;\n use chalk_ir::{\n     cast::Cast,\n     fold::{FallibleTypeFolder, Shift},\n-    BoundVar, DebruijnIndex, Mutability,\n+    BoundVar, DebruijnIndex,\n };\n use either::Either;\n use hir_def::{\n@@ -16,7 +16,6 @@ use hir_def::{\n         GenericParams, TypeOrConstParamData, TypeParamProvenance, WherePredicate,\n         WherePredicateTypeTarget,\n     },\n-    hir::BindingAnnotation,\n     lang_item::LangItem,\n     resolver::{HasResolver, TypeNs},\n     type_ref::{TraitBoundModifier, TypeRef},\n@@ -35,7 +34,7 @@ use crate::{\n     layout::{Layout, TagEncoding},\n     mir::pad16,\n     ChalkTraitId, Const, ConstScalar, GenericArg, Interner, Substitution, TraitRef, TraitRefExt,\n-    Ty, TyExt, WhereClause,\n+    Ty, WhereClause,\n };\n \n pub(crate) fn fn_traits(\n@@ -395,23 +394,6 @@ pub fn is_fn_unsafe_to_call(db: &dyn HirDatabase, func: FunctionId) -> bool {\n     }\n }\n \n-pub(crate) fn pattern_matching_dereference_count(\n-    cond_ty: &mut Ty,\n-    binding_mode: &mut BindingAnnotation,\n-) -> usize {\n-    let mut r = 0;\n-    while let Some((ty, _, mu)) = cond_ty.as_reference() {\n-        if mu == Mutability::Mut && *binding_mode != BindingAnnotation::Ref {\n-            *binding_mode = BindingAnnotation::RefMut;\n-        } else {\n-            *binding_mode = BindingAnnotation::Ref;\n-        }\n-        *cond_ty = ty.clone();\n-        r += 1;\n-    }\n-    r\n-}\n-\n pub(crate) struct UnevaluatedConstEvaluatorFolder<'a> {\n     pub(crate) db: &'a dyn HirDatabase,\n }"}]}