{"sha": "9d64e46013096997627da62ecc65225bc22682e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNjRlNDYwMTMwOTY5OTc2MjdkYTYyZWNjNjUyMjViYzIyNjgyZTg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-11-28T12:52:11Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-04T11:35:53Z"}, "message": "std::str: remove from_utf8.\n\nThis function had type &[u8] -> ~str, i.e. it allocates a string\ninternally, even though the non-allocating version that take &[u8] ->\n&str and ~[u8] -> ~str are all that is necessary in most circumstances.", "tree": {"sha": "fa20c8fd1d653acff5f996253d16103dd61addd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa20c8fd1d653acff5f996253d16103dd61addd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d64e46013096997627da62ecc65225bc22682e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d64e46013096997627da62ecc65225bc22682e8", "html_url": "https://github.com/rust-lang/rust/commit/9d64e46013096997627da62ecc65225bc22682e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d64e46013096997627da62ecc65225bc22682e8/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9635c763ba5edc8c8ea2868b895548b52f640e5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9635c763ba5edc8c8ea2868b895548b52f640e5a", "html_url": "https://github.com/rust-lang/rust/commit/9635c763ba5edc8c8ea2868b895548b52f640e5a"}], "stats": {"total": 342, "additions": 119, "deletions": 223}, "files": [{"sha": "4f05247ada4b832a8ad9e649cc08bf35e8520ae5", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -60,12 +60,12 @@ pub fn run(lib_path: &str,\n     for input in input.iter() {\n         process.input().write(input.as_bytes());\n     }\n-    let output = process.finish_with_output();\n+    let run::ProcessOutput { status, output, error } = process.finish_with_output();\n \n     Result {\n-        status: output.status,\n-        out: str::from_utf8(output.output),\n-        err: str::from_utf8(output.error)\n+        status: status,\n+        out: str::from_utf8_owned(output),\n+        err: str::from_utf8_owned(error)\n     }\n }\n \n@@ -90,4 +90,3 @@ pub fn run_background(lib_path: &str,\n \n     return process;\n }\n-"}, {"sha": "e91652365c3d612e13d030509192f31dc343f128", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -298,7 +298,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n \n                 let adb_arg = format!(\"export LD_LIBRARY_PATH={}; gdbserver :5039 {}/{}\",\n                          config.adb_test_dir.clone(), config.adb_test_dir.clone(),\n-                         str::from_utf8(exe_file.filename().unwrap())).clone();\n+                         str::from_utf8_slice(exe_file.filename().unwrap()));\n \n                 let mut process = procsrv::run_background(\"\", config.adb_path.clone(),\n                         [~\"shell\",adb_arg.clone()],~[(~\"\",~\"\")], Some(~\"\"));\n@@ -1151,4 +1151,3 @@ fn run_codegen_test(config: &config, props: &TestProps,\n                      (base_lines as f64) / (clang_lines as f64),\n                      0.001);\n }\n-"}, {"sha": "c4247799cad1dbb23e8b632cb6823618d1577e76", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -162,7 +162,7 @@ impl<'self> FromBase64 for &'self str {\n      * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes.\n      *\n-     * You can use the `from_utf8` function in `std::str`\n+     * You can use the `from_utf8_owned` function in `std::str`\n      * to turn a `[u8]` into a string with characters corresponding to those\n      * values.\n      *\n@@ -180,7 +180,7 @@ impl<'self> FromBase64 for &'self str {\n      *     println!(\"base64 output: {}\", hello_str);\n      *     let res = hello_str.from_base64();\n      *     if res.is_ok() {\n-     *       let optBytes = str::from_utf8_opt(res.unwrap());\n+     *       let optBytes = str::from_utf8_owned_opt(res.unwrap());\n      *       if optBytes.is_some() {\n      *         println!(\"decoded from base64: {}\", optBytes.unwrap());\n      *       }"}, {"sha": "7daba4c08f23ed06c024fc6c60d55c2878b4d3bb", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -62,7 +62,7 @@ impl<'self> FromHex for &'self str {\n      * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes.\n      *\n-     * You can use the `from_utf8` function in `std::str`\n+     * You can use the `from_utf8_owned` function in `std::str`\n      * to turn a `[u8]` into a string with characters corresponding to those\n      * values.\n      *\n@@ -80,7 +80,7 @@ impl<'self> FromHex for &'self str {\n      *     println!(\"{}\", hello_str);\n      *     let bytes = hello_str.from_hex().unwrap();\n      *     println!(\"{:?}\", bytes);\n-     *     let result_str = str::from_utf8(bytes);\n+     *     let result_str = str::from_utf8_owned(bytes);\n      *     println!(\"{}\", result_str);\n      * }\n      * ```"}, {"sha": "bc997c5147dbd844df6343468299a147c9ae2a41", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -215,7 +215,9 @@ pub fn parse(file: &mut io::Reader,\n         return Err(~\"incompatible file: more string offsets than expected\");\n     }\n \n-    let names_str = str::from_utf8(file.read_bytes(names_bytes as uint - 1)); // don't read NUL\n+    // don't read NUL\n+    let names_str = str::from_utf8_owned(file.read_bytes(names_bytes as uint - 1));\n+\n     let term_names: ~[~str] = names_str.split('|').map(|s| s.to_owned()).collect();\n \n     file.read_byte(); // consume NUL"}, {"sha": "693f4532a43e5abc4c560f71e3d2e9b9a5e0a3ff", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -701,7 +701,7 @@ fn should_sort_failures_before_printing_them() {\n \n     st.write_failures();\n     let s = match st.out {\n-        Right(ref m) => str::from_utf8(*m.inner_ref()),\n+        Right(ref m) => str::from_utf8_slice(*m.inner_ref()),\n         Left(_) => unreachable!()\n     };\n "}, {"sha": "0fbac7771dc2aed87aa26aed0d4b320eddc9a8e3", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -310,7 +310,7 @@ impl Uuid {\n             s[i*2+0] = digit[0];\n             s[i*2+1] = digit[1];\n         }\n-        str::from_utf8(s)\n+        str::from_utf8_owned(s)\n     }\n \n     /// Returns a string of hexadecimal digits, separated into groups with a hypen"}, {"sha": "d906896ff60b5ca50441f962bbb41db31298bcf7", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -260,7 +260,7 @@ fn json_encode<'self, T:Encodable<json::Encoder<'self>>>(t: &T) -> ~str {\n     let mut writer = MemWriter::new();\n     let mut encoder = json::Encoder::init(&mut writer as &mut io::Writer);\n     t.encode(&mut encoder);\n-    str::from_utf8(writer.inner_ref().as_slice())\n+    str::from_utf8_owned(writer.inner())\n }\n \n // FIXME(#5121)"}, {"sha": "2a84f01cbd6db4fdd2aa8d89f9163545b4c58a22", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -41,8 +41,8 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n     let o = Process::new(ar, args.as_slice(), opts).finish_with_output();\n     if !o.status.success() {\n         sess.err(format!(\"{} failed with: {}\", ar, o.status));\n-        sess.note(format!(\"stdout ---\\n{}\", str::from_utf8(o.output)));\n-        sess.note(format!(\"stderr ---\\n{}\", str::from_utf8(o.error)));\n+        sess.note(format!(\"stdout ---\\n{}\", str::from_utf8_slice(o.output)));\n+        sess.note(format!(\"stderr ---\\n{}\", str::from_utf8_slice(o.error)));\n         sess.abort_if_errors();\n     }\n     o"}, {"sha": "1c4b15f42e986180469ee7e68d8f2a34e5ed4cbe", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -368,7 +368,7 @@ pub mod write {\n         if !prog.status.success() {\n             sess.err(format!(\"linking with `{}` failed: {}\", cc, prog.status));\n             sess.note(format!(\"{} arguments: '{}'\", cc, args.connect(\"' '\")));\n-            sess.note(str::from_utf8(prog.error + prog.output));\n+            sess.note(str::from_utf8_owned(prog.error + prog.output));\n             sess.abort_if_errors();\n         }\n     }\n@@ -1079,7 +1079,7 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n     if !prog.status.success() {\n         sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n         sess.note(format!(\"{} arguments: '{}'\", cc_prog, cc_args.connect(\"' '\")));\n-        sess.note(str::from_utf8(prog.error + prog.output));\n+        sess.note(str::from_utf8_owned(prog.error + prog.output));\n         sess.abort_if_errors();\n     }\n "}, {"sha": "24cac4d9aeef0d2efda8be61bdff323ca0a8fe89", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -166,7 +166,7 @@ Available lint options:\n         max_key = num::max(name.len(), max_key);\n     }\n     fn padded(max: uint, s: &str) -> ~str {\n-        str::from_utf8(vec::from_elem(max - s.len(), ' ' as u8)) + s\n+        \" \".repeat(max - s.len()) + s\n     }\n     println(\"\\nAvailable lint checks:\\n\");\n     println!(\"    {}  {:7.7s}  {}\",\n@@ -246,7 +246,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n       1u => {\n         let ifile = matches.free[0].as_slice();\n         if \"-\" == ifile {\n-            let src = str::from_utf8(io::stdin().read_to_end());\n+            let src = str::from_utf8_owned(io::stdin().read_to_end());\n             str_input(src.to_managed())\n         } else {\n             file_input(Path::init(ifile))"}, {"sha": "7ccfe6b8d216c99a6a1a444a1aa703a04b4dd7cb", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -1274,8 +1274,8 @@ fn family_names_type(fam: Family) -> bool {\n fn read_path(d: ebml::Doc) -> (~str, uint) {\n     reader::with_doc_data(d, |desc| {\n         let pos = u64_from_be_bytes(desc, 0u, 4u) as uint;\n-        let pathbytes = desc.slice(4u, desc.len());\n-        let path = str::from_utf8(pathbytes);\n+        let pathbytes = desc.slice_from(4u).to_owned();\n+        let path = str::from_utf8_owned(pathbytes);\n \n         (path, pos)\n     })"}, {"sha": "152c64a4b6e2fa11eef5210457686ef71aba3f4f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -1902,5 +1902,5 @@ pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n         abbrevs: tyencode::ac_no_abbrevs};\n     let wr = @mut MemWriter::new();\n     tyencode::enc_ty(wr, cx, t);\n-    str::from_utf8(*wr.inner_ref())\n+    str::from_utf8_owned(wr.inner_ref().to_owned())\n }"}, {"sha": "74452a6217bf2b330b63e314522ef7831b817a98", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -97,8 +97,9 @@ pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n }\n \n fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n-    let rslt = scan(st, is_last, str::from_utf8);\n-    return st.tcx.sess.ident_of(rslt);\n+    scan(st, is_last, |bytes| {\n+            st.tcx.sess.ident_of(str::from_utf8_slice(bytes))\n+        })\n }\n \n pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: ast::CrateNum,\n@@ -492,10 +493,11 @@ fn parse_abi_set(st: &mut PState) -> AbiSet {\n     assert_eq!(next(st), '[');\n     let mut abis = AbiSet::empty();\n     while peek(st) != ']' {\n-        // FIXME(#5422) str API should not force this copy\n-        let abi_str = scan(st, |c| c == ',', str::from_utf8);\n-        let abi = abi::lookup(abi_str).expect(abi_str);\n-        abis.add(abi);\n+         scan(st, |c| c == ',', |bytes| {\n+                 let abi_str = str::from_utf8_slice(bytes).to_owned();\n+                 let abi = abi::lookup(abi_str).expect(abi_str);\n+                 abis.add(abi);\n+              });\n     }\n     assert_eq!(next(st), ']');\n     return abis;"}, {"sha": "1e8a6d85975d0ddc7a464fb6fb4de139bc8892eb", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -72,7 +72,7 @@ pub fn enc_ty(w: @mut MemWriter, cx: @ctxt, t: ty::t) {\n             None => {\n                 let wr = @mut MemWriter::new();\n                 enc_sty(wr, cx, &ty::get(t).sty);\n-                let s = str::from_utf8(*wr.inner_ref()).to_managed();\n+                let s = str::from_utf8_slice(*wr.inner_ref()).to_managed();\n                 cx.tcx.short_names_cache.insert(t, s);\n                 s\n           }"}, {"sha": "1932182560a520f12b32345915576290718f607e", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -154,7 +154,7 @@ fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &st\n     let rslt = prog.finish_with_output();\n     if !rslt.status.success() {\n         fail!(\"{} [git returned {:?}, output = {}, error = {}]\", err_msg,\n-           rslt.status, str::from_utf8(rslt.output), str::from_utf8(rslt.error));\n+           rslt.status, str::from_utf8_slice(rslt.output), str::from_utf8_slice(rslt.error));\n     }\n }\n \n@@ -290,13 +290,13 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n     });\n     let output = prog.finish_with_output();\n     debug!(\"Output from command {} with args {:?} was {} \\\\{{}\\\\}[{:?}]\",\n-                    cmd, args, str::from_utf8(output.output),\n-                   str::from_utf8(output.error),\n-                   output.status);\n+           cmd, args, str::from_utf8_slice(output.output),\n+           str::from_utf8_slice(output.error),\n+           output.status);\n     if !output.status.success() {\n         debug!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} ---\",\n               cmd, args, output.status,\n-              str::from_utf8(output.output) + str::from_utf8(output.error));\n+              str::from_utf8_slice(output.output) + str::from_utf8_slice(output.error));\n         Fail(output)\n     }\n     else {\n@@ -455,7 +455,7 @@ fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n fn command_line_test_output(args: &[~str]) -> ~[~str] {\n     let mut result = ~[];\n     let p_output = command_line_test(args, &os::getcwd());\n-    let test_output = str::from_utf8(p_output.output);\n+    let test_output = str::from_utf8_slice(p_output.output);\n     for s in test_output.split('\\n') {\n         result.push(s.to_owned());\n     }\n@@ -469,7 +469,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n         Fail(_) => fail!(\"Command-line test failed\"),\n         Success(r) => r\n     };\n-    let test_output = str::from_utf8(p_output.output);\n+    let test_output = str::from_utf8_slice(p_output.output);\n     for s in test_output.split('\\n') {\n         result.push(s.to_owned());\n     }\n@@ -1204,15 +1204,15 @@ fn test_info() {\n     let expected_info = ~\"package foo\"; // fill in\n     let workspace = create_local_package(&PkgId::new(\"foo\"));\n     let output = command_line_test([~\"info\", ~\"foo\"], workspace.path());\n-    assert_eq!(str::from_utf8(output.output), expected_info);\n+    assert_eq!(str::from_utf8_owned(output.output), expected_info);\n }\n \n #[test]\n fn test_uninstall() {\n     let workspace = create_local_package(&PkgId::new(\"foo\"));\n     command_line_test([~\"uninstall\", ~\"foo\"], workspace.path());\n     let output = command_line_test([~\"list\"], workspace.path());\n-    assert!(!str::from_utf8(output.output).contains(\"foo\"));\n+    assert!(!str::from_utf8_slice(output.output).contains(\"foo\"));\n }\n \n #[test]\n@@ -1282,8 +1282,8 @@ fn test_extern_mod() {\n     let outp = prog.finish_with_output();\n     if !outp.status.success() {\n         fail!(\"output was {}, error was {}\",\n-              str::from_utf8(outp.output),\n-              str::from_utf8(outp.error));\n+              str::from_utf8_slice(outp.output),\n+              str::from_utf8_slice(outp.error));\n     }\n     assert!(exec_file.exists() && is_executable(&exec_file));\n }\n@@ -1337,8 +1337,8 @@ fn test_extern_mod_simpler() {\n     let outp = prog.finish_with_output();\n     if !outp.status.success() {\n         fail!(\"output was {}, error was {}\",\n-              str::from_utf8(outp.output),\n-              str::from_utf8(outp.error));\n+              str::from_utf8_slice(outp.output),\n+              str::from_utf8_slice(outp.error));\n     }\n     assert!(exec_file.exists() && is_executable(&exec_file));\n }\n@@ -2101,7 +2101,7 @@ fn test_rustpkg_test_creates_exec() {\n fn test_rustpkg_test_output() {\n     let workspace = create_local_package_with_test(&PkgId::new(\"foo\"));\n     let output = command_line_test([~\"test\", ~\"foo\"], workspace.path());\n-    let output_str = str::from_utf8(output.output);\n+    let output_str = str::from_utf8_slice(output.output);\n     // The first two assertions are separate because test output may\n     // contain color codes, which could appear between \"test f\" and \"ok\".\n     assert!(output_str.contains(\"test f\"));\n@@ -2132,7 +2132,7 @@ fn test_rustpkg_test_cfg() {\n               \"#[test] #[cfg(not(foobar))] fn f() { assert!('a' != 'a'); }\");\n     let output = command_line_test([~\"test\", ~\"--cfg\", ~\"foobar\", ~\"foo\"],\n                                    foo_workspace);\n-    let output_str = str::from_utf8(output.output);\n+    let output_str = str::from_utf8_slice(output.output);\n     assert!(output_str.contains(\"0 passed; 0 failed; 0 ignored; 0 measured\"));\n }\n \n@@ -2430,8 +2430,8 @@ fn correct_error_dependency() {\n         Fail(ProcessOutput{ error: error, output: output, .. }) => {\n             assert!(str::is_utf8(error));\n             assert!(str::is_utf8(output));\n-            let error_str = str::from_utf8(error);\n-            let out_str   = str::from_utf8(output);\n+            let error_str = str::from_utf8_slice(error);\n+            let out_str   = str::from_utf8_slice(output);\n             debug!(\"ss = {}\", error_str);\n             debug!(\"out_str = {}\", out_str);\n             if out_str.contains(\"Package badpkg depends on some_package_that_doesnt_exist\") &&"}, {"sha": "f11f5962c39e872baf734aef845b9b0609d57615", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -113,19 +113,19 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n             continue;\n         }\n \n-    let mut output = None;\n-    let output_text = str::from_utf8(outp.output);\n-    for l in output_text.lines() {\n-        if !l.is_whitespace() {\n-            output = Some(l);\n-        }\n-        match output.and_then(try_parsing_version) {\n-            Some(v) => return Some(v),\n-            None    => ()\n+        let mut output = None;\n+        let output_text = str::from_utf8_slice(outp.output);\n+        for l in output_text.lines() {\n+            if !l.is_whitespace() {\n+                output = Some(l);\n+            }\n+            match output.and_then(try_parsing_version) {\n+                Some(v) => return Some(v),\n+                None    => ()\n+            }\n         }\n     }\n-  }\n-  None\n+    None\n }\n \n /// If `remote_path` refers to a git repo that can be downloaded,\n@@ -145,8 +145,8 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n                                                 tmp_dir.as_str().unwrap().to_owned()]);\n         if outp.status.success() {\n             debug!(\"Cloned it... ( {}, {} )\",\n-                   str::from_utf8(outp.output),\n-                   str::from_utf8(outp.error));\n+                   str::from_utf8_slice(outp.output),\n+                   str::from_utf8_slice(outp.error));\n             let mut output = None;\n             let git_dir = tmp_dir.join(\".git\");\n             debug!(\"(getting version, now getting tags) executing \\\\{git --git-dir={} tag -l\\\\}\",\n@@ -155,7 +155,7 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n             let outp = run::process_output(\"git\",\n                                            [\"--git-dir=\" + git_dir.as_str().unwrap(),\n                                             ~\"tag\", ~\"-l\"]);\n-            let output_text = str::from_utf8(outp.output);\n+            let output_text = str::from_utf8_slice(outp.output);\n             debug!(\"Full output: ( {} ) [{:?}]\", output_text, outp.status);\n             for l in output_text.lines() {\n                 debug!(\"A line of output: {}\", l);"}, {"sha": "d2ecb92fffe9795c4b81ffd937287db7a0a6604a", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -487,8 +487,8 @@ mod test {\n \n             let nread = result.unwrap();\n             assert!(nread > 0);\n-            let read_str = str::from_utf8(read_mem.slice(0, nread as uint));\n-            assert_eq!(read_str, ~\"hello\");\n+            let read_str = str::from_utf8_slice(read_mem.slice_to(nread as uint));\n+            assert_eq!(read_str, \"hello\");\n         }\n         // unlink\n         let result = FsRequest::unlink(l(), &path_str.to_c_str());"}, {"sha": "6548c0e65c9945ead54aab53274afe3f519d99e9", "filename": "src/libstd/io/flate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibstd%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibstd%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fflate.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -107,7 +107,7 @@ mod test {\n     fn smoke_test() {\n         let mem_writer = MemWriter::new();\n         let mut deflate_writer = DeflateWriter::new(mem_writer);\n-        let in_msg = \"test\";\n+        let in_msg: &str = \"test\";\n         let in_bytes = in_msg.as_bytes();\n         deflate_writer.write(in_bytes);\n         deflate_writer.flush();\n@@ -117,7 +117,7 @@ mod test {\n         let mut out_bytes = [0, .. 100];\n         let bytes_read = inflate_reader.read(out_bytes).unwrap();\n         assert_eq!(bytes_read, in_bytes.len());\n-        let out_msg = str::from_utf8(out_bytes);\n-        assert!(in_msg == out_msg);\n+        let out_msg = str::from_utf8_slice(out_bytes);\n+        assert_eq!(in_msg, out_msg);\n     }\n }"}, {"sha": "db8de9df24aafdadb06274346419fefb1f93d6e6", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -770,9 +770,9 @@ mod test {\n             let mut read_buf = [0, .. 1028];\n             let read_str = match read_stream.read(read_buf).unwrap() {\n                 -1|0 => fail!(\"shouldn't happen\"),\n-                n => str::from_utf8(read_buf.slice_to(n))\n+                n => str::from_utf8_owned(read_buf.slice_to(n).to_owned())\n             };\n-            assert!(read_str == message.to_owned());\n+            assert_eq!(read_str, message.to_owned());\n         }\n         unlink(filename);\n     })\n@@ -801,7 +801,7 @@ mod test {\n     })\n \n     test!(fn file_test_io_non_positional_read() {\n-        let message = \"ten-four\";\n+        let message: &str = \"ten-four\";\n         let mut read_mem = [0, .. 8];\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n@@ -821,8 +821,8 @@ mod test {\n             }\n         }\n         unlink(filename);\n-        let read_str = str::from_utf8(read_mem);\n-        assert!(read_str == message.to_owned());\n+        let read_str = str::from_utf8_slice(read_mem);\n+        assert_eq!(read_str, message);\n     })\n \n     test!(fn file_test_io_seek_and_tell_smoke_test() {\n@@ -845,10 +845,10 @@ mod test {\n             tell_pos_post_read = read_stream.tell();\n         }\n         unlink(filename);\n-        let read_str = str::from_utf8(read_mem);\n-        assert!(read_str == message.slice(4, 8).to_owned());\n-        assert!(tell_pos_pre_read == set_cursor);\n-        assert!(tell_pos_post_read == message.len() as u64);\n+        let read_str = str::from_utf8_slice(read_mem);\n+        assert_eq!(read_str, message.slice(4, 8));\n+        assert_eq!(tell_pos_pre_read, set_cursor);\n+        assert_eq!(tell_pos_post_read, message.len() as u64);\n     })\n \n     test!(fn file_test_io_seek_and_write() {\n@@ -870,16 +870,16 @@ mod test {\n             read_stream.read(read_mem);\n         }\n         unlink(filename);\n-        let read_str = str::from_utf8(read_mem);\n+        let read_str = str::from_utf8_slice(read_mem);\n         assert!(read_str == final_msg.to_owned());\n     })\n \n     test!(fn file_test_io_seek_shakedown() {\n         use std::str;          // 01234567890123\n         let initial_msg =   \"qwer-asdf-zxcv\";\n-        let chunk_one = \"qwer\";\n-        let chunk_two = \"asdf\";\n-        let chunk_three = \"zxcv\";\n+        let chunk_one: &str = \"qwer\";\n+        let chunk_two: &str = \"asdf\";\n+        let chunk_three: &str = \"zxcv\";\n         let mut read_mem = [0, .. 4];\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n@@ -892,18 +892,15 @@ mod test {\n \n             read_stream.seek(-4, SeekEnd);\n             read_stream.read(read_mem);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == chunk_three.to_owned());\n+            assert_eq!(str::from_utf8_slice(read_mem), chunk_three);\n \n             read_stream.seek(-9, SeekCur);\n             read_stream.read(read_mem);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == chunk_two.to_owned());\n+            assert_eq!(str::from_utf8_slice(read_mem), chunk_two);\n \n             read_stream.seek(0, SeekSet);\n             read_stream.read(read_mem);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == chunk_one.to_owned());\n+            assert_eq!(str::from_utf8_slice(read_mem), chunk_one);\n         }\n         unlink(filename);\n     })\n@@ -977,12 +974,12 @@ mod test {\n             {\n                 let n = f.filestem_str();\n                 File::open(f).read(mem);\n-                let read_str = str::from_utf8(mem);\n+                let read_str = str::from_utf8_slice(mem);\n                 let expected = match n {\n                     None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n                     Some(n) => prefix+n\n                 };\n-                assert!(expected == read_str);\n+                assert_eq!(expected.as_slice(), read_str);\n             }\n             unlink(f);\n         }"}, {"sha": "8e678ab66b25e73871be80789f673f0196969d9c", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -426,7 +426,7 @@ pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+Round+\n         sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n     let (bytes, special) = float_to_str_bytes_common(num, radix,\n                                negative_zero, sign, digits);\n-    (str::from_utf8(bytes), special)\n+    (str::from_utf8_owned(bytes), special)\n }\n \n // Some constants for from_str_bytes_common's input validation,"}, {"sha": "6cc5e5cc9f26b09bd81d58e2c4a54273b03a1b02", "filename": "src/libstd/run.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -347,7 +347,7 @@ mod tests {\n \n         let run::ProcessOutput {status, output, error}\n              = run::process_output(\"echo\", [~\"hello\"]);\n-        let output_str = str::from_utf8(output);\n+        let output_str = str::from_utf8_owned(output);\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n@@ -439,7 +439,7 @@ mod tests {\n         let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new());\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n-        let output_str = str::from_utf8(output);\n+        let output_str = str::from_utf8_owned(output);\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n@@ -457,7 +457,7 @@ mod tests {\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n \n-        let output_str = str::from_utf8(output);\n+        let output_str = str::from_utf8_owned(output);\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n@@ -504,7 +504,7 @@ mod tests {\n     fn test_keep_current_working_dir() {\n         let mut prog = run_pwd(None);\n \n-        let output = str::from_utf8(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output);\n         let parent_dir = os::getcwd();\n         let child_dir = Path::init(output.trim());\n \n@@ -522,7 +522,7 @@ mod tests {\n         let parent_dir = os::getcwd().dir_path();\n         let mut prog = run_pwd(Some(&parent_dir));\n \n-        let output = str::from_utf8(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output);\n         let child_dir = Path::init(output.trim());\n \n         let parent_stat = parent_dir.stat();\n@@ -561,7 +561,7 @@ mod tests {\n         if running_on_valgrind() { return; }\n \n         let mut prog = run_env(None);\n-        let output = str::from_utf8(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output);\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -575,7 +575,7 @@ mod tests {\n         if running_on_valgrind() { return; }\n \n         let mut prog = run_env(None);\n-        let output = str::from_utf8(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output);\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -594,7 +594,7 @@ mod tests {\n         new_env.push((~\"RUN_TEST_NEW_ENV\", ~\"123\"));\n \n         let mut prog = run_env(Some(new_env));\n-        let output = str::from_utf8(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output);\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"));\n     }"}, {"sha": "2076d433fb6347d30b2fea88201cc04917220859", "filename": "src/libstd/str.rs", "status": "modified", "additions": 7, "deletions": 107, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -124,34 +124,6 @@ condition! {\n Section: Creating a string\n */\n \n-/// Convert a vector of bytes to a new UTF-8 string\n-///\n-/// # Failure\n-///\n-/// Raises the `not_utf8` condition if invalid UTF-8\n-pub fn from_utf8(vv: &[u8]) -> ~str {\n-    use str::not_utf8::cond;\n-\n-    match from_utf8_opt(vv) {\n-        None => {\n-            let first_bad_byte = *vv.iter().find(|&b| !is_utf8([*b])).unwrap();\n-            cond.raise(format!(\"from_utf8: input is not UTF-8; first bad \\\n-                                byte is {}\", first_bad_byte))\n-        }\n-        Some(s) => s\n-    }\n-}\n-\n-/// Convert a vector of bytes to a new UTF-8 string, if possible.\n-/// Returns None if the vector contains invalid UTF-8.\n-pub fn from_utf8_opt(vv: &[u8]) -> Option<~str> {\n-    if is_utf8(vv) {\n-        Some(unsafe { raw::from_utf8(vv) })\n-    } else {\n-        None\n-    }\n-}\n-\n /// Consumes a vector of bytes to create a new utf-8 string\n ///\n /// # Failure\n@@ -196,7 +168,7 @@ pub fn from_utf8_slice<'a>(v: &'a [u8]) -> &'a str {\n /// Returns None if the slice is not utf-8.\n pub fn from_utf8_slice_opt<'a>(v: &'a [u8]) -> Option<&'a str> {\n     if is_utf8(v) {\n-        Some(unsafe { cast::transmute(v) })\n+        Some(unsafe { raw::from_utf8_slice(v) })\n     } else { None }\n }\n \n@@ -1055,9 +1027,10 @@ pub mod raw {\n         from_buf_len(buf as *u8, i as uint)\n     }\n \n-    /// Converts a vector of bytes to a new owned string.\n-    pub unsafe fn from_utf8(v: &[u8]) -> ~str {\n-        v.as_imm_buf(|buf, len| from_buf_len(buf, len))\n+    /// Converts a slice of bytes to a string slice without checking\n+    /// that the string contains valid UTF-8.\n+    pub unsafe fn from_utf8_slice<'a>(v: &'a [u8]) -> &'a str {\n+        cast::transmute(v)\n     }\n \n     /// Converts an owned vector of bytes to a new owned string. This assumes\n@@ -1068,7 +1041,7 @@ pub mod raw {\n     }\n \n     /// Converts a byte to a string.\n-    pub unsafe fn from_byte(u: u8) -> ~str { from_utf8([u]) }\n+    pub unsafe fn from_byte(u: u8) -> ~str { from_utf8_owned(~[u]) }\n \n     /// Form a slice from a C string. Unsafe because the caller must ensure the\n     /// C string has the static lifetime, or else the return value may be\n@@ -3077,33 +3050,6 @@ mod tests {\n         assert_eq!(b, 67u8);\n     }\n \n-    #[test]\n-    fn test_unsafe_from_utf8() {\n-        let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n-        let b = unsafe { raw::from_utf8(a) };\n-        assert_eq!(b, ~\"AAAAAAA\");\n-    }\n-\n-    #[test]\n-    fn test_from_utf8() {\n-        let ss = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let bb = ~[0xe0_u8, 0xb8_u8, 0xa8_u8,\n-                  0xe0_u8, 0xb9_u8, 0x84_u8,\n-                  0xe0_u8, 0xb8_u8, 0x97_u8,\n-                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n-                  0xe4_u8, 0xb8_u8, 0xad_u8,\n-                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n-                  0x56_u8, 0x69_u8, 0xe1_u8,\n-                  0xbb_u8, 0x87_u8, 0x74_u8,\n-                  0x20_u8, 0x4e_u8, 0x61_u8,\n-                  0x6d_u8];\n-\n-\n-        assert_eq!(ss, from_utf8(bb));\n-        assert_eq!(~\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\",\n-                   from_utf8(bytes!(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\")));\n-    }\n-\n     #[test]\n     fn test_is_utf8() {\n         // deny overlong encodings\n@@ -3129,31 +3075,6 @@ mod tests {\n         assert!(is_utf8([0xF4, 0x8F, 0xBF, 0xBF]));\n     }\n \n-\n-    #[test]\n-    fn test_from_utf8_fail() {\n-        use str::not_utf8::cond;\n-\n-        let bb = ~[0xff_u8, 0xb8_u8, 0xa8_u8,\n-                  0xe0_u8, 0xb9_u8, 0x84_u8,\n-                  0xe0_u8, 0xb8_u8, 0x97_u8,\n-                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n-                  0xe4_u8, 0xb8_u8, 0xad_u8,\n-                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n-                  0x56_u8, 0x69_u8, 0xe1_u8,\n-                  0xbb_u8, 0x87_u8, 0x74_u8,\n-                  0x20_u8, 0x4e_u8, 0x61_u8,\n-                  0x6d_u8];\n-\n-        let mut error_happened = false;\n-        let _x = cond.trap(|err| {\n-            assert_eq!(err, ~\"from_utf8: input is not UTF-8; first bad byte is 255\");\n-            error_happened = true;\n-            ~\"\"\n-        }).inside(|| from_utf8(bb));\n-        assert!(error_happened);\n-    }\n-\n     #[test]\n     fn test_raw_from_c_str() {\n         unsafe {\n@@ -3232,7 +3153,7 @@ mod tests {\n         let s1: ~str = ~\"All mimsy were the borogoves\";\n \n         let v: ~[u8] = s1.as_bytes().to_owned();\n-        let s2: ~str = from_utf8(v);\n+        let s2: ~str = from_utf8_slice(v).to_owned();\n         let mut i: uint = 0u;\n         let n1: uint = s1.len();\n         let n2: uint = v.len();\n@@ -3782,27 +3703,6 @@ mod tests {\n         assert_eq!(from_utf8_slice_opt(xs), None);\n     }\n \n-    #[test]\n-    fn test_str_from_utf8() {\n-        let xs = bytes!(\"hello\");\n-        assert_eq!(from_utf8(xs), ~\"hello\");\n-\n-        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(from_utf8(xs), ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-    }\n-\n-    #[test]\n-    fn test_str_from_utf8_opt() {\n-        let xs = bytes!(\"hello\").to_owned();\n-        assert_eq!(from_utf8_opt(xs), Some(~\"hello\"));\n-\n-        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(from_utf8_opt(xs), Some(~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n-\n-        let xs = bytes!(\"hello\", 0xff);\n-        assert_eq!(from_utf8_opt(xs), None);\n-    }\n-\n     #[test]\n     fn test_str_from_utf8_owned() {\n         let xs = bytes!(\"hello\").to_owned();"}, {"sha": "0704bf913d7c419d1f1f35d735b653f26ac0f6dd", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -346,7 +346,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                                     path: @str,\n                                     srdr: &mut io::Reader)\n                                  -> (~[cmnt], ~[lit]) {\n-    let src = str::from_utf8(srdr.read_to_end()).to_managed();\n+    let src = str::from_utf8_owned(srdr.read_to_end()).to_managed();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);"}, {"sha": "3c6fa86485d21e6fd2424160b1e675f5d11675fc", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -210,7 +210,7 @@ pub fn fun_to_str(decl: &ast::fn_decl, purity: ast::purity, name: ast::Ident,\n     end(s); // Close the head box\n     end(s); // Close the outer box\n     eof(s.s);\n-    str::from_utf8(*wr.inner_ref())\n+    str::from_utf8_owned(wr.inner_ref().to_owned())\n }\n \n pub fn block_to_str(blk: &ast::Block, intr: @ident_interner) -> ~str {\n@@ -222,7 +222,7 @@ pub fn block_to_str(blk: &ast::Block, intr: @ident_interner) -> ~str {\n     ibox(s, 0u);\n     print_block(s, blk);\n     eof(s.s);\n-    str::from_utf8(*wr.inner_ref())\n+    str::from_utf8_owned(wr.inner_ref().to_owned())\n }\n \n pub fn meta_item_to_str(mi: &ast::MetaItem, intr: @ident_interner) -> ~str {\n@@ -2292,7 +2292,7 @@ pub fn to_str<T>(t: &T, f: |@ps, &T|, intr: @ident_interner) -> ~str {\n     let s = rust_printer(wr as @mut io::Writer, intr);\n     f(s, t);\n     eof(s.s);\n-    str::from_utf8(*wr.inner_ref())\n+    str::from_utf8_owned(wr.inner_ref().to_owned())\n }\n \n pub fn next_comment(s: @ps) -> Option<comments::cmnt> {"}, {"sha": "76d2ca1f30bfc0078b87fbcaf2d1e2ca1a8fcbf9", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -70,12 +70,10 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n \n    let mut buffer = ~\"\";\n \n-   for kv in pairs_sorted.iter() {\n-       let (k,v) = (*kv).clone();\n+   for &(ref k, v) in pairs_sorted.iter() {\n        unsafe {\n-           let b = str::raw::from_utf8(k);\n            buffer.push_str(format!(\"{} {:0.3f}\\n\",\n-                                   b.into_ascii().to_upper().into_str(), v));\n+                                   k.to_ascii().to_upper().into_str(), v));\n        }\n    }\n "}, {"sha": "84b2d33c501dca38f80dc86e8054c8cafa326fd7", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -60,7 +60,7 @@ impl Code {\n         }\n \n         reverse(result);\n-        str::from_utf8(result)\n+        str::from_utf8_owned(result)\n     }\n }\n "}, {"sha": "f4c6e4e689a997f7a39fbe0d9c550caf9fbc2c1c", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -17,13 +17,13 @@ static C: *u8 = B as *u8;\n pub fn main() {\n     unsafe {\n         let foo = &A as *u8;\n-        assert_eq!(str::raw::from_utf8(A), ~\"hi\");\n+        assert_eq!(str::raw::from_utf8_slice(A), \"hi\");\n         assert_eq!(str::raw::from_buf_len(foo, A.len()), ~\"hi\");\n         assert_eq!(str::raw::from_buf_len(C, B.len()), ~\"hi\");\n         assert!(*C == A[0]);\n         assert!(*(&B[0] as *u8) == A[0]);\n \n-        let bar = str::raw::from_utf8(A).to_c_str();\n+        let bar = str::raw::from_utf8_slice(A).to_c_str();\n         assert_eq!(bar.with_ref(|buf| str::raw::from_c_str(buf)), ~\"hi\");\n     }\n }"}, {"sha": "05f74ca8373ee5e02935ac0ae83721213bb31629", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -59,13 +59,13 @@ fn test_destroy_actually_kills(force: bool) {\n     #[cfg(unix,not(target_os=\"android\"))]\n     fn process_exists(pid: libc::pid_t) -> bool {\n         let run::ProcessOutput {output, ..} = run::process_output(\"ps\", [~\"-p\", pid.to_str()]);\n-        str::from_utf8(output).contains(pid.to_str())\n+        str::from_utf8_owned(output).contains(pid.to_str())\n     }\n \n     #[cfg(unix,target_os=\"android\")]\n     fn process_exists(pid: libc::pid_t) -> bool {\n         let run::ProcessOutput {output, ..} = run::process_output(\"/system/bin/ps\", [pid.to_str()]);\n-        str::from_utf8(output).contains(~\"root\")\n+        str::from_utf8_owned(output).contains(~\"root\")\n     }\n \n     #[cfg(windows)]"}, {"sha": "3d02d2c2c5bef34222bd2b2a3e9369375ef974b1", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -79,11 +79,10 @@ mod map_reduce {\n             match ctrl_port.recv() {\n               mapper_done => { num_mappers -= 1; }\n               find_reducer(k, cc) => {\n-                let mut c;\n-                match reducers.find(&str::from_utf8(k)) {\n-                  Some(&_c) => { c = _c; }\n-                  None => { c = 0; }\n-                }\n+                let c = match reducers.find(&str::from_utf8_owned(k)) {\n+                  Some(&_c) => _c,\n+                  None => 0\n+                };\n                 cc.send(c);\n               }\n             }"}, {"sha": "b9287494bae2ac198830170584229f8657462201", "filename": "src/test/run-pass/rtio-processes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d64e46013096997627da62ecc65225bc22682e8/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d64e46013096997627da62ecc65225bc22682e8/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frtio-processes.rs?ref=9d64e46013096997627da62ecc65225bc22682e8", "patch": "@@ -108,7 +108,7 @@ fn read_all(input: &mut Reader) -> ~str {\n     loop {\n         match input.read(buf) {\n             None => { break }\n-            Some(n) => { ret = ret + str::from_utf8(buf.slice_to(n)); }\n+            Some(n) => { ret.push_str(str::from_utf8_slice(buf.slice_to(n))); }\n         }\n     }\n     return ret;"}]}