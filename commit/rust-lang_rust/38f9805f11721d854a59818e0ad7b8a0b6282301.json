{"sha": "38f9805f11721d854a59818e0ad7b8a0b6282301", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4Zjk4MDVmMTE3MjFkODU0YTU5ODE4ZTBhZDdiOGEwYjYyODIzMDE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-31T00:26:22Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-31T00:26:22Z"}, "message": "rollup merge of #20348: frewsxcv/rm-reexports\n\nPart of #19253\n\n[breaking-change]", "tree": {"sha": "19d00fb3429aa12a04de119e93fef0f3c7258eb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19d00fb3429aa12a04de119e93fef0f3c7258eb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38f9805f11721d854a59818e0ad7b8a0b6282301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38f9805f11721d854a59818e0ad7b8a0b6282301", "html_url": "https://github.com/rust-lang/rust/commit/38f9805f11721d854a59818e0ad7b8a0b6282301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38f9805f11721d854a59818e0ad7b8a0b6282301/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04f42212a3940f7abaa7765a43e247584b09a29b", "url": "https://api.github.com/repos/rust-lang/rust/commits/04f42212a3940f7abaa7765a43e247584b09a29b", "html_url": "https://github.com/rust-lang/rust/commit/04f42212a3940f7abaa7765a43e247584b09a29b"}, {"sha": "1d26fb9e07e664b312ca9d7b666f6d1dd52285ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d26fb9e07e664b312ca9d7b666f6d1dd52285ed", "html_url": "https://github.com/rust-lang/rust/commit/1d26fb9e07e664b312ca9d7b666f6d1dd52285ed"}], "stats": {"total": 43, "additions": 22, "deletions": 21}, "files": [{"sha": "04128f837ec12e310630a8998b65017e751deba8", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/38f9805f11721d854a59818e0ad7b8a0b6282301/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f9805f11721d854a59818e0ad7b8a0b6282301/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=38f9805f11721d854a59818e0ad7b8a0b6282301", "patch": "@@ -68,6 +68,7 @@\n //! ```\n \n use core::atomic;\n+use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n use core::borrow::BorrowFrom;\n use core::clone::Clone;\n use core::fmt::{mod, Show};\n@@ -182,7 +183,7 @@ impl<T> Arc<T> {\n     #[experimental = \"Weak pointers may not belong in this module.\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         // See the clone() impl for why this is relaxed\n-        self.inner().weak.fetch_add(1, atomic::Relaxed);\n+        self.inner().weak.fetch_add(1, Relaxed);\n         Weak { _ptr: self._ptr }\n     }\n }\n@@ -201,12 +202,12 @@ impl<T> Arc<T> {\n /// Get the number of weak references to this value.\n #[inline]\n #[experimental]\n-pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(atomic::SeqCst) - 1 }\n+pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(SeqCst) - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n #[experimental]\n-pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(atomic::SeqCst) }\n+pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(SeqCst) }\n \n #[stable]\n impl<T> Clone for Arc<T> {\n@@ -234,7 +235,7 @@ impl<T> Clone for Arc<T> {\n         // must already provide any required synchronization.\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-        self.inner().strong.fetch_add(1, atomic::Relaxed);\n+        self.inner().strong.fetch_add(1, Relaxed);\n         Arc { _ptr: self._ptr }\n     }\n }\n@@ -273,8 +274,8 @@ impl<T: Send + Sync + Clone> Arc<T> {\n     pub fn make_unique(&mut self) -> &mut T {\n         // Note that we hold a strong reference, which also counts as a weak reference, so we only\n         // clone if there is an additional reference of either kind.\n-        if self.inner().strong.load(atomic::SeqCst) != 1 ||\n-           self.inner().weak.load(atomic::SeqCst) != 1 {\n+        if self.inner().strong.load(SeqCst) != 1 ||\n+           self.inner().weak.load(SeqCst) != 1 {\n             *self = Arc::new((**self).clone())\n         }\n         // This unsafety is ok because we're guaranteed that the pointer returned is the *only*\n@@ -322,7 +323,7 @@ impl<T: Sync + Send> Drop for Arc<T> {\n         // Because `fetch_sub` is already atomic, we do not need to synchronize with other threads\n         // unless we are going to delete the object. This same logic applies to the below\n         // `fetch_sub` to the `weak` count.\n-        if self.inner().strong.fetch_sub(1, atomic::Release) != 1 { return }\n+        if self.inner().strong.fetch_sub(1, Release) != 1 { return }\n \n         // This fence is needed to prevent reordering of use of the data and deletion of the data.\n         // Because it is marked `Release`, the decreasing of the reference count synchronizes with\n@@ -339,14 +340,14 @@ impl<T: Sync + Send> Drop for Arc<T> {\n         // > operation before deleting the object.\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-        atomic::fence(atomic::Acquire);\n+        atomic::fence(Acquire);\n \n         // Destroy the data at this time, even though we may not free the box allocation itself\n         // (there may still be weak pointers lying around).\n         unsafe { drop(ptr::read(&self.inner().data)); }\n \n-        if self.inner().weak.fetch_sub(1, atomic::Release) == 1 {\n-            atomic::fence(atomic::Acquire);\n+        if self.inner().weak.fetch_sub(1, Release) == 1 {\n+            atomic::fence(Acquire);\n             unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n                                 min_align_of::<ArcInner<T>>()) }\n         }\n@@ -377,9 +378,9 @@ impl<T: Sync + Send> Weak<T> {\n         // count hits 0 is must never be above 0.\n         let inner = self.inner();\n         loop {\n-            let n = inner.strong.load(atomic::SeqCst);\n+            let n = inner.strong.load(SeqCst);\n             if n == 0 { return None }\n-            let old = inner.strong.compare_and_swap(n, n + 1, atomic::SeqCst);\n+            let old = inner.strong.compare_and_swap(n, n + 1, SeqCst);\n             if old == n { return Some(Arc { _ptr: self._ptr }) }\n         }\n     }\n@@ -409,7 +410,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n         // See comments in Arc::clone() for why this is relaxed\n-        self.inner().weak.fetch_add(1, atomic::Relaxed);\n+        self.inner().weak.fetch_add(1, Relaxed);\n         Weak { _ptr: self._ptr }\n     }\n }\n@@ -450,8 +451,8 @@ impl<T: Sync + Send> Drop for Weak<T> {\n \n         // If we find out that we were the last weak pointer, then its time to deallocate the data\n         // entirely. See the discussion in Arc::drop() about the memory orderings\n-        if self.inner().weak.fetch_sub(1, atomic::Release) == 1 {\n-            atomic::fence(atomic::Acquire);\n+        if self.inner().weak.fetch_sub(1, Release) == 1 {\n+            atomic::fence(Acquire);\n             unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n                                 min_align_of::<ArcInner<T>>()) }\n         }\n@@ -613,7 +614,7 @@ mod tests {\n             unsafe {\n                 match *self {\n                     Canary(c) => {\n-                        (*c).fetch_add(1, atomic::SeqCst);\n+                        (*c).fetch_add(1, SeqCst);\n                     }\n                 }\n             }\n@@ -732,17 +733,17 @@ mod tests {\n         let mut canary = atomic::AtomicUint::new(0);\n         let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUint));\n         drop(x);\n-        assert!(canary.load(atomic::Acquire) == 1);\n+        assert!(canary.load(Acquire) == 1);\n     }\n \n     #[test]\n     fn drop_arc_weak() {\n         let mut canary = atomic::AtomicUint::new(0);\n         let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUint));\n         let arc_weak = arc.downgrade();\n-        assert!(canary.load(atomic::Acquire) == 0);\n+        assert!(canary.load(Acquire) == 0);\n         drop(arc);\n-        assert!(canary.load(atomic::Acquire) == 1);\n+        assert!(canary.load(Acquire) == 1);\n         drop(arc_weak);\n     }\n "}, {"sha": "6a40915f4dd829970102bf1a557827c5a9ff0957", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38f9805f11721d854a59818e0ad7b8a0b6282301/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f9805f11721d854a59818e0ad7b8a0b6282301/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=38f9805f11721d854a59818e0ad7b8a0b6282301", "patch": "@@ -12,7 +12,7 @@\n \n #![stable]\n \n-pub use self::Ordering::*;\n+use self::Ordering::*;\n \n use kinds::Sync;\n "}, {"sha": "18c917aca8a4aba2102adb4f7785fadee4f3786d", "filename": "src/libstd/sync/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38f9805f11721d854a59818e0ad7b8a0b6282301/src%2Flibstd%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f9805f11721d854a59818e0ad7b8a0b6282301/src%2Flibstd%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomic.rs?ref=38f9805f11721d854a59818e0ad7b8a0b6282301", "patch": "@@ -101,9 +101,9 @@ use core::mem;\n use core::prelude::{Send, Drop, None, Option, Some};\n \n pub use core::atomic::{AtomicBool, AtomicInt, AtomicUint, AtomicPtr};\n-pub use core::atomic::{Ordering, Relaxed, Release, Acquire, AcqRel, SeqCst};\n pub use core::atomic::{INIT_ATOMIC_BOOL, INIT_ATOMIC_INT, INIT_ATOMIC_UINT};\n pub use core::atomic::fence;\n+pub use core::atomic::Ordering::{mod, Relaxed, Release, Acquire, AcqRel, SeqCst};\n \n /// An atomic, nullable unique pointer\n ///"}]}