{"sha": "5615aceff0f44f7ac6ec0c51800b162804e22453", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MTVhY2VmZjBmNDRmN2FjNmVjMGM1MTgwMGIxNjI4MDRlMjI0NTM=", "commit": {"author": {"name": "Samuel Neves", "email": "sneves@dei.uc.pt", "date": "2014-09-19T05:33:52Z"}, "committer": {"name": "Samuel Neves", "email": "sneves@dei.uc.pt", "date": "2014-09-30T02:36:52Z"}, "message": "Include ChaCha pseudorandom generator", "tree": {"sha": "45964f93a4c8fdbb252ace26ce413b6848ce5752", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45964f93a4c8fdbb252ace26ce413b6848ce5752"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5615aceff0f44f7ac6ec0c51800b162804e22453", "comment_count": 8, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5615aceff0f44f7ac6ec0c51800b162804e22453", "html_url": "https://github.com/rust-lang/rust/commit/5615aceff0f44f7ac6ec0c51800b162804e22453", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5615aceff0f44f7ac6ec0c51800b162804e22453/comments", "author": {"login": "sneves", "id": 1407263, "node_id": "MDQ6VXNlcjE0MDcyNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1407263?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sneves", "html_url": "https://github.com/sneves", "followers_url": "https://api.github.com/users/sneves/followers", "following_url": "https://api.github.com/users/sneves/following{/other_user}", "gists_url": "https://api.github.com/users/sneves/gists{/gist_id}", "starred_url": "https://api.github.com/users/sneves/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sneves/subscriptions", "organizations_url": "https://api.github.com/users/sneves/orgs", "repos_url": "https://api.github.com/users/sneves/repos", "events_url": "https://api.github.com/users/sneves/events{/privacy}", "received_events_url": "https://api.github.com/users/sneves/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sneves", "id": 1407263, "node_id": "MDQ6VXNlcjE0MDcyNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1407263?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sneves", "html_url": "https://github.com/sneves", "followers_url": "https://api.github.com/users/sneves/followers", "following_url": "https://api.github.com/users/sneves/following{/other_user}", "gists_url": "https://api.github.com/users/sneves/gists{/gist_id}", "starred_url": "https://api.github.com/users/sneves/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sneves/subscriptions", "organizations_url": "https://api.github.com/users/sneves/orgs", "repos_url": "https://api.github.com/users/sneves/repos", "events_url": "https://api.github.com/users/sneves/events{/privacy}", "received_events_url": "https://api.github.com/users/sneves/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "482e7788c7721a637781d20830366947fcacb0f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/482e7788c7721a637781d20830366947fcacb0f4", "html_url": "https://github.com/rust-lang/rust/commit/482e7788c7721a637781d20830366947fcacb0f4"}], "stats": {"total": 289, "additions": 288, "deletions": 1}, "files": [{"sha": "df33e6e2ced0cbcc0036e14719aa931095110528", "filename": "src/librand/chacha.rs", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/5615aceff0f44f7ac6ec0c51800b162804e22453/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5615aceff0f44f7ac6ec0c51800b162804e22453/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=5615aceff0f44f7ac6ec0c51800b162804e22453", "patch": "@@ -0,0 +1,285 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The ChaCha random number generator.\n+\n+use core::prelude::*;\n+\n+use {Rng, SeedableRng, Rand};\n+\n+static KEY_WORDS    : uint =  8; // 8 words for the 256-bit key\n+static STATE_WORDS  : uint = 16;\n+static CHACHA_ROUNDS: uint = 20; // Cryptographically secure from 8 upwards as of this writing\n+\n+/// A random number generator that uses the ChaCha20 algorithm [1].\n+///\n+/// The ChaCha algorithm is widely accepted as suitable for\n+/// cryptographic purposes, but this implementation has not been\n+/// verified as such. Prefer a generator like `OsRng` that defers to\n+/// the operating system for cases that need high security.\n+///\n+/// [1]: D. J. Bernstein, [*ChaCha, a variant of\n+/// Salsa20*](http://cr.yp.to/chacha.html)\n+\n+pub struct ChaChaRng {\n+    buffer:  [u32, ..STATE_WORDS], // Internal buffer of output\n+    state:   [u32, ..STATE_WORDS], // Initial state\n+    index:   uint,                 // Index into state\n+}\n+\n+static EMPTY: ChaChaRng = ChaChaRng {\n+    buffer:  [0, ..STATE_WORDS],\n+    state:   [0, ..STATE_WORDS],\n+    index:   STATE_WORDS\n+};\n+\n+\n+macro_rules! quarter_round{\n+    ($a: expr, $b: expr, $c: expr, $d: expr) => {{\n+        $a += $b; $d ^= $a; $d = $d.rotate_left(16);\n+        $c += $d; $b ^= $c; $b = $b.rotate_left(12);\n+        $a += $b; $d ^= $a; $d = $d.rotate_left( 8);\n+        $c += $d; $b ^= $c; $b = $b.rotate_left( 7);\n+    }}\n+}\n+\n+macro_rules! double_round{\n+    ($x: expr) => {{\n+        // Column round\n+        quarter_round!($x[ 0], $x[ 4], $x[ 8], $x[12]);\n+        quarter_round!($x[ 1], $x[ 5], $x[ 9], $x[13]);\n+        quarter_round!($x[ 2], $x[ 6], $x[10], $x[14]);\n+        quarter_round!($x[ 3], $x[ 7], $x[11], $x[15]);\n+        // Diagonal round\n+        quarter_round!($x[ 0], $x[ 5], $x[10], $x[15]);\n+        quarter_round!($x[ 1], $x[ 6], $x[11], $x[12]);\n+        quarter_round!($x[ 2], $x[ 7], $x[ 8], $x[13]);\n+        quarter_round!($x[ 3], $x[ 4], $x[ 9], $x[14]);\n+    }}\n+}\n+\n+#[inline]\n+fn core(output: &mut [u32, ..STATE_WORDS], input: &[u32, ..STATE_WORDS]) {\n+    *output = *input;\n+\n+    for _ in range(0, CHACHA_ROUNDS / 2) {\n+        double_round!(output);\n+    }\n+\n+    for i in range(0, STATE_WORDS) {\n+        output[i] += input[i];\n+    }\n+}\n+\n+impl ChaChaRng {\n+\n+    /// Create an ChaCha random number generator using the default\n+    /// fixed key of 8 zero words.\n+    pub fn new_unseeded() -> ChaChaRng {\n+        let mut rng = EMPTY;\n+        rng.init(&[0, ..KEY_WORDS]);\n+        rng\n+    }\n+\n+    /// Sets the internal 128-bit ChaCha counter to\n+    /// a user-provided value. This permits jumping\n+    /// arbitrarily ahead (or backwards) in the pseudorandom stream.\n+    ///\n+    /// Since the nonce words are used to extend the counter to 128 bits,\n+    /// users wishing to obtain the conventional ChaCha pseudorandom stream\n+    /// associated with a particular nonce can call this function with\n+    /// arguments `0, desired_nonce`.\n+    pub fn set_counter(&mut self, counter_low: u64, counter_high: u64) {\n+        self.state[12] = (counter_low >>  0) as u32;\n+        self.state[13] = (counter_low >> 32) as u32;\n+        self.state[14] = (counter_high >>  0) as u32;\n+        self.state[15] = (counter_high >> 32) as u32;\n+        self.index = STATE_WORDS; // force recomputation\n+    }\n+\n+    /// Initializes `self.state` with the appropriate key and constants\n+    ///\n+    /// We deviate slightly from the ChaCha specification regarding\n+    /// the nonce, which is used to extend the counter to 128 bits.\n+    /// This is provably as strong as the original cipher, though,\n+    /// since any distinguishing attack on our variant also works\n+    /// against ChaCha with a chosen-nonce. See the XSalsa20 [1]\n+    /// security proof for a more involved example of this.\n+    ///\n+    /// The modified word layout is:\n+    /// ```notrust\n+    /// constant constant constant constant\n+    /// key      key      key      key\n+    /// key      key      key      key\n+    /// counter  counter  counter  counter\n+    /// ```\n+    /// [1]: Daniel J. Bernstein. [*Extending the Salsa20\n+    /// nonce.*](http://cr.yp.to/papers.html#xsalsa)\n+    fn init(&mut self, key: &[u32, ..KEY_WORDS]) {\n+        self.state[0] = 0x61707865;\n+        self.state[1] = 0x3320646E;\n+        self.state[2] = 0x79622D32;\n+        self.state[3] = 0x6B206574;\n+\n+        for i in range(0, KEY_WORDS) {\n+            self.state[4+i] = key[i];\n+        }\n+\n+        self.state[12] = 0;\n+        self.state[13] = 0;\n+        self.state[14] = 0;\n+        self.state[15] = 0;\n+\n+        self.index = STATE_WORDS;\n+    }\n+\n+    /// Refill the internal output buffer (`self.buffer`)\n+    fn update(&mut self) {\n+        core(&mut self.buffer, &self.state);\n+        self.index = 0;\n+        // update 128-bit counter\n+        self.state[12] += 1;\n+        if self.state[12] != 0 { return };\n+        self.state[13] += 1;\n+        if self.state[13] != 0 { return };\n+        self.state[14] += 1;\n+        if self.state[14] != 0 { return };\n+        self.state[15] += 1;\n+    }\n+}\n+\n+impl Rng for ChaChaRng {\n+    #[inline]\n+    fn next_u32(&mut self) -> u32 {\n+        if self.index == STATE_WORDS {\n+            self.update();\n+        }\n+\n+        let value = self.buffer[self.index % STATE_WORDS];\n+        self.index += 1;\n+        value\n+    }\n+}\n+\n+impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n+\n+    fn reseed(&mut self, seed: &'a [u32]) {\n+        // reset state\n+        self.init(&[0u32, ..KEY_WORDS]);\n+        // set key inplace\n+        let key = self.state.slice_mut(4, 4+KEY_WORDS);\n+        for (k, s) in key.iter_mut().zip(seed.iter()) {\n+            *k = *s;\n+        }\n+    }\n+\n+    /// Create a ChaCha generator from a seed,\n+    /// obtained from a variable-length u32 array.\n+    /// Only up to 8 words are used; if less than 8\n+    /// words are used, the remaining are set to zero.\n+    fn from_seed(seed: &'a [u32]) -> ChaChaRng {\n+        let mut rng = EMPTY;\n+        rng.reseed(seed);\n+        rng\n+    }\n+}\n+\n+impl Rand for ChaChaRng {\n+    fn rand<R: Rng>(other: &mut R) -> ChaChaRng {\n+        let mut key : [u32, ..KEY_WORDS] = [0, ..KEY_WORDS];\n+        for word in key.iter_mut() {\n+            *word = other.gen();\n+        }\n+        SeedableRng::from_seed(key.as_slice())\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use std::prelude::*;\n+\n+    use core::iter::order;\n+    use {Rng, SeedableRng};\n+    use super::ChaChaRng;\n+\n+    #[test]\n+    fn test_rng_rand_seeded() {\n+        let s = ::test::rng().gen_iter::<u32>().take(8).collect::<Vec<u32>>();\n+        let mut ra: ChaChaRng = SeedableRng::from_seed(s.as_slice());\n+        let mut rb: ChaChaRng = SeedableRng::from_seed(s.as_slice());\n+        assert!(order::equals(ra.gen_ascii_chars().take(100),\n+                              rb.gen_ascii_chars().take(100)));\n+    }\n+\n+    #[test]\n+    fn test_rng_seeded() {\n+        let seed : &[_] = &[0,1,2,3,4,5,6,7];\n+        let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n+        let mut rb: ChaChaRng = SeedableRng::from_seed(seed);\n+        assert!(order::equals(ra.gen_ascii_chars().take(100),\n+                              rb.gen_ascii_chars().take(100)));\n+    }\n+\n+    #[test]\n+    fn test_rng_reseed() {\n+        let s = ::test::rng().gen_iter::<u32>().take(8).collect::<Vec<u32>>();\n+        let mut r: ChaChaRng = SeedableRng::from_seed(s.as_slice());\n+        let string1: String = r.gen_ascii_chars().take(100).collect();\n+\n+        r.reseed(s.as_slice());\n+\n+        let string2: String = r.gen_ascii_chars().take(100).collect();\n+        assert_eq!(string1, string2);\n+    }\n+\n+    #[test]\n+    fn test_rng_true_values() {\n+        // Test vectors 1 and 2 from\n+        // http://tools.ietf.org/html/draft-nir-cfrg-chacha20-poly1305-04\n+        let seed : &[_] = &[0u32, ..8];\n+        let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n+\n+        let v = Vec::from_fn(16, |_| ra.next_u32());\n+        assert_eq!(v,\n+                   vec!(0xade0b876, 0x903df1a0, 0xe56a5d40, 0x28bd8653,\n+                        0xb819d2bd, 0x1aed8da0, 0xccef36a8, 0xc70d778b,\n+                        0x7c5941da, 0x8d485751, 0x3fe02477, 0x374ad8b8,\n+                        0xf4b8436a, 0x1ca11815, 0x69b687c3, 0x8665eeb2));\n+\n+        let v = Vec::from_fn(16, |_| ra.next_u32());\n+        assert_eq!(v,\n+                   vec!(0xbee7079f, 0x7a385155, 0x7c97ba98, 0x0d082d73,\n+                        0xa0290fcb, 0x6965e348, 0x3e53c612, 0xed7aee32,\n+                        0x7621b729, 0x434ee69c, 0xb03371d5, 0xd539d874,\n+                        0x281fed31, 0x45fb0a51, 0x1f0ae1ac, 0x6f4d794b));\n+\n+\n+        let seed : &[_] = &[0,1,2,3,4,5,6,7];\n+        let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n+\n+        // Store the 17*i-th 32-bit word,\n+        // i.e., the i-th word of the i-th 16-word block\n+        let mut v : Vec<u32> = Vec::new();\n+        for _ in range(0u, 16) {\n+            v.push(ra.next_u32());\n+            for _ in range(0u, 16) {\n+                ra.next_u32();\n+            }\n+        }\n+\n+        assert_eq!(v,\n+                   vec!(0xf225c81a, 0x6ab1be57, 0x04d42951, 0x70858036,\n+                        0x49884684, 0x64efec72, 0x4be2d186, 0x3615b384,\n+                        0x11cfa18e, 0xd3c50049, 0x75c775f6, 0x434c6530,\n+                        0x2c5bad8f, 0x898881dc, 0x5f1c86d9, 0xc1f8e7f4));\n+    }\n+}\n+"}, {"sha": "3319e75a628b69be9a4d6d1d0d7df49155f6f3c7", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5615aceff0f44f7ac6ec0c51800b162804e22453/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5615aceff0f44f7ac6ec0c51800b162804e22453/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=5615aceff0f44f7ac6ec0c51800b162804e22453", "patch": "@@ -39,6 +39,7 @@ extern crate core;\n use core::prelude::*;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n+pub use chacha::ChaChaRng;\n \n use distributions::{Range, IndependentSample};\n use distributions::range::SampleRange;\n@@ -48,6 +49,7 @@ static RAND_BENCH_N: u64 = 100;\n \n pub mod distributions;\n pub mod isaac;\n+pub mod chacha;\n pub mod reseeding;\n mod rand_impls;\n "}, {"sha": "29eae0ced5412d0663ab53407edd89839748b011", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5615aceff0f44f7ac6ec0c51800b162804e22453/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5615aceff0f44f7ac6ec0c51800b162804e22453/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=5615aceff0f44f7ac6ec0c51800b162804e22453", "patch": "@@ -233,7 +233,7 @@ use core_rand::IsaacRng as IsaacWordRng;\n use core_rand::Isaac64Rng as IsaacWordRng;\n \n pub use core_rand::{Rand, Rng, SeedableRng, Open01, Closed01};\n-pub use core_rand::{XorShiftRng, IsaacRng, Isaac64Rng};\n+pub use core_rand::{XorShiftRng, IsaacRng, Isaac64Rng, ChaChaRng};\n pub use core_rand::{distributions, reseeding};\n pub use rand::os::OsRng;\n "}]}