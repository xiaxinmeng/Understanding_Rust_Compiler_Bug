{"sha": "0570f09a33e1ee857918764da9422661f8ae80aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NzBmMDlhMzNlMWVlODU3OTE4NzY0ZGE5NDIyNjYxZjhhZTgwYWE=", "commit": {"author": {"name": "Beno\u00eet du Garreau", "email": "bdgdlm@outlook.com", "date": "2021-06-24T12:44:09Z"}, "committer": {"name": "Beno\u00eet du Garreau", "email": "bdgdlm@outlook.com", "date": "2021-07-23T18:37:09Z"}, "message": "Add support for custom allocator in `VecDeque`", "tree": {"sha": "caadd1d7c2d4329a442b8224b6b340276ee9f336", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caadd1d7c2d4329a442b8224b6b340276ee9f336"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0570f09a33e1ee857918764da9422661f8ae80aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0570f09a33e1ee857918764da9422661f8ae80aa", "html_url": "https://github.com/rust-lang/rust/commit/0570f09a33e1ee857918764da9422661f8ae80aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0570f09a33e1ee857918764da9422661f8ae80aa/comments", "author": {"login": "a1phyr", "id": 47725341, "node_id": "MDQ6VXNlcjQ3NzI1MzQx", "avatar_url": "https://avatars.githubusercontent.com/u/47725341?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a1phyr", "html_url": "https://github.com/a1phyr", "followers_url": "https://api.github.com/users/a1phyr/followers", "following_url": "https://api.github.com/users/a1phyr/following{/other_user}", "gists_url": "https://api.github.com/users/a1phyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/a1phyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a1phyr/subscriptions", "organizations_url": "https://api.github.com/users/a1phyr/orgs", "repos_url": "https://api.github.com/users/a1phyr/repos", "events_url": "https://api.github.com/users/a1phyr/events{/privacy}", "received_events_url": "https://api.github.com/users/a1phyr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "a1phyr", "id": 47725341, "node_id": "MDQ6VXNlcjQ3NzI1MzQx", "avatar_url": "https://avatars.githubusercontent.com/u/47725341?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a1phyr", "html_url": "https://github.com/a1phyr", "followers_url": "https://api.github.com/users/a1phyr/followers", "following_url": "https://api.github.com/users/a1phyr/following{/other_user}", "gists_url": "https://api.github.com/users/a1phyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/a1phyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a1phyr/subscriptions", "organizations_url": "https://api.github.com/users/a1phyr/orgs", "repos_url": "https://api.github.com/users/a1phyr/repos", "events_url": "https://api.github.com/users/a1phyr/events{/privacy}", "received_events_url": "https://api.github.com/users/a1phyr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0443424954f32d94f847322e85c77df50d44f80f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0443424954f32d94f847322e85c77df50d44f80f", "html_url": "https://github.com/rust-lang/rust/commit/0443424954f32d94f847322e85c77df50d44f80f"}], "stats": {"total": 204, "additions": 130, "deletions": 74}, "files": [{"sha": "4f68279129ef959799970fb4d32b2bdf0297f44b", "filename": "library/alloc/src/collections/vec_deque/drain.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0570f09a33e1ee857918764da9422661f8ae80aa/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0570f09a33e1ee857918764da9422661f8ae80aa/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs?ref=0570f09a33e1ee857918764da9422661f8ae80aa", "patch": "@@ -2,6 +2,8 @@ use core::iter::FusedIterator;\n use core::ptr::{self, NonNull};\n use core::{fmt, mem};\n \n+use crate::alloc::{Allocator, Global};\n+\n use super::{count, Iter, VecDeque};\n \n /// A draining iterator over the elements of a `VecDeque`.\n@@ -11,15 +13,15 @@ use super::{count, Iter, VecDeque};\n ///\n /// [`drain`]: VecDeque::drain\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-pub struct Drain<'a, T: 'a> {\n+pub struct Drain<'a, T: 'a, A: Allocator = Global> {\n     pub(crate) after_tail: usize,\n     pub(crate) after_head: usize,\n     pub(crate) iter: Iter<'a, T>,\n-    pub(crate) deque: NonNull<VecDeque<T>>,\n+    pub(crate) deque: NonNull<VecDeque<T, A>>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Drain\")\n             .field(&self.after_tail)\n@@ -30,16 +32,16 @@ impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n+unsafe impl<T: Sync, A: Allocator + Sync> Sync for Drain<'_, T, A> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Send> Send for Drain<'_, T> {}\n+unsafe impl<T: Send, A: Allocator + Send> Send for Drain<'_, T, A> {}\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> Drop for Drain<'_, T> {\n+impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n     fn drop(&mut self) {\n-        struct DropGuard<'r, 'a, T>(&'r mut Drain<'a, T>);\n+        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n \n-        impl<'r, 'a, T> Drop for DropGuard<'r, 'a, T> {\n+        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n             fn drop(&mut self) {\n                 self.0.for_each(drop);\n \n@@ -96,7 +98,7 @@ impl<T> Drop for Drain<'_, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> Iterator for Drain<'_, T> {\n+impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n     type Item = T;\n \n     #[inline]\n@@ -111,15 +113,15 @@ impl<T> Iterator for Drain<'_, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> DoubleEndedIterator for Drain<'_, T> {\n+impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.iter.next_back().map(|elt| unsafe { ptr::read(elt) })\n     }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> ExactSizeIterator for Drain<'_, T> {}\n+impl<T, A: Allocator> ExactSizeIterator for Drain<'_, T, A> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Drain<'_, T> {}\n+impl<T, A: Allocator> FusedIterator for Drain<'_, T, A> {}"}, {"sha": "4263878aa176589e6cd0fc0927e1fbebe77d0979", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0570f09a33e1ee857918764da9422661f8ae80aa/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0570f09a33e1ee857918764da9422661f8ae80aa/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=0570f09a33e1ee857918764da9422661f8ae80aa", "patch": "@@ -1,6 +1,8 @@\n use core::fmt;\n use core::iter::{FusedIterator, TrustedLen};\n \n+use crate::alloc::{Allocator, Global};\n+\n use super::VecDeque;\n \n /// An owning iterator over the elements of a `VecDeque`.\n@@ -11,19 +13,19 @@ use super::VecDeque;\n /// [`into_iter`]: VecDeque::into_iter\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<T> {\n-    pub(crate) inner: VecDeque<T>,\n+pub struct IntoIter<T, A: Allocator = Global> {\n+    pub(crate) inner: VecDeque<T, A>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for IntoIter<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"IntoIter\").field(&self.inner).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Iterator for IntoIter<T> {\n+impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n     type Item = T;\n \n     #[inline]\n@@ -39,22 +41,22 @@ impl<T> Iterator for IntoIter<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> DoubleEndedIterator for IntoIter<T> {\n+impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for IntoIter<T> {\n+impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n     fn is_empty(&self) -> bool {\n         self.inner.is_empty()\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for IntoIter<T> {}\n+impl<T, A: Allocator> FusedIterator for IntoIter<T, A> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T> TrustedLen for IntoIter<T> {}\n+unsafe impl<T, A: Allocator> TrustedLen for IntoIter<T, A> {}"}, {"sha": "5c7913073fe8780f48c29f98b259caaf0f740a98", "filename": "library/alloc/src/collections/vec_deque/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0570f09a33e1ee857918764da9422661f8ae80aa/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0570f09a33e1ee857918764da9422661f8ae80aa/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmacros.rs?ref=0570f09a33e1ee857918764da9422661f8ae80aa", "patch": "@@ -1,9 +1,9 @@\n macro_rules! __impl_slice_eq1 {\n     ([$($vars:tt)*] $lhs:ty, $rhs:ty, $($constraints:tt)*) => {\n         #[stable(feature = \"vec_deque_partial_eq_slice\", since = \"1.17.0\")]\n-        impl<A, B, $($vars)*> PartialEq<$rhs> for $lhs\n+        impl<T, U, A: Allocator, $($vars)*> PartialEq<$rhs> for $lhs\n         where\n-            A: PartialEq<B>,\n+            T: PartialEq<U>,\n             $($constraints)*\n         {\n             fn eq(&self, other: &$rhs) -> bool {"}, {"sha": "fbd6149733704846bdb782500ab17f3b8424999f", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 101, "deletions": 51, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/0570f09a33e1ee857918764da9422661f8ae80aa/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0570f09a33e1ee857918764da9422661f8ae80aa/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=0570f09a33e1ee857918764da9422661f8ae80aa", "patch": "@@ -17,6 +17,7 @@ use core::ops::{Index, IndexMut, Range, RangeBounds};\n use core::ptr::{self, NonNull};\n use core::slice;\n \n+use crate::alloc::{Allocator, Global};\n use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n@@ -80,21 +81,26 @@ const MAXIMUM_ZST_CAPACITY: usize = 1 << (usize::BITS - 1); // Largest possible\n /// [`make_contiguous`]: VecDeque::make_contiguous\n #[cfg_attr(not(test), rustc_diagnostic_item = \"vecdeque_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct VecDeque<T> {\n+pub struct VecDeque<\n+    T,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points\n     // to where data should be written.\n     // If tail == head the buffer is empty. The length of the ringbuffer\n     // is defined as the distance between the two.\n     tail: usize,\n     head: usize,\n-    buf: RawVec<T>,\n+    buf: RawVec<T, A>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone> Clone for VecDeque<T> {\n-    fn clone(&self) -> VecDeque<T> {\n-        self.iter().cloned().collect()\n+impl<T: Clone, A: Allocator + Clone> Clone for VecDeque<T, A> {\n+    fn clone(&self) -> Self {\n+        let mut deq = Self::with_capacity_in(self.len(), self.allocator().clone());\n+        deq.extend(self.iter().cloned());\n+        deq\n     }\n \n     fn clone_from(&mut self, other: &Self) {\n@@ -114,7 +120,7 @@ impl<T: Clone> Clone for VecDeque<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T> Drop for VecDeque<T> {\n+unsafe impl<#[may_dangle] T, A: Allocator> Drop for VecDeque<T, A> {\n     fn drop(&mut self) {\n         /// Runs the destructor for all items in the slice when it gets dropped (normally or\n         /// during unwinding).\n@@ -147,7 +153,7 @@ impl<T> Default for VecDeque<T> {\n     }\n }\n \n-impl<T> VecDeque<T> {\n+impl<T, A: Allocator> VecDeque<T, A> {\n     /// Marginally more convenient\n     #[inline]\n     fn ptr(&self) -> *mut T {\n@@ -457,9 +463,10 @@ impl<T> VecDeque<T> {\n     ///\n     /// let vector: VecDeque<u32> = VecDeque::new();\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> VecDeque<T> {\n-        VecDeque::with_capacity(INITIAL_CAPACITY)\n+        VecDeque::new_in(Global)\n     }\n \n     /// Creates an empty `VecDeque` with space for at least `capacity` elements.\n@@ -471,13 +478,45 @@ impl<T> VecDeque<T> {\n     ///\n     /// let vector: VecDeque<u32> = VecDeque::with_capacity(10);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> VecDeque<T> {\n+        Self::with_capacity_in(capacity, Global)\n+    }\n+}\n+\n+impl<T, A: Allocator> VecDeque<T, A> {\n+    /// Creates an empty `VecDeque`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let vector: VecDeque<u32> = VecDeque::new();\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new_in(alloc: A) -> VecDeque<T, A> {\n+        VecDeque::with_capacity_in(INITIAL_CAPACITY, alloc)\n+    }\n+\n+    /// Creates an empty `VecDeque` with space for at least `capacity` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let vector: VecDeque<u32> = VecDeque::with_capacity(10);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn with_capacity_in(capacity: usize, alloc: A) -> VecDeque<T, A> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(capacity + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n         assert!(cap > capacity, \"capacity overflow\");\n \n-        VecDeque { tail: 0, head: 0, buf: RawVec::with_capacity(cap) }\n+        VecDeque { tail: 0, head: 0, buf: RawVec::with_capacity_in(cap, alloc) }\n     }\n \n     /// Provides a reference to the element at the given index.\n@@ -904,6 +943,13 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn allocator(&self) -> &A {\n+        self.buf.allocator()\n+    }\n+\n     /// Returns a front-to-back iterator.\n     ///\n     /// # Examples\n@@ -1176,7 +1222,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n-    pub fn drain<R>(&mut self, range: R) -> Drain<'_, T>\n+    pub fn drain<R>(&mut self, range: R) -> Drain<'_, T, A>\n     where\n         R: RangeBounds<usize>,\n     {\n@@ -1965,12 +2011,15 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[must_use = \"use `.truncate()` if you don't need the other half\"]\n     #[stable(feature = \"split_off\", since = \"1.4.0\")]\n-    pub fn split_off(&mut self, at: usize) -> Self {\n+    pub fn split_off(&mut self, at: usize) -> Self\n+    where\n+        A: Clone,\n+    {\n         let len = self.len();\n         assert!(at <= len, \"`at` out of bounds\");\n \n         let other_len = len - at;\n-        let mut other = VecDeque::with_capacity(other_len);\n+        let mut other = VecDeque::with_capacity_in(other_len, self.allocator().clone());\n \n         unsafe {\n             let (first_half, second_half) = self.as_slices();\n@@ -2593,7 +2642,7 @@ impl<T> VecDeque<T> {\n     }\n }\n \n-impl<T: Clone> VecDeque<T> {\n+impl<T: Clone, A: Allocator> VecDeque<T, A> {\n     /// Modifies the `VecDeque` in-place so that `len()` is equal to new_len,\n     /// either by removing excess elements from the back or by appending clones of `value`\n     /// to the back.\n@@ -2637,8 +2686,8 @@ fn count(tail: usize, head: usize, size: usize) -> usize {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialEq> PartialEq for VecDeque<A> {\n-    fn eq(&self, other: &VecDeque<A>) -> bool {\n+impl<T: PartialEq, A: Allocator> PartialEq for VecDeque<T, A> {\n+    fn eq(&self, other: &Self) -> bool {\n         if self.len() != other.len() {\n             return false;\n         }\n@@ -2676,32 +2725,32 @@ impl<A: PartialEq> PartialEq for VecDeque<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Eq> Eq for VecDeque<A> {}\n+impl<T: Eq, A: Allocator> Eq for VecDeque<T, A> {}\n \n-__impl_slice_eq1! { [] VecDeque<A>, Vec<B>, }\n-__impl_slice_eq1! { [] VecDeque<A>, &[B], }\n-__impl_slice_eq1! { [] VecDeque<A>, &mut [B], }\n-__impl_slice_eq1! { [const N: usize] VecDeque<A>, [B; N], }\n-__impl_slice_eq1! { [const N: usize] VecDeque<A>, &[B; N], }\n-__impl_slice_eq1! { [const N: usize] VecDeque<A>, &mut [B; N], }\n+__impl_slice_eq1! { [] VecDeque<T, A>, Vec<U, A>, }\n+__impl_slice_eq1! { [] VecDeque<T, A>, &[U], }\n+__impl_slice_eq1! { [] VecDeque<T, A>, &mut [U], }\n+__impl_slice_eq1! { [const N: usize] VecDeque<T, A>, [U; N], }\n+__impl_slice_eq1! { [const N: usize] VecDeque<T, A>, &[U; N], }\n+__impl_slice_eq1! { [const N: usize] VecDeque<T, A>, &mut [U; N], }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialOrd> PartialOrd for VecDeque<A> {\n-    fn partial_cmp(&self, other: &VecDeque<A>) -> Option<Ordering> {\n+impl<T: PartialOrd, A: Allocator> PartialOrd for VecDeque<T, A> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         self.iter().partial_cmp(other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Ord> Ord for VecDeque<A> {\n+impl<T: Ord, A: Allocator> Ord for VecDeque<T, A> {\n     #[inline]\n-    fn cmp(&self, other: &VecDeque<A>) -> Ordering {\n+    fn cmp(&self, other: &Self) -> Ordering {\n         self.iter().cmp(other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Hash> Hash for VecDeque<A> {\n+impl<T: Hash, A: Allocator> Hash for VecDeque<T, A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.len().hash(state);\n         // It's not possible to use Hash::hash_slice on slices\n@@ -2715,26 +2764,26 @@ impl<A: Hash> Hash for VecDeque<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Index<usize> for VecDeque<A> {\n-    type Output = A;\n+impl<T, A: Allocator> Index<usize> for VecDeque<T, A> {\n+    type Output = T;\n \n     #[inline]\n-    fn index(&self, index: usize) -> &A {\n+    fn index(&self, index: usize) -> &T {\n         self.get(index).expect(\"Out of bounds access\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> IndexMut<usize> for VecDeque<A> {\n+impl<T, A: Allocator> IndexMut<usize> for VecDeque<T, A> {\n     #[inline]\n-    fn index_mut(&mut self, index: usize) -> &mut A {\n+    fn index_mut(&mut self, index: usize) -> &mut T {\n         self.get_mut(index).expect(\"Out of bounds access\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> FromIterator<A> for VecDeque<A> {\n-    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> VecDeque<A> {\n+impl<T> FromIterator<T> for VecDeque<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> VecDeque<T> {\n         let iterator = iter.into_iter();\n         let (lower, _) = iterator.size_hint();\n         let mut deq = VecDeque::with_capacity(lower);\n@@ -2744,19 +2793,19 @@ impl<A> FromIterator<A> for VecDeque<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IntoIterator for VecDeque<T> {\n+impl<T, A: Allocator> IntoIterator for VecDeque<T, A> {\n     type Item = T;\n-    type IntoIter = IntoIter<T>;\n+    type IntoIter = IntoIter<T, A>;\n \n     /// Consumes the `VecDeque` into a front-to-back iterator yielding elements by\n     /// value.\n-    fn into_iter(self) -> IntoIter<T> {\n+    fn into_iter(self) -> IntoIter<T, A> {\n         IntoIter { inner: self }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a VecDeque<T> {\n+impl<'a, T, A: Allocator> IntoIterator for &'a VecDeque<T, A> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -2766,7 +2815,7 @@ impl<'a, T> IntoIterator for &'a VecDeque<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n+impl<'a, T, A: Allocator> IntoIterator for &'a mut VecDeque<T, A> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n@@ -2776,8 +2825,8 @@ impl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Extend<A> for VecDeque<A> {\n-    fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T) {\n+impl<T, A: Allocator> Extend<T> for VecDeque<T, A> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         // This function should be the moral equivalent of:\n         //\n         //      for item in iter.into_iter() {\n@@ -2799,7 +2848,7 @@ impl<A> Extend<A> for VecDeque<A> {\n     }\n \n     #[inline]\n-    fn extend_one(&mut self, elem: A) {\n+    fn extend_one(&mut self, elem: T) {\n         self.push_back(elem);\n     }\n \n@@ -2810,7 +2859,7 @@ impl<A> Extend<A> for VecDeque<A> {\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a, T: 'a + Copy> Extend<&'a T> for VecDeque<T> {\n+impl<'a, T: 'a + Copy, A: Allocator> Extend<&'a T> for VecDeque<T, A> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n@@ -2827,14 +2876,14 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for VecDeque<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for VecDeque<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self).finish()\n     }\n }\n \n #[stable(feature = \"vecdeque_vec_conversions\", since = \"1.10.0\")]\n-impl<T> From<Vec<T>> for VecDeque<T> {\n+impl<T, A: Allocator> From<Vec<T, A>> for VecDeque<T, A> {\n     /// Turn a [`Vec<T>`] into a [`VecDeque<T>`].\n     ///\n     /// [`Vec<T>`]: crate::vec::Vec\n@@ -2843,7 +2892,7 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n     /// This avoids reallocating where possible, but the conditions for that are\n     /// strict, and subject to change, and so shouldn't be relied upon unless the\n     /// `Vec<T>` came from `From<VecDeque<T>>` and hasn't been reallocated.\n-    fn from(mut other: Vec<T>) -> Self {\n+    fn from(mut other: Vec<T, A>) -> Self {\n         let len = other.len();\n         if mem::size_of::<T>() == 0 {\n             // There's no actual allocation for ZSTs to worry about capacity,\n@@ -2861,15 +2910,15 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n         }\n \n         unsafe {\n-            let (other_buf, len, capacity) = other.into_raw_parts();\n-            let buf = RawVec::from_raw_parts(other_buf, capacity);\n+            let (other_buf, len, capacity, alloc) = other.into_raw_parts_with_alloc();\n+            let buf = RawVec::from_raw_parts_in(other_buf, capacity, alloc);\n             VecDeque { tail: 0, head: len, buf }\n         }\n     }\n }\n \n #[stable(feature = \"vecdeque_vec_conversions\", since = \"1.10.0\")]\n-impl<T> From<VecDeque<T>> for Vec<T> {\n+impl<T, A: Allocator> From<VecDeque<T, A>> for Vec<T, A> {\n     /// Turn a [`VecDeque<T>`] into a [`Vec<T>`].\n     ///\n     /// [`Vec<T>`]: crate::vec::Vec\n@@ -2899,19 +2948,20 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// assert_eq!(vec, [8, 9, 1, 2, 3, 4]);\n     /// assert_eq!(vec.as_ptr(), ptr);\n     /// ```\n-    fn from(mut other: VecDeque<T>) -> Self {\n+    fn from(mut other: VecDeque<T, A>) -> Self {\n         other.make_contiguous();\n \n         unsafe {\n             let other = ManuallyDrop::new(other);\n             let buf = other.buf.ptr();\n             let len = other.len();\n             let cap = other.cap();\n+            let alloc = ptr::read(other.allocator());\n \n             if other.tail != 0 {\n                 ptr::copy(buf.add(other.tail), buf, len);\n             }\n-            Vec::from_raw_parts(buf, len, cap)\n+            Vec::from_raw_parts_in(buf, len, cap, alloc)\n         }\n     }\n }"}, {"sha": "8e3ac9cfd1d87dc919b7cce59bd8fb1ee8a3b663", "filename": "library/alloc/src/collections/vec_deque/pair_slices.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0570f09a33e1ee857918764da9422661f8ae80aa/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0570f09a33e1ee857918764da9422661f8ae80aa/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs?ref=0570f09a33e1ee857918764da9422661f8ae80aa", "patch": "@@ -1,6 +1,8 @@\n use core::cmp::{self};\n use core::mem::replace;\n \n+use crate::alloc::Allocator;\n+\n use super::VecDeque;\n \n /// PairSlices pairs up equal length slice parts of two deques\n@@ -25,7 +27,7 @@ pub struct PairSlices<'a, 'b, T> {\n }\n \n impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n-    pub fn from(to: &'a mut VecDeque<T>, from: &'b VecDeque<T>) -> Self {\n+    pub fn from<A: Allocator>(to: &'a mut VecDeque<T, A>, from: &'b VecDeque<T, A>) -> Self {\n         let (a0, a1) = to.as_mut_slices();\n         let (b0, b1) = from.as_slices();\n         PairSlices { a0, a1, b0, b1 }"}]}