{"sha": "81b07edde87f94492051c7cd07478d2715939d80", "node_id": "C_kwDOAAsO6NoAKDgxYjA3ZWRkZTg3Zjk0NDkyMDUxYzdjZDA3NDc4ZDI3MTU5MzlkODA", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-05-31T13:56:16Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-05-31T14:07:16Z"}, "message": "Inline from_inline_const into its sole call site", "tree": {"sha": "86432540c49eeed4554314cdb6f31f81b0d12625", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86432540c49eeed4554314cdb6f31f81b0d12625"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81b07edde87f94492051c7cd07478d2715939d80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81b07edde87f94492051c7cd07478d2715939d80", "html_url": "https://github.com/rust-lang/rust/commit/81b07edde87f94492051c7cd07478d2715939d80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81b07edde87f94492051c7cd07478d2715939d80/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4d5dded572d70fb3a8635e878c9088c0db362bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4d5dded572d70fb3a8635e878c9088c0db362bd", "html_url": "https://github.com/rust-lang/rust/commit/c4d5dded572d70fb3a8635e878c9088c0db362bd"}], "stats": {"total": 140, "additions": 62, "deletions": 78}, "files": [{"sha": "4e7cb6853ea3fb758501f0b1c3b9d91ddbc5d1ac", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/81b07edde87f94492051c7cd07478d2715939d80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b07edde87f94492051c7cd07478d2715939d80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=81b07edde87f94492051c7cd07478d2715939d80", "patch": "@@ -3,7 +3,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n use crate::mir::interpret::{\n-    AllocRange, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, LitToConstInput, Scalar,\n+    AllocRange, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n use crate::mir::visit::MirVisitable;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -2461,51 +2461,6 @@ impl<'tcx> ConstantKind<'tcx> {\n         Self::Val(val, ty)\n     }\n \n-    #[instrument(skip(tcx), level = \"debug\", ret)]\n-    pub fn from_inline_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        let body_id = match tcx.hir().get(hir_id) {\n-            hir::Node::AnonConst(ac) => ac.body,\n-            _ => span_bug!(\n-                tcx.def_span(def_id.to_def_id()),\n-                \"from_inline_const can only process anonymous constants\"\n-            ),\n-        };\n-        let expr = &tcx.hir().body(body_id).value;\n-        let ty = tcx.typeck(def_id).node_type(hir_id);\n-\n-        let lit_input = match expr.kind {\n-            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n-            hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => match expr.kind {\n-                hir::ExprKind::Lit(ref lit) => {\n-                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        };\n-        if let Some(lit_input) = lit_input {\n-            // If an error occurred, ignore that it's a literal and leave reporting the error up to\n-            // mir.\n-            match tcx.at(expr.span).lit_to_const(lit_input) {\n-                Ok(c) => return Self::Ty(c),\n-                Err(_) => {}\n-            }\n-        }\n-\n-        let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id());\n-        let parent_substs =\n-            tcx.erase_regions(InternalSubsts::identity_for_item(tcx, typeck_root_def_id));\n-        let substs =\n-            ty::InlineConstSubsts::new(tcx, ty::InlineConstSubstsParts { parent_substs, ty })\n-                .substs;\n-\n-        let uneval = UnevaluatedConst { def: def_id.to_def_id(), substs, promoted: None };\n-        debug_assert!(!uneval.has_free_regions());\n-\n-        Self::Unevaluated(uneval, ty)\n-    }\n-\n     /// Literals are converted to `ConstantKindVal`, const generic parameters are eagerly\n     /// converted to a constant, everything else becomes `Unevaluated`.\n     #[instrument(skip(tcx), level = \"debug\", ret)]"}, {"sha": "1bbe7b45c1ed2bc7144c352c25126e434fbb6126", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 61, "deletions": 32, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/81b07edde87f94492051c7cd07478d2715939d80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b07edde87f94492051c7cd07478d2715939d80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=81b07edde87f94492051c7cd07478d2715939d80", "patch": "@@ -25,7 +25,8 @@ use rustc_middle::mir::{BorrowKind, Mutability};\n use rustc_middle::thir::{Ascription, BindingMode, FieldPat, LocalVarId, Pat, PatKind, PatRange};\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n use rustc_middle::ty::CanonicalUserTypeAnnotation;\n-use rustc_middle::ty::{self, AdtDef, ConstKind, Region, Ty, TyCtxt, UserType};\n+use rustc_middle::ty::TypeVisitableExt;\n+use rustc_middle::ty::{self, AdtDef, Region, Ty, TyCtxt, UserType};\n use rustc_span::{Span, Symbol};\n use rustc_target::abi::FieldIdx;\n \n@@ -585,43 +586,71 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         id: hir::HirId,\n         span: Span,\n     ) -> PatKind<'tcx> {\n-        let value = mir::ConstantKind::from_inline_const(self.tcx, anon_const.def_id);\n-        let value = match value {\n-            mir::ConstantKind::Ty(_) => value,\n-            // Evaluate early like we do in `lower_path`.\n-            mir::ConstantKind::Unevaluated(ct, ty) => {\n-                let ct = ty::UnevaluatedConst { def: ct.def, substs: ct.substs };\n-                if let Ok(Some(valtree)) =\n-                    self.tcx.const_eval_resolve_for_typeck(self.param_env, ct, Some(span))\n-                {\n-                    mir::ConstantKind::Ty(self.tcx.mk_const(valtree, ty))\n-                } else {\n-                    value.eval(self.tcx, self.param_env)\n-                }\n-            }\n-            mir::ConstantKind::Val(_, _) => unreachable!(),\n+        let tcx = self.tcx;\n+        let def_id = anon_const.def_id;\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let body_id = match tcx.hir().get(hir_id) {\n+            hir::Node::AnonConst(ac) => ac.body,\n+            _ => span_bug!(\n+                tcx.def_span(def_id.to_def_id()),\n+                \"from_inline_const can only process anonymous constants\"\n+            ),\n         };\n-\n-        match value {\n-            mir::ConstantKind::Ty(c) => match c.kind() {\n-                ConstKind::Param(_) => {\n-                    self.tcx.sess.emit_err(ConstParamInPattern { span });\n-                    return PatKind::Wild;\n-                }\n-                ConstKind::Error(_) => {\n-                    return PatKind::Wild;\n+        let expr = &tcx.hir().body(body_id).value;\n+        let ty = tcx.typeck(def_id).node_type(hir_id);\n+\n+        // Special case inline consts that are just literals. This is solely\n+        // a performance optimization, as we could also just go through the regular\n+        // const eval path below.\n+        // FIXME: investigate the performance impact of removing this.\n+        let lit_input = match expr.kind {\n+            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n+            hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => match expr.kind {\n+                hir::ExprKind::Lit(ref lit) => {\n+                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n                 }\n-                _ => {}\n+                _ => None,\n             },\n-            mir::ConstantKind::Val(_, _) => {}\n-            mir::ConstantKind::Unevaluated(..) => {\n-                // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n-                self.tcx.sess.emit_err(ConstPatternDependsOnGenericParameter { span });\n-                return PatKind::Wild;\n+            _ => None,\n+        };\n+        if let Some(lit_input) = lit_input {\n+            match tcx.at(expr.span).lit_to_const(lit_input) {\n+                Ok(c) => return self.const_to_pat(ConstantKind::Ty(c), id, span, None).kind,\n+                // If an error occurred, ignore that it's a literal\n+                // and leave reporting the error up to const eval of\n+                // the unevaluated constant below.\n+                Err(_) => {}\n             }\n         }\n \n-        self.const_to_pat(value, id, span, None).kind\n+        let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id());\n+        let parent_substs =\n+            tcx.erase_regions(ty::InternalSubsts::identity_for_item(tcx, typeck_root_def_id));\n+        let substs =\n+            ty::InlineConstSubsts::new(tcx, ty::InlineConstSubstsParts { parent_substs, ty })\n+                .substs;\n+\n+        let uneval = mir::UnevaluatedConst { def: def_id.to_def_id(), substs, promoted: None };\n+        debug_assert!(!substs.has_free_regions());\n+\n+        let ct = ty::UnevaluatedConst { def: def_id.to_def_id(), substs: substs };\n+        // First try using a valtree in order to destructure the constant into a pattern.\n+        if let Ok(Some(valtree)) =\n+            self.tcx.const_eval_resolve_for_typeck(self.param_env, ct, Some(span))\n+        {\n+            self.const_to_pat(ConstantKind::Ty(self.tcx.mk_const(valtree, ty)), id, span, None).kind\n+        } else {\n+            // If that fails, convert it to an opaque constant pattern.\n+            match tcx.const_eval_resolve(self.param_env, uneval, None) {\n+                Ok(val) => self.const_to_pat(mir::ConstantKind::Val(val, ty), id, span, None).kind,\n+                Err(ErrorHandled::TooGeneric) => {\n+                    // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n+                    self.tcx.sess.emit_err(ConstPatternDependsOnGenericParameter { span });\n+                    PatKind::Wild\n+                }\n+                Err(ErrorHandled::Reported(_)) => PatKind::Wild,\n+            }\n+        }\n     }\n \n     /// Converts literals, paths and negation of literals to patterns."}]}