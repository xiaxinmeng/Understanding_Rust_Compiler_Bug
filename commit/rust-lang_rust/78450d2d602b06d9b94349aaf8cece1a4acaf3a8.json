{"sha": "78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "node_id": "C_kwDOAAsO6NoAKDc4NDUwZDJkNjAyYjA2ZDliOTQzNDlhYWY4Y2VjZTFhNGFjYWYzYTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-11T15:16:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-11T15:16:09Z"}, "message": "Auto merge of #93891 - matthiaskrgr:rollup-xadut8w, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #92242 (Erase regions before calculating layout for packed field capture)\n - #93443 (Add comment on stable_hash_impl for OwnerNodes)\n - #93742 (Drop rustc-docs from complete profile)\n - #93852 (rustdoc: remove support for multi-query search)\n - #93853 (Make all `hir::Map` methods consistently by-value)\n - #93861 (Fix ICE if no trait assoc const eq)\n - #93862 (Split x86_64-apple builder into two)\n - #93864 (Remove ArchiveBuilder::update_symbols)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "5bc15e671d115341faaa337fd223353696755ab1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bc15e671d115341faaa337fd223353696755ab1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "html_url": "https://github.com/rust-lang/rust/commit/78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "html_url": "https://github.com/rust-lang/rust/commit/e273fca380c5d28bc32b25ac1a885c61d4c5e75e"}, {"sha": "c543f7dbd4cc4afb57cb00b2937b50a3371fa15d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c543f7dbd4cc4afb57cb00b2937b50a3371fa15d", "html_url": "https://github.com/rust-lang/rust/commit/c543f7dbd4cc4afb57cb00b2937b50a3371fa15d"}], "stats": {"total": 482, "additions": 226, "deletions": 256}, "files": [{"sha": "97a31d3c97020777971fdb277b9ed5e07071178f", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -319,9 +319,20 @@ jobs:\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n             os: macos-latest\n-          - name: x86_64-apple\n+          - name: x86_64-apple-1\n             env:\n-              SCRIPT: \"./x.py --stage 2 test\"\n+              SCRIPT: \"./x.py --stage 2 test --exclude src/test/ui --exclude src/test/rustdoc --exclude src/test/run-make-fulldeps\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.8\n+              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_OVERFLOW_CHECKS: 1\n+            os: macos-latest\n+          - name: x86_64-apple-2\n+            env:\n+              SCRIPT: \"./x.py --stage 2 test src/test/ui src/test/rustdoc src/test/run-make-fulldeps\"\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.8"}, {"sha": "e6c057cc8eea5daf2d9e15b1af58ed8502cfde25", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -763,7 +763,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             HirId, ImplItem, ImplItemKind, Item, ItemKind,\n         };\n \n-        fn maybe_body_id_of_fn(hir_map: &Map<'_>, id: HirId) -> Option<BodyId> {\n+        fn maybe_body_id_of_fn(hir_map: Map<'_>, id: HirId) -> Option<BodyId> {\n             match hir_map.find(id) {\n                 Some(Node::Item(Item { kind: ItemKind::Fn(_, _, body_id), .. }))\n                 | Some(Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(_, body_id), .. })) => {\n@@ -774,7 +774,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n         let hir_map = self.infcx.tcx.hir();\n         let mir_body_hir_id = self.mir_hir_id();\n-        if let Some(fn_body_id) = maybe_body_id_of_fn(&hir_map, mir_body_hir_id) {\n+        if let Some(fn_body_id) = maybe_body_id_of_fn(hir_map, mir_body_hir_id) {\n             if let Block(\n                 hir::Block {\n                     expr:"}, {"sha": "a099e8b3a6af3a07806d1c5e3b33996941adc1f1", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -105,8 +105,6 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         Ok(())\n     }\n \n-    fn update_symbols(&mut self) {}\n-\n     fn build(mut self) {\n         enum BuilderKind {\n             Bsd(ar::Builder<File>),"}, {"sha": "fac532f3e9c83a1f2dad6c48a27faecd64a25d2c", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -113,9 +113,6 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         Ok(())\n     }\n \n-    fn update_symbols(&mut self) {\n-    }\n-\n     fn build(mut self) {\n         use std::process::Command;\n "}, {"sha": "21bd1dae7ac47161ccfbfe42c981b396a3b3933d", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -27,7 +27,6 @@ pub struct LlvmArchiveBuilder<'a> {\n     config: ArchiveConfig<'a>,\n     removals: Vec<String>,\n     additions: Vec<Addition>,\n-    should_update_symbols: bool,\n     src_archive: Option<Option<ArchiveRO>>,\n }\n \n@@ -75,7 +74,6 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n             config,\n             removals: Vec::new(),\n             additions: Vec::new(),\n-            should_update_symbols: false,\n             src_archive: None,\n         }\n     }\n@@ -129,12 +127,6 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n             .push(Addition::File { path: file.to_path_buf(), name_in_archive: name.to_owned() });\n     }\n \n-    /// Indicate that the next call to `build` should update all symbols in\n-    /// the archive (equivalent to running 'ar s' over it).\n-    fn update_symbols(&mut self) {\n-        self.should_update_symbols = true;\n-    }\n-\n     /// Combine the provided files, rlibs, and native libraries into a single\n     /// `Archive`.\n     fn build(mut self) {\n@@ -313,7 +305,6 @@ impl<'a> LlvmArchiveBuilder<'a> {\n         let mut members = Vec::new();\n \n         let dst = CString::new(self.config.dst.to_str().unwrap())?;\n-        let should_update_symbols = self.should_update_symbols;\n \n         unsafe {\n             if let Some(archive) = self.src_archive() {\n@@ -385,7 +376,7 @@ impl<'a> LlvmArchiveBuilder<'a> {\n                 dst.as_ptr(),\n                 members.len() as libc::size_t,\n                 members.as_ptr() as *const &_,\n-                should_update_symbols,\n+                true,\n                 kind,\n             );\n             let ret = if r.into_result().is_err() {"}, {"sha": "a2f74b9421468105e76a59d75c645a5034b9a6be", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -51,7 +51,6 @@ pub trait ArchiveBuilder<'a> {\n     fn add_archive<F>(&mut self, archive: &Path, skip: F) -> io::Result<()>\n     where\n         F: FnMut(&str) -> bool + 'static;\n-    fn update_symbols(&mut self);\n \n     fn build(self);\n "}, {"sha": "e53c98421176c69eb22dc361494361bb66463584", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -333,10 +333,6 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n         ab.inject_dll_import_lib(&raw_dylib_name, &raw_dylib_imports, tmpdir);\n     }\n \n-    // After adding all files to the archive, we need to update the\n-    // symbol table of the archive.\n-    ab.update_symbols();\n-\n     // Note that it is important that we add all of our non-object \"magical\n     // files\" *after* all of the object files in the archive. The reason for\n     // this is as follows:\n@@ -365,13 +361,6 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n             // normal linkers for the platform.\n             let metadata = create_rmeta_file(sess, codegen_results.metadata.raw_data());\n             ab.add_file(&emit_metadata(sess, &metadata, tmpdir));\n-\n-            // After adding all files to the archive, we need to update the\n-            // symbol table of the archive. This currently dies on macOS (see\n-            // #11162), and isn't necessary there anyway\n-            if !sess.target.is_like_osx {\n-                ab.update_symbols();\n-            }\n         }\n \n         RlibFlavor::StaticlibBase => {\n@@ -381,6 +370,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n             }\n         }\n     }\n+\n     return Ok(ab);\n }\n \n@@ -509,7 +499,6 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n         sess.fatal(&e);\n     }\n \n-    ab.update_symbols();\n     ab.build();\n \n     if !all_native_libs.is_empty() {\n@@ -2310,7 +2299,6 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n \n         sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n             let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n-            archive.update_symbols();\n \n             let mut any_objects = false;\n             for f in archive.src_files() {"}, {"sha": "c55f2a7b03941461ed0e9ca824d69da656f99532", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -141,22 +141,22 @@ pub trait Map<'hir> {\n // Used when no map is actually available, forcing manual implementation of nested visitors.\n impl<'hir> Map<'hir> for ! {\n     fn find(&self, _: HirId) -> Option<Node<'hir>> {\n-        unreachable!()\n+        *self;\n     }\n     fn body(&self, _: BodyId) -> &'hir Body<'hir> {\n-        unreachable!()\n+        *self;\n     }\n     fn item(&self, _: ItemId) -> &'hir Item<'hir> {\n-        unreachable!()\n+        *self;\n     }\n     fn trait_item(&self, _: TraitItemId) -> &'hir TraitItem<'hir> {\n-        unreachable!()\n+        *self;\n     }\n     fn impl_item(&self, _: ImplItemId) -> &'hir ImplItem<'hir> {\n-        unreachable!()\n+        *self;\n     }\n     fn foreign_item(&self, _: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        unreachable!()\n+        *self;\n     }\n }\n "}, {"sha": "61f03442d61f204d1f0ba83a7c06fe00133b1b95", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -206,6 +206,9 @@ impl<'tcx, HirCtx: crate::HashStableContext> HashStable<HirCtx> for OwnerNodes<'\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n         // We ignore the `nodes` and `bodies` fields since these refer to information included in\n         // `hash` which is hashed in the collector and used for the crate hash.\n+        // `local_id_to_def_id` is also ignored because is dependent on the body, then just hashing\n+        // the body satisfies the condition of two nodes being different have different\n+        // `hash_stable` results.\n         let OwnerNodes {\n             hash_including_bodies,\n             hash_without_bodies: _,"}, {"sha": "b2de440084cc4e938a9b2a471cdfc432f2ea33c9", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -2226,7 +2226,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) -> DiagnosticBuilder<'a> {\n-        let hir = &self.tcx.hir();\n+        let hir = self.tcx.hir();\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n         let generics = self"}, {"sha": "f36847c778109249544df0d16fc5b77532854aa4", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -149,35 +149,35 @@ impl<'hir> Iterator for ParentOwnerIterator<'hir> {\n }\n \n impl<'hir> Map<'hir> {\n-    pub fn krate(&self) -> &'hir Crate<'hir> {\n+    pub fn krate(self) -> &'hir Crate<'hir> {\n         self.tcx.hir_crate(())\n     }\n \n-    pub fn root_module(&self) -> &'hir Mod<'hir> {\n+    pub fn root_module(self) -> &'hir Mod<'hir> {\n         match self.tcx.hir_owner(CRATE_DEF_ID).map(|o| o.node) {\n             Some(OwnerNode::Crate(item)) => item,\n             _ => bug!(),\n         }\n     }\n \n-    pub fn items(&self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n+    pub fn items(self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n         let krate = self.krate();\n         krate.owners.iter().filter_map(|owner| match owner.as_owner()?.node() {\n             OwnerNode::Item(item) => Some(item),\n             _ => None,\n         })\n     }\n \n-    pub fn def_key(&self, def_id: LocalDefId) -> DefKey {\n+    pub fn def_key(self, def_id: LocalDefId) -> DefKey {\n         // Accessing the DefKey is ok, since it is part of DefPathHash.\n         self.tcx.untracked_resolutions.definitions.def_key(def_id)\n     }\n \n-    pub fn def_path_from_hir_id(&self, id: HirId) -> Option<DefPath> {\n+    pub fn def_path_from_hir_id(self, id: HirId) -> Option<DefPath> {\n         self.opt_local_def_id(id).map(|def_id| self.def_path(def_id))\n     }\n \n-    pub fn def_path(&self, def_id: LocalDefId) -> DefPath {\n+    pub fn def_path(self, def_id: LocalDefId) -> DefPath {\n         // Accessing the DefPath is ok, since it is part of DefPathHash.\n         self.tcx.untracked_resolutions.definitions.def_path(def_id)\n     }\n@@ -189,7 +189,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn local_def_id(&self, hir_id: HirId) -> LocalDefId {\n+    pub fn local_def_id(self, hir_id: HirId) -> LocalDefId {\n         self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n             bug!(\n                 \"local_def_id: no entry for `{:?}`, which has a map of `{:?}`\",\n@@ -200,7 +200,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn opt_local_def_id(&self, hir_id: HirId) -> Option<LocalDefId> {\n+    pub fn opt_local_def_id(self, hir_id: HirId) -> Option<LocalDefId> {\n         if hir_id.local_id == ItemLocalId::new(0) {\n             Some(hir_id.owner)\n         } else {\n@@ -214,18 +214,18 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n+    pub fn local_def_id_to_hir_id(self, def_id: LocalDefId) -> HirId {\n         self.tcx.local_def_id_to_hir_id(def_id)\n     }\n \n-    pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n+    pub fn iter_local_def_id(self) -> impl Iterator<Item = LocalDefId> + 'hir {\n         // Create a dependency to the crate to be sure we reexcute this when the amount of\n         // definitions change.\n         self.tcx.ensure().hir_crate(());\n         self.tcx.untracked_resolutions.definitions.iter_local_def_id()\n     }\n \n-    pub fn opt_def_kind(&self, local_def_id: LocalDefId) -> Option<DefKind> {\n+    pub fn opt_def_kind(self, local_def_id: LocalDefId) -> Option<DefKind> {\n         let hir_id = self.local_def_id_to_hir_id(local_def_id);\n         let def_kind = match self.find(hir_id)? {\n             Node::Item(item) => match item.kind {\n@@ -312,12 +312,12 @@ impl<'hir> Map<'hir> {\n         Some(def_kind)\n     }\n \n-    pub fn def_kind(&self, local_def_id: LocalDefId) -> DefKind {\n+    pub fn def_kind(self, local_def_id: LocalDefId) -> DefKind {\n         self.opt_def_kind(local_def_id)\n             .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", local_def_id))\n     }\n \n-    pub fn find_parent_node(&self, id: HirId) -> Option<HirId> {\n+    pub fn find_parent_node(self, id: HirId) -> Option<HirId> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n             Some(self.tcx.hir_owner_parent(id.owner))\n         } else {\n@@ -328,12 +328,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn get_parent_node(&self, hir_id: HirId) -> HirId {\n+    pub fn get_parent_node(self, hir_id: HirId) -> HirId {\n         self.find_parent_node(hir_id).unwrap()\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n-    pub fn find(&self, id: HirId) -> Option<Node<'hir>> {\n+    pub fn find(self, id: HirId) -> Option<Node<'hir>> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n             let owner = self.tcx.hir_owner(id.owner)?;\n             Some(owner.node.into())\n@@ -346,26 +346,26 @@ impl<'hir> Map<'hir> {\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     #[inline]\n-    pub fn find_by_def_id(&self, id: LocalDefId) -> Option<Node<'hir>> {\n+    pub fn find_by_def_id(self, id: LocalDefId) -> Option<Node<'hir>> {\n         self.find(self.local_def_id_to_hir_id(id))\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n-    pub fn get(&self, id: HirId) -> Node<'hir> {\n+    pub fn get(self, id: HirId) -> Node<'hir> {\n         self.find(id).unwrap_or_else(|| bug!(\"couldn't find hir id {} in the HIR map\", id))\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n     #[inline]\n-    pub fn get_by_def_id(&self, id: LocalDefId) -> Node<'hir> {\n+    pub fn get_by_def_id(self, id: LocalDefId) -> Node<'hir> {\n         self.find_by_def_id(id).unwrap_or_else(|| bug!(\"couldn't find {:?} in the HIR map\", id))\n     }\n \n-    pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n+    pub fn get_if_local(self, id: DefId) -> Option<Node<'hir>> {\n         id.as_local().and_then(|id| self.find(self.local_def_id_to_hir_id(id)))\n     }\n \n-    pub fn get_generics(&self, id: LocalDefId) -> Option<&'hir Generics<'hir>> {\n+    pub fn get_generics(self, id: LocalDefId) -> Option<&'hir Generics<'hir>> {\n         let node = self.tcx.hir_owner(id)?;\n         match node.node {\n             OwnerNode::ImplItem(impl_item) => Some(&impl_item.generics),\n@@ -386,43 +386,43 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n+    pub fn item(self, id: ItemId) -> &'hir Item<'hir> {\n         self.tcx.hir_owner(id.def_id).unwrap().node.expect_item()\n     }\n \n-    pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n+    pub fn trait_item(self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n         self.tcx.hir_owner(id.def_id).unwrap().node.expect_trait_item()\n     }\n \n-    pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n+    pub fn impl_item(self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n         self.tcx.hir_owner(id.def_id).unwrap().node.expect_impl_item()\n     }\n \n-    pub fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n+    pub fn foreign_item(self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n         self.tcx.hir_owner(id.def_id).unwrap().node.expect_foreign_item()\n     }\n \n-    pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n+    pub fn body(self, id: BodyId) -> &'hir Body<'hir> {\n         self.tcx.hir_owner_nodes(id.hir_id.owner).unwrap().bodies[&id.hir_id.local_id]\n     }\n \n-    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n+    pub fn fn_decl_by_hir_id(self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n         if let Some(node) = self.find(hir_id) {\n             fn_decl(node)\n         } else {\n             bug!(\"no node for hir_id `{}`\", hir_id)\n         }\n     }\n \n-    pub fn fn_sig_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnSig<'hir>> {\n+    pub fn fn_sig_by_hir_id(self, hir_id: HirId) -> Option<&'hir FnSig<'hir>> {\n         if let Some(node) = self.find(hir_id) {\n             fn_sig(node)\n         } else {\n             bug!(\"no node for hir_id `{}`\", hir_id)\n         }\n     }\n \n-    pub fn enclosing_body_owner(&self, hir_id: HirId) -> HirId {\n+    pub fn enclosing_body_owner(self, hir_id: HirId) -> HirId {\n         for (parent, _) in self.parent_iter(hir_id) {\n             if let Some(body) = self.maybe_body_owned_by(parent) {\n                 return self.body_owner(body);\n@@ -435,24 +435,24 @@ impl<'hir> Map<'hir> {\n     /// Returns the `HirId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n-    pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> HirId {\n+    pub fn body_owner(self, BodyId { hir_id }: BodyId) -> HirId {\n         let parent = self.get_parent_node(hir_id);\n         assert!(self.find(parent).map_or(false, |n| is_body_owner(n, hir_id)));\n         parent\n     }\n \n-    pub fn body_owner_def_id(&self, id: BodyId) -> LocalDefId {\n+    pub fn body_owner_def_id(self, id: BodyId) -> LocalDefId {\n         self.local_def_id(self.body_owner(id))\n     }\n \n     /// Given a `HirId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n-    pub fn maybe_body_owned_by(&self, hir_id: HirId) -> Option<BodyId> {\n+    pub fn maybe_body_owned_by(self, hir_id: HirId) -> Option<BodyId> {\n         self.find(hir_id).map(associated_body).flatten()\n     }\n \n     /// Given a body owner's id, returns the `BodyId` associated with it.\n-    pub fn body_owned_by(&self, id: HirId) -> BodyId {\n+    pub fn body_owned_by(self, id: HirId) -> BodyId {\n         self.maybe_body_owned_by(id).unwrap_or_else(|| {\n             span_bug!(\n                 self.span(id),\n@@ -462,7 +462,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn body_param_names(&self, id: BodyId) -> impl Iterator<Item = Ident> + 'hir {\n+    pub fn body_param_names(self, id: BodyId) -> impl Iterator<Item = Ident> + 'hir {\n         self.body(id).params.iter().map(|arg| match arg.pat.kind {\n             PatKind::Binding(_, _, ident, _) => ident,\n             _ => Ident::empty(),\n@@ -472,7 +472,7 @@ impl<'hir> Map<'hir> {\n     /// Returns the `BodyOwnerKind` of this `LocalDefId`.\n     ///\n     /// Panics if `LocalDefId` does not have an associated body.\n-    pub fn body_owner_kind(&self, id: HirId) -> BodyOwnerKind {\n+    pub fn body_owner_kind(self, id: HirId) -> BodyOwnerKind {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Const(..), .. })\n             | Node::TraitItem(&TraitItem { kind: TraitItemKind::Const(..), .. })\n@@ -495,7 +495,7 @@ impl<'hir> Map<'hir> {\n     /// This should only be used for determining the context of a body, a return\n     /// value of `Some` does not always suggest that the owner of the body is `const`,\n     /// just that it has to be checked as if it were.\n-    pub fn body_const_context(&self, did: LocalDefId) -> Option<ConstContext> {\n+    pub fn body_const_context(self, did: LocalDefId) -> Option<ConstContext> {\n         let hir_id = self.local_def_id_to_hir_id(did);\n         let ccx = match self.body_owner_kind(hir_id) {\n             BodyOwnerKind::Const => ConstContext::Const,\n@@ -549,7 +549,7 @@ impl<'hir> Map<'hir> {\n         });\n     }\n \n-    pub fn ty_param_owner(&self, id: HirId) -> LocalDefId {\n+    pub fn ty_param_owner(self, id: HirId) -> LocalDefId {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Trait(..) | ItemKind::TraitAlias(..), .. }) => {\n                 id.expect_owner()\n@@ -559,7 +559,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn ty_param_name(&self, id: HirId) -> Symbol {\n+    pub fn ty_param_name(self, id: HirId) -> Symbol {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Trait(..) | ItemKind::TraitAlias(..), .. }) => {\n                 kw::SelfUpper\n@@ -569,18 +569,18 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn trait_impls(&self, trait_did: DefId) -> &'hir [LocalDefId] {\n+    pub fn trait_impls(self, trait_did: DefId) -> &'hir [LocalDefId] {\n         self.tcx.all_local_trait_impls(()).get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n     /// Gets the attributes on the crate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n-    pub fn krate_attrs(&self) -> &'hir [ast::Attribute] {\n+    pub fn krate_attrs(self) -> &'hir [ast::Attribute] {\n         self.attrs(CRATE_HIR_ID)\n     }\n \n-    pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n+    pub fn get_module(self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = HirId::make_owner(module);\n         match self.tcx.hir_owner(module).map(|o| o.node) {\n             Some(OwnerNode::Item(&Item { span, kind: ItemKind::Mod(ref m), .. })) => {\n@@ -620,7 +620,7 @@ impl<'hir> Map<'hir> {\n     /// follows lexical scoping rules -- then you want a different\n     /// approach. You should override `visit_nested_item` in your\n     /// visitor and then call `intravisit::walk_crate` instead.\n-    pub fn visit_all_item_likes<V>(&self, visitor: &mut V)\n+    pub fn visit_all_item_likes<V>(self, visitor: &mut V)\n     where\n         V: itemlikevisit::ItemLikeVisitor<'hir>,\n     {\n@@ -637,7 +637,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// A parallel version of `visit_all_item_likes`.\n-    pub fn par_visit_all_item_likes<V>(&self, visitor: &V)\n+    pub fn par_visit_all_item_likes<V>(self, visitor: &V)\n     where\n         V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send,\n     {\n@@ -653,7 +653,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn visit_item_likes_in_module<V>(&self, module: LocalDefId, visitor: &mut V)\n+    pub fn visit_item_likes_in_module<V>(self, module: LocalDefId, visitor: &mut V)\n     where\n         V: ItemLikeVisitor<'hir>,\n     {\n@@ -676,7 +676,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn for_each_module(&self, f: impl Fn(LocalDefId)) {\n+    pub fn for_each_module(self, f: impl Fn(LocalDefId)) {\n         let mut queue = VecDeque::new();\n         queue.push_back(CRATE_DEF_ID);\n \n@@ -689,12 +689,12 @@ impl<'hir> Map<'hir> {\n \n     #[cfg(not(parallel_compiler))]\n     #[inline]\n-    pub fn par_for_each_module(&self, f: impl Fn(LocalDefId)) {\n+    pub fn par_for_each_module(self, f: impl Fn(LocalDefId)) {\n         self.for_each_module(f)\n     }\n \n     #[cfg(parallel_compiler)]\n-    pub fn par_for_each_module(&self, f: impl Fn(LocalDefId) + Sync) {\n+    pub fn par_for_each_module(self, f: impl Fn(LocalDefId) + Sync) {\n         use rustc_data_structures::sync::{par_iter, ParallelIterator};\n         par_iter_submodules(self.tcx, CRATE_DEF_ID, &f);\n \n@@ -721,7 +721,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Checks if the node is left-hand side of an assignment.\n-    pub fn is_lhs(&self, id: HirId) -> bool {\n+    pub fn is_lhs(self, id: HirId) -> bool {\n         match self.find(self.get_parent_node(id)) {\n             Some(Node::Expr(expr)) => match expr.kind {\n                 ExprKind::Assign(lhs, _rhs, _span) => lhs.hir_id == id,\n@@ -733,7 +733,7 @@ impl<'hir> Map<'hir> {\n \n     /// Whether the expression pointed at by `hir_id` belongs to a `const` evaluation context.\n     /// Used exclusively for diagnostics, to avoid suggestion function calls.\n-    pub fn is_inside_const_context(&self, hir_id: HirId) -> bool {\n+    pub fn is_inside_const_context(self, hir_id: HirId) -> bool {\n         self.body_const_context(self.local_def_id(self.enclosing_body_owner(hir_id))).is_some()\n     }\n \n@@ -759,7 +759,7 @@ impl<'hir> Map<'hir> {\n     ///     false\n     /// }\n     /// ```\n-    pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n+    pub fn get_return_block(self, id: HirId) -> Option<HirId> {\n         let mut iter = self.parent_iter(id).peekable();\n         let mut ignore_tail = false;\n         if let Some(node) = self.find(id) {\n@@ -799,7 +799,7 @@ impl<'hir> Map<'hir> {\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n-    pub fn get_parent_item(&self, hir_id: HirId) -> LocalDefId {\n+    pub fn get_parent_item(self, hir_id: HirId) -> LocalDefId {\n         if let Some((def_id, _node)) = self.parent_owner_iter(hir_id).next() {\n             def_id\n         } else {\n@@ -809,7 +809,7 @@ impl<'hir> Map<'hir> {\n \n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    pub(super) fn get_module_parent_node(&self, hir_id: HirId) -> LocalDefId {\n+    pub(super) fn get_module_parent_node(self, hir_id: HirId) -> LocalDefId {\n         for (def_id, node) in self.parent_owner_iter(hir_id) {\n             if let OwnerNode::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n                 return def_id;\n@@ -823,7 +823,7 @@ impl<'hir> Map<'hir> {\n     ///\n     /// Used by error reporting when there's a type error in an if or match arm caused by the\n     /// expression needing to be unit.\n-    pub fn get_if_cause(&self, hir_id: HirId) -> Option<&'hir Expr<'hir>> {\n+    pub fn get_if_cause(self, hir_id: HirId) -> Option<&'hir Expr<'hir>> {\n         for (_, node) in self.parent_iter(hir_id) {\n             match node {\n                 Node::Item(_)\n@@ -841,7 +841,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n-    pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n+    pub fn get_enclosing_scope(self, hir_id: HirId) -> Option<HirId> {\n         for (hir_id, node) in self.parent_iter(hir_id) {\n             if let Node::Item(Item {\n                 kind:\n@@ -868,7 +868,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Returns the defining scope for an opaque type definition.\n-    pub fn get_defining_scope(&self, id: HirId) -> HirId {\n+    pub fn get_defining_scope(self, id: HirId) -> HirId {\n         let mut scope = id;\n         loop {\n             scope = self.get_enclosing_scope(scope).unwrap_or(CRATE_HIR_ID);\n@@ -878,7 +878,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n+    pub fn get_foreign_abi(self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n         if let Some(node) = self.tcx.hir_owner(parent) {\n             if let OwnerNode::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }) = node.node\n@@ -892,35 +892,35 @@ impl<'hir> Map<'hir> {\n         )\n     }\n \n-    pub fn expect_item(&self, id: LocalDefId) -> &'hir Item<'hir> {\n+    pub fn expect_item(self, id: LocalDefId) -> &'hir Item<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::Item(item), .. }) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n-    pub fn expect_impl_item(&self, id: LocalDefId) -> &'hir ImplItem<'hir> {\n+    pub fn expect_impl_item(self, id: LocalDefId) -> &'hir ImplItem<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::ImplItem(item), .. }) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n-    pub fn expect_trait_item(&self, id: LocalDefId) -> &'hir TraitItem<'hir> {\n+    pub fn expect_trait_item(self, id: LocalDefId) -> &'hir TraitItem<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::TraitItem(item), .. }) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n-    pub fn expect_variant(&self, id: HirId) -> &'hir Variant<'hir> {\n+    pub fn expect_variant(self, id: HirId) -> &'hir Variant<'hir> {\n         match self.find(id) {\n             Some(Node::Variant(variant)) => variant,\n             _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n         }\n     }\n \n-    pub fn expect_foreign_item(&self, id: LocalDefId) -> &'hir ForeignItem<'hir> {\n+    pub fn expect_foreign_item(self, id: LocalDefId) -> &'hir ForeignItem<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::ForeignItem(item), .. }) => item,\n             _ => {\n@@ -929,14 +929,14 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_expr(&self, id: HirId) -> &'hir Expr<'hir> {\n+    pub fn expect_expr(self, id: HirId) -> &'hir Expr<'hir> {\n         match self.find(id) {\n             Some(Node::Expr(expr)) => expr,\n             _ => bug!(\"expected expr, found {}\", self.node_to_string(id)),\n         }\n     }\n \n-    pub fn opt_name(&self, id: HirId) -> Option<Symbol> {\n+    pub fn opt_name(self, id: HirId) -> Option<Symbol> {\n         Some(match self.get(id) {\n             Node::Item(i) => i.ident.name,\n             Node::ForeignItem(fi) => fi.ident.name,\n@@ -952,7 +952,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn name(&self, id: HirId) -> Symbol {\n+    pub fn name(self, id: HirId) -> Symbol {\n         match self.opt_name(id) {\n             Some(name) => name,\n             None => bug!(\"no name for {}\", self.node_to_string(id)),\n@@ -961,18 +961,18 @@ impl<'hir> Map<'hir> {\n \n     /// Given a node ID, gets a list of attributes associated with the AST\n     /// corresponding to the node-ID.\n-    pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n+    pub fn attrs(self, id: HirId) -> &'hir [ast::Attribute] {\n         self.tcx.hir_attrs(id.owner).get(id.local_id)\n     }\n \n     /// Gets the span of the definition of the specified HIR node.\n     /// This is used by `tcx.get_span`\n-    pub fn span(&self, hir_id: HirId) -> Span {\n+    pub fn span(self, hir_id: HirId) -> Span {\n         self.opt_span(hir_id)\n             .unwrap_or_else(|| bug!(\"hir::map::Map::span: id not in map: {:?}\", hir_id))\n     }\n \n-    pub fn opt_span(&self, hir_id: HirId) -> Option<Span> {\n+    pub fn opt_span(self, hir_id: HirId) -> Option<Span> {\n         let span = match self.find(hir_id)? {\n             Node::Param(param) => param.span,\n             Node::Item(item) => match &item.kind {\n@@ -1021,7 +1021,7 @@ impl<'hir> Map<'hir> {\n \n     /// Like `hir.span()`, but includes the body of function items\n     /// (instead of just the function header)\n-    pub fn span_with_body(&self, hir_id: HirId) -> Span {\n+    pub fn span_with_body(self, hir_id: HirId) -> Span {\n         match self.find(hir_id) {\n             Some(Node::TraitItem(item)) => item.span,\n             Some(Node::ImplItem(impl_item)) => impl_item.span,\n@@ -1031,11 +1031,11 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n+    pub fn span_if_local(self, id: DefId) -> Option<Span> {\n         id.as_local().and_then(|id| self.opt_span(self.local_def_id_to_hir_id(id)))\n     }\n \n-    pub fn res_span(&self, res: Res) -> Option<Span> {\n+    pub fn res_span(self, res: Res) -> Option<Span> {\n         match res {\n             Res::Err => None,\n             Res::Local(id) => Some(self.span(id)),\n@@ -1045,13 +1045,13 @@ impl<'hir> Map<'hir> {\n \n     /// Get a representation of this `id` for debugging purposes.\n     /// NOTE: Do NOT use this in diagnostics!\n-    pub fn node_to_string(&self, id: HirId) -> String {\n+    pub fn node_to_string(self, id: HirId) -> String {\n         hir_id_to_string(self, id)\n     }\n \n     /// Returns the HirId of `N` in `struct Foo<const N: usize = { ... }>` when\n     /// called with the HirId for the `{ ... }` anon const\n-    pub fn opt_const_param_default_param_hir_id(&self, anon_const: HirId) -> Option<HirId> {\n+    pub fn opt_const_param_default_param_hir_id(self, anon_const: HirId) -> Option<HirId> {\n         match self.get(self.get_parent_node(anon_const)) {\n             Node::GenericParam(GenericParam {\n                 hir_id: param_id,\n@@ -1065,27 +1065,27 @@ impl<'hir> Map<'hir> {\n \n impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n     fn find(&self, hir_id: HirId) -> Option<Node<'hir>> {\n-        self.find(hir_id)\n+        (*self).find(hir_id)\n     }\n \n     fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n-        self.body(id)\n+        (*self).body(id)\n     }\n \n     fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n-        self.item(id)\n+        (*self).item(id)\n     }\n \n     fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n-        self.trait_item(id)\n+        (*self).trait_item(id)\n     }\n \n     fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n-        self.impl_item(id)\n+        (*self).impl_item(id)\n     }\n \n     fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        self.foreign_item(id)\n+        (*self).foreign_item(id)\n     }\n }\n \n@@ -1154,7 +1154,7 @@ fn upstream_crates(tcx: TyCtxt<'_>) -> Vec<(StableCrateId, Svh)> {\n     upstream_crates\n }\n \n-fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n+fn hir_id_to_string(map: Map<'_>, id: HirId) -> String {\n     let id_str = format!(\" (hir_id={})\", id);\n \n     let path_str = || {"}, {"sha": "5a1378a3686b359146f22ddaf9053977209a9b93", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -41,9 +41,9 @@ pub enum LifetimeUseSet<'tcx> {\n }\n \n trait RegionExt {\n-    fn early(hir_map: &Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region);\n+    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region);\n \n-    fn late(index: u32, hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region);\n+    fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region);\n \n     fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region;\n \n@@ -59,7 +59,7 @@ trait RegionExt {\n }\n \n impl RegionExt for Region {\n-    fn early(hir_map: &Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region) {\n+    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region) {\n         let i = *index;\n         *index += 1;\n         let def_id = hir_map.local_def_id(param.hir_id);\n@@ -68,7 +68,7 @@ impl RegionExt for Region {\n         (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id.to_def_id(), origin))\n     }\n \n-    fn late(idx: u32, hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n+    fn late(idx: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n         let depth = ty::INNERMOST;\n         let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n@@ -817,7 +817,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                            Some(Region::early(self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                             non_lifetime_count += 1;\n@@ -888,7 +888,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n                     .enumerate()\n                     .map(|(late_bound_idx, param)| {\n-                        let pair = Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n+                        let pair = Region::late(late_bound_idx as u32, self.tcx.hir(), param);\n                         let r = late_region_as_bound_region(self.tcx, &pair.1);\n                         (pair, r)\n                     })\n@@ -1045,7 +1045,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 for param in generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            let (name, reg) = Region::early(&self.tcx.hir(), &mut index, &param);\n+                            let (name, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n                             let Region::EarlyBound(_, def_id, _) = reg else {\n                                 bug!();\n                             };\n@@ -1145,7 +1145,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                            Some(Region::early(self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                             non_lifetime_count += 1;\n@@ -1214,7 +1214,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                            Some(Region::early(self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => {\n                             non_lifetime_count += 1;\n@@ -1368,7 +1368,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 .enumerate()\n                                 .map(|(late_bound_idx, param)| {\n                                     let pair =\n-                                        Region::late(late_bound_idx as u32, &this.tcx.hir(), param);\n+                                        Region::late(late_bound_idx as u32, this.tcx.hir(), param);\n                                     let r = late_region_as_bound_region(this.tcx, &pair.1);\n                                     (pair, r)\n                                 })\n@@ -1463,11 +1463,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n-                let pair = Region::late(\n-                    initial_bound_vars + late_bound_idx as u32,\n-                    &self.tcx.hir(),\n-                    param,\n-                );\n+                let pair =\n+                    Region::late(initial_bound_vars + late_bound_idx as u32, self.tcx.hir(), param);\n                 let r = late_region_as_bound_region(self.tcx, &pair.1);\n                 lifetimes.insert(pair.0, pair.1);\n                 r\n@@ -2194,9 +2191,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     if self.map.late_bound.contains(&param.hir_id) {\n                         let late_bound_idx = named_late_bound_vars;\n                         named_late_bound_vars += 1;\n-                        Some(Region::late(late_bound_idx, &self.tcx.hir(), param))\n+                        Some(Region::late(late_bound_idx, self.tcx.hir(), param))\n                     } else {\n-                        Some(Region::early(&self.tcx.hir(), &mut next_early_index, param))\n+                        Some(Region::early(self.tcx.hir(), &mut next_early_index, param))\n                     }\n                 }\n                 GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n@@ -2216,7 +2213,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             })\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n-                let pair = Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n+                let pair = Region::late(late_bound_idx as u32, self.tcx.hir(), param);\n                 late_region_as_bound_region(self.tcx, &pair.1)\n             })\n             .collect();"}, {"sha": "79d55b297fd30b308cc0b4d7849db9a5009d6b5d", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -262,7 +262,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     ) {\n         debug!(\"process_method: {:?}:{}\", def_id, ident);\n \n-        let map = &self.tcx.hir();\n+        let map = self.tcx.hir();\n         let hir_id = map.local_def_id_to_hir_id(def_id);\n         self.nest_typeck_results(def_id, |v| {\n             if let Some(mut method_data) = v.save_ctxt.get_method_data(hir_id, ident, span) {\n@@ -361,7 +361,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         ty_params: &'tcx hir::Generics<'tcx>,\n         body: hir::BodyId,\n     ) {\n-        let map = &self.tcx.hir();\n+        let map = self.tcx.hir();\n         self.nest_typeck_results(item.def_id, |v| {\n             let body = map.body(body);\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n@@ -626,7 +626,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             }\n         }\n \n-        let map = &self.tcx.hir();\n+        let map = self.tcx.hir();\n         self.nest_typeck_results(item.def_id, |v| {\n             v.visit_ty(&impl_.self_ty);\n             if let Some(trait_ref) = &impl_.of_trait {\n@@ -716,7 +716,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         // walk generics and methods\n         self.process_generic_params(generics, &qualname, item.hir_id());\n         for method in methods {\n-            let map = &self.tcx.hir();\n+            let map = self.tcx.hir();\n             self.process_trait_item(map.trait_item(method.id), item.def_id.to_def_id())\n         }\n     }"}, {"sha": "4e7a34d5951113f7474180891ad2f2f58c9bfde0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// Used to set on_unimplemented's `ItemContext`\n     /// to be the enclosing (async) block/function/closure\n     fn describe_enclosure(&self, hir_id: hir::HirId) -> Option<&'static str> {\n-        let hir = &self.tcx.hir();\n+        let hir = self.tcx.hir();\n         let node = hir.find(hir_id)?;\n         match &node {\n             hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. }) => {"}, {"sha": "a17553b920f03971056c1532fb49b300e822d0e4", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -1663,7 +1663,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let table_owner = table.borrow().hir_owner;\n                 let generics = self.tcx.generics_of(table_owner.to_def_id());\n                 let type_param = generics.type_param(param, self.tcx);\n-                let hir = &self.tcx.hir();\n+                let hir = self.tcx.hir();\n                 if let Some(def_id) = type_param.def_id.as_local() {\n                     let id = hir.local_def_id_to_hir_id(def_id);\n                     // Get the `hir::Param` to verify whether it already has any bounds."}, {"sha": "428a866c1fe0732ba835584e26d0c55db4ca0ee4", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -1648,7 +1648,8 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n         match p.kind {\n             ProjectionKind::Field(..) => match ty.kind() {\n                 ty::Adt(def, _) if def.repr.packed() => {\n-                    match tcx.layout_of(param_env.and(p.ty)) {\n+                    // We erase regions here because they cannot be hashed\n+                    match tcx.layout_of(param_env.and(tcx.erase_regions(p.ty))) {\n                         Ok(layout) if layout.align.abi.bytes() == 1 => {\n                             // if the alignment is 1, the type can't be further\n                             // disaligned."}, {"sha": "471cd2e6ccb1cbf50e9dab3a85d6f7d83001200a", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -508,8 +508,9 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                               })\n                       }) =>\n                 {\n-                  // FIXME(associated_const_equality) when does this unwrap fail? I have no idea what case it would.\n-                  let trait_def_id = trait_ref.trait_def_id().unwrap();\n+                  let Some(trait_def_id) = trait_ref.trait_def_id() else {\n+                    return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");\n+                  };\n                   let assoc_items = tcx.associated_items(trait_def_id);\n                   let assoc_item = assoc_items.find_by_name_and_kind(\n                     tcx, binding.ident, ty::AssocKind::Const, def_id.to_def_id(),"}, {"sha": "8abf4244a38dd8c79c6525fdcdc671b3909f9c98", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -486,9 +486,9 @@ jobs:\n               NO_OVERFLOW_CHECKS: 1\n             <<: *job-macos-xl\n \n-          - name: x86_64-apple\n-            env:\n-              SCRIPT: ./x.py --stage 2 test\n+          - name: x86_64-apple-1\n+            env: &env-x86_64-apple-tests\n+              SCRIPT: ./x.py --stage 2 test --exclude src/test/ui --exclude src/test/rustdoc --exclude src/test/run-make-fulldeps\n               RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.8\n@@ -498,6 +498,12 @@ jobs:\n               NO_OVERFLOW_CHECKS: 1\n             <<: *job-macos-xl\n \n+          - name: x86_64-apple-2\n+            env:\n+              SCRIPT: ./x.py --stage 2 test src/test/ui src/test/rustdoc src/test/run-make-fulldeps\n+              <<: *env-x86_64-apple-tests\n+            <<: *job-macos-xl\n+\n           # This target only needs to support 11.0 and up as nothing else supports the hardware\n           - name: dist-aarch64-apple\n             env:"}, {"sha": "b0ce63a4ec1d5d7177feacb2d84198642d807ce5", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 6, "deletions": 97, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -1197,110 +1197,19 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     function execSearch(query, searchWords, filterCrates) {\n-        function getSmallest(arrays, positions, notDuplicates) {\n-            var start = null;\n-\n-            for (var it = 0, len = positions.length; it < len; ++it) {\n-                if (arrays[it].length > positions[it] &&\n-                    (start === null || start > arrays[it][positions[it]].lev) &&\n-                    !notDuplicates[arrays[it][positions[it]].fullPath]) {\n-                    start = arrays[it][positions[it]].lev;\n-                }\n-            }\n-            return start;\n-        }\n-\n-        function mergeArrays(arrays) {\n-            var ret = [];\n-            var positions = [];\n-            var notDuplicates = {};\n-\n-            for (var x = 0, arrays_len = arrays.length; x < arrays_len; ++x) {\n-                positions.push(0);\n-            }\n-            while (ret.length < MAX_RESULTS) {\n-                var smallest = getSmallest(arrays, positions, notDuplicates);\n-\n-                if (smallest === null) {\n-                    break;\n-                }\n-                for (x = 0; x < arrays_len && ret.length < MAX_RESULTS; ++x) {\n-                    if (arrays[x].length > positions[x] &&\n-                            arrays[x][positions[x]].lev === smallest &&\n-                            !notDuplicates[arrays[x][positions[x]].fullPath]) {\n-                        ret.push(arrays[x][positions[x]]);\n-                        notDuplicates[arrays[x][positions[x]].fullPath] = true;\n-                        positions[x] += 1;\n-                    }\n-                }\n-            }\n-            return ret;\n-        }\n-\n-        // Split search query by \",\", while respecting angle bracket nesting.\n-        // Since \"<\" is an alias for the Ord family of traits, it also uses\n-        // lookahead to distinguish \"<\"-as-less-than from \"<\"-as-angle-bracket.\n-        //\n-        // tokenizeQuery(\"A<B, C>, D\") == [\"A<B, C>\", \"D\"]\n-        // tokenizeQuery(\"A<B, C, D\") == [\"A<B\", \"C\", \"D\"]\n-        function tokenizeQuery(raw) {\n-            var i, matched;\n-            var l = raw.length;\n-            var depth = 0;\n-            var nextAngle = /(<|>)/g;\n-            var ret = [];\n-            var start = 0;\n-            for (i = 0; i < l; ++i) {\n-                switch (raw[i]) {\n-                    case \"<\":\n-                        nextAngle.lastIndex = i + 1;\n-                        matched = nextAngle.exec(raw);\n-                        if (matched && matched[1] === '>') {\n-                            depth += 1;\n-                        }\n-                        break;\n-                    case \">\":\n-                        if (depth > 0) {\n-                            depth -= 1;\n-                        }\n-                        break;\n-                    case \",\":\n-                        if (depth === 0) {\n-                            ret.push(raw.substring(start, i));\n-                            start = i + 1;\n-                        }\n-                        break;\n-                }\n-            }\n-            if (start !== i) {\n-                ret.push(raw.substring(start, i));\n-            }\n-            return ret;\n-        }\n-\n-        var queries = tokenizeQuery(query.raw);\n+        query = query.raw.trim();\n         var results = {\n             \"in_args\": [],\n             \"returned\": [],\n             \"others\": [],\n         };\n \n-        for (var i = 0, len = queries.length; i < len; ++i) {\n-            query = queries[i].trim();\n-            if (query.length !== 0) {\n-                var tmp = execQuery(getQuery(query), searchWords, filterCrates);\n+        if (query.length !== 0) {\n+            var tmp = execQuery(getQuery(query), searchWords, filterCrates);\n \n-                results.in_args.push(tmp.in_args);\n-                results.returned.push(tmp.returned);\n-                results.others.push(tmp.others);\n-            }\n-        }\n-        if (queries.length > 1) {\n-            return {\n-                \"in_args\": mergeArrays(results.in_args),\n-                \"returned\": mergeArrays(results.returned),\n-                \"others\": mergeArrays(results.others),\n-            };\n+            results.in_args.push(tmp.in_args);\n+            results.returned.push(tmp.returned);\n+            results.others.push(tmp.others);\n         }\n         return {\n             \"in_args\": results.in_args[0],"}, {"sha": "1c92d019606b673f056ecd613478c877eb6d8afc", "filename": "src/test/rustdoc-js-std/multi-query.js", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftest%2Frustdoc-js-std%2Fmulti-query.js", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftest%2Frustdoc-js-std%2Fmulti-query.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fmulti-query.js?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,10 +0,0 @@\n-const QUERY = 'str,u8';\n-\n-const EXPECTED = {\n-    'others': [\n-        { 'path': 'std', 'name': 'str', 'href': '../std/primitive.str.html' },\n-        { 'path': 'std', 'name': 'u8', 'href': '../std/primitive.u8.html'  },\n-        { 'path': 'std', 'name': 'str', 'href': '../std/str/index.html' },\n-        { 'path': 'std', 'name': 'u8', 'href': '../std/u8/index.html' },\n-    ],\n-};"}, {"sha": "5c7b065983e194f3af96f0c321e2355912882bf2", "filename": "src/test/ui/associated-consts/issue-93835.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-93835.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-93835.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-93835.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -0,0 +1,10 @@\n+fn e() {\n+    p:a<p:p<e=6>>\n+    //~^ ERROR comparison operators\n+    //~| ERROR cannot find value\n+    //~| ERROR associated const equality\n+    //~| ERROR associated const equality\n+    //~| ERROR associated type bounds\n+}\n+\n+fn main() {}"}, {"sha": "12df0e4381d15c552bae91681969d6f2007809d4", "filename": "src/test/ui/associated-consts/issue-93835.stderr", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-93835.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-93835.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-93835.stderr?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -0,0 +1,66 @@\n+error: comparison operators cannot be chained\n+  --> $DIR/issue-93835.rs:2:8\n+   |\n+LL | fn e() {\n+   |        - while parsing this struct\n+LL |     p:a<p:p<e=6>>\n+   |        ^        ^\n+   |\n+   = help: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n+\n+error[E0425]: cannot find value `p` in this scope\n+  --> $DIR/issue-93835.rs:2:5\n+   |\n+LL |     p:a<p:p<e=6>>\n+   |     ^ not found in this scope\n+   |\n+help: you might have meant to write a `struct` literal\n+   |\n+LL ~ fn e() { SomeStruct {\n+LL |     p:a<p:p<e=6>>\n+LL |\n+LL |\n+LL |\n+LL |\n+ ...\n+help: maybe you meant to write a path separator here\n+   |\n+LL |     p::a<p:p<e=6>>\n+   |      ~~\n+help: maybe you meant to write an assignment here\n+   |\n+LL |     let p:a<p:p<e=6>>\n+   |     ~~~~~\n+\n+error[E0658]: associated const equality is incomplete\n+  --> $DIR/issue-93835.rs:2:13\n+   |\n+LL |     p:a<p:p<e=6>>\n+   |             ^^^\n+   |\n+   = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n+   = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n+\n+error[E0658]: associated const equality is incomplete\n+  --> $DIR/issue-93835.rs:2:13\n+   |\n+LL |     p:a<p:p<e=6>>\n+   |             ^^^\n+   |\n+   = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n+   = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/issue-93835.rs:2:9\n+   |\n+LL |     p:a<p:p<e=6>>\n+   |         ^^^^^^^^\n+   |\n+   = note: see issue #52662 <https://github.com/rust-lang/rust/issues/52662> for more information\n+   = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0425, E0658.\n+For more information about an error, try `rustc --explain E0425`."}, {"sha": "8a62146abfc4e47e3a1d16cf91fc31e4bb0b3dfa", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78450d2d602b06d9b94349aaf8cece1a4acaf3a8/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=78450d2d602b06d9b94349aaf8cece1a4acaf3a8", "patch": "@@ -386,7 +386,10 @@ impl Builder {\n         // for users to install the additional component manually, if needed.\n         if self.versions.channel() == \"nightly\" {\n             self.extend_profile(\"complete\", &mut manifest.profiles, &[\"rustc-dev\"]);\n-            self.extend_profile(\"complete\", &mut manifest.profiles, &[\"rustc-docs\"]);\n+            // Do not include the rustc-docs component for now, as it causes\n+            // conflicts with the rust-docs component when installed. See\n+            // #75833.\n+            // self.extend_profile(\"complete\", &mut manifest.profiles, &[\"rustc-docs\"]);\n         }\n     }\n "}]}