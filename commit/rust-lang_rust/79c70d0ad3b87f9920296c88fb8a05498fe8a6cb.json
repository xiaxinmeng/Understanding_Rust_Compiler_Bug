{"sha": "79c70d0ad3b87f9920296c88fb8a05498fe8a6cb", "node_id": "C_kwDOAAsO6NoAKDc5YzcwZDBhZDNiODdmOTkyMDI5NmM4OGZiOGEwNTQ5OGZlOGE2Y2I", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-26T12:56:43Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-26T12:56:43Z"}, "message": "Simplify", "tree": {"sha": "049386acb8faa4c795171ee0c468ce833c2be92d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/049386acb8faa4c795171ee0c468ce833c2be92d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79c70d0ad3b87f9920296c88fb8a05498fe8a6cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79c70d0ad3b87f9920296c88fb8a05498fe8a6cb", "html_url": "https://github.com/rust-lang/rust/commit/79c70d0ad3b87f9920296c88fb8a05498fe8a6cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79c70d0ad3b87f9920296c88fb8a05498fe8a6cb/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a50f904effd780d93ca8b71f92eb0e7b7643924", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a50f904effd780d93ca8b71f92eb0e7b7643924", "html_url": "https://github.com/rust-lang/rust/commit/1a50f904effd780d93ca8b71f92eb0e7b7643924"}], "stats": {"total": 106, "additions": 46, "deletions": 60}, "files": [{"sha": "7d47dee2ed73d2a2d528d8fa63899ec52dfb39f2", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "modified", "additions": 46, "deletions": 60, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/79c70d0ad3b87f9920296c88fb8a05498fe8a6cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79c70d0ad3b87f9920296c88fb8a05498fe8a6cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=79c70d0ad3b87f9920296c88fb8a05498fe8a6cb", "patch": "@@ -100,31 +100,7 @@ pub(crate) fn inline_into_callers(acc: &mut Assists, ctx: &AssistContext) -> Opt\n                     ast::NameLike::NameRef(name_ref) => Some(name_ref),\n                     _ => None,\n                 });\n-                let call_infos = name_refs.filter_map(|name_ref| {\n-                    let parent = name_ref.syntax().parent()?;\n-                    if let Some(call) = ast::MethodCallExpr::cast(parent.clone()) {\n-                        let receiver = call.receiver()?;\n-                        let mut arguments = vec![receiver];\n-                        arguments.extend(call.arg_list()?.args());\n-                        Some(CallInfo {\n-                            generic_arg_list: call.generic_arg_list(),\n-                            node: CallExprNode::MethodCallExpr(call),\n-                            arguments,\n-                        })\n-                    } else if let Some(segment) = ast::PathSegment::cast(parent) {\n-                        let path = segment.syntax().parent().and_then(ast::Path::cast)?;\n-                        let path = path.syntax().parent().and_then(ast::PathExpr::cast)?;\n-                        let call = path.syntax().parent().and_then(ast::CallExpr::cast)?;\n-\n-                        Some(CallInfo {\n-                            arguments: call.arg_list()?.args().collect(),\n-                            node: CallExprNode::Call(call),\n-                            generic_arg_list: segment.generic_arg_list(),\n-                        })\n-                    } else {\n-                        None\n-                    }\n-                });\n+                let call_infos = name_refs.filter_map(CallInfo::from_name_ref);\n                 let replaced = call_infos\n                     .map(|call_info| {\n                         let replacement =\n@@ -178,43 +154,25 @@ pub(crate) fn inline_into_callers(acc: &mut Assists, ctx: &AssistContext) -> Opt\n // }\n // ```\n pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let (label, function, call_info) =\n-        if let Some(path_expr) = ctx.find_node_at_offset::<ast::PathExpr>() {\n-            // FIXME make applicable only on nameref\n-            let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n-            let path = path_expr.path()?;\n-\n+    let name_ref: ast::NameRef = ctx.find_node_at_offset()?;\n+    let call_info = CallInfo::from_name_ref(name_ref.clone())?;\n+    let (function, label) = match &call_info.node {\n+        CallExprNode::Call(call) => {\n+            let path = match call.expr()? {\n+                ast::Expr::PathExpr(path) => path.path(),\n+                _ => None,\n+            }?;\n             let function = match ctx.sema.resolve_path(&path)? {\n-                PathResolution::Def(hir::ModuleDef::Function(f))\n-                | PathResolution::AssocItem(hir::AssocItem::Function(f)) => f,\n+                PathResolution::Def(hir::ModuleDef::Function(f)) => f,\n+                PathResolution::AssocItem(hir::AssocItem::Function(f)) => f,\n                 _ => return None,\n             };\n-            (\n-                format!(\"Inline `{}`\", path),\n-                function,\n-                CallInfo {\n-                    arguments: call.arg_list()?.args().collect(),\n-                    node: CallExprNode::Call(call),\n-                    generic_arg_list: path.segment().and_then(|it| it.generic_arg_list()),\n-                },\n-            )\n-        } else {\n-            let name_ref: ast::NameRef = ctx.find_node_at_offset()?;\n-            let call = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n-            let receiver = call.receiver()?;\n-            let function = ctx.sema.resolve_method_call(&call)?;\n-            let mut arguments = vec![receiver];\n-            arguments.extend(call.arg_list()?.args());\n-            (\n-                format!(\"Inline `{}`\", name_ref),\n-                function,\n-                CallInfo {\n-                    generic_arg_list: call.generic_arg_list(),\n-                    node: CallExprNode::MethodCallExpr(call),\n-                    arguments,\n-                },\n-            )\n-        };\n+            (function, format!(\"Inline `{}`\", path))\n+        }\n+        CallExprNode::MethodCallExpr(call) => {\n+            (ctx.sema.resolve_method_call(call)?, format!(\"Inline `{}`\", name_ref))\n+        }\n+    };\n \n     let fn_source = function.source(ctx.db())?;\n     let fn_body = fn_source.value.body()?;\n@@ -273,6 +231,34 @@ struct CallInfo {\n     generic_arg_list: Option<ast::GenericArgList>,\n }\n \n+impl CallInfo {\n+    fn from_name_ref(name_ref: ast::NameRef) -> Option<CallInfo> {\n+        let parent = name_ref.syntax().parent()?;\n+        if let Some(call) = ast::MethodCallExpr::cast(parent.clone()) {\n+            let receiver = call.receiver()?;\n+            let mut arguments = vec![receiver];\n+            arguments.extend(call.arg_list()?.args());\n+            Some(CallInfo {\n+                generic_arg_list: call.generic_arg_list(),\n+                node: CallExprNode::MethodCallExpr(call),\n+                arguments,\n+            })\n+        } else if let Some(segment) = ast::PathSegment::cast(parent) {\n+            let path = segment.syntax().parent().and_then(ast::Path::cast)?;\n+            let path = path.syntax().parent().and_then(ast::PathExpr::cast)?;\n+            let call = path.syntax().parent().and_then(ast::CallExpr::cast)?;\n+\n+            Some(CallInfo {\n+                arguments: call.arg_list()?.args().collect(),\n+                node: CallExprNode::Call(call),\n+                generic_arg_list: segment.generic_arg_list(),\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n fn get_fn_params(\n     db: &dyn HirDatabase,\n     function: hir::Function,\n@@ -860,7 +846,7 @@ fn foo<T, const N: usize>() {\n fn bar<U, const M: usize>() {}\n \n fn main() {\n-    foo::<usize, {0}>$0();\n+    foo$0::<usize, {0}>();\n }\n \"#,\n             r#\""}]}