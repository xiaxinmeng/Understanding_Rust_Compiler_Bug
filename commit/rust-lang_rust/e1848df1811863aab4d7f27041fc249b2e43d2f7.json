{"sha": "e1848df1811863aab4d7f27041fc249b2e43d2f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxODQ4ZGYxODExODYzYWFiNGQ3ZjI3MDQxZmMyNDliMmU0M2QyZjc=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-05-17T19:51:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-05-17T19:51:22Z"}, "message": "Rollup merge of #50649 - nnethercote:tweak-nearest_common_ancestor, r=nikomatsakis\n\nTweak `nearest_common_ancestor()`.\n\n- Remove the \"no nearest common ancestor found\" case, because it's never\n  hit in practise. (This means `closure_is_enclosed_by` can also be\n  removed.)\n\n- Add a comment about why `SmallVec` is used for the \"seen\" structures.\n\n- Use `&Scope` instead of `Scope` to avoid some `map()` calls.\n\n- Use `any(p)` instead of `position(p).is_some()`.\n\nr? @nikomatsakis", "tree": {"sha": "9299a956ec71073b319bc389da711a55cea2472b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9299a956ec71073b319bc389da711a55cea2472b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1848df1811863aab4d7f27041fc249b2e43d2f7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJa/d06CRBK7hj4Ov3rIwAAdHIIAE0gzUvZEaEv5GeUC0kwILPg\nLP3IS9bfTrt+pL2WsF31Ngf/lzySo3hYuD3ozhxiUxbFjp811omVc8cFMXCmlc8I\nbpAyK74jn3MOokb5I6WM5YHnADqdyS4yGSC1TWHmhkuG2eR7ebvUX5wNH0GQz26J\nd7DW1iFqjAFO6CkVBrmH6HKD5cuCjPvcZF5/oNvF4SwBPjemjeWd0Dzl9kErQzJU\n+sb9nc6gNPyECgXiXb3HfDS/ej8WkDl4PObWjmNrJfH0aVLI9u6x9s68/jTpkGey\nLfGnbnpO1JGq1a9qfQsFd41r9+jxmvhdEzH5+EHxWLiiB3m3dRLBJ2X7kGHsbhI=\n=KFzl\n-----END PGP SIGNATURE-----\n", "payload": "tree 9299a956ec71073b319bc389da711a55cea2472b\nparent b3734bd78f566dc9c6ddf977fb290c847cccdc9c\nparent a91f6f745e18bd9f32dbcb29286f81efec41eff2\nauthor Mark Simulacrum <mark.simulacrum@gmail.com> 1526586682 -0600\ncommitter GitHub <noreply@github.com> 1526586682 -0600\n\nRollup merge of #50649 - nnethercote:tweak-nearest_common_ancestor, r=nikomatsakis\n\nTweak `nearest_common_ancestor()`.\n\n- Remove the \"no nearest common ancestor found\" case, because it's never\n  hit in practise. (This means `closure_is_enclosed_by` can also be\n  removed.)\n\n- Add a comment about why `SmallVec` is used for the \"seen\" structures.\n\n- Use `&Scope` instead of `Scope` to avoid some `map()` calls.\n\n- Use `any(p)` instead of `position(p).is_some()`.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1848df1811863aab4d7f27041fc249b2e43d2f7", "html_url": "https://github.com/rust-lang/rust/commit/e1848df1811863aab4d7f27041fc249b2e43d2f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1848df1811863aab4d7f27041fc249b2e43d2f7/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3734bd78f566dc9c6ddf977fb290c847cccdc9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3734bd78f566dc9c6ddf977fb290c847cccdc9c", "html_url": "https://github.com/rust-lang/rust/commit/b3734bd78f566dc9c6ddf977fb290c847cccdc9c"}, {"sha": "a91f6f745e18bd9f32dbcb29286f81efec41eff2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a91f6f745e18bd9f32dbcb29286f81efec41eff2", "html_url": "https://github.com/rust-lang/rust/commit/a91f6f745e18bd9f32dbcb29286f81efec41eff2"}], "stats": {"total": 78, "additions": 19, "deletions": 59}, "files": [{"sha": "42a08afe305a5acfff45baeb68996b42612414ce", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 19, "deletions": 59, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e1848df1811863aab4d7f27041fc249b2e43d2f7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1848df1811863aab4d7f27041fc249b2e43d2f7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e1848df1811863aab4d7f27041fc249b2e43d2f7", "patch": "@@ -542,18 +542,6 @@ impl<'tcx> ScopeTree {\n         assert!(previous.is_none());\n     }\n \n-    fn closure_is_enclosed_by(&self,\n-                              mut sub_closure: hir::ItemLocalId,\n-                              sup_closure: hir::ItemLocalId) -> bool {\n-        loop {\n-            if sub_closure == sup_closure { return true; }\n-            match self.closure_tree.get(&sub_closure) {\n-                Some(&s) => { sub_closure = s; }\n-                None => { return false; }\n-            }\n-        }\n-    }\n-\n     fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: Scope) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.item_local_id());\n@@ -688,65 +676,37 @@ impl<'tcx> ScopeTree {\n         // requires a hash table lookup, and we often have very long scope\n         // chains (10s or 100s of scopes) that only differ by a few elements at\n         // the start. So this algorithm is faster.\n-        let mut ma = Some(scope_a);\n-        let mut mb = Some(scope_b);\n-        let mut seen_a: SmallVec<[Scope; 32]> = SmallVec::new();\n-        let mut seen_b: SmallVec<[Scope; 32]> = SmallVec::new();\n+\n+        let mut ma = Some(&scope_a);\n+        let mut mb = Some(&scope_b);\n+\n+        // A HashSet<Scope> is a more obvious choice for these, but SmallVec is\n+        // faster because the set size is normally small so linear search is\n+        // as good or better than a hash table lookup, plus the size is usually\n+        // small enough to avoid a heap allocation.\n+        let mut seen_a: SmallVec<[&Scope; 32]> = SmallVec::new();\n+        let mut seen_b: SmallVec<[&Scope; 32]> = SmallVec::new();\n+\n         loop {\n             if let Some(a) = ma {\n-                if seen_b.iter().position(|s| *s == a).is_some() {\n-                    return a;\n+                if seen_b.iter().any(|s| *s == a) {\n+                    return *a;\n                 }\n                 seen_a.push(a);\n-                ma = self.parent_map.get(&a).map(|s| *s);\n+                ma = self.parent_map.get(&a);\n             }\n \n             if let Some(b) = mb {\n-                if seen_a.iter().position(|s| *s == b).is_some() {\n-                    return b;\n+                if seen_a.iter().any(|s| *s == b) {\n+                    return *b;\n                 }\n                 seen_b.push(b);\n-                mb = self.parent_map.get(&b).map(|s| *s);\n+                mb = self.parent_map.get(&b);\n             }\n \n             if ma.is_none() && mb.is_none() {\n-                break;\n-            }\n-        };\n-\n-        fn outermost_scope(parent_map: &FxHashMap<Scope, Scope>, scope: Scope) -> Scope {\n-            let mut scope = scope;\n-            loop {\n-               match parent_map.get(&scope) {\n-                   Some(&superscope) => scope = superscope,\n-                   None => break scope,\n-               }\n-            }\n-        }\n-\n-        // In this (rare) case, the two regions belong to completely different\n-        // functions. Compare those fn for lexical nesting. The reasoning\n-        // behind this is subtle. See the \"Modeling closures\" section of the\n-        // README in infer::region_constraints for more details.\n-        let a_root_scope = outermost_scope(&self.parent_map, scope_a);\n-        let b_root_scope = outermost_scope(&self.parent_map, scope_b);\n-        match (a_root_scope.data(), b_root_scope.data()) {\n-            (ScopeData::Destruction(a_root_id),\n-             ScopeData::Destruction(b_root_id)) => {\n-                if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n-                    // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n-                    scope_b\n-                } else if self.closure_is_enclosed_by(b_root_id, a_root_id) {\n-                    // `b` is enclosed by `a`, hence `a` is the ancestor of everything in `b`\n-                    scope_a\n-                } else {\n-                    // neither fn encloses the other\n-                    bug!()\n-                }\n-            }\n-            _ => {\n-                // root ids are always Node right now\n-                bug!()\n+                // No nearest common ancestor found.\n+                bug!();\n             }\n         }\n     }"}]}