{"sha": "0532f3e521293d4fa01518a238ea61665b11a3aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MzJmM2U1MjEyOTNkNGZhMDE1MThhMjM4ZWE2MTY2NWIxMWEzYWE=", "commit": {"author": {"name": "Krishna Sai Veera Reddy", "email": "veerareddy@email.arizona.edu", "date": "2020-02-17T07:48:10Z"}, "committer": {"name": "Krishna Sai Veera Reddy", "email": "veerareddy@email.arizona.edu", "date": "2020-02-17T08:05:50Z"}, "message": "Add lint to detect lossy float literals", "tree": {"sha": "88aaa16685974d5e39cf6e4a2307ae013a572a95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88aaa16685974d5e39cf6e4a2307ae013a572a95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0532f3e521293d4fa01518a238ea61665b11a3aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0532f3e521293d4fa01518a238ea61665b11a3aa", "html_url": "https://github.com/rust-lang/rust/commit/0532f3e521293d4fa01518a238ea61665b11a3aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0532f3e521293d4fa01518a238ea61665b11a3aa/comments", "author": {"login": "krishna-veerareddy", "id": 41484652, "node_id": "MDQ6VXNlcjQxNDg0NjUy", "avatar_url": "https://avatars.githubusercontent.com/u/41484652?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krishna-veerareddy", "html_url": "https://github.com/krishna-veerareddy", "followers_url": "https://api.github.com/users/krishna-veerareddy/followers", "following_url": "https://api.github.com/users/krishna-veerareddy/following{/other_user}", "gists_url": "https://api.github.com/users/krishna-veerareddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/krishna-veerareddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krishna-veerareddy/subscriptions", "organizations_url": "https://api.github.com/users/krishna-veerareddy/orgs", "repos_url": "https://api.github.com/users/krishna-veerareddy/repos", "events_url": "https://api.github.com/users/krishna-veerareddy/events{/privacy}", "received_events_url": "https://api.github.com/users/krishna-veerareddy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "krishna-veerareddy", "id": 41484652, "node_id": "MDQ6VXNlcjQxNDg0NjUy", "avatar_url": "https://avatars.githubusercontent.com/u/41484652?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krishna-veerareddy", "html_url": "https://github.com/krishna-veerareddy", "followers_url": "https://api.github.com/users/krishna-veerareddy/followers", "following_url": "https://api.github.com/users/krishna-veerareddy/following{/other_user}", "gists_url": "https://api.github.com/users/krishna-veerareddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/krishna-veerareddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krishna-veerareddy/subscriptions", "organizations_url": "https://api.github.com/users/krishna-veerareddy/orgs", "repos_url": "https://api.github.com/users/krishna-veerareddy/repos", "events_url": "https://api.github.com/users/krishna-veerareddy/events{/privacy}", "received_events_url": "https://api.github.com/users/krishna-veerareddy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b54be5f87373a95562565209a12420f1c70c0dc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b54be5f87373a95562565209a12420f1c70c0dc7", "html_url": "https://github.com/rust-lang/rust/commit/b54be5f87373a95562565209a12420f1c70c0dc7"}], "stats": {"total": 115, "additions": 52, "deletions": 63}, "files": [{"sha": "70b44dee6619f57a05c3137003fad09f8b36ad45", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 52, "deletions": 63, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0532f3e521293d4fa01518a238ea61665b11a3aa/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0532f3e521293d4fa01518a238ea61665b11a3aa/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=0532f3e521293d4fa01518a238ea61665b11a3aa", "patch": "@@ -6,17 +6,15 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::Symbol;\n-use std::f32;\n-use std::f64;\n-use std::fmt;\n+use std::{f32, f64, fmt};\n use syntax::ast::*;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for float literals with a precision greater\n-    /// than that supported by the underlying type\n+    /// than that supported by the underlying type.\n     ///\n-    /// **Why is this bad?** Rust will truncate the literal silently.\n+    /// **Why is this bad?** Rust will silently lose precision during conversion\n+    /// to a float.\n     ///\n     /// **Known problems:** None.\n     ///\n@@ -44,71 +42,62 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n             let ty = cx.tables.expr_ty(expr);\n             if let ty::Float(fty) = ty.kind;\n             if let hir::ExprKind::Lit(ref lit) = expr.kind;\n-            if let LitKind::Float(sym, _) = lit.node;\n-            if let Some(sugg) = Self::check(sym, fty);\n+            if let LitKind::Float(sym, lit_float_ty) = lit.node;\n             then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    EXCESSIVE_PRECISION,\n-                    expr.span,\n-                    \"float has excessive precision\",\n-                    \"consider changing the type or truncating it to\",\n-                    sugg,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-impl ExcessivePrecision {\n-    // None if nothing to lint, Some(suggestion) if lint necessary\n-    #[must_use]\n-    fn check(sym: Symbol, fty: FloatTy) -> Option<String> {\n-        let max = max_digits(fty);\n-        let sym_str = sym.as_str();\n-        if dot_zero_exclusion(&sym_str) {\n-            return None;\n-        }\n-        // Try to bail out if the float is for sure fine.\n-        // If its within the 2 decimal digits of being out of precision we\n-        // check if the parsed representation is the same as the string\n-        // since we'll need the truncated string anyway.\n-        let digits = count_digits(&sym_str);\n-        if digits > max as usize {\n-            let formatter = FloatFormat::new(&sym_str);\n-            let sr = match fty {\n-                FloatTy::F32 => sym_str.parse::<f32>().map(|f| formatter.format(f)),\n-                FloatTy::F64 => sym_str.parse::<f64>().map(|f| formatter.format(f)),\n-            };\n-            // We know this will parse since we are in LatePass\n-            let s = sr.unwrap();\n+                let sym_str = sym.as_str();\n+                let formatter = FloatFormat::new(&sym_str);\n+                // Try to bail out if the float is for sure fine.\n+                // If its within the 2 decimal digits of being out of precision we\n+                // check if the parsed representation is the same as the string\n+                // since we'll need the truncated string anyway.\n+                let digits = count_digits(&sym_str);\n+                let max = max_digits(fty);\n+                let float_str = match fty {\n+                    FloatTy::F32 => sym_str.parse::<f32>().map(|f| formatter.format(f)),\n+                    FloatTy::F64 => sym_str.parse::<f64>().map(|f| formatter.format(f)),\n+                }.unwrap();\n+                let type_suffix = match lit_float_ty {\n+                    LitFloatType::Suffixed(FloatTy::F32) => Some(\"f32\"),\n+                    LitFloatType::Suffixed(FloatTy::F64) => Some(\"f64\"),\n+                    _ => None\n+                };\n \n-            if sym_str == s {\n-                None\n-            } else {\n-                Some(format_numeric_literal(&s, None, true))\n+                if is_whole_number(&sym_str, fty) {\n+                    // Normalize the literal by stripping the fractional portion\n+                    if sym_str.split('.').next().unwrap() != float_str {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            EXCESSIVE_PRECISION,\n+                            expr.span,\n+                            \"literal cannot be represented as the underlying type without loss of precision\",\n+                            \"consider changing the type or replacing it with\",\n+                            format_numeric_literal(format!(\"{}.0\", float_str).as_str(), type_suffix, true),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                } else if digits > max as usize && sym_str != float_str {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        EXCESSIVE_PRECISION,\n+                        expr.span,\n+                        \"float has excessive precision\",\n+                        \"consider changing the type or truncating it to\",\n+                        format_numeric_literal(&float_str, type_suffix, true),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n             }\n-        } else {\n-            None\n         }\n     }\n }\n \n-/// Should we exclude the float because it has a `.0` or `.` suffix\n-/// Ex `1_000_000_000.0`\n-/// Ex `1_000_000_000.`\n+// Checks whether a float literal is a whole number\n #[must_use]\n-fn dot_zero_exclusion(s: &str) -> bool {\n-    s.split('.').nth(1).map_or(false, |after_dec| {\n-        let mut decpart = after_dec.chars().take_while(|c| *c != 'e' || *c != 'E');\n-\n-        match decpart.next() {\n-            Some('0') => decpart.count() == 0,\n-            Some(_) => false,\n-            None => true,\n-        }\n-    })\n+fn is_whole_number(sym_str: &str, fty: FloatTy) -> bool {\n+    match fty {\n+        FloatTy::F32 => sym_str.parse::<f32>().unwrap().fract() == 0.0,\n+        FloatTy::F64 => sym_str.parse::<f64>().unwrap().fract() == 0.0,\n+    }\n }\n \n #[must_use]"}]}