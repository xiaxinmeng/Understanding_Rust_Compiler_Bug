{"sha": "f2904674e8d0dbb6f7b02ae74aa81d930a0e8617", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyOTA0Njc0ZThkMGRiYjZmN2IwMmFlNzRhYTgxZDkzMGEwZTg2MTc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-29T22:20:03Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-30T01:31:09Z"}, "message": "syntax: cleanup method parsing.", "tree": {"sha": "16c9db0e629c89c87daf7a553b91212e5721c56a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16c9db0e629c89c87daf7a553b91212e5721c56a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2904674e8d0dbb6f7b02ae74aa81d930a0e8617", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2904674e8d0dbb6f7b02ae74aa81d930a0e8617", "html_url": "https://github.com/rust-lang/rust/commit/f2904674e8d0dbb6f7b02ae74aa81d930a0e8617", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2904674e8d0dbb6f7b02ae74aa81d930a0e8617/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8431f261dd160021b6af85916f161a13dd101ca0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8431f261dd160021b6af85916f161a13dd101ca0", "html_url": "https://github.com/rust-lang/rust/commit/8431f261dd160021b6af85916f161a13dd101ca0"}], "stats": {"total": 140, "additions": 66, "deletions": 74}, "files": [{"sha": "e8d7b7663ed5211a99390aa9826006f3acfaa589", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2904674e8d0dbb6f7b02ae74aa81d930a0e8617/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2904674e8d0dbb6f7b02ae74aa81d930a0e8617/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=f2904674e8d0dbb6f7b02ae74aa81d930a0e8617", "patch": "@@ -1180,7 +1180,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn expected_semi_or_open_brace(&mut self) -> PResult<'a, ast::TraitItem> {\n+    crate fn expected_semi_or_open_brace<T>(&mut self) -> PResult<'a, T> {\n         let token_str = self.this_token_descr();\n         let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\", token_str));\n         err.span_label(self.token.span, \"expected `;` or `{`\");"}, {"sha": "69fbb343ff3b6e0b99340c47ff1f8d3642a65d12", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 65, "deletions": 73, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/f2904674e8d0dbb6f7b02ae74aa81d930a0e8617/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2904674e8d0dbb6f7b02ae74aa81d930a0e8617/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=f2904674e8d0dbb6f7b02ae74aa81d930a0e8617", "patch": "@@ -7,7 +7,7 @@ use crate::ast::{\n     Item, ItemKind, ImplItem, TraitItem, TraitItemKind,\n     UseTree, UseTreeKind, PathSegment,\n     IsAuto, Constness, IsAsync, Unsafety, Defaultness,\n-    Visibility, VisibilityKind, Mutability, FnDecl, FnHeader,\n+    Visibility, VisibilityKind, Mutability, FnDecl, FnHeader, MethodSig, Block,\n     ForeignItem, ForeignItemKind,\n     Ty, TyKind, Generics, GenericBounds, TraitRef,\n     EnumDef, VariantData, StructField, AnonConst,\n@@ -848,29 +848,38 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a method or a macro invocation in a trait impl.\n-    fn parse_impl_method(&mut self, vis: &Visibility, at_end: &mut bool)\n-                         -> PResult<'a, (Ident, Vec<Attribute>, Generics, ast::ImplItemKind)> {\n+    fn parse_impl_method(\n+        &mut self,\n+        vis: &Visibility,\n+        at_end: &mut bool\n+    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ast::ImplItemKind)> {\n         // FIXME: code copied from `parse_macro_use_or_failure` -- use abstraction!\n         if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n             // method macro\n-            Ok((Ident::invalid(), vec![], Generics::default(),\n-                ast::ImplItemKind::Macro(mac)))\n+            Ok((Ident::invalid(), vec![], Generics::default(), ast::ImplItemKind::Macro(mac)))\n         } else {\n-            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n-            let ident = self.parse_ident()?;\n-            let mut generics = self.parse_generics()?;\n-            let decl = self.parse_fn_decl_with_self(|_| true)?;\n-            generics.where_clause = self.parse_where_clause()?;\n+            let (ident, sig, generics) = self.parse_method_sig(|_| true)?;\n             *at_end = true;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-            let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n-            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(\n-                ast::MethodSig { header, decl },\n-                body\n-            )))\n+            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(sig, body)))\n         }\n     }\n \n+    /// Parse the \"signature\", including the identifier, parameters, and generics\n+    /// of a method. The body is not parsed as that differs between `trait`s and `impl`s.\n+    fn parse_method_sig(\n+        &mut self,\n+        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n+    ) -> PResult<'a, (Ident, MethodSig, Generics)> {\n+        let header = self.parse_fn_front_matter()?;\n+        let ident = self.parse_ident()?;\n+        let mut generics = self.parse_generics()?;\n+        let decl = self.parse_fn_decl_with_self(is_name_required)?;\n+        let sig = MethodSig { header, decl };\n+        generics.where_clause = self.parse_where_clause()?;\n+        Ok((ident, sig, generics))\n+    }\n+\n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n     /// and including the `fn` keyword:\n     ///\n@@ -879,14 +888,7 @@ impl<'a> Parser<'a> {\n     /// - `const unsafe fn`\n     /// - `extern fn`\n     /// - etc.\n-    fn parse_fn_front_matter(&mut self)\n-        -> PResult<'a, (\n-            Spanned<Constness>,\n-            Unsafety,\n-            Spanned<IsAsync>,\n-            Abi\n-        )>\n-    {\n+    fn parse_fn_front_matter(&mut self) -> PResult<'a, FnHeader> {\n         let is_const_fn = self.eat_keyword(kw::Const);\n         let const_span = self.prev_span;\n         let asyncness = self.parse_asyncness();\n@@ -911,7 +913,7 @@ impl<'a> Parser<'a> {\n             // account for this.\n             if !self.expect_one_of(&[], &[])? { unreachable!() }\n         }\n-        Ok((constness, unsafety, asyncness, abi))\n+        Ok(FnHeader { constness, unsafety, asyncness, abi })\n     }\n \n     /// Parses `trait Foo { ... }` or `trait Foo = Bar;`.\n@@ -1025,59 +1027,12 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (Ident::invalid(), ast::TraitItemKind::Macro(mac), Generics::default())\n         } else {\n-            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n-\n-            let ident = self.parse_ident()?;\n-            let mut generics = self.parse_generics()?;\n-\n             // This is somewhat dubious; We don't want to allow\n             // argument names to be left off if there is a definition...\n             //\n             // We don't allow argument names to be left off in edition 2018.\n-            let decl = self.parse_fn_decl_with_self(|t| t.span.rust_2018())?;\n-            generics.where_clause = self.parse_where_clause()?;\n-\n-            let sig = ast::MethodSig {\n-                header: FnHeader {\n-                    unsafety,\n-                    constness,\n-                    abi,\n-                    asyncness,\n-                },\n-                decl,\n-            };\n-\n-            let body = match self.token.kind {\n-                token::Semi => {\n-                    self.bump();\n-                    *at_end = true;\n-                    debug!(\"parse_trait_methods(): parsing required method\");\n-                    None\n-                }\n-                token::OpenDelim(token::Brace) => {\n-                    debug!(\"parse_trait_methods(): parsing provided method\");\n-                    *at_end = true;\n-                    let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                    attrs.extend(inner_attrs.iter().cloned());\n-                    Some(body)\n-                }\n-                token::Interpolated(ref nt) => {\n-                    match **nt {\n-                        token::NtBlock(..) => {\n-                            *at_end = true;\n-                            let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                            attrs.extend(inner_attrs.iter().cloned());\n-                            Some(body)\n-                        }\n-                        _ => {\n-                            return self.expected_semi_or_open_brace();\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    return self.expected_semi_or_open_brace();\n-                }\n-            };\n+            let (ident, sig, generics) = self.parse_method_sig(|t| t.span.rust_2018())?;\n+            let body = self.parse_trait_method_body(at_end, &mut attrs)?;\n             (ident, ast::TraitItemKind::Method(sig, body), generics)\n         };\n \n@@ -1092,6 +1047,43 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    /// Parse the \"body\" of a method in a trait item definition.\n+    /// This can either be `;` when there's no body,\n+    /// or e.g. a block when the method is a provided one.\n+    fn parse_trait_method_body(\n+        &mut self,\n+        at_end: &mut bool,\n+        attrs: &mut Vec<Attribute>,\n+    ) -> PResult<'a, Option<P<Block>>> {\n+        Ok(match self.token.kind {\n+            token::Semi => {\n+                debug!(\"parse_trait_method_body(): parsing required method\");\n+                self.bump();\n+                *at_end = true;\n+                None\n+            }\n+            token::OpenDelim(token::Brace) => {\n+                debug!(\"parse_trait_method_body(): parsing provided method\");\n+                *at_end = true;\n+                let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                attrs.extend(inner_attrs.iter().cloned());\n+                Some(body)\n+            }\n+            token::Interpolated(ref nt) => {\n+                match **nt {\n+                    token::NtBlock(..) => {\n+                        *at_end = true;\n+                        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                        attrs.extend(inner_attrs.iter().cloned());\n+                        Some(body)\n+                    }\n+                    _ => return self.expected_semi_or_open_brace(),\n+                }\n+            }\n+            _ => return self.expected_semi_or_open_brace(),\n+        })\n+    }\n+\n     /// Parses the following grammar:\n     ///\n     ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]"}]}