{"sha": "ccf12853d869afa5c6a79baeabd2f2711116261d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZjEyODUzZDg2OWFmYTVjNmE3OWJhZWFiZDJmMjcxMTExNjI2MWQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-05-08T13:22:25Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-05-08T13:22:25Z"}, "message": "Regression tests for Issue 25199 (dropck and `Box<Trait + 'a>`).", "tree": {"sha": "9f75afb30709d580908605ff5cb5bfea04f2314e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f75afb30709d580908605ff5cb5bfea04f2314e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccf12853d869afa5c6a79baeabd2f2711116261d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccf12853d869afa5c6a79baeabd2f2711116261d", "html_url": "https://github.com/rust-lang/rust/commit/ccf12853d869afa5c6a79baeabd2f2711116261d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccf12853d869afa5c6a79baeabd2f2711116261d/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5b5a177588c0e8dfc6b9e79540bcbd1eeb9ef91", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b5a177588c0e8dfc6b9e79540bcbd1eeb9ef91", "html_url": "https://github.com/rust-lang/rust/commit/b5b5a177588c0e8dfc6b9e79540bcbd1eeb9ef91"}], "stats": {"total": 214, "additions": 214, "deletions": 0}, "files": [{"sha": "6e543d017f26045b10177d560f656d0531d499bc", "filename": "src/test/compile-fail/dropck_trait_cycle_checked.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/ccf12853d869afa5c6a79baeabd2f2711116261d/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf12853d869afa5c6a79baeabd2f2711116261d/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs?ref=ccf12853d869afa5c6a79baeabd2f2711116261d", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reject mixing cyclic structure and Drop when using trait\n+// objects to hide the the cross-references.\n+//\n+// (Compare against compile-fail/dropck_vec_cycle_checked.rs)\n+\n+use std::cell::Cell;\n+use id::Id;\n+\n+mod s {\n+    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+    pub fn next_count() -> usize {\n+        S_COUNT.fetch_add(1, Ordering::SeqCst) + 1\n+    }\n+}\n+\n+mod id {\n+    use s;\n+    #[derive(Debug)]\n+    pub struct Id {\n+        orig_count: usize,\n+        count: usize,\n+    }\n+\n+    impl Id {\n+        pub fn new() -> Id {\n+            let c = s::next_count();\n+            println!(\"building Id {}\", c);\n+            Id { orig_count: c, count: c }\n+        }\n+        pub fn count(&self) -> usize {\n+            println!(\"Id::count on {} returns {}\", self.orig_count, self.count);\n+            self.count\n+        }\n+    }\n+\n+    impl Drop for Id {\n+        fn drop(&mut self) {\n+            println!(\"dropping Id {}\", self.count);\n+            self.count = 0;\n+        }\n+    }\n+}\n+\n+trait HasId {\n+    fn count(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+struct CheckId<T:HasId> {\n+    v: T\n+}\n+\n+#[allow(non_snake_case)]\n+fn CheckId<T:HasId>(t: T) -> CheckId<T> { CheckId{ v: t } }\n+\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+trait Obj<'a> : HasId {\n+    fn set0(&self, b: &'a Box<Obj<'a>>);\n+    fn set1(&self, b: &'a Box<Obj<'a>>);\n+}\n+\n+struct O<'a> {\n+    id: Id,\n+    obj0: CheckId<Cell<Option<&'a Box<Obj<'a>>>>>,\n+    obj1: CheckId<Cell<Option<&'a Box<Obj<'a>>>>>,\n+}\n+\n+impl<'a> HasId for O<'a> {\n+    fn count(&self) -> usize { self.id.count() }\n+}\n+\n+impl<'a> O<'a> {\n+    fn new() -> Box<O<'a>> {\n+        Box::new(O {\n+            id: Id::new(),\n+            obj0: CheckId(Cell::new(None)),\n+            obj1: CheckId(Cell::new(None)),\n+        })\n+    }\n+}\n+\n+impl<'a> HasId for Cell<Option<&'a Box<Obj<'a>>>> {\n+    fn count(&self) -> usize {\n+        match self.get() {\n+            None => 1,\n+            Some(c) => c.count(),\n+        }\n+    }\n+}\n+\n+impl<'a> Obj<'a> for O<'a> {\n+    fn set0(&self, b: &'a Box<Obj<'a>>) {\n+        self.obj0.v.set(Some(b))\n+    }\n+    fn set1(&self, b: &'a Box<Obj<'a>>) {\n+        self.obj1.v.set(Some(b))\n+    }\n+}\n+\n+\n+fn f() {\n+    let (o1, o2, o3): (Box<Obj>, Box<Obj>, Box<Obj>) = (O::new(), O::new(), O::new());\n+    o1.set0(&o2); //~ ERROR `o2` does not live long enough\n+    o1.set1(&o3); //~ ERROR `o3` does not live long enough\n+    o2.set0(&o2); //~ ERROR `o2` does not live long enough\n+    o2.set1(&o3); //~ ERROR `o3` does not live long enough\n+    o3.set0(&o1); //~ ERROR `o1` does not live long enough\n+    o3.set1(&o2); //~ ERROR `o2` does not live long enough\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "74ea1ca2947f2a699ce80abe460b12067ad2ee84", "filename": "src/test/compile-fail/issue-25199.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ccf12853d869afa5c6a79baeabd2f2711116261d/src%2Ftest%2Fcompile-fail%2Fissue-25199.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf12853d869afa5c6a79baeabd2f2711116261d/src%2Ftest%2Fcompile-fail%2Fissue-25199.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25199.rs?ref=ccf12853d869afa5c6a79baeabd2f2711116261d", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue 25199: Check that one cannot hide a\n+// destructor's access to borrowed data behind a boxed trait object.\n+//\n+// Prior to fixing Issue 25199, this example was able to be compiled\n+// with rustc, and thus when you ran it, you would see the `Drop` impl\n+// for `Test` accessing state that had already been dropping (which is\n+// marked explicitly here with checking code within the `Drop` impl\n+// for `VecHolder`, but in the general case could just do unsound\n+// things like accessing memory that has been freed).\n+//\n+// Note that I would have liked to encode my go-to example of cyclic\n+// structure that accesses its neighbors in drop (and thus is\n+// fundamentally unsound) via this trick, but the closest I was able\n+// to come was dropck_trait_cycle_checked.rs, which is not quite as\n+// \"good\" as this regression test because the encoding of that example\n+// was forced to attach a lifetime to the trait definition itself\n+// (`trait Obj<'a>`) while *this* example is solely\n+\n+use std::cell::RefCell;\n+\n+trait Obj { }\n+\n+struct VecHolder {\n+    v: Vec<(bool, &'static str)>,\n+}\n+\n+impl Drop for VecHolder {\n+    fn drop(&mut self) {\n+        println!(\"Dropping Vec\");\n+        self.v[30].0 = false;\n+        self.v[30].1 = \"invalid access: VecHolder dropped already\";\n+    }\n+}\n+\n+struct Container<'a> {\n+    v: VecHolder,\n+    d: RefCell<Vec<Box<Obj+'a>>>,\n+}\n+\n+impl<'a> Container<'a> {\n+    fn new() -> Container<'a> {\n+        Container {\n+            d: RefCell::new(Vec::new()),\n+            v: VecHolder {\n+                v: vec![(true, \"valid\"); 100]\n+            }\n+        }\n+    }\n+\n+    fn store<T: Obj+'a>(&'a self, val: T) {\n+        self.d.borrow_mut().push(Box::new(val));\n+    }\n+}\n+\n+struct Test<'a> {\n+    test: &'a Container<'a>,\n+}\n+\n+impl<'a> Obj for Test<'a> { }\n+impl<'a> Drop for Test<'a> {\n+    fn drop(&mut self) {\n+        for e in &self.test.v.v {\n+            assert!(e.0, e.1);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let container = Container::new();\n+    let test = Test{test: &container}; //~ ERROR `container` does not live long enough\n+    println!(\"container.v[30]: {:?}\", container.v.v[30]);\n+    container.store(test); //~ ERROR `container` does not live long enough\n+}"}]}