{"sha": "76e5ed655c762b812c3da4749a55f1bb1b52c787", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZTVlZDY1NWM3NjJiODEyYzNkYTQ3NDlhNTVmMWJiMWI1MmM3ODc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-09T04:20:03Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-29T17:18:09Z"}, "message": "std: Return Result from RWLock/Mutex methods\n\nAll of the current std::sync primitives have poisoning enable which means that\nwhen a task fails inside of a write-access lock then all future attempts to\nacquire the lock will fail. This strategy ensures that stale data whose\ninvariants are possibly not upheld are never viewed by other tasks to help\npropagate unexpected panics (bugs in a program) among tasks.\n\nCurrently there is no way to test whether a mutex or rwlock is poisoned. One\nmethod would be to duplicate all the methods with a sister foo_catch function,\nfor example. This pattern is, however, against our [error guidelines][errors].\nAs a result, this commit exposes the fact that a task has failed internally\nthrough the return value of a `Result`.\n\n[errors]: https://github.com/rust-lang/rfcs/blob/master/text/0236-error-conventions.md#do-not-provide-both-result-and-fail-variants\n\nAll methods now return a `LockResult<T>` or a `TryLockResult<T>` which\ncommunicates whether the lock was poisoned or not. In a `LockResult`, both the\n`Ok` and `Err` variants contains the `MutexGuard<T>` that is being returned in\norder to allow access to the data if poisoning is not desired. This also means\nthat the lock is *always* held upon returning from `.lock()`.\n\nA new type, `PoisonError`, was added with one method `into_guard` which can\nconsume the assertion that a lock is poisoned to gain access to the underlying\ndata.\n\nThis is a breaking change because the signatures of these methods have changed,\noften incompatible ways. One major difference is that the `wait` methods on a\ncondition variable now consume the guard and return it in as a `LockResult` to\nindicate whether the lock was poisoned while waiting. Most code can be updated\nby calling `.unwrap()` on the return value of `.lock()`.\n\n[breaking-change]", "tree": {"sha": "3b80c601248892255f6b7d8241d76577959f0b53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b80c601248892255f6b7d8241d76577959f0b53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76e5ed655c762b812c3da4749a55f1bb1b52c787", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76e5ed655c762b812c3da4749a55f1bb1b52c787", "html_url": "https://github.com/rust-lang/rust/commit/76e5ed655c762b812c3da4749a55f1bb1b52c787", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76e5ed655c762b812c3da4749a55f1bb1b52c787/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dcc409fac18a258ba2a8af4345d9566ec8eebad", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dcc409fac18a258ba2a8af4345d9566ec8eebad", "html_url": "https://github.com/rust-lang/rust/commit/3dcc409fac18a258ba2a8af4345d9566ec8eebad"}], "stats": {"total": 916, "additions": 572, "deletions": 344}, "files": [{"sha": "a4e9d85bffdf8eb203e0de8dc2f0319b06e1b130", "filename": "src/doc/intro.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -483,7 +483,7 @@ fn main() {\n     for i in range(0u, 3u) {\n         let number = numbers.clone();\n         Thread::spawn(move || {\n-            let mut array = number.lock();\n+            let mut array = number.lock().unwrap();\n \n             (*array)[i] += 1;\n "}, {"sha": "13ee8c26075f3752ca31fdd07e11d4149af14183", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -58,7 +58,7 @@\n //!     let five = five.clone();\n //!\n //!     Thread::spawn(move || {\n-//!         let mut number = five.lock();\n+//!         let mut number = five.lock().unwrap();\n //!\n //!         *number += 1;\n //!\n@@ -722,7 +722,7 @@ mod tests {\n \n         let a = Arc::new(Cycle { x: Mutex::new(None) });\n         let b = a.clone().downgrade();\n-        *a.x.lock() = Some(b);\n+        *a.x.lock().unwrap() = Some(b);\n \n         // hopefully we don't double-free (or leak)...\n     }"}, {"sha": "99e11bf520205926d355518a2e2c17f1f01dd2ab", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -98,7 +98,7 @@ impl SharedEmitter {\n     }\n \n     fn dump(&mut self, handler: &Handler) {\n-        let mut buffer = self.buffer.lock();\n+        let mut buffer = self.buffer.lock().unwrap();\n         for diag in buffer.iter() {\n             match diag.code {\n                 Some(ref code) => {\n@@ -123,7 +123,7 @@ impl Emitter for SharedEmitter {\n             msg: &str, code: Option<&str>, lvl: Level) {\n         assert!(cmsp.is_none(), \"SharedEmitter doesn't support spans\");\n \n-        self.buffer.lock().push(Diagnostic {\n+        self.buffer.lock().unwrap().push(Diagnostic {\n             msg: msg.to_string(),\n             code: code.map(|s| s.to_string()),\n             lvl: lvl,\n@@ -915,7 +915,7 @@ fn run_work_multithreaded(sess: &Session,\n \n             loop {\n                 // Avoid holding the lock for the entire duration of the match.\n-                let maybe_work = work_items_arc.lock().pop();\n+                let maybe_work = work_items_arc.lock().unwrap().pop();\n                 match maybe_work {\n                     Some(work) => {\n                         execute_work_item(&cgcx, work);"}, {"sha": "3f23ec5dc665966b5aa499a0696e3f3e5d7f9e34", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -86,7 +86,7 @@ impl<T: Send> Packet<T> {\n     // and that could cause problems on platforms where it is\n     // represented by opaque data structure\n     pub fn postinit_lock(&self) -> MutexGuard<()> {\n-        self.select_lock.lock()\n+        self.select_lock.lock().unwrap()\n     }\n \n     // This function is used at the creation of a shared packet to inherit a\n@@ -435,7 +435,7 @@ impl<T: Send> Packet<T> {\n         // about looking at and dealing with to_wake. Once we have acquired the\n         // lock, we are guaranteed that inherit_blocker is done.\n         {\n-            let _guard = self.select_lock.lock();\n+            let _guard = self.select_lock.lock().unwrap();\n         }\n \n         // Like the stream implementation, we want to make sure that the count"}, {"sha": "82ec1814ebde70e05ac4f957d702d55e6b91c7b8", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -121,9 +121,9 @@ fn wait<'a, 'b, T: Send>(lock: &'a Mutex<State<T>>,\n         NoneBlocked => {}\n         _ => unreachable!(),\n     }\n-    drop(guard);        // unlock\n-    wait_token.wait();  // block\n-    lock.lock()         // relock\n+    drop(guard);         // unlock\n+    wait_token.wait();   // block\n+    lock.lock().unwrap() // relock\n }\n \n /// Wakes up a thread, dropping the lock at the correct time\n@@ -161,7 +161,7 @@ impl<T: Send> Packet<T> {\n     fn acquire_send_slot(&self) -> MutexGuard<State<T>> {\n         let mut node = Node { token: None, next: 0 as *mut Node };\n         loop {\n-            let mut guard = self.lock.lock();\n+            let mut guard = self.lock.lock().unwrap();\n             // are we ready to go?\n             if guard.disconnected || guard.buf.size() < guard.buf.cap() {\n                 return guard;\n@@ -202,7 +202,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> {\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n         if guard.disconnected {\n             Err(super::RecvDisconnected(t))\n         } else if guard.buf.size() == guard.buf.cap() {\n@@ -239,7 +239,7 @@ impl<T: Send> Packet<T> {\n     // When reading this, remember that there can only ever be one receiver at\n     // time.\n     pub fn recv(&self) -> Result<T, ()> {\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n \n         // Wait for the buffer to have something in it. No need for a while loop\n         // because we're the only receiver.\n@@ -258,7 +258,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn try_recv(&self) -> Result<T, Failure> {\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n \n         // Easy cases first\n         if guard.disconnected { return Err(Disconnected) }\n@@ -315,7 +315,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         // Not much to do other than wake up a receiver if one's there\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n         if guard.disconnected { return }\n         guard.disconnected = true;\n         match mem::replace(&mut guard.blocker, NoneBlocked) {\n@@ -326,7 +326,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn drop_port(&self) {\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n \n         if guard.disconnected { return }\n         guard.disconnected = true;\n@@ -372,14 +372,14 @@ impl<T: Send> Packet<T> {\n     // If Ok, the value is whether this port has data, if Err, then the upgraded\n     // port needs to be checked instead of this one.\n     pub fn can_recv(&self) -> bool {\n-        let guard = self.lock.lock();\n+        let guard = self.lock.lock().unwrap();\n         guard.disconnected || guard.buf.size() > 0\n     }\n \n     // Attempts to start selection on this port. This can either succeed or fail\n     // because there is data waiting.\n     pub fn start_selection(&self, token: SignalToken) -> StartResult {\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n         if guard.disconnected || guard.buf.size() > 0 {\n             Abort\n         } else {\n@@ -397,7 +397,7 @@ impl<T: Send> Packet<T> {\n     //\n     // The return value indicates whether there's data on this port.\n     pub fn abort_selection(&self) -> bool {\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n         match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => true,\n             BlockedSender(token) => {\n@@ -413,7 +413,7 @@ impl<T: Send> Packet<T> {\n impl<T: Send> Drop for Packet<T> {\n     fn drop(&mut self) {\n         assert_eq!(self.channels.load(atomic::SeqCst), 0);\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n         assert!(guard.queue.dequeue().is_none());\n         assert!(guard.canceled.is_none());\n     }"}, {"sha": "6c8e4eea40fdc442b5f799b2ceb140e83eedd500", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -146,7 +146,7 @@ impl StdinReader {\n     /// ```\n     pub fn lock<'a>(&'a mut self) -> StdinReaderGuard<'a> {\n         StdinReaderGuard {\n-            inner: self.inner.lock()\n+            inner: self.inner.lock().unwrap()\n         }\n     }\n \n@@ -155,53 +155,53 @@ impl StdinReader {\n     /// The read is performed atomically - concurrent read calls in other\n     /// threads will not interleave with this one.\n     pub fn read_line(&mut self) -> IoResult<String> {\n-        self.inner.lock().0.read_line()\n+        self.inner.lock().unwrap().0.read_line()\n     }\n \n     /// Like `Buffer::read_until`.\n     ///\n     /// The read is performed atomically - concurrent read calls in other\n     /// threads will not interleave with this one.\n     pub fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> {\n-        self.inner.lock().0.read_until(byte)\n+        self.inner.lock().unwrap().0.read_until(byte)\n     }\n \n     /// Like `Buffer::read_char`.\n     ///\n     /// The read is performed atomically - concurrent read calls in other\n     /// threads will not interleave with this one.\n     pub fn read_char(&mut self) -> IoResult<char> {\n-        self.inner.lock().0.read_char()\n+        self.inner.lock().unwrap().0.read_char()\n     }\n }\n \n impl Reader for StdinReader {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner.lock().0.read(buf)\n+        self.inner.lock().unwrap().0.read(buf)\n     }\n \n     // We have to manually delegate all of these because the default impls call\n     // read more than once and we don't want those calls to interleave (or\n     // incur the costs of repeated locking).\n \n     fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner.lock().0.read_at_least(min, buf)\n+        self.inner.lock().unwrap().0.read_at_least(min, buf)\n     }\n \n     fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n-        self.inner.lock().0.push_at_least(min, len, buf)\n+        self.inner.lock().unwrap().0.push_at_least(min, len, buf)\n     }\n \n     fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n-        self.inner.lock().0.read_to_end()\n+        self.inner.lock().unwrap().0.read_to_end()\n     }\n \n     fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n-        self.inner.lock().0.read_le_uint_n(nbytes)\n+        self.inner.lock().unwrap().0.read_le_uint_n(nbytes)\n     }\n \n     fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n-        self.inner.lock().0.read_be_uint_n(nbytes)\n+        self.inner.lock().unwrap().0.read_be_uint_n(nbytes)\n     }\n }\n "}, {"sha": "4091f0df39597d2b7fc683f257baf197574e4877", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -69,15 +69,15 @@ impl Barrier {\n     /// Barriers are re-usable after all threads have rendezvoused once, and can\n     /// be used continuously.\n     pub fn wait(&self) {\n-        let mut lock = self.lock.lock();\n+        let mut lock = self.lock.lock().unwrap();\n         let local_gen = lock.generation_id;\n         lock.count += 1;\n         if lock.count < self.num_threads {\n             // We need a while loop to guard against spurious wakeups.\n             // http://en.wikipedia.org/wiki/Spurious_wakeup\n             while local_gen == lock.generation_id &&\n                   lock.count < self.num_threads {\n-                self.cvar.wait(&lock);\n+                lock = self.cvar.wait(lock).unwrap();\n             }\n         } else {\n             lock.count = 0;"}, {"sha": "3e17d8b6be1ff2228ce24f61346c369fb1c151f6", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 58, "deletions": 41, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -11,7 +11,8 @@\n use prelude::*;\n \n use sync::atomic::{mod, AtomicUint};\n-use sync::{mutex, StaticMutexGuard};\n+use sync::poison::{mod, LockResult};\n+use sync::CondvarGuard;\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n use time::Duration;\n@@ -44,16 +45,16 @@ use time::Duration;\n /// // Inside of our lock, spawn a new thread, and then wait for it to start\n /// Thread::spawn(move|| {\n ///     let &(ref lock, ref cvar) = &*pair2;\n-///     let mut started = lock.lock();\n+///     let mut started = lock.lock().unwrap();\n ///     *started = true;\n ///     cvar.notify_one();\n /// }).detach();\n ///\n /// // wait for the thread to start up\n /// let &(ref lock, ref cvar) = &*pair;\n-/// let started = lock.lock();\n+/// let mut started = lock.lock().unwrap();\n /// while !*started {\n-///     cvar.wait(&started);\n+///     started = cvar.wait(started).unwrap();\n /// }\n /// ```\n pub struct Condvar { inner: Box<StaticCondvar> }\n@@ -92,9 +93,9 @@ pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n ///\n /// Note that this trait should likely not be implemented manually unless you\n /// really know what you're doing.\n-pub trait AsMutexGuard {\n+pub trait AsGuard {\n     #[allow(missing_docs)]\n-    unsafe fn as_mutex_guard(&self) -> &StaticMutexGuard;\n+    fn as_guard(&self) -> CondvarGuard;\n }\n \n impl Condvar {\n@@ -113,8 +114,8 @@ impl Condvar {\n     /// notification.\n     ///\n     /// This function will atomically unlock the mutex specified (represented by\n-    /// `guard`) and block the current thread. This means that any calls to\n-    /// `notify_*()` which happen logically after the mutex is unlocked are\n+    /// `mutex_guard`) and block the current thread. This means that any calls\n+    /// to `notify_*()` which happen logically after the mutex is unlocked are\n     /// candidates to wake this thread up. When this function call returns, the\n     /// lock specified will have been re-acquired.\n     ///\n@@ -123,13 +124,20 @@ impl Condvar {\n     /// the predicate must always be checked each time this function returns to\n     /// protect against spurious wakeups.\n     ///\n+    /// # Failure\n+    ///\n+    /// This function will return an error if the mutex being waited on is\n+    /// poisoned when this thread re-acquires the lock. For more information,\n+    /// see information about poisoning on the Mutex type.\n+    ///\n     /// # Panics\n     ///\n     /// This function will `panic!()` if it is used with more than one mutex\n     /// over time. Each condition variable is dynamically bound to exactly one\n     /// mutex to ensure defined behavior across platforms. If this functionality\n     /// is not desired, then unsafe primitives in `sys` are provided.\n-    pub fn wait<T: AsMutexGuard>(&self, mutex_guard: &T) {\n+    pub fn wait<T: AsGuard>(&self, mutex_guard: T)\n+                            -> LockResult<T> {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n             me.inner.wait(mutex_guard)\n@@ -156,8 +164,8 @@ impl Condvar {\n     // provide. There are also additional concerns about the unix-specific\n     // implementation which may need to be addressed.\n     #[allow(dead_code)]\n-    fn wait_timeout<T: AsMutexGuard>(&self, mutex_guard: &T,\n-                                     dur: Duration) -> bool {\n+    fn wait_timeout<T: AsGuard>(&self, mutex_guard: T, dur: Duration)\n+                                -> LockResult<(T, bool)> {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n             me.inner.wait_timeout(mutex_guard, dur)\n@@ -194,13 +202,17 @@ impl StaticCondvar {\n     /// notification.\n     ///\n     /// See `Condvar::wait`.\n-    pub fn wait<T: AsMutexGuard>(&'static self, mutex_guard: &T) {\n-        unsafe {\n-            let lock = mutex_guard.as_mutex_guard();\n-            let sys = mutex::guard_lock(lock);\n-            self.verify(sys);\n-            self.inner.wait(sys);\n-            (*mutex::guard_poison(lock)).check(\"mutex\");\n+    pub fn wait<T: AsGuard>(&'static self, mutex_guard: T) -> LockResult<T> {\n+        let poisoned = unsafe {\n+            let cvar_guard = mutex_guard.as_guard();\n+            self.verify(cvar_guard.lock);\n+            self.inner.wait(cvar_guard.lock);\n+            cvar_guard.poisoned.get()\n+        };\n+        if poisoned {\n+            Err(poison::new_poison_error(mutex_guard))\n+        } else {\n+            Ok(mutex_guard)\n         }\n     }\n \n@@ -209,15 +221,18 @@ impl StaticCondvar {\n     ///\n     /// See `Condvar::wait_timeout`.\n     #[allow(dead_code)] // may want to stabilize this later, see wait_timeout above\n-    fn wait_timeout<T: AsMutexGuard>(&'static self, mutex_guard: &T,\n-                                     dur: Duration) -> bool {\n-        unsafe {\n-            let lock = mutex_guard.as_mutex_guard();\n-            let sys = mutex::guard_lock(lock);\n-            self.verify(sys);\n-            let ret = self.inner.wait_timeout(sys, dur);\n-            (*mutex::guard_poison(lock)).check(\"mutex\");\n-            return ret;\n+    fn wait_timeout<T: AsGuard>(&'static self, mutex_guard: T, dur: Duration)\n+                                -> LockResult<(T, bool)> {\n+        let (poisoned, success) = unsafe {\n+            let cvar_guard = mutex_guard.as_guard();\n+            self.verify(cvar_guard.lock);\n+            let success = self.inner.wait_timeout(cvar_guard.lock, dur);\n+            (cvar_guard.poisoned.get(), success)\n+        };\n+        if poisoned {\n+            Err(poison::new_poison_error((mutex_guard, success)))\n+        } else {\n+            Ok((mutex_guard, success))\n         }\n     }\n \n@@ -288,12 +303,12 @@ mod tests {\n         static C: StaticCondvar = CONDVAR_INIT;\n         static M: StaticMutex = MUTEX_INIT;\n \n-        let g = M.lock();\n+        let g = M.lock().unwrap();\n         spawn(move|| {\n-            let _g = M.lock();\n+            let _g = M.lock().unwrap();\n             C.notify_one();\n         });\n-        C.wait(&g);\n+        let g = C.wait(g).unwrap();\n         drop(g);\n         unsafe { C.destroy(); M.destroy(); }\n     }\n@@ -309,13 +324,13 @@ mod tests {\n             let tx = tx.clone();\n             spawn(move|| {\n                 let &(ref lock, ref cond) = &*data;\n-                let mut cnt = lock.lock();\n+                let mut cnt = lock.lock().unwrap();\n                 *cnt += 1;\n                 if *cnt == N {\n                     tx.send(());\n                 }\n                 while *cnt != 0 {\n-                    cond.wait(&cnt);\n+                    cnt = cond.wait(cnt).unwrap();\n                 }\n                 tx.send(());\n             });\n@@ -324,7 +339,7 @@ mod tests {\n \n         let &(ref lock, ref cond) = &*data;\n         rx.recv();\n-        let mut cnt = lock.lock();\n+        let mut cnt = lock.lock().unwrap();\n         *cnt = 0;\n         cond.notify_all();\n         drop(cnt);\n@@ -339,13 +354,15 @@ mod tests {\n         static C: StaticCondvar = CONDVAR_INIT;\n         static M: StaticMutex = MUTEX_INIT;\n \n-        let g = M.lock();\n-        assert!(!C.wait_timeout(&g, Duration::nanoseconds(1000)));\n+        let g = M.lock().unwrap();\n+        let (g, success) = C.wait_timeout(g, Duration::nanoseconds(1000)).unwrap();\n+        assert!(!success);\n         spawn(move|| {\n-            let _g = M.lock();\n+            let _g = M.lock().unwrap();\n             C.notify_one();\n         });\n-        assert!(C.wait_timeout(&g, Duration::days(1)));\n+        let (g, success) = C.wait_timeout(g, Duration::days(1)).unwrap();\n+        assert!(success);\n         drop(g);\n         unsafe { C.destroy(); M.destroy(); }\n     }\n@@ -357,15 +374,15 @@ mod tests {\n         static M2: StaticMutex = MUTEX_INIT;\n         static C: StaticCondvar = CONDVAR_INIT;\n \n-        let g = M1.lock();\n+        let mut g = M1.lock().unwrap();\n         spawn(move|| {\n-            let _g = M1.lock();\n+            let _g = M1.lock().unwrap();\n             C.notify_one();\n         });\n-        C.wait(&g);\n+        g = C.wait(g).unwrap();\n         drop(g);\n \n-        C.wait(&M2.lock());\n+        C.wait(M2.lock().unwrap()).unwrap();\n \n     }\n }"}, {"sha": "3f95eac509082b769a6e590b8935b51721046d0e", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -17,16 +17,20 @@\n \n #![experimental]\n \n+use sys_common::mutex as sys_mutex;\n+\n pub use alloc::arc::{Arc, Weak};\n \n-pub use self::mutex::{Mutex, MutexGuard, StaticMutex, StaticMutexGuard, MUTEX_INIT};\n+pub use self::mutex::{Mutex, MutexGuard, StaticMutex, StaticMutexGuard};\n+pub use self::mutex::MUTEX_INIT;\n pub use self::rwlock::{RWLock, StaticRWLock, RWLOCK_INIT};\n pub use self::rwlock::{RWLockReadGuard, RWLockWriteGuard};\n pub use self::rwlock::{StaticRWLockReadGuard, StaticRWLockWriteGuard};\n-pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT, AsMutexGuard};\n+pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT, AsGuard};\n pub use self::once::{Once, ONCE_INIT};\n pub use self::semaphore::{Semaphore, SemaphoreGuard};\n pub use self::barrier::Barrier;\n+pub use self::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n \n pub use self::future::Future;\n pub use self::task_pool::TaskPool;\n@@ -41,3 +45,10 @@ mod poison;\n mod rwlock;\n mod semaphore;\n mod task_pool;\n+\n+/// Structure returned by `AsGuard` to wait on a condition variable.\n+// NB: defined here to all modules have access to these private fields.\n+pub struct CondvarGuard<'a> {\n+    lock: &'a sys_mutex::Mutex,\n+    poisoned: &'a poison::Flag,\n+}"}, {"sha": "621d7274062f9250846ecd69a54c73f71c46bf41", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 162, "deletions": 81, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -12,7 +12,8 @@ use prelude::*;\n \n use cell::UnsafeCell;\n use kinds::marker;\n-use sync::{poison, AsMutexGuard};\n+use sync::{AsGuard, CondvarGuard};\n+use sync::poison::{mod, TryLockError, TryLockResult, LockResult};\n use sys_common::mutex as sys;\n \n /// A mutual exclusion primitive useful for protecting shared data\n@@ -26,12 +27,23 @@ use sys_common::mutex as sys;\n ///\n /// # Poisoning\n ///\n-/// In order to prevent access to otherwise invalid data, each mutex will\n-/// propagate any panics which occur while the lock is held. Once a thread has\n-/// panicked while holding the lock, then all other threads will immediately\n-/// panic as well once they hold the lock.\n+/// The mutexes in this module implement a strategy called \"poisoning\" where a\n+/// mutex is considered poisoned whenever a thread panics while holding the\n+/// lock. Once a mutex is poisoned, all other tasks are unable to access the\n+/// data by default as it is likely tainted (some invariant is not being\n+/// upheld).\n ///\n-/// # Example\n+/// For a mutex, this means that the `lock` and `try_lock` methods return a\n+/// `Result` which indicates whether a mutex has been poisoned or not. Most\n+/// usage of a mutex will simply `unwrap()` these results, propagating panics\n+/// among threads to ensure that a possibly invalid invariant is not witnessed.\n+///\n+/// A poisoned mutex, however, does not prevent all access to the underlying\n+/// data. The `PoisonError` type has an `into_guard` method which will return\n+/// the guard that would have otherwise been returned on a successful lock. This\n+/// allows access to the data, despite the lock being poisoned.\n+///\n+/// # Examples\n ///\n /// ```rust\n /// use std::sync::{Arc, Mutex};\n@@ -48,11 +60,14 @@ use sys_common::mutex as sys;\n /// let (tx, rx) = channel();\n /// for _ in range(0u, 10) {\n ///     let (data, tx) = (data.clone(), tx.clone());\n-///     Thread::spawn(move|| {\n+///     Thread::spawn(move || {\n ///         // The shared static can only be accessed once the lock is held.\n ///         // Our non-atomic increment is safe because we're the only thread\n ///         // which can access the shared state when the lock is held.\n-///         let mut data = data.lock();\n+///         //\n+///         // We unwrap() the return value to assert that we are not expecting\n+///         // tasks to ever fail while holding the lock.\n+///         let mut data = data.lock().unwrap();\n ///         *data += 1;\n ///         if *data == N {\n ///             tx.send(());\n@@ -63,6 +78,35 @@ use sys_common::mutex as sys;\n ///\n /// rx.recv();\n /// ```\n+///\n+/// To recover from a poisoned mutex:\n+///\n+/// ```rust\n+/// use std::sync::{Arc, Mutex};\n+/// use std::thread::Thread;\n+///\n+/// let lock = Arc::new(Mutex::new(0u));\n+/// let lock2 = lock.clone();\n+///\n+/// let _ = Thread::spawn(move || -> () {\n+///     // This thread will acquire the mutex first, unwrapping the result of\n+///     // `lock` because the lock has not been poisoned.\n+///     let _lock = lock2.lock().unwrap();\n+///\n+///     // This panic while holding the lock (`_guard` is in scope) will poison\n+///     // the mutex.\n+///     panic!();\n+/// }).join();\n+///\n+/// // The lock is poisoned by this point, but the returned result can be\n+/// // pattern matched on to return the underlying guard on both branches.\n+/// let mut guard = match lock.lock() {\n+///     Ok(guard) => guard,\n+///     Err(poisoned) => poisoned.into_guard(),\n+/// };\n+///\n+/// *guard += 1;\n+/// ```\n pub struct Mutex<T> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n     // itself. Once a native mutex has been used once, its address can never\n@@ -93,14 +137,14 @@ unsafe impl<T:Send> Sync for Mutex<T> { }\n /// static LOCK: StaticMutex = MUTEX_INIT;\n ///\n /// {\n-///     let _g = LOCK.lock();\n+///     let _g = LOCK.lock().unwrap();\n ///     // do some productive work\n /// }\n /// // lock is unlocked here.\n /// ```\n pub struct StaticMutex {\n     lock: sys::Mutex,\n-    poison: UnsafeCell<poison::Flag>,\n+    poison: poison::Flag,\n }\n \n unsafe impl Sync for StaticMutex {}\n@@ -114,24 +158,27 @@ unsafe impl Sync for StaticMutex {}\n pub struct MutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n-    __lock: &'a Mutex<T>,\n-    __guard: StaticMutexGuard,\n+    __inner: Guard<'a, Mutex<T>>,\n }\n \n /// An RAII implementation of a \"scoped lock\" of a static mutex. When this\n /// structure is dropped (falls out of scope), the lock will be unlocked.\n #[must_use]\n pub struct StaticMutexGuard {\n-    lock: &'static sys::Mutex,\n-    marker: marker::NoSend,\n-    poison: poison::Guard<'static>,\n+    inner: Guard<'static, StaticMutex>,\n+}\n+\n+struct Guard<'a, T: 'a> {\n+    inner: &'a T,\n+    poison: poison::Guard,\n+    marker: marker::NoSend, // even if 'a is static, this cannot be sent\n }\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n pub const MUTEX_INIT: StaticMutex = StaticMutex {\n     lock: sys::MUTEX_INIT,\n-    poison: UnsafeCell { value: poison::Flag { failed: false } },\n+    poison: poison::FLAG_INIT,\n };\n \n impl<T: Send> Mutex<T> {\n@@ -150,15 +197,13 @@ impl<T: Send> Mutex<T> {\n     /// held. An RAII guard is returned to allow scoped unlock of the lock. When\n     /// the guard goes out of scope, the mutex will be unlocked.\n     ///\n-    /// # Panics\n+    /// # Failure\n     ///\n     /// If another user of this mutex panicked while holding the mutex, then\n-    /// this call will immediately panic once the mutex is acquired.\n-    pub fn lock(&self) -> MutexGuard<T> {\n-        unsafe {\n-            let lock: &'static StaticMutex = &*(&*self.inner as *const _);\n-            MutexGuard::new(self, lock.lock())\n-        }\n+    /// this call will return an error once the mutex is acquired.\n+    pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n+        unsafe { self.inner.lock.lock() }\n+        MutexGuard::new(self)\n     }\n \n     /// Attempts to acquire this lock.\n@@ -169,17 +214,16 @@ impl<T: Send> Mutex<T> {\n     ///\n     /// This function does not block.\n     ///\n-    /// # Panics\n+    /// # Failure\n     ///\n     /// If another user of this mutex panicked while holding the mutex, then\n-    /// this call will immediately panic if the mutex would otherwise be\n+    /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    pub fn try_lock(&self) -> Option<MutexGuard<T>> {\n-        unsafe {\n-            let lock: &'static StaticMutex = &*(&*self.inner as *const _);\n-            lock.try_lock().map(|guard| {\n-                MutexGuard::new(self, guard)\n-            })\n+    pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n+        if unsafe { self.inner.lock.try_lock() } {\n+            Ok(try!(MutexGuard::new(self)))\n+        } else {\n+            Err(TryLockError::WouldBlock)\n         }\n     }\n }\n@@ -196,17 +240,19 @@ impl<T: Send> Drop for Mutex<T> {\n \n impl StaticMutex {\n     /// Acquires this lock, see `Mutex::lock`\n-    pub fn lock(&'static self) -> StaticMutexGuard {\n+    #[inline]\n+    pub fn lock(&'static self) -> LockResult<StaticMutexGuard> {\n         unsafe { self.lock.lock() }\n         StaticMutexGuard::new(self)\n     }\n \n     /// Attempts to grab this lock, see `Mutex::try_lock`\n-    pub fn try_lock(&'static self) -> Option<StaticMutexGuard> {\n+    #[inline]\n+    pub fn try_lock(&'static self) -> TryLockResult<StaticMutexGuard> {\n         if unsafe { self.lock.try_lock() } {\n-            Some(StaticMutexGuard::new(self))\n+            Ok(try!(StaticMutexGuard::new(self)))\n         } else {\n-            None\n+            Err(TryLockError::WouldBlock)\n         }\n     }\n \n@@ -226,53 +272,85 @@ impl StaticMutex {\n }\n \n impl<'mutex, T> MutexGuard<'mutex, T> {\n-    fn new(lock: &Mutex<T>, guard: StaticMutexGuard) -> MutexGuard<T> {\n-        MutexGuard { __lock: lock, __guard: guard }\n+    fn new(lock: &Mutex<T>) -> LockResult<MutexGuard<T>> {\n+        poison::map_result(Guard::new(lock), |guard| {\n+            MutexGuard { __inner: guard }\n+        })\n     }\n }\n \n-impl<'mutex, T> AsMutexGuard for MutexGuard<'mutex, T> {\n-    unsafe fn as_mutex_guard(&self) -> &StaticMutexGuard { &self.__guard }\n+impl<T> AsGuard for Mutex<T> {\n+    fn as_guard(&self) -> CondvarGuard { self.inner.as_guard() }\n+}\n+\n+impl<'mutex, T> AsGuard for MutexGuard<'mutex, T> {\n+    fn as_guard(&self) -> CondvarGuard {\n+        CondvarGuard {\n+            lock: &self.__inner.inner.inner.lock,\n+            poisoned: &self.__inner.inner.inner.poison,\n+        }\n+    }\n }\n \n impl<'mutex, T> Deref<T> for MutexGuard<'mutex, T> {\n-    fn deref<'a>(&'a self) -> &'a T { unsafe { &*self.__lock.data.get() } }\n+    fn deref<'a>(&'a self) -> &'a T {\n+        unsafe { &*self.__inner.inner.data.get() }\n+    }\n }\n impl<'mutex, T> DerefMut<T> for MutexGuard<'mutex, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n-        unsafe { &mut *self.__lock.data.get() }\n+        unsafe { &mut *self.__inner.inner.data.get() }\n     }\n }\n \n impl StaticMutexGuard {\n-    fn new(lock: &'static StaticMutex) -> StaticMutexGuard {\n-        unsafe {\n-            let guard = StaticMutexGuard {\n-                lock: &lock.lock,\n-                marker: marker::NoSend,\n-                poison: (*lock.poison.get()).borrow(),\n-            };\n-            guard.poison.check(\"mutex\");\n-            return guard;\n-        }\n+    #[inline]\n+    fn new(lock: &'static StaticMutex) -> LockResult<StaticMutexGuard> {\n+        poison::map_result(Guard::new(lock), |guard| {\n+            StaticMutexGuard { inner: guard }\n+        })\n     }\n }\n \n-pub fn guard_lock(guard: &StaticMutexGuard) -> &sys::Mutex { guard.lock }\n-pub fn guard_poison(guard: &StaticMutexGuard) -> &poison::Guard {\n-    &guard.poison\n+impl AsGuard for StaticMutex {\n+    #[inline]\n+    fn as_guard(&self) -> CondvarGuard {\n+        CondvarGuard { lock: &self.lock, poisoned: &self.poison }\n+    }\n }\n \n-impl AsMutexGuard for StaticMutexGuard {\n-    unsafe fn as_mutex_guard(&self) -> &StaticMutexGuard { self }\n+impl AsGuard for StaticMutexGuard {\n+    #[inline]\n+    fn as_guard(&self) -> CondvarGuard {\n+        CondvarGuard {\n+            lock: &self.inner.inner.lock,\n+            poisoned: &self.inner.inner.poison,\n+        }\n+    }\n+}\n+\n+impl<'a, T: AsGuard> Guard<'a, T> {\n+    #[inline]\n+    fn new(t: &T) -> LockResult<Guard<T>> {\n+        let data = t.as_guard();\n+        poison::map_result(data.poisoned.borrow(), |guard| {\n+            Guard {\n+                inner: t,\n+                poison: guard,\n+                marker: marker::NoSend,\n+            }\n+        })\n+    }\n }\n \n #[unsafe_destructor]\n-impl Drop for StaticMutexGuard {\n+impl<'a, T: AsGuard> Drop for Guard<'a, T> {\n+    #[inline]\n     fn drop(&mut self) {\n         unsafe {\n-            self.poison.done();\n-            self.lock.unlock();\n+            let data = self.inner.as_guard();\n+            data.poisoned.done(&self.poison);\n+            data.lock.unlock();\n         }\n     }\n }\n@@ -292,16 +370,16 @@ mod test {\n     #[test]\n     fn smoke() {\n         let m = Mutex::new(());\n-        drop(m.lock());\n-        drop(m.lock());\n+        drop(m.lock().unwrap());\n+        drop(m.lock().unwrap());\n     }\n \n     #[test]\n     fn smoke_static() {\n         static M: StaticMutex = MUTEX_INIT;\n         unsafe {\n-            drop(M.lock());\n-            drop(M.lock());\n+            drop(M.lock().unwrap());\n+            drop(M.lock().unwrap());\n             M.destroy();\n         }\n     }\n@@ -316,7 +394,7 @@ mod test {\n         fn inc() {\n             for _ in range(0, J) {\n                 unsafe {\n-                    let _g = M.lock();\n+                    let _g = M.lock().unwrap();\n                     CNT += 1;\n                 }\n             }\n@@ -343,7 +421,7 @@ mod test {\n     #[test]\n     fn try_lock() {\n         let m = Mutex::new(());\n-        assert!(m.try_lock().is_some());\n+        *m.try_lock().unwrap() = ();\n     }\n \n     #[test]\n@@ -355,22 +433,21 @@ mod test {\n             // wait until parent gets in\n             rx.recv();\n             let &(ref lock, ref cvar) = &*packet2.0;\n-            let mut lock = lock.lock();\n+            let mut lock = lock.lock().unwrap();\n             *lock = true;\n             cvar.notify_one();\n         });\n \n         let &(ref lock, ref cvar) = &*packet.0;\n-        let lock = lock.lock();\n+        let mut lock = lock.lock().unwrap();\n         tx.send(());\n         assert!(!*lock);\n         while !*lock {\n-            cvar.wait(&lock);\n+            lock = cvar.wait(lock).unwrap();\n         }\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_arc_condvar_poison() {\n         let packet = Packet(Arc::new((Mutex::new(1i), Condvar::new())));\n         let packet2 = Packet(packet.0.clone());\n@@ -379,31 +456,35 @@ mod test {\n         spawn(move|| {\n             rx.recv();\n             let &(ref lock, ref cvar) = &*packet2.0;\n-            let _g = lock.lock();\n+            let _g = lock.lock().unwrap();\n             cvar.notify_one();\n             // Parent should fail when it wakes up.\n             panic!();\n         });\n \n         let &(ref lock, ref cvar) = &*packet.0;\n-        let lock = lock.lock();\n+        let mut lock = lock.lock().unwrap();\n         tx.send(());\n         while *lock == 1 {\n-            cvar.wait(&lock);\n+            match cvar.wait(lock) {\n+                Ok(l) => {\n+                    lock = l;\n+                    assert_eq!(*lock, 1);\n+                }\n+                Err(..) => break,\n+            }\n         }\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_mutex_arc_poison() {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::spawn(move|| {\n-            let lock = arc2.lock();\n+        Thread::spawn(move|| {\n+            let lock = arc2.lock().unwrap();\n             assert_eq!(*lock, 2);\n         }).join();\n-        let lock = arc.lock();\n-        assert_eq!(*lock, 1);\n+        assert!(arc.lock().is_err());\n     }\n \n     #[test]\n@@ -414,8 +495,8 @@ mod test {\n         let arc2 = Arc::new(Mutex::new(arc));\n         let (tx, rx) = channel();\n         spawn(move|| {\n-            let lock = arc2.lock();\n-            let lock2 = lock.deref().lock();\n+            let lock = arc2.lock().unwrap();\n+            let lock2 = lock.deref().lock().unwrap();\n             assert_eq!(*lock2, 1);\n             tx.send(());\n         });\n@@ -432,13 +513,13 @@ mod test {\n             }\n             impl Drop for Unwinder {\n                 fn drop(&mut self) {\n-                    *self.i.lock() += 1;\n+                    *self.i.lock().unwrap() += 1;\n                 }\n             }\n             let _u = Unwinder { i: arc2 };\n             panic!();\n         }).join();\n-        let lock = arc.lock();\n+        let lock = arc.lock().unwrap();\n         assert_eq!(*lock, 2);\n     }\n }"}, {"sha": "d99fd91d0ac04ded5945e64a0df33cc2c4509b27", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 102, "deletions": 13, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -8,31 +8,120 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::*;\n+\n+use cell::UnsafeCell;\n+use error::FromError;\n+use fmt;\n use thread::Thread;\n \n-pub struct Flag { pub failed: bool }\n+pub struct Flag { failed: UnsafeCell<bool> }\n+pub const FLAG_INIT: Flag = Flag { failed: UnsafeCell { value: false } };\n \n impl Flag {\n-    pub fn borrow(&mut self) -> Guard {\n-        Guard { flag: &mut self.failed, panicking: Thread::panicking() }\n+    #[inline]\n+    pub fn borrow(&self) -> LockResult<Guard> {\n+        let ret = Guard { panicking: Thread::panicking() };\n+        if unsafe { *self.failed.get() } {\n+            Err(new_poison_error(ret))\n+        } else {\n+            Ok(ret)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn done(&self, guard: &Guard) {\n+        if !guard.panicking && Thread::panicking() {\n+            unsafe { *self.failed.get() = true; }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get(&self) -> bool {\n+        unsafe { *self.failed.get() }\n     }\n }\n \n-pub struct Guard<'a> {\n-    flag: &'a mut bool,\n+#[allow(missing_copy_implementations)]\n+pub struct Guard {\n     panicking: bool,\n }\n \n-impl<'a> Guard<'a> {\n-    pub fn check(&self, name: &str) {\n-        if *self.flag {\n-            panic!(\"poisoned {} - another task failed inside\", name);\n-        }\n+/// A type of error which can be returned whenever a lock is acquired.\n+///\n+/// Both Mutexes and RWLocks are poisoned whenever a task fails while the lock\n+/// is held. The precise semantics for when a lock is poisoned is documented on\n+/// each lock, but once a lock is poisoned then all future acquisitions will\n+/// return this error.\n+pub struct PoisonError<T> {\n+    guard: T,\n+}\n+\n+/// An enumeration of possible errors which can occur while calling the\n+/// `try_lock` method.\n+pub enum TryLockError<T> {\n+    /// The lock could not be acquired because another task failed while holding\n+    /// the lock.\n+    Poisoned(PoisonError<T>),\n+    /// The lock could not be acquired at this time because the operation would\n+    /// otherwise block.\n+    WouldBlock,\n+}\n+\n+/// A type alias for the result of a lock method which can be poisoned.\n+///\n+/// The `Ok` variant of this result indicates that the primitive was not\n+/// poisoned, and the `Guard` is contained within. The `Err` variant indicates\n+/// that the primitive was poisoned. Note that the `Err` variant *also* carries\n+/// the associated guard, and it can be acquired through the `into_inner`\n+/// method.\n+pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n+\n+/// A type alias for the result of a nonblocking locking method.\n+///\n+/// For more information, see `LockResult`. A `TryLockResult` doesn't\n+/// necessarily hold the associated guard in the `Err` type as the lock may not\n+/// have been acquired for other reasons.\n+pub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;\n+\n+impl<T> fmt::Show for PoisonError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"poisoned lock: another task failed inside\".fmt(f)\n+    }\n+}\n+\n+impl<T> PoisonError<T> {\n+    /// Consumes this error indicating that a lock is poisoned, returning the\n+    /// underlying guard to allow access regardless.\n+    pub fn into_guard(self) -> T { self.guard }\n+}\n+\n+impl<T> FromError<PoisonError<T>> for TryLockError<T> {\n+    fn from_error(err: PoisonError<T>) -> TryLockError<T> {\n+        TryLockError::Poisoned(err)\n     }\n+}\n \n-    pub fn done(&mut self) {\n-        if !self.panicking && Thread::panicking() {\n-            *self.flag = true;\n+impl<T> fmt::Show for TryLockError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            TryLockError::Poisoned(ref p) => p.fmt(f),\n+            TryLockError::WouldBlock => {\n+                \"try_lock failed because the operation would block\".fmt(f)\n+            }\n         }\n     }\n }\n+\n+pub fn new_poison_error<T>(guard: T) -> PoisonError<T> {\n+    PoisonError { guard: guard }\n+}\n+\n+pub fn map_result<T, U, F>(result: LockResult<T>, f: F)\n+                           -> LockResult<U>\n+                           where F: FnOnce(T) -> U {\n+    match result {\n+        Ok(t) => Ok(f(t)),\n+        Err(PoisonError { guard }) => Err(new_poison_error(f(guard)))\n+    }\n+}"}, {"sha": "f7632c4f8b5a4fadcb09fea6f22ba095f299e1f7", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 167, "deletions": 139, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -10,10 +10,10 @@\n \n use prelude::*;\n \n-use kinds::marker;\n use cell::UnsafeCell;\n+use kinds::marker;\n+use sync::poison::{mod, LockResult, TryLockError, TryLockResult};\n use sys_common::rwlock as sys;\n-use sync::poison;\n \n /// A reader-writer lock\n ///\n@@ -28,12 +28,14 @@ use sync::poison;\n /// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n /// to allow access to the contained of the lock.\n ///\n+/// # Poisoning\n+///\n /// RWLocks, like Mutexes, will become poisoned on panics. Note, however, that\n /// an RWLock may only be poisoned if a panic occurs while it is locked\n /// exclusively (write mode). If a panic occurs in any reader, then the lock\n /// will not be poisoned.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::sync::RWLock;\n@@ -42,15 +44,15 @@ use sync::poison;\n ///\n /// // many reader locks can be held at once\n /// {\n-///     let r1 = lock.read();\n-///     let r2 = lock.read();\n+///     let r1 = lock.read().unwrap();\n+///     let r2 = lock.read().unwrap();\n ///     assert_eq!(*r1, 5);\n ///     assert_eq!(*r2, 5);\n /// } // read locks are dropped at this point\n ///\n /// // only one write lock may be held, however\n /// {\n-///     let mut w = lock.write();\n+///     let mut w = lock.write().unwrap();\n ///     *w += 1;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n@@ -77,60 +79,71 @@ unsafe impl<T> Sync for RWLock<T> {}\n /// static LOCK: StaticRWLock = RWLOCK_INIT;\n ///\n /// {\n-///     let _g = LOCK.read();\n+///     let _g = LOCK.read().unwrap();\n ///     // ... shared read access\n /// }\n /// {\n-///     let _g = LOCK.write();\n+///     let _g = LOCK.write().unwrap();\n ///     // ... exclusive write access\n /// }\n /// unsafe { LOCK.destroy() } // free all resources\n /// ```\n pub struct StaticRWLock {\n-    inner: sys::RWLock,\n-    poison: UnsafeCell<poison::Flag>,\n+    lock: sys::RWLock,\n+    poison: poison::Flag,\n }\n \n unsafe impl Send for StaticRWLock {}\n unsafe impl Sync for StaticRWLock {}\n \n /// Constant initialization for a statically-initialized rwlock.\n pub const RWLOCK_INIT: StaticRWLock = StaticRWLock {\n-    inner: sys::RWLOCK_INIT,\n-    poison: UnsafeCell { value: poison::Flag { failed: false } },\n+    lock: sys::RWLOCK_INIT,\n+    poison: poison::FLAG_INIT,\n };\n \n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n #[must_use]\n pub struct RWLockReadGuard<'a, T: 'a> {\n-    __lock: &'a RWLock<T>,\n-    __guard: StaticRWLockReadGuard,\n+    __inner: ReadGuard<'a, RWLock<T>>,\n }\n \n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n pub struct RWLockWriteGuard<'a, T: 'a> {\n-    __lock: &'a RWLock<T>,\n-    __guard: StaticRWLockWriteGuard,\n+    __inner: WriteGuard<'a, RWLock<T>>,\n }\n \n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n #[must_use]\n pub struct StaticRWLockReadGuard {\n-    lock: &'static sys::RWLock,\n-    marker: marker::NoSend,\n+    _inner: ReadGuard<'static, StaticRWLock>,\n }\n \n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n pub struct StaticRWLockWriteGuard {\n-    lock: &'static sys::RWLock,\n-    marker: marker::NoSend,\n-    poison: poison::Guard<'static>,\n+    _inner: WriteGuard<'static, StaticRWLock>,\n+}\n+\n+struct ReadGuard<'a, T: 'a> {\n+    inner: &'a T,\n+    marker: marker::NoSend, // even if 'a == static, cannot send\n+}\n+\n+struct WriteGuard<'a, T: 'a> {\n+    inner: &'a T,\n+    poison: poison::Guard,\n+    marker: marker::NoSend, // even if 'a == static, cannot send\n+}\n+\n+#[doc(hidden)]\n+trait AsStaticRWLock {\n+    fn as_static_rwlock(&self) -> &StaticRWLock;\n }\n \n impl<T: Send + Sync> RWLock<T> {\n@@ -151,17 +164,15 @@ impl<T: Send + Sync> RWLock<T> {\n     /// Returns an RAII guard which will release this thread's shared access\n     /// once it is dropped.\n     ///\n-    /// # Panics\n+    /// # Failure\n     ///\n-    /// This function will panic if the RWLock is poisoned. An RWLock is\n-    /// poisoned whenever a writer panics while holding an exclusive lock. The\n-    /// panic will occur immediately after the lock has been acquired.\n+    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// is poisoned whenever a writer panics while holding an exclusive lock.\n+    /// The failure will occur immediately after the lock has been acquired.\n     #[inline]\n-    pub fn read(&self) -> RWLockReadGuard<T> {\n-        unsafe {\n-            let lock: &'static StaticRWLock = &*(&*self.inner as *const _);\n-            RWLockReadGuard::new(self, lock.read())\n-        }\n+    pub fn read(&self) -> LockResult<RWLockReadGuard<T>> {\n+        unsafe { self.inner.lock.read() }\n+        RWLockReadGuard::new(self)\n     }\n \n     /// Attempt to acquire this lock with shared read access.\n@@ -173,18 +184,18 @@ impl<T: Send + Sync> RWLock<T> {\n     /// guarantees with respect to the ordering of whether contentious readers\n     /// or writers will acquire the lock first.\n     ///\n-    /// # Panics\n+    /// # Failure\n     ///\n-    /// This function will panic if the RWLock is poisoned. An RWLock is\n-    /// poisoned whenever a writer panics while holding an exclusive lock. A\n-    /// panic will only occur if the lock is acquired.\n+    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// is poisoned whenever a writer panics while holding an exclusive lock. An\n+    /// error will only be returned if the lock would have otherwise been\n+    /// acquired.\n     #[inline]\n-    pub fn try_read(&self) -> Option<RWLockReadGuard<T>> {\n-        unsafe {\n-            let lock: &'static StaticRWLock = &*(&*self.inner as *const _);\n-            lock.try_read().map(|guard| {\n-                RWLockReadGuard::new(self, guard)\n-            })\n+    pub fn try_read(&self) -> TryLockResult<RWLockReadGuard<T>> {\n+        if unsafe { self.inner.lock.try_read() } {\n+            Ok(try!(RWLockReadGuard::new(self)))\n+        } else {\n+            Err(TryLockError::WouldBlock)\n         }\n     }\n \n@@ -197,17 +208,15 @@ impl<T: Send + Sync> RWLock<T> {\n     /// Returns an RAII guard which will drop the write access of this rwlock\n     /// when dropped.\n     ///\n-    /// # Panics\n+    /// # Failure\n     ///\n-    /// This function will panic if the RWLock is poisoned. An RWLock is\n-    /// poisoned whenever a writer panics while holding an exclusive lock. The\n-    /// panic will occur when the lock is acquired.\n+    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// is poisoned whenever a writer panics while holding an exclusive lock.\n+    /// An error will be returned when the lock is acquired.\n     #[inline]\n-    pub fn write(&self) -> RWLockWriteGuard<T> {\n-        unsafe {\n-            let lock: &'static StaticRWLock = &*(&*self.inner as *const _);\n-            RWLockWriteGuard::new(self, lock.write())\n-        }\n+    pub fn write(&self) -> LockResult<RWLockWriteGuard<T>> {\n+        unsafe { self.inner.lock.write() }\n+        RWLockWriteGuard::new(self)\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n@@ -216,26 +225,26 @@ impl<T: Send + Sync> RWLock<T> {\n     /// to `write` would otherwise block. If successful, an RAII guard is\n     /// returned.\n     ///\n-    /// # Panics\n+    /// # Failure\n     ///\n-    /// This function will panic if the RWLock is poisoned. An RWLock is\n-    /// poisoned whenever a writer panics while holding an exclusive lock. A\n-    /// panic will only occur if the lock is acquired.\n+    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// is poisoned whenever a writer panics while holding an exclusive lock. An\n+    /// error will only be returned if the lock would have otherwise been\n+    /// acquired.\n     #[inline]\n-    pub fn try_write(&self) -> Option<RWLockWriteGuard<T>> {\n-        unsafe {\n-            let lock: &'static StaticRWLock = &*(&*self.inner as *const _);\n-            lock.try_write().map(|guard| {\n-                RWLockWriteGuard::new(self, guard)\n-            })\n+    pub fn try_write(&self) -> TryLockResult<RWLockWriteGuard<T>> {\n+        if unsafe { self.inner.lock.try_read() } {\n+            Ok(try!(RWLockWriteGuard::new(self)))\n+        } else {\n+            Err(TryLockError::WouldBlock)\n         }\n     }\n }\n \n #[unsafe_destructor]\n impl<T> Drop for RWLock<T> {\n     fn drop(&mut self) {\n-        unsafe { self.inner.inner.destroy() }\n+        unsafe { self.inner.lock.destroy() }\n     }\n }\n \n@@ -245,20 +254,20 @@ impl StaticRWLock {\n     ///\n     /// See `RWLock::read`.\n     #[inline]\n-    pub fn read(&'static self) -> StaticRWLockReadGuard {\n-        unsafe { self.inner.read() }\n+    pub fn read(&'static self) -> LockResult<StaticRWLockReadGuard> {\n+        unsafe { self.lock.read() }\n         StaticRWLockReadGuard::new(self)\n     }\n \n     /// Attempt to acquire this lock with shared read access.\n     ///\n     /// See `RWLock::try_read`.\n     #[inline]\n-    pub fn try_read(&'static self) -> Option<StaticRWLockReadGuard> {\n-        if unsafe { self.inner.try_read() } {\n-            Some(StaticRWLockReadGuard::new(self))\n+    pub fn try_read(&'static self) -> TryLockResult<StaticRWLockReadGuard> {\n+        if unsafe { self.lock.try_read() } {\n+            Ok(try!(StaticRWLockReadGuard::new(self)))\n         } else {\n-            None\n+            Err(TryLockError::WouldBlock)\n         }\n     }\n \n@@ -267,20 +276,20 @@ impl StaticRWLock {\n     ///\n     /// See `RWLock::write`.\n     #[inline]\n-    pub fn write(&'static self) -> StaticRWLockWriteGuard {\n-        unsafe { self.inner.write() }\n+    pub fn write(&'static self) -> LockResult<StaticRWLockWriteGuard> {\n+        unsafe { self.lock.write() }\n         StaticRWLockWriteGuard::new(self)\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n     ///\n     /// See `RWLock::try_write`.\n     #[inline]\n-    pub fn try_write(&'static self) -> Option<StaticRWLockWriteGuard> {\n-        if unsafe { self.inner.try_write() } {\n-            Some(StaticRWLockWriteGuard::new(self))\n+    pub fn try_write(&'static self) -> TryLockResult<StaticRWLockWriteGuard> {\n+        if unsafe { self.lock.try_write() } {\n+            Ok(try!(StaticRWLockWriteGuard::new(self)))\n         } else {\n-            None\n+            Err(TryLockError::WouldBlock)\n         }\n     }\n \n@@ -291,69 +300,92 @@ impl StaticRWLock {\n     /// of this lock. This method is required to be called to not leak memory on\n     /// all platforms.\n     pub unsafe fn destroy(&'static self) {\n-        self.inner.destroy()\n+        self.lock.destroy()\n     }\n }\n \n impl<'rwlock, T> RWLockReadGuard<'rwlock, T> {\n-    fn new(lock: &RWLock<T>, guard: StaticRWLockReadGuard)\n-           -> RWLockReadGuard<T> {\n-        RWLockReadGuard { __lock: lock, __guard: guard }\n+    fn new(lock: &RWLock<T>) -> LockResult<RWLockReadGuard<T>> {\n+        poison::map_result(ReadGuard::new(lock), |guard| {\n+            RWLockReadGuard { __inner: guard }\n+        })\n     }\n }\n impl<'rwlock, T> RWLockWriteGuard<'rwlock, T> {\n-    fn new(lock: &RWLock<T>, guard: StaticRWLockWriteGuard)\n-           -> RWLockWriteGuard<T> {\n-        RWLockWriteGuard { __lock: lock, __guard: guard }\n+    fn new(lock: &RWLock<T>) -> LockResult<RWLockWriteGuard<T>> {\n+        poison::map_result(WriteGuard::new(lock), |guard| {\n+            RWLockWriteGuard { __inner: guard }\n+        })\n     }\n }\n \n impl<'rwlock, T> Deref<T> for RWLockReadGuard<'rwlock, T> {\n-    fn deref(&self) -> &T { unsafe { &*self.__lock.data.get() } }\n+    fn deref(&self) -> &T { unsafe { &*self.__inner.inner.data.get() } }\n }\n impl<'rwlock, T> Deref<T> for RWLockWriteGuard<'rwlock, T> {\n-    fn deref(&self) -> &T { unsafe { &*self.__lock.data.get() } }\n+    fn deref(&self) -> &T { unsafe { &*self.__inner.inner.data.get() } }\n }\n impl<'rwlock, T> DerefMut<T> for RWLockWriteGuard<'rwlock, T> {\n-    fn deref_mut(&mut self) -> &mut T { unsafe { &mut *self.__lock.data.get() } }\n+    fn deref_mut(&mut self) -> &mut T {\n+        unsafe { &mut *self.__inner.inner.data.get() }\n+    }\n }\n \n impl StaticRWLockReadGuard {\n-    fn new(lock: &'static StaticRWLock) -> StaticRWLockReadGuard {\n-        let guard = StaticRWLockReadGuard {\n-            lock: &lock.inner,\n-            marker: marker::NoSend,\n-        };\n-        unsafe { (*lock.poison.get()).borrow().check(\"rwlock\"); }\n-        return guard;\n+    #[inline]\n+    fn new(lock: &'static StaticRWLock) -> LockResult<StaticRWLockReadGuard> {\n+        poison::map_result(ReadGuard::new(lock), |guard| {\n+            StaticRWLockReadGuard { _inner: guard }\n+        })\n     }\n }\n impl StaticRWLockWriteGuard {\n-    fn new(lock: &'static StaticRWLock) -> StaticRWLockWriteGuard {\n-        unsafe {\n-            let guard = StaticRWLockWriteGuard {\n-                lock: &lock.inner,\n-                marker: marker::NoSend,\n-                poison: (*lock.poison.get()).borrow(),\n-            };\n-            guard.poison.check(\"rwlock\");\n-            return guard;\n-        }\n+    #[inline]\n+    fn new(lock: &'static StaticRWLock) -> LockResult<StaticRWLockWriteGuard> {\n+        poison::map_result(WriteGuard::new(lock), |guard| {\n+            StaticRWLockWriteGuard { _inner: guard }\n+        })\n+    }\n+}\n+\n+impl<T> AsStaticRWLock for RWLock<T> {\n+    #[inline]\n+    fn as_static_rwlock(&self) -> &StaticRWLock { &*self.inner }\n+}\n+impl AsStaticRWLock for StaticRWLock {\n+    #[inline]\n+    fn as_static_rwlock(&self) -> &StaticRWLock { self }\n+}\n+\n+impl<'a, T: AsStaticRWLock> ReadGuard<'a, T> {\n+    fn new(t: &'a T) -> LockResult<ReadGuard<'a, T>> {\n+        poison::map_result(t.as_static_rwlock().poison.borrow(), |_| {\n+            ReadGuard { inner: t, marker: marker::NoSend }\n+        })\n+    }\n+}\n+\n+impl<'a, T: AsStaticRWLock> WriteGuard<'a, T> {\n+    fn new(t: &'a T) -> LockResult<WriteGuard<'a, T>> {\n+        poison::map_result(t.as_static_rwlock().poison.borrow(), |guard| {\n+            WriteGuard { inner: t, marker: marker::NoSend, poison: guard }\n+        })\n     }\n }\n \n #[unsafe_destructor]\n-impl Drop for StaticRWLockReadGuard {\n+impl<'a, T: AsStaticRWLock> Drop for ReadGuard<'a, T> {\n     fn drop(&mut self) {\n-        unsafe { self.lock.read_unlock(); }\n+        unsafe { self.inner.as_static_rwlock().lock.read_unlock(); }\n     }\n }\n \n #[unsafe_destructor]\n-impl Drop for StaticRWLockWriteGuard {\n+impl<'a, T: AsStaticRWLock> Drop for WriteGuard<'a, T> {\n     fn drop(&mut self) {\n-        self.poison.done();\n-        unsafe { self.lock.write_unlock(); }\n+        let inner = self.inner.as_static_rwlock();\n+        inner.poison.done(&self.poison);\n+        unsafe { inner.lock.write_unlock(); }\n     }\n }\n \n@@ -368,19 +400,19 @@ mod tests {\n     #[test]\n     fn smoke() {\n         let l = RWLock::new(());\n-        drop(l.read());\n-        drop(l.write());\n-        drop((l.read(), l.read()));\n-        drop(l.write());\n+        drop(l.read().unwrap());\n+        drop(l.write().unwrap());\n+        drop((l.read().unwrap(), l.read().unwrap()));\n+        drop(l.write().unwrap());\n     }\n \n     #[test]\n     fn static_smoke() {\n         static R: StaticRWLock = RWLOCK_INIT;\n-        drop(R.read());\n-        drop(R.write());\n-        drop((R.read(), R.read()));\n-        drop(R.write());\n+        drop(R.read().unwrap());\n+        drop(R.write().unwrap());\n+        drop((R.read().unwrap(), R.read().unwrap()));\n+        drop(R.write().unwrap());\n         unsafe { R.destroy(); }\n     }\n \n@@ -397,9 +429,9 @@ mod tests {\n                 let mut rng = rand::task_rng();\n                 for _ in range(0, M) {\n                     if rng.gen_weighted_bool(N) {\n-                        drop(R.write());\n+                        drop(R.write().unwrap());\n                     } else {\n-                        drop(R.read());\n+                        drop(R.read().unwrap());\n                     }\n                 }\n                 drop(tx);\n@@ -411,51 +443,47 @@ mod tests {\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::spawn(move|| {\n-            let lock = arc2.write();\n-            assert_eq!(*lock, 2);\n+        let _: Result<uint, _> = Thread::spawn(move|| {\n+            let _lock = arc2.write().unwrap();\n+            panic!();\n         }).join();\n-        let lock = arc.read();\n-        assert_eq!(*lock, 1);\n+        assert!(arc.read().is_err());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_rw_arc_poison_ww() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::spawn(move|| {\n-            let lock = arc2.write();\n-            assert_eq!(*lock, 2);\n+        let _: Result<uint, _> = Thread::spawn(move|| {\n+            let _lock = arc2.write().unwrap();\n+            panic!();\n         }).join();\n-        let lock = arc.write();\n-        assert_eq!(*lock, 1);\n+        assert!(arc.write().is_err());\n     }\n \n     #[test]\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::spawn(move|| {\n-            let lock = arc2.read();\n-            assert_eq!(*lock, 2);\n+        let _: Result<uint, _> = Thread::spawn(move|| {\n+            let _lock = arc2.read().unwrap();\n+            panic!();\n         }).join();\n-        let lock = arc.read();\n+        let lock = arc.read().unwrap();\n         assert_eq!(*lock, 1);\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::spawn(move|| {\n-            let lock = arc2.read();\n-            assert_eq!(*lock, 2);\n+        let _: Result<uint, _> = Thread::spawn(move|| {\n+            let _lock = arc2.read().unwrap();\n+            panic!()\n         }).join();\n-        let lock = arc.write();\n+        let lock = arc.write().unwrap();\n         assert_eq!(*lock, 1);\n     }\n \n@@ -466,7 +494,7 @@ mod tests {\n         let (tx, rx) = channel();\n \n         Thread::spawn(move|| {\n-            let mut lock = arc2.write();\n+            let mut lock = arc2.write().unwrap();\n             for _ in range(0u, 10) {\n                 let tmp = *lock;\n                 *lock = -1;\n@@ -481,7 +509,7 @@ mod tests {\n         for _ in range(0u, 5) {\n             let arc3 = arc.clone();\n             children.push(Thread::spawn(move|| {\n-                let lock = arc3.read();\n+                let lock = arc3.read().unwrap();\n                 assert!(*lock >= 0);\n             }));\n         }\n@@ -493,7 +521,7 @@ mod tests {\n \n         // Wait for writer to finish\n         rx.recv();\n-        let lock = arc.read();\n+        let lock = arc.read().unwrap();\n         assert_eq!(*lock, 10);\n     }\n \n@@ -507,14 +535,14 @@ mod tests {\n             }\n             impl Drop for Unwinder {\n                 fn drop(&mut self) {\n-                    let mut lock = self.i.write();\n+                    let mut lock = self.i.write().unwrap();\n                     *lock += 1;\n                 }\n             }\n             let _u = Unwinder { i: arc2 };\n             panic!();\n         }).join();\n-        let lock = arc.read();\n+        let lock = arc.read().unwrap();\n         assert_eq!(*lock, 2);\n     }\n }"}, {"sha": "e3b683a6ccb380786588fd57930197e9e2efb3c5", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -68,9 +68,9 @@ impl Semaphore {\n     /// This method will block until the internal count of the semaphore is at\n     /// least 1.\n     pub fn acquire(&self) {\n-        let mut count = self.lock.lock();\n+        let mut count = self.lock.lock().unwrap();\n         while *count <= 0 {\n-            self.cvar.wait(&count);\n+            count = self.cvar.wait(count).unwrap();\n         }\n         *count -= 1;\n     }\n@@ -80,7 +80,7 @@ impl Semaphore {\n     /// This will increment the number of resources in this semaphore by 1 and\n     /// will notify any pending waiters in `acquire` or `access` if necessary.\n     pub fn release(&self) {\n-        *self.lock.lock() += 1;\n+        *self.lock.lock().unwrap() += 1;\n         self.cvar.notify_one();\n     }\n "}, {"sha": "98da5ccc554763159e70cda431e9441aed03e7ad", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -113,7 +113,7 @@ fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n             let message = {\n                 // Only lock jobs for the time it takes\n                 // to get a job, not run it.\n-                let lock = jobs.lock();\n+                let lock = jobs.lock().unwrap();\n                 lock.recv_opt()\n             };\n "}, {"sha": "9ef1c33312fc8b4ac6c5a6e354ce0caa12bcc0b2", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -83,7 +83,7 @@ impl<M: Send> Helper<M> {\n         F: FnOnce() -> T,\n     {\n         unsafe {\n-            let _guard = self.lock.lock();\n+            let _guard = self.lock.lock().unwrap();\n             if !*self.initialized.get() {\n                 let (tx, rx) = channel();\n                 *self.chan.get() = mem::transmute(box tx);\n@@ -95,7 +95,7 @@ impl<M: Send> Helper<M> {\n                 let t = f();\n                 Thread::spawn(move |:| {\n                     helper(receive.0, rx, t);\n-                    let _g = self.lock.lock();\n+                    let _g = self.lock.lock().unwrap();\n                     *self.shutdown.get() = true;\n                     self.cond.notify_one()\n                 }).detach();\n@@ -111,7 +111,7 @@ impl<M: Send> Helper<M> {\n     /// This is only valid if the worker thread has previously booted\n     pub fn send(&'static self, msg: M) {\n         unsafe {\n-            let _guard = self.lock.lock();\n+            let _guard = self.lock.lock().unwrap();\n \n             // Must send and *then* signal to ensure that the child receives the\n             // message. Otherwise it could wake up and go to sleep before we\n@@ -127,7 +127,7 @@ impl<M: Send> Helper<M> {\n             // Shut down, but make sure this is done inside our lock to ensure\n             // that we'll always receive the exit signal when the thread\n             // returns.\n-            let guard = self.lock.lock();\n+            let mut guard = self.lock.lock().unwrap();\n \n             // Close the channel by destroying it\n             let chan: Box<Sender<M>> = mem::transmute(*self.chan.get());\n@@ -137,7 +137,7 @@ impl<M: Send> Helper<M> {\n \n             // Wait for the child to exit\n             while !*self.shutdown.get() {\n-                self.cond.wait(&guard);\n+                guard = self.cond.wait(guard).unwrap();\n             }\n             drop(guard);\n "}, {"sha": "38e304ccfecc0a02b5022fbfb839fb85fdca2d2f", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -334,6 +334,7 @@ impl Thread {\n     }\n \n     /// Determines whether the current thread is panicking.\n+    #[inline]\n     pub fn panicking() -> bool {\n         unwind::panicking()\n     }\n@@ -349,9 +350,9 @@ impl Thread {\n     // or futuxes, and in either case may allow spurious wakeups.\n     pub fn park() {\n         let thread = Thread::current();\n-        let mut guard = thread.inner.lock.lock();\n+        let mut guard = thread.inner.lock.lock().unwrap();\n         while !*guard {\n-            thread.inner.cvar.wait(&guard);\n+            guard = thread.inner.cvar.wait(guard).unwrap();\n         }\n         *guard = false;\n     }\n@@ -360,7 +361,7 @@ impl Thread {\n     ///\n     /// See the module doc for more detail.\n     pub fn unpark(&self) {\n-        let mut guard = self.inner.lock.lock();\n+        let mut guard = self.inner.lock.lock().unwrap();\n         if !*guard {\n             *guard = true;\n             self.inner.cvar.notify_one();"}, {"sha": "4cfa27093527a81720182f5692377a642458baeb", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -240,13 +240,18 @@ impl<T: 'static> Key<T> {\n         unsafe {\n             let slot = slot.get().expect(\"cannot access a TLS value during or \\\n                                           after it is destroyed\");\n-            if (*slot.get()).is_none() {\n-                *slot.get() = Some((self.init)());\n-            }\n-            f((*slot.get()).as_ref().unwrap())\n+            f(match *slot.get() {\n+                Some(ref inner) => inner,\n+                None => self.init(slot),\n+            })\n         }\n     }\n \n+    unsafe fn init(&self, slot: &UnsafeCell<Option<T>>) -> &T {\n+        *slot.get() = Some((self.init)());\n+        (*slot.get()).as_ref().unwrap()\n+    }\n+\n     /// Test this TLS key to determine whether its value has been destroyed for\n     /// the current thread or not.\n     ///"}, {"sha": "8ec44b2dd3c1405e896d54f95232083fd9389359", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -28,15 +28,15 @@ type pipe = Arc<(Mutex<Vec<uint>>, Condvar)>;\n \n fn send(p: &pipe, msg: uint) {\n     let &(ref lock, ref cond) = &**p;\n-    let mut arr = lock.lock();\n+    let mut arr = lock.lock().unwrap();\n     arr.push(msg);\n     cond.notify_one();\n }\n fn recv(p: &pipe) -> uint {\n     let &(ref lock, ref cond) = &**p;\n-    let mut arr = lock.lock();\n+    let mut arr = lock.lock().unwrap();\n     while arr.is_empty() {\n-        cond.wait(&arr);\n+        arr = cond.wait(arr).unwrap();\n     }\n     arr.pop().unwrap()\n }"}, {"sha": "a83bc73457e020b4bdac0682be4294f22cdff004", "filename": "src/test/run-pass/match-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -11,13 +11,11 @@\n use std::sync::Mutex;\n \n pub fn main() {\n-    unsafe {\n-        let x = Some(Mutex::new(true));\n-        match x {\n-            Some(ref z) if *z.lock() => {\n-                assert!(*z.lock());\n-            },\n-            _ => panic!()\n-        }\n+    let x = Some(Mutex::new(true));\n+    match x {\n+        Some(ref z) if *z.lock().unwrap() => {\n+            assert!(*z.lock().unwrap());\n+        },\n+        _ => panic!()\n     }\n }"}, {"sha": "dacfeb0081925ab0bcd6d4fc617cc60c70d0a53f", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e5ed655c762b812c3da4749a55f1bb1b52c787/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=76e5ed655c762b812c3da4749a55f1bb1b52c787", "patch": "@@ -15,13 +15,11 @@ struct Point {x: int, y: int, z: int}\n fn f(p: &mut Point) { p.z = 13; }\n \n pub fn main() {\n-    unsafe {\n-        let x = Some(Mutex::new(true));\n-        match x {\n-            Some(ref z) if *z.lock() => {\n-                assert!(*z.lock());\n-            },\n-            _ => panic!()\n-        }\n+    let x = Some(Mutex::new(true));\n+    match x {\n+        Some(ref z) if *z.lock().unwrap() => {\n+            assert!(*z.lock().unwrap());\n+        },\n+        _ => panic!()\n     }\n }"}]}