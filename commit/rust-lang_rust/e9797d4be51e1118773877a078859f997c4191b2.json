{"sha": "e9797d4be51e1118773877a078859f997c4191b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5Nzk3ZDRiZTUxZTExMTg3NzM4NzdhMDc4ODU5Zjk5N2M0MTkxYjI=", "commit": {"author": {"name": "ggomez", "email": "ggomez@ggo.ifr.lan", "date": "2016-01-21T09:57:21Z"}, "committer": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-05-11T11:18:57Z"}, "message": "Extend rustc_on_unimplemented flag: if a message is available at an impl, this message will be displayed instead", "tree": {"sha": "9c318f540e75a27d69600258bf1944d64f4b41df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c318f540e75a27d69600258bf1944d64f4b41df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9797d4be51e1118773877a078859f997c4191b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9797d4be51e1118773877a078859f997c4191b2", "html_url": "https://github.com/rust-lang/rust/commit/e9797d4be51e1118773877a078859f997c4191b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9797d4be51e1118773877a078859f997c4191b2/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "html_url": "https://github.com/rust-lang/rust/commit/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}], "stats": {"total": 241, "additions": 235, "deletions": 6}, "files": [{"sha": "e1bbdf4a7ae41ccf5b15741516c021329d9c8373", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9797d4be51e1118773877a078859f997c4191b2/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9797d4be51e1118773877a078859f997c4191b2/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e9797d4be51e1118773877a078859f997c4191b2", "patch": "@@ -43,6 +43,7 @@\n // Since libcore defines many fundamental lang items, all tests live in a\n // separate crate, libcoretest, to avoid bizarre issues.\n \n+#![cfg_attr(stage0, allow(unused_attributes))]\n #![crate_name = \"core\"]\n #![stable(feature = \"core\", since = \"1.6.0\")]\n #![crate_type = \"rlib\"]"}, {"sha": "41982ddc78b65e69662f37f6c0ad2aa5e5f06ea4", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9797d4be51e1118773877a078859f997c4191b2/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9797d4be51e1118773877a078859f997c4191b2/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e9797d4be51e1118773877a078859f997c4191b2", "patch": "@@ -167,7 +167,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n /// region that each late-bound region was replaced with.\n-pub type SkolemizationMap = FnvHashMap<ty::BoundRegion,ty::Region>;\n+pub type SkolemizationMap = FnvHashMap<ty::BoundRegion, ty::Region>;\n \n /// Why did we require that the two types be related?\n ///"}, {"sha": "b23ca4ae832841f5f96485ae2718f4c2bb1b73ef", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 179, "deletions": 4, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/e9797d4be51e1118773877a078859f997c4191b2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9797d4be51e1118773877a078859f997c4191b2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e9797d4be51e1118773877a078859f997c4191b2", "patch": "@@ -26,14 +26,16 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n-use infer::InferCtxt;\n-use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n+use infer::{self, InferCtxt, TypeOrigin};\n+use ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::fast_reject;\n use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::::subst::{self, Subst};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n use std::fmt;\n+use syntax::ast;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -60,6 +62,154 @@ impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n     }\n }\n \n+fn impl_self_ty<'a, 'tcx>(fcx: &InferCtxt<'a, 'tcx>,\n+                          did: DefId,\n+                          obligation: PredicateObligation<'tcx>)\n+                          -> subst::Substs<'tcx> {\n+    let tcx = fcx.tcx;\n+\n+    let ity = tcx.lookup_item_type(did);\n+    let (tps, rps, _) =\n+        (ity.generics.types.get_slice(subst::TypeSpace),\n+         ity.generics.regions.get_slice(subst::TypeSpace),\n+         ity.ty);\n+\n+    let rps = fcx.region_vars_for_defs(obligation.cause.span, rps);\n+    let mut substs = subst::Substs::new(\n+        subst::VecPerParamSpace::empty(),\n+        subst::VecPerParamSpace::new(rps, Vec::new(), Vec::new()));\n+    fcx.type_vars_for_defs(obligation.cause.span, subst::ParamSpace::TypeSpace, &mut substs, tps);\n+    substs\n+}\n+\n+fn get_current_failing_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                      trait_ref: &TraitRef<'tcx>,\n+                                      obligation: &PredicateObligation<'tcx>)\n+                                     -> Option<DefId> {\n+    let simp = fast_reject::simplify_type(infcx.tcx,\n+                                          trait_ref.self_ty(),\n+                                          true);\n+    let trait_def = infcx.tcx.lookup_trait_def(trait_ref.def_id);\n+\n+    match simp {\n+        Some(_) => {\n+            let mut ret = None;\n+            trait_def.for_each_impl(infcx.tcx, |def_id| {\n+                let imp = infcx.tcx.impl_trait_ref(def_id).unwrap();\n+                let imp = imp.subst(infcx.tcx, &impl_self_ty(infcx, def_id, obligation.clone()));\n+                if ret.is_none() {\n+                    for error in infcx.reported_trait_errors.borrow().iter() {\n+                        if let ty::Predicate::Trait(ref t) = error.predicate {\n+                            if infer::mk_eqty(infcx, true, TypeOrigin::Misc(obligation.cause.span),\n+                                              t.skip_binder().trait_ref.self_ty(),\n+                                              imp.self_ty()).is_ok() {\n+                                ret = Some(def_id);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            });\n+            ret\n+        },\n+        None => None,\n+    }\n+}\n+\n+fn find_attr<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                       def_id: DefId,\n+                       attr_name: &str)\n+                      -> Option<ast::Attribute> {\n+    for item in infcx.tcx.get_attrs(def_id).iter() {\n+        if item.check_name(attr_name) {\n+            return Some(item.clone());\n+        }\n+    }\n+    None\n+}\n+\n+fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                     trait_ref: &TraitRef<'tcx>,\n+                                     obligation: &PredicateObligation<'tcx>)\n+                                    -> Option<String> {\n+    let def_id = match get_current_failing_impl(infcx, trait_ref, obligation) {\n+        Some(def_id) => {\n+            if let Some(_) = find_attr(infcx, def_id, \"rustc_on_unimplemented\") {\n+                def_id\n+            } else {\n+                trait_ref.def_id\n+            }\n+        },\n+        None         => trait_ref.def_id,\n+    };\n+    let span = obligation.cause.span;\n+    let mut report = None;\n+\n+    for item in infcx.tcx.get_attrs(def_id).iter() {\n+        if item.check_name(\"rustc_on_unimplemented\") {\n+            let err_sp = item.meta().span.substitute_dummy(span);\n+            let def = infcx.tcx.lookup_trait_def(trait_ref.def_id);\n+            let trait_str = def.trait_ref.to_string();\n+            if let Some(ref istring) = item.value_str() {\n+                let mut generic_map = def.generics.types.iter_enumerated()\n+                                         .map(|(param, i, gen)| {\n+                                               (gen.name.as_str().to_string(),\n+                                                trait_ref.substs.types.get(param, i)\n+                                                         .to_string())\n+                                              }).collect::<FnvHashMap<String, String>>();\n+                generic_map.insert(\"Self\".to_string(),\n+                                   trait_ref.self_ty().to_string());\n+                let parser = Parser::new(&istring);\n+                let mut errored = false;\n+                let err: String = parser.filter_map(|p| {\n+                    match p {\n+                        Piece::String(s) => Some(s),\n+                        Piece::NextArgument(a) => match a.position {\n+                            Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                                Some(val) => Some(val),\n+                                None => {\n+                                    span_err!(infcx.tcx.sess, err_sp, E0272,\n+                                              \"the #[rustc_on_unimplemented] \\\n+                                               attribute on \\\n+                                               trait definition for {} refers to \\\n+                                               non-existent type parameter {}\",\n+                                              trait_str, s);\n+                                    errored = true;\n+                                    None\n+                                }\n+                            },\n+                            _ => {\n+                                span_err!(infcx.tcx.sess, err_sp, E0273,\n+                                          \"the #[rustc_on_unimplemented] \\\n+                                           attribute on \\\n+                                           trait definition for {} must have named \\\n+                                           format arguments, \\\n+                                           eg `#[rustc_on_unimplemented = \\\n+                                           \\\"foo {{T}}\\\"]`\",\n+                                          trait_str);\n+                                errored = true;\n+                                None\n+                            }\n+                        }\n+                    }\n+                }).collect();\n+                // Report only if the format string checks out\n+                if !errored {\n+                    report = Some(err);\n+                }\n+            } else {\n+                span_err!(infcx.tcx.sess, err_sp, E0274,\n+                          \"the #[rustc_on_unimplemented] attribute on \\\n+                           trait definition for {} must have a value, \\\n+                           eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n+                          trait_str);\n+            }\n+            break;\n+        }\n+    }\n+    report\n+}\n+\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n         for error in errors {\n@@ -403,7 +553,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 self.resolve_type_vars_if_possible(trait_predicate);\n \n                             if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n-                                return;\n+                                let trait_ref = trait_predicate.to_poly_trait_ref();\n+                                let mut err = struct_span_err!(\n+                                    infcx.tcx.sess, obligation.cause.span, E0277,\n+                                    \"the trait bound `{}` is not satisfied\",\n+                                    trait_ref.to_predicate());\n+\n+                            // Try to report a help message\n+\n+                            if !trait_ref.has_infer_types() &&\n+                                predicate_can_apply(infcx, trait_ref)\n+                            {\n+                                // If a where-clause may be useful, remind the\n+                                // user that they can add it.\n+                                //\n+                                // don't display an on-unimplemented note, as\n+                                // these notes will often be of the form\n+                                //     \"the type `T` can't be frobnicated\"\n+                                // which is somewhat confusing.\n+                                err.help(&format!(\"consider adding a `where {}` bound\",\n+                                    trait_ref.to_predicate()));\n+                            } else if let Some(s) = on_unimplemented_note(infcx, trait_ref,\n+                                                                          obligation.cause.span) {\n+                                // Otherwise, if there is an on-unimplemented note,\n+                                // display it.\n+                                err.note(&s);\n                             } else {\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n \n@@ -450,7 +624,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 }\n                                 err\n                             }\n-                        },\n+                        }\n+\n                         ty::Predicate::Equate(ref predicate) => {\n                             let predicate = self.resolve_type_vars_if_possible(predicate);\n                             let err = self.equality_predicate(span,"}, {"sha": "2db9ceb8a05c8ddc8517fd7364f1c16b76682759", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9797d4be51e1118773877a078859f997c4191b2/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9797d4be51e1118773877a078859f997c4191b2/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=e9797d4be51e1118773877a078859f997c4191b2", "patch": "@@ -136,7 +136,6 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n }\n \n impl<'tcx> Encodable for Substs<'tcx> {\n-\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         cstore::tls::with_encoding_context(s, |ecx, rbml_w| {\n             ecx.encode_substs(rbml_w, self);"}, {"sha": "042fdb070f42f5c53fc0058ae4931aa078cbf14d", "filename": "src/test/compile-fail/check_on_unimplemented.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e9797d4be51e1118773877a078859f997c4191b2/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9797d4be51e1118773877a078859f997c4191b2/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented.rs?ref=e9797d4be51e1118773877a078859f997c4191b2", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test if the on_unimplemented message override works\n+\n+#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_on_unimplemented = \"invalid\"]\n+trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n+impl Index<usize> for [i32] {\n+    type Output = i32;\n+    fn index(&self, index: usize) -> &i32 {\n+        &self[index]\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() {\n+    Index::<u32>::index(&[1, 2, 3] as &[i32], 2u32); //~ ERROR E0277\n+                                                     //~| NOTE a usize is required\n+}"}, {"sha": "d594b1cea8bce38d74f47f1576bc68ce4cbafdcf", "filename": "src/test/compile-fail/check_on_unimplemented_on_slice.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9797d4be51e1118773877a078859f997c4191b2/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented_on_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9797d4be51e1118773877a078859f997c4191b2/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented_on_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented_on_slice.rs?ref=e9797d4be51e1118773877a078859f997c4191b2", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test new Index error message for slices\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_error]\n+fn main() {\n+    let x = &[1, 2, 3] as &[i32];\n+    x[1i32]; //~ ERROR E0277\n+             //~| NOTE a usize is required\n+}"}]}