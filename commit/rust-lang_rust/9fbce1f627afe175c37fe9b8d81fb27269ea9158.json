{"sha": "9fbce1f627afe175c37fe9b8d81fb27269ea9158", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYmNlMWY2MjdhZmUxNzVjMzdmZTliOGQ4MWZiMjcyNjllYTkxNTg=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T02:10:09Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T02:10:09Z"}, "message": "Reorganise formatting.rs", "tree": {"sha": "14a5a7edfc6eaff489f11c6147db111b1d3d691b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14a5a7edfc6eaff489f11c6147db111b1d3d691b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fbce1f627afe175c37fe9b8d81fb27269ea9158", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fbce1f627afe175c37fe9b8d81fb27269ea9158", "html_url": "https://github.com/rust-lang/rust/commit/9fbce1f627afe175c37fe9b8d81fb27269ea9158", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fbce1f627afe175c37fe9b8d81fb27269ea9158/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2af1ed109c95747cd674ace5758b175ff1f5e50f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2af1ed109c95747cd674ace5758b175ff1f5e50f", "html_url": "https://github.com/rust-lang/rust/commit/2af1ed109c95747cd674ace5758b175ff1f5e50f"}], "stats": {"total": 870, "additions": 435, "deletions": 435}, "files": [{"sha": "656a18b876f37cd02003e1581fe9068a0496d94f", "filename": "src/formatting.rs", "status": "modified", "additions": 435, "deletions": 435, "changes": 870, "blob_url": "https://github.com/rust-lang/rust/blob/9fbce1f627afe175c37fe9b8d81fb27269ea9158/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fbce1f627afe175c37fe9b8d81fb27269ea9158/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=9fbce1f627afe175c37fe9b8d81fb27269ea9158", "patch": "@@ -22,6 +22,231 @@ use {filemap, modules, ErrorKind, FormatReport, Input, Session};\n pub(crate) type FileMap = Vec<FileRecord>;\n pub(crate) type FileRecord = (FileName, String);\n \n+impl<'b, T: Write + 'b> Session<'b, T> {\n+    pub(crate) fn format_input_inner(&mut self, input: Input) -> Result<FormatReport, ErrorKind> {\n+        if !self.config.version_meets_requirement() {\n+            return Err(ErrorKind::VersionMismatch);\n+        }\n+\n+        syntax::with_globals(|| {\n+            syntax_pos::hygiene::set_default_edition(\n+                self.config.edition().to_libsyntax_pos_edition(),\n+            );\n+\n+            if self.config.disable_all_formatting() {\n+                // When the input is from stdin, echo back the input.\n+                if let Input::Text(ref buf) = input {\n+                    if let Err(e) = io::stdout().write_all(buf.as_bytes()) {\n+                        return Err(From::from(e));\n+                    }\n+                }\n+                return Ok(FormatReport::new());\n+            }\n+\n+            let config = &self.config.clone();\n+            let format_result = format_project(input, config, self);\n+\n+            format_result.map(|(report, summary)| {\n+                self.summary.add(summary);\n+                report\n+            })\n+        })\n+    }\n+}\n+\n+// Format an entire crate (or subset of the module tree).\n+fn format_project<T: FormatHandler>(\n+    input: Input,\n+    config: &Config,\n+    handler: &mut T,\n+) -> Result<(FormatReport, Summary), ErrorKind> {\n+    let mut summary = Summary::default();\n+    let mut timer = Timer::Initialized(Instant::now());\n+\n+    let input_is_stdin = input.is_text();\n+    let main_file = match input {\n+        Input::File(ref file) => FileName::Real(file.clone()),\n+        Input::Text(..) => FileName::Stdin,\n+    };\n+\n+    // Parse the crate.\n+    let codemap = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+    let mut parse_session = make_parse_sess(codemap.clone(), config);\n+    let krate = match parse_input(input, &parse_session, config) {\n+        Ok(krate) => krate,\n+        Err(err) => {\n+            match err {\n+                ParseError::Error(mut diagnostic) => diagnostic.emit(),\n+                ParseError::Panic => {\n+                    // Note that if you see this message and want more information,\n+                    // then go to `parse_input` and run the parse function without\n+                    // `catch_unwind` so rustfmt panics and you can get a backtrace.\n+                    should_emit_verbose(!input_is_stdin, config, || {\n+                        println!(\"The Rust parser panicked\")\n+                    });\n+                }\n+                ParseError::Recovered => {}\n+            }\n+            summary.add_parsing_error();\n+            return Err(ErrorKind::ParseError);\n+        }\n+    };\n+    timer = timer.done_parsing();\n+\n+    // Suppress error output if we have to do any further parsing.\n+    let silent_emitter = Box::new(EmitterWriter::new(\n+        Box::new(Vec::new()),\n+        Some(codemap.clone()),\n+        false,\n+        false,\n+    ));\n+    parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n+\n+    let mut context = FormatContext::new(\n+        &krate,\n+        FormatReport::new(),\n+        summary,\n+        parse_session,\n+        config,\n+        handler,\n+    );\n+\n+    let files = modules::list_files(&krate, context.parse_session.codemap())?;\n+    for (path, module) in files {\n+        if (config.skip_children() && path != main_file) || config.ignore().skip_file(&path) {\n+            continue;\n+        }\n+        should_emit_verbose(!input_is_stdin, config, || println!(\"Formatting {}\", path));\n+        let is_root = path == main_file;\n+        context.format_file(path, module, is_root)?;\n+    }\n+    timer = timer.done_formatting();\n+\n+    should_emit_verbose(!input_is_stdin, config, || {\n+        println!(\n+            \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n+            timer.get_parse_time(),\n+            timer.get_format_time(),\n+        )\n+    });\n+\n+    if context.report.has_warnings() {\n+        context.summary.add_formatting_error();\n+    }\n+    {\n+        let report_errs = &context.report.internal.borrow().1;\n+        if report_errs.has_check_errors {\n+            context.summary.add_check_error();\n+        }\n+        if report_errs.has_operational_errors {\n+            context.summary.add_operational_error();\n+        }\n+    }\n+\n+    Ok((context.report, context.summary))\n+}\n+\n+// Used for formatting files.\n+#[derive(new)]\n+struct FormatContext<'a, T: FormatHandler + 'a> {\n+    krate: &'a ast::Crate,\n+    report: FormatReport,\n+    summary: Summary,\n+    parse_session: ParseSess,\n+    config: &'a Config,\n+    handler: &'a mut T,\n+}\n+\n+impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n+    // Formats a single file/module.\n+    fn format_file(\n+        &mut self,\n+        path: FileName,\n+        module: &ast::Mod,\n+        is_root: bool,\n+    ) -> Result<(), ErrorKind> {\n+        let filemap = self\n+            .parse_session\n+            .codemap()\n+            .lookup_char_pos(module.inner.lo())\n+            .file;\n+        let big_snippet = filemap.src.as_ref().unwrap();\n+        let snippet_provider = SnippetProvider::new(filemap.start_pos, big_snippet);\n+        let mut visitor = FmtVisitor::from_codemap(\n+            &self.parse_session,\n+            &self.config,\n+            &snippet_provider,\n+            self.report.clone(),\n+        );\n+        // Format inner attributes if available.\n+        if !self.krate.attrs.is_empty() && is_root {\n+            visitor.skip_empty_lines(filemap.end_pos);\n+            if visitor.visit_attrs(&self.krate.attrs, ast::AttrStyle::Inner) {\n+                visitor.push_rewrite(module.inner, None);\n+            } else {\n+                visitor.format_separate_mod(module, &*filemap);\n+            }\n+        } else {\n+            visitor.last_pos = filemap.start_pos;\n+            visitor.skip_empty_lines(filemap.end_pos);\n+            visitor.format_separate_mod(module, &*filemap);\n+        };\n+\n+        debug_assert_eq!(\n+            visitor.line_number,\n+            ::utils::count_newlines(&visitor.buffer)\n+        );\n+\n+        // For some reason, the codemap does not include terminating\n+        // newlines so we must add one on for each file. This is sad.\n+        filemap::append_newline(&mut visitor.buffer);\n+\n+        format_lines(\n+            &mut visitor.buffer,\n+            &path,\n+            &visitor.skipped_range,\n+            &self.config,\n+            &self.report,\n+        );\n+        replace_with_system_newlines(&mut visitor.buffer, &self.config);\n+\n+        if visitor.macro_rewrite_failure {\n+            self.summary.add_macro_format_failure();\n+        }\n+\n+        self.handler.handle_formatted_file(path, visitor.buffer)\n+    }\n+}\n+\n+// Handle the results of formatting.\n+trait FormatHandler {\n+    fn handle_formatted_file(&mut self, path: FileName, result: String) -> Result<(), ErrorKind>;\n+}\n+\n+impl<'b, T: Write + 'b> FormatHandler for Session<'b, T> {\n+    // Called for each formatted file.\n+    fn handle_formatted_file(\n+        &mut self,\n+        path: FileName,\n+        mut result: String,\n+    ) -> Result<(), ErrorKind> {\n+        if let Some(ref mut out) = self.out {\n+            match filemap::write_file(&mut result, &path, out, &self.config) {\n+                Ok(b) if b => self.summary.add_diff(),\n+                Err(e) => {\n+                    // Create a new error with path_str to help users see which files failed\n+                    let err_msg = format!(\"{}: {}\", path, e);\n+                    return Err(io::Error::new(e.kind(), err_msg).into());\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        self.filemap.push((path, result));\n+        Ok(())\n+    }\n+}\n+\n pub(crate) struct FormattingError {\n     pub(crate) line: usize,\n     pub(crate) kind: ErrorKind,\n@@ -101,26 +326,181 @@ pub(crate) struct ReportedErrors {\n     pub(crate) has_check_errors: bool,\n }\n \n-fn should_emit_verbose<F>(is_stdin: bool, config: &Config, f: F)\n-where\n-    F: Fn(),\n-{\n-    if config.verbose() == Verbosity::Verbose && !is_stdin {\n-        f();\n-    }\n+/// A single span of changed lines, with 0 or more removed lines\n+/// and a vector of 0 or more inserted lines.\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct ModifiedChunk {\n+    /// The first to be removed from the original text\n+    pub line_number_orig: u32,\n+    /// The number of lines which have been replaced\n+    pub lines_removed: u32,\n+    /// The new lines\n+    pub lines: Vec<String>,\n }\n \n-/// Returns true if the line with the given line number was skipped by `#[rustfmt::skip]`.\n-fn is_skipped_line(line_number: usize, skipped_range: &[(usize, usize)]) -> bool {\n-    skipped_range\n-        .iter()\n-        .any(|&(lo, hi)| lo <= line_number && line_number <= hi)\n+/// Set of changed sections of a file.\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct ModifiedLines {\n+    /// The set of changed chunks.\n+    pub chunks: Vec<ModifiedChunk>,\n }\n \n-fn should_report_error(\n-    config: &Config,\n-    char_kind: FullCodeCharKind,\n-    is_string: bool,\n+/// A summary of a Rustfmt run.\n+#[derive(Debug, Default, Clone, Copy)]\n+pub struct Summary {\n+    // Encountered e.g. an IO error.\n+    has_operational_errors: bool,\n+\n+    // Failed to reformat code because of parsing errors.\n+    has_parsing_errors: bool,\n+\n+    // Code is valid, but it is impossible to format it properly.\n+    has_formatting_errors: bool,\n+\n+    // Code contains macro call that was unable to format.\n+    pub(crate) has_macro_format_failure: bool,\n+\n+    // Failed a check, such as the license check or other opt-in checking.\n+    has_check_errors: bool,\n+\n+    /// Formatted code differs from existing code (--check only).\n+    pub has_diff: bool,\n+}\n+\n+impl Summary {\n+    pub fn has_operational_errors(&self) -> bool {\n+        self.has_operational_errors\n+    }\n+\n+    pub fn has_parsing_errors(&self) -> bool {\n+        self.has_parsing_errors\n+    }\n+\n+    pub fn has_formatting_errors(&self) -> bool {\n+        self.has_formatting_errors\n+    }\n+\n+    pub fn has_check_errors(&self) -> bool {\n+        self.has_check_errors\n+    }\n+\n+    pub(crate) fn has_macro_formatting_failure(&self) -> bool {\n+        self.has_macro_format_failure\n+    }\n+\n+    pub fn add_operational_error(&mut self) {\n+        self.has_operational_errors = true;\n+    }\n+\n+    pub(crate) fn add_parsing_error(&mut self) {\n+        self.has_parsing_errors = true;\n+    }\n+\n+    pub(crate) fn add_formatting_error(&mut self) {\n+        self.has_formatting_errors = true;\n+    }\n+\n+    pub(crate) fn add_check_error(&mut self) {\n+        self.has_check_errors = true;\n+    }\n+\n+    pub(crate) fn add_diff(&mut self) {\n+        self.has_diff = true;\n+    }\n+\n+    pub(crate) fn add_macro_format_failure(&mut self) {\n+        self.has_macro_format_failure = true;\n+    }\n+\n+    pub fn has_no_errors(&self) -> bool {\n+        !(self.has_operational_errors\n+            || self.has_parsing_errors\n+            || self.has_formatting_errors\n+            || self.has_diff)\n+    }\n+\n+    /// Combine two summaries together.\n+    pub fn add(&mut self, other: Summary) {\n+        self.has_operational_errors |= other.has_operational_errors;\n+        self.has_formatting_errors |= other.has_formatting_errors;\n+        self.has_macro_format_failure |= other.has_macro_format_failure;\n+        self.has_parsing_errors |= other.has_parsing_errors;\n+        self.has_check_errors |= other.has_check_errors;\n+        self.has_diff |= other.has_diff;\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum Timer {\n+    Initialized(Instant),\n+    DoneParsing(Instant, Instant),\n+    DoneFormatting(Instant, Instant, Instant),\n+}\n+\n+impl Timer {\n+    fn done_parsing(self) -> Self {\n+        match self {\n+            Timer::Initialized(init_time) => Timer::DoneParsing(init_time, Instant::now()),\n+            _ => panic!(\"Timer can only transition to DoneParsing from Initialized state\"),\n+        }\n+    }\n+\n+    fn done_formatting(self) -> Self {\n+        match self {\n+            Timer::DoneParsing(init_time, parse_time) => {\n+                Timer::DoneFormatting(init_time, parse_time, Instant::now())\n+            }\n+            _ => panic!(\"Timer can only transition to DoneFormatting from DoneParsing state\"),\n+        }\n+    }\n+\n+    /// Returns the time it took to parse the source files in seconds.\n+    fn get_parse_time(&self) -> f32 {\n+        match *self {\n+            Timer::DoneParsing(init, parse_time) | Timer::DoneFormatting(init, parse_time, _) => {\n+                // This should never underflow since `Instant::now()` guarantees monotonicity.\n+                Self::duration_to_f32(parse_time.duration_since(init))\n+            }\n+            Timer::Initialized(..) => unreachable!(),\n+        }\n+    }\n+\n+    /// Returns the time it took to go from the parsed AST to the formatted output. Parsing time is\n+    /// not included.\n+    fn get_format_time(&self) -> f32 {\n+        match *self {\n+            Timer::DoneFormatting(_init, parse_time, format_time) => {\n+                Self::duration_to_f32(format_time.duration_since(parse_time))\n+            }\n+            Timer::DoneParsing(..) | Timer::Initialized(..) => unreachable!(),\n+        }\n+    }\n+\n+    fn duration_to_f32(d: Duration) -> f32 {\n+        d.as_secs() as f32 + d.subsec_nanos() as f32 / 1_000_000_000f32\n+    }\n+}\n+\n+fn should_emit_verbose<F>(is_stdin: bool, config: &Config, f: F)\n+where\n+    F: Fn(),\n+{\n+    if config.verbose() == Verbosity::Verbose && !is_stdin {\n+        f();\n+    }\n+}\n+\n+/// Returns true if the line with the given line number was skipped by `#[rustfmt::skip]`.\n+fn is_skipped_line(line_number: usize, skipped_range: &[(usize, usize)]) -> bool {\n+    skipped_range\n+        .iter()\n+        .any(|&(lo, hi)| lo <= line_number && line_number <= hi)\n+}\n+\n+fn should_report_error(\n+    config: &Config,\n+    char_kind: FullCodeCharKind,\n+    is_string: bool,\n     error_kind: &ErrorKind,\n ) -> bool {\n     let allow_error_report = if char_kind.is_comment() || is_string || error_kind.is_comment() {\n@@ -295,432 +675,52 @@ enum ParseError<'sess> {\n     Panic,\n }\n \n-impl<'b, T: Write + 'b> Session<'b, T> {\n-    pub(crate) fn format_input_inner(&mut self, input: Input) -> Result<FormatReport, ErrorKind> {\n-        if !self.config.version_meets_requirement() {\n-            return Err(ErrorKind::VersionMismatch);\n-        }\n-\n-        syntax::with_globals(|| {\n-            syntax_pos::hygiene::set_default_edition(\n-                self.config.edition().to_libsyntax_pos_edition(),\n-            );\n-\n-            if self.config.disable_all_formatting() {\n-                // When the input is from stdin, echo back the input.\n-                if let Input::Text(ref buf) = input {\n-                    if let Err(e) = io::stdout().write_all(buf.as_bytes()) {\n-                        return Err(From::from(e));\n-                    }\n-                }\n-                return Ok(FormatReport::new());\n-            }\n-\n-            let config = &self.config.clone();\n-            let format_result = format_project(input, config, self);\n+fn make_parse_sess(codemap: Rc<CodeMap>, config: &Config) -> ParseSess {\n+    let tty_handler = if config.hide_parse_errors() {\n+        let silent_emitter = Box::new(EmitterWriter::new(\n+            Box::new(Vec::new()),\n+            Some(codemap.clone()),\n+            false,\n+            false,\n+        ));\n+        Handler::with_emitter(true, false, silent_emitter)\n+    } else {\n+        let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n+        let color_cfg = if supports_color {\n+            ColorConfig::Auto\n+        } else {\n+            ColorConfig::Never\n+        };\n+        Handler::with_tty_emitter(color_cfg, true, false, Some(codemap.clone()))\n+    };\n \n-            format_result.map(|(report, summary)| {\n-                self.summary.add(summary);\n-                report\n-            })\n-        })\n-    }\n+    ParseSess::with_span_handler(tty_handler, codemap)\n }\n \n-// Handle the results of formatting.\n-trait FormatHandler {\n-    fn handle_formatted_file(&mut self, path: FileName, result: String) -> Result<(), ErrorKind>;\n-}\n+fn replace_with_system_newlines(text: &mut String, config: &Config) -> () {\n+    let style = if config.newline_style() == NewlineStyle::Native {\n+        if cfg!(windows) {\n+            NewlineStyle::Windows\n+        } else {\n+            NewlineStyle::Unix\n+        }\n+    } else {\n+        config.newline_style()\n+    };\n \n-impl<'b, T: Write + 'b> FormatHandler for Session<'b, T> {\n-    // Called for each formatted file.\n-    fn handle_formatted_file(\n-        &mut self,\n-        path: FileName,\n-        mut result: String,\n-    ) -> Result<(), ErrorKind> {\n-        if let Some(ref mut out) = self.out {\n-            match filemap::write_file(&mut result, &path, out, &self.config) {\n-                Ok(b) if b => self.summary.add_diff(),\n-                Err(e) => {\n-                    // Create a new error with path_str to help users see which files failed\n-                    let err_msg = format!(\"{}: {}\", path, e);\n-                    return Err(io::Error::new(e.kind(), err_msg).into());\n+    match style {\n+        NewlineStyle::Unix => return,\n+        NewlineStyle::Windows => {\n+            let mut transformed = String::with_capacity(text.capacity());\n+            for c in text.chars() {\n+                match c {\n+                    '\\n' => transformed.push_str(\"\\r\\n\"),\n+                    '\\r' => continue,\n+                    c => transformed.push(c),\n                 }\n-                _ => {}\n             }\n-        }\n-\n-        self.filemap.push((path, result));\n-        Ok(())\n-    }\n-}\n-\n-// Format an entire crate (or subset of the module tree).\n-fn format_project<T: FormatHandler>(\n-    input: Input,\n-    config: &Config,\n-    handler: &mut T,\n-) -> Result<(FormatReport, Summary), ErrorKind> {\n-    let mut summary = Summary::default();\n-    let mut timer = Timer::Initialized(Instant::now());\n-\n-    let input_is_stdin = input.is_text();\n-    let main_file = match input {\n-        Input::File(ref file) => FileName::Real(file.clone()),\n-        Input::Text(..) => FileName::Stdin,\n-    };\n-\n-    // Parse the crate.\n-    let codemap = Rc::new(CodeMap::new(FilePathMapping::empty()));\n-    let mut parse_session = make_parse_sess(codemap.clone(), config);\n-    let krate = match parse_input(input, &parse_session, config) {\n-        Ok(krate) => krate,\n-        Err(err) => {\n-            match err {\n-                ParseError::Error(mut diagnostic) => diagnostic.emit(),\n-                ParseError::Panic => {\n-                    // Note that if you see this message and want more information,\n-                    // then go to `parse_input` and run the parse function without\n-                    // `catch_unwind` so rustfmt panics and you can get a backtrace.\n-                    should_emit_verbose(!input_is_stdin, config, || {\n-                        println!(\"The Rust parser panicked\")\n-                    });\n-                }\n-                ParseError::Recovered => {}\n-            }\n-            summary.add_parsing_error();\n-            return Err(ErrorKind::ParseError);\n-        }\n-    };\n-    timer = timer.done_parsing();\n-\n-    // Suppress error output if we have to do any further parsing.\n-    let silent_emitter = Box::new(EmitterWriter::new(\n-        Box::new(Vec::new()),\n-        Some(codemap.clone()),\n-        false,\n-        false,\n-    ));\n-    parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n-\n-    let mut context = FormatContext::new(\n-        &krate,\n-        FormatReport::new(),\n-        summary,\n-        parse_session,\n-        config,\n-        handler,\n-    );\n-\n-    let files = modules::list_files(&krate, context.parse_session.codemap())?;\n-    for (path, module) in files {\n-        if (config.skip_children() && path != main_file) || config.ignore().skip_file(&path) {\n-            continue;\n-        }\n-        should_emit_verbose(!input_is_stdin, config, || println!(\"Formatting {}\", path));\n-        let is_root = path == main_file;\n-        context.format_file(path, module, is_root)?;\n-    }\n-    timer = timer.done_formatting();\n-\n-    should_emit_verbose(!input_is_stdin, config, || {\n-        println!(\n-            \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n-            timer.get_parse_time(),\n-            timer.get_format_time(),\n-        )\n-    });\n-\n-    if context.report.has_warnings() {\n-        context.summary.add_formatting_error();\n-    }\n-    {\n-        let report_errs = &context.report.internal.borrow().1;\n-        if report_errs.has_check_errors {\n-            context.summary.add_check_error();\n-        }\n-        if report_errs.has_operational_errors {\n-            context.summary.add_operational_error();\n-        }\n-    }\n-\n-    Ok((context.report, context.summary))\n-}\n-\n-// Used for formatting files.\n-#[derive(new)]\n-struct FormatContext<'a, T: FormatHandler + 'a> {\n-    krate: &'a ast::Crate,\n-    report: FormatReport,\n-    summary: Summary,\n-    parse_session: ParseSess,\n-    config: &'a Config,\n-    handler: &'a mut T,\n-}\n-\n-impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n-    // Formats a single file/module.\n-    fn format_file(\n-        &mut self,\n-        path: FileName,\n-        module: &ast::Mod,\n-        is_root: bool,\n-    ) -> Result<(), ErrorKind> {\n-        let filemap = self\n-            .parse_session\n-            .codemap()\n-            .lookup_char_pos(module.inner.lo())\n-            .file;\n-        let big_snippet = filemap.src.as_ref().unwrap();\n-        let snippet_provider = SnippetProvider::new(filemap.start_pos, big_snippet);\n-        let mut visitor = FmtVisitor::from_codemap(\n-            &self.parse_session,\n-            &self.config,\n-            &snippet_provider,\n-            self.report.clone(),\n-        );\n-        // Format inner attributes if available.\n-        if !self.krate.attrs.is_empty() && is_root {\n-            visitor.skip_empty_lines(filemap.end_pos);\n-            if visitor.visit_attrs(&self.krate.attrs, ast::AttrStyle::Inner) {\n-                visitor.push_rewrite(module.inner, None);\n-            } else {\n-                visitor.format_separate_mod(module, &*filemap);\n-            }\n-        } else {\n-            visitor.last_pos = filemap.start_pos;\n-            visitor.skip_empty_lines(filemap.end_pos);\n-            visitor.format_separate_mod(module, &*filemap);\n-        };\n-\n-        debug_assert_eq!(\n-            visitor.line_number,\n-            ::utils::count_newlines(&visitor.buffer)\n-        );\n-\n-        // For some reason, the codemap does not include terminating\n-        // newlines so we must add one on for each file. This is sad.\n-        filemap::append_newline(&mut visitor.buffer);\n-\n-        format_lines(\n-            &mut visitor.buffer,\n-            &path,\n-            &visitor.skipped_range,\n-            &self.config,\n-            &self.report,\n-        );\n-        replace_with_system_newlines(&mut visitor.buffer, &self.config);\n-\n-        if visitor.macro_rewrite_failure {\n-            self.summary.add_macro_format_failure();\n-        }\n-\n-        self.handler.handle_formatted_file(path, visitor.buffer)\n-    }\n-}\n-\n-fn make_parse_sess(codemap: Rc<CodeMap>, config: &Config) -> ParseSess {\n-    let tty_handler = if config.hide_parse_errors() {\n-        let silent_emitter = Box::new(EmitterWriter::new(\n-            Box::new(Vec::new()),\n-            Some(codemap.clone()),\n-            false,\n-            false,\n-        ));\n-        Handler::with_emitter(true, false, silent_emitter)\n-    } else {\n-        let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n-        let color_cfg = if supports_color {\n-            ColorConfig::Auto\n-        } else {\n-            ColorConfig::Never\n-        };\n-        Handler::with_tty_emitter(color_cfg, true, false, Some(codemap.clone()))\n-    };\n-\n-    ParseSess::with_span_handler(tty_handler, codemap)\n-}\n-\n-fn replace_with_system_newlines(text: &mut String, config: &Config) -> () {\n-    let style = if config.newline_style() == NewlineStyle::Native {\n-        if cfg!(windows) {\n-            NewlineStyle::Windows\n-        } else {\n-            NewlineStyle::Unix\n-        }\n-    } else {\n-        config.newline_style()\n-    };\n-\n-    match style {\n-        NewlineStyle::Unix => return,\n-        NewlineStyle::Windows => {\n-            let mut transformed = String::with_capacity(text.capacity());\n-            for c in text.chars() {\n-                match c {\n-                    '\\n' => transformed.push_str(\"\\r\\n\"),\n-                    '\\r' => continue,\n-                    c => transformed.push(c),\n-                }\n-            }\n-            *text = transformed;\n+            *text = transformed;\n         }\n         NewlineStyle::Native => unreachable!(),\n     }\n }\n-\n-/// A single span of changed lines, with 0 or more removed lines\n-/// and a vector of 0 or more inserted lines.\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ModifiedChunk {\n-    /// The first to be removed from the original text\n-    pub line_number_orig: u32,\n-    /// The number of lines which have been replaced\n-    pub lines_removed: u32,\n-    /// The new lines\n-    pub lines: Vec<String>,\n-}\n-\n-/// Set of changed sections of a file.\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ModifiedLines {\n-    /// The set of changed chunks.\n-    pub chunks: Vec<ModifiedChunk>,\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-enum Timer {\n-    Initialized(Instant),\n-    DoneParsing(Instant, Instant),\n-    DoneFormatting(Instant, Instant, Instant),\n-}\n-\n-impl Timer {\n-    fn done_parsing(self) -> Self {\n-        match self {\n-            Timer::Initialized(init_time) => Timer::DoneParsing(init_time, Instant::now()),\n-            _ => panic!(\"Timer can only transition to DoneParsing from Initialized state\"),\n-        }\n-    }\n-\n-    fn done_formatting(self) -> Self {\n-        match self {\n-            Timer::DoneParsing(init_time, parse_time) => {\n-                Timer::DoneFormatting(init_time, parse_time, Instant::now())\n-            }\n-            _ => panic!(\"Timer can only transition to DoneFormatting from DoneParsing state\"),\n-        }\n-    }\n-\n-    /// Returns the time it took to parse the source files in seconds.\n-    fn get_parse_time(&self) -> f32 {\n-        match *self {\n-            Timer::DoneParsing(init, parse_time) | Timer::DoneFormatting(init, parse_time, _) => {\n-                // This should never underflow since `Instant::now()` guarantees monotonicity.\n-                Self::duration_to_f32(parse_time.duration_since(init))\n-            }\n-            Timer::Initialized(..) => unreachable!(),\n-        }\n-    }\n-\n-    /// Returns the time it took to go from the parsed AST to the formatted output. Parsing time is\n-    /// not included.\n-    fn get_format_time(&self) -> f32 {\n-        match *self {\n-            Timer::DoneFormatting(_init, parse_time, format_time) => {\n-                Self::duration_to_f32(format_time.duration_since(parse_time))\n-            }\n-            Timer::DoneParsing(..) | Timer::Initialized(..) => unreachable!(),\n-        }\n-    }\n-\n-    fn duration_to_f32(d: Duration) -> f32 {\n-        d.as_secs() as f32 + d.subsec_nanos() as f32 / 1_000_000_000f32\n-    }\n-}\n-\n-/// A summary of a Rustfmt run.\n-#[derive(Debug, Default, Clone, Copy)]\n-pub struct Summary {\n-    // Encountered e.g. an IO error.\n-    has_operational_errors: bool,\n-\n-    // Failed to reformat code because of parsing errors.\n-    has_parsing_errors: bool,\n-\n-    // Code is valid, but it is impossible to format it properly.\n-    has_formatting_errors: bool,\n-\n-    // Code contains macro call that was unable to format.\n-    pub(crate) has_macro_format_failure: bool,\n-\n-    // Failed a check, such as the license check or other opt-in checking.\n-    has_check_errors: bool,\n-\n-    /// Formatted code differs from existing code (--check only).\n-    pub has_diff: bool,\n-}\n-\n-impl Summary {\n-    pub fn has_operational_errors(&self) -> bool {\n-        self.has_operational_errors\n-    }\n-\n-    pub fn has_parsing_errors(&self) -> bool {\n-        self.has_parsing_errors\n-    }\n-\n-    pub fn has_formatting_errors(&self) -> bool {\n-        self.has_formatting_errors\n-    }\n-\n-    pub fn has_check_errors(&self) -> bool {\n-        self.has_check_errors\n-    }\n-\n-    pub(crate) fn has_macro_formatting_failure(&self) -> bool {\n-        self.has_macro_format_failure\n-    }\n-\n-    pub fn add_operational_error(&mut self) {\n-        self.has_operational_errors = true;\n-    }\n-\n-    pub(crate) fn add_parsing_error(&mut self) {\n-        self.has_parsing_errors = true;\n-    }\n-\n-    pub(crate) fn add_formatting_error(&mut self) {\n-        self.has_formatting_errors = true;\n-    }\n-\n-    pub(crate) fn add_check_error(&mut self) {\n-        self.has_check_errors = true;\n-    }\n-\n-    pub(crate) fn add_diff(&mut self) {\n-        self.has_diff = true;\n-    }\n-\n-    pub(crate) fn add_macro_format_failure(&mut self) {\n-        self.has_macro_format_failure = true;\n-    }\n-\n-    pub fn has_no_errors(&self) -> bool {\n-        !(self.has_operational_errors\n-            || self.has_parsing_errors\n-            || self.has_formatting_errors\n-            || self.has_diff)\n-    }\n-\n-    /// Combine two summaries together.\n-    pub fn add(&mut self, other: Summary) {\n-        self.has_operational_errors |= other.has_operational_errors;\n-        self.has_formatting_errors |= other.has_formatting_errors;\n-        self.has_macro_format_failure |= other.has_macro_format_failure;\n-        self.has_parsing_errors |= other.has_parsing_errors;\n-        self.has_check_errors |= other.has_check_errors;\n-        self.has_diff |= other.has_diff;\n-    }\n-}"}]}