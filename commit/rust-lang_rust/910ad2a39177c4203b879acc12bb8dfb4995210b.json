{"sha": "910ad2a39177c4203b879acc12bb8dfb4995210b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMGFkMmEzOTE3N2M0MjAzYjg3OWFjYzEyYmI4ZGZiNDk5NTIxMGI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-07T11:56:07Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-07T11:56:07Z"}, "message": "Implement filling drop.", "tree": {"sha": "693c0f667c014b4750184f70256c1af501e05229", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/693c0f667c014b4750184f70256c1af501e05229"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/910ad2a39177c4203b879acc12bb8dfb4995210b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/910ad2a39177c4203b879acc12bb8dfb4995210b", "html_url": "https://github.com/rust-lang/rust/commit/910ad2a39177c4203b879acc12bb8dfb4995210b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/910ad2a39177c4203b879acc12bb8dfb4995210b/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6be14eab15242f503e56bf023237651bea43861d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6be14eab15242f503e56bf023237651bea43861d", "html_url": "https://github.com/rust-lang/rust/commit/6be14eab15242f503e56bf023237651bea43861d"}], "stats": {"total": 117, "additions": 88, "deletions": 29}, "files": [{"sha": "850ddf8aa18b0d6139030287a3876d3493a2703d", "filename": "src/interpreter.rs", "status": "modified", "additions": 67, "deletions": 27, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/910ad2a39177c4203b879acc12bb8dfb4995210b/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910ad2a39177c4203b879acc12bb8dfb4995210b/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=910ad2a39177c4203b879acc12bb8dfb4995210b", "patch": "@@ -11,9 +11,9 @@ use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::cell::RefCell;\n-use std::iter;\n use std::ops::Deref;\n use std::rc::Rc;\n+use std::{iter, mem};\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap::{self, DUMMY_SP};\n@@ -318,35 +318,37 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n \n                                 let mut arg_srcs = Vec::new();\n                                 for arg in args {\n-                                    let (src, repr) = try!(self.eval_operand_and_repr(arg));\n-                                    arg_srcs.push((src, repr.size()));\n+                                    let src = try!(self.eval_operand(arg));\n+                                    let src_ty = self.operand_ty(arg);\n+                                    arg_srcs.push((src, src_ty));\n                                 }\n \n                                 if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n                                     arg_srcs.pop();\n                                     let last_arg = args.last().unwrap();\n-                                    let (last_src, last_repr) =\n-                                        try!(self.eval_operand_and_repr(last_arg));\n-                                    match *last_repr {\n-                                        Repr::Aggregate { discr_size: 0, ref variants, .. } => {\n+                                    let last = try!(self.eval_operand(last_arg));\n+                                    let last_ty = self.operand_ty(last_arg);\n+                                    let last_repr = self.type_repr(last_ty);\n+                                    match (&last_ty.sty, last_repr) {\n+                                        (&ty::TyTuple(ref fields),\n+                                         &Repr::Aggregate { discr_size: 0, ref variants, .. }) => {\n                                             assert_eq!(variants.len(), 1);\n-                                            for field in &variants[0] {\n-                                                let src = last_src.offset(field.offset as isize);\n-                                                arg_srcs.push((src, field.size));\n+                                            for (repr, ty) in variants[0].iter().zip(fields) {\n+                                                let src = last.offset(repr.offset as isize);\n+                                                arg_srcs.push((src, ty));\n                                             }\n                                         }\n-\n-                                        _ => panic!(\"expected tuple as last argument in function with 'rust-call' ABI\"),\n+                                        ty => panic!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n                                     }\n                                 }\n \n                                 let mir = self.load_mir(resolved_def_id);\n                                 self.name_stack.push((def_id, substs, terminator.span));\n                                 self.push_stack_frame(mir, resolved_substs, return_ptr);\n \n-                                for (i, (src, size)) in arg_srcs.into_iter().enumerate() {\n+                                for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n                                     let dest = self.frame().locals[i];\n-                                    try!(self.memory.copy(src, dest, size));\n+                                    try!(self.move_(src, dest, src_ty));\n                                 }\n \n                                 TerminatorTarget::Call\n@@ -380,18 +382,37 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         }\n         self.log(1, || print!(\"need to drop {:?}\", ty));\n \n+        // TODO(tsion): Call user-defined Drop::drop impls.\n+\n         match ty.sty {\n             ty::TyBox(contents_ty) => {\n-                let contents_ptr = try!(self.memory.read_ptr(ptr));\n-                try!(self.drop(contents_ptr, contents_ty));\n-                self.log(1, || print!(\"deallocating box\"));\n-                try!(self.memory.deallocate(contents_ptr));\n+                match self.memory.read_ptr(ptr) {\n+                    Ok(contents_ptr) => {\n+                        try!(self.drop(contents_ptr, contents_ty));\n+                        self.log(1, || print!(\"deallocating box\"));\n+                        try!(self.memory.deallocate(contents_ptr));\n+                    }\n+                    Err(EvalError::ReadBytesAsPointer) => {\n+                        let possible_drop_fill = try!(self.memory.read_usize(ptr));\n+                        if possible_drop_fill == mem::POST_DROP_U64 {\n+                            return Ok(());\n+                        } else {\n+                            return Err(EvalError::ReadBytesAsPointer);\n+                        }\n+                    }\n+                    Err(e) => return Err(e),\n+                }\n             }\n \n             // TODO(tsion): Implement drop for other relevant types (e.g. aggregates).\n             _ => {}\n         }\n \n+        // Filling drop.\n+        // FIXME(tsion): Trait objects (with no static size) probably get filled, too.\n+        let size = self.type_size(ty);\n+        try!(self.memory.drop_fill(ptr, size));\n+\n         Ok(())\n     }\n \n@@ -420,18 +441,22 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                 try!(self.memory.copy(src, dest, count as usize * elem_size));\n             }\n \n-            // TODO(tsion): Mark as dropped?\n-            \"forget\" => {}\n+            \"forget\" => {\n+                let arg_ty = *substs.types.get(subst::FnSpace, 0);\n+                let arg_size = self.type_size(arg_ty);\n+                try!(self.memory.drop_fill(args[0], arg_size));\n+            }\n+\n+            \"init\" => try!(self.memory.write_repeat(dest, 0, dest_size)),\n \n             \"min_align_of\" => {\n                 try!(self.memory.write_int(dest, 1, dest_size));\n             }\n \n             \"move_val_init\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n                 let ptr = try!(self.memory.read_ptr(args[0]));\n-                try!(self.memory.copy(args[1], ptr, size));\n+                try!(self.move_(args[1], ptr, ty));\n             }\n \n             // FIXME(tsion): Handle different integer types correctly.\n@@ -496,7 +521,10 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                 try!(self.memory.write_uint(dest, size, dest_size));\n             }\n \n-            \"transmute\" => try!(self.memory.copy(args[0], dest, dest_size)),\n+            \"transmute\" => {\n+                let ty = *substs.types.get(subst::FnSpace, 0);\n+                try!(self.move_(args[0], dest, ty));\n+            }\n             \"uninit\" => try!(self.memory.mark_definedness(dest, dest_size, false)),\n \n             name => panic!(\"can't handle intrinsic: {}\", name),\n@@ -565,8 +593,9 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                 let after_discr = dest.offset(discr_size as isize);\n                 for (field, operand) in variants[variant].iter().zip(operands) {\n                     let src = try!(self.eval_operand(operand));\n+                    let src_ty = self.operand_ty(operand);\n                     let field_dest = after_discr.offset(field.offset as isize);\n-                    try!(self.memory.copy(src, field_dest, field.size));\n+                    try!(self.move_(src, field_dest, src_ty));\n                 }\n             }\n             _ => panic!(\"expected Repr::Aggregate target\"),\n@@ -578,13 +607,14 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         -> EvalResult<()>\n     {\n         let dest = try!(self.eval_lvalue(lvalue)).to_ptr();\n+        let dest_ty = self.lvalue_ty(lvalue);\n         let dest_repr = self.lvalue_repr(lvalue);\n \n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n             Use(ref operand) => {\n                 let src = try!(self.eval_operand(operand));\n-                try!(self.memory.copy(src, dest, dest_repr.size()));\n+                try!(self.move_(src, dest, dest_ty));\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n@@ -622,8 +652,9 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                         assert_eq!(length, operands.len());\n                         for (i, operand) in operands.iter().enumerate() {\n                             let src = try!(self.eval_operand(operand));\n+                            let src_ty = self.operand_ty(operand);\n                             let elem_dest = dest.offset((i * elem_size) as isize);\n-                            try!(self.memory.copy(src, elem_dest, elem_size));\n+                            try!(self.move_(src, elem_dest, src_ty));\n                         }\n                     } else {\n                         panic!(\"expected Repr::Array target\");\n@@ -683,7 +714,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                 use rustc::mir::repr::CastKind::*;\n                 match kind {\n                     Unsize => {\n-                        try!(self.memory.copy(src, dest, 8));\n+                        try!(self.move_(src, dest, src_ty));\n                         let src_pointee_ty = pointee_type(src_ty).unwrap();\n                         let dest_pointee_ty = pointee_type(dest_ty).unwrap();\n \n@@ -875,6 +906,15 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n     }\n \n+    fn move_(&mut self, src: Pointer, dest: Pointer, ty: ty::Ty<'tcx>) -> EvalResult<()> {\n+        let size = self.type_size(ty);\n+        try!(self.memory.copy(src, dest, size));\n+        if self.type_needs_drop(ty) {\n+            try!(self.memory.drop_fill(src, size));\n+        }\n+        Ok(())\n+    }\n+\n     fn type_is_sized(&self, ty: ty::Ty<'tcx>) -> bool {\n         ty.is_sized(&self.tcx.empty_parameter_environment(), DUMMY_SP)\n     }"}, {"sha": "8ddafb49911155e34943389a95ec57d5ec4378c8", "filename": "src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/910ad2a39177c4203b879acc12bb8dfb4995210b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910ad2a39177c4203b879acc12bb8dfb4995210b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=910ad2a39177c4203b879acc12bb8dfb4995210b", "patch": "@@ -1,4 +1,11 @@\n-#![feature(btree_range, collections, collections_bound, core_intrinsics, rustc_private)]\n+#![feature(\n+    btree_range,\n+    collections,\n+    collections_bound,\n+    core_intrinsics,\n+    filling_drop,\n+    rustc_private,\n+)]\n \n // From rustc.\n extern crate arena;"}, {"sha": "2a2956bbb4c468592e33a7106fd8d7761e36ff46", "filename": "src/memory.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/910ad2a39177c4203b879acc12bb8dfb4995210b/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910ad2a39177c4203b879acc12bb8dfb4995210b/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=910ad2a39177c4203b879acc12bb8dfb4995210b", "patch": "@@ -279,7 +279,19 @@ impl Memory {\n     }\n \n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<()> {\n-        self.get_bytes_mut(ptr, src.len()).map(|dest| dest.clone_from_slice(src))\n+        let bytes = try!(self.get_bytes_mut(ptr, src.len()));\n+        bytes.clone_from_slice(src);\n+        Ok(())\n+    }\n+\n+    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: usize) -> EvalResult<()> {\n+        let bytes = try!(self.get_bytes_mut(ptr, count));\n+        for b in bytes { *b = val; }\n+        Ok(())\n+    }\n+\n+    pub fn drop_fill(&mut self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+        self.write_repeat(ptr, mem::POST_DROP_U8, size)\n     }\n \n     pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<Pointer> {"}]}