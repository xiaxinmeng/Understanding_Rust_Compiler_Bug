{"sha": "8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf", "node_id": "C_kwDOAAsO6NoAKDhmYzViYTY1ZTFhNmYyZTc2MDBjOTg1NzlkNGEwZjQ4ODU2MGM1YmY", "commit": {"author": {"name": "Nikita Tomashevich", "email": "quant3234@gmail.com", "date": "2023-01-18T13:34:08Z"}, "committer": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-02-14T15:31:45Z"}, "message": "Port OutlivesContent, OutlivesBound, FUllfillReqLifetime, LfBoundNotSatisfied diagnostics", "tree": {"sha": "5b3022cfc1c8dc724bf81d646072923166414fee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b3022cfc1c8dc724bf81d646072923166414fee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf", "html_url": "https://github.com/rust-lang/rust/commit/8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf/comments", "author": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bb6e60d1f1360234aae90c97964c0fa5524f141", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb6e60d1f1360234aae90c97964c0fa5524f141", "html_url": "https://github.com/rust-lang/rust/commit/9bb6e60d1f1360234aae90c97964c0fa5524f141"}], "stats": {"total": 207, "additions": 131, "deletions": 76}, "files": [{"sha": "505dd9804944463d0cdb0586b0f5068b7304429a", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf", "patch": "@@ -140,6 +140,14 @@ infer_lifetime_param_suggestion_elided = each elided lifetime in input position\n \n infer_region_explanation = {$pref_kind ->\n     *[should_not_happen] [{$pref_kind}]\n+    [ref_valid_for] ...the reference is valid for\n+    [content_valid_for] ...but the borrowed content is only valid for\n+    [type_valid_for] object type is valid for\n+    [source_pointer_valid_for] source pointer is only valid for\n+    [type_satisfy] type must satisfy\n+    [type_outlive] type must outlive\n+    [lf_instantiated_with] lifetime parameter instantiated with\n+    [lf_must_outlive] but lifetime parameter must outlive\n     [empty] {\"\"}\n }{$pref_kind ->\n     [empty] {\"\"}\n@@ -158,8 +166,14 @@ infer_region_explanation = {$pref_kind ->\n     *[should_not_happen] [{$suff_kind}]\n     [empty]{\"\"}\n     [continues] ...\n+    [req_by_binding] {\" \"}as required by this binding\n }\n \n+infer_outlives_content = lifetime of reference outlives lifetime of borrowed content...\n+infer_outlives_bound = lifetime of the source pointer does not outlive lifetime bound of the object type\n+infer_fullfill_req_lifetime = the type `{$ty}` does not fulfill the required lifetime\n+infer_lf_bound_not_satisfied = lifetime bound not satisfied\n+\n infer_mismatched_static_lifetime = incompatible lifetime on type\n infer_does_not_outlive_static_from_impl = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n infer_implicit_static_lifetime_note = this has an implicit `'static` lifetime requirement"}, {"sha": "ae2985d456b79d9f93fda8fef3040605609af51b", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf", "patch": "@@ -933,3 +933,40 @@ pub struct ButNeedsToSatisfy {\n     pub has_lifetime: bool,\n     pub lifetime: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_outlives_content, code = \"E0312\")]\n+pub struct OutlivesContent<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_outlives_bound, code = \"E0476\")]\n+pub struct OutlivesBound<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_fullfill_req_lifetime, code = \"E0477\")]\n+pub struct FullfillReqLifetime<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'a>,\n+    #[subdiagnostic]\n+    pub note: Option<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_lf_bound_not_satisfied, code = \"E0478\")]\n+pub struct LfBoundNotSatisfied<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}"}, {"sha": "c60eee609946b6538ca3a0889280cd4c8f549db6", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf", "patch": "@@ -121,16 +121,34 @@ impl<'a> DescriptionCtx<'a> {\n \n pub enum PrefixKind {\n     Empty,\n+    RefValidFor,\n+    ContentValidFor,\n+    TypeValidFor,\n+    SourcePointerValidFor,\n+    TypeSatisfy,\n+    TypeOutlive,\n+    LfInstantiatedWith,\n+    LfMustOutlive,\n }\n \n pub enum SuffixKind {\n+    Empty,\n     Continues,\n+    ReqByBinding,\n }\n \n impl IntoDiagnosticArg for PrefixKind {\n     fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n         let kind = match self {\n             Self::Empty => \"empty\",\n+            Self::RefValidFor => \"ref_valid_for\",\n+            Self::ContentValidFor => \"content_valid_for\",\n+            Self::TypeValidFor => \"type_valid_for\",\n+            Self::SourcePointerValidFor => \"source_pointer_valid_for\",\n+            Self::TypeSatisfy => \"type_satisfy\",\n+            Self::TypeOutlive => \"type_outlive\",\n+            Self::LfInstantiatedWith => \"lf_instantiated_with\",\n+            Self::LfMustOutlive => \"lf_must_outlive\",\n         }\n         .into();\n         rustc_errors::DiagnosticArgValue::Str(kind)\n@@ -140,7 +158,9 @@ impl IntoDiagnosticArg for PrefixKind {\n impl IntoDiagnosticArg for SuffixKind {\n     fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n         let kind = match self {\n+            Self::Empty => \"empty\",\n             Self::Continues => \"continues\",\n+            Self::ReqByBinding => \"req_by_binding\",\n         }\n         .into();\n         rustc_errors::DiagnosticArgValue::Str(kind)\n@@ -166,17 +186,19 @@ impl RegionExplanation<'_> {\n }\n \n impl AddToDiagnostic for RegionExplanation<'_> {\n-    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n     where\n         F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n     {\n-        if let Some(span) = self.desc.span {\n-            diag.span_note(span, fluent::infer_region_explanation);\n-        } else {\n-            diag.note(fluent::infer_region_explanation);\n-        }\n-        self.desc.add_to(diag);\n         diag.set_arg(\"pref_kind\", self.prefix);\n         diag.set_arg(\"suff_kind\", self.suffix);\n+        let desc_span = self.desc.span;\n+        self.desc.add_to(diag);\n+        let msg = f(diag, fluent::infer_region_explanation.into());\n+        if let Some(span) = desc_span {\n+            diag.span_note(span, msg);\n+        } else {\n+            diag.note(msg);\n+        }\n     }\n }"}, {"sha": "c2b936c3402a245aa014f5eacddee8759207dd71", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 51, "deletions": 69, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=8fc5ba65e1a6f2e7600c98579d4a0f488560c5bf", "patch": "@@ -1,9 +1,12 @@\n-use crate::errors::RegionOriginNote;\n+use crate::errors::{\n+    note_and_explain, FullfillReqLifetime, LfBoundNotSatisfied, OutlivesBound, OutlivesContent,\n+    RegionOriginNote,\n+};\n use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n use crate::infer::{self, SubregionOrigin};\n use rustc_errors::{\n     fluent, struct_span_err, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder,\n-    ErrorGuaranteed,\n+    ErrorGuaranteed, IntoDiagnostic,\n };\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::traits::ObligationCauseCode;\n@@ -119,104 +122,83 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 err\n             }\n             infer::Reborrow(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0312,\n-                    \"lifetime of reference outlives lifetime of borrowed content...\"\n-                );\n-                note_and_explain_region(\n+                let reference_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"...the reference is valid for \",\n                     sub,\n-                    \"...\",\n                     None,\n+                    note_and_explain::PrefixKind::RefValidFor,\n+                    note_and_explain::SuffixKind::Continues,\n                 );\n-                note_and_explain_region(\n+                let content_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"...but the borrowed content is only valid for \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::ContentValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                OutlivesContent {\n+                    span,\n+                    notes: reference_valid.into_iter().chain(content_valid).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateObjectBound(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0476,\n-                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n-                     object type\"\n-                );\n-                note_and_explain_region(\n+                let object_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"object type is valid for \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::TypeValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let pointer_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"source pointer is only valid for \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::SourcePointerValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                OutlivesBound {\n+                    span,\n+                    notes: object_valid.into_iter().chain(pointer_valid).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateParamBound(span, ty, opt_span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0477,\n-                    \"the type `{}` does not fulfill the required lifetime\",\n-                    self.ty_to_string(ty)\n+                let prefix = match *sub {\n+                    ty::ReStatic => note_and_explain::PrefixKind::TypeSatisfy,\n+                    _ => note_and_explain::PrefixKind::TypeOutlive,\n+                };\n+                let suffix = if opt_span.is_some() {\n+                    note_and_explain::SuffixKind::ReqByBinding\n+                } else {\n+                    note_and_explain::SuffixKind::Empty\n+                };\n+                let note = note_and_explain::RegionExplanation::new(\n+                    self.tcx, sub, opt_span, prefix, suffix,\n                 );\n-                match *sub {\n-                    ty::ReStatic => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must satisfy \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                    _ => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must outlive \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                }\n-                err\n+                FullfillReqLifetime { span, ty: self.resolve_vars_if_possible(ty), note }\n+                    .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateRegionParamBound(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n+                let param_instantiated = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"lifetime parameter instantiated with \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfInstantiatedWith,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let param_must_outlive = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"but lifetime parameter must outlive \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfMustOutlive,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                LfBoundNotSatisfied {\n+                    span,\n+                    notes: param_instantiated.into_iter().chain(param_must_outlive).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 let mut err = struct_span_err!("}]}