{"sha": "8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNDNiMzE4YmYzMGMyNmY0ZTlmMzU1N2I2YzcwMzZmY2I5ZDUzNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-03T20:34:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-03T20:34:56Z"}, "message": "auto merge of #6826 : cmr/rust/terminfo, r=thestinger\n\nThis will let *everyone* (non-windows, at least) who can see colors see the glorious colors rustc produces.", "tree": {"sha": "402e0be1b130574e325c772b0ab8e8346566d0fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/402e0be1b130574e325c772b0ab8e8346566d0fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "html_url": "https://github.com/rust-lang/rust/commit/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c68c015798998448dd51af138f4a223fb94ea387", "url": "https://api.github.com/repos/rust-lang/rust/commits/c68c015798998448dd51af138f4a223fb94ea387", "html_url": "https://github.com/rust-lang/rust/commit/c68c015798998448dd51af138f4a223fb94ea387"}, {"sha": "ae5f3de5f00368cd8c5e62a472ab0062115d97df", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae5f3de5f00368cd8c5e62a472ab0062115d97df", "html_url": "https://github.com/rust-lang/rust/commit/ae5f3de5f00368cd8c5e62a472ab0062115d97df"}], "stats": {"total": 875, "additions": 794, "deletions": 81}, "files": [{"sha": "4e9a547e14119e3673853c0ac5b6ddf5ce9588a1", "filename": "src/libextra/std.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstd.rc?ref=8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "patch": "@@ -118,6 +118,8 @@ pub mod flate;\n #[cfg(unicode)]\n mod unicode;\n \n+#[path=\"terminfo/terminfo.rs\"]\n+pub mod terminfo;\n \n // Compiler support modules\n "}, {"sha": "e74a0f4e18e12e7450b908f5c4b0cceef43980d6", "filename": "src/libextra/term.rs", "status": "modified", "additions": 84, "deletions": 33, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -15,9 +15,13 @@\n use core::prelude::*;\n \n use core::io;\n-use core::option;\n use core::os;\n \n+use terminfo::*;\n+use terminfo::searcher::open;\n+use terminfo::parser::compiled::parse;\n+use terminfo::parm::{expand, Number};\n+\n // FIXME (#2807): Windows support.\n \n pub static color_black: u8 = 0u8;\n@@ -39,43 +43,90 @@ pub static color_bright_magenta: u8 = 13u8;\n pub static color_bright_cyan: u8 = 14u8;\n pub static color_bright_white: u8 = 15u8;\n \n-pub fn esc(writer: @io::Writer) { writer.write([0x1bu8, '[' as u8]); }\n+#[cfg(not(target_os = \"win32\"))]\n+pub struct Terminal {\n+    color_supported: bool,\n+    priv out: @io::Writer,\n+    priv ti: ~TermInfo\n+}\n \n-/// Reset the foreground and background colors to default\n-pub fn reset(writer: @io::Writer) {\n-    esc(writer);\n-    writer.write(['0' as u8, 'm' as u8]);\n+#[cfg(target_os = \"win32\")]\n+pub struct Terminal {\n+    color_supported: bool,\n+    priv out: @io::Writer,\n }\n \n-/// Returns true if the terminal supports color\n-pub fn color_supported() -> bool {\n-    let supported_terms = ~[~\"xterm-color\", ~\"xterm\",\n-                           ~\"screen-bce\", ~\"xterm-256color\"];\n-    return match os::getenv(\"TERM\") {\n-          option::Some(ref env) => {\n-            for supported_terms.each |term| {\n-                if *term == *env { return true; }\n+#[cfg(not(target_os = \"win32\"))]\n+pub impl Terminal {\n+    pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n+        let term = os::getenv(\"TERM\");\n+        if term.is_none() {\n+            return Err(~\"TERM environment variable undefined\");\n+        }\n+\n+        let entry = open(term.unwrap());\n+        if entry.is_err() {\n+            return Err(entry.get_err());\n+        }\n+\n+        let ti = parse(entry.get(), false);\n+        if ti.is_err() {\n+            return Err(entry.get_err());\n+        }\n+\n+        let mut inf = ti.get();\n+        let cs = *inf.numbers.find_or_insert(~\"colors\", 0) >= 16\n+            && inf.strings.find(&~\"setaf\").is_some()\n+            && inf.strings.find_equiv(&(\"setab\")).is_some();\n+\n+        return Ok(Terminal {out: out, ti: inf, color_supported: cs});\n+    }\n+    fn fg(&self, color: u8) {\n+        if self.color_supported {\n+            let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n+                           [Number(color as int)], [], []);\n+            if s.is_ok() {\n+                self.out.write(s.get());\n+            } else {\n+                warn!(s.get_err());\n             }\n-            false\n-          }\n-          option::None => false\n-        };\n+        }\n+    }\n+    fn bg(&self, color: u8) {\n+        if self.color_supported {\n+            let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n+                           [Number(color as int)], [], []);\n+            if s.is_ok() {\n+                self.out.write(s.get());\n+            } else {\n+                warn!(s.get_err());\n+            }\n+        }\n+    }\n+    fn reset(&self) {\n+        if self.color_supported {\n+            let s = expand(*self.ti.strings.find_equiv(&(\"op\")).unwrap(), [], [], []);\n+            if s.is_ok() {\n+                self.out.write(s.get());\n+            } else {\n+                warn!(s.get_err());\n+            }\n+        }\n+    }\n }\n \n-pub fn set_color(writer: @io::Writer, first_char: u8, color: u8) {\n-    assert!((color < 16u8));\n-    esc(writer);\n-    let mut color = color;\n-    if color >= 8u8 { writer.write(['1' as u8, ';' as u8]); color -= 8u8; }\n-    writer.write([first_char, ('0' as u8) + color, 'm' as u8]);\n-}\n+#[cfg(target_os = \"win32\")]\n+pub impl Terminal {\n+    pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n+        return Ok(Terminal {out: out, color_supported: false});\n+    }\n \n-/// Set the foreground color\n-pub fn fg(writer: @io::Writer, color: u8) {\n-    return set_color(writer, '3' as u8, color);\n-}\n+    fn fg(&self, color: u8) {\n+    }\n+\n+    fn bg(&self, color: u8) {\n+    }\n \n-/// Set the background color\n-pub fn bg(writer: @io::Writer, color: u8) {\n-    return set_color(writer, '4' as u8, color);\n+    fn reset(&self) {\n+    }\n }"}, {"sha": "4eb48f60a99992a6fba888f2e3370ebcd992b4d7", "filename": "src/libextra/terminfo/parm.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "patch": "@@ -0,0 +1,209 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Parameterized string expansion\n+\n+use core::prelude::*;\n+use core::{char, int, vec};\n+\n+#[deriving(Eq)]\n+enum States {\n+    Nothing,\n+    Percent,\n+    SetVar,\n+    GetVar,\n+    PushParam,\n+    CharConstant,\n+    CharClose,\n+    IntConstant,\n+    IfCond,\n+    IfBody\n+}\n+\n+/// Types of parameters a capability can use\n+pub enum Param {\n+    String(~str),\n+    Char(char),\n+    Number(int)\n+}\n+\n+/**\n+  Expand a parameterized capability\n+\n+  # Arguments\n+  * `cap`    - string to expand\n+  * `params` - vector of params for %p1 etc\n+  * `sta`    - vector of params corresponding to static variables\n+  * `dyn`    - vector of params corresponding to stativ variables\n+\n+  To be compatible with ncurses, `sta` and `dyn` should be the same between calls to `expand` for\n+  multiple capabilities for the same terminal.\n+  */\n+pub fn expand(cap: &[u8], params: &mut [Param], sta: &mut [Param], dyn: &mut [Param])\n+    -> Result<~[u8], ~str> {\n+    assert!(cap.len() != 0, \"expanding an empty capability makes no sense\");\n+    assert!(params.len() <= 9, \"only 9 parameters are supported by capability strings\");\n+\n+    assert!(sta.len() <= 26, \"only 26 static vars are able to be used by capability strings\");\n+    assert!(dyn.len() <= 26, \"only 26 dynamic vars are able to be used by capability strings\");\n+\n+    let mut state = Nothing;\n+    let mut i = 0;\n+\n+    // expanded cap will only rarely be smaller than the cap itself\n+    let mut output = vec::with_capacity(cap.len());\n+\n+    let mut cur;\n+\n+    let mut stack: ~[Param] = ~[];\n+\n+    let mut intstate = ~[];\n+\n+    while i < cap.len() {\n+        cur = cap[i] as char;\n+        let mut old_state = state;\n+        match state {\n+            Nothing => {\n+                if cur == '%' {\n+                    state = Percent;\n+                } else {\n+                    output.push(cap[i]);\n+                }\n+            },\n+            Percent => {\n+                match cur {\n+                    '%' => { output.push(cap[i]); state = Nothing },\n+                    'c' => match stack.pop() {\n+                        Char(c) => output.push(c as u8),\n+                        _       => return Err(~\"a non-char was used with %c\")\n+                    },\n+                    's' => match stack.pop() {\n+                        String(s) => output.push_all(s.to_bytes()),\n+                        _         => return Err(~\"a non-str was used with %s\")\n+                    },\n+                    'd' => match stack.pop() {\n+                        Number(x) => output.push_all(x.to_str().to_bytes()),\n+                        _         => return Err(~\"a non-number was used with %d\")\n+                    },\n+                    'p' => state = PushParam,\n+                    'P' => state = SetVar,\n+                    'g' => state = GetVar,\n+                    '\\'' => state = CharConstant,\n+                    '{' => state = IntConstant,\n+                    'l' => match stack.pop() {\n+                        String(s) => stack.push(Number(s.len() as int)),\n+                        _         => return Err(~\"a non-str was used with %l\")\n+                    },\n+                    '+' => match (stack.pop(), stack.pop()) {\n+                        (Number(x), Number(y)) => stack.push(Number(x + y)),\n+                        (_, _) => return Err(~\"non-numbers on stack with +\")\n+                    },\n+                    '-' => match (stack.pop(), stack.pop()) {\n+                        (Number(x), Number(y)) => stack.push(Number(x - y)),\n+                        (_, _) => return Err(~\"non-numbers on stack with -\")\n+                    },\n+                    '*' => match (stack.pop(), stack.pop()) {\n+                        (Number(x), Number(y)) => stack.push(Number(x * y)),\n+                        (_, _) => return Err(~\"non-numbers on stack with *\")\n+                    },\n+                    '/' => match (stack.pop(), stack.pop()) {\n+                        (Number(x), Number(y)) => stack.push(Number(x / y)),\n+                        (_, _) => return Err(~\"non-numbers on stack with /\")\n+                    },\n+                    'm' => match (stack.pop(), stack.pop()) {\n+                        (Number(x), Number(y)) => stack.push(Number(x % y)),\n+                        (_, _) => return Err(~\"non-numbers on stack with %\")\n+                    },\n+                    '&' => match (stack.pop(), stack.pop()) {\n+                        (Number(x), Number(y)) => stack.push(Number(x & y)),\n+                        (_, _) => return Err(~\"non-numbers on stack with &\")\n+                    },\n+                    '|' => match (stack.pop(), stack.pop()) {\n+                        (Number(x), Number(y)) => stack.push(Number(x | y)),\n+                        (_, _) => return Err(~\"non-numbers on stack with |\")\n+                    },\n+                    'A' => return Err(~\"logical operations unimplemented\"),\n+                    'O' => return Err(~\"logical operations unimplemented\"),\n+                    '!' => return Err(~\"logical operations unimplemented\"),\n+                    '~' => match stack.pop() {\n+                        Number(x) => stack.push(Number(!x)),\n+                        _         => return Err(~\"non-number on stack with %~\")\n+                    },\n+                    'i' => match (copy params[0], copy params[1]) {\n+                        (Number(x), Number(y)) => {\n+                            params[0] = Number(x + 1);\n+                            params[1] = Number(y + 1);\n+                        },\n+                        (_, _) => return Err(~\"first two params not numbers with %i\")\n+                    },\n+                    '?' => state = return Err(fmt!(\"if expressions unimplemented (%?)\", cap)),\n+                    _ => return Err(fmt!(\"unrecognized format option %c\", cur))\n+                }\n+            },\n+            PushParam => {\n+                // params are 1-indexed\n+                stack.push(copy params[char::to_digit(cur, 10).expect(\"bad param number\") - 1]);\n+            },\n+            SetVar => {\n+                if cur >= 'A' && cur <= 'Z' {\n+                    let idx = (cur as u8) - ('A' as u8);\n+                    sta[idx] = stack.pop();\n+                } else if cur >= 'a' && cur <= 'z' {\n+                    let idx = (cur as u8) - ('a' as u8);\n+                    dyn[idx] = stack.pop();\n+                } else {\n+                    return Err(~\"bad variable name in %P\");\n+                }\n+            },\n+            GetVar => {\n+                if cur >= 'A' && cur <= 'Z' {\n+                    let idx = (cur as u8) - ('A' as u8);\n+                    stack.push(copy sta[idx]);\n+                } else if cur >= 'a' && cur <= 'z' {\n+                    let idx = (cur as u8) - ('a' as u8);\n+                    stack.push(copy dyn[idx]);\n+                } else {\n+                    return Err(~\"bad variable name in %g\");\n+                }\n+            },\n+            CharConstant => {\n+                stack.push(Char(cur));\n+                state = CharClose;\n+            },\n+            CharClose => {\n+                assert!(cur == '\\'', \"malformed character constant\");\n+            },\n+            IntConstant => {\n+                if cur == '}' {\n+                    stack.push(Number(int::parse_bytes(intstate, 10).expect(\"bad int constant\")));\n+                    state = Nothing;\n+                }\n+                intstate.push(cur as u8);\n+                old_state = Nothing;\n+            }\n+            _ => return Err(~\"unimplemented state\")\n+        }\n+        if state == old_state {\n+            state = Nothing;\n+        }\n+        i += 1;\n+    }\n+    Ok(output)\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    #[test]\n+    fn test_basic_setabf() {\n+        let s = bytes!(\"\\\\E[48;5;%p1%dm\");\n+        assert_eq!(expand(s, [Number(1)], [], []).unwrap(), bytes!(\"\\\\E[48;5;1m\").to_owned());\n+    }\n+}"}, {"sha": "10b6d3860852b4a115efee48a3238806ca5fcd1f", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "patch": "@@ -0,0 +1,332 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// ncurses-compatible compiled terminfo format parsing (term(5))\n+\n+use core::prelude::*;\n+\n+use core::{vec, int, str};\n+use core::io::Reader;\n+use core::hashmap::HashMap;\n+use super::super::TermInfo;\n+\n+// These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n+\n+pub static boolfnames: &'static[&'static str] = &'static[\"auto_left_margin\", \"auto_right_margin\",\n+    \"no_esc_ctlc\", \"ceol_standout_glitch\", \"eat_newline_glitch\", \"erase_overstrike\", \"generic_type\",\n+    \"hard_copy\", \"has_meta_key\", \"has_status_line\", \"insert_null_glitch\", \"memory_above\",\n+    \"memory_below\", \"move_insert_mode\", \"move_standout_mode\", \"over_strike\", \"status_line_esc_ok\",\n+    \"dest_tabs_magic_smso\", \"tilde_glitch\", \"transparent_underline\", \"xon_xoff\", \"needs_xon_xoff\",\n+    \"prtr_silent\", \"hard_cursor\", \"non_rev_rmcup\", \"no_pad_char\", \"non_dest_scroll_region\",\n+    \"can_change\", \"back_color_erase\", \"hue_lightness_saturation\", \"col_addr_glitch\",\n+    \"cr_cancels_micro_mode\", \"has_print_wheel\", \"row_addr_glitch\", \"semi_auto_right_margin\",\n+    \"cpi_changes_res\", \"lpi_changes_res\", \"backspaces_with_bs\", \"crt_no_scrolling\",\n+    \"no_correctly_working_cr\", \"gnu_has_meta_key\", \"linefeed_is_newline\", \"has_hardware_tabs\",\n+    \"return_does_clr_eol\"];\n+\n+pub static boolnames: &'static[&'static str] = &'static[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n+    \"gn\", \"hc\", \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\", \"msgr\", \"os\", \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\",\n+    \"nxon\", \"mc5i\", \"chts\", \"nrrmc\", \"npc\", \"ndscr\", \"ccc\", \"bce\", \"hls\", \"xhpa\", \"crxm\", \"daisy\",\n+    \"xvpa\", \"sam\", \"cpix\", \"lpix\", \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\", \"OTNL\", \"OTpt\", \"OTxr\"];\n+\n+pub static numfnames: &'static[&'static str] = &'static[ \"columns\", \"init_tabs\", \"lines\",\n+    \"lines_of_memory\", \"magic_cookie_glitch\", \"padding_baud_rate\", \"virtual_terminal\",\n+    \"width_status_line\", \"num_labels\", \"label_height\", \"label_width\", \"max_attributes\",\n+    \"maximum_windows\", \"max_colors\", \"max_pairs\", \"no_color_video\", \"buffer_capacity\",\n+    \"dot_vert_spacing\", \"dot_horz_spacing\", \"max_micro_address\", \"max_micro_jump\", \"micro_col_size\",\n+    \"micro_line_size\", \"number_of_pins\", \"output_res_char\", \"output_res_line\",\n+    \"output_res_horz_inch\", \"output_res_vert_inch\", \"print_rate\", \"wide_char_size\", \"buttons\",\n+    \"bit_image_entwining\", \"bit_image_type\", \"magic_cookie_glitch_ul\", \"carriage_return_delay\",\n+    \"new_line_delay\", \"backspace_delay\", \"horizontal_tab_delay\", \"number_of_function_keys\"];\n+\n+pub static numnames: &'static[&'static str] = &'static[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n+    \"vt\", \"wsl\", \"nlab\", \"lh\", \"lw\", \"ma\", \"wnum\", \"colors\", \"pairs\", \"ncv\", \"bufsz\", \"spinv\",\n+    \"spinh\", \"maddr\", \"mjump\", \"mcs\", \"mls\", \"npins\", \"orc\", \"orl\", \"orhi\", \"orvi\", \"cps\", \"widcs\",\n+    \"btns\", \"bitwin\", \"bitype\", \"UTug\", \"OTdC\", \"OTdN\", \"OTdB\", \"OTdT\", \"OTkn\"];\n+\n+pub static stringfnames: &'static[&'static str] = &'static[ \"back_tab\", \"bell\", \"carriage_return\",\n+    \"change_scroll_region\", \"clear_all_tabs\", \"clear_screen\", \"clr_eol\", \"clr_eos\",\n+    \"column_address\", \"command_character\", \"cursor_address\", \"cursor_down\", \"cursor_home\",\n+    \"cursor_invisible\", \"cursor_left\", \"cursor_mem_address\", \"cursor_normal\", \"cursor_right\",\n+    \"cursor_to_ll\", \"cursor_up\", \"cursor_visible\", \"delete_character\", \"delete_line\",\n+    \"dis_status_line\", \"down_half_line\", \"enter_alt_charset_mode\", \"enter_blink_mode\",\n+    \"enter_bold_mode\", \"enter_ca_mode\", \"enter_delete_mode\", \"enter_dim_mode\", \"enter_insert_mode\",\n+    \"enter_secure_mode\", \"enter_protected_mode\", \"enter_reverse_mode\", \"enter_standout_mode\",\n+    \"enter_underline_mode\", \"erase_chars\", \"exit_alt_charset_mode\", \"exit_attribute_mode\",\n+    \"exit_ca_mode\", \"exit_delete_mode\", \"exit_insert_mode\", \"exit_standout_mode\",\n+    \"exit_underline_mode\", \"flash_screen\", \"form_feed\", \"from_status_line\", \"init_1string\",\n+    \"init_2string\", \"init_3string\", \"init_file\", \"insert_character\", \"insert_line\",\n+    \"insert_padding\", \"key_backspace\", \"key_catab\", \"key_clear\", \"key_ctab\", \"key_dc\", \"key_dl\",\n+    \"key_down\", \"key_eic\", \"key_eol\", \"key_eos\", \"key_f0\", \"key_f1\", \"key_f10\", \"key_f2\", \"key_f3\",\n+    \"key_f4\", \"key_f5\", \"key_f6\", \"key_f7\", \"key_f8\", \"key_f9\", \"key_home\", \"key_ic\", \"key_il\",\n+    \"key_left\", \"key_ll\", \"key_npage\", \"key_ppage\", \"key_right\", \"key_sf\", \"key_sr\", \"key_stab\",\n+    \"key_up\", \"keypad_local\", \"keypad_xmit\", \"lab_f0\", \"lab_f1\", \"lab_f10\", \"lab_f2\", \"lab_f3\",\n+    \"lab_f4\", \"lab_f5\", \"lab_f6\", \"lab_f7\", \"lab_f8\", \"lab_f9\", \"meta_off\", \"meta_on\", \"newline\",\n+    \"pad_char\", \"parm_dch\", \"parm_delete_line\", \"parm_down_cursor\", \"parm_ich\", \"parm_index\",\n+    \"parm_insert_line\", \"parm_left_cursor\", \"parm_right_cursor\", \"parm_rindex\", \"parm_up_cursor\",\n+    \"pkey_key\", \"pkey_local\", \"pkey_xmit\", \"print_screen\", \"prtr_off\", \"prtr_on\", \"repeat_char\",\n+    \"reset_1string\", \"reset_2string\", \"reset_3string\", \"reset_file\", \"restore_cursor\",\n+    \"row_address\", \"save_cursor\", \"scroll_forward\", \"scroll_reverse\", \"set_attributes\", \"set_tab\",\n+    \"set_window\", \"tab\", \"to_status_line\", \"underline_char\", \"up_half_line\", \"init_prog\", \"key_a1\",\n+    \"key_a3\", \"key_b2\", \"key_c1\", \"key_c3\", \"prtr_non\", \"char_padding\", \"acs_chars\", \"plab_norm\",\n+    \"key_btab\", \"enter_xon_mode\", \"exit_xon_mode\", \"enter_am_mode\", \"exit_am_mode\", \"xon_character\",\n+    \"xoff_character\", \"ena_acs\", \"label_on\", \"label_off\", \"key_beg\", \"key_cancel\", \"key_close\",\n+    \"key_command\", \"key_copy\", \"key_create\", \"key_end\", \"key_enter\", \"key_exit\", \"key_find\",\n+    \"key_help\", \"key_mark\", \"key_message\", \"key_move\", \"key_next\", \"key_open\", \"key_options\",\n+    \"key_previous\", \"key_print\", \"key_redo\", \"key_reference\", \"key_refresh\", \"key_replace\",\n+    \"key_restart\", \"key_resume\", \"key_save\", \"key_suspend\", \"key_undo\", \"key_sbeg\", \"key_scancel\",\n+    \"key_scommand\", \"key_scopy\", \"key_screate\", \"key_sdc\", \"key_sdl\", \"key_select\", \"key_send\",\n+    \"key_seol\", \"key_sexit\", \"key_sfind\", \"key_shelp\", \"key_shome\", \"key_sic\", \"key_sleft\",\n+    \"key_smessage\", \"key_smove\", \"key_snext\", \"key_soptions\", \"key_sprevious\", \"key_sprint\",\n+    \"key_sredo\", \"key_sreplace\", \"key_sright\", \"key_srsume\", \"key_ssave\", \"key_ssuspend\",\n+    \"key_sundo\", \"req_for_input\", \"key_f11\", \"key_f12\", \"key_f13\", \"key_f14\", \"key_f15\", \"key_f16\",\n+    \"key_f17\", \"key_f18\", \"key_f19\", \"key_f20\", \"key_f21\", \"key_f22\", \"key_f23\", \"key_f24\",\n+    \"key_f25\", \"key_f26\", \"key_f27\", \"key_f28\", \"key_f29\", \"key_f30\", \"key_f31\", \"key_f32\",\n+    \"key_f33\", \"key_f34\", \"key_f35\", \"key_f36\", \"key_f37\", \"key_f38\", \"key_f39\", \"key_f40\",\n+    \"key_f41\", \"key_f42\", \"key_f43\", \"key_f44\", \"key_f45\", \"key_f46\", \"key_f47\", \"key_f48\",\n+    \"key_f49\", \"key_f50\", \"key_f51\", \"key_f52\", \"key_f53\", \"key_f54\", \"key_f55\", \"key_f56\",\n+    \"key_f57\", \"key_f58\", \"key_f59\", \"key_f60\", \"key_f61\", \"key_f62\", \"key_f63\", \"clr_bol\",\n+    \"clear_margins\", \"set_left_margin\", \"set_right_margin\", \"label_format\", \"set_clock\",\n+    \"display_clock\", \"remove_clock\", \"create_window\", \"goto_window\", \"hangup\", \"dial_phone\",\n+    \"quick_dial\", \"tone\", \"pulse\", \"flash_hook\", \"fixed_pause\", \"wait_tone\", \"user0\", \"user1\",\n+    \"user2\", \"user3\", \"user4\", \"user5\", \"user6\", \"user7\", \"user8\", \"user9\", \"orig_pair\",\n+    \"orig_colors\", \"initialize_color\", \"initialize_pair\", \"set_color_pair\", \"set_foreground\",\n+    \"set_background\", \"change_char_pitch\", \"change_line_pitch\", \"change_res_horz\",\n+    \"change_res_vert\", \"define_char\", \"enter_doublewide_mode\", \"enter_draft_quality\",\n+    \"enter_italics_mode\", \"enter_leftward_mode\", \"enter_micro_mode\", \"enter_near_letter_quality\",\n+    \"enter_normal_quality\", \"enter_shadow_mode\", \"enter_subscript_mode\", \"enter_superscript_mode\",\n+    \"enter_upward_mode\", \"exit_doublewide_mode\", \"exit_italics_mode\", \"exit_leftward_mode\",\n+    \"exit_micro_mode\", \"exit_shadow_mode\", \"exit_subscript_mode\", \"exit_superscript_mode\",\n+    \"exit_upward_mode\", \"micro_column_address\", \"micro_down\", \"micro_left\", \"micro_right\",\n+    \"micro_row_address\", \"micro_up\", \"order_of_pins\", \"parm_down_micro\", \"parm_left_micro\",\n+    \"parm_right_micro\", \"parm_up_micro\", \"select_char_set\", \"set_bottom_margin\",\n+    \"set_bottom_margin_parm\", \"set_left_margin_parm\", \"set_right_margin_parm\", \"set_top_margin\",\n+    \"set_top_margin_parm\", \"start_bit_image\", \"start_char_set_def\", \"stop_bit_image\",\n+    \"stop_char_set_def\", \"subscript_characters\", \"superscript_characters\", \"these_cause_cr\",\n+    \"zero_motion\", \"char_set_names\", \"key_mouse\", \"mouse_info\", \"req_mouse_pos\", \"get_mouse\",\n+    \"set_a_foreground\", \"set_a_background\", \"pkey_plab\", \"device_type\", \"code_set_init\",\n+    \"set0_des_seq\", \"set1_des_seq\", \"set2_des_seq\", \"set3_des_seq\", \"set_lr_margin\",\n+    \"set_tb_margin\", \"bit_image_repeat\", \"bit_image_newline\", \"bit_image_carriage_return\",\n+    \"color_names\", \"define_bit_image_region\", \"end_bit_image_region\", \"set_color_band\",\n+    \"set_page_length\", \"display_pc_char\", \"enter_pc_charset_mode\", \"exit_pc_charset_mode\",\n+    \"enter_scancode_mode\", \"exit_scancode_mode\", \"pc_term_options\", \"scancode_escape\",\n+    \"alt_scancode_esc\", \"enter_horizontal_hl_mode\", \"enter_left_hl_mode\", \"enter_low_hl_mode\",\n+    \"enter_right_hl_mode\", \"enter_top_hl_mode\", \"enter_vertical_hl_mode\", \"set_a_attributes\",\n+    \"set_pglen_inch\", \"termcap_init2\", \"termcap_reset\", \"linefeed_if_not_lf\", \"backspace_if_not_bs\",\n+    \"other_non_function_keys\", \"arrow_key_map\", \"acs_ulcorner\", \"acs_llcorner\", \"acs_urcorner\",\n+    \"acs_lrcorner\", \"acs_ltee\", \"acs_rtee\", \"acs_btee\", \"acs_ttee\", \"acs_hline\", \"acs_vline\",\n+    \"acs_plus\", \"memory_lock\", \"memory_unlock\", \"box_chars_1\"];\n+\n+pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n+    \"_\", \"_\", \"hpa\", \"cmdch\", \"cup\", \"cud1\", \"home\", \"civis\", \"cub1\", \"mrcup\", \"cnorm\", \"cuf1\",\n+    \"ll\", \"cuu1\", \"cvvis\", \"dch1\", \"dl1\", \"dsl\", \"hd\", \"smacs\", \"blink\", \"bold\", \"smcup\", \"smdc\",\n+    \"dim\", \"smir\", \"invis\", \"prot\", \"rev\", \"smso\", \"smul\", \"ech\", \"rmacs\", \"sgr0\", \"rmcup\", \"rmdc\",\n+    \"rmir\", \"rmso\", \"rmul\", \"flash\", \"ff\", \"fsl\", \"is1\", \"is2\", \"is3\", \"if\", \"ich1\", \"il1\", \"ip\",\n+    \"kbs\", \"ktbc\", \"kclr\", \"kctab\", \"_\", \"_\", \"kcud1\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"khome\", \"_\", \"_\", \"kcub1\", \"_\", \"knp\", \"kpp\", \"kcuf1\", \"_\", \"_\",\n+    \"khts\", \"_\", \"rmkx\", \"smkx\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"rmm\", \"_\",\n+    \"_\", \"pad\", \"dch\", \"dl\", \"cud\", \"ich\", \"indn\", \"il\", \"cub\", \"cuf\", \"rin\", \"cuu\", \"pfkey\",\n+    \"pfloc\", \"pfx\", \"mc0\", \"mc4\", \"_\", \"rep\", \"rs1\", \"rs2\", \"rs3\", \"rf\", \"rc\", \"vpa\", \"sc\", \"ind\",\n+    \"ri\", \"sgr\", \"_\", \"wind\", \"_\", \"tsl\", \"uc\", \"hu\", \"iprog\", \"_\", \"_\", \"_\", \"_\", \"_\", \"mc5p\",\n+    \"rmp\", \"acsc\", \"pln\", \"kcbt\", \"smxon\", \"rmxon\", \"smam\", \"rmam\", \"xonc\", \"xoffc\", \"_\", \"smln\",\n+    \"rmln\", \"_\", \"kcan\", \"kclo\", \"kcmd\", \"kcpy\", \"kcrt\", \"_\", \"kent\", \"kext\", \"kfnd\", \"khlp\",\n+    \"kmrk\", \"kmsg\", \"kmov\", \"knxt\", \"kopn\", \"kopt\", \"kprv\", \"kprt\", \"krdo\", \"kref\", \"krfr\", \"krpl\",\n+    \"krst\", \"kres\", \"ksav\", \"kspd\", \"kund\", \"kBEG\", \"kCAN\", \"kCMD\", \"kCPY\", \"kCRT\", \"_\", \"_\",\n+    \"kslt\", \"kEND\", \"kEOL\", \"kEXT\", \"kFND\", \"kHLP\", \"kHOM\", \"_\", \"kLFT\", \"kMSG\", \"kMOV\", \"kNXT\",\n+    \"kOPT\", \"kPRV\", \"kPRT\", \"kRDO\", \"kRPL\", \"kRIT\", \"kRES\", \"kSAV\", \"kSPD\", \"kUND\", \"rfi\", \"_\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n+    \"dclk\", \"rmclk\", \"cwin\", \"wingo\", \"_\", \"dial\", \"qdial\", \"_\", \"_\", \"hook\", \"pause\", \"wait\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"op\", \"oc\", \"initc\", \"initp\", \"scp\", \"setf\",\n+    \"setb\", \"cpi\", \"lpi\", \"chr\", \"cvr\", \"defc\", \"swidm\", \"sdrfq\", \"sitm\", \"slm\", \"smicm\", \"snlq\",\n+    \"snrmq\", \"sshm\", \"ssubm\", \"ssupm\", \"sum\", \"rwidm\", \"ritm\", \"rlm\", \"rmicm\", \"rshm\", \"rsubm\",\n+    \"rsupm\", \"rum\", \"mhpa\", \"mcud1\", \"mcub1\", \"mcuf1\", \"mvpa\", \"mcuu1\", \"porder\", \"mcud\", \"mcub\",\n+    \"mcuf\", \"mcuu\", \"scs\", \"smgb\", \"smgbp\", \"smglp\", \"smgrp\", \"smgt\", \"smgtp\", \"sbim\", \"scsd\",\n+    \"rbim\", \"rcsd\", \"subcs\", \"supcs\", \"docr\", \"zerom\", \"csnm\", \"kmous\", \"minfo\", \"reqmp\", \"getm\",\n+    \"setaf\", \"setab\", \"pfxl\", \"devt\", \"csin\", \"s0ds\", \"s1ds\", \"s2ds\", \"s3ds\", \"smglr\", \"smgtb\",\n+    \"birep\", \"binel\", \"bicr\", \"colornm\", \"defbi\", \"endbi\", \"setcolor\", \"slines\", \"dispc\", \"smpch\",\n+    \"rmpch\", \"smsc\", \"rmsc\", \"pctrm\", \"scesc\", \"scesa\", \"ehhlm\", \"elhlm\", \"elohlm\", \"erhlm\",\n+    \"ethlm\", \"evhlm\", \"sgr1\", \"slength\", \"OTi2\", \"OTrs\", \"OTnl\", \"OTbs\", \"OTko\", \"OTma\", \"OTG2\",\n+    \"OTG3\", \"OTG1\", \"OTG4\", \"OTGR\", \"OTGL\", \"OTGU\", \"OTGD\", \"OTGH\", \"OTGV\", \"OTGC\", \"meml\", \"memu\",\n+    \"box1\"];\n+\n+/// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n+pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n+    let bnames, snames, nnames;\n+\n+    if longnames {\n+        bnames = boolfnames;\n+        snames = stringfnames;\n+        nnames = numfnames;\n+    } else {\n+        bnames = boolnames;\n+        snames = stringnames;\n+        nnames = numnames;\n+    }\n+\n+    // Check magic number\n+    let magic = file.read_le_u16();\n+    if (magic != 0x011A) {\n+        return Err(fmt!(\"invalid magic number: expected %x but found %x\", 0x011A, magic as uint));\n+    }\n+\n+    let names_bytes          = file.read_le_i16() as int;\n+    let bools_bytes          = file.read_le_i16() as int;\n+    let numbers_count        = file.read_le_i16() as int;\n+    let string_offsets_count = file.read_le_i16() as int;\n+    let string_table_bytes   = file.read_le_i16() as int;\n+\n+    assert!(names_bytes          > 0);\n+\n+    debug!(\"names_bytes = %?\", names_bytes);\n+    debug!(\"bools_bytes = %?\", bools_bytes);\n+    debug!(\"numbers_count = %?\", numbers_count);\n+    debug!(\"string_offsets_count = %?\", string_offsets_count);\n+    debug!(\"string_table_bytes = %?\", string_table_bytes);\n+\n+    if (bools_bytes as uint) > boolnames.len() {\n+        error!(\"expected bools_bytes to be less than %? but found %?\", boolnames.len(),\n+               bools_bytes);\n+        return Err(~\"incompatible file: more booleans than expected\");\n+    }\n+\n+    if (numbers_count as uint) > numnames.len() {\n+        error!(\"expected numbers_count to be less than %? but found %?\", numnames.len(),\n+               numbers_count);\n+        return Err(~\"incompatible file: more numbers than expected\");\n+    }\n+\n+    if (string_offsets_count as uint) > stringnames.len() {\n+        error!(\"expected string_offsets_count to be less than %? but found %?\", stringnames.len(),\n+               string_offsets_count);\n+        return Err(~\"incompatible file: more string offsets than expected\");\n+    }\n+\n+    let mut term_names: ~[~str] = vec::with_capacity(2);\n+    let names_str = str::from_bytes(file.read_bytes(names_bytes as uint - 1)); // don't read NUL\n+    for names_str.each_split_char('|') |s| {\n+        term_names.push(s.to_owned());\n+    }\n+\n+    file.read_byte(); // consume NUL\n+\n+    debug!(\"term names: %?\", term_names);\n+\n+    let mut bools_map = HashMap::new();\n+    if bools_bytes != 0 {\n+        for int::range(0, bools_bytes) |i| {\n+            let b = file.read_byte();\n+            if b < 0 {\n+                error!(\"EOF reading bools after %? entries\", i);\n+                return Err(~\"error: expected more bools but hit EOF\");\n+            } else if b == 1 {\n+                debug!(\"%s set\", bnames[i]);\n+                bools_map.insert(bnames[i].to_owned(), true);\n+            }\n+        }\n+    }\n+\n+    debug!(\"bools: %?\", bools_map);\n+\n+    if (bools_bytes + names_bytes) % 2 == 1 {\n+        debug!(\"adjusting for padding between bools and numbers\");\n+        file.read_byte(); // compensate for padding\n+    }\n+\n+    let mut numbers_map = HashMap::new();\n+    if numbers_count != 0 {\n+        for int::range(0, numbers_count) |i| {\n+            let n = file.read_le_u16();\n+            if n != 0xFFFF {\n+                debug!(\"%s#%?\", nnames[i], n);\n+                numbers_map.insert(nnames[i].to_owned(), n);\n+            }\n+        }\n+    }\n+\n+    debug!(\"numbers: %?\", numbers_map);\n+\n+    let mut string_map = HashMap::new();\n+\n+    if string_offsets_count != 0 {\n+        let mut string_offsets = vec::with_capacity(10);\n+        for int::range(0, string_offsets_count) |_i| {\n+            string_offsets.push(file.read_le_u16());\n+        }\n+\n+        debug!(\"offsets: %?\", string_offsets);\n+\n+        let string_table = file.read_bytes(string_table_bytes as uint);\n+\n+        if string_table.len() != string_table_bytes as uint {\n+            error!(\"EOF reading string table after %? bytes, wanted %?\", string_table.len(),\n+                   string_table_bytes);\n+            return Err(~\"error: hit EOF before end of string table\");\n+        }\n+\n+        for string_offsets.eachi |i, v| {\n+            let offset = *v;\n+            if offset == 0xFFFF { // non-entry\n+                loop;\n+            }\n+\n+            let name = if snames[i] == \"_\" {\n+                stringfnames[i]\n+            } else {\n+                snames[i]\n+            };\n+\n+            if offset == 0xFFFE {\n+                // undocumented: FFFE indicates cap@, which means the capability is not present\n+                // unsure if the handling for this is correct\n+                string_map.insert(name.to_owned(), ~[]);\n+                loop;\n+            }\n+\n+\n+            // Find the offset of the NUL we want to go to\n+            let nulpos = vec::position_between(string_table, offset as uint,\n+                                               string_table_bytes as uint, |&b| b == 0);\n+            match nulpos {\n+                Some(x) => {\n+                    string_map.insert(name.to_owned(),\n+                                      string_table.slice(offset as uint, x).to_owned())\n+                },\n+                None => {\n+                    return Err(~\"invalid file: missing NUL in string_table\");\n+                }\n+            };\n+        }\n+    }\n+\n+    // And that's all there is to it\n+    Ok(~TermInfo {names: term_names, bools: bools_map, numbers: numbers_map, strings: string_map })\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use p = core::path::Path;\n+\n+    #[test]\n+    fn test_veclens() {\n+        assert_eq!(boolfnames.len(), boolnames.len());\n+        assert_eq!(numfnames.len(), numnames.len());\n+        assert_eq!(stringfnames.len(), stringnames.len());\n+    }\n+\n+    #[test]\n+    #[ignore(reason = \"no ncurses on buildbots, needs a bundled terminfo file to test against\")]\n+    fn test_parse() {\n+        // FIXME #6870: Distribute a compiled file in src/tests and test there\n+        // parse(io::file_reader(&p(\"/usr/share/terminfo/r/rxvt-256color\")).unwrap(), false);\n+    }\n+}"}, {"sha": "d6577cf3b94db408a8a73ee6f443e800f822c701", "filename": "src/libextra/terminfo/searcher.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Implement ncurses-compatible database discovery\n+/// Does not support hashed database, only filesystem!\n+\n+use core::prelude::*;\n+use core::{os, str};\n+use core::os::getenv;\n+use core::io::{file_reader, Reader};\n+use path = core::path::Path;\n+\n+/// Return path to database entry for `term`\n+pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n+    if term.len() == 0 {\n+        return None;\n+    }\n+\n+    let homedir = os::homedir();\n+\n+    let mut dirs_to_search = ~[];\n+    let first_char = term.substr(0, 1);\n+\n+    // Find search directory\n+    match getenv(\"TERMINFO\") {\n+        Some(dir) => dirs_to_search.push(path(dir)),\n+        None => {\n+            if homedir.is_some() {\n+                dirs_to_search.push(homedir.unwrap().push(\".terminfo\")); // ncurses compatability\n+            }\n+            match getenv(\"TERMINFO_DIRS\") {\n+                Some(dirs) => for str::each_split_char(dirs, ':') |i| {\n+                    if i == \"\" {\n+                        dirs_to_search.push(path(\"/usr/share/terminfo\"));\n+                    } else {\n+                        dirs_to_search.push(path(i.to_owned()));\n+                    }\n+                },\n+                // Found nothing, use the default path\n+                None => dirs_to_search.push(path(\"/usr/share/terminfo\"))\n+            }\n+        }\n+    };\n+\n+    // Look for the terminal in all of the search directories\n+    for dirs_to_search.each |p| {\n+        let newp = ~p.push_many(&[first_char.to_owned(), term.to_owned()]);\n+        if os::path_exists(p) && os::path_exists(newp) {\n+            return Some(newp);\n+        }\n+    }\n+    None\n+}\n+\n+/// Return open file for `term`\n+pub fn open(term: &str) -> Result<@Reader, ~str> {\n+    match get_dbpath_for_term(term) {\n+        Some(x) => file_reader(x),\n+        None => Err(fmt!(\"could not find terminfo entry for %s\", term))\n+    }\n+}\n+\n+#[test]\n+#[ignore(reason = \"buildbots don't have ncurses installed and I can't mock everything I need\")]\n+fn test_get_dbpath_for_term() {\n+    // woefully inadequate test coverage\n+    use std::os::{setenv, unsetenv};\n+    fn x(t: &str) -> ~str { get_dbpath_for_term(t).expect(\"no terminfo entry found\").to_str() };\n+    assert!(x(\"screen\") == ~\"/usr/share/terminfo/s/screen\");\n+    assert!(get_dbpath_for_term(\"\") == None);\n+    setenv(\"TERMINFO_DIRS\", \":\");\n+    assert!(x(\"screen\") == ~\"/usr/share/terminfo/s/screen\");\n+    unsetenv(\"TERMINFO_DIRS\");\n+}\n+\n+#[test]\n+#[ignore(reason = \"see test_get_dbpath_for_term\")]\n+fn test_open() {\n+    open(\"screen\");\n+    let t = open(\"nonexistent terminal that hopefully does not exist\");\n+    assert!(t.is_err());\n+}"}, {"sha": "141a5b6bf7f9b72b663b00ce6b5ac63c1f3af3fb", "filename": "src/libextra/terminfo/terminfo.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Fterminfo%2Fterminfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Fterminfo%2Fterminfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fterminfo.rs?ref=8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::hashmap::HashMap;\n+\n+/// A parsed terminfo entry.\n+pub struct TermInfo {\n+    /// Names for the terminal\n+    names: ~[~str],\n+    /// Map of capability name to boolean value\n+    bools: HashMap<~str, bool>,\n+    /// Map of capability name to numeric value\n+    numbers: HashMap<~str, u16>,\n+    /// Map of capability name to raw (unexpanded) string\n+    strings: HashMap<~str, ~[u8]>\n+}\n+\n+pub mod searcher;\n+pub mod parser {\n+    pub mod compiled;\n+}\n+pub mod parm;"}, {"sha": "99903be8b22ae4f644f5058d339400cb94075d9a", "filename": "src/libextra/test.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "patch": "@@ -210,7 +210,6 @@ struct ConsoleTestState {\n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts,\n                          tests: ~[TestDescAndFn]) -> bool {\n-\n     fn callback(event: &TestEvent, st: &mut ConsoleTestState) {\n         debug!(\"callback(event=%?)\", event);\n         match copy *event {\n@@ -347,12 +346,18 @@ pub fn run_tests_console(opts: &TestOpts,\n                     word: &str,\n                     color: u8,\n                     use_color: bool) {\n-        if use_color && term::color_supported() {\n-            term::fg(out, color);\n-        }\n-        out.write_str(word);\n-        if use_color && term::color_supported() {\n-            term::reset(out);\n+        let t = term::Terminal::new(out);\n+        match t {\n+            Ok(term)  => {\n+                if use_color && term.color_supported {\n+                    term.fg(color);\n+                }\n+                out.write_str(word);\n+                if use_color && term.color_supported {\n+                    term.reset();\n+                }\n+            },\n+            Err(_) => out.write_str(word)\n         }\n     }\n }"}, {"sha": "33745e85387e5109e1f6a59c25de62e8920e2e9e", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "patch": "@@ -162,43 +162,31 @@ pub fn need_dir(s: &Path) {\n     }\n }\n \n-pub fn note(msg: ~str) {\n-    let out = io::stdout();\n-\n-    if term::color_supported() {\n-        term::fg(out, term::color_green);\n-        out.write_str(\"note: \");\n-        term::reset(out);\n-        out.write_line(msg);\n-    } else {\n-        out.write_line(~\"note: \" + msg);\n+fn pretty_message<'a>(msg: &'a str, prefix: &'a str, color: u8, out: @io::Writer) {\n+    let term = term::Terminal::new(out);\n+    match term {\n+        Ok(ref t) => {\n+            t.fg(color);\n+            out.write_str(prefix);\n+            t.reset();\n+        },\n+        _ => {\n+            out.write_str(prefix);\n+        }\n     }\n+    out.write_line(msg);\n }\n \n-pub fn warn(msg: ~str) {\n-    let out = io::stdout();\n-\n-    if term::color_supported() {\n-        term::fg(out, term::color_yellow);\n-        out.write_str(\"warning: \");\n-        term::reset(out);\n-        out.write_line(msg);\n-    } else {\n-        out.write_line(~\"warning: \" + msg);\n-    }\n+pub fn note(msg: &str) {\n+    pretty_message(msg, \"note: \", term::color_green, io::stdout())\n }\n \n-pub fn error(msg: ~str) {\n-    let out = io::stdout();\n+pub fn warn(msg: &str) {\n+    pretty_message(msg, \"warning: \", term::color_yellow, io::stdout())\n+}\n \n-    if term::color_supported() {\n-        term::fg(out, term::color_red);\n-        out.write_str(\"error: \");\n-        term::reset(out);\n-        out.write_line(msg);\n-    } else {\n-        out.write_line(~\"error: \" + msg);\n-    }\n+pub fn error(msg: &str) {\n+    pretty_message(msg, \"error: \", term::color_red, io::stdout())\n }\n \n // FIXME (#4432): Use workcache to only compile when needed"}, {"sha": "fa4a74b895454408841b3e618b7f1bf0b1f86639", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a43b318bf30c26f4e9f3557b6c7036fcb9d5342/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=8a43b318bf30c26f4e9f3557b6c7036fcb9d5342", "patch": "@@ -191,19 +191,27 @@ fn diagnosticcolor(lvl: level) -> u8 {\n }\n \n fn print_diagnostic(topic: &str, lvl: level, msg: &str) {\n-    let use_color = term::color_supported() &&\n-        io::stderr().get_type() == io::Screen;\n+    let t = term::Terminal::new(io::stderr());\n+\n+    let stderr = io::stderr();\n+\n     if !topic.is_empty() {\n-        io::stderr().write_str(fmt!(\"%s \", topic));\n+        stderr.write_str(fmt!(\"%s \", topic));\n     }\n-    if use_color {\n-        term::fg(io::stderr(), diagnosticcolor(lvl));\n-    }\n-    io::stderr().write_str(fmt!(\"%s:\", diagnosticstr(lvl)));\n-    if use_color {\n-        term::reset(io::stderr());\n+\n+    match t {\n+        Ok(term) => {\n+            if stderr.get_type() == io::Screen {\n+                term.fg(diagnosticcolor(lvl));\n+                stderr.write_str(fmt!(\"%s: \", diagnosticstr(lvl)));\n+                term.reset();\n+                stderr.write_str(fmt!(\"%s\\n\", msg));\n+            } else {\n+                stderr.write_str(fmt!(\"%s: %s\\n\", diagnosticstr(lvl), msg));\n+            }\n+        },\n+        _ => stderr.write_str(fmt!(\"%s: %s\\n\", diagnosticstr(lvl), msg))\n     }\n-    io::stderr().write_str(fmt!(\" %s\\n\", msg));\n }\n \n pub fn collect(messages: @mut ~[~str])"}]}