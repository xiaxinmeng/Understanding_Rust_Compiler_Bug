{"sha": "a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3Yzc3NjRjOTMxYjU5ZjRiZjU2YWQ4YmJhMWEzMWJiNmFjNzBkNGQ=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-15T03:48:00Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-15T03:48:00Z"}, "message": "Reorganize and simplify.", "tree": {"sha": "959e6d520f7b0d58df814ecc3c0356c89a373947", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/959e6d520f7b0d58df814ecc3c0356c89a373947"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d", "html_url": "https://github.com/rust-lang/rust/commit/a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f74d1dc7f12e4b8996a2bbdf0b48410ce99bee31", "url": "https://api.github.com/repos/rust-lang/rust/commits/f74d1dc7f12e4b8996a2bbdf0b48410ce99bee31", "html_url": "https://github.com/rust-lang/rust/commit/f74d1dc7f12e4b8996a2bbdf0b48410ce99bee31"}], "stats": {"total": 243, "additions": 111, "deletions": 132}, "files": [{"sha": "a05250e3b54829adfdf9660a3a050a9254756072", "filename": "src/error.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d", "patch": "@@ -0,0 +1,32 @@\n+use std::error::Error;\n+use std::fmt;\n+\n+#[derive(Clone, Debug)]\n+pub enum EvalError {\n+    DanglingPointerDeref,\n+    InvalidBool,\n+    PointerOutOfBounds,\n+    InvalidPointerAccess,\n+}\n+\n+pub type EvalResult<T> = Result<T, EvalError>;\n+\n+impl Error for EvalError {\n+    fn description(&self) -> &str {\n+        match *self {\n+            EvalError::DanglingPointerDeref => \"dangling pointer was dereferenced\",\n+            EvalError::InvalidBool => \"invalid boolean value read\",\n+            EvalError::PointerOutOfBounds => \"pointer offset outside bounds of allocation\",\n+            EvalError::InvalidPointerAccess =>\n+                \"a raw memory access tried to access part of a pointer value as bytes\",\n+        }\n+    }\n+\n+    fn cause(&self) -> Option<&Error> { None }\n+}\n+\n+impl fmt::Display for EvalError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.description())\n+    }\n+}"}, {"sha": "145d3d30808d9347da8832d18e41cb8002b32cb6", "filename": "src/interpreter.rs", "status": "modified", "additions": 77, "deletions": 131, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d", "patch": "@@ -1,67 +1,20 @@\n use rustc::middle::const_eval;\n use rustc::middle::def_id::DefId;\n-use rustc::middle::ty::{self, TyCtxt};\n use rustc::middle::subst::{Subst, Substs};\n+use rustc::middle::ty::{self, TyCtxt};\n use rustc::mir::mir_map::MirMap;\n use rustc::mir::repr as mir;\n use rustc::util::nodemap::DefIdMap;\n use std::cell::RefCell;\n-use std::error::Error;\n-use std::fmt;\n use std::ops::Deref;\n use std::rc::Rc;\n \n+use error::EvalResult;\n use memory::{FieldRepr, Memory, Pointer, Repr};\n use primval::{self, PrimVal};\n \n const TRACE_EXECUTION: bool = true;\n \n-#[derive(Clone, Debug)]\n-pub enum EvalError {\n-    DanglingPointerDeref,\n-    InvalidBool,\n-    PointerOutOfBounds,\n-    InvalidPointerAccess,\n-}\n-\n-pub type EvalResult<T> = Result<T, EvalError>;\n-\n-impl Error for EvalError {\n-    fn description(&self) -> &str {\n-        match *self {\n-            EvalError::DanglingPointerDeref => \"dangling pointer was dereferenced\",\n-            EvalError::InvalidBool => \"invalid boolean value read\",\n-            EvalError::PointerOutOfBounds => \"pointer offset outside bounds of allocation\",\n-            EvalError::InvalidPointerAccess =>\n-                \"a raw memory access tried to access part of a pointer value as bytes\",\n-        }\n-    }\n-\n-    fn cause(&self) -> Option<&Error> { None }\n-}\n-\n-impl fmt::Display for EvalError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.description())\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub enum CachedMir<'mir, 'tcx: 'mir> {\n-    Ref(&'mir mir::Mir<'tcx>),\n-    Owned(Rc<mir::Mir<'tcx>>)\n-}\n-\n-impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n-    type Target = mir::Mir<'tcx>;\n-    fn deref(&self) -> &mir::Mir<'tcx> {\n-        match *self {\n-            CachedMir::Ref(r) => r,\n-            CachedMir::Owned(ref rc) => &rc,\n-        }\n-    }\n-}\n-\n struct Interpreter<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n     tcx: &'a TyCtxt<'tcx>,\n@@ -78,8 +31,8 @@ struct Interpreter<'a, 'tcx: 'a> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'a, 'tcx>>,\n \n-    /// Another stack containing the type substitutions for the current function invocation. Exists\n-    /// separately from `stack` because it must contain the `Substs` for a function while\n+    /// Another stack containing the type substitutions for the current function invocation. It\n+    /// exists separately from `stack` because it must contain the `Substs` for a function while\n     /// *creating* the `Frame` for that same function.\n     substs_stack: Vec<&'tcx Substs<'tcx>>,\n }\n@@ -107,6 +60,12 @@ struct Frame<'a, 'tcx: 'a> {\n     temp_offset: usize,\n }\n \n+#[derive(Clone)]\n+enum CachedMir<'mir, 'tcx: 'mir> {\n+    Ref(&'mir mir::Mir<'tcx>),\n+    Owned(Rc<mir::Mir<'tcx>>)\n+}\n+\n /// Represents the action to be taken in the main loop as a result of executing a terminator.\n enum TerminatorTarget {\n     /// Make a local jump to the given block.\n@@ -131,6 +90,46 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         }\n     }\n \n+    fn run(&mut self) -> EvalResult<()> {\n+        use std::fmt::Debug;\n+        fn print_trace<T: Debug>(t: &T, suffix: &'static str, indent: usize) {\n+            if !TRACE_EXECUTION { return; }\n+            for _ in 0..indent { print!(\"  \"); }\n+            println!(\"{:?}{}\", t, suffix);\n+        }\n+\n+        'outer: while !self.stack.is_empty() {\n+            let mut current_block = self.current_frame().next_block;\n+\n+            loop {\n+                print_trace(&current_block, \":\", self.stack.len());\n+                let current_mir = self.current_frame().mir.clone(); // Cloning a reference.\n+                let block_data = current_mir.basic_block_data(current_block);\n+\n+                for stmt in &block_data.statements {\n+                    print_trace(stmt, \"\", self.stack.len() + 1);\n+                    let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n+                    try!(self.eval_assignment(lvalue, rvalue));\n+                }\n+\n+                let terminator = block_data.terminator();\n+                print_trace(terminator, \"\", self.stack.len() + 1);\n+\n+                match try!(self.eval_terminator(terminator)) {\n+                    TerminatorTarget::Block(block) => current_block = block,\n+                    TerminatorTarget::Return => {\n+                        self.pop_stack_frame();\n+                        self.substs_stack.pop();\n+                        continue 'outer;\n+                    }\n+                    TerminatorTarget::Call => continue 'outer,\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     fn push_stack_frame(&mut self, mir: CachedMir<'a, 'tcx>, args: &[mir::Operand<'tcx>],\n                         return_ptr: Option<Pointer>) -> EvalResult<()> {\n         let num_args = mir.arg_decls.len();\n@@ -172,74 +171,6 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         // TODO(tsion): Deallocate local variables.\n     }\n \n-    fn load_mir(&self, def_id: DefId) -> CachedMir<'a, 'tcx> {\n-        match self.tcx.map.as_local_node_id(def_id) {\n-            Some(node_id) => CachedMir::Ref(self.mir_map.map.get(&node_id).unwrap()),\n-            None => {\n-                let mut mir_cache = self.mir_cache.borrow_mut();\n-                if let Some(mir) = mir_cache.get(&def_id) {\n-                    return CachedMir::Owned(mir.clone());\n-                }\n-\n-                use rustc::middle::cstore::CrateStore;\n-                let cs = &self.tcx.sess.cstore;\n-                let mir = cs.maybe_get_item_mir(self.tcx, def_id).unwrap();\n-                let cached = Rc::new(mir);\n-                mir_cache.insert(def_id, cached.clone());\n-                CachedMir::Owned(cached)\n-            }\n-        }\n-    }\n-\n-    fn run(&mut self) -> EvalResult<()> {\n-        fn print_indent(n: usize) {\n-            for _ in 0..n {\n-                print!(\"  \");\n-            }\n-        }\n-\n-        'outer: while !self.stack.is_empty() {\n-            let mut current_block = self.current_frame().next_block;\n-\n-            loop {\n-                if TRACE_EXECUTION {\n-                    print_indent(self.stack.len());\n-                    println!(\"{:?}:\", current_block);\n-                }\n-\n-                let current_mir = self.current_frame().mir.clone(); // Cloning a reference.\n-                let block_data = current_mir.basic_block_data(current_block);\n-\n-                for stmt in &block_data.statements {\n-                    if TRACE_EXECUTION {\n-                        print_indent(self.stack.len() + 1);\n-                        println!(\"{:?}\", stmt);\n-                    }\n-                    let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n-                    try!(self.eval_assignment(lvalue, rvalue));\n-                }\n-\n-                let terminator = block_data.terminator();\n-                if TRACE_EXECUTION {\n-                    print_indent(self.stack.len() + 1);\n-                    println!(\"{:?}\", terminator);\n-                }\n-\n-                match try!(self.eval_terminator(terminator)) {\n-                    TerminatorTarget::Block(block) => current_block = block,\n-                    TerminatorTarget::Return => {\n-                        self.pop_stack_frame();\n-                        self.substs_stack.pop();\n-                        continue 'outer;\n-                    }\n-                    TerminatorTarget::Call => continue 'outer,\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n     fn eval_terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<TerminatorTarget> {\n         use rustc::mir::repr::Terminator::*;\n         let target = match *terminator {\n@@ -417,9 +348,9 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         let ptr = match *lvalue {\n             ReturnPointer =>\n                 frame.return_ptr.expect(\"ReturnPointer used in a function with no return value\"),\n-            Arg(i) => frame.arg_ptr(i),\n-            Var(i) => frame.var_ptr(i),\n-            Temp(i) => frame.temp_ptr(i),\n+            Arg(i) => frame.locals[i as usize],\n+            Var(i) => frame.locals[frame.var_offset + i as usize],\n+            Temp(i) => frame.locals[frame.temp_offset + i as usize],\n \n             Projection(ref proj) => {\n                 let (base_ptr, base_repr) = try!(self.eval_lvalue(&proj.base));\n@@ -560,19 +491,34 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n     fn current_frame_mut(&mut self) -> &mut Frame<'a, 'tcx> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n-}\n \n-impl<'a, 'tcx: 'a> Frame<'a, 'tcx> {\n-    fn arg_ptr(&self, i: u32) -> Pointer {\n-        self.locals[i as usize]\n-    }\n+    fn load_mir(&self, def_id: DefId) -> CachedMir<'a, 'tcx> {\n+        match self.tcx.map.as_local_node_id(def_id) {\n+            Some(node_id) => CachedMir::Ref(self.mir_map.map.get(&node_id).unwrap()),\n+            None => {\n+                let mut mir_cache = self.mir_cache.borrow_mut();\n+                if let Some(mir) = mir_cache.get(&def_id) {\n+                    return CachedMir::Owned(mir.clone());\n+                }\n \n-    fn var_ptr(&self, i: u32) -> Pointer {\n-        self.locals[self.var_offset + i as usize]\n+                use rustc::middle::cstore::CrateStore;\n+                let cs = &self.tcx.sess.cstore;\n+                let mir = cs.maybe_get_item_mir(self.tcx, def_id).unwrap();\n+                let cached = Rc::new(mir);\n+                mir_cache.insert(def_id, cached.clone());\n+                CachedMir::Owned(cached)\n+            }\n+        }\n     }\n+}\n \n-    fn temp_ptr(&self, i: u32) -> Pointer {\n-        self.locals[self.temp_offset + i as usize]\n+impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n+    type Target = mir::Mir<'tcx>;\n+    fn deref(&self) -> &mir::Mir<'tcx> {\n+        match *self {\n+            CachedMir::Ref(r) => r,\n+            CachedMir::Owned(ref rc) => &rc,\n+        }\n     }\n }\n "}, {"sha": "9b938d5147225961e8152ed64004e60a5c4e5c7d", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d", "patch": "@@ -5,6 +5,7 @@ extern crate rustc;\n extern crate rustc_mir;\n extern crate syntax;\n \n+mod error;\n pub mod interpreter;\n mod memory;\n mod primval;"}, {"sha": "8a962d804b7b0e1be9ce01892960b3cad6d346d0", "filename": "src/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=a7c7764c931b59f4bf56ad8bba1a31bb6ac70d4d", "patch": "@@ -3,7 +3,7 @@ use std::collections::{BTreeMap, HashMap};\n use std::collections::Bound::{Included, Excluded};\n use std::ptr;\n \n-use interpreter::{EvalError, EvalResult};\n+use error::{EvalError, EvalResult};\n use primval::PrimVal;\n \n const POINTER_SIZE: usize = 8;"}]}