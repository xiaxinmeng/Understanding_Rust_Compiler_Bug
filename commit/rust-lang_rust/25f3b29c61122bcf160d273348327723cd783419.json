{"sha": "25f3b29c61122bcf160d273348327723cd783419", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZjNiMjljNjExMjJiY2YxNjBkMjczMzQ4MzI3NzIzY2Q3ODM0MTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-07T03:10:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-07T03:10:57Z"}, "message": "auto merge of #9010 : aaronlaursen/rust/master, r=alexcrichton\n\nHere's a fix for issue #7588, \"Overflow handling of from_str methods is broken\". \r\n\r\nThe integer overflow issues are taken care of by checking to see if the multiply-by-radix-and-add-next-digit process is reversible. If it overflowed, then some information is lost and the process is irreversible, in which case, None is returned. \r\n\r\nFloats now consistently return Some(Inf) of Some(-Inf) on overflow thanks to a call to NumStrConv::inf() and NumStrConv::neg_inf() respectively when the overflow is detected (which yields a value of None in the case of ints and uints anyway). \r\n\r\nThis is my first contribution to Rust, and my first time using the language in general, so any and all feedback is appreciated.", "tree": {"sha": "23bce629648ef1685e5cf3a7ea51f9b073111708", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23bce629648ef1685e5cf3a7ea51f9b073111708"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25f3b29c61122bcf160d273348327723cd783419", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25f3b29c61122bcf160d273348327723cd783419", "html_url": "https://github.com/rust-lang/rust/commit/25f3b29c61122bcf160d273348327723cd783419", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25f3b29c61122bcf160d273348327723cd783419/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12bca20d781cf4f6810c1cfc1666c1adb1d5d97f", "url": "https://api.github.com/repos/rust-lang/rust/commits/12bca20d781cf4f6810c1cfc1666c1adb1d5d97f", "html_url": "https://github.com/rust-lang/rust/commit/12bca20d781cf4f6810c1cfc1666c1adb1d5d97f"}, {"sha": "caf5321eb45db8ba64d3f9f4b9e16febfeb46a4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/caf5321eb45db8ba64d3f9f4b9e16febfeb46a4c", "html_url": "https://github.com/rust-lang/rust/commit/caf5321eb45db8ba64d3f9f4b9e16febfeb46a4c"}], "stats": {"total": 35, "additions": 31, "deletions": 4}, "files": [{"sha": "dcda27d8ea923fcb9caf76ba86f696312ccf2d52", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/25f3b29c61122bcf160d273348327723cd783419/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25f3b29c61122bcf160d273348327723cd783419/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=25f3b29c61122bcf160d273348327723cd783419", "patch": "@@ -552,8 +552,18 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n                 // Detect overflow by comparing to last value, except\n                 // if we've not seen any non-zero digits.\n                 if last_accum != _0 {\n-                    if accum_positive && accum <= last_accum { return None; }\n-                    if !accum_positive && accum >= last_accum { return None; }\n+                    if accum_positive && accum <= last_accum { return NumStrConv::inf(); }\n+                    if !accum_positive && accum >= last_accum { return NumStrConv::neg_inf(); }\n+\n+                    // Detect overflow by reversing the shift-and-add proccess\n+                    if accum_positive &&\n+                        (last_accum != ((accum - cast(digit as int))/radix_gen.clone())) {\n+                        return NumStrConv::inf();\n+                    }\n+                    if !accum_positive &&\n+                        (last_accum != ((accum + cast(digit as int))/radix_gen.clone())) {\n+                        return NumStrConv::neg_inf();\n+                    }\n                 }\n                 last_accum = accum.clone();\n             }\n@@ -597,8 +607,8 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n                     }\n \n                     // Detect overflow by comparing to last value\n-                    if accum_positive && accum < last_accum { return None; }\n-                    if !accum_positive && accum > last_accum { return None; }\n+                    if accum_positive && accum < last_accum { return NumStrConv::inf(); }\n+                    if !accum_positive && accum > last_accum { return NumStrConv::neg_inf(); }\n                     last_accum = accum.clone();\n                 }\n                 None => match c {\n@@ -702,6 +712,23 @@ mod test {\n                                              ExpNone, false, false);\n         assert_eq!(n, None);\n     }\n+\n+    #[test]\n+    fn from_str_issue7588() {\n+        let u : Option<u8> = from_str_common(\"1000\", 10, false, false, false,\n+                                            ExpNone, false, false);\n+        assert_eq!(u, None);\n+        let s : Option<i16> = from_str_common(\"80000\", 10, false, false, false,\n+                                             ExpNone, false, false);\n+        assert_eq!(s, None);\n+        let f : Option<f32> = from_str_common(\n+            \"10000000000000000000000000000000000000000\", 10, false, false, false,\n+            ExpNone, false, false);\n+        assert_eq!(f, NumStrConv::inf())\n+        let fe : Option<f32> = from_str_common(\"1e40\", 10, false, false, false,\n+                                            ExpDec, false, false);\n+        assert_eq!(fe, NumStrConv::inf())\n+    }\n }\n \n #[cfg(test)]"}]}