{"sha": "90856565124965295202aae11a33e66870f39e71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwODU2NTY1MTI0OTY1Mjk1MjAyYWFlMTFhMzNlNjY4NzBmMzllNzE=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-10-25T09:43:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-25T09:43:47Z"}, "message": "Rollup merge of #78322 - ssomers:btree_no_min_len_at_node_level, r=Mark-Simulacrum\n\nBTreeMap: stop mistaking node::MIN_LEN for a node level constraint\n\nCorrecting #77612 that fell into the trap of assuming that node::MIN_LEN is an imposed minimum everywhere, and trying to make it much more clear it is an offered minimum at the node level.\n\nr? @Mark-Simulacrum", "tree": {"sha": "29bc3b1e2a586fe28632aa4623559ea747b722ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29bc3b1e2a586fe28632aa4623559ea747b722ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90856565124965295202aae11a33e66870f39e71", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJflUjUCRBK7hj4Ov3rIwAAdHIIABSUZ6tXoP4x2V++P7OtnOf/\nzbvZdoxQZYzwOhqRrVmbpZTSU5k85lvz/P2zluHT0jf+kEGR5pZ3Z3H22mToX6n8\nScas3mg3g5P6gl9hNdZDBy86j9fRCPLDQXTn09aOnviPV/UYwWGOrS6YSW3XO7yH\nw14zAah6Ebu18Z9qezuaxpMrGqifX9jlpXeQSoNrKgR/JxXDuD4WZiLuRc1I651D\n/yLGvwHPPs1RwU/KRCgbpUGqYlsQX1A+SplixmkmLd936G/S0IcyfELPtU4ruI4j\nMDoBTFLg1J7ToRNGfNQ3PMTWkuYqJvT/ss0qVITIpox+J/MTJUp/OlAqVIIwUNk=\n=g4zk\n-----END PGP SIGNATURE-----\n", "payload": "tree 29bc3b1e2a586fe28632aa4623559ea747b722ce\nparent 63e48cd4100619550af142471543f1969bfeb8c0\nparent 3b6c4fe465bcb8c47a6b6530d7687a19e78b2f41\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1603619027 +0900\ncommitter GitHub <noreply@github.com> 1603619027 +0900\n\nRollup merge of #78322 - ssomers:btree_no_min_len_at_node_level, r=Mark-Simulacrum\n\nBTreeMap: stop mistaking node::MIN_LEN for a node level constraint\n\nCorrecting #77612 that fell into the trap of assuming that node::MIN_LEN is an imposed minimum everywhere, and trying to make it much more clear it is an offered minimum at the node level.\n\nr? @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90856565124965295202aae11a33e66870f39e71", "html_url": "https://github.com/rust-lang/rust/commit/90856565124965295202aae11a33e66870f39e71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90856565124965295202aae11a33e66870f39e71/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63e48cd4100619550af142471543f1969bfeb8c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/63e48cd4100619550af142471543f1969bfeb8c0", "html_url": "https://github.com/rust-lang/rust/commit/63e48cd4100619550af142471543f1969bfeb8c0"}, {"sha": "3b6c4fe465bcb8c47a6b6530d7687a19e78b2f41", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b6c4fe465bcb8c47a6b6530d7687a19e78b2f41", "html_url": "https://github.com/rust-lang/rust/commit/3b6c4fe465bcb8c47a6b6530d7687a19e78b2f41"}], "stats": {"total": 110, "additions": 55, "deletions": 55}, "files": [{"sha": "4f9aa44b6b510b78d7dbc9ebaf5f0a998d3f7a1b", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90856565124965295202aae11a33e66870f39e71/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90856565124965295202aae11a33e66870f39e71/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=90856565124965295202aae11a33e66870f39e71", "patch": "@@ -17,6 +17,10 @@ mod entry;\n pub use entry::{Entry, OccupiedEntry, VacantEntry};\n use Entry::*;\n \n+/// Minimum number of elements in nodes that are not a root.\n+/// We might temporarily have fewer elements during methods.\n+pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n+\n /// A map based on a B-Tree.\n ///\n /// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\n@@ -1094,13 +1098,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             // Check if right-most child is underfull.\n             let mut last_edge = internal.last_edge();\n             let right_child_len = last_edge.reborrow().descend().len();\n-            if right_child_len < node::MIN_LEN {\n+            if right_child_len < MIN_LEN {\n                 // We need to steal.\n                 let mut last_kv = match last_edge.left_kv() {\n                     Ok(left) => left,\n                     Err(_) => unreachable!(),\n                 };\n-                last_kv.bulk_steal_left(node::MIN_LEN - right_child_len);\n+                last_kv.bulk_steal_left(MIN_LEN - right_child_len);\n                 last_edge = last_kv.right_edge();\n             }\n "}, {"sha": "adb94972f5bb63de616f644fe79aaac7d564d2dd", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/90856565124965295202aae11a33e66870f39e71/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90856565124965295202aae11a33e66870f39e71/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=90856565124965295202aae11a33e66870f39e71", "patch": "@@ -50,10 +50,15 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n     {\n         if let Some(root) = &self.root {\n             let root_node = root.node_as_ref();\n+\n             assert!(root_node.ascend().is_err());\n             root_node.assert_back_pointers();\n-            root_node.assert_ascending();\n-            assert_eq!(self.length, root_node.assert_and_add_lengths());\n+\n+            let counted = root_node.assert_ascending();\n+            assert_eq!(self.length, counted);\n+            assert_eq!(self.length, root_node.calc_length());\n+\n+            root_node.assert_min_len(if root_node.height() > 0 { 1 } else { 0 });\n         } else {\n             assert_eq!(self.length, 0);\n         }\n@@ -76,6 +81,18 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n     }\n }\n \n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n+    pub fn assert_min_len(self, min_len: usize) {\n+        assert!(self.len() >= min_len, \"{} < {}\", self.len(), min_len);\n+        if let node::ForceResult::Internal(node) = self.force() {\n+            for idx in 0..=node.len() {\n+                let edge = unsafe { Handle::new_edge(node, idx) };\n+                edge.descend().assert_min_len(MIN_LEN);\n+            }\n+        }\n+    }\n+}\n+\n // Test our value of MIN_INSERTS_HEIGHT_2. It may change according to the\n // implementation of insertion, but it's best to be aware of when it does.\n #[test]"}, {"sha": "f5aff9bf494e9d0ca4f6adb95cedf5f656e6dec0", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90856565124965295202aae11a33e66870f39e71/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90856565124965295202aae11a33e66870f39e71/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=90856565124965295202aae11a33e66870f39e71", "patch": "@@ -38,8 +38,8 @@ use crate::alloc::{AllocRef, Global, Layout};\n use crate::boxed::Box;\n \n const B: usize = 6;\n-pub const MIN_LEN: usize = B - 1;\n pub const CAPACITY: usize = 2 * B - 1;\n+pub const MIN_LEN_AFTER_SPLIT: usize = B - 1;\n const KV_IDX_CENTER: usize = B - 1;\n const EDGE_IDX_LEFT_OF_CENTER: usize = B - 1;\n const EDGE_IDX_RIGHT_OF_CENTER: usize = B;"}, {"sha": "d6527057c5d772f9789f20d9fb53474d8cad8f7d", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/90856565124965295202aae11a33e66870f39e71/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90856565124965295202aae11a33e66870f39e71/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=90856565124965295202aae11a33e66870f39e71", "patch": "@@ -5,25 +5,26 @@ use crate::string::String;\n use core::cmp::Ordering::*;\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Asserts that the back pointer in each reachable node points to its parent.\n     pub fn assert_back_pointers(self) {\n-        match self.force() {\n-            ForceResult::Leaf(_) => {}\n-            ForceResult::Internal(node) => {\n-                for idx in 0..=node.len() {\n-                    let edge = unsafe { Handle::new_edge(node, idx) };\n-                    let child = edge.descend();\n-                    assert!(child.ascend().ok() == Some(edge));\n-                    child.assert_back_pointers();\n-                }\n+        if let ForceResult::Internal(node) = self.force() {\n+            for idx in 0..=node.len() {\n+                let edge = unsafe { Handle::new_edge(node, idx) };\n+                let child = edge.descend();\n+                assert!(child.ascend().ok() == Some(edge));\n+                child.assert_back_pointers();\n             }\n         }\n     }\n \n-    pub fn assert_ascending(self)\n+    /// Asserts that the keys are in strictly ascending order.\n+    /// Returns how many keys it encountered.\n+    pub fn assert_ascending(self) -> usize\n     where\n         K: Copy + Debug + Ord,\n     {\n         struct SeriesChecker<T> {\n+            num_seen: usize,\n             previous: Option<T>,\n         }\n         impl<T: Copy + Debug + Ord> SeriesChecker<T> {\n@@ -32,10 +33,11 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n                     assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n                 }\n                 self.previous = Some(next);\n+                self.num_seen += 1;\n             }\n         }\n \n-        let mut checker = SeriesChecker { previous: None };\n+        let mut checker = SeriesChecker { num_seen: 0, previous: None };\n         self.visit_nodes_in_order(|pos| match pos {\n             navigate::Position::Leaf(node) => {\n                 for idx in 0..node.len() {\n@@ -49,33 +51,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n             }\n             navigate::Position::Internal(_) => {}\n         });\n-    }\n-\n-    pub fn assert_and_add_lengths(self) -> usize {\n-        let mut internal_length = 0;\n-        let mut internal_kv_count = 0;\n-        let mut leaf_length = 0;\n-        self.visit_nodes_in_order(|pos| match pos {\n-            navigate::Position::Leaf(node) => {\n-                let is_root = self.height() == 0;\n-                let min_len = if is_root { 0 } else { MIN_LEN };\n-                assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n-                leaf_length += node.len();\n-            }\n-            navigate::Position::Internal(node) => {\n-                let is_root = self.height() == node.height();\n-                let min_len = if is_root { 1 } else { MIN_LEN };\n-                assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n-                internal_length += node.len();\n-            }\n-            navigate::Position::InternalKV(_) => {\n-                internal_kv_count += 1;\n-            }\n-        });\n-        assert_eq!(internal_length, internal_kv_count);\n-        let total = internal_length + leaf_length;\n-        assert_eq!(self.calc_length(), total);\n-        total\n+        checker.num_seen\n     }\n \n     pub fn dump_keys(self) -> String\n@@ -124,8 +100,8 @@ fn test_splitpoint() {\n                 right_len += 1;\n             }\n         }\n-        assert!(left_len >= MIN_LEN);\n-        assert!(right_len >= MIN_LEN);\n+        assert!(left_len >= MIN_LEN_AFTER_SPLIT);\n+        assert!(right_len >= MIN_LEN_AFTER_SPLIT);\n         assert!(left_len + right_len == CAPACITY);\n     }\n }"}, {"sha": "99655d3e2bf64f35c2bc0f52b1427f7e81b92fa1", "filename": "library/alloc/src/collections/btree/remove.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/90856565124965295202aae11a33e66870f39e71/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90856565124965295202aae11a33e66870f39e71/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs?ref=90856565124965295202aae11a33e66870f39e71", "patch": "@@ -1,4 +1,5 @@\n-use super::node::{self, marker, ForceResult, Handle, NodeRef};\n+use super::map::MIN_LEN;\n+use super::node::{marker, ForceResult, Handle, NodeRef};\n use super::unwrap_unchecked;\n use core::mem;\n use core::ptr;\n@@ -40,7 +41,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n         // Handle underflow\n         let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n         let mut at_leaf = true;\n-        while cur_node.len() < node::MIN_LEN {\n+        while cur_node.len() < MIN_LEN {\n             match handle_underfull_node(cur_node) {\n                 UnderflowResult::AtRoot => break,\n                 UnderflowResult::Merged(edge, merged_with_left, offset) => {"}, {"sha": "5f00a5a25abad5bf2a091c8f9ea024b6e304a713", "filename": "library/alloc/src/collections/btree/split.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/90856565124965295202aae11a33e66870f39e71/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90856565124965295202aae11a33e66870f39e71/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=90856565124965295202aae11a33e66870f39e71", "patch": "@@ -1,5 +1,6 @@\n-use super::node::{self, ForceResult::*, Root};\n-use super::search::{self, SearchResult::*};\n+use super::map::MIN_LEN;\n+use super::node::{ForceResult::*, Root};\n+use super::search::{search_node, SearchResult::*};\n use core::borrow::Borrow;\n \n impl<K, V> Root<K, V> {\n@@ -20,7 +21,7 @@ impl<K, V> Root<K, V> {\n             let mut right_node = right_root.node_as_mut();\n \n             loop {\n-                let mut split_edge = match search::search_node(left_node, key) {\n+                let mut split_edge = match search_node(left_node, key) {\n                     // key is going to the right tree\n                     Found(handle) => handle.left_edge(),\n                     GoDown(handle) => handle,\n@@ -65,9 +66,9 @@ impl<K, V> Root<K, V> {\n                     cur_node = last_kv.merge().descend();\n                 } else {\n                     let right_len = last_kv.reborrow().right_edge().descend().len();\n-                    // `MINLEN + 1` to avoid readjust if merge happens on the next level.\n-                    if right_len < node::MIN_LEN + 1 {\n-                        last_kv.bulk_steal_left(node::MIN_LEN + 1 - right_len);\n+                    // `MIN_LEN + 1` to avoid readjust if merge happens on the next level.\n+                    if right_len < MIN_LEN + 1 {\n+                        last_kv.bulk_steal_left(MIN_LEN + 1 - right_len);\n                     }\n                     cur_node = last_kv.right_edge().descend();\n                 }\n@@ -91,8 +92,9 @@ impl<K, V> Root<K, V> {\n                     cur_node = first_kv.merge().descend();\n                 } else {\n                     let left_len = first_kv.reborrow().left_edge().descend().len();\n-                    if left_len < node::MIN_LEN + 1 {\n-                        first_kv.bulk_steal_right(node::MIN_LEN + 1 - left_len);\n+                    // `MIN_LEN + 1` to avoid readjust if merge happens on the next level.\n+                    if left_len < MIN_LEN + 1 {\n+                        first_kv.bulk_steal_right(MIN_LEN + 1 - left_len);\n                     }\n                     cur_node = first_kv.left_edge().descend();\n                 }"}]}