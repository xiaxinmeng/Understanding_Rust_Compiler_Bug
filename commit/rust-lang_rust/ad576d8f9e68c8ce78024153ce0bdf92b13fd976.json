{"sha": "ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "node_id": "C_kwDOAAsO6NoAKGFkNTc2ZDhmOWU2OGM4Y2U3ODAyNDE1M2NlMGJkZjkyYjEzZmQ5NzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-07T01:48:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-07T01:48:57Z"}, "message": "Auto merge of #2208 - RalfJung:preempt, r=RalfJung\n\nMake scheduler preemptive\n\nThis is actually fairly easy. :D I just roll the dice on each terminator to decide whether we want to yield the active thread. I think with this we are also justified to no longer show \"experimental\" warnings when a thread is spawned. :)\n\nCloses https://github.com/rust-lang/miri/issues/1388", "tree": {"sha": "f625aa023160a793d20e6130726272fe230079d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f625aa023160a793d20e6130726272fe230079d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "html_url": "https://github.com/rust-lang/rust/commit/ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d98bd9838554f3d33512db6fae6fa67cede1afaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d98bd9838554f3d33512db6fae6fa67cede1afaf", "html_url": "https://github.com/rust-lang/rust/commit/d98bd9838554f3d33512db6fae6fa67cede1afaf"}, {"sha": "11a8b3a00b72505751743230bf265c9eecfd58db", "url": "https://api.github.com/repos/rust-lang/rust/commits/11a8b3a00b72505751743230bf265c9eecfd58db", "html_url": "https://github.com/rust-lang/rust/commit/11a8b3a00b72505751743230bf265c9eecfd58db"}], "stats": {"total": 465, "additions": 192, "deletions": 273}, "files": [{"sha": "6ccc9e25f69755e796732791e24321ca5aff96eb", "filename": "README.md", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -288,14 +288,16 @@ environment variable. We first document the most relevant and most commonly used\n   `-Zmiri-disable-isolation` is set.\n * `-Zmiri-ignore-leaks` disables the memory leak checker, and also allows some\n   remaining threads to exist when the main thread exits.\n-* `-Zmiri-seed=<hex>` configures the seed of the RNG that Miri uses to resolve\n-  non-determinism. This RNG is used to pick base addresses for allocations. When\n-  isolation is enabled (the default), this is also used to emulate system\n-  entropy. The default seed is 0. You can increase test coverage by running Miri\n-  multiple times with different seeds.\n-  **NOTE**: This entropy is not good enough for cryptographic use! Do not\n-  generate secret keys in Miri or perform other kinds of cryptographic\n-  operations that rely on proper random numbers.\n+* `-Zmiri-preemption-rate` configures the probability that at the end of a basic block, the active\n+  thread will be preempted. The default is `0.01` (i.e., 1%). Setting this to `0` disables\n+  preemption.\n+* `-Zmiri-seed=<hex>` configures the seed of the RNG that Miri uses to resolve non-determinism. This\n+  RNG is used to pick base addresses for allocations, to determine preemption and failure of\n+  `compare_exchange_weak`, and to control store buffering for weak memory emulation. When isolation\n+  is enabled (the default), this is also used to emulate system entropy. The default seed is 0. You\n+  can increase test coverage by running Miri multiple times with different seeds. **NOTE**: This\n+  entropy is not good enough for cryptographic use! Do not generate secret keys in Miri or perform\n+  other kinds of cryptographic operations that rely on proper random numbers.\n * `-Zmiri-strict-provenance` enables [strict\n   provenance](https://github.com/rust-lang/rust/issues/95228) checking in Miri. This means that\n   casting an integer to a pointer yields a result with 'invalid' provenance, i.e., with provenance"}, {"sha": "64047d146c3b992bd820b85e67bcda72ef8a0ad9", "filename": "src/bin/miri.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -449,6 +449,17 @@ fn main() {\n                     ),\n             };\n             miri_config.cmpxchg_weak_failure_rate = rate;\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-preemption-rate=\") {\n+            let rate = match param.parse::<f64>() {\n+                Ok(rate) if rate >= 0.0 && rate <= 1.0 => rate,\n+                Ok(_) => panic!(\"-Zmiri-preemption-rate must be between `0.0` and `1.0`\"),\n+                Err(err) =>\n+                    panic!(\n+                        \"-Zmiri-preemption-rate requires a `f64` between `0.0` and `1.0`: {}\",\n+                        err\n+                    ),\n+            };\n+            miri_config.preemption_rate = rate;\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-measureme=\") {\n             miri_config.measureme_out = Some(param.to_string());\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-backtrace=\") {"}, {"sha": "5f8bba802728cd739019abdff10d27270bd30467", "filename": "src/concurrency/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fconcurrency%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fconcurrency%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fmod.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,3 +1,3 @@\n-mod allocation_map;\n pub mod data_race;\n+mod range_object_map;\n pub mod weak_memory;"}, {"sha": "2bb32803023923090114dc9c4c0cc8f61eda3a63", "filename": "src/concurrency/range_object_map.rs", "status": "renamed", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fconcurrency%2Frange_object_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fconcurrency%2Frange_object_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Frange_object_map.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,7 +1,6 @@\n-//! Implements a map from allocation ranges to data.\n-//! This is somewhat similar to RangeMap, but the ranges\n-//! and data are discrete and non-splittable. An allocation in the\n-//! map will always have the same range until explicitly removed\n+//! Implements a map from allocation ranges to data. This is somewhat similar to RangeMap, but the\n+//! ranges and data are discrete and non-splittable -- they represent distinct \"objects\". An\n+//! allocation in the map will always have the same range until explicitly removed\n \n use rustc_target::abi::Size;\n use std::ops::{Index, IndexMut, Range};\n@@ -20,7 +19,7 @@ struct Elem<T> {\n type Position = usize;\n \n #[derive(Clone, Debug)]\n-pub struct AllocationMap<T> {\n+pub struct RangeObjectMap<T> {\n     v: Vec<Elem<T>>,\n }\n \n@@ -34,7 +33,7 @@ pub enum AccessType {\n     ImperfectlyOverlapping(Range<Position>),\n }\n \n-impl<T> AllocationMap<T> {\n+impl<T> RangeObjectMap<T> {\n     pub fn new() -> Self {\n         Self { v: Vec::new() }\n     }\n@@ -135,15 +134,15 @@ impl<T> AllocationMap<T> {\n     }\n }\n \n-impl<T> Index<Position> for AllocationMap<T> {\n+impl<T> Index<Position> for RangeObjectMap<T> {\n     type Output = T;\n \n     fn index(&self, pos: Position) -> &Self::Output {\n         &self.v[pos].data\n     }\n }\n \n-impl<T> IndexMut<Position> for AllocationMap<T> {\n+impl<T> IndexMut<Position> for RangeObjectMap<T> {\n     fn index_mut(&mut self, pos: Position) -> &mut Self::Output {\n         &mut self.v[pos].data\n     }\n@@ -159,7 +158,7 @@ mod tests {\n     fn empty_map() {\n         // FIXME: make Size::from_bytes const\n         let four = Size::from_bytes(4);\n-        let map = AllocationMap::<()>::new();\n+        let map = RangeObjectMap::<()>::new();\n \n         // Correctly tells where we should insert the first element (at position 0)\n         assert_eq!(map.find_offset(Size::from_bytes(3)), Err(0));\n@@ -173,7 +172,7 @@ mod tests {\n     fn no_overlapping_inserts() {\n         let four = Size::from_bytes(4);\n \n-        let mut map = AllocationMap::<&str>::new();\n+        let mut map = RangeObjectMap::<&str>::new();\n \n         // |_|_|_|_|#|#|#|#|_|_|_|_|...\n         //  0 1 2 3 4 5 6 7 8 9 a b c d\n@@ -187,7 +186,7 @@ mod tests {\n     fn boundaries() {\n         let four = Size::from_bytes(4);\n \n-        let mut map = AllocationMap::<&str>::new();\n+        let mut map = RangeObjectMap::<&str>::new();\n \n         // |#|#|#|#|_|_|...\n         //  0 1 2 3 4 5\n@@ -215,7 +214,7 @@ mod tests {\n     fn perfectly_overlapping() {\n         let four = Size::from_bytes(4);\n \n-        let mut map = AllocationMap::<&str>::new();\n+        let mut map = RangeObjectMap::<&str>::new();\n \n         // |#|#|#|#|_|_|...\n         //  0 1 2 3 4 5\n@@ -241,7 +240,7 @@ mod tests {\n     fn straddling() {\n         let four = Size::from_bytes(4);\n \n-        let mut map = AllocationMap::<&str>::new();\n+        let mut map = RangeObjectMap::<&str>::new();\n \n         // |_|_|_|_|#|#|#|#|_|_|_|_|...\n         //  0 1 2 3 4 5 6 7 8 9 a b c d", "previous_filename": "src/concurrency/allocation_map.rs"}, {"sha": "be3963a93f072307831bfdbd23e43be47bc3d939", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -85,8 +85,8 @@ use rustc_data_structures::fx::FxHashMap;\n use crate::{AtomicReadOp, AtomicRwOp, AtomicWriteOp, Tag, VClock, VTimestamp, VectorIdx};\n \n use super::{\n-    allocation_map::{AccessType, AllocationMap},\n     data_race::{GlobalState, ThreadClockSet},\n+    range_object_map::{AccessType, RangeObjectMap},\n };\n \n pub type AllocExtra = StoreBufferAlloc;\n@@ -101,7 +101,7 @@ const STORE_BUFFER_LIMIT: usize = 128;\n pub struct StoreBufferAlloc {\n     /// Store buffer of each atomic object in this allocation\n     // Behind a RefCell because we need to allocate/remove on read access\n-    store_buffers: RefCell<AllocationMap<StoreBuffer>>,\n+    store_buffers: RefCell<RangeObjectMap<StoreBuffer>>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -134,7 +134,7 @@ struct StoreElement {\n \n impl StoreBufferAlloc {\n     pub fn new_allocation() -> Self {\n-        Self { store_buffers: RefCell::new(AllocationMap::new()) }\n+        Self { store_buffers: RefCell::new(RangeObjectMap::new()) }\n     }\n \n     /// Checks if the range imperfectly overlaps with existing buffers"}, {"sha": "7c971d2a1490ad184e2794c99b7e45f3b527994b", "filename": "src/eval.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -122,6 +122,8 @@ pub struct MiriConfig {\n     /// Whether to ignore any output by the program. This is helpful when debugging miri\n     /// as its messages don't get intermingled with the program messages.\n     pub mute_stdout_stderr: bool,\n+    /// The probability of the active thread being preempted at the end of each basic block.\n+    pub preemption_rate: f64,\n }\n \n impl Default for MiriConfig {\n@@ -145,12 +147,13 @@ impl Default for MiriConfig {\n             tag_raw: false,\n             data_race_detector: true,\n             weak_memory_emulation: true,\n-            cmpxchg_weak_failure_rate: 0.8,\n+            cmpxchg_weak_failure_rate: 0.8, // 80%\n             measureme_out: None,\n             panic_on_unsupported: false,\n             backtrace_style: BacktraceStyle::Short,\n             provenance_mode: ProvenanceMode::Legacy,\n             mute_stdout_stderr: false,\n+            preemption_rate: 0.01, // 1%\n         }\n     }\n }"}, {"sha": "5e93045aec1abd200a429068bc403c8d777cf35b", "filename": "src/machine.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -333,6 +333,9 @@ pub struct Evaluator<'mir, 'tcx> {\n \n     /// Whether weak memory emulation is enabled\n     pub(crate) weak_memory: bool,\n+\n+    /// The probability of the active thread being preempted at the end of each basic block.\n+    pub(crate) preemption_rate: f64,\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n@@ -389,6 +392,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             cmpxchg_weak_failure_rate: config.cmpxchg_weak_failure_rate,\n             mute_stdout_stderr: config.mute_stdout_stderr,\n             weak_memory: config.weak_memory_emulation,\n+            preemption_rate: config.preemption_rate,\n         }\n     }\n \n@@ -846,6 +850,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx.active_thread_stack_mut()\n     }\n \n+    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        ecx.maybe_preempt_active_thread();\n+        Ok(())\n+    }\n+\n     #[inline(always)]\n     fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         if ecx.machine.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }"}, {"sha": "63b9f36d6ffa4edbdd7b3ceba177217de8c6d734", "filename": "src/shims/unix/thread.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fthread.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -13,10 +13,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.tcx.sess.warn(\n-            \"thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\\n(see https://github.com/rust-lang/miri/issues/1388)\",\n-        );\n-\n         // Create the new thread\n         let new_thread_id = this.create_thread();\n "}, {"sha": "9eabbd77419fb82d33dfab10a76fb6aa5d39e807", "filename": "src/thread.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -717,6 +717,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.yield_active_thread();\n     }\n \n+    #[inline]\n+    fn maybe_preempt_active_thread(&mut self) {\n+        use rand::Rng as _;\n+\n+        let this = self.eval_context_mut();\n+        if this.machine.rng.get_mut().gen_bool(this.machine.preemption_rate) {\n+            this.yield_active_thread();\n+        }\n+    }\n+\n     #[inline]\n     fn register_timeout_callback(\n         &mut self,"}, {"sha": "c5093c0e60113a3dd780be2d1eb5601d95bcf9fb", "filename": "tests/fail/concurrency/libc_pthread_create_main_terminate.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_main_terminate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_main_terminate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_main_terminate.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,9 +1,6 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: the main thread terminated without waiting for all remaining threads\n \n note: pass `-Zmiri-ignore-leaks` to disable this check\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "44d0f727a395ec26db4802533d79d7e7cfe4cbf1", "filename": "tests/fail/concurrency/libc_pthread_join_detached.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: trying to join a detached or already joined thread\n   --> $DIR/libc_pthread_join_detached.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL | ...   assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "b67974c58eaef8616d938ad9b70a3f6231478038", "filename": "tests/fail/concurrency/libc_pthread_join_joined.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: trying to join a detached or already joined thread\n   --> $DIR/libc_pthread_join_joined.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL | ...   assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "3e69df508359a772c93093695da8b47cea3f35be", "filename": "tests/fail/concurrency/libc_pthread_join_main.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: trying to join a detached or already joined thread\n   --> $DIR/libc_pthread_join_main.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL | ...   assert_eq!(libc::pthread_join(thread_id, ptr::null_mut()), 0);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "997bca9fe4223a0da6b8a569ee9b277104258ff1", "filename": "tests/fail/concurrency/libc_pthread_join_multiple.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: trying to join a detached or already joined thread\n   --> $DIR/libc_pthread_join_multiple.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL | ...   assert_eq!(libc::pthread_join(native_copy, ptr::null_mut()), 0);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "db45b33c146840bf50ee0b4c8810bd592282e768", "filename": "tests/fail/concurrency/libc_pthread_join_self.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,4 +1,6 @@\n // ignore-windows: No libc on Windows\n+// We are making scheduler assumptions here.\n+// compile-flags: -Zmiri-preemption-rate=0\n \n // Joining itself is undefined behavior.\n "}, {"sha": "8d2acb817f938bf0e19e38c83cd0ff4993ec4686", "filename": "tests/fail/concurrency/libc_pthread_join_self.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: trying to join itself\n   --> $DIR/libc_pthread_join_self.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "a485edc0da93f344a3b955d423849588ce9e3ff1", "filename": "tests/fail/concurrency/thread_local_static_dealloc.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: pointer to ALLOC was dereferenced after this allocation got freed\n   --> $DIR/thread_local_static_dealloc.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |     let _val = *(dangling_ptr as *const u8);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "9d96b718bc305ce6957c9d9ccc3a7afbc6a71213", "filename": "tests/fail/concurrency/too_few_args.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Ftoo_few_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Ftoo_few_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Ftoo_few_args.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: callee has fewer arguments than expected\n   --> $DIR/too_few_args.rs:LL:CC\n    |\n@@ -13,5 +10,5 @@ LL |     panic!()\n    = note: inside `thread_start` at RUSTLIB/std/src/panic.rs:LL:CC\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "7132b8c453afa2059ba0094ddc0609dbf2c0e125", "filename": "tests/fail/concurrency/too_many_args.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Ftoo_many_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Ftoo_many_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Ftoo_many_args.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: callee has more arguments than expected\n   --> $DIR/too_many_args.rs:LL:CC\n    |\n@@ -13,5 +10,5 @@ LL |     panic!()\n    = note: inside `thread_start` at RUSTLIB/std/src/panic.rs:LL:CC\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "35d6f7c38494022cb71560d731bd9e1a86830d1b", "filename": "tests/fail/concurrency/unwind_top_of_stack.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n thread '<unnamed>' panicked at 'explicit panic', $DIR/unwind_top_of_stack.rs:LL:CC\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n error: Undefined Behavior: unwinding past the topmost frame of the stack\n@@ -16,5 +13,5 @@ LL | | }\n            \n    = note: inside `thread_start` at $DIR/unwind_top_of_stack.rs:LL:CC\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "4adb7071f294b9aa9b10d50b48a38f787e6caa1d", "filename": "tests/fail/data_race/alloc_read_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-weak-memory-emulation\n+// compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n #![feature(new_uninit)]\n \n use std::thread::spawn;"}, {"sha": "52004f2d2d025611f8bd261b1a343b736d0981ae", "filename": "tests/fail/data_race/alloc_read_race.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Falloc_read_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Falloc_read_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_read_race.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Read on Thread(id = 2) and Allocate on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/alloc_read_race.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             *pointer.load(Ordering::Relaxed)\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "e4a1192f95b39605eb0b7916a06ce7cead6a6a45", "filename": "tests/fail/data_race/alloc_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-weak-memory-emulation\n+// compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n #![feature(new_uninit)]\n \n use std::thread::spawn;"}, {"sha": "b6c05b34073c51c47d579805abde5c05e28465d9", "filename": "tests/fail/data_race/alloc_write_race.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Falloc_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Falloc_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_write_race.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Allocate on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/alloc_write_race.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             *pointer.load(Ordering::Relaxed) = 2;\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "80e79eb553ee9576a8e0f622dedbc09324888b33", "filename": "tests/fail/data_race/atomic_read_na_write_race1.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Atomic Load on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/atomic_read_na_write_race1.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             atomic_load(c.0 as *mut usize)\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "9a432c586afe7f151d6fce9e6fb57f6df490b969", "filename": "tests/fail/data_race/atomic_read_na_write_race2.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Atomic Load on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/atomic_read_na_write_race2.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             *atomic_ref.get_mut() = 32;\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "8280f43b518fe9ef68c011d37b5d79a828b67f72", "filename": "tests/fail/data_race/atomic_write_na_read_race1.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Read on Thread(id = 2) and Atomic Store on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/atomic_write_na_read_race1.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             *atomic_ref.get_mut()\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "63d0f5814ef4d78d48f2d52b59337acfd9bdeafe", "filename": "tests/fail/data_race/atomic_write_na_read_race2.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Atomic Store on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/atomic_write_na_read_race2.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             atomic_store(c.0 as *mut usize, 32);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "332be7406c82dfc5f078477a9af24e092faa143d", "filename": "tests/fail/data_race/atomic_write_na_write_race1.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Atomic Store on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/atomic_write_na_write_race1.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             atomic_store(c.0 as *mut usize, 64);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "024f525b121353f9cc277988ed9c70f9ada1ad57", "filename": "tests/fail/data_race/atomic_write_na_write_race2.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Atomic Store on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/atomic_write_na_write_race2.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             *atomic_ref.get_mut() = 32;\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "6d31e3971e530b8f6d63248ea1e281cf392789e1", "filename": "tests/fail/data_race/dangling_thread_async_race.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Write on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dangling_thread_async_race.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             *c.0 = 64;\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "ba1ef2760f8f65559ac6ef317a9046cdacba0e1e", "filename": "tests/fail/data_race/dangling_thread_race.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Write on Thread(id = 0, name = \"main\") and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dangling_thread_race.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |         *c.0 = 64;\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "6b5cf5fc02f64a4248bf0a64e45c6124903678f0", "filename": "tests/fail/data_race/dealloc_read_race1.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dealloc_read_race1.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), s\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "f703d1896d91f10cdf17876ccc98bf3204745f32", "filename": "tests/fail/data_race/dealloc_read_race2.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: pointer to ALLOC was dereferenced after this allocation got freed\n   --> $DIR/dealloc_read_race2.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             *ptr.0\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "f458d1126efe73684488ac5125b330bb58ef6231", "filename": "tests/fail/data_race/dealloc_read_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::thread::{spawn, sleep};\n use std::ptr::null_mut;"}, {"sha": "1275d1290b0ac6a867f6faeecae8fb7613099c40", "filename": "tests/fail/data_race/dealloc_read_race_stack.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 1) and Read on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dealloc_read_race_stack.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             }\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "ac9701d49f5f71963cf11bd28297fbd98c2b09d3", "filename": "tests/fail/data_race/dealloc_write_race1.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dealloc_write_race1.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), s\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "37d1c551d49350e9b4d6629bb4509e5c2f48b361", "filename": "tests/fail/data_race/dealloc_write_race2.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: pointer to ALLOC was dereferenced after this allocation got freed\n   --> $DIR/dealloc_write_race2.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             *ptr.0 = 2;\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "d1fe8c3e9a16040e20794f5197bcd37818b7730c", "filename": "tests/fail/data_race/dealloc_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::thread::{spawn, sleep};\n use std::ptr::null_mut;"}, {"sha": "28a131aac07b5c041462b4cbd1886e886bbc3595", "filename": "tests/fail/data_race/dealloc_write_race_stack.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 1) and Write on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dealloc_write_race_stack.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             }\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "db7577b0966e5eedabbee55c0385cc21aa01db21", "filename": "tests/fail/data_race/enable_after_join_to_main.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Write on Thread(id = 6) and Write on Thread(id = 5) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/enable_after_join_to_main.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             *c.0 = 64;\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "17cc6a82a1c2aafd5c8c775598a54a20719d0c9d", "filename": "tests/fail/data_race/fence_after_load.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Ffence_after_load.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Ffence_after_load.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Ffence_after_load.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Write on Thread(id = 0, name = \"main\") and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/fence_after_load.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |     unsafe { V = 2 }\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "b775e2b6fdf1fc7f7305dfda2f448f4a119b14ab", "filename": "tests/fail/data_race/read_write_race.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fread_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fread_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/read_write_race.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             *c.0 = 64;\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "f5c4768296b01aa90219c65b910fc32eda9d3070", "filename": "tests/fail/data_race/read_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation -Zmir-opt-level=0 -Zmiri-disable-weak-memory-emulation\n+// compile-flags: -Zmiri-disable-isolation -Zmir-opt-level=0 -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n // Note: mir-opt-level set to 0 to prevent the read of stack_var in thread 1\n // from being optimized away and preventing the detection of the data-race."}, {"sha": "0f5f4956ffdaeedb164b8b9db87c2cc3d326215e", "filename": "tests/fail/data_race/read_write_race_stack.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Read on Thread(id = 1) and Write on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/read_write_race_stack.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             stack_var\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "64c0f95fa4bae850621256dffef2fe033740335c", "filename": "tests/fail/data_race/relax_acquire_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-weak-memory-emulation\n+// compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::thread::spawn;\n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "fb376b58f2c1670a4125dd7e6c41436dfddbbb73", "filename": "tests/fail/data_race/relax_acquire_race.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/relax_acquire_race.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |                 *c.0\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "964d1b4937b8968b6da7453f90485001fe9ace2b", "filename": "tests/fail/data_race/release_seq_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::thread::{spawn, sleep};\n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "1de9c0ac1c7fd5fb9f01676254fe78f2479c5dc3", "filename": "tests/fail/data_race/release_seq_race.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/release_seq_race.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |                 *c.0\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "01d45a1b7ccf03c8d4f37aa88407194270e368f1", "filename": "tests/fail/data_race/release_seq_race_same_thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::thread::spawn;\n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "9bbdd9a475733034059ff9c1de79cef1f0a85858", "filename": "tests/fail/data_race/release_seq_race_same_thread.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Read on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/release_seq_race_same_thread.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |                 *c.0\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "fab6fabe5b6fb744dc2fe652cf331163debabf51", "filename": "tests/fail/data_race/rmw_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frmw_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frmw_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frmw_race.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-weak-memory-emulation\n+// compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::thread::spawn;\n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "10d3291fa733d9631852b5deca8ceeca3bc252f2", "filename": "tests/fail/data_race/rmw_race.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frmw_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Frmw_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frmw_race.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/rmw_race.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |                 *c.0\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "0054f5bf63a0527b721a9693bd3a5b794b3f88d0", "filename": "tests/fail/data_race/write_write_race.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/write_write_race.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             *c.0 = 64;\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "e6ae207d8610039857a62fa58a96eccb1bc67e01", "filename": "tests/fail/data_race/write_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::thread::{spawn, sleep};\n use std::ptr::null_mut;"}, {"sha": "2012643431f6ea378f99b248c02ea4bd53f34414", "filename": "tests/fail/data_race/write_write_race_stack.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: Data race detected between Write on Thread(id = 1) and Write on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/write_write_race_stack.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL |             stack_var = 1usize;\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "00b03bceb65e4e7d51bfd73bc05e56b9adfe1157", "filename": "tests/fail/should-pass/cpp20_rwc_syncs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,6 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n // compile-flags: -Zmiri-ignore-leaks\n-// error-pattern:\n+// error-pattern: unreachable\n \n // https://plv.mpi-sws.org/scfix/paper.pdf\n // 2.2 Second Problem: SC Fences are Too Weak\n@@ -76,7 +76,7 @@ fn test_cpp20_rwc_syncs() {\n     // Our ui_test does not yet support overriding failure status codes.\n     if (b, c) == (0, 0) {\n         // This *should* be unreachable, but Miri will reach it.\n-        std::process::exit(1);\n+        unsafe { std::hint::unreachable_unchecked(); }\n     }\n }\n "}, {"sha": "9aec82d3336540670318efae799d28d2a1c2a25e", "filename": "tests/fail/should-pass/cpp20_rwc_syncs.stderr", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,3 +1,25 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n+error: Undefined Behavior: entering unreachable code\n+  --> RUSTLIB/core/src/hint.rs:LL:CC\n+   |\n+LL |     unsafe { intrinsics::unreachable() }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ entering unreachable code\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+           \n+   = note: inside `std::hint::unreachable_unchecked` at RUSTLIB/core/src/hint.rs:LL:CC\n+note: inside `test_cpp20_rwc_syncs` at $DIR/cpp20_rwc_syncs.rs:LL:CC\n+  --> $DIR/cpp20_rwc_syncs.rs:LL:CC\n+   |\n+LL |         unsafe { std::hint::unreachable_unchecked(); }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `main` at $DIR/cpp20_rwc_syncs.rs:LL:CC\n+  --> $DIR/cpp20_rwc_syncs.rs:LL:CC\n+   |\n+LL |         test_cpp20_rwc_syncs();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n "}, {"sha": "599655a8692b1b334fa92b1fca60eb257ecba496", "filename": "tests/fail/sync/libc_pthread_mutex_deadlock.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fsync%2Flibc_pthread_mutex_deadlock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fsync%2Flibc_pthread_mutex_deadlock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fsync%2Flibc_pthread_mutex_deadlock.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: deadlock: the evaluated program deadlocked\n   --> $DIR/libc_pthread_mutex_deadlock.rs:LL:CC\n    |\n@@ -11,5 +8,5 @@ LL |             assert_eq!(libc::pthread_mutex_lock(lock_copy.0.get() as *mut _\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "86d02c22819e888e6cd19dc7509f211c6bb8a6f2", "filename": "tests/fail/sync/libc_pthread_mutex_wrong_owner.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fsync%2Flibc_pthread_mutex_wrong_owner.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fsync%2Flibc_pthread_mutex_wrong_owner.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fsync%2Flibc_pthread_mutex_wrong_owner.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: unlocked a default mutex that was not locked by the current thread\n   --> $DIR/libc_pthread_mutex_wrong_owner.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL | ...t_eq!(libc::pthread_mutex_unlock(lock_copy.0.get() as *mut _), 0);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "c7c8823eaa3712db5ac5493a9067891781ed011c", "filename": "tests/fail/sync/libc_pthread_rwlock_read_wrong_owner.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_read_wrong_owner.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_read_wrong_owner.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_read_wrong_owner.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: unlocked an rwlock that was not locked by the active thread\n   --> $DIR/libc_pthread_rwlock_read_wrong_owner.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL | ...   assert_eq!(libc::pthread_rwlock_unlock(lock_copy.0.get() as *mut _),\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "333fb1afb91b7a6bf7ae5e32ab7c90193ef82b24", "filename": "tests/fail/sync/libc_pthread_rwlock_write_read_deadlock.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_read_deadlock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_read_deadlock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_read_deadlock.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: deadlock: the evaluated program deadlocked\n   --> $DIR/libc_pthread_rwlock_write_read_deadlock.rs:LL:CC\n    |\n@@ -11,5 +8,5 @@ LL |             assert_eq!(libc::pthread_rwlock_wrlock(lock_copy.0.get() as *mu\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "93bede54fcf1838df52a48f154bdeccba268e2b7", "filename": "tests/fail/sync/libc_pthread_rwlock_write_write_deadlock.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_write_deadlock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_write_deadlock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_write_deadlock.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: deadlock: the evaluated program deadlocked\n   --> $DIR/libc_pthread_rwlock_write_write_deadlock.rs:LL:CC\n    |\n@@ -11,5 +8,5 @@ LL |             assert_eq!(libc::pthread_rwlock_wrlock(lock_copy.0.get() as *mu\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "a7a17ae71b3ad0583907f2ce2d950039f288d60f", "filename": "tests/fail/sync/libc_pthread_rwlock_write_wrong_owner.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_wrong_owner.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_wrong_owner.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_wrong_owner.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: Undefined Behavior: unlocked an rwlock that was not locked by the active thread\n   --> $DIR/libc_pthread_rwlock_write_wrong_owner.rs:LL:CC\n    |\n@@ -14,5 +11,5 @@ LL | ...   assert_eq!(libc::pthread_rwlock_unlock(lock_copy.0.get() as *mut _),\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "0fb23be06bb783e18aeefee8e362627e1a34612b", "filename": "tests/fail/weak_memory/racing_mixed_size.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: unsupported operation: racy imperfectly overlapping atomic access is not possible in the C++20 memory model, and not supported by Miri's weak memory emulation\n   --> $DIR/racing_mixed_size.rs:LL:CC\n    |\n@@ -13,5 +10,5 @@ LL |             std::intrinsics::atomic_load_relaxed(hi);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "6de185161084bfa439cd6290b1ae5af01c67ee53", "filename": "tests/fail/weak_memory/racing_mixed_size_read.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n error: unsupported operation: racy imperfectly overlapping atomic access is not possible in the C++20 memory model, and not supported by Miri's weak memory emulation\n   --> $DIR/racing_mixed_size_read.rs:LL:CC\n    |\n@@ -13,5 +10,5 @@ LL |             std::intrinsics::atomic_load_relaxed(hi);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/channels.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fchannels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fchannels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fchannels.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/concurrent_caller_location.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/data_race.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fdata_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fdata_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fdata_race.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/disable_data_race_detector.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fdisable_data_race_detector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fdisable_data_race_detector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fdisable_data_race_detector.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/issue1643.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fissue1643.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fissue1643.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fissue1643.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/linux-futex.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Flinux-futex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Flinux-futex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Flinux-futex.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "028cc0fb736ff23700b9fb74387a2a2577ffc74f", "filename": "tests/pass/concurrency/simple.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fconcurrency%2Fsimple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fconcurrency%2Fsimple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsimple.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n thread '<unnamed>' panicked at 'Hello!', $DIR/simple.rs:LL:CC\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n thread 'childthread' panicked at 'Hello, world!', $DIR/simple.rs:LL:CC"}, {"sha": "1e81f5dc86dce5b114d68747e650fb8666efeab7", "filename": "tests/pass/concurrency/spin_loop.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fconcurrency%2Fspin_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fconcurrency%2Fspin_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loop.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -0,0 +1,43 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+use std::thread;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+static FLAG: AtomicUsize = AtomicUsize::new(0);\n+\n+fn spin() {\n+    let j = thread::spawn(|| {\n+        while FLAG.load(Ordering::Acquire) == 0 {\n+            // We do *not* yield, and yet this should terminate eventually.\n+        }\n+    });\n+    thread::yield_now(); // schedule the other thread\n+    FLAG.store(1, Ordering::Release);\n+    j.join().unwrap();\n+}\n+\n+fn two_player_ping_pong() {\n+    static FLAG: AtomicUsize = AtomicUsize::new(0);\n+\n+    let waiter1 = thread::spawn(|| {\n+        while FLAG.load(Ordering::Acquire) == 0 {\n+            // We do *not* yield, and yet this should terminate eventually.\n+        }\n+    });\n+    let waiter2 = thread::spawn(|| {\n+        while FLAG.load(Ordering::Acquire) == 0 {\n+            // We do *not* yield, and yet this should terminate eventually.\n+        }\n+    });\n+    let progress = thread::spawn(|| {\n+        FLAG.store(1, Ordering::Release);\n+    });\n+    // The first `join` blocks the main thread and thus takes it out of the equation.\n+    waiter1.join().unwrap();\n+    waiter2.join().unwrap();\n+    progress.join().unwrap();\n+}\n+\n+fn main() {\n+    spin();\n+    two_player_ping_pong();\n+}"}, {"sha": "d8064f6ed53964630cf1259530a223c2187fc645", "filename": "tests/pass/concurrency/spin_loops_nopreempt.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,4 +1,6 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n+// This specifically tests behavior *without* preemption.\n+// compile-flags: -Zmiri-preemption-rate=0\n \n use std::thread;\n use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};", "previous_filename": "tests/pass/concurrency/spin_loops.rs"}, {"sha": "26f44aa4371896239e714f5f0685958f717a6832", "filename": "tests/pass/concurrency/sync.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsync.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,5 +1,6 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation -Zmiri-strict-provenance\n+// We are making scheduler assumptions here.\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-strict-provenance -Zmiri-preemption-rate=0\n \n use std::sync::{Arc, Barrier, Condvar, Mutex, Once, RwLock};\n use std::thread;"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/sync.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fsync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fsync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsync.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/thread_locals.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fthread_locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Fthread_locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fthread_locals.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/tls_lib_drop.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/libc.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Flibc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Flibc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flibc.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "7b17ac4fa79c1ae95eecd0cb678a2c45efa8e797", "filename": "tests/pass/panic/concurrent-panic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fpanic%2Fconcurrent-panic.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,4 +1,6 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n+// We are making scheduler assumptions here.\n+// compile-flags: -Zmiri-preemption-rate=0\n \n //! Cause a panic in one thread while another thread is unwinding. This checks\n //! that separate threads have their own panicking state."}, {"sha": "fd8fabc89cccf04ce76e7ce0aef295393ab1e96d", "filename": "tests/pass/panic/concurrent-panic.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fpanic%2Fconcurrent-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fpanic%2Fconcurrent-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fpanic%2Fconcurrent-panic.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,6 +1,3 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n Thread 1 starting, will block on mutex\n Thread 1 reported it has started\n thread '<unnamed>' panicked at 'panic in thread 2', $DIR/concurrent-panic.rs:LL:CC"}, {"sha": "7557f49c7584b93e56e57c3fbf20be12f7b96748", "filename": "tests/pass/threadleak_ignored.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fthreadleak_ignored.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fthreadleak_ignored.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fthreadleak_ignored.stderr?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,4 +1 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-\n Dropping 0"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/weak_memory/consistency.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fweak_memory%2Fconsistency.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fweak_memory%2Fconsistency.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fconsistency.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/weak_memory/extra_cpp.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fweak_memory%2Fextra_cpp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fweak_memory%2Fextra_cpp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fextra_cpp.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/weak_memory/extra_cpp_unsafe.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}, {"sha": "e1e9c41e36f5d94489d0891ebbb520dffead38f7", "filename": "tests/pass/weak_memory/weak.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fweak_memory%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad576d8f9e68c8ce78024153ce0bdf92b13fd976/tests%2Fpass%2Fweak_memory%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fweak.rs?ref=ad576d8f9e68c8ce78024153ce0bdf92b13fd976", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-ignore-leaks\n+// compile-flags: -Zmiri-ignore-leaks -Zmiri-preemption-rate=0\n \n // Tests showing weak memory behaviours are exhibited. All tests\n // return true when the desired behaviour is seen."}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/weak_memory/weak.stderr", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fweak_memory%2Fweak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98bd9838554f3d33512db6fae6fa67cede1afaf/tests%2Fpass%2Fweak_memory%2Fweak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fweak.stderr?ref=d98bd9838554f3d33512db6fae6fa67cede1afaf", "patch": "@@ -1,3 +0,0 @@\n-warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n-         (see https://github.com/rust-lang/miri/issues/1388)\n-"}]}