{"sha": "a699f17483baeff87dc027331bce9a552a6b0624", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2OTlmMTc0ODNiYWVmZjg3ZGMwMjczMzFiY2U5YTU1MmE2YjA2MjQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-10T14:04:12Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-16T18:21:37Z"}, "message": "parse: Use string literal parsing in the `asm` macro", "tree": {"sha": "5142f5ba40dd086d783cdcffed2db7d114c7801d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5142f5ba40dd086d783cdcffed2db7d114c7801d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a699f17483baeff87dc027331bce9a552a6b0624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a699f17483baeff87dc027331bce9a552a6b0624", "html_url": "https://github.com/rust-lang/rust/commit/a699f17483baeff87dc027331bce9a552a6b0624", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a699f17483baeff87dc027331bce9a552a6b0624/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b85a3da421abad7d1936ec6e57e43c7b0ff10bd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b85a3da421abad7d1936ec6e57e43c7b0ff10bd3", "html_url": "https://github.com/rust-lang/rust/commit/b85a3da421abad7d1936ec6e57e43c7b0ff10bd3"}], "stats": {"total": 115, "additions": 56, "deletions": 59}, "files": [{"sha": "be1dc4f19a70ec27279061a2114b1d6e78c789c8", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a699f17483baeff87dc027331bce9a552a6b0624/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a699f17483baeff87dc027331bce9a552a6b0624/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=a699f17483baeff87dc027331bce9a552a6b0624", "patch": "@@ -1073,6 +1073,22 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n+    pub fn parse_str_lit(&mut self) -> Result<ast::StrLit, Option<Lit>> {\n+        match self.parse_opt_lit() {\n+            Some(lit) => match lit.kind {\n+                ast::LitKind::Str(symbol_unescaped, style) => Ok(ast::StrLit {\n+                    style,\n+                    symbol: lit.token.symbol,\n+                    suffix: lit.token.suffix,\n+                    span: lit.span,\n+                    symbol_unescaped,\n+                }),\n+                _ => Err(Some(lit)),\n+            }\n+            None => Err(None),\n+        }\n+    }\n+\n     pub(super) fn parse_lit(&mut self) -> PResult<'a, Lit> {\n         self.parse_opt_lit().ok_or_else(|| {\n             let msg = format!(\"unexpected token: {}\", self.this_token_descr());"}, {"sha": "20b96d5cd62f6a6060fd7303526afe1d8ff1c31b", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a699f17483baeff87dc027331bce9a552a6b0624/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a699f17483baeff87dc027331bce9a552a6b0624/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=a699f17483baeff87dc027331bce9a552a6b0624", "patch": "@@ -3,9 +3,9 @@ use super::diagnostics::{Error, dummy_arg, ConsumeClosingDelim};\n \n use crate::maybe_whole;\n \n-use syntax::ast::{self, Abi, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyle, AnonConst, Item};\n+use syntax::ast::{self, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyle, AnonConst, Item};\n use syntax::ast::{ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n-use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness};\n+use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness, Extern, StrLit};\n use syntax::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n use syntax::ast::{Ty, TyKind, Generics, TraitRef, EnumDef, VariantData, StructField};\n use syntax::ast::{Mac, MacDelimiter, Block, BindingMode, FnDecl, FnSig, SelfKind, Param};\n@@ -105,7 +105,7 @@ impl<'a> Parser<'a> {\n                 return Ok(Some(self.parse_item_extern_crate(lo, vis, attrs)?));\n             }\n \n-            let abi = self.parse_opt_abi();\n+            let abi = self.parse_abi();\n \n             if self.eat_keyword(kw::Fn) {\n                 // EXTERN FUNCTION ITEM"}, {"sha": "d5ec46114980659ad45b76ce1ae95ec76b08b710", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 12, "deletions": 42, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a699f17483baeff87dc027331bce9a552a6b0624/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a699f17483baeff87dc027331bce9a552a6b0624/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=a699f17483baeff87dc027331bce9a552a6b0624", "patch": "@@ -15,8 +15,8 @@ use crate::{Directory, DirectoryOwnership};\n use crate::lexer::UnmatchedBrace;\n \n use syntax::ast::{\n-    self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Extern, Ident,\n-    IsAsync, MacDelimiter, Mutability, StrStyle, Visibility, VisibilityKind, Unsafety,\n+    self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Extern, Ident, StrLit,\n+    IsAsync, MacDelimiter, Mutability, Visibility, VisibilityKind, Unsafety,\n };\n \n use syntax::print::pprust;\n@@ -1214,34 +1214,32 @@ impl<'a> Parser<'a> {\n     /// Parses `extern string_literal?`.\n     fn parse_extern(&mut self) -> PResult<'a, Extern> {\n         Ok(if self.eat_keyword(kw::Extern) {\n-            Extern::from_abi(self.parse_opt_abi())\n+            Extern::from_abi(self.parse_abi())\n         } else {\n             Extern::None\n         })\n     }\n \n     /// Parses a string literal as an ABI spec.\n-    fn parse_opt_abi(&mut self) -> Option<StrLit> {\n-        if let Some(ast::Lit { token: token::Lit { symbol, suffix, .. }, span, kind })\n-                = self.parse_opt_lit() {\n-            match kind {\n-                ast::LitKind::Str(symbol_unescaped, style) => return Some(StrLit {\n-                    style, symbol, suffix, span, symbol_unescaped,\n-                }),\n-                ast::LitKind::Err(_) => {}\n+    fn parse_abi(&mut self) -> Option<StrLit> {\n+        match self.parse_str_lit() {\n+            Ok(str_lit) => Some(str_lit),\n+            Err(Some(lit)) => match lit.kind {\n+                ast::LitKind::Err(_) => None,\n                 _ => {\n-                    self.struct_span_err(span, \"non-string ABI literal\")\n+                    self.struct_span_err(lit.span, \"non-string ABI literal\")\n                         .span_suggestion(\n-                            span,\n+                            lit.span,\n                             \"specify the ABI with a string literal\",\n                             \"\\\"C\\\"\".to_string(),\n                             Applicability::MaybeIncorrect,\n                         )\n                         .emit();\n+                    None\n                 }\n             }\n+            Err(None) => None,\n         }\n-        None\n     }\n \n     /// We are parsing `async fn`. If we are on Rust 2015, emit an error.\n@@ -1333,34 +1331,6 @@ impl<'a> Parser<'a> {\n             self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace) ||\n                                    *t == token::BinOp(token::Star))\n     }\n-\n-    fn parse_optional_str(&mut self) -> Option<(Symbol, ast::StrStyle, Option<ast::Name>)> {\n-        let ret = match self.token.kind {\n-            token::Literal(token::Lit { kind: token::Str, symbol, suffix }) =>\n-                (symbol, ast::StrStyle::Cooked, suffix),\n-            token::Literal(token::Lit { kind: token::StrRaw(n), symbol, suffix }) =>\n-                (symbol, ast::StrStyle::Raw(n), suffix),\n-            _ => return None\n-        };\n-        self.bump();\n-        Some(ret)\n-    }\n-\n-    pub fn parse_str(&mut self) -> PResult<'a, (Symbol, StrStyle)> {\n-        match self.parse_optional_str() {\n-            Some((s, style, suf)) => {\n-                let sp = self.prev_span;\n-                self.expect_no_suffix(sp, \"a string literal\", suf);\n-                Ok((s, style))\n-            }\n-            _ => {\n-                let msg = \"expected string literal\";\n-                let mut err = self.fatal(msg);\n-                err.span_label(self.token.span, msg);\n-                Err(err)\n-            }\n-        }\n-    }\n }\n \n crate fn make_unclosed_delims_error("}, {"sha": "9b37143557efb1103c1b281ac528156a8b271e4d", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a699f17483baeff87dc027331bce9a552a6b0624/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a699f17483baeff87dc027331bce9a552a6b0624/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=a699f17483baeff87dc027331bce9a552a6b0624", "patch": "@@ -2,19 +2,17 @@\n //\n use State::*;\n \n+use errors::{DiagnosticBuilder, PResult};\n use rustc_data_structures::thin_vec::ThinVec;\n-\n-use errors::DiagnosticBuilder;\n-\n-use syntax::ast;\n-use syntax_expand::base::{self, *};\n-use syntax::token::{self, Token};\n+use rustc_parse::parser::Parser;\n+use syntax_expand::base::*;\n+use syntax_pos::Span;\n+use syntax::{span_err, struct_span_err};\n+use syntax::ast::{self, AsmDialect};\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym, Symbol};\n-use syntax::ast::AsmDialect;\n-use syntax_pos::Span;\n+use syntax::token::{self, Token};\n use syntax::tokenstream::{self, TokenStream};\n-use syntax::{span_err, struct_span_err};\n \n use rustc_error_codes::*;\n \n@@ -45,7 +43,7 @@ const OPTIONS: &[Symbol] = &[sym::volatile, sym::alignstack, sym::intel];\n pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                        sp: Span,\n                        tts: TokenStream)\n-                       -> Box<dyn base::MacResult + 'cx> {\n+                       -> Box<dyn MacResult + 'cx> {\n     let mut inline_asm = match parse_inline_asm(cx, sp, tts) {\n         Ok(Some(inline_asm)) => inline_asm,\n         Ok(None) => return DummyResult::any(sp),\n@@ -69,6 +67,19 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n     }))\n }\n \n+fn parse_asm_str<'a>(p: &mut Parser<'a>) -> PResult<'a, Symbol> {\n+    match p.parse_str_lit() {\n+        Ok(str_lit) => Ok(str_lit.symbol_unescaped),\n+        Err(opt_lit) => {\n+            let span = opt_lit.map_or(p.token.span, |lit| lit.span);\n+            let msg = \"expected string literal\";\n+            let mut err = p.sess.span_diagnostic.struct_span_fatal(span, msg);\n+            err.span_label(span, msg);\n+            Err(err)\n+        }\n+    }\n+}\n+\n fn parse_inline_asm<'a>(\n     cx: &mut ExtCtxt<'a>,\n     sp: Span,\n@@ -144,7 +155,7 @@ fn parse_inline_asm<'a>(\n                         p.eat(&token::Comma);\n                     }\n \n-                    let (constraint, _) = p.parse_str()?;\n+                    let constraint = parse_asm_str(&mut p)?;\n \n                     let span = p.prev_span;\n \n@@ -189,7 +200,7 @@ fn parse_inline_asm<'a>(\n                         p.eat(&token::Comma);\n                     }\n \n-                    let (constraint, _) = p.parse_str()?;\n+                    let constraint = parse_asm_str(&mut p)?;\n \n                     if constraint.as_str().starts_with(\"=\") {\n                         span_err!(cx, p.prev_span, E0662,\n@@ -212,7 +223,7 @@ fn parse_inline_asm<'a>(\n                         p.eat(&token::Comma);\n                     }\n \n-                    let (s, _) = p.parse_str()?;\n+                    let s = parse_asm_str(&mut p)?;\n \n                     if OPTIONS.iter().any(|&opt| s == opt) {\n                         cx.span_warn(p.prev_span, \"expected a clobber, found an option\");\n@@ -225,7 +236,7 @@ fn parse_inline_asm<'a>(\n                 }\n             }\n             Options => {\n-                let (option, _) = p.parse_str()?;\n+                let option = parse_asm_str(&mut p)?;\n \n                 if option == sym::volatile {\n                     // Indicates that the inline assembly has side effects"}]}