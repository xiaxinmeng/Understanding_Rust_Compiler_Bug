{"sha": "ee8f8bfacd171375b3961ae2bafe0547bffccfaa", "node_id": "C_kwDOAAsO6NoAKGVlOGY4YmZhY2QxNzEzNzViMzk2MWFlMmJhZmUwNTQ3YmZmY2NmYWE", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-24T15:22:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-24T15:22:30Z"}, "message": "Merge pull request #1271 from bjorn3/parallel_comp_support\n\nSupport compiling codegen units in parallel", "tree": {"sha": "f8a402f3bc6f8a5679e57049583a841208023578", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8a402f3bc6f8a5679e57049583a841208023578"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee8f8bfacd171375b3961ae2bafe0547bffccfaa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjBkI2CRBK7hj4Ov3rIwAAovwIAGLW/s+8WDqmVvu5k39ZaEEC\n84iXrm17viiCtjvgK/9uEnlavJ6TVfy/3Z8+BNfos/8aM+S88/SAya4Mwo5p5DM9\nXT1/3QNWPUgATGYv4iy9P4qRC7HBmIhfZmxGcCkCSIoxBeEh8kuxkkJqSRjVw/H8\nvF/qZOCDWz3mVb6ezOTfcUTqVjS1vFani0kaoPsKQ4ONFtar/LjuXwbHIZySAzBV\no8rnw1yKgbGUH45OY1ve57VU9qAJhz2VK+4UNbGgb7mLbGy99hI0TxtcwWW1AaAw\nP1p0r1y2guceG+tgYDNWClEOrBt+/tXoT/X/E9q+V1MFKGgIJIulGtENDIDnZOg=\n=lTo1\n-----END PGP SIGNATURE-----\n", "payload": "tree f8a402f3bc6f8a5679e57049583a841208023578\nparent b1e9d2e1a21f91fee0013b03555f723358890864\nparent 072fd2b0b14e6da232cf51b991766a32456632e0\nauthor bjorn3 <17426603+bjorn3@users.noreply.github.com> 1661354550 +0200\ncommitter GitHub <noreply@github.com> 1661354550 +0200\n\nMerge pull request #1271 from bjorn3/parallel_comp_support\n\nSupport compiling codegen units in parallel"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee8f8bfacd171375b3961ae2bafe0547bffccfaa", "html_url": "https://github.com/rust-lang/rust/commit/ee8f8bfacd171375b3961ae2bafe0547bffccfaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee8f8bfacd171375b3961ae2bafe0547bffccfaa/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1e9d2e1a21f91fee0013b03555f723358890864", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1e9d2e1a21f91fee0013b03555f723358890864", "html_url": "https://github.com/rust-lang/rust/commit/b1e9d2e1a21f91fee0013b03555f723358890864"}, {"sha": "072fd2b0b14e6da232cf51b991766a32456632e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/072fd2b0b14e6da232cf51b991766a32456632e0", "html_url": "https://github.com/rust-lang/rust/commit/072fd2b0b14e6da232cf51b991766a32456632e0"}], "stats": {"total": 375, "additions": 297, "deletions": 78}, "files": [{"sha": "44c34d6c8cb79928ecf5aacac453df0f292bed82", "filename": "src/base.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ee8f8bfacd171375b3961ae2bafe0547bffccfaa/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8f8bfacd171375b3961ae2bafe0547bffccfaa/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=ee8f8bfacd171375b3961ae2bafe0547bffccfaa", "patch": "@@ -5,21 +5,21 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::SymbolName;\n \n use crate::constant::ConstantCx;\n use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n use crate::pretty_clif::CommentWriter;\n \n-struct CodegenedFunction<'tcx> {\n-    symbol_name: SymbolName<'tcx>,\n+pub(crate) struct CodegenedFunction {\n+    symbol_name: String,\n     func_id: FuncId,\n     func: Function,\n     clif_comments: CommentWriter,\n     func_debug_cx: Option<FunctionDebugContext>,\n }\n \n+#[cfg_attr(not(feature = \"jit\"), allow(dead_code))]\n pub(crate) fn codegen_and_compile_fn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     cx: &mut crate::CodegenCx,\n@@ -36,13 +36,13 @@ pub(crate) fn codegen_and_compile_fn<'tcx>(\n     compile_fn(cx, cached_context, module, codegened_func);\n }\n \n-fn codegen_fn<'tcx>(\n+pub(crate) fn codegen_fn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     cx: &mut crate::CodegenCx,\n     cached_func: Function,\n     module: &mut dyn Module,\n     instance: Instance<'tcx>,\n-) -> CodegenedFunction<'tcx> {\n+) -> CodegenedFunction {\n     debug_assert!(!instance.substs.needs_infer());\n \n     let mir = tcx.instance_mir(instance.def);\n@@ -56,9 +56,9 @@ fn codegen_fn<'tcx>(\n     });\n \n     // Declare function\n-    let symbol_name = tcx.symbol_name(instance);\n+    let symbol_name = tcx.symbol_name(instance).name.to_string();\n     let sig = get_function_sig(tcx, module.isa().triple(), instance);\n-    let func_id = module.declare_function(symbol_name.name, Linkage::Local, &sig).unwrap();\n+    let func_id = module.declare_function(&symbol_name, Linkage::Local, &sig).unwrap();\n \n     // Make the FunctionBuilder\n     let mut func_ctx = FunctionBuilderContext::new();\n@@ -81,7 +81,7 @@ fn codegen_fn<'tcx>(\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n     let func_debug_cx = if let Some(debug_context) = &mut cx.debug_context {\n-        Some(debug_context.define_function(tcx, symbol_name.name, mir.span))\n+        Some(debug_context.define_function(tcx, &symbol_name, mir.span))\n     } else {\n         None\n     };\n@@ -113,6 +113,7 @@ fn codegen_fn<'tcx>(\n     tcx.sess.time(\"codegen clif ir\", || codegen_fn_body(&mut fx, start_block));\n \n     // Recover all necessary data from fx, before accessing func will prevent future access to it.\n+    let symbol_name = fx.symbol_name;\n     let clif_comments = fx.clif_comments;\n     let func_debug_cx = fx.func_debug_cx;\n \n@@ -121,7 +122,7 @@ fn codegen_fn<'tcx>(\n     if cx.should_write_ir {\n         crate::pretty_clif::write_clif_file(\n             tcx.output_filenames(()),\n-            symbol_name.name,\n+            &symbol_name,\n             \"unopt\",\n             module.isa(),\n             &func,\n@@ -135,11 +136,11 @@ fn codegen_fn<'tcx>(\n     CodegenedFunction { symbol_name, func_id, func, clif_comments, func_debug_cx }\n }\n \n-fn compile_fn<'tcx>(\n+pub(crate) fn compile_fn(\n     cx: &mut crate::CodegenCx,\n     cached_context: &mut Context,\n     module: &mut dyn Module,\n-    codegened_func: CodegenedFunction<'tcx>,\n+    codegened_func: CodegenedFunction,\n ) {\n     let clif_comments = codegened_func.clif_comments;\n \n@@ -195,7 +196,7 @@ fn compile_fn<'tcx>(\n         // Write optimized function to file for debugging\n         crate::pretty_clif::write_clif_file(\n             &cx.output_filenames,\n-            codegened_func.symbol_name.name,\n+            &codegened_func.symbol_name,\n             \"opt\",\n             module.isa(),\n             &context.func,\n@@ -205,7 +206,7 @@ fn compile_fn<'tcx>(\n         if let Some(disasm) = &context.compiled_code().unwrap().disasm {\n             crate::pretty_clif::write_ir_file(\n                 &cx.output_filenames,\n-                &format!(\"{}.vcode\", codegened_func.symbol_name.name),\n+                &format!(\"{}.vcode\", codegened_func.symbol_name),\n                 |file| file.write_all(disasm.as_bytes()),\n             )\n         }"}, {"sha": "589594465783e1611c688cd17f5c82325ae9576f", "filename": "src/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee8f8bfacd171375b3961ae2bafe0547bffccfaa/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8f8bfacd171375b3961ae2bafe0547bffccfaa/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=ee8f8bfacd171375b3961ae2bafe0547bffccfaa", "patch": "@@ -6,7 +6,6 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::ty::layout::{\n     FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers,\n };\n-use rustc_middle::ty::SymbolName;\n use rustc_span::SourceFile;\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n@@ -246,7 +245,7 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) func_debug_cx: Option<FunctionDebugContext>,\n \n     pub(crate) instance: Instance<'tcx>,\n-    pub(crate) symbol_name: SymbolName<'tcx>,\n+    pub(crate) symbol_name: String,\n     pub(crate) mir: &'tcx Body<'tcx>,\n     pub(crate) fn_abi: Option<&'tcx FnAbi<'tcx, Ty<'tcx>>>,\n "}, {"sha": "dfde97920461e21de9d6cfcc40581d5eda55234e", "filename": "src/concurrency_limiter.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/ee8f8bfacd171375b3961ae2bafe0547bffccfaa/src%2Fconcurrency_limiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8f8bfacd171375b3961ae2bafe0547bffccfaa/src%2Fconcurrency_limiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency_limiter.rs?ref=ee8f8bfacd171375b3961ae2bafe0547bffccfaa", "patch": "@@ -0,0 +1,168 @@\n+use std::sync::{Arc, Condvar, Mutex};\n+\n+use rustc_session::Session;\n+\n+use jobserver::HelperThread;\n+\n+// FIXME don't panic when a worker thread panics\n+\n+pub(super) struct ConcurrencyLimiter {\n+    helper_thread: Option<HelperThread>,\n+    state: Arc<Mutex<state::ConcurrencyLimiterState>>,\n+    available_token_condvar: Arc<Condvar>,\n+}\n+\n+impl ConcurrencyLimiter {\n+    pub(super) fn new(sess: &Session, pending_jobs: usize) -> Self {\n+        let state = Arc::new(Mutex::new(state::ConcurrencyLimiterState::new(pending_jobs)));\n+        let available_token_condvar = Arc::new(Condvar::new());\n+\n+        let state_helper = state.clone();\n+        let available_token_condvar_helper = available_token_condvar.clone();\n+        let helper_thread = sess\n+            .jobserver\n+            .clone()\n+            .into_helper_thread(move |token| {\n+                let mut state = state_helper.lock().unwrap();\n+                state.add_new_token(token.unwrap());\n+                available_token_condvar_helper.notify_one();\n+            })\n+            .unwrap();\n+        ConcurrencyLimiter {\n+            helper_thread: Some(helper_thread),\n+            state,\n+            available_token_condvar: Arc::new(Condvar::new()),\n+        }\n+    }\n+\n+    pub(super) fn acquire(&mut self) -> ConcurrencyLimiterToken {\n+        let mut state = self.state.lock().unwrap();\n+        loop {\n+            state.assert_invariants();\n+\n+            if state.try_start_job() {\n+                return ConcurrencyLimiterToken {\n+                    state: self.state.clone(),\n+                    available_token_condvar: self.available_token_condvar.clone(),\n+                };\n+            }\n+\n+            self.helper_thread.as_mut().unwrap().request_token();\n+            state = self.available_token_condvar.wait(state).unwrap();\n+        }\n+    }\n+\n+    pub(super) fn job_already_done(&mut self) {\n+        let mut state = self.state.lock().unwrap();\n+        state.job_already_done();\n+    }\n+}\n+\n+impl Drop for ConcurrencyLimiter {\n+    fn drop(&mut self) {\n+        //\n+        self.helper_thread.take();\n+\n+        // Assert that all jobs have finished\n+        let state = Mutex::get_mut(Arc::get_mut(&mut self.state).unwrap()).unwrap();\n+        state.assert_done();\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(super) struct ConcurrencyLimiterToken {\n+    state: Arc<Mutex<state::ConcurrencyLimiterState>>,\n+    available_token_condvar: Arc<Condvar>,\n+}\n+\n+impl Drop for ConcurrencyLimiterToken {\n+    fn drop(&mut self) {\n+        let mut state = self.state.lock().unwrap();\n+        state.job_finished();\n+        self.available_token_condvar.notify_one();\n+    }\n+}\n+\n+mod state {\n+    use jobserver::Acquired;\n+\n+    #[derive(Debug)]\n+    pub(super) struct ConcurrencyLimiterState {\n+        pending_jobs: usize,\n+        active_jobs: usize,\n+\n+        // None is used to represent the implicit token, Some to represent explicit tokens\n+        tokens: Vec<Option<Acquired>>,\n+    }\n+\n+    impl ConcurrencyLimiterState {\n+        pub(super) fn new(pending_jobs: usize) -> Self {\n+            ConcurrencyLimiterState { pending_jobs, active_jobs: 0, tokens: vec![None] }\n+        }\n+\n+        pub(super) fn assert_invariants(&self) {\n+            // There must be no excess active jobs\n+            assert!(self.active_jobs <= self.pending_jobs);\n+\n+            // There may not be more active jobs than there are tokens\n+            assert!(self.active_jobs <= self.tokens.len());\n+        }\n+\n+        pub(super) fn assert_done(&self) {\n+            assert_eq!(self.pending_jobs, 0);\n+            assert_eq!(self.active_jobs, 0);\n+        }\n+\n+        pub(super) fn add_new_token(&mut self, token: Acquired) {\n+            self.tokens.push(Some(token));\n+            self.drop_excess_capacity();\n+        }\n+\n+        pub(super) fn try_start_job(&mut self) -> bool {\n+            if self.active_jobs < self.tokens.len() {\n+                // Using existing token\n+                self.job_started();\n+                return true;\n+            }\n+\n+            false\n+        }\n+\n+        pub(super) fn job_started(&mut self) {\n+            self.assert_invariants();\n+            self.active_jobs += 1;\n+            self.drop_excess_capacity();\n+            self.assert_invariants();\n+        }\n+\n+        pub(super) fn job_finished(&mut self) {\n+            self.assert_invariants();\n+            self.pending_jobs -= 1;\n+            self.active_jobs -= 1;\n+            self.assert_invariants();\n+            self.drop_excess_capacity();\n+            self.assert_invariants();\n+        }\n+\n+        pub(super) fn job_already_done(&mut self) {\n+            self.assert_invariants();\n+            self.pending_jobs -= 1;\n+            self.assert_invariants();\n+            self.drop_excess_capacity();\n+            self.assert_invariants();\n+        }\n+\n+        fn drop_excess_capacity(&mut self) {\n+            self.assert_invariants();\n+\n+            // Drop all tokens that can never be used anymore\n+            self.tokens.truncate(std::cmp::max(self.pending_jobs, 1));\n+\n+            // Keep some excess tokens to satisfy requests faster\n+            const MAX_EXTRA_CAPACITY: usize = 2;\n+            self.tokens.truncate(std::cmp::max(self.active_jobs + MAX_EXTRA_CAPACITY, 1));\n+\n+            self.assert_invariants();\n+        }\n+    }\n+}"}, {"sha": "8eabe1cbcb15030380e0ac333315d3326c765629", "filename": "src/driver/aot.rs", "status": "modified", "additions": 112, "deletions": 63, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/ee8f8bfacd171375b3961ae2bafe0547bffccfaa/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8f8bfacd171375b3961ae2bafe0547bffccfaa/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=ee8f8bfacd171375b3961ae2bafe0547bffccfaa", "patch": "@@ -4,6 +4,7 @@\n use std::fs::File;\n use std::path::PathBuf;\n use std::sync::Arc;\n+use std::thread::JoinHandle;\n \n use rustc_codegen_ssa::back::metadata::create_compressed_metadata_file;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n@@ -18,6 +19,7 @@ use rustc_session::Session;\n \n use cranelift_object::{ObjectBuilder, ObjectModule};\n \n+use crate::concurrency_limiter::{ConcurrencyLimiter, ConcurrencyLimiterToken};\n use crate::global_asm::GlobalAsmConfig;\n use crate::{prelude::*, BackendConfig};\n \n@@ -27,18 +29,24 @@ struct ModuleCodegenResult {\n     existing_work_product: Option<(WorkProductId, WorkProduct)>,\n }\n \n-impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n+enum OngoingModuleCodegen {\n+    Sync(Result<ModuleCodegenResult, String>),\n+    Async(JoinHandle<Result<ModuleCodegenResult, String>>),\n+}\n+\n+impl<HCX> HashStable<HCX> for OngoingModuleCodegen {\n     fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n         // do nothing\n     }\n }\n \n pub(crate) struct OngoingCodegen {\n-    modules: Vec<Result<ModuleCodegenResult, String>>,\n+    modules: Vec<OngoingModuleCodegen>,\n     allocator_module: Option<CompiledModule>,\n     metadata_module: Option<CompiledModule>,\n     metadata: EncodedMetadata,\n     crate_info: CrateInfo,\n+    concurrency_limiter: ConcurrencyLimiter,\n }\n \n impl OngoingCodegen {\n@@ -50,7 +58,15 @@ impl OngoingCodegen {\n         let mut work_products = FxHashMap::default();\n         let mut modules = vec![];\n \n-        for module_codegen_result in self.modules {\n+        for module_codegen in self.modules {\n+            let module_codegen_result = match module_codegen {\n+                OngoingModuleCodegen::Sync(module_codegen_result) => module_codegen_result,\n+                OngoingModuleCodegen::Async(join_handle) => match join_handle.join() {\n+                    Ok(module_codegen_result) => module_codegen_result,\n+                    Err(panic) => std::panic::resume_unwind(panic),\n+                },\n+            };\n+\n             let module_codegen_result = match module_codegen_result {\n                 Ok(module_codegen_result) => module_codegen_result,\n                 Err(err) => sess.fatal(&err),\n@@ -90,6 +106,8 @@ impl OngoingCodegen {\n             }\n         }\n \n+        drop(self.concurrency_limiter);\n+\n         (\n             CodegenResults {\n                 modules,\n@@ -233,70 +251,90 @@ fn reuse_workproduct_for_cgu(\n \n fn module_codegen(\n     tcx: TyCtxt<'_>,\n-    (backend_config, global_asm_config, cgu_name): (\n+    (backend_config, global_asm_config, cgu_name, token): (\n         BackendConfig,\n         Arc<GlobalAsmConfig>,\n         rustc_span::Symbol,\n+        ConcurrencyLimiterToken,\n     ),\n-) -> Result<ModuleCodegenResult, String> {\n-    let cgu = tcx.codegen_unit(cgu_name);\n-    let mono_items = cgu.items_in_deterministic_order(tcx);\n+) -> OngoingModuleCodegen {\n+    let (cgu_name, mut cx, mut module, codegened_functions) = tcx.sess.time(\"codegen cgu\", || {\n+        let cgu = tcx.codegen_unit(cgu_name);\n+        let mono_items = cgu.items_in_deterministic_order(tcx);\n+\n+        let mut module = make_module(tcx.sess, &backend_config, cgu_name.as_str().to_string());\n+\n+        let mut cx = crate::CodegenCx::new(\n+            tcx,\n+            backend_config.clone(),\n+            module.isa(),\n+            tcx.sess.opts.debuginfo != DebugInfo::None,\n+            cgu_name,\n+        );\n+        super::predefine_mono_items(tcx, &mut module, &mono_items);\n+        let mut codegened_functions = vec![];\n+        for (mono_item, _) in mono_items {\n+            match mono_item {\n+                MonoItem::Fn(inst) => {\n+                    tcx.sess.time(\"codegen fn\", || {\n+                        let codegened_function = crate::base::codegen_fn(\n+                            tcx,\n+                            &mut cx,\n+                            Function::new(),\n+                            &mut module,\n+                            inst,\n+                        );\n+                        codegened_functions.push(codegened_function);\n+                    });\n+                }\n+                MonoItem::Static(def_id) => {\n+                    crate::constant::codegen_static(tcx, &mut module, def_id)\n+                }\n+                MonoItem::GlobalAsm(item_id) => {\n+                    crate::global_asm::codegen_global_asm_item(tcx, &mut cx.global_asm, item_id);\n+                }\n+            }\n+        }\n+        crate::main_shim::maybe_create_entry_wrapper(\n+            tcx,\n+            &mut module,\n+            &mut cx.unwind_context,\n+            false,\n+            cgu.is_primary(),\n+        );\n \n-    let mut module = make_module(tcx.sess, &backend_config, cgu_name.as_str().to_string());\n+        let cgu_name = cgu.name().as_str().to_owned();\n \n-    let mut cx = crate::CodegenCx::new(\n-        tcx,\n-        backend_config.clone(),\n-        module.isa(),\n-        tcx.sess.opts.debuginfo != DebugInfo::None,\n-        cgu_name,\n-    );\n-    super::predefine_mono_items(tcx, &mut module, &mono_items);\n-    let mut cached_context = Context::new();\n-    for (mono_item, _) in mono_items {\n-        match mono_item {\n-            MonoItem::Fn(inst) => {\n-                tcx.sess.time(\"codegen fn\", || {\n-                    crate::base::codegen_and_compile_fn(\n-                        tcx,\n-                        &mut cx,\n-                        &mut cached_context,\n-                        &mut module,\n-                        inst,\n-                    )\n-                });\n-            }\n-            MonoItem::Static(def_id) => crate::constant::codegen_static(tcx, &mut module, def_id),\n-            MonoItem::GlobalAsm(item_id) => {\n-                crate::global_asm::codegen_global_asm_item(tcx, &mut cx.global_asm, item_id);\n+        (cgu_name, cx, module, codegened_functions)\n+    });\n+\n+    OngoingModuleCodegen::Async(std::thread::spawn(move || {\n+        cx.profiler.clone().verbose_generic_activity(\"compile functions\").run(|| {\n+            let mut cached_context = Context::new();\n+            for codegened_func in codegened_functions {\n+                crate::base::compile_fn(&mut cx, &mut cached_context, &mut module, codegened_func);\n             }\n-        }\n-    }\n-    crate::main_shim::maybe_create_entry_wrapper(\n-        tcx,\n-        &mut module,\n-        &mut cx.unwind_context,\n-        false,\n-        cgu.is_primary(),\n-    );\n+        });\n \n-    let global_asm_object_file = crate::global_asm::compile_global_asm(\n-        &global_asm_config,\n-        cgu.name().as_str(),\n-        &cx.global_asm,\n-    )?;\n-\n-    tcx.sess.time(\"write object file\", || {\n-        emit_cgu(\n-            &global_asm_config.output_filenames,\n-            &cx.profiler,\n-            cgu.name().as_str().to_string(),\n-            module,\n-            cx.debug_context,\n-            cx.unwind_context,\n-            global_asm_object_file,\n-        )\n-    })\n+        let global_asm_object_file =\n+            cx.profiler.verbose_generic_activity(\"compile assembly\").run(|| {\n+                crate::global_asm::compile_global_asm(&global_asm_config, &cgu_name, &cx.global_asm)\n+            })?;\n+\n+        let codegen_result = cx.profiler.verbose_generic_activity(\"write object file\").run(|| {\n+            emit_cgu(\n+                &global_asm_config.output_filenames,\n+                &cx.profiler,\n+                cgu_name,\n+                module,\n+                cx.debug_context,\n+                cx.unwind_context,\n+                global_asm_object_file,\n+            )\n+        });\n+        std::mem::drop(token);\n+        codegen_result\n+    }))\n }\n \n pub(crate) fn run_aot(\n@@ -321,6 +359,8 @@ pub(crate) fn run_aot(\n \n     let global_asm_config = Arc::new(crate::global_asm::GlobalAsmConfig::new(tcx));\n \n+    let mut concurrency_limiter = ConcurrencyLimiter::new(tcx.sess, cgus.len());\n+\n     let modules = super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n         cgus.iter()\n             .map(|cgu| {\n@@ -338,14 +378,22 @@ pub(crate) fn run_aot(\n                             .with_task(\n                                 dep_node,\n                                 tcx,\n-                                (backend_config.clone(), global_asm_config.clone(), cgu.name()),\n+                                (\n+                                    backend_config.clone(),\n+                                    global_asm_config.clone(),\n+                                    cgu.name(),\n+                                    concurrency_limiter.acquire(),\n+                                ),\n                                 module_codegen,\n                                 Some(rustc_middle::dep_graph::hash_result),\n                             )\n                             .0\n                     }\n-                    CguReuse::PreLto => reuse_workproduct_for_cgu(tcx, &*cgu),\n-                    CguReuse::PostLto => unreachable!(),\n+                    CguReuse::PreLto => unreachable!(),\n+                    CguReuse::PostLto => {\n+                        concurrency_limiter.job_already_done();\n+                        OngoingModuleCodegen::Sync(reuse_workproduct_for_cgu(tcx, &*cgu))\n+                    }\n                 }\n             })\n             .collect::<Vec<_>>()\n@@ -424,6 +472,7 @@ pub(crate) fn run_aot(\n         metadata_module,\n         metadata,\n         crate_info: CrateInfo::new(tcx, target_cpu),\n+        concurrency_limiter,\n     })\n }\n \n@@ -453,5 +502,5 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         cgu.name()\n     );\n \n-    if tcx.try_mark_green(&dep_node) { CguReuse::PreLto } else { CguReuse::No }\n+    if tcx.try_mark_green(&dep_node) { CguReuse::PostLto } else { CguReuse::No }\n }"}, {"sha": "913414e7618213d99adb63a711ef18412e747695", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8f8bfacd171375b3961ae2bafe0547bffccfaa/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8f8bfacd171375b3961ae2bafe0547bffccfaa/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ee8f8bfacd171375b3961ae2bafe0547bffccfaa", "patch": "@@ -4,6 +4,7 @@\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n \n+extern crate jobserver;\n #[macro_use]\n extern crate rustc_middle;\n extern crate rustc_ast;\n@@ -53,6 +54,7 @@ mod cast;\n mod codegen_i128;\n mod common;\n mod compiler_builtins;\n+mod concurrency_limiter;\n mod config;\n mod constant;\n mod debuginfo;"}]}