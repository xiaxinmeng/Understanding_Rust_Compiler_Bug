{"sha": "7f1234492e3164f9688027278df7e915bc1d919c", "node_id": "C_kwDOAAsO6NoAKDdmMTIzNDQ5MmUzMTY0Zjk2ODgwMjcyNzhkZjdlOTE1YmMxZDkxOWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-07T17:25:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-07T17:25:31Z"}, "message": "Auto merge of #14084 - Veykril:float-parse, r=Veykril\n\nfix: Fix parsing of nested tuple field accesses in a cursed way\n\nThis is absolutely terrible but seems to work. Macro fragment parsing comes next.", "tree": {"sha": "afd3200dca1e207a0a1cecf672985b6ddccb287d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afd3200dca1e207a0a1cecf672985b6ddccb287d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f1234492e3164f9688027278df7e915bc1d919c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f1234492e3164f9688027278df7e915bc1d919c", "html_url": "https://github.com/rust-lang/rust/commit/7f1234492e3164f9688027278df7e915bc1d919c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f1234492e3164f9688027278df7e915bc1d919c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57ea9826b52c2613056389d491b6e3ab9c0c3630", "url": "https://api.github.com/repos/rust-lang/rust/commits/57ea9826b52c2613056389d491b6e3ab9c0c3630", "html_url": "https://github.com/rust-lang/rust/commit/57ea9826b52c2613056389d491b6e3ab9c0c3630"}, {"sha": "a756c9ad0825d0a113e406adddda8629f2db1214", "url": "https://api.github.com/repos/rust-lang/rust/commits/a756c9ad0825d0a113e406adddda8629f2db1214", "html_url": "https://github.com/rust-lang/rust/commit/a756c9ad0825d0a113e406adddda8629f2db1214"}], "stats": {"total": 510, "additions": 447, "deletions": 63}, "files": [{"sha": "19d01630ef0885bed9c4d5286d9e99d05c453f7e", "filename": "crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -111,7 +111,8 @@ impl ItemTree {\n             Some(node) => node,\n             None => return Default::default(),\n         };\n-        if never!(syntax.kind() == SyntaxKind::ERROR) {\n+        if never!(syntax.kind() == SyntaxKind::ERROR, \"{:?} from {:?} {}\", file_id, syntax, syntax)\n+        {\n             // FIXME: not 100% sure why these crop up, but return an empty tree to avoid a panic\n             return Default::default();\n         }\n@@ -133,7 +134,7 @@ impl ItemTree {\n                     ctx.lower_macro_stmts(stmts)\n                 },\n                 _ => {\n-                    panic!(\"cannot create item tree from {syntax:?} {syntax}\");\n+                    panic!(\"cannot create item tree for file {file_id:?} from {syntax:?} {syntax}\");\n                 },\n             }\n         };"}, {"sha": "49bbc64bff1807b442fefc8b842e91e97d181874", "filename": "crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -97,6 +97,41 @@ fn#19 main#20(#21)#21 {#22\n \"##]],\n     );\n }\n+#[test]\n+fn float_field_acces_macro_input() {\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($expr:expr) => {\n+        fn foo() {\n+            $expr;\n+        }\n+    };\n+}\n+foo!(x .0.1);\n+foo!(x .2. 3);\n+foo!(x .4 .5);\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    ($expr:expr) => {\n+        fn foo() {\n+            $expr;\n+        }\n+    };\n+}\n+fn foo() {\n+    (x.0.1);\n+}\n+fn foo() {\n+    (x.2.3);\n+}\n+fn foo() {\n+    (x.4.5);\n+}\n+\"#]],\n+    );\n+}\n \n #[test]\n fn mbe_smoke_test() {"}, {"sha": "822bdcc122dc6633c49f34ef0d4d23d5dd45a32e", "filename": "crates/hir-def/src/macro_expansion_tests/proc_macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -104,7 +104,7 @@ macro_rules! id {\n         $($t)*\n     };\n }\n-id /*+errors*/! {\n+id! {\n     #[proc_macros::identity]\n     impl Foo for WrapBj {\n         async fn foo(&self) {\n@@ -113,18 +113,17 @@ id /*+errors*/! {\n     }\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n macro_rules! id {\n     ($($t:tt)*) => {\n         $($t)*\n     };\n }\n-/* parse error: expected SEMICOLON */\n #[proc_macros::identity] impl Foo for WrapBj {\n     async fn foo(&self ) {\n         self .0.id().await ;\n     }\n }\n-\"##]],\n+\"#]],\n     );\n }"}, {"sha": "fb5313401088d1d0b5eaf35710dc6eff6df4ad2b", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -95,6 +95,9 @@ pub fn token_tree_to_syntax_node(\n             parser::Step::Token { kind, n_input_tokens: n_raw_tokens } => {\n                 tree_sink.token(kind, n_raw_tokens)\n             }\n+            parser::Step::FloatSplit { ends_in_dot: has_pseudo_dot } => {\n+                tree_sink.float_split(has_pseudo_dot)\n+            }\n             parser::Step::Enter { kind } => tree_sink.start_node(kind),\n             parser::Step::Exit => tree_sink.finish_node(),\n             parser::Step::Error { msg } => tree_sink.error(msg.to_string()),\n@@ -796,6 +799,43 @@ fn delim_to_str(d: tt::DelimiterKind, closing: bool) -> Option<&'static str> {\n }\n \n impl<'a> TtTreeSink<'a> {\n+    /// Parses a float literal as if it was a one to two name ref nodes with a dot inbetween.\n+    /// This occurs when a float literal is used as a field access.\n+    fn float_split(&mut self, has_pseudo_dot: bool) {\n+        let (text, _span) = match self.cursor.token_tree() {\n+            Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Literal(lit), _)) => {\n+                (lit.text.as_str(), lit.span)\n+            }\n+            _ => unreachable!(),\n+        };\n+        match text.split_once('.') {\n+            Some((left, right)) => {\n+                assert!(!left.is_empty());\n+                self.inner.start_node(SyntaxKind::NAME_REF);\n+                self.inner.token(SyntaxKind::INT_NUMBER, left);\n+                self.inner.finish_node();\n+\n+                // here we move the exit up, the original exit has been deleted in process\n+                self.inner.finish_node();\n+\n+                self.inner.token(SyntaxKind::DOT, \".\");\n+\n+                if has_pseudo_dot {\n+                    assert!(right.is_empty(), \"{left}.{right}\");\n+                } else {\n+                    self.inner.start_node(SyntaxKind::NAME_REF);\n+                    self.inner.token(SyntaxKind::INT_NUMBER, right);\n+                    self.inner.finish_node();\n+\n+                    // the parser creates an unbalanced start node, we are required to close it here\n+                    self.inner.finish_node();\n+                }\n+            }\n+            None => unreachable!(),\n+        }\n+        self.cursor = self.cursor.bump();\n+    }\n+\n     fn token(&mut self, kind: SyntaxKind, mut n_tokens: u8) {\n         if kind == LIFETIME_IDENT {\n             n_tokens = 2;"}, {"sha": "051e20b3a3f9c21b0b9efe8983b5f2b872bac307", "filename": "crates/mbe/src/to_parser_input.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -45,6 +45,13 @@ pub(crate) fn to_parser_input(buffer: &TokenBuffer<'_>) -> parser::Input {\n                             .unwrap_or_else(|| panic!(\"Fail to convert given literal {:#?}\", &lit));\n \n                         res.push(kind);\n+\n+                        if kind == FLOAT_NUMBER && !inner_text.ends_with('.') {\n+                            // Tag the token as joint if it is float with a fractional part\n+                            // we use this jointness to inform the parser about what token split\n+                            // event to emit when we encounter a float literal in a field access\n+                            res.was_joint();\n+                        }\n                     }\n                     tt::Leaf::Ident(ident) => match ident.text.as_ref() {\n                         \"_\" => res.push(T![_]),"}, {"sha": "f744481f3aecbe9019c14296f7525f92d6e995f1", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -150,6 +150,11 @@ impl<'a> TtIter<'a> {\n                         cursor = cursor.bump_subtree();\n                     }\n                 }\n+                parser::Step::FloatSplit { .. } => {\n+                    // FIXME: We need to split the tree properly here, but mutating the token trees\n+                    // in the buffer is somewhat tricky to pull off.\n+                    cursor = cursor.bump_subtree();\n+                }\n                 parser::Step::Enter { .. } | parser::Step::Exit => (),\n                 parser::Step::Error { .. } => error = true,\n             }\n@@ -166,19 +171,18 @@ impl<'a> TtIter<'a> {\n \n         if cursor.is_root() {\n             while curr != cursor {\n-                if let Some(token) = curr.token_tree() {\n-                    res.push(token);\n-                }\n+                let Some(token) = curr.token_tree() else { break };\n+                res.push(token.cloned());\n                 curr = curr.bump();\n             }\n         }\n+\n         self.inner = self.inner.as_slice()[res.len()..].iter();\n         let res = match res.len() {\n-            1 => Some(res[0].cloned()),\n-            0 => None,\n+            0 | 1 => res.pop(),\n             _ => Some(tt::TokenTree::Subtree(tt::Subtree {\n                 delimiter: tt::Delimiter::unspecified(),\n-                token_trees: res.into_iter().map(|it| it.cloned()).collect(),\n+                token_trees: res,\n             })),\n         };\n         ExpandResult { value: res, err }"}, {"sha": "577eb0967b4263d4e3814bd0af9a6ccfaa329cad", "filename": "crates/parser/src/event.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fevent.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -74,7 +74,13 @@ pub(crate) enum Event {\n         kind: SyntaxKind,\n         n_raw_tokens: u8,\n     },\n-\n+    /// When we parse `foo.0.0` or `foo. 0. 0` the lexer will hand us a float literal\n+    /// instead of an integer literal followed by a dot as the lexer has no contextual knowledge.\n+    /// This event instructs whatever consumes the events to split the float literal into\n+    /// the corresponding parts.\n+    FloatSplitHack {\n+        ends_in_dot: bool,\n+    },\n     Error {\n         msg: String,\n     },\n@@ -125,6 +131,11 @@ pub(super) fn process(mut events: Vec<Event>) -> Output {\n             Event::Token { kind, n_raw_tokens } => {\n                 res.token(kind, n_raw_tokens);\n             }\n+            Event::FloatSplitHack { ends_in_dot } => {\n+                res.float_split_hack(ends_in_dot);\n+                let ev = mem::replace(&mut events[i + 1], Event::tombstone());\n+                assert!(matches!(ev, Event::Finish), \"{ev:?}\");\n+            }\n             Event::Error { msg } => res.error(msg),\n         }\n     }"}, {"sha": "7516ac3c4bd37f3e9b04617159c5163dd3c24b8f", "filename": "crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 66, "deletions": 32, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -379,7 +379,7 @@ fn postfix_expr(\n             // }\n             T!['('] if allow_calls => call_expr(p, lhs),\n             T!['['] if allow_calls => index_expr(p, lhs),\n-            T![.] => match postfix_dot_expr(p, lhs) {\n+            T![.] => match postfix_dot_expr::<false>(p, lhs) {\n                 Ok(it) => it,\n                 Err(it) => {\n                     lhs = it;\n@@ -393,35 +393,44 @@ fn postfix_expr(\n         block_like = BlockLike::NotBlock;\n     }\n     return (lhs, block_like);\n+}\n \n-    fn postfix_dot_expr(\n-        p: &mut Parser<'_>,\n-        lhs: CompletedMarker,\n-    ) -> Result<CompletedMarker, CompletedMarker> {\n+fn postfix_dot_expr<const FLOAT_RECOVERY: bool>(\n+    p: &mut Parser<'_>,\n+    lhs: CompletedMarker,\n+) -> Result<CompletedMarker, CompletedMarker> {\n+    if !FLOAT_RECOVERY {\n         assert!(p.at(T![.]));\n-        if p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth_at(2, T![::])) {\n-            return Ok(method_call_expr(p, lhs));\n-        }\n+    }\n+    let nth1 = if FLOAT_RECOVERY { 0 } else { 1 };\n+    let nth2 = if FLOAT_RECOVERY { 1 } else { 2 };\n \n-        // test await_expr\n-        // fn foo() {\n-        //     x.await;\n-        //     x.0.await;\n-        //     x.0().await?.hello();\n-        // }\n-        if p.nth(1) == T![await] {\n-            let m = lhs.precede(p);\n-            p.bump(T![.]);\n-            p.bump(T![await]);\n-            return Ok(m.complete(p, AWAIT_EXPR));\n-        }\n+    if p.nth(nth1) == IDENT && (p.nth(nth2) == T!['('] || p.nth_at(nth2, T![::])) {\n+        return Ok(method_call_expr::<FLOAT_RECOVERY>(p, lhs));\n+    }\n \n-        if p.at(T![..=]) || p.at(T![..]) {\n-            return Err(lhs);\n+    // test await_expr\n+    // fn foo() {\n+    //     x.await;\n+    //     x.0.await;\n+    //     x.0().await?.hello();\n+    //     x.0.0.await;\n+    //     x.0. await;\n+    // }\n+    if p.nth(nth1) == T![await] {\n+        let m = lhs.precede(p);\n+        if !FLOAT_RECOVERY {\n+            p.bump(T![.]);\n         }\n+        p.bump(T![await]);\n+        return Ok(m.complete(p, AWAIT_EXPR));\n+    }\n \n-        Ok(field_expr(p, lhs))\n+    if p.at(T![..=]) || p.at(T![..]) {\n+        return Err(lhs);\n     }\n+\n+    field_expr::<FLOAT_RECOVERY>(p, lhs)\n }\n \n // test call_expr\n@@ -455,11 +464,22 @@ fn index_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {\n // fn foo() {\n //     x.foo();\n //     y.bar::<T>(1, 2,);\n+//     x.0.0.call();\n+//     x.0. call();\n // }\n-fn method_call_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(T![.]) && p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth_at(2, T![::])));\n+fn method_call_expr<const FLOAT_RECOVERY: bool>(\n+    p: &mut Parser<'_>,\n+    lhs: CompletedMarker,\n+) -> CompletedMarker {\n+    if FLOAT_RECOVERY {\n+        assert!(p.nth(0) == IDENT && (p.nth(1) == T!['('] || p.nth_at(1, T![::])));\n+    } else {\n+        assert!(p.at(T![.]) && p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth_at(2, T![::])));\n+    }\n     let m = lhs.precede(p);\n-    p.bump_any();\n+    if !FLOAT_RECOVERY {\n+        p.bump(T![.]);\n+    }\n     name_ref(p);\n     generic_args::opt_generic_arg_list(p, true);\n     if p.at(T!['(']) {\n@@ -472,21 +492,35 @@ fn method_call_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker\n // fn foo() {\n //     x.foo;\n //     x.0.bar;\n+//     x.0.1;\n+//     x.0. bar;\n //     x.0();\n // }\n-fn field_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(T![.]));\n+fn field_expr<const FLOAT_RECOVERY: bool>(\n+    p: &mut Parser<'_>,\n+    lhs: CompletedMarker,\n+) -> Result<CompletedMarker, CompletedMarker> {\n+    if !FLOAT_RECOVERY {\n+        assert!(p.at(T![.]));\n+    }\n     let m = lhs.precede(p);\n-    p.bump(T![.]);\n+    if !FLOAT_RECOVERY {\n+        p.bump(T![.]);\n+    }\n     if p.at(IDENT) || p.at(INT_NUMBER) {\n         name_ref_or_index(p);\n     } else if p.at(FLOAT_NUMBER) {\n-        // FIXME: How to recover and instead parse INT + T![.]?\n-        p.bump_any();\n+        return match p.split_float(m) {\n+            (true, m) => {\n+                let lhs = m.complete(p, FIELD_EXPR);\n+                postfix_dot_expr::<true>(p, lhs)\n+            }\n+            (false, m) => Ok(m.complete(p, FIELD_EXPR)),\n+        };\n     } else {\n         p.error(\"expected field name or number\");\n     }\n-    m.complete(p, FIELD_EXPR)\n+    Ok(m.complete(p, FIELD_EXPR))\n }\n \n // test try_expr"}, {"sha": "8c5aed0232ba3282f841e831ed3b318c1cd66fb3", "filename": "crates/parser/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -102,10 +102,14 @@ impl TopEntryPoint {\n                 match step {\n                     Step::Enter { .. } => depth += 1,\n                     Step::Exit => depth -= 1,\n+                    Step::FloatSplit { ends_in_dot: has_pseudo_dot } => {\n+                        depth -= 1 + !has_pseudo_dot as usize\n+                    }\n                     Step::Token { .. } | Step::Error { .. } => (),\n                 }\n             }\n             assert!(!first, \"no tree at all\");\n+            assert_eq!(depth, 0, \"unbalanced tree\");\n         }\n \n         res"}, {"sha": "41d4c68b2d7486c69a969112c4d39ac8ca03ea36", "filename": "crates/parser/src/output.rs", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Foutput.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -25,53 +25,88 @@ pub struct Output {\n #[derive(Debug)]\n pub enum Step<'a> {\n     Token { kind: SyntaxKind, n_input_tokens: u8 },\n+    FloatSplit { ends_in_dot: bool },\n     Enter { kind: SyntaxKind },\n     Exit,\n     Error { msg: &'a str },\n }\n \n impl Output {\n+    const EVENT_MASK: u32 = 0b1;\n+    const TAG_MASK: u32 = 0x0000_00F0;\n+    const N_INPUT_TOKEN_MASK: u32 = 0x0000_FF00;\n+    const KIND_MASK: u32 = 0xFFFF_0000;\n+\n+    const ERROR_SHIFT: u32 = Self::EVENT_MASK.trailing_ones();\n+    const TAG_SHIFT: u32 = Self::TAG_MASK.trailing_zeros();\n+    const N_INPUT_TOKEN_SHIFT: u32 = Self::N_INPUT_TOKEN_MASK.trailing_zeros();\n+    const KIND_SHIFT: u32 = Self::KIND_MASK.trailing_zeros();\n+\n+    const TOKEN_EVENT: u8 = 0;\n+    const ENTER_EVENT: u8 = 1;\n+    const EXIT_EVENT: u8 = 2;\n+    const SPLIT_EVENT: u8 = 3;\n+\n     pub fn iter(&self) -> impl Iterator<Item = Step<'_>> {\n         self.event.iter().map(|&event| {\n-            if event & 0b1 == 0 {\n-                return Step::Error { msg: self.error[(event as usize) >> 1].as_str() };\n+            if event & Self::EVENT_MASK == 0 {\n+                return Step::Error {\n+                    msg: self.error[(event as usize) >> Self::ERROR_SHIFT].as_str(),\n+                };\n             }\n-            let tag = ((event & 0x0000_00F0) >> 4) as u8;\n+            let tag = ((event & Self::TAG_MASK) >> Self::TAG_SHIFT) as u8;\n             match tag {\n-                0 => {\n-                    let kind: SyntaxKind = (((event & 0xFFFF_0000) >> 16) as u16).into();\n-                    let n_input_tokens = ((event & 0x0000_FF00) >> 8) as u8;\n+                Self::TOKEN_EVENT => {\n+                    let kind: SyntaxKind =\n+                        (((event & Self::KIND_MASK) >> Self::KIND_SHIFT) as u16).into();\n+                    let n_input_tokens =\n+                        ((event & Self::N_INPUT_TOKEN_MASK) >> Self::N_INPUT_TOKEN_SHIFT) as u8;\n                     Step::Token { kind, n_input_tokens }\n                 }\n-                1 => {\n-                    let kind: SyntaxKind = (((event & 0xFFFF_0000) >> 16) as u16).into();\n+                Self::ENTER_EVENT => {\n+                    let kind: SyntaxKind =\n+                        (((event & Self::KIND_MASK) >> Self::KIND_SHIFT) as u16).into();\n                     Step::Enter { kind }\n                 }\n-                2 => Step::Exit,\n+                Self::EXIT_EVENT => Step::Exit,\n+                Self::SPLIT_EVENT => {\n+                    Step::FloatSplit { ends_in_dot: event & Self::N_INPUT_TOKEN_MASK != 0 }\n+                }\n                 _ => unreachable!(),\n             }\n         })\n     }\n \n     pub(crate) fn token(&mut self, kind: SyntaxKind, n_tokens: u8) {\n-        let e = ((kind as u16 as u32) << 16) | ((n_tokens as u32) << 8) | 1;\n+        let e = ((kind as u16 as u32) << Self::KIND_SHIFT)\n+            | ((n_tokens as u32) << Self::N_INPUT_TOKEN_SHIFT)\n+            | Self::EVENT_MASK;\n         self.event.push(e)\n     }\n \n+    pub(crate) fn float_split_hack(&mut self, ends_in_dot: bool) {\n+        let e = (Self::SPLIT_EVENT as u32) << Self::TAG_SHIFT\n+            | ((ends_in_dot as u32) << Self::N_INPUT_TOKEN_SHIFT)\n+            | Self::EVENT_MASK;\n+        self.event.push(e);\n+    }\n+\n     pub(crate) fn enter_node(&mut self, kind: SyntaxKind) {\n-        let e = ((kind as u16 as u32) << 16) | (1 << 4) | 1;\n+        let e = ((kind as u16 as u32) << Self::KIND_SHIFT)\n+            | ((Self::ENTER_EVENT as u32) << Self::TAG_SHIFT)\n+            | Self::EVENT_MASK;\n         self.event.push(e)\n     }\n \n     pub(crate) fn leave_node(&mut self) {\n-        let e = 2 << 4 | 1;\n+        let e = (Self::EXIT_EVENT as u32) << Self::TAG_SHIFT | Self::EVENT_MASK;\n         self.event.push(e)\n     }\n \n     pub(crate) fn error(&mut self, error: String) {\n         let idx = self.error.len();\n         self.error.push(error);\n-        let e = (idx as u32) << 1;\n+        let e = (idx as u32) << Self::ERROR_SHIFT;\n         self.event.push(e);\n     }\n }"}, {"sha": "280416ae7c99462af6c452984297ab4e31d32578", "filename": "crates/parser/src/parser.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fparser.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -181,6 +181,35 @@ impl<'t> Parser<'t> {\n         self.do_bump(kind, 1);\n     }\n \n+    /// Advances the parser by one token\n+    pub(crate) fn split_float(&mut self, mut marker: Marker) -> (bool, Marker) {\n+        assert!(self.at(SyntaxKind::FLOAT_NUMBER));\n+        // we have parse `<something>.`\n+        // `<something>`.0.1\n+        // here we need to insert an extra event\n+        //\n+        // `<something>`. 0. 1;\n+        // here we need to change the follow up parse, the return value will cause us to emulate a dot\n+        // the actual splitting happens later\n+        let ends_in_dot = !self.inp.is_joint(self.pos);\n+        if !ends_in_dot {\n+            let new_marker = self.start();\n+            let idx = marker.pos as usize;\n+            match &mut self.events[idx] {\n+                Event::Start { forward_parent, kind } => {\n+                    *kind = SyntaxKind::FIELD_EXPR;\n+                    *forward_parent = Some(new_marker.pos - marker.pos);\n+                }\n+                _ => unreachable!(),\n+            }\n+            marker.bomb.defuse();\n+            marker = new_marker;\n+        };\n+        self.pos += 1 as usize;\n+        self.push_event(Event::FloatSplitHack { ends_in_dot });\n+        (ends_in_dot, marker)\n+    }\n+\n     /// Advances the parser by one token, remapping its kind.\n     /// This is useful to create contextual keywords from\n     /// identifiers. For example, the lexer creates a `union`"}, {"sha": "47e4adcbbe6955acf6f345c81d37fff55f911ecb", "filename": "crates/parser/src/shortcuts.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Fshortcuts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Fshortcuts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fshortcuts.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -43,7 +43,16 @@ impl<'a> LexedStr<'a> {\n                         res.was_joint();\n                     }\n                     res.push(kind);\n+                    // Tag the token as joint if it is float with a fractional part\n+                    // we use this jointness to inform the parser about what token split\n+                    // event to emit when we encounter a float literal in a field access\n+                    if kind == SyntaxKind::FLOAT_NUMBER {\n+                        if !self.text(i).ends_with('.') {\n+                            res.was_joint();\n+                        }\n+                    }\n                 }\n+\n                 was_joint = true;\n             }\n         }\n@@ -63,6 +72,9 @@ impl<'a> LexedStr<'a> {\n                 Step::Token { kind, n_input_tokens: n_raw_tokens } => {\n                     builder.token(kind, n_raw_tokens)\n                 }\n+                Step::FloatSplit { ends_in_dot: has_pseudo_dot } => {\n+                    builder.float_split(has_pseudo_dot)\n+                }\n                 Step::Enter { kind } => builder.enter(kind),\n                 Step::Exit => builder.exit(),\n                 Step::Error { msg } => {\n@@ -109,6 +121,16 @@ impl Builder<'_, '_> {\n         self.do_token(kind, n_tokens as usize);\n     }\n \n+    fn float_split(&mut self, has_pseudo_dot: bool) {\n+        match mem::replace(&mut self.state, State::Normal) {\n+            State::PendingEnter => unreachable!(),\n+            State::PendingExit => (self.sink)(StrStep::Exit),\n+            State::Normal => (),\n+        }\n+        self.eat_trivias();\n+        self.do_float_split(has_pseudo_dot);\n+    }\n+\n     fn enter(&mut self, kind: SyntaxKind) {\n         match mem::replace(&mut self.state, State::Normal) {\n             State::PendingEnter => {\n@@ -164,6 +186,37 @@ impl Builder<'_, '_> {\n         self.pos += n_tokens;\n         (self.sink)(StrStep::Token { kind, text });\n     }\n+\n+    fn do_float_split(&mut self, has_pseudo_dot: bool) {\n+        let text = &self.lexed.range_text(self.pos..self.pos + 1);\n+        self.pos += 1;\n+        match text.split_once('.') {\n+            Some((left, right)) => {\n+                assert!(!left.is_empty());\n+                (self.sink)(StrStep::Enter { kind: SyntaxKind::NAME_REF });\n+                (self.sink)(StrStep::Token { kind: SyntaxKind::INT_NUMBER, text: left });\n+                (self.sink)(StrStep::Exit);\n+\n+                // here we move the exit up, the original exit has been deleted in process\n+                (self.sink)(StrStep::Exit);\n+\n+                (self.sink)(StrStep::Token { kind: SyntaxKind::DOT, text: \".\" });\n+\n+                if has_pseudo_dot {\n+                    assert!(right.is_empty(), \"{left}.{right}\");\n+                    self.state = State::Normal;\n+                } else {\n+                    (self.sink)(StrStep::Enter { kind: SyntaxKind::NAME_REF });\n+                    (self.sink)(StrStep::Token { kind: SyntaxKind::INT_NUMBER, text: right });\n+                    (self.sink)(StrStep::Exit);\n+\n+                    // the parser creates an unbalanced start node, we are required to close it here\n+                    self.state = State::PendingExit;\n+                }\n+            }\n+            None => unreachable!(),\n+        }\n+    }\n }\n \n fn n_attached_trivias<'a>("}, {"sha": "40f92e58804f925018c59518a66f811594794169", "filename": "crates/parser/src/tests/prefix_entries.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Ftests%2Fprefix_entries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Fsrc%2Ftests%2Fprefix_entries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Ftests%2Fprefix_entries.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -51,6 +51,9 @@ fn expr() {\n     check(PrefixEntryPoint::Expr, \"-1\", \"-1\");\n     check(PrefixEntryPoint::Expr, \"fn foo() {}\", \"fn\");\n     check(PrefixEntryPoint::Expr, \"#[attr] ()\", \"#[attr] ()\");\n+    check(PrefixEntryPoint::Expr, \"foo.0\", \"foo.0\");\n+    check(PrefixEntryPoint::Expr, \"foo.0.1\", \"foo.0.1\");\n+    check(PrefixEntryPoint::Expr, \"foo.0. foo\", \"foo.0. foo\");\n }\n \n #[test]\n@@ -88,6 +91,7 @@ fn check(entry: PrefixEntryPoint, input: &str, prefix: &str) {\n     for step in entry.parse(&input).iter() {\n         match step {\n             Step::Token { n_input_tokens, .. } => n_tokens += n_input_tokens as usize,\n+            Step::FloatSplit { .. } => n_tokens += 1,\n             Step::Enter { .. } | Step::Exit | Step::Error { .. } => (),\n         }\n     }"}, {"sha": "dd27dc48964242015e5420418f085d7037ed0597", "filename": "crates/parser/test_data/parser/inline/ok/0011_field_expr.rast", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rast?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -40,6 +40,39 @@ SOURCE_FILE\n               IDENT \"bar\"\n           SEMICOLON \";\"\n         WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          FIELD_EXPR\n+            FIELD_EXPR\n+              PATH_EXPR\n+                PATH\n+                  PATH_SEGMENT\n+                    NAME_REF\n+                      IDENT \"x\"\n+              DOT \".\"\n+              NAME_REF\n+                INT_NUMBER \"0\"\n+            DOT \".\"\n+            NAME_REF\n+              INT_NUMBER \"1\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          FIELD_EXPR\n+            FIELD_EXPR\n+              PATH_EXPR\n+                PATH\n+                  PATH_SEGMENT\n+                    NAME_REF\n+                      IDENT \"x\"\n+              DOT \".\"\n+              NAME_REF\n+                INT_NUMBER \"0\"\n+            DOT \".\"\n+            WHITESPACE \" \"\n+            NAME_REF\n+              IDENT \"bar\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n         EXPR_STMT\n           CALL_EXPR\n             FIELD_EXPR"}, {"sha": "98dbe45a7ec92531842c86179be30b2d38e3d133", "filename": "crates/parser/test_data/parser/inline/ok/0011_field_expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -1,5 +1,7 @@\n fn foo() {\n     x.foo;\n     x.0.bar;\n+    x.0.1;\n+    x.0. bar;\n     x.0();\n }"}, {"sha": "b28b8eb673a7033c5990b54f75e758f8369e0d3e", "filename": "crates/parser/test_data/parser/inline/ok/0107_method_call_expr.rast", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rast?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -58,6 +58,49 @@ SOURCE_FILE\n               COMMA \",\"\n               R_PAREN \")\"\n           SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          METHOD_CALL_EXPR\n+            FIELD_EXPR\n+              FIELD_EXPR\n+                PATH_EXPR\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"x\"\n+                DOT \".\"\n+                NAME_REF\n+                  INT_NUMBER \"0\"\n+              DOT \".\"\n+              NAME_REF\n+                INT_NUMBER \"0\"\n+            DOT \".\"\n+            NAME_REF\n+              IDENT \"call\"\n+            ARG_LIST\n+              L_PAREN \"(\"\n+              R_PAREN \")\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          METHOD_CALL_EXPR\n+            FIELD_EXPR\n+              PATH_EXPR\n+                PATH\n+                  PATH_SEGMENT\n+                    NAME_REF\n+                      IDENT \"x\"\n+              DOT \".\"\n+              NAME_REF\n+                INT_NUMBER \"0\"\n+            DOT \".\"\n+            WHITESPACE \" \"\n+            NAME_REF\n+              IDENT \"call\"\n+            ARG_LIST\n+              L_PAREN \"(\"\n+              R_PAREN \")\"\n+          SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\""}, {"sha": "48bb6381e80bf8e84bd173457137457595e3ef45", "filename": "crates/parser/test_data/parser/inline/ok/0107_method_call_expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -1,4 +1,6 @@\n fn foo() {\n     x.foo();\n     y.bar::<T>(1, 2,);\n+    x.0.0.call();\n+    x.0. call();\n }"}, {"sha": "af713a22072fe5d4e67a81d978742708263651a6", "filename": "crates/parser/test_data/parser/inline/ok/0137_await_expr.rast", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0137_await_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0137_await_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0137_await_expr.rast?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -65,6 +65,41 @@ SOURCE_FILE\n               L_PAREN \"(\"\n               R_PAREN \")\"\n           SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          AWAIT_EXPR\n+            FIELD_EXPR\n+              FIELD_EXPR\n+                PATH_EXPR\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"x\"\n+                DOT \".\"\n+                NAME_REF\n+                  INT_NUMBER \"0\"\n+              DOT \".\"\n+              NAME_REF\n+                INT_NUMBER \"0\"\n+            DOT \".\"\n+            AWAIT_KW \"await\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          AWAIT_EXPR\n+            FIELD_EXPR\n+              PATH_EXPR\n+                PATH\n+                  PATH_SEGMENT\n+                    NAME_REF\n+                      IDENT \"x\"\n+              DOT \".\"\n+              NAME_REF\n+                INT_NUMBER \"0\"\n+            DOT \".\"\n+            WHITESPACE \" \"\n+            AWAIT_KW \"await\"\n+          SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\""}, {"sha": "fe9a3211bb18d2061eb86e8702bfe991d747068c", "filename": "crates/parser/test_data/parser/inline/ok/0137_await_expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0137_await_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0137_await_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0137_await_expr.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -2,4 +2,6 @@ fn foo() {\n     x.await;\n     x.0.await;\n     x.0().await?.hello();\n+    x.0.0.await;\n+    x.0. await;\n }"}, {"sha": "0615a3763dfa1c172c8be30ea9de0d00693c1b76", "filename": "crates/tt/src/buffer.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Ftt%2Fsrc%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1234492e3164f9688027278df7e915bc1d919c/crates%2Ftt%2Fsrc%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftt%2Fsrc%2Fbuffer.rs?ref=7f1234492e3164f9688027278df7e915bc1d919c", "patch": "@@ -7,7 +7,12 @@ use crate::{Leaf, Subtree, TokenTree};\n struct EntryId(usize);\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-struct EntryPtr(EntryId, usize);\n+struct EntryPtr(\n+    /// The index of the buffer containing the entry.\n+    EntryId,\n+    /// The index of the entry within the buffer.\n+    usize,\n+);\n \n /// Internal type which is used instead of `TokenTree` to represent a token tree\n /// within a `TokenBuffer`.\n@@ -16,8 +21,8 @@ enum Entry<'t, Span> {\n     // Mimicking types from proc-macro.\n     Subtree(Option<&'t TokenTree<Span>>, &'t Subtree<Span>, EntryId),\n     Leaf(&'t TokenTree<Span>),\n-    // End entries contain a pointer to the entry from the containing\n-    // token tree, or None if this is the outermost level.\n+    /// End entries contain a pointer to the entry from the containing\n+    /// token tree, or [`None`] if this is the outermost level.\n     End(Option<EntryPtr>),\n }\n \n@@ -226,8 +231,14 @@ impl<'a, Span> Cursor<'a, Span> {\n     /// a cursor into that subtree\n     pub fn bump_subtree(self) -> Cursor<'a, Span> {\n         match self.entry() {\n-            Some(Entry::Subtree(_, _, _)) => self.subtree().unwrap(),\n-            _ => self.bump(),\n+            Some(&Entry::Subtree(_, _, entry_id)) => {\n+                Cursor::create(self.buffer, EntryPtr(entry_id, 0))\n+            }\n+            Some(Entry::End(exit)) => match exit {\n+                Some(exit) => Cursor::create(self.buffer, *exit),\n+                None => self,\n+            },\n+            _ => Cursor::create(self.buffer, EntryPtr(self.ptr.0, self.ptr.1 + 1)),\n         }\n     }\n "}]}