{"sha": "0a440b159436ad3c75d25b24ce5d43086b567872", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNDQwYjE1OTQzNmFkM2M3NWQyNWIyNGNlNWQ0MzA4NmI1Njc4NzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-21T14:30:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-21T14:30:26Z"}, "message": "Auto merge of #67485 - Centril:rollup-gt0opvr, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #67059 (Fix too restrictive checks on Drop impls)\n - #67355 (Merge `ast::Mutability` and `mir::Mutability`)\n - #67393 (Enable opting out of specific default LLVM arguments.)\n - #67422 (Cleanup err codes)\n - #67462 (Make ptr::slice_from_raw_parts a const fn available under a feature flag)\n - #67467 (Test slice patterns more)\n - #67478 (Fix src/libcore/str/mod.rs doc comments)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e06d52ecf3aa773bf54931fb18503b3fb5f89567", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e06d52ecf3aa773bf54931fb18503b3fb5f89567"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a440b159436ad3c75d25b24ce5d43086b567872", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a440b159436ad3c75d25b24ce5d43086b567872", "html_url": "https://github.com/rust-lang/rust/commit/0a440b159436ad3c75d25b24ce5d43086b567872", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a440b159436ad3c75d25b24ce5d43086b567872/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "url": "https://api.github.com/repos/rust-lang/rust/commits/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "html_url": "https://github.com/rust-lang/rust/commit/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06"}, {"sha": "466fdeaed5bba6570aeaaaa99cecef17e7007ca6", "url": "https://api.github.com/repos/rust-lang/rust/commits/466fdeaed5bba6570aeaaaa99cecef17e7007ca6", "html_url": "https://github.com/rust-lang/rust/commit/466fdeaed5bba6570aeaaaa99cecef17e7007ca6"}], "stats": {"total": 1677, "additions": 1301, "deletions": 376}, "files": [{"sha": "924563fc44f6e74f632e1ebd31dcad62815afd86", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -259,7 +259,8 @@ pub(crate) struct FatPtr<T> {\n /// ```\n #[inline]\n #[unstable(feature = \"slice_from_raw_parts\", reason = \"recently added\", issue = \"36925\")]\n-pub fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n+#[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n+pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n     unsafe { Repr { raw: FatPtr { data, len } }.rust }\n }\n \n@@ -275,7 +276,8 @@ pub fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n /// [`from_raw_parts_mut`]: ../../std/slice/fn.from_raw_parts_mut.html\n #[inline]\n #[unstable(feature = \"slice_from_raw_parts\", reason = \"recently added\", issue = \"36925\")]\n-pub fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n+#[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n+pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n     unsafe { Repr { raw: FatPtr { data, len } }.rust_mut }\n }\n "}, {"sha": "e2cc99813aca55eb2461bb7ed7c18090478f3c4e", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -2325,7 +2325,7 @@ impl str {\n         i.get_mut(self)\n     }\n \n-    /// Returns a unchecked subslice of `str`.\n+    /// Returns an unchecked subslice of `str`.\n     ///\n     /// This is the unchecked alternative to indexing the `str`.\n     ///"}, {"sha": "1f20ebc01e9937d62f26fb38a51f21701b2467ba", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -36,6 +36,9 @@\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]\n #![feature(cmp_min_max_by)]\n+#![feature(slice_from_raw_parts)]\n+#![feature(const_slice_from_raw_parts)]\n+#![feature(const_raw_ptr_deref)]\n \n extern crate test;\n "}, {"sha": "473bc881d2932a8775b4213bdb8a84bc5408a487", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1,6 +1,17 @@\n use core::cell::RefCell;\n use core::ptr::*;\n \n+#[test]\n+fn test_const_from_raw_parts() {\n+    const SLICE: &[u8] = &[1, 2, 3, 4];\n+    const FROM_RAW: &[u8] = unsafe { &*slice_from_raw_parts(SLICE.as_ptr(), SLICE.len()) };\n+    assert_eq!(SLICE, FROM_RAW);\n+\n+    let slice = &[1, 2, 3, 4, 5];\n+    let from_raw = unsafe { &*slice_from_raw_parts(slice.as_ptr(), 2) } ;\n+    assert_eq!(&slice[..2], from_raw);\n+}\n+\n #[test]\n fn test() {\n     unsafe {"}, {"sha": "2fd708f1ea344b00ded6bd88d0d4bfb379f09151", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -2253,7 +2253,7 @@ impl<'a> LoweringContext<'a> {\n                     let is_mutable_pat = match arg.pat.kind {\n                         PatKind::Ident(BindingMode::ByValue(mt), _, _) |\n                         PatKind::Ident(BindingMode::ByRef(mt), _, _) =>\n-                            mt == Mutability::Mutable,\n+                            mt == Mutability::Mut,\n                         _ => false,\n                     };\n \n@@ -2264,7 +2264,7 @@ impl<'a> LoweringContext<'a> {\n                         // the case where we have a mutable pattern to a reference as that would\n                         // no longer be an `ImplicitSelf`.\n                         TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() &&\n-                            mt.mutbl == ast::Mutability::Mutable =>\n+                            mt.mutbl == ast::Mutability::Mut =>\n                                 hir::ImplicitSelfKind::MutRef,\n                         TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() =>\n                             hir::ImplicitSelfKind::ImmRef,\n@@ -3068,10 +3068,10 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingAnnotation {\n         match *b {\n-            BindingMode::ByValue(Mutability::Immutable) => hir::BindingAnnotation::Unannotated,\n-            BindingMode::ByRef(Mutability::Immutable) => hir::BindingAnnotation::Ref,\n-            BindingMode::ByValue(Mutability::Mutable) => hir::BindingAnnotation::Mutable,\n-            BindingMode::ByRef(Mutability::Mutable) => hir::BindingAnnotation::RefMut,\n+            BindingMode::ByValue(Mutability::Not) => hir::BindingAnnotation::Unannotated,\n+            BindingMode::ByRef(Mutability::Not) => hir::BindingAnnotation::Ref,\n+            BindingMode::ByValue(Mutability::Mut) => hir::BindingAnnotation::Mutable,\n+            BindingMode::ByRef(Mutability::Mut) => hir::BindingAnnotation::RefMut,\n         }\n     }\n "}, {"sha": "a1a37719812b6fba2523a0437093f38708a73c3b", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1340,7 +1340,7 @@ impl LoweringContext<'_> {\n     fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n         self.expr(\n             span,\n-            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mutable, e),\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e),\n             ThinVec::new(),\n         )\n     }"}, {"sha": "b59c7438005b22a8b96b5cc0daebba919681e908", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -169,11 +169,10 @@ impl hir::Pat {\n         self.each_binding(|annotation, _, _, _| {\n             match annotation {\n                 hir::BindingAnnotation::Ref => match result {\n-                    None | Some(hir::Mutability::Immutable) =>\n-                        result = Some(hir::Mutability::Immutable),\n+                    None | Some(hir::Mutability::Not) => result = Some(hir::Mutability::Not),\n                     _ => {}\n                 }\n-                hir::BindingAnnotation::RefMut => result = Some(hir::Mutability::Mutable),\n+                hir::BindingAnnotation::RefMut => result = Some(hir::Mutability::Mut),\n                 _ => {}\n             }\n         });"}, {"sha": "92ad1c38fa04335097a61a384125e5d2de385da3", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -386,7 +386,7 @@ impl<'a> State<'a> {\n             }\n             hir::ForeignItemKind::Static(ref t, m) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == hir::Mutability::Mutable {\n+                if m == hir::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -502,7 +502,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Static(ref ty, m, expr) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == hir::Mutability::Mutable {\n+                if m == hir::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -1632,11 +1632,11 @@ impl<'a> State<'a> {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Immutable, false);\n+                        self.print_mutability(hir::Mutability::Not, false);\n                     }\n                     hir::BindingAnnotation::RefMut => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Mutable, false);\n+                        self.print_mutability(hir::Mutability::Mut, false);\n                     }\n                     hir::BindingAnnotation::Unannotated => {}\n                     hir::BindingAnnotation::Mutable => {\n@@ -2065,8 +2065,8 @@ impl<'a> State<'a> {\n \n     pub fn print_mutability(&mut self, mutbl: hir::Mutability, print_const: bool) {\n         match mutbl {\n-            hir::Mutability::Mutable => self.word_nbsp(\"mut\"),\n-            hir::Mutability::Immutable => if print_const { self.word_nbsp(\"const\") },\n+            hir::Mutability::Mut => self.word_nbsp(\"mut\"),\n+            hir::Mutability::Not => if print_const { self.word_nbsp(\"const\") },\n         }\n     }\n "}, {"sha": "f80a72365e361de3eed56712e704e8554d00cf7f", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                     }\n                 }\n             }\n-            TyKind::Rptr(_, MutTy { ty: inner_ty, mutbl: Mutability::Immutable }) => {\n+            TyKind::Rptr(_, MutTy { ty: inner_ty, mutbl: Mutability::Not }) => {\n                 if let Some(impl_did) = cx.tcx.impl_of_method(ty.hir_id.owner_def_id()) {\n                     if cx.tcx.impl_trait_ref(impl_did).is_some() {\n                         return;"}, {"sha": "a1bb80f6179e22f6654885c3fa8e8f211be0cb0f", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -106,7 +106,7 @@ impl<Tag> Allocation<Tag> {\n             undef_mask: UndefMask::new(size, true),\n             size,\n             align,\n-            mutability: Mutability::Immutable,\n+            mutability: Mutability::Not,\n             extra: (),\n         }\n     }\n@@ -123,7 +123,7 @@ impl<Tag> Allocation<Tag> {\n             undef_mask: UndefMask::new(size, false),\n             size,\n             align,\n-            mutability: Mutability::Mutable,\n+            mutability: Mutability::Mut,\n             extra: (),\n         }\n     }"}, {"sha": "0757e02da970d7ab95c413d6eebdf92fa36341be", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -34,6 +34,7 @@ use std::ops::Index;\n use std::slice;\n use std::{iter, mem, option, u32};\n use syntax::ast::Name;\n+pub use syntax::ast::Mutability;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -396,22 +397,7 @@ pub struct SourceInfo {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Mutability and borrow kinds\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum Mutability {\n-    Mut,\n-    Not,\n-}\n-\n-impl From<Mutability> for hir::Mutability {\n-    fn from(m: Mutability) -> Self {\n-        match m {\n-            Mutability::Mut => hir::Mutability::Mutable,\n-            Mutability::Not => hir::Mutability::Immutable,\n-        }\n-    }\n-}\n+// Borrow kinds\n \n #[derive(\n     Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, HashStable,\n@@ -2886,7 +2872,6 @@ pub enum ClosureOutlivesSubject<'tcx> {\n CloneTypeFoldableAndLiftImpls! {\n     BlockTailInfo,\n     MirPhase,\n-    Mutability,\n     SourceInfo,\n     FakeReadCause,\n     RetagKind,"}, {"sha": "841c0b458d157a3e78549fdd037fce31194c6530", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -279,17 +279,17 @@ impl<'tcx> BinOp {\n impl BorrowKind {\n     pub fn to_mutbl_lossy(self) -> hir::Mutability {\n         match self {\n-            BorrowKind::Mut { .. } => hir::Mutability::Mutable,\n-            BorrowKind::Shared => hir::Mutability::Immutable,\n+            BorrowKind::Mut { .. } => hir::Mutability::Mut,\n+            BorrowKind::Shared => hir::Mutability::Not,\n \n             // We have no type corresponding to a unique imm borrow, so\n             // use `&mut`. It gives all the capabilities of an `&uniq`\n             // and hence is a safe \"over approximation\".\n-            BorrowKind::Unique => hir::Mutability::Mutable,\n+            BorrowKind::Unique => hir::Mutability::Mut,\n \n             // We have no type corresponding to a shallow borrow, so use\n             // `&` as an approximation.\n-            BorrowKind::Shallow => hir::Mutability::Immutable,\n+            BorrowKind::Shallow => hir::Mutability::Not,\n         }\n     }\n }"}, {"sha": "735627578a6275019ba689bff1da905e84e7fd5a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1548,8 +1548,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             if let ty::Ref(region, t_type, mutability) = trait_ref.skip_binder().self_ty().kind {\n                 let trait_type = match mutability {\n-                    hir::Mutability::Mutable => self.tcx.mk_imm_ref(region, t_type),\n-                    hir::Mutability::Immutable => self.tcx.mk_mut_ref(region, t_type),\n+                    hir::Mutability::Mut => self.tcx.mk_imm_ref(region, t_type),\n+                    hir::Mutability::Not => self.tcx.mk_mut_ref(region, t_type),\n                 };\n \n                 let new_obligation = self.mk_obligation_for_def_id(\n@@ -1565,7 +1565,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let sp = self.tcx.sess.source_map()\n                         .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n                     if points_at_arg &&\n-                        mutability == hir::Mutability::Immutable &&\n+                        mutability == hir::Mutability::Not &&\n                         refs_number > 0\n                     {\n                         err.span_suggestion("}, {"sha": "f1cd002d19b647533b889e2664348034881ec884", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -2622,7 +2622,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Char\n             | ty::RawPtr(..)\n             | ty::Never\n-            | ty::Ref(_, _, hir::Mutability::Immutable) => {\n+            | ty::Ref(_, _, hir::Mutability::Not) => {\n                 // Implementations provided in libcore\n                 None\n             }\n@@ -2633,7 +2633,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n             | ty::Foreign(..)\n-            | ty::Ref(_, _, hir::Mutability::Mutable) => None,\n+            | ty::Ref(_, _, hir::Mutability::Mut) => None,\n \n             ty::Array(element_ty, _) => {\n                 // (*) binder moved here"}, {"sha": "0c04ba96365ed0999477921692c8ae7737186fac", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -109,8 +109,8 @@ pub struct OverloadedDeref<'tcx> {\n impl<'tcx> OverloadedDeref<'tcx> {\n     pub fn method_call(&self, tcx: TyCtxt<'tcx>, source: Ty<'tcx>) -> (DefId, SubstsRef<'tcx>) {\n         let trait_def_id = match self.mutbl {\n-            hir::Mutability::Immutable => tcx.lang_items().deref_trait(),\n-            hir::Mutability::Mutable => tcx.lang_items().deref_mut_trait()\n+            hir::Mutability::Not => tcx.lang_items().deref_trait(),\n+            hir::Mutability::Mut => tcx.lang_items().deref_mut_trait()\n         };\n         let method_def_id = tcx.associated_items(trait_def_id.unwrap())\n             .find(|m| m.kind == ty::AssocKind::Method).unwrap().def_id;\n@@ -138,15 +138,15 @@ pub enum AllowTwoPhase {\n \n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum AutoBorrowMutability {\n-    Mutable { allow_two_phase_borrow: AllowTwoPhase },\n-    Immutable,\n+    Mut { allow_two_phase_borrow: AllowTwoPhase },\n+    Not,\n }\n \n impl From<AutoBorrowMutability> for hir::Mutability {\n     fn from(m: AutoBorrowMutability) -> Self {\n         match m {\n-            AutoBorrowMutability::Mutable { .. } => hir::Mutability::Mutable,\n-            AutoBorrowMutability::Immutable => hir::Mutability::Immutable,\n+            AutoBorrowMutability::Mut { .. } => hir::Mutability::Mut,\n+            AutoBorrowMutability::Not => hir::Mutability::Not,\n         }\n     }\n }"}, {"sha": "00cff1f1be17fd675e65d97ec1ddb879061f3328", "filename": "src/librustc/ty/binding.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -13,10 +13,10 @@ CloneTypeFoldableAndLiftImpls! { BindingMode, }\n impl BindingMode {\n     pub fn convert(ba: BindingAnnotation) -> BindingMode {\n         match ba {\n-            Unannotated => BindingMode::BindByValue(Mutability::Immutable),\n-            Mutable => BindingMode::BindByValue(Mutability::Mutable),\n-            Ref => BindingMode::BindByReference(Mutability::Immutable),\n-            RefMut => BindingMode::BindByReference(Mutability::Mutable),\n+            Unannotated => BindingMode::BindByValue(Mutability::Not),\n+            Mutable => BindingMode::BindByValue(Mutability::Mut),\n+            Ref => BindingMode::BindByReference(Mutability::Not),\n+            RefMut => BindingMode::BindByReference(Mutability::Mut),\n         }\n     }\n }"}, {"sha": "0806e2d77650e58a316cfd02b6445a68bdc0093d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -2406,22 +2406,22 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Mutable})\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Mut })\n     }\n \n     #[inline]\n     pub fn mk_imm_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Immutable})\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Not })\n     }\n \n     #[inline]\n     pub fn mk_mut_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Mutable})\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Mut })\n     }\n \n     #[inline]\n     pub fn mk_imm_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Immutable})\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Not })\n     }\n \n     #[inline]"}, {"sha": "0218cb1d6fda7129c558d45723556e832ae6b229", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -248,7 +248,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                     format!(\"`&{}`\", tymut_string).into()\n                 } else { // Unknown type name, it's long or has type arguments\n                     match mutbl {\n-                        hir::Mutability::Mutable => \"mutable reference\",\n+                        hir::Mutability::Mut => \"mutable reference\",\n                         _ => \"reference\",\n                     }.into()\n                 }\n@@ -293,7 +293,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Slice(_) => \"slice\".into(),\n             ty::RawPtr(_) => \"raw pointer\".into(),\n             ty::Ref(.., mutbl) => match mutbl {\n-                hir::Mutability::Mutable => \"mutable reference\",\n+                hir::Mutability::Mut => \"mutable reference\",\n                 _ => \"reference\"\n             }.into(),\n             ty::FnDef(..) => \"fn item\".into(),"}, {"sha": "a8c44aa507cd8a5938350879af4a0b5969f46f0b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -2221,12 +2221,12 @@ where\n                 let tcx = cx.tcx();\n                 let is_freeze = ty.is_freeze(tcx, cx.param_env(), DUMMY_SP);\n                 let kind = match mt {\n-                    hir::Mutability::Immutable => if is_freeze {\n+                    hir::Mutability::Not => if is_freeze {\n                         PointerKind::Frozen\n                     } else {\n                         PointerKind::Shared\n                     },\n-                    hir::Mutability::Mutable => {\n+                    hir::Mutability::Mut => {\n                         // Previously we would only emit noalias annotations for LLVM >= 6 or in\n                         // panic=abort mode. That was deemed right, as prior versions had many bugs\n                         // in conjunction with unwinding, but later versions didn\u2019t seem to have"}, {"sha": "62fea7c31a9d9f16807cbc5e26a1b2bf2eb87531", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -2657,8 +2657,8 @@ impl<'tcx> TyS<'tcx> {\n impl BorrowKind {\n     pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n         match m {\n-            hir::Mutability::Mutable => MutBorrow,\n-            hir::Mutability::Immutable => ImmBorrow,\n+            hir::Mutability::Mut => MutBorrow,\n+            hir::Mutability::Not => ImmBorrow,\n         }\n     }\n \n@@ -2668,13 +2668,13 @@ impl BorrowKind {\n     /// question.\n     pub fn to_mutbl_lossy(self) -> hir::Mutability {\n         match self {\n-            MutBorrow => hir::Mutability::Mutable,\n-            ImmBorrow => hir::Mutability::Immutable,\n+            MutBorrow => hir::Mutability::Mut,\n+            ImmBorrow => hir::Mutability::Not,\n \n             // We have no type corresponding to a unique imm borrow, so\n             // use `&mut`. It gives all the capabilities of an `&uniq`\n             // and hence is a safe \"over approximation\".\n-            UniqueImmBorrow => hir::Mutability::Mutable,\n+            UniqueImmBorrow => hir::Mutability::Mut,\n         }\n     }\n "}, {"sha": "5e146119b51acb5be5bd74914c37cdee6cc23824", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -59,8 +59,8 @@ impl DefPathBasedNames<'tcx> {\n             ty::RawPtr(ty::TypeAndMut { ty: inner_type, mutbl }) => {\n                 output.push('*');\n                 match mutbl {\n-                    hir::Mutability::Immutable => output.push_str(\"const \"),\n-                    hir::Mutability::Mutable => output.push_str(\"mut \"),\n+                    hir::Mutability::Not => output.push_str(\"const \"),\n+                    hir::Mutability::Mut => output.push_str(\"mut \"),\n                 }\n \n                 self.push_type_name(inner_type, output, debug);"}, {"sha": "b4f1f9d779a69eda03edb657e79ed153673c71ed", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -490,8 +490,8 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Float(t) => p!(write(\"{}\", t.name_str())),\n             ty::RawPtr(ref tm) => {\n                 p!(write(\"*{} \", match tm.mutbl {\n-                    hir::Mutability::Mutable => \"mut\",\n-                    hir::Mutability::Immutable => \"const\",\n+                    hir::Mutability::Mut => \"mut\",\n+                    hir::Mutability::Not => \"const\",\n                 }));\n                 p!(print(tm.ty))\n             }"}, {"sha": "15b14c51c7843ec0a069098a4fa3bae7572e311e", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -121,8 +121,8 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n         } else {\n             let mutbl = a.mutbl;\n             let variance = match mutbl {\n-                ast::Mutability::Immutable => ty::Covariant,\n-                ast::Mutability::Mutable => ty::Invariant,\n+                ast::Mutability::Not => ty::Covariant,\n+                ast::Mutability::Mut => ty::Invariant,\n             };\n             let ty = relation.relate_with_variance(variance, &a.ty, &b.ty)?;\n             Ok(ty::TypeAndMut { ty, mutbl })"}, {"sha": "ea4369c0180fe3d42da34a6faddac4b5e56fd393", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1853,8 +1853,8 @@ impl<'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_mutable_ptr(&self) -> bool {\n         match self.kind {\n-            RawPtr(TypeAndMut { mutbl: hir::Mutability::Mutable, .. }) |\n-            Ref(_, _, hir::Mutability::Mutable) => true,\n+            RawPtr(TypeAndMut { mutbl: hir::Mutability::Mut, .. }) |\n+            Ref(_, _, hir::Mutability::Mut) => true,\n             _ => false\n         }\n     }\n@@ -2044,7 +2044,7 @@ impl<'tcx> TyS<'tcx> {\n             Adt(def, _) if def.is_box() => {\n                 Some(TypeAndMut {\n                     ty: self.boxed_ty(),\n-                    mutbl: hir::Mutability::Immutable,\n+                    mutbl: hir::Mutability::Not,\n                 })\n             },\n             Ref(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl }),"}, {"sha": "f054a630e4b8e8ce5ea8fa92eb86e44756337019", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -183,7 +183,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n                 // Now libcore provides that impl.\n                 ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n                 ty::Char | ty::RawPtr(..) | ty::Never |\n-                ty::Ref(_, _, hir::Mutability::Immutable) => return Ok(()),\n+                ty::Ref(_, _, hir::Mutability::Not) => return Ok(()),\n \n                 ty::Adt(adt, substs) => (adt, substs),\n \n@@ -679,7 +679,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Returns `true` if the node pointed to by `def_id` is a mutable `static` item.\n     pub fn is_mutable_static(&self, def_id: DefId) -> bool {\n-        self.static_mutability(def_id) == Some(hir::Mutability::Mutable)\n+        self.static_mutability(def_id) == Some(hir::Mutability::Mut)\n     }\n \n     /// Get the type of the pointer to the static that we use in MIR."}, {"sha": "cda8fbc3517a9cb31c41219f330e4acf099cd73d", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -277,7 +277,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 let base_addr = match alloc_kind {\n                     Some(GlobalAlloc::Memory(alloc)) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n-                        if alloc.mutability == Mutability::Mutable {\n+                        if alloc.mutability == Mutability::Mut {\n                             self.static_addr_of_mut(init, alloc.align, None)\n                         } else {\n                             self.static_addr_of(init, alloc.align, None)"}, {"sha": "e178050b36918fe0f3e3a9c4515447a92f9ea1cd", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1582,7 +1582,7 @@ fn generic_simd_intrinsic(\n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n         let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).kind {\n-            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mutable\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut\n                 => (ptr_count(arg_tys[1].simd_type(tcx)),\n                     non_ptr(arg_tys[1].simd_type(tcx))),\n             _ => {"}, {"sha": "3145b0df63b8ae6c8c00077ea45e211e97e5892c", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -3,6 +3,7 @@ use crate::llvm;\n use syntax_pos::symbol::Symbol;\n use rustc::session::Session;\n use rustc::session::config::PrintRequest;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_target::spec::{MergeFunctions, PanicStrategy};\n use libc::c_int;\n use std::ffi::CString;\n@@ -51,43 +52,60 @@ unsafe fn configure_llvm(sess: &Session) {\n \n     llvm::LLVMRustInstallFatalErrorHandler();\n \n+    fn llvm_arg_to_arg_name(full_arg: &str) -> &str {\n+        full_arg.trim().split(|c: char| {\n+            c == '=' || c.is_whitespace()\n+        }).next().unwrap_or(\"\")\n+    }\n+\n+    let user_specified_args: FxHashSet<_> = sess\n+        .opts\n+        .cg\n+        .llvm_args\n+        .iter()\n+        .map(|s| llvm_arg_to_arg_name(s))\n+        .filter(|s| s.len() > 0)\n+        .collect();\n+\n     {\n-        let mut add = |arg: &str| {\n-            let s = CString::new(arg).unwrap();\n-            llvm_args.push(s.as_ptr());\n-            llvm_c_strs.push(s);\n+        // This adds the given argument to LLVM. Unless `force` is true\n+        // user specified arguments are *not* overridden.\n+        let mut add = |arg: &str, force: bool| {\n+            if force || !user_specified_args.contains(llvm_arg_to_arg_name(arg)) {\n+                let s = CString::new(arg).unwrap();\n+                llvm_args.push(s.as_ptr());\n+                llvm_c_strs.push(s);\n+            }\n         };\n-        add(\"rustc\"); // fake program name\n-        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n-        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n-        if sess.opts.debugging_opts.disable_instrumentation_preinliner {\n-            add(\"-disable-preinline\");\n-        }\n+        add(\"rustc\", true); // fake program name\n+        if sess.time_llvm_passes() { add(\"-time-passes\", false); }\n+        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\", false); }\n+\n         if sess.opts.debugging_opts.generate_arange_section {\n-            add(\"-generate-arange-section\");\n+            add(\"-generate-arange-section\", false);\n         }\n         if get_major_version() >= 8 {\n             match sess.opts.debugging_opts.merge_functions\n                   .unwrap_or(sess.target.target.options.merge_functions) {\n                 MergeFunctions::Disabled |\n                 MergeFunctions::Trampolines => {}\n                 MergeFunctions::Aliases => {\n-                    add(\"-mergefunc-use-aliases\");\n+                    add(\"-mergefunc-use-aliases\", false);\n                 }\n             }\n         }\n \n         if sess.target.target.target_os == \"emscripten\" &&\n             sess.panic_strategy() == PanicStrategy::Unwind {\n-            add(\"-enable-emscripten-cxx-exceptions\");\n+            add(\"-enable-emscripten-cxx-exceptions\", false);\n         }\n \n         // HACK(eddyb) LLVM inserts `llvm.assume` calls to preserve align attributes\n         // during inlining. Unfortunately these may block other optimizations.\n-        add(\"-preserve-alignment-assumptions-during-inlining=false\");\n+        add(\"-preserve-alignment-assumptions-during-inlining=false\", false);\n \n         for arg in &sess.opts.cg.llvm_args {\n-            add(&(*arg));\n+            add(&(*arg), true);\n         }\n     }\n "}, {"sha": "c5340892daf0cafffbe88b865cef22e254e395c0", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -62,8 +62,8 @@ pub fn push_debuginfo_type_name<'tcx>(\n                 output.push('*');\n             }\n             match mutbl {\n-                hir::Mutability::Immutable => output.push_str(\"const \"),\n-                hir::Mutability::Mutable => output.push_str(\"mut \"),\n+                hir::Mutability::Not => output.push_str(\"const \"),\n+                hir::Mutability::Mut => output.push_str(\"mut \"),\n             }\n \n             push_debuginfo_type_name(tcx, inner_type, true, output, visited);"}, {"sha": "858ad9f1cfda72d42f2510d02e533026bf6a235b", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -373,8 +373,8 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n             ty::Ref(r, ty, mutbl) => {\n                 self.push(match mutbl {\n-                    hir::Mutability::Immutable => \"R\",\n-                    hir::Mutability::Mutable => \"Q\",\n+                    hir::Mutability::Not => \"R\",\n+                    hir::Mutability::Mut => \"Q\",\n                 });\n                 if *r != ty::ReErased {\n                     self = r.print(self)?;\n@@ -384,8 +384,8 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n             ty::RawPtr(mt) => {\n                 self.push(match mt.mutbl {\n-                    hir::Mutability::Immutable => \"P\",\n-                    hir::Mutability::Mutable => \"O\",\n+                    hir::Mutability::Not => \"P\",\n+                    hir::Mutability::Mut => \"O\",\n                 });\n                 self = mt.ty.print(self)?;\n             }"}, {"sha": "dc7258d87317fd7ad811b3655ac963f2ad8f8031", "filename": "src/librustc_error_codes/error_codes/E0120.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_error_codes%2Ferror_codes%2FE0120.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_error_codes%2Ferror_codes%2FE0120.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0120.md?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1,5 +1,7 @@\n-An attempt was made to implement Drop on a trait, which is not allowed: only\n-structs and enums can implement Drop. An example causing this error:\n+Drop was implemented on a trait, which is not allowed: only structs and\n+enums can implement Drop.\n+\n+Erroneous code example:\n \n ```compile_fail,E0120\n trait MyTrait {}\n@@ -10,7 +12,7 @@ impl Drop for MyTrait {\n ```\n \n A workaround for this problem is to wrap the trait up in a struct, and implement\n-Drop on that. An example is shown below:\n+Drop on that:\n \n ```\n trait MyTrait {}\n@@ -22,7 +24,7 @@ impl <T: MyTrait> Drop for MyWrapper<T> {\n \n ```\n \n-Alternatively, wrapping trait objects requires something like the following:\n+Alternatively, wrapping trait objects requires something:\n \n ```\n trait MyTrait {}"}, {"sha": "06fe396d50d3b2d5dac334ec7fdf8482adf1786b", "filename": "src/librustc_error_codes/error_codes/E0121.md", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_error_codes%2Ferror_codes%2FE0121.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_error_codes%2Ferror_codes%2FE0121.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0121.md?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1,10 +1,24 @@\n-In order to be consistent with Rust's lack of global type inference,\n-type and const placeholders are disallowed by design in item signatures.\n+The type placeholder `_` was used within a type on an item's signature.\n \n-Examples of this error include:\n+Erroneous code example:\n \n ```compile_fail,E0121\n-fn foo() -> _ { 5 } // error, explicitly write out the return type instead\n+fn foo() -> _ { 5 } // error\n \n-static BAR: _ = \"test\"; // error, explicitly write out the type instead\n+static BAR: _ = \"test\"; // error\n+```\n+\n+In those cases, you need to provide the type explicitly:\n+\n+```\n+fn foo() -> i32 { 5 } // ok!\n+\n+static BAR: &str = \"test\"; // ok!\n+```\n+\n+The type placeholder `_` can be used outside item's signature as follows:\n+\n+```\n+let x = \"a4a\".split('4')\n+    .collect::<Vec<_>>(); // No need to precise the Vec's generic type.\n ```"}, {"sha": "4cf694631d0d38040b3c080ac5354d8d612818dd", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -887,8 +887,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind)) {\n             Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n-                if to_mt == hir::Mutability::Mutable &&\n-                   from_mt == hir::Mutability::Immutable {\n+                if to_mt == hir::Mutability::Mut &&\n+                   from_mt == hir::Mutability::Not {\n                     cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n                 }\n             }"}, {"sha": "06ec3f380091560484f1e91b1732ead11dcbeb5b", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -392,7 +392,7 @@ impl UnusedParens {\n         avoid_or: bool,\n         avoid_mut: bool,\n     ) {\n-        use ast::{PatKind, BindingMode::ByValue, Mutability::Mutable};\n+        use ast::{PatKind, BindingMode, Mutability};\n \n         if let PatKind::Paren(inner) = &value.kind {\n             match inner.kind {\n@@ -404,7 +404,7 @@ impl UnusedParens {\n                 // Avoid `p0 | .. | pn` if we should.\n                 PatKind::Or(..) if avoid_or => return,\n                 // Avoid `mut x` and `mut x @ p` if we should:\n-                PatKind::Ident(ByValue(Mutable), ..) if avoid_mut => return,\n+                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ..) if avoid_mut => return,\n                 // Otherwise proceed with linting.\n                 _ => {}\n             }\n@@ -560,7 +560,7 @@ impl EarlyLintPass for UnusedParens {\n             Ident(.., Some(p)) | Box(p) => self.check_unused_parens_pat(cx, p, true, false),\n             // Avoid linting on `&(mut x)` as `&mut x` has a different meaning, #55342.\n             // Also avoid linting on `& mut? (p0 | .. | pn)`, #64106.\n-            Ref(p, m) => self.check_unused_parens_pat(cx, p, true, *m == Mutability::Immutable),\n+            Ref(p, m) => self.check_unused_parens_pat(cx, p, true, *m == Mutability::Not),\n         }\n     }\n \n@@ -668,9 +668,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n         for adj in cx.tables.expr_adjustments(e) {\n             if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n                 let msg = match m {\n-                    adjustment::AutoBorrowMutability::Immutable =>\n+                    adjustment::AutoBorrowMutability::Not =>\n                         \"unnecessary allocation, use `&` instead\",\n-                    adjustment::AutoBorrowMutability::Mutable { .. }=>\n+                    adjustment::AutoBorrowMutability::Mut { .. }=>\n                         \"unnecessary allocation, use `&mut` instead\"\n                 };\n                 cx.span_lint(UNUSED_ALLOCATION, e.span, msg);"}, {"sha": "eb2fb39fb2f25da9cf86930cdd1dedad29a1ca4d", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1401,9 +1401,9 @@ impl<'a, 'tcx> CrateMetadata {\n     fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n         match self.kind(id) {\n             EntryKind::ImmStatic |\n-            EntryKind::ForeignImmStatic => Some(hir::Mutability::Immutable),\n+            EntryKind::ForeignImmStatic => Some(hir::Mutability::Not),\n             EntryKind::MutStatic |\n-            EntryKind::ForeignMutStatic => Some(hir::Mutability::Mutable),\n+            EntryKind::ForeignMutStatic => Some(hir::Mutability::Mut),\n             _ => None,\n         }\n     }"}, {"sha": "d963323342c33f76f68fa436412ad3b69f80579c", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1054,8 +1054,8 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n         record!(self.per_def.kind[def_id] <- match item.kind {\n-            hir::ItemKind::Static(_, hir::Mutability::Mutable, _) => EntryKind::MutStatic,\n-            hir::ItemKind::Static(_, hir::Mutability::Immutable, _) => EntryKind::ImmStatic,\n+            hir::ItemKind::Static(_, hir::Mutability::Mut, _) => EntryKind::MutStatic,\n+            hir::ItemKind::Static(_, hir::Mutability::Not, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n                 let qualifs = self.tcx.at(item.span).mir_const_qualif(def_id);\n                 EntryKind::Const(\n@@ -1544,10 +1544,8 @@ impl EncodeContext<'tcx> {\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))\n             }\n-            hir::ForeignItemKind::Static(_, hir::Mutability::Mutable) =>\n-                EntryKind::ForeignMutStatic,\n-            hir::ForeignItemKind::Static(_, hir::Mutability::Immutable) =>\n-                EntryKind::ForeignImmStatic,\n+            hir::ForeignItemKind::Static(_, hir::Mutability::Mut) => EntryKind::ForeignMutStatic,\n+            hir::ForeignItemKind::Static(_, hir::Mutability::Not) => EntryKind::ForeignImmStatic,\n             hir::ForeignItemKind::Type => EntryKind::ForeignType,\n         });\n         record!(self.per_def.visibility[def_id] <-"}, {"sha": "38101c35dcc14e22f1b746d769a5e0f96c868262", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -261,7 +261,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // we have an explicit self. Do the same thing in this case and check\n                         // for a `self: &mut Self` to suggest removing the `&mut`.\n                         if let ty::Ref(\n-                            _, _, hir::Mutability::Mutable\n+                            _, _, hir::Mutability::Mut\n                         ) = local_decl.ty.kind {\n                             true\n                         } else {\n@@ -578,7 +578,7 @@ fn suggest_ampmut<'tcx>(\n     }\n \n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n-    assert_eq!(ty_mut.mutbl, hir::Mutability::Immutable);\n+    assert_eq!(ty_mut.mutbl, hir::Mutability::Not);\n     (highlight_span,\n      if local_decl.ty.is_region_ptr() {\n          format!(\"&mut {}\", ty_mut.ty)\n@@ -614,7 +614,7 @@ fn annotate_struct_field(\n             // we can expect a field that is an immutable reference to a type.\n             if let hir::Node::Field(field) = node {\n                 if let hir::TyKind::Rptr(lifetime, hir::MutTy {\n-                    mutbl: hir::Mutability::Immutable,\n+                    mutbl: hir::Mutability::Not,\n                     ref ty\n                 }) = field.ty.kind {\n                     // Get the snippets in two parts - the named lifetime (if there is one) and"}, {"sha": "cd1e72e9d170106acb0e3b3748aa87837229da22", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -160,7 +160,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n             };\n             let bm = *tables.pat_binding_modes().get(var_hir_id)\n                 .expect(\"missing binding mode\");\n-            if bm == ty::BindByValue(hir::Mutability::Mutable) {\n+            if bm == ty::BindByValue(hir::Mutability::Mut) {\n                 upvar.mutability = Mutability::Mut;\n             }\n             upvar\n@@ -2225,10 +2225,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ty::Ref(_, _, mutbl) => {\n                                 match mutbl {\n                                     // Shared borrowed data is never mutable\n-                                    hir::Mutability::Immutable => Err(place),\n+                                    hir::Mutability::Not => Err(place),\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n-                                    hir::Mutability::Mutable => {\n+                                    hir::Mutability::Mut => {\n                                         let mode = match self.is_upvar_field_projection(place) {\n                                             Some(field)\n                                                 if self.upvars[field.index()].by_ref =>\n@@ -2248,10 +2248,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ty::RawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n-                                    hir::Mutability::Immutable => Err(place),\n+                                    hir::Mutability::Not => Err(place),\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n-                                    hir::Mutability::Mutable => {\n+                                    hir::Mutability::Mut => {\n                                         Ok(RootPlace {\n                                             place_base: place.base,\n                                             place_projection: place.projection,"}, {"sha": "e11db4ad5bb6047103b781bada0ce8b6607ea7bc", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -58,15 +58,15 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n             if *elem == ProjectionElem::Deref {\n                 let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n                 match ty.kind {\n-                    ty::Ref(_, _, hir::Mutability::Immutable) if i == 0 => {\n+                    ty::Ref(_, _, hir::Mutability::Not) if i == 0 => {\n                         // For references to thread-local statics, we do need\n                         // to track the borrow.\n                         if body.local_decls[local].is_ref_to_thread_local() {\n                             continue;\n                         }\n                         return true;\n                     }\n-                    ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Immutable) => {\n+                    ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Not) => {\n                         // For both derefs of raw pointers and `&T`\n                         // references, the original path is `Copy` and\n                         // therefore not significant.  In particular,"}, {"sha": "0cc7af330caad25d865d38666f45a2b47c385873", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -246,13 +246,11 @@ fn place_components_conflict<'tcx>(\n                     debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n                     return false;\n                 }\n-                (ProjectionElem::Deref, ty::Ref(_, _, hir::Mutability::Immutable), _) => {\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::Mutability::Not), _) => {\n                     // Shouldn't be tracked\n                     bug!(\"Tracking borrow behind shared reference.\");\n                 }\n-                (ProjectionElem::Deref,\n-                 ty::Ref(_, _, hir::Mutability::Mutable),\n-                 AccessDepth::Drop) => {\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::Mutability::Mut), AccessDepth::Drop) => {\n                     // Values behind a mutable reference are not access either by dropping a\n                     // value, or by StorageDead\n                     debug!(\"borrow_conflicts_with_place: drop access behind ptr\");"}, {"sha": "5b9ce7cb5fd8df5e37786c5fc849657be550a803", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -149,7 +149,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         ty::Ref(\n                             _, /*rgn*/\n                             _, /*ty*/\n-                            hir::Mutability::Immutable\n+                            hir::Mutability::Not\n                             ) => {\n                             // don't continue traversing over derefs of raw pointers or shared\n                             // borrows.\n@@ -160,7 +160,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         ty::Ref(\n                             _, /*rgn*/\n                             _, /*ty*/\n-                            hir::Mutability::Mutable,\n+                            hir::Mutability::Mut,\n                             ) => {\n                             self.next = Some(PlaceRef {\n                                 base: cursor.base,"}, {"sha": "5613fd045ea50f4651e959e6ea6d7753d22e3cd0", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -2162,7 +2162,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_from = match op.ty(*body, tcx).kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n-                                mutbl: hir::Mutability::Mutable,\n+                                mutbl: hir::Mutability::Mut,\n                             }) => ty_from,\n                             _ => {\n                                 span_mirbug!(\n@@ -2177,7 +2177,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_to = match ty.kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_to,\n-                                mutbl: hir::Mutability::Immutable,\n+                                mutbl: hir::Mutability::Not,\n                             }) => ty_to,\n                             _ => {\n                                 span_mirbug!(\n@@ -2211,7 +2211,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                         let opt_ty_elem = match ty_from.kind {\n                             ty::RawPtr(\n-                                ty::TypeAndMut { mutbl: hir::Mutability::Immutable, ty: array_ty }\n+                                ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: array_ty }\n                             ) => {\n                                 match array_ty.kind {\n                                     ty::Array(ty_elem, _) => Some(ty_elem),\n@@ -2236,7 +2236,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                         let ty_to = match ty.kind {\n                             ty::RawPtr(\n-                                ty::TypeAndMut { mutbl: hir::Mutability::Immutable, ty: ty_to }\n+                                ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: ty_to }\n                             ) => {\n                                 ty_to\n                             }\n@@ -2504,13 +2504,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             });\n \n                             match mutbl {\n-                                hir::Mutability::Immutable => {\n+                                hir::Mutability::Not => {\n                                     // Immutable reference. We don't need the base\n                                     // to be valid for the entire lifetime of\n                                     // the borrow.\n                                     break;\n                                 }\n-                                hir::Mutability::Mutable => {\n+                                hir::Mutability::Mut => {\n                                     // Mutable reference. We *do* need the base\n                                     // to be valid, because after the base becomes\n                                     // invalid, someone else can use our mutable deref."}, {"sha": "608415408e35c8b3d05060ea584a2cfc9ccd5b10", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -300,16 +300,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 mutability,\n                 arg,\n             } => {\n-                let address_of = match mutability {\n-                    hir::Mutability::Immutable => Rvalue::AddressOf(\n-                        Mutability::Not,\n-                        unpack!(block = this.as_read_only_place(block, arg)),\n-                    ),\n-                    hir::Mutability::Mutable => Rvalue::AddressOf(\n-                        Mutability::Mut,\n-                        unpack!(block = this.as_place(block, arg)),\n-                    ),\n+                let place = match mutability {\n+                    hir::Mutability::Not => this.as_read_only_place(block, arg),\n+                    hir::Mutability::Mut => this.as_place(block, arg),\n                 };\n+                let address_of = Rvalue::AddressOf(mutability, unpack!(block = place));\n                 this.cfg.push_assign(block, source_info, destination, address_of);\n                 block.unit()\n             }"}, {"sha": "3479ad6749a9041f07f4d0a74281dfab7c78c060", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -821,7 +821,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         name = ident.name;\n \n                         if let Some(&bm) = hir_tables.pat_binding_modes().get(pat.hir_id) {\n-                            if bm == ty::BindByValue(hir::Mutability::Mutable) {\n+                            if bm == ty::BindByValue(hir::Mutability::Mut) {\n                                 mutability = Mutability::Mut;\n                             } else {\n                                 mutability = Mutability::Not;"}, {"sha": "c05641fe8bf0a870763078123b3d49f72b8aacd5", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -812,22 +812,21 @@ impl ToBorrowKind for AutoBorrowMutability {\n     fn to_borrow_kind(&self) -> BorrowKind {\n         use rustc::ty::adjustment::AllowTwoPhase;\n         match *self {\n-            AutoBorrowMutability::Mutable { allow_two_phase_borrow } =>\n+            AutoBorrowMutability::Mut { allow_two_phase_borrow } =>\n                 BorrowKind::Mut { allow_two_phase_borrow: match allow_two_phase_borrow {\n                     AllowTwoPhase::Yes => true,\n                     AllowTwoPhase::No => false\n                 }},\n-            AutoBorrowMutability::Immutable =>\n-                BorrowKind::Shared,\n+            AutoBorrowMutability::Not => BorrowKind::Shared,\n         }\n     }\n }\n \n impl ToBorrowKind for hir::Mutability {\n     fn to_borrow_kind(&self) -> BorrowKind {\n         match *self {\n-            hir::Mutability::Mutable => BorrowKind::Mut { allow_two_phase_borrow: false },\n-            hir::Mutability::Immutable => BorrowKind::Shared,\n+            hir::Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n+            hir::Mutability::Not => BorrowKind::Shared,\n         }\n     }\n }\n@@ -994,7 +993,7 @@ fn convert_var(\n                         let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                            ty::TypeAndMut {\n                                                                ty: closure_ty,\n-                                                               mutbl: hir::Mutability::Immutable,\n+                                                               mutbl: hir::Mutability::Not,\n                                                            });\n                         Expr {\n                             ty: closure_ty,\n@@ -1015,7 +1014,7 @@ fn convert_var(\n                         let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                            ty::TypeAndMut {\n                                                                ty: closure_ty,\n-                                                               mutbl: hir::Mutability::Mutable,\n+                                                               mutbl: hir::Mutability::Mut,\n                                                            });\n                         Expr {\n                             ty: closure_ty,"}, {"sha": "28f0edadc89caec1267303110d8dc293deb495ed", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -269,7 +269,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n     pat.walk(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n             if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n-                if bm != ty::BindByValue(hir::Mutability::Immutable) {\n+                if bm != ty::BindByValue(hir::Mutability::Not) {\n                     // Nothing to check.\n                     return true;\n                 }"}, {"sha": "7f15b3de5efc0ffc828b8f12fdf63e08d9f2e7fb", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -598,14 +598,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n                                                          .expect(\"missing binding mode\");\n                 let (mutability, mode) = match bm {\n-                    ty::BindByValue(hir::Mutability::Mutable) =>\n-                        (Mutability::Mut, BindingMode::ByValue),\n-                    ty::BindByValue(hir::Mutability::Immutable) =>\n-                        (Mutability::Not, BindingMode::ByValue),\n-                    ty::BindByReference(hir::Mutability::Mutable) =>\n+                    ty::BindByValue(mutbl) => (mutbl, BindingMode::ByValue),\n+                    ty::BindByReference(hir::Mutability::Mut) =>\n                         (Mutability::Not, BindingMode::ByRef(\n                             BorrowKind::Mut { allow_two_phase_borrow: false })),\n-                    ty::BindByReference(hir::Mutability::Immutable) =>\n+                    ty::BindByReference(hir::Mutability::Not) =>\n                         (Mutability::Not, BindingMode::ByRef(\n                             BorrowKind::Shared)),\n                 };"}, {"sha": "e4698303afe993873d037fa07ef3b49c57b968ee", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -115,22 +115,22 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n         // For statics, allocation mutability is the combination of the place mutability and\n         // the type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n-        if mutability == Mutability::Immutable && frozen {\n-            alloc.mutability = Mutability::Immutable;\n+        if mutability == Mutability::Not && frozen {\n+            alloc.mutability = Mutability::Not;\n         } else {\n             // Just making sure we are not \"upgrading\" an immutable allocation to mutable.\n-            assert_eq!(alloc.mutability, Mutability::Mutable);\n+            assert_eq!(alloc.mutability, Mutability::Mut);\n         }\n     } else {\n         // We *could* be non-frozen at `ConstBase`, for constants like `Cell::new(0)`.\n         // But we still intern that as immutable as the memory cannot be changed once the\n         // initial value was computed.\n         // Constants are never mutable.\n         assert_eq!(\n-            mutability, Mutability::Immutable,\n+            mutability, Mutability::Not,\n             \"Something went very wrong: mutability requested for a constant\"\n         );\n-        alloc.mutability = Mutability::Immutable;\n+        alloc.mutability = Mutability::Not;\n     };\n     // link the alloc id to the actual allocation\n     let alloc = tcx.intern_const_alloc(alloc);\n@@ -179,7 +179,7 @@ for\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable\n                 // allocations.\n-                let old = std::mem::replace(&mut self.mutability, Mutability::Mutable);\n+                let old = std::mem::replace(&mut self.mutability, Mutability::Mut);\n                 assert_ne!(\n                     self.mode, InternMode::Const,\n                     \"UnsafeCells are not allowed behind references in constants. This should have \\\n@@ -210,7 +210,7 @@ for\n                 if let Ok(vtable) = mplace.meta.unwrap().to_ptr() {\n                     // explitly choose `Immutable` here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable\n-                    self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n+                    self.intern_shallow(vtable.alloc_id, Mutability::Not, None)?;\n                 }\n             }\n             // Check if we have encountered this pointer+layout combination before.\n@@ -223,16 +223,16 @@ for\n                 // const qualification enforces it. We can lift it in the future.\n                 match (self.mode, mutability) {\n                     // immutable references are fine everywhere\n-                    (_, hir::Mutability::Immutable) => {},\n+                    (_, hir::Mutability::Not) => {},\n                     // all is \"good and well\" in the unsoundness of `static mut`\n \n                     // mutable references are ok in `static`. Either they are treated as immutable\n                     // because they are behind an immutable one, or they are behind an `UnsafeCell`\n                     // and thus ok.\n-                    (InternMode::Static, hir::Mutability::Mutable) => {},\n+                    (InternMode::Static, hir::Mutability::Mut) => {},\n                     // we statically prevent `&mut T` via `const_qualif` and double check this here\n-                    (InternMode::ConstBase, hir::Mutability::Mutable) |\n-                    (InternMode::Const, hir::Mutability::Mutable) => {\n+                    (InternMode::ConstBase, hir::Mutability::Mut) |\n+                    (InternMode::Const, hir::Mutability::Mut) => {\n                         match referenced_ty.kind {\n                             ty::Array(_, n)\n                                 if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n@@ -243,16 +243,14 @@ for\n                     },\n                 }\n                 // Compute the mutability with which we'll start visiting the allocation. This is\n-                // what gets changed when we encounter an `UnsafeCell`\n-                let mutability = match (self.mutability, mutability) {\n-                    // The only way a mutable reference actually works as a mutable reference is\n-                    // by being in a `static mut` directly or behind another mutable reference.\n-                    // If there's an immutable reference or we are inside a static, then our\n-                    // mutable reference is equivalent to an immutable one. As an example:\n-                    // `&&mut Foo` is semantically equivalent to `&&Foo`\n-                    (Mutability::Mutable, hir::Mutability::Mutable) => Mutability::Mutable,\n-                    _ => Mutability::Immutable,\n-                };\n+                // what gets changed when we encounter an `UnsafeCell`.\n+                //\n+                // The only way a mutable reference actually works as a mutable reference is\n+                // by being in a `static mut` directly or behind another mutable reference.\n+                // If there's an immutable reference or we are inside a static, then our\n+                // mutable reference is equivalent to an immutable one. As an example:\n+                // `&&mut Foo` is semantically equivalent to `&&Foo`\n+                let mutability = self.mutability.and(mutability);\n                 // Recursing behind references changes the intern mode for constants in order to\n                 // cause assertions to trigger if we encounter any `UnsafeCell`s.\n                 let mode = match self.mode {\n@@ -282,11 +280,10 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n ) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n     let (base_mutability, base_intern_mode) = match place_mut {\n-        Some(hir::Mutability::Immutable) => (Mutability::Immutable, InternMode::Static),\n         // `static mut` doesn't care about interior mutability, it's mutable anyway\n-        Some(hir::Mutability::Mutable) => (Mutability::Mutable, InternMode::Static),\n+        Some(mutbl) => (mutbl, InternMode::Static),\n         // consts, promoteds. FIXME: what about array lengths, array initializers?\n-        None => (Mutability::Immutable, InternMode::ConstBase),\n+        None => (Mutability::Not, InternMode::ConstBase),\n     };\n \n     // Type based interning.\n@@ -346,7 +343,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n                 // We cannot have mutable memory inside a constant.\n                 // FIXME: ideally we would assert that they already are immutable, to double-\n                 // check our static checks.\n-                alloc.mutability = Mutability::Immutable;\n+                alloc.mutability = Mutability::Not;\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);"}, {"sha": "ba571043d38130da92617649a1b410946ce3c2fa", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -539,7 +539,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // Need to make a copy, even if `get_static_alloc` is able\n             // to give us a cheap reference.\n             let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n-            if alloc.mutability == Mutability::Immutable {\n+            if alloc.mutability == Mutability::Not {\n                 throw_unsup!(ModifiedConstantMemory)\n             }\n             match M::STATIC_KIND {\n@@ -553,7 +553,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Err(e) => Err(e),\n             Ok(a) => {\n                 let a = &mut a.1;\n-                if a.mutability == Mutability::Immutable {\n+                if a.mutability == Mutability::Not {\n                     throw_unsup!(ModifiedConstantMemory)\n                 }\n                 Ok(a)\n@@ -643,7 +643,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n-        self.get_raw_mut(id)?.mutability = Mutability::Immutable;\n+        self.get_raw_mut(id)?.mutability = Mutability::Not;\n         Ok(())\n     }\n "}, {"sha": "93ab7b9aab7fbf5925b3a404570f056eacdad991", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -444,13 +444,27 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Field(field, _) => self.operand_field(base, field.index() as u64)?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),\n-            Subslice { .. } | ConstantIndex { .. } | Index(_) => if base.layout.is_zst() {\n+            ConstantIndex { .. } | Index(_) if base.layout.is_zst() => {\n                 OpTy {\n                     op: Operand::Immediate(Scalar::zst().into()),\n                     // the actual index doesn't matter, so we just pick a convenient one like 0\n                     layout: base.layout.field(self, 0)?,\n                 }\n-            } else {\n+            }\n+            Subslice { from, to, from_end } if base.layout.is_zst() => {\n+                let elem_ty = if let ty::Array(elem_ty, _) = base.layout.ty.kind {\n+                    elem_ty\n+                } else {\n+                    bug!(\"slices shouldn't be zero-sized\");\n+                };\n+                assert!(!from_end, \"arrays shouldn't be subsliced from the end\");\n+\n+                OpTy {\n+                    op: Operand::Immediate(Scalar::zst().into()),\n+                    layout: self.layout_of(self.tcx.mk_array(elem_ty, (to - from) as u64))?,\n+                }\n+            }\n+            Subslice { .. } | ConstantIndex { .. }  | Index(_) => {\n                 // The rest should only occur as mplace, we do not use Immediates for types\n                 // allowing such operations.  This matches place_projection forcing an allocation.\n                 let mplace = base.assert_mem_place();"}, {"sha": "8923b167fdee8aa8cdf8244ec576eb6c7fe7d24f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -455,7 +455,10 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let actual_to = if from_end {\n-            assert!(from <= len - to);\n+            if from + to > len {\n+                // This can only be reached in ConstProp and non-rustc-MIR.\n+                throw_ub!(BoundsCheckFailed { len: len as u64, index: from as u64 + to as u64 });\n+            }\n             len - to\n         } else {\n             to\n@@ -523,7 +526,11 @@ where\n                 from_end,\n             } => {\n                 let n = base.len(self)?;\n-                assert!(n >= min_length as u64);\n+                if n < min_length as u64 {\n+                    // This can only be reached in ConstProp and non-rustc-MIR.\n+                    throw_ub!(BoundsCheckFailed { len: min_length as u64, index: n as u64 });\n+                }\n+                assert!(offset < min_length);\n \n                 let index = if from_end {\n                     n - u64::from(offset)"}, {"sha": "a29748962181e6209f27c2b9f28b45901386cb14", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -471,7 +471,7 @@ impl CloneShimBuilder<'tcx> {\n             Mutability::Not,\n             tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n                 ty,\n-                mutbl: hir::Mutability::Immutable,\n+                mutbl: hir::Mutability::Not,\n             })\n         );\n \n@@ -757,7 +757,7 @@ fn build_call_shim<'tcx>(\n                 Mutability::Not,\n                 tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n                     ty: sig.inputs()[0],\n-                    mutbl: hir::Mutability::Mutable\n+                    mutbl: hir::Mutability::Mut\n                 }),\n                 span\n             ));"}, {"sha": "e8365a9ee1c13c779c38bf843ec00817b35f73db", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -87,8 +87,8 @@ impl ConstKind {\n \n             HirKind::Const => ConstKind::Const,\n \n-            HirKind::Static(hir::Mutability::Immutable) => ConstKind::Static,\n-            HirKind::Static(hir::Mutability::Mutable) => ConstKind::StaticMut,\n+            HirKind::Static(hir::Mutability::Not) => ConstKind::Static,\n+            HirKind::Static(hir::Mutability::Mut) => ConstKind::StaticMut,\n         };\n \n         Some(mode)"}, {"sha": "1a24a8b371d76efa4864f6a642ab0235e44e28d9", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -238,7 +238,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     ) -> InterpResult<'tcx> {\n         // if the static allocation is mutable or if it has relocations (it may be legal to mutate\n         // the memory behind that in the future), then we can't const prop it\n-        if allocation.mutability == Mutability::Mutable || allocation.relocations().len() > 0 {\n+        if allocation.mutability == Mutability::Mut || allocation.relocations().len() > 0 {\n             throw_unsup!(ConstPropUnsupported(\"can't eval mutable statics in ConstProp\"));\n         }\n "}, {"sha": "b314ff83abe6a757c3086927bcdaddebb4c6ff41", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -391,7 +391,7 @@ fn make_generator_state_argument_indirect<'tcx>(\n \n     let ref_gen_ty = tcx.mk_ref(region, ty::TypeAndMut {\n         ty: gen_ty,\n-        mutbl: hir::Mutability::Mutable\n+        mutbl: hir::Mutability::Mut\n     });\n \n     // Replace the by value generator argument\n@@ -969,7 +969,7 @@ fn create_generator_drop_shim<'tcx>(\n         mutability: Mutability::Mut,\n         ty: tcx.mk_ptr(ty::TypeAndMut {\n             ty: gen_ty,\n-            mutbl: hir::Mutability::Mutable,\n+            mutbl: hir::Mutability::Mut,\n         }),\n         user_ty: UserTypeProjections::none(),\n         source_info,"}, {"sha": "0d2e0bb8281e0096a277e981d6373f3e91e9e98b", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -79,7 +79,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n     for ty in ty.walk() {\n         match ty.kind {\n-            ty::Ref(_, _, hir::Mutability::Mutable) => {\n+            ty::Ref(_, _, hir::Mutability::Mut) => {\n                 if !feature_allowed(tcx, fn_def_id, sym::const_mut_refs) {\n                     return Err((\n                         span,"}, {"sha": "6ff84996bd34aeb439134973124494c8e6b91053", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -521,7 +521,7 @@ where\n \n         let ref_ty = tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n             ty,\n-            mutbl: hir::Mutability::Mutable\n+            mutbl: hir::Mutability::Mut\n         });\n         let ref_place = self.new_temp(ref_ty);\n         let unit_temp = Place::from(self.new_temp(tcx.mk_unit()));\n@@ -580,7 +580,7 @@ where\n \n         let ptr_ty = tcx.mk_ptr(ty::TypeAndMut {\n             ty: ety,\n-            mutbl: hir::Mutability::Mutable\n+            mutbl: hir::Mutability::Mut\n         });\n         let ptr = &Place::from(self.new_temp(ptr_ty));\n         let can_go = Place::from(self.new_temp(tcx.types.bool));"}, {"sha": "353f6607c1db77a2b01ee5c67325c4a77a8dc384", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -22,7 +22,7 @@ const TURBOFISH: &'static str = \"use `::<...>` instead of `<...>` to specify typ\n pub(super) fn dummy_arg(ident: Ident) -> Param {\n     let pat = P(Pat {\n         id: ast::DUMMY_NODE_ID,\n-        kind: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n+        kind: PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None),\n         span: ident.span,\n     });\n     let ty = Ty {"}, {"sha": "271e5092018d9ba8a020d264934a1a0d3cb6c3d3", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1239,8 +1239,8 @@ impl<'a> Parser<'a> {\n         // Construct the error and stash it away with the hope\n         // that typeck will later enrich the error with a type.\n         let kind = match m {\n-            Some(Mutability::Mutable) => \"static mut\",\n-            Some(Mutability::Immutable) => \"static\",\n+            Some(Mutability::Mut) => \"static mut\",\n+            Some(Mutability::Not) => \"static\",\n             None => \"const\",\n         };\n         let mut err = self.struct_span_err(id.span, &format!(\"missing type for `{}` item\", kind));\n@@ -1960,7 +1960,7 @@ impl<'a> Parser<'a> {\n             match ty {\n                 Ok(ty) => {\n                     let ident = Ident::new(kw::Invalid, self.prev_span);\n-                    let bm = BindingMode::ByValue(Mutability::Immutable);\n+                    let bm = BindingMode::ByValue(Mutability::Not);\n                     let pat = self.mk_pat_ident(ty.span, bm, ident);\n                     (pat, ty)\n                 }\n@@ -2032,7 +2032,7 @@ impl<'a> Parser<'a> {\n                 .span_label(span, msg)\n                 .emit();\n \n-            Ok((SelfKind::Value(Mutability::Immutable), expect_self_ident(this), this.prev_span))\n+            Ok((SelfKind::Value(Mutability::Not), expect_self_ident(this), this.prev_span))\n         };\n \n         // Parse optional `self` parameter of a method.\n@@ -2044,23 +2044,23 @@ impl<'a> Parser<'a> {\n                 let eself = if is_isolated_self(self, 1) {\n                     // `&self`\n                     self.bump();\n-                    SelfKind::Region(None, Mutability::Immutable)\n+                    SelfKind::Region(None, Mutability::Not)\n                 } else if is_isolated_mut_self(self, 1) {\n                     // `&mut self`\n                     self.bump();\n                     self.bump();\n-                    SelfKind::Region(None, Mutability::Mutable)\n+                    SelfKind::Region(None, Mutability::Mut)\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_self(self, 2) {\n                     // `&'lt self`\n                     self.bump();\n                     let lt = self.expect_lifetime();\n-                    SelfKind::Region(Some(lt), Mutability::Immutable)\n+                    SelfKind::Region(Some(lt), Mutability::Not)\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_mut_self(self, 2) {\n                     // `&'lt mut self`\n                     self.bump();\n                     let lt = self.expect_lifetime();\n                     self.bump();\n-                    SelfKind::Region(Some(lt), Mutability::Mutable)\n+                    SelfKind::Region(Some(lt), Mutability::Mut)\n                 } else {\n                     // `&not_self`\n                     return Ok(None);\n@@ -2083,12 +2083,12 @@ impl<'a> Parser<'a> {\n             }\n             // `self` and `self: TYPE`\n             token::Ident(..) if is_isolated_self(self, 0) => {\n-                parse_self_possibly_typed(self, Mutability::Immutable)?\n+                parse_self_possibly_typed(self, Mutability::Not)?\n             }\n             // `mut self` and `mut self: TYPE`\n             token::Ident(..) if is_isolated_mut_self(self, 0) => {\n                 self.bump();\n-                parse_self_possibly_typed(self, Mutability::Mutable)?\n+                parse_self_possibly_typed(self, Mutability::Mut)?\n             }\n             _ => return Ok(None),\n         };"}, {"sha": "16bc2e1a8d60e4493ef6da3ba6c35864a832dec1", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -974,18 +974,18 @@ impl<'a> Parser<'a> {\n     /// Parses mutability (`mut` or nothing).\n     fn parse_mutability(&mut self) -> Mutability {\n         if self.eat_keyword(kw::Mut) {\n-            Mutability::Mutable\n+            Mutability::Mut\n         } else {\n-            Mutability::Immutable\n+            Mutability::Not\n         }\n     }\n \n     /// Possibly parses mutability (`const` or `mut`).\n     fn parse_const_or_mut(&mut self) -> Option<Mutability> {\n         if self.eat_keyword(kw::Mut) {\n-            Some(Mutability::Mutable)\n+            Some(Mutability::Mut)\n         } else if self.eat_keyword(kw::Const) {\n-            Some(Mutability::Immutable)\n+            Some(Mutability::Not)\n         } else {\n             None\n         }"}, {"sha": "33cac1aaceeb0bd4e28431901b516818d5af6741", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -325,7 +325,7 @@ impl<'a> Parser<'a> {\n                 // Parse `ident @ pat`\n                 // This can give false positives and parse nullary enums,\n                 // they are dealt with later in resolve.\n-                self.parse_pat_ident(BindingMode::ByValue(Mutability::Immutable))?\n+                self.parse_pat_ident(BindingMode::ByValue(Mutability::Not))?\n             } else if self.is_start_of_pat_with_path() {\n                 // Parse pattern starting with a path\n                 let (qself, path) = if self.eat_lt() {\n@@ -539,7 +539,7 @@ impl<'a> Parser<'a> {\n             )\n             .emit();\n \n-        self.parse_pat_ident(BindingMode::ByRef(Mutability::Mutable))\n+        self.parse_pat_ident(BindingMode::ByRef(Mutability::Mut))\n     }\n \n     /// Turn all by-value immutable bindings in a pattern into mutable bindings.\n@@ -552,10 +552,10 @@ impl<'a> Parser<'a> {\n             }\n \n             fn visit_pat(&mut self, pat: &mut P<Pat>) {\n-                if let PatKind::Ident(BindingMode::ByValue(ref mut m @ Mutability::Immutable), ..)\n+                if let PatKind::Ident(BindingMode::ByValue(ref mut m @ Mutability::Not), ..)\n                     = pat.kind\n                 {\n-                    *m = Mutability::Mutable;\n+                    *m = Mutability::Mut;\n                     self.0 = true;\n                 }\n                 noop_visit_pat(pat, self);\n@@ -986,10 +986,10 @@ impl<'a> Parser<'a> {\n             hi = self.prev_span;\n \n             let bind_type = match (is_ref, is_mut) {\n-                (true, true) => BindingMode::ByRef(Mutability::Mutable),\n-                (true, false) => BindingMode::ByRef(Mutability::Immutable),\n-                (false, true) => BindingMode::ByValue(Mutability::Mutable),\n-                (false, false) => BindingMode::ByValue(Mutability::Immutable),\n+                (true, true) => BindingMode::ByRef(Mutability::Mut),\n+                (true, false) => BindingMode::ByRef(Mutability::Not),\n+                (false, true) => BindingMode::ByValue(Mutability::Mut),\n+                (false, false) => BindingMode::ByValue(Mutability::Not),\n             };\n \n             let fieldpat = self.mk_pat_ident(boxed_span.to(hi), bind_type, fieldname);"}, {"sha": "86692610324d411806d0722441d1c0247b2a24f5", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -261,7 +261,7 @@ impl<'a> Parser<'a> {\n                 .span_label(span, msg)\n                 .help(\"use `*mut T` or `*const T` as appropriate\")\n                 .emit();\n-            Mutability::Immutable\n+            Mutability::Not\n         });\n         let t = self.parse_ty_no_plus()?;\n         Ok(MutTy { ty: t, mutbl })"}, {"sha": "ee6a67802ade38237ee305cb972dbf822e797f3b", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -161,9 +161,9 @@ impl<'a> AstValidator<'a> {\n     fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, bool)) {\n         for Param { pat, .. } in &decl.inputs {\n             match pat.kind {\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), _, None) |\n+                PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, None) |\n                 PatKind::Wild => {}\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Mutable), _, None) =>\n+                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), _, None) =>\n                     report_err(pat.span, true),\n                 _ => report_err(pat.span, false),\n             }"}, {"sha": "f7bdefcb0690b83c5e87cff24beb39d6291cb82c", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -81,8 +81,8 @@ impl ConstKind {\n         let owner = hir_map.body_owner(body.id());\n         let const_kind = match hir_map.body_owner_kind(owner) {\n             hir::BodyOwnerKind::Const => Self::Const,\n-            hir::BodyOwnerKind::Static(Mutability::Mutable) => Self::StaticMut,\n-            hir::BodyOwnerKind::Static(Mutability::Immutable) => Self::Static,\n+            hir::BodyOwnerKind::Static(Mutability::Mut) => Self::StaticMut,\n+            hir::BodyOwnerKind::Static(Mutability::Not) => Self::Static,\n \n             hir::BodyOwnerKind::Fn if is_const_fn(owner) => Self::ConstFn,\n             hir::BodyOwnerKind::Fn | hir::BodyOwnerKind::Closure => return None,"}, {"sha": "43ac85993344e24e91f5311757b39ed0790ce422", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1472,7 +1472,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         // An immutable (no `mut`) by-value (no `ref`) binding pattern without\n         // a sub pattern (no `@ $pat`) is syntactically ambiguous as it could\n         // also be interpreted as a path to e.g. a constant, variant, etc.\n-        let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Immutable);\n+        let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n \n         match res {\n             Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |"}, {"sha": "0509748020a8452a57047312f42ce381e2f3b7af", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -985,7 +985,7 @@ impl<'l> Visitor<'l> for PathCollector<'l> {\n                     // Even if the ref is mut, you can't change the ref, only\n                     // the data pointed at, so showing the initialising expression\n                     // is still worthwhile.\n-                    ast::BindingMode::ByRef(_) => ast::Mutability::Immutable,\n+                    ast::BindingMode::ByRef(_) => ast::Mutability::Not,\n                     ast::BindingMode::ByValue(mt) => mt,\n                 };\n                 self.collected_idents"}, {"sha": "d1ac0ac210e40894a7e1c8c35020bdebac3ce4e6", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -175,8 +175,8 @@ impl Sig for ast::Ty {\n             }\n             ast::TyKind::Ptr(ref mt) => {\n                 let prefix = match mt.mutbl {\n-                    ast::Mutability::Mutable => \"*mut \",\n-                    ast::Mutability::Immutable => \"*const \",\n+                    ast::Mutability::Mut => \"*mut \",\n+                    ast::Mutability::Not => \"*const \",\n                 };\n                 let nested = mt.ty.make(offset + prefix.len(), id, scx)?;\n                 let text = format!(\"{}{}\", prefix, nested.text);\n@@ -188,7 +188,7 @@ impl Sig for ast::Ty {\n                     prefix.push_str(&l.ident.to_string());\n                     prefix.push(' ');\n                 }\n-                if let ast::Mutability::Mutable = mt.mutbl {\n+                if let ast::Mutability::Mut = mt.mutbl {\n                     prefix.push_str(\"mut \");\n                 };\n \n@@ -330,7 +330,7 @@ impl Sig for ast::Item {\n         match self.kind {\n             ast::ItemKind::Static(ref ty, m, ref expr) => {\n                 let mut text = \"static \".to_owned();\n-                if m == ast::Mutability::Mutable {\n+                if m == ast::Mutability::Mut {\n                     text.push_str(\"mut \");\n                 }\n                 let name = self.ident.to_string();\n@@ -787,7 +787,7 @@ impl Sig for ast::ForeignItem {\n             }\n             ast::ForeignItemKind::Static(ref ty, m) => {\n                 let mut text = \"static \".to_owned();\n-                if m == ast::Mutability::Mutable {\n+                if m == ast::Mutability::Mut {\n                     text.push_str(\"mut \");\n                 }\n                 let name = self.ident.to_string();"}, {"sha": "2f2d03fc596e48e6fadc6ebf647b64d876925bb8", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -866,8 +866,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"extra arguments to prepend to the linker invocation (space separated)\"),\n     profile: bool = (false, parse_bool, [TRACKED],\n                      \"insert profiling code\"),\n-    disable_instrumentation_preinliner: bool = (false, parse_bool, [TRACKED],\n-        \"Disable the instrumentation pre-inliner, useful for profiling / PGO.\"),\n     relro_level: Option<RelroLevel> = (None, parse_relro_level, [TRACKED],\n         \"choose which RELRO level to use\"),\n     nll_facts: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "f281ac176206499bc2a04d6bdf1f6a2282ecd42a", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -243,7 +243,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n         ty::Float(..) |\n         ty::RawPtr(..) |\n         ty::Never |\n-        ty::Ref(_, _, hir::Mutability::Immutable) => (),\n+        ty::Ref(_, _, hir::Mutability::Not) => (),\n \n         // Non parametric primitive types.\n         ty::Infer(ty::IntVar(_)) |\n@@ -319,7 +319,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n         ty::Generator(..) |\n         ty::Str |\n         ty::Slice(..) |\n-        ty::Ref(_, _, hir::Mutability::Mutable) => (),\n+        ty::Ref(_, _, hir::Mutability::Mut) => (),\n \n         ty::Bound(..) |\n         ty::GeneratorWitness(..) |"}, {"sha": "182c64e9069cdbb0bc68928ff755e063d28886ff", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -430,8 +430,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let contains_ref_bindings = arms.iter()\n             .filter_map(|a| a.pat.contains_explicit_ref_binding())\n             .max_by_key(|m| match *m {\n-                hir::Mutability::Mutable => 1,\n-                hir::Mutability::Immutable => 0,\n+                hir::Mutability::Mut => 1,\n+                hir::Mutability::Not => 0,\n             });\n \n         if let Some(m) = contains_ref_bindings {"}, {"sha": "db969486b8d16b180c9e38ad87a329dca3e067cf", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -217,8 +217,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if borrow {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                         let mutbl = match mutbl {\n-                            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                            hir::Mutability::Not => AutoBorrowMutability::Not,\n+                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                                 // For initial two-phase borrow\n                                 // deployment, conservatively omit\n                                 // overloaded function call ops."}, {"sha": "052364396953f63c59f61ace3f7af410c2d6f477", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -637,8 +637,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     ) -> Result<CastKind, CastError> {\n         // array-ptr-cast.\n \n-        if m_expr.mutbl == hir::Mutability::Immutable &&\n-            m_cast.mutbl == hir::Mutability::Immutable {\n+        if m_expr.mutbl == hir::Mutability::Not &&\n+            m_cast.mutbl == hir::Mutability::Not {\n             if let ty::Array(ety, _) = m_expr.ty.kind {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of"}, {"sha": "e44b00d74bf0a162be23afd48210a736b13e1594", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -101,10 +101,10 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n                        to_mutbl: hir::Mutability)\n                        -> RelateResult<'tcx, ()> {\n     match (from_mutbl, to_mutbl) {\n-        (hir::Mutability::Mutable, hir::Mutability::Mutable) |\n-        (hir::Mutability::Immutable, hir::Mutability::Immutable) |\n-        (hir::Mutability::Mutable, hir::Mutability::Immutable) => Ok(()),\n-        (hir::Mutability::Immutable, hir::Mutability::Mutable) => Err(TypeError::Mutability),\n+        (hir::Mutability::Mut, hir::Mutability::Mut) |\n+        (hir::Mutability::Not, hir::Mutability::Not) |\n+        (hir::Mutability::Mut, hir::Mutability::Not) => Ok(()),\n+        (hir::Mutability::Not, hir::Mutability::Mut) => Err(TypeError::Mutability),\n     }\n }\n \n@@ -412,7 +412,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n         };\n \n-        if ty == a && mt_a.mutbl == hir::Mutability::Immutable && autoderef.step_count() == 1 {\n+        if ty == a && mt_a.mutbl == hir::Mutability::Not && autoderef.step_count() == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n             // we started with.  In that case, just skip it\n@@ -424,7 +424,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // `self.x` both have `&mut `type would be a move of\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n-            assert_eq!(mt_b.mutbl, hir::Mutability::Immutable); // can only coerce &T -> &U\n+            assert_eq!(mt_b.mutbl, hir::Mutability::Not); // can only coerce &T -> &U\n             return success(vec![], ty, obligations);\n         }\n \n@@ -441,8 +441,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n         let mutbl = match mt_b.mutbl {\n-            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+            hir::Mutability::Not => AutoBorrowMutability::Not,\n+            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                 allow_two_phase_borrow: self.allow_two_phase,\n             }\n         };\n@@ -487,8 +487,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n                 let mutbl = match mutbl_b {\n-                    hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                    hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                    hir::Mutability::Not => AutoBorrowMutability::Not,\n+                    hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                         // We don't allow two-phase borrows here, at least for initial\n                         // implementation. If it happens that this coercion is a function argument,\n                         // the reborrow in coerce_borrowed_ptr will pick it up."}, {"sha": "ab8a4e5a9d053eb69f134e5b2bdcc9e5382e4add", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -534,8 +534,8 @@ fn compare_self_type<'tcx>(\n             let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n             match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n                 ExplicitSelf::ByValue => \"self\".to_owned(),\n-                ExplicitSelf::ByReference(_, hir::Mutability::Immutable) => \"&self\".to_owned(),\n-                ExplicitSelf::ByReference(_, hir::Mutability::Mutable) => \"&mut self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n                 _ => format!(\"self: {}\", self_arg_ty)\n             }\n         })"}, {"sha": "6a78a4d733a9450d41c6c7429a2a63ffa40d2eba", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -436,10 +436,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // bar(&x); // error, expected &mut\n                 // ```\n                 let ref_ty = match mutability {\n-                    hir::Mutability::Mutable => {\n+                    hir::Mutability::Mut => {\n                         self.tcx.mk_mut_ref(self.tcx.mk_region(ty::ReStatic), checked_ty)\n                     }\n-                    hir::Mutability::Immutable => {\n+                    hir::Mutability::Not => {\n                         self.tcx.mk_imm_ref(self.tcx.mk_region(ty::ReStatic), checked_ty)\n                     }\n                 };\n@@ -489,7 +489,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         })) = self.tcx.hir().find(\n                             self.tcx.hir().get_parent_node(expr.hir_id),\n                         ) {\n-                            if mutability == hir::Mutability::Mutable {\n+                            if mutability == hir::Mutability::Mut {\n                                 // Found the following case:\n                                 // fn foo(opt: &mut Option<String>){ opt = None }\n                                 //                                   ---   ^^^^\n@@ -508,12 +508,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n \n                         return Some(match mutability {\n-                            hir::Mutability::Mutable => (\n+                            hir::Mutability::Mut => (\n                                 sp,\n                                 \"consider mutably borrowing here\",\n                                 format!(\"{}&mut {}\", field_name, sugg_expr),\n                             ),\n-                            hir::Mutability::Immutable => (\n+                            hir::Mutability::Not => (\n                                 sp,\n                                 \"consider borrowing here\",\n                                 format!(\"{}&{}\", field_name, sugg_expr),"}, {"sha": "025bb05f63a4a069e35f176abdafce18b6b9f15a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 139, "deletions": 17, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -2,13 +2,15 @@ use crate::check::regionck::RegionCtxt;\n \n use crate::hir;\n use crate::hir::def_id::DefId;\n+use crate::util::common::ErrorReported;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::{InferOk, SuppressRegionErrors};\n use rustc::middle::region;\n use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc::ty::error::TypeError;\n+use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc::ty::subst::{Subst, SubstsRef};\n-use rustc::ty::{self, Ty, TyCtxt};\n-use crate::util::common::ErrorReported;\n+use rustc::ty::{self, Predicate, Ty, TyCtxt};\n \n use syntax_pos::Span;\n \n@@ -56,8 +58,10 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n             // already checked by coherence, but compilation may\n             // not have been terminated.\n             let span = tcx.def_span(drop_impl_did);\n-            tcx.sess.delay_span_bug(span,\n-                &format!(\"should have been rejected by coherence check: {}\", dtor_self_type));\n+            tcx.sess.delay_span_bug(\n+                span,\n+                &format!(\"should have been rejected by coherence check: {}\", dtor_self_type),\n+            );\n             Err(ErrorReported)\n         }\n     }\n@@ -85,10 +89,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_hir_id);\n-        match infcx\n-            .at(cause, impl_param_env)\n-            .eq(named_type, fresh_impl_self_ty)\n-        {\n+        match infcx.at(cause, impl_param_env).eq(named_type, fresh_impl_self_ty) {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfillment_cx.register_predicate_obligations(infcx, obligations);\n             }\n@@ -99,12 +100,13 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n                     drop_impl_span,\n                     E0366,\n                     \"Implementations of Drop cannot be specialized\"\n-                ).span_note(\n+                )\n+                .span_note(\n                     item_span,\n                     \"Use same sequence of generic type and region \\\n                      parameters that is on the struct/enum definition\",\n                 )\n-                    .emit();\n+                .emit();\n                 return Err(ErrorReported);\n             }\n         }\n@@ -194,6 +196,8 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n     let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n \n+    let self_param_env = tcx.param_env(self_type_did);\n+\n     // An earlier version of this code attempted to do this checking\n     // via the traits::fulfill machinery. However, it ran into trouble\n     // since the fulfill machinery merely turns outlives-predicates\n@@ -207,27 +211,49 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // to take on a structure that is roughly an alpha-renaming of\n         // the generic parameters of the item definition.)\n \n-        // This path now just checks *all* predicates via the direct\n-        // lookup, rather than using fulfill machinery.\n+        // This path now just checks *all* predicates via an instantiation of\n+        // the `SimpleEqRelation`, which simply forwards to the `relate` machinery\n+        // after taking care of anonymizing late bound regions.\n         //\n         // However, it may be more efficient in the future to batch\n-        // the analysis together via the fulfill , rather than the\n-        // repeated `contains` calls.\n+        // the analysis together via the fulfill (see comment above regarding\n+        // the usage of the fulfill machinery), rather than the\n+        // repeated `.iter().any(..)` calls.\n \n-        if !assumptions_in_impl_context.contains(&predicate) {\n+        // This closure is a more robust way to check `Predicate` equality\n+        // than simple `==` checks (which were the previous implementation).\n+        // It relies on `ty::relate` for `TraitPredicate` and `ProjectionPredicate`\n+        // (which implement the Relate trait), while delegating on simple equality\n+        // for the other `Predicate`.\n+        // This implementation solves (Issue #59497) and (Issue #58311).\n+        // It is unclear to me at the moment whether the approach based on `relate`\n+        // could be extended easily also to the other `Predicate`.\n+        let predicate_matches_closure = |p: &'_ Predicate<'tcx>| {\n+            let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n+            match (predicate, p) {\n+                (Predicate::Trait(a), Predicate::Trait(b)) => relator.relate(a, b).is_ok(),\n+                (Predicate::Projection(a), Predicate::Projection(b)) => {\n+                    relator.relate(a, b).is_ok()\n+                }\n+                _ => predicate == p,\n+            }\n+        };\n+\n+        if !assumptions_in_impl_context.iter().any(predicate_matches_closure) {\n             let item_span = tcx.hir().span(self_type_hir_id);\n             struct_span_err!(\n                 tcx.sess,\n                 drop_impl_span,\n                 E0367,\n                 \"The requirement `{}` is added only by the Drop impl.\",\n                 predicate\n-            ).span_note(\n+            )\n+            .span_note(\n                 item_span,\n                 \"The same requirement must be part of \\\n                  the struct/enum definition\",\n             )\n-                .emit();\n+            .emit();\n             result = Err(ErrorReported);\n         }\n     }\n@@ -253,3 +279,99 @@ crate fn check_drop_obligations<'a, 'tcx>(\n \n     Ok(())\n }\n+\n+// This is an implementation of the TypeRelation trait with the\n+// aim of simply comparing for equality (without side-effects).\n+// It is not intended to be used anywhere else other than here.\n+crate struct SimpleEqRelation<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'tcx> SimpleEqRelation<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> SimpleEqRelation<'tcx> {\n+        SimpleEqRelation { tcx, param_env }\n+    }\n+}\n+\n+impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"dropck::SimpleEqRelation\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        // Here we ignore variance because we require drop impl's types\n+        // to be *exactly* the same as to the ones in the struct definition.\n+        self.relate(a, b)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"SimpleEqRelation::tys(a={:?}, b={:?})\", a, b);\n+        ty::relate::super_relate_tys(self, a, b)\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\"SimpleEqRelation::regions(a={:?}, b={:?})\", a, b);\n+\n+        // We can just equate the regions because LBRs have been\n+        // already anonymized.\n+        if a == b {\n+            Ok(a)\n+        } else {\n+            // I'm not sure is this `TypeError` is the right one, but\n+            // it should not matter as it won't be checked (the dropck\n+            // will emit its own, more informative and higher-level errors\n+            // in case anything goes wrong).\n+            Err(TypeError::RegionsPlaceholderMismatch)\n+        }\n+    }\n+\n+    fn consts(\n+        &mut self,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        debug!(\"SimpleEqRelation::consts(a={:?}, b={:?})\", a, b);\n+        ty::relate::super_relate_consts(self, a, b)\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        b: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        debug!(\"SimpleEqRelation::binders({:?}: {:?}\", a, b);\n+\n+        // Anonymizing the LBRs is necessary to solve (Issue #59497).\n+        // After we do so, it should be totally fine to skip the binders.\n+        let anon_a = self.tcx.anonymize_late_bound_regions(a);\n+        let anon_b = self.tcx.anonymize_late_bound_regions(b);\n+        self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n+\n+        Ok(a.clone())\n+    }\n+}"}, {"sha": "17b168cfab05a193c10b336c8744208cbd72a9e2", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -365,8 +365,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let method = self.register_infer_ok_obligations(ok);\n                         if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                             let mutbl = match mutbl {\n-                                hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                                hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                                hir::Mutability::Not => AutoBorrowMutability::Not,\n+                                hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                                     // (It shouldn't actually matter for unary ops whether\n                                     // we enable two-phase borrows or not, since a unary\n                                     // op has no additional operands.)"}, {"sha": "c5eb94e2165b8705a59879e0b2ed5e2669c1bc20", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -165,7 +165,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n             \"prefetch_read_instruction\" | \"prefetch_write_instruction\" => {\n                 (1, vec![tcx.mk_ptr(ty::TypeAndMut {\n                           ty: param(0),\n-                          mutbl: hir::Mutability::Immutable\n+                          mutbl: hir::Mutability::Not\n                          }), tcx.types.i32],\n                     tcx.mk_unit())\n             }\n@@ -181,25 +181,25 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::Mutability::Immutable\n+                      mutbl: hir::Mutability::Not\n                   }),\n                   tcx.types.isize\n                ],\n                tcx.mk_ptr(ty::TypeAndMut {\n                    ty: param(0),\n-                   mutbl: hir::Mutability::Immutable\n+                   mutbl: hir::Mutability::Not\n                }))\n             }\n             \"copy\" | \"copy_nonoverlapping\" => {\n               (1,\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::Mutability::Immutable\n+                      mutbl: hir::Mutability::Not\n                   }),\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::Mutability::Mutable\n+                      mutbl: hir::Mutability::Mut\n                   }),\n                   tcx.types.usize,\n                ],\n@@ -210,11 +210,11 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::Mutability::Mutable\n+                      mutbl: hir::Mutability::Mut\n                   }),\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::Mutability::Immutable\n+                      mutbl: hir::Mutability::Not\n                   }),\n                   tcx.types.usize,\n                ],\n@@ -225,7 +225,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::Mutability::Mutable\n+                      mutbl: hir::Mutability::Mut\n                   }),\n                   tcx.types.u8,\n                   tcx.types.usize,\n@@ -351,14 +351,14 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n             }\n \n             \"va_start\" | \"va_end\" => {\n-                match mk_va_list_ty(hir::Mutability::Mutable) {\n+                match mk_va_list_ty(hir::Mutability::Mut) {\n                     Some((va_list_ref_ty, _)) => (0, vec![va_list_ref_ty], tcx.mk_unit()),\n                     None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }\n             }\n \n             \"va_copy\" => {\n-                match mk_va_list_ty(hir::Mutability::Immutable) {\n+                match mk_va_list_ty(hir::Mutability::Not) {\n                     Some((va_list_ref_ty, va_list_ty)) => {\n                         let va_list_ptr_ty = tcx.mk_mut_ptr(va_list_ty);\n                         (0, vec![va_list_ptr_ty, va_list_ref_ty], tcx.mk_unit())\n@@ -368,7 +368,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n             }\n \n             \"va_arg\" => {\n-                match mk_va_list_ty(hir::Mutability::Mutable) {\n+                match mk_va_list_ty(hir::Mutability::Mut) {\n                     Some((va_list_ref_ty, _)) => (1, vec![va_list_ref_ty], param(0)),\n                     None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }"}, {"sha": "d04baf7dd077b4d8390ad57c0a63f194b300c568", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             sig: method_sig,\n         };\n \n-        if let Some(hir::Mutability::Mutable) = pick.autoref {\n+        if let Some(hir::Mutability::Mut) = pick.autoref {\n             self.convert_place_derefs_to_mutable();\n         }\n \n@@ -172,8 +172,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 ty: target\n             });\n             let mutbl = match mutbl {\n-                hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                hir::Mutability::Not => AutoBorrowMutability::Not,\n+                hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                     // Method call receivers are the primary use case\n                     // for two-phase borrows.\n                     allow_two_phase_borrow: AllowTwoPhase::Yes,\n@@ -554,8 +554,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n                     debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n                     let mutbl = match mutbl {\n-                        hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                        hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                        hir::Mutability::Not => AutoBorrowMutability::Not,\n+                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                             // For initial two-phase borrow\n                             // deployment, conservatively omit\n                             // overloaded operators."}, {"sha": "f797eec911bfdc2a707faedf381c9f242b764336", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -608,11 +608,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 let lang_def_id = lang_items.slice_u8_alloc_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Immutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Not }) => {\n                 let lang_def_id = lang_items.const_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mut }) => {\n                 let lang_def_id = lang_items.mut_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n@@ -1047,8 +1047,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         span_bug!(self.span, \"{:?} was applicable but now isn't?\", step.self_ty)\n                     });\n                 self.pick_by_value_method(step, self_ty).or_else(|| {\n-                self.pick_autorefd_method(step, self_ty, hir::Mutability::Immutable).or_else(|| {\n-                self.pick_autorefd_method(step, self_ty, hir::Mutability::Mutable)\n+                self.pick_autorefd_method(step, self_ty, hir::Mutability::Not).or_else(|| {\n+                self.pick_autorefd_method(step, self_ty, hir::Mutability::Mut)\n             })})})\n             .next()\n     }"}, {"sha": "afd027e34380d9f6197010872e91fc6bb7f58f02", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -397,8 +397,8 @@ pub enum Needs {\n impl Needs {\n     fn maybe_mut_place(m: hir::Mutability) -> Self {\n         match m {\n-            hir::Mutability::Mutable => Needs::MutPlace,\n-            hir::Mutability::Immutable => Needs::None,\n+            hir::Mutability::Mut => Needs::MutPlace,\n+            hir::Mutability::Not => Needs::None,\n         }\n     }\n }\n@@ -1436,7 +1436,7 @@ fn check_fn<'a, 'tcx>(\n                         ty::Ref(region, ty, mutbl) => match ty.kind {\n                             ty::Adt(ref adt, _) => {\n                                 adt.did == panic_info_did &&\n-                                    mutbl == hir::Mutability::Immutable &&\n+                                    mutbl == hir::Mutability::Not &&\n                                     *region != RegionKind::ReStatic\n                             },\n                             _ => false,\n@@ -3419,8 +3419,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut adjustments = autoderef.adjust_steps(self, needs);\n                 if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].kind {\n                     let mutbl = match r_mutbl {\n-                        hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                        hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                        hir::Mutability::Not => AutoBorrowMutability::Not,\n+                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                             // Indexing can be desugared to a method call,\n                             // so maybe we could use two-phase here.\n                             // See the documentation of AllowTwoPhase for why that's"}, {"sha": "041a6c6f44c519f2ffa937fccd0cbfbd8fb497a1", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -206,8 +206,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                         let mutbl = match mutbl {\n-                            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                            hir::Mutability::Not => AutoBorrowMutability::Not,\n+                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                                 // Allow two-phase borrows for binops in initial deployment\n                                 // since they desugar to methods\n                                 allow_two_phase_borrow: AllowTwoPhase::Yes,\n@@ -223,8 +223,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if by_ref_binop {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[1].kind {\n                         let mutbl = match mutbl {\n-                            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                            hir::Mutability::Not => AutoBorrowMutability::Not,\n+                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                                 // Allow two-phase borrows for binops in initial deployment\n                                 // since they desugar to methods\n                                 allow_two_phase_borrow: AllowTwoPhase::Yes,"}, {"sha": "11f744e97614c7bfa007d04665968a17b8c18c1a", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -32,7 +32,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\";\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_pat_top(&self, pat: &'tcx Pat, expected: Ty<'tcx>, discrim_span: Option<Span>) {\n-        let def_bm = BindingMode::BindByValue(hir::Mutability::Immutable);\n+        let def_bm = BindingMode::BindByValue(hir::Mutability::Not);\n         self.check_pat(pat, expected, def_bm, discrim_span);\n     }\n \n@@ -196,7 +196,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             //\n             // See issue #46688.\n             let def_bm = match pat.kind {\n-                PatKind::Ref(..) => ty::BindByValue(hir::Mutability::Immutable),\n+                PatKind::Ref(..) => ty::BindByValue(hir::Mutability::Not),\n                 _ => def_bm,\n             };\n             (expected, def_bm)\n@@ -277,10 +277,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // (depending on whether we observe `&` or `&mut`).\n                 ty::BindByValue(_) |\n                 // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref` (on `&`).\n-                ty::BindByReference(hir::Mutability::Mutable) => inner_mutability,\n+                ty::BindByReference(hir::Mutability::Mut) => inner_mutability,\n                 // Once a `ref`, always a `ref`.\n                 // This is because a `& &mut` cannot mutate the underlying value.\n-                ty::BindByReference(m @ hir::Mutability::Immutable) => m,\n+                ty::BindByReference(m @ hir::Mutability::Not) => m,\n             });\n         }\n "}, {"sha": "179c462f5e374a08d5b73ba44a88acfcc27396e4", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1255,15 +1255,15 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         // know whether this scenario has occurred; but I wanted to show\n         // how all the types get adjusted.)\n         match ref_mutability {\n-            hir::Mutability::Immutable => {\n+            hir::Mutability::Not => {\n                 // The reference being reborrowed is a shareable ref of\n                 // type `&'a T`. In this case, it doesn't matter where we\n                 // *found* the `&T` pointer, the memory it references will\n                 // be valid and immutable for `'a`. So we can stop here.\n                 true\n             }\n \n-            hir::Mutability::Mutable => {\n+            hir::Mutability::Mut => {\n                 // The reference being reborrowed is either an `&mut T`. This is\n                 // the case where recursion is needed.\n                 false"}, {"sha": "68cb0080b7d4135f3704885eb3a04f45be60a1a9", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n                     // borrowed pointer implies that the\n                     // pointer itself must be unique, but not\n                     // necessarily *mutable*\n-                    ty::Ref(.., hir::Mutability::Mutable) => borrow_kind = ty::UniqueImmBorrow,\n+                    ty::Ref(.., hir::Mutability::Mut) => borrow_kind = ty::UniqueImmBorrow,\n                     _ => (),\n                 }\n             }"}, {"sha": "3797fcb1a6b4c8295c7927f73cb318e17e981961", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -360,7 +360,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,\n                            mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n-            if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Immutable, hir::Mutability::Mutable) {\n+            if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Not, hir::Mutability::Mut) {\n                 infcx.report_mismatched_types(&cause,\n                                               mk_ptr(mt_b.ty),\n                                               target,"}, {"sha": "2e2e56e6dcfeded2b99513ce1848f45b745e1bba", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -109,15 +109,15 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                                           \"[T]\",\n                                           item.span);\n             }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Immutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Not }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.const_ptr_impl(),\n                                           None,\n                                           \"const_ptr\",\n                                           \"*const T\",\n                                           item.span);\n             }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mut }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.mut_ptr_impl(),\n                                           None,"}, {"sha": "30558a0f5f679f5f8dbbfc6611fce14e03107145", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -454,12 +454,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                mt: &ty::TypeAndMut<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {\n-            hir::Mutability::Mutable => {\n+            hir::Mutability::Mut => {\n                 let invar = self.invariant(variance);\n                 self.add_constraints_from_ty(current, mt.ty, invar);\n             }\n \n-            hir::Mutability::Immutable => {\n+            hir::Mutability::Not => {\n                 self.add_constraints_from_ty(current, mt.ty, variance);\n             }\n         }"}, {"sha": "cebfd99452ad42b0b630c9d6f0e6291b96d013f5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -2101,8 +2101,8 @@ impl Clean<Item> for doctree::Constant<'_> {\n impl Clean<Mutability> for hir::Mutability {\n     fn clean(&self, _: &DocContext<'_>) -> Mutability {\n         match self {\n-            &hir::Mutability::Mutable => Mutable,\n-            &hir::Mutability::Immutable => Immutable,\n+            &hir::Mutability::Mut => Mutable,\n+            &hir::Mutability::Not => Immutable,\n         }\n     }\n }"}, {"sha": "aa38a8135cecbe462d6a9c982b2dbe33320363de", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -509,7 +509,7 @@ impl Pat {\n             // In a type expression `_` is an inference variable.\n             PatKind::Wild => TyKind::Infer,\n             // An IDENT pattern with no binding mode would be valid as path to a type. E.g. `u32`.\n-            PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None) => {\n+            PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None) => {\n                 TyKind::Path(None, Path::from_ident(*ident))\n             }\n             PatKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n@@ -695,30 +695,30 @@ pub enum PatKind {\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n          RustcEncodable, RustcDecodable, Debug, Copy, HashStable_Generic)]\n pub enum Mutability {\n-    Mutable,\n-    Immutable,\n+    Mut,\n+    Not,\n }\n \n impl Mutability {\n     /// Returns `MutMutable` only if both `self` and `other` are mutable.\n     pub fn and(self, other: Self) -> Self {\n         match self {\n-            Mutability::Mutable => other,\n-            Mutability::Immutable => Mutability::Immutable,\n+            Mutability::Mut => other,\n+            Mutability::Not => Mutability::Not,\n         }\n     }\n \n     pub fn invert(self) -> Self {\n         match self {\n-            Mutability::Mutable => Mutability::Immutable,\n-            Mutability::Immutable => Mutability::Mutable,\n+            Mutability::Mut => Mutability::Not,\n+            Mutability::Not => Mutability::Mut,\n         }\n     }\n \n     pub fn prefix_str(&self) -> &'static str {\n         match self {\n-            Mutability::Mutable => \"mut \",\n-            Mutability::Immutable => \"\",\n+            Mutability::Mut => \"mut \",\n+            Mutability::Not => \"\",\n         }\n     }\n }\n@@ -2037,7 +2037,7 @@ impl Param {\n             SelfKind::Explicit(ty, mutbl) => param(mutbl, ty),\n             SelfKind::Value(mutbl) => param(mutbl, infer_ty),\n             SelfKind::Region(lt, mutbl) => param(\n-                Mutability::Immutable,\n+                Mutability::Not,\n                 P(Ty {\n                     id: DUMMY_NODE_ID,\n                     kind: TyKind::Rptr("}, {"sha": "e63d11ce832279a451a362f6bd666f642ca5f3f6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1071,7 +1071,7 @@ impl<'a> State<'a> {\n             }\n             ast::ForeignItemKind::Static(ref t, m) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == ast::Mutability::Mutable {\n+                if m == ast::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -1162,7 +1162,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::Static(ref ty, m, ref expr) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == ast::Mutability::Mutable {\n+                if m == ast::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -2302,8 +2302,8 @@ impl<'a> State<'a> {\n                         self.word_nbsp(\"ref\");\n                         self.print_mutability(mutbl, false);\n                     }\n-                    ast::BindingMode::ByValue(ast::Mutability::Immutable) => {}\n-                    ast::BindingMode::ByValue(ast::Mutability::Mutable) => {\n+                    ast::BindingMode::ByValue(ast::Mutability::Not) => {}\n+                    ast::BindingMode::ByValue(ast::Mutability::Mut) => {\n                         self.word_nbsp(\"mut\");\n                     }\n                 }\n@@ -2366,7 +2366,7 @@ impl<'a> State<'a> {\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n                 self.s.word(\"&\");\n-                if mutbl == ast::Mutability::Mutable {\n+                if mutbl == ast::Mutability::Mut {\n                     self.s.word(\"mut \");\n                 }\n                 self.print_pat(inner);\n@@ -2667,8 +2667,8 @@ impl<'a> State<'a> {\n \n     pub fn print_mutability(&mut self, mutbl: ast::Mutability, print_const: bool) {\n         match mutbl {\n-            ast::Mutability::Mutable => self.word_nbsp(\"mut\"),\n-            ast::Mutability::Immutable => if print_const { self.word_nbsp(\"const\"); },\n+            ast::Mutability::Mut => self.word_nbsp(\"mut\"),\n+            ast::Mutability::Not => if print_const { self.word_nbsp(\"const\"); },\n         }\n     }\n "}, {"sha": "7c69be56beb81f956da11af5ee9e57555b442b8c", "filename": "src/libsyntax_expand/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbuild.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -178,7 +178,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n                 ex: P<ast::Expr>) -> ast::Stmt {\n         let pat = if mutbl {\n-            let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mutable);\n+            let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mut);\n             self.pat_ident_binding_mode(sp, ident, binding_mode)\n         } else {\n             self.pat_ident(sp, ident)\n@@ -269,7 +269,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::AddrOf(ast::BorrowKind::Ref, ast::Mutability::Immutable, e))\n+        self.expr(sp, ast::ExprKind::AddrOf(ast::BorrowKind::Ref, ast::Mutability::Not, e))\n     }\n \n     pub fn expr_call(\n@@ -421,7 +421,7 @@ impl<'a> ExtCtxt<'a> {\n         self.pat(span, PatKind::Lit(expr))\n     }\n     pub fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat> {\n-        let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Immutable);\n+        let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Not);\n         self.pat_ident_binding_mode(span, ident, binding_mode)\n     }\n "}, {"sha": "1b1a231f2d8703ba0e93f8bebc12fe258385879e", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -16,7 +16,7 @@ pub fn expand_deriving_debug(cx: &mut ExtCtxt<'_>,\n                              push: &mut dyn FnMut(Annotatable)) {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(Box::new(Literal(path_std!(cx, fmt::Formatter))),\n-                   Borrowed(None, ast::Mutability::Mutable));\n+                   Borrowed(None, ast::Mutability::Mut));\n \n     let trait_def = TraitDef {\n         span,"}, {"sha": "5cc5aebaba02098a242eb9c1264350f9e5481e42", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -39,7 +39,7 @@ pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt<'_>,\n                           },\n                           explicit_self: None,\n                           args: vec![(Ptr(Box::new(Literal(Path::new_local(typaram))),\n-                                         Borrowed(None, Mutability::Mutable)), \"d\")],\n+                                         Borrowed(None, Mutability::Mut)), \"d\")],\n                           ret_ty:\n                               Literal(Path::new_(pathvec_std!(cx, result::Result),\n                                                  None,"}, {"sha": "99ee0f47d6d6667cdc207bc69bd7b827f172a593", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -123,7 +123,7 @@ pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt<'_>,\n                 },\n                 explicit_self: borrowed_explicit_self(),\n                 args: vec![(Ptr(Box::new(Literal(Path::new_local(typaram))),\n-                           Borrowed(None, Mutability::Mutable)), \"s\")],\n+                           Borrowed(None, Mutability::Mut)), \"s\")],\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, result::Result),\n                     None,"}, {"sha": "5fecd13db9895d8901e0f78665701b3f14cc5f50", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -1017,7 +1017,7 @@ impl<'a> MethodDef<'a> {\n                                                                  struct_path,\n                                                                  struct_def,\n                                                                  &format!(\"__self_{}\", i),\n-                                                                 ast::Mutability::Immutable,\n+                                                                 ast::Mutability::Not,\n                                                                  use_temporaries);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n@@ -1227,8 +1227,8 @@ impl<'a> MethodDef<'a> {\n                                                      type_ident,\n                                                      variant,\n                                                      self_arg_name,\n-                                                     ast::Mutability::Immutable);\n-                    (cx.pat(sp, PatKind::Ref(p, ast::Mutability::Immutable)), idents)\n+                                                     ast::Mutability::Not);\n+                    (cx.pat(sp, PatKind::Ref(p, ast::Mutability::Not)), idents)\n                 };\n \n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n@@ -1558,7 +1558,7 @@ impl<'a> TraitDef<'a> {\n         field_paths.iter()\n             .map(|path| {\n                 let binding_mode = if use_temporaries {\n-                    ast::BindingMode::ByValue(ast::Mutability::Immutable)\n+                    ast::BindingMode::ByValue(ast::Mutability::Not)\n                 } else {\n                     ast::BindingMode::ByRef(mutbl)\n                 };"}, {"sha": "b7aa8874aad3dc689c1b3c4f4faf47e80462593b", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -108,7 +108,7 @@ pub enum Ty<'a> {\n }\n \n pub fn borrowed_ptrty() -> PtrTy {\n-    Borrowed(None, ast::Mutability::Immutable)\n+    Borrowed(None, ast::Mutability::Not)\n }\n pub fn borrowed(ty: Box<Ty<'_>>) -> Ty<'_> {\n     Ptr(ty, borrowed_ptrty())\n@@ -268,7 +268,7 @@ pub fn get_explicit_self(cx: &ExtCtxt<'_>,\n     // this constructs a fresh `self` path\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n-        None => (self_path, respan(span, SelfKind::Value(ast::Mutability::Immutable))),\n+        None => (self_path, respan(span, SelfKind::Value(ast::Mutability::Not))),\n         Some(ref ptr) => {\n             let self_ty =\n                 respan(span,"}, {"sha": "3ea8dcf46ec1b830989c45b7f5d8c3f0db81e7fa", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -35,7 +35,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt<'_>,\n                           },\n                           explicit_self: borrowed_explicit_self(),\n                           args: vec![(Ptr(Box::new(Literal(arg)),\n-                                         Borrowed(None, Mutability::Mutable)), \"state\")],\n+                                         Borrowed(None, Mutability::Mut)), \"state\")],\n                           ret_ty: nil_ty(),\n                           attributes: vec![],\n                           is_unsafe: false,"}, {"sha": "1ea202f630b620dccf348934dd79dcdeae3ccdbc", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -31,7 +31,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                                                      cx.ty_ident(sp,\n                                                                  Ident::new(sym::str, sp)),\n                                                      Some(lt),\n-                                                     ast::Mutability::Immutable))],\n+                                                     ast::Mutability::Not))],\n                                      ))\n         }\n         Ok(s) => {"}, {"sha": "025d3e91c8166375360226e66d9f4f5857f7eb8e", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -180,6 +180,6 @@ impl AllocFnFactory<'_, '_> {\n     fn ptr_u8(&self) -> P<Ty> {\n         let u8 = self.cx.path_ident(self.span, Ident::new(sym::u8, self.span));\n         let ty_u8 = self.cx.ty_path(u8);\n-        self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n+        self.cx.ty_ptr(self.span, ty_u8, Mutability::Mut)\n     }\n }"}, {"sha": "bcc38c8644a0902628d66b5f1001ba842b969497", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -415,8 +415,8 @@ fn mk_decls(\n             cx.ty(span, ast::TyKind::Slice(\n                 cx.ty_path(cx.path(span,\n                     vec![proc_macro, bridge, client, proc_macro_ty])))),\n-            None, ast::Mutability::Immutable),\n-        ast::Mutability::Immutable,\n+            None, ast::Mutability::Not),\n+        ast::Mutability::Not,\n         cx.expr_vec_slice(span, decls),\n     ).map(|mut i| {\n         let attr = cx.meta_word(span, sym::rustc_proc_macro_decls);"}, {"sha": "0c050e314133e49e84865c08ff8abf02568a683f", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -141,7 +141,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n             15 => {\n                 iter_exprs(\n                     depth - 1,\n-                    &mut |e| g(ExprKind::AddrOf(BorrowKind::Ref, Mutability::Immutable, e)),\n+                    &mut |e| g(ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, e)),\n                 );\n             },\n             16 => {"}, {"sha": "0e767d9613a996b7f591cfb472aab1d58b6e82f9", "filename": "src/test/ui/array-slice-vec/subslice-patterns-const-eval-match.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval-match.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -0,0 +1,97 @@\n+// Test that slice subslice patterns are correctly handled in const evaluation.\n+\n+// run-pass\n+\n+#![feature(slice_patterns, const_fn, const_if_match)]\n+#[derive(PartialEq, Debug, Clone)]\n+struct N(u8);\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct Z;\n+\n+macro_rules! n {\n+    ($($e:expr),* $(,)?) => {\n+        [$(N($e)),*]\n+    }\n+}\n+\n+// This macro has an unused variable so that it can be repeated base on the\n+// number of times a repeated variable (`$e` in `z`) occurs.\n+macro_rules! zed {\n+    ($e:expr) => { Z }\n+}\n+\n+macro_rules! z {\n+    ($($e:expr),* $(,)?) => {\n+        [$(zed!($e)),*]\n+    }\n+}\n+\n+// Compare constant evaluation and runtime evaluation of a given expression.\n+macro_rules! compare_evaluation_inner {\n+    ($e:expr, $t:ty $(,)?) => {{\n+        const CONST_EVAL: $t = $e;\n+        const fn const_eval() -> $t { $e }\n+        static CONST_EVAL2: $t = const_eval();\n+        let runtime_eval = $e;\n+        assert_eq!(CONST_EVAL, runtime_eval);\n+        assert_eq!(CONST_EVAL2, runtime_eval);\n+    }}\n+}\n+\n+// Compare the result of matching `$e` against `$p` using both `if let` and\n+// `match`.\n+macro_rules! compare_evaluation {\n+    ($p:pat, $e:expr, $matches:expr, $t:ty $(,)?) => {{\n+        compare_evaluation_inner!(if let $p = $e as &[_] { $matches } else { None }, $t);\n+        compare_evaluation_inner!(match $e as &[_] { $p => $matches, _ => None }, $t);\n+    }}\n+}\n+\n+// Repeat `$test`, substituting the given macro variables with the given\n+// identifiers.\n+//\n+// For example:\n+//\n+// repeat! {\n+//     ($name); X; Y:\n+//     struct $name;\n+// }\n+//\n+// Expands to:\n+//\n+// struct X; struct Y;\n+//\n+// This is used to repeat the tests using both the `N` and `Z`\n+// types.\n+macro_rules! repeat {\n+    (($($dollar:tt $placeholder:ident)*); $($($values:ident),+);*: $($test:tt)*) => {\n+        macro_rules! single {\n+            ($($dollar $placeholder:ident),*) => { $($test)* }\n+        }\n+        $(single!($($values),+);)*\n+    }\n+}\n+\n+fn main() {\n+    repeat! {\n+        ($arr $Ty); n, N; z, Z:\n+        compare_evaluation!([_, x @ .., _], &$arr!(1, 2, 3, 4), Some(x), Option<&'static [$Ty]>);\n+        compare_evaluation!([x, .., _], &$arr!(1, 2, 3, 4), Some(x), Option<&'static $Ty>);\n+        compare_evaluation!([_, .., x], &$arr!(1, 2, 3, 4), Some(x), Option<&'static $Ty>);\n+\n+        compare_evaluation!([_, x @ .., _], &$arr!(1, 2), Some(x), Option<&'static [$Ty]>);\n+        compare_evaluation!([x, .., _], &$arr!(1, 2), Some(x), Option<&'static $Ty>);\n+        compare_evaluation!([_, .., x], &$arr!(1, 2), Some(x), Option<&'static $Ty>);\n+\n+        compare_evaluation!([_, x @ .., _], &$arr!(1), Some(x), Option<&'static [$Ty]>);\n+        compare_evaluation!([x, .., _], &$arr!(1), Some(x), Option<&'static $Ty>);\n+        compare_evaluation!([_, .., x], &$arr!(1), Some(x), Option<&'static $Ty>);\n+    }\n+\n+    compare_evaluation!([N(x), .., _], &n!(1, 2, 3, 4), Some(x), Option<&'static u8>);\n+    compare_evaluation!([_, .., N(x)], &n!(1, 2, 3, 4), Some(x), Option<&'static u8>);\n+\n+    compare_evaluation!([N(x), .., _], &n!(1, 2), Some(x), Option<&'static u8>);\n+    compare_evaluation!([_, .., N(x)], &n!(1, 2), Some(x), Option<&'static u8>);\n+}"}, {"sha": "5444f8a9051bdae248ee4b09fb684ecc93f09053", "filename": "src/test/ui/array-slice-vec/subslice-patterns-const-eval.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -0,0 +1,97 @@\n+// Test that array subslice patterns are correctly handled in const evaluation.\n+\n+// run-pass\n+\n+#![feature(slice_patterns)]\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct N(u8);\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct Z;\n+\n+macro_rules! n {\n+    ($($e:expr),* $(,)?) => {\n+        [$(N($e)),*]\n+    }\n+}\n+\n+// This macro has an unused variable so that it can be repeated base on the\n+// number of times a repeated variable (`$e` in `z`) occurs.\n+macro_rules! zed {\n+    ($e:expr) => { Z }\n+}\n+\n+macro_rules! z {\n+    ($($e:expr),* $(,)?) => {\n+        [$(zed!($e)),*]\n+    }\n+}\n+\n+// Compare constant evaluation and runtime evaluation of a given expression.\n+macro_rules! compare_evaluation {\n+    ($e:expr, $t:ty $(,)?) => {{\n+        const CONST_EVAL: $t = $e;\n+        const fn const_eval() -> $t { $e }\n+        static CONST_EVAL2: $t = const_eval();\n+        let runtime_eval = $e;\n+        assert_eq!(CONST_EVAL, runtime_eval);\n+        assert_eq!(CONST_EVAL2, runtime_eval);\n+    }}\n+}\n+\n+// Repeat `$test`, substituting the given macro variables with the given\n+// identifiers.\n+//\n+// For example:\n+//\n+// repeat! {\n+//     ($name); X; Y:\n+//     struct $name;\n+// }\n+//\n+// Expands to:\n+//\n+// struct X; struct Y;\n+//\n+// This is used to repeat the tests using both the `N` and `Z`\n+// types.\n+macro_rules! repeat {\n+    (($($dollar:tt $placeholder:ident)*); $($($values:ident),+);*: $($test:tt)*) => {\n+        macro_rules! single {\n+            ($($dollar $placeholder:ident),*) => { $($test)* }\n+        }\n+        $(single!($($values),+);)*\n+    }\n+}\n+\n+fn main() {\n+    repeat! {\n+        ($arr $Ty); n, N; z, Z:\n+        compare_evaluation!({ let [_, x @ .., _] = $arr!(1, 2, 3, 4); x }, [$Ty; 2]);\n+        compare_evaluation!({ let [_, ref x @ .., _] = $arr!(1, 2, 3, 4); x }, &'static [$Ty; 2]);\n+        compare_evaluation!({ let [_, x @ .., _] = &$arr!(1, 2, 3, 4); x }, &'static [$Ty; 2]);\n+\n+        compare_evaluation!({ let [_, _, x @ .., _, _] = $arr!(1, 2, 3, 4); x }, [$Ty; 0]);\n+        compare_evaluation!(\n+            { let [_, _, ref x @ .., _, _] = $arr!(1, 2, 3, 4); x },\n+            &'static [$Ty; 0],\n+        );\n+        compare_evaluation!(\n+            { let [_, _, x @ .., _, _] = &$arr!(1, 2, 3, 4); x },\n+            &'static [$Ty; 0],\n+        );\n+\n+        compare_evaluation!({ let [_, .., x] = $arr!(1, 2, 3, 4); x }, $Ty);\n+        compare_evaluation!({ let [_, .., ref x] = $arr!(1, 2, 3, 4); x }, &'static $Ty);\n+        compare_evaluation!({ let [_, _y @ .., x] = &$arr!(1, 2, 3, 4); x }, &'static $Ty);\n+    }\n+\n+    compare_evaluation!({ let [_, .., N(x)] = n!(1, 2, 3, 4); x }, u8);\n+    compare_evaluation!({ let [_, .., N(ref x)] = n!(1, 2, 3, 4); x }, &'static u8);\n+    compare_evaluation!({ let [_, .., N(x)] = &n!(1, 2, 3, 4); x }, &'static u8);\n+\n+    compare_evaluation!({ let [N(x), .., _] = n!(1, 2, 3, 4); x }, u8);\n+    compare_evaluation!({ let [N(ref x), .., _] = n!(1, 2, 3, 4); x }, &'static u8);\n+    compare_evaluation!({ let [N(x), .., _] = &n!(1, 2, 3, 4); x }, &'static u8);\n+}"}, {"sha": "a70ccb7aa4b73ccd51c7f5cbee83a09a70ac9eb0", "filename": "src/test/ui/borrowck/borrowck-closures-slice-patterns-ok.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns-ok.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -0,0 +1,118 @@\n+// Check that closure captures for slice patterns are inferred correctly\n+\n+#![feature(slice_patterns)]\n+#![allow(unused_variables)]\n+\n+// run-pass\n+\n+fn arr_by_ref(x: [String; 3]) {\n+    let r = &x;\n+    let f = || {\n+        let [ref y, ref z @ ..] = x;\n+    };\n+    f();\n+    f();\n+    // Ensure `x` was borrowed\n+    drop(r);\n+    // Ensure that `x` wasn't moved from.\n+    drop(x);\n+}\n+\n+fn arr_by_mut(mut x: [String; 3]) {\n+    let mut f = || {\n+        let [ref mut y, ref mut z @ ..] = x;\n+    };\n+    f();\n+    f();\n+    drop(x);\n+}\n+\n+fn arr_by_move(x: [String; 3]) {\n+    let f = || {\n+        let [y, z @ ..] = x;\n+    };\n+    f();\n+}\n+\n+fn arr_ref_by_ref(x: &[String; 3]) {\n+    let r = &x;\n+    let f = || {\n+        let [ref y, ref z @ ..] = *x;\n+    };\n+    let g = || {\n+        let [y, z @ ..] = x;\n+    };\n+    f();\n+    g();\n+    f();\n+    g();\n+    drop(r);\n+    drop(x);\n+}\n+\n+fn arr_ref_by_mut(x: &mut [String; 3]) {\n+    let mut f = || {\n+        let [ref mut y, ref mut z @ ..] = *x;\n+    };\n+    f();\n+    f();\n+    let mut g = || {\n+        let [y, z @ ..] = x;\n+        // Ensure binding mode was chosen correctly:\n+        std::mem::swap(y, &mut z[0]);\n+    };\n+    g();\n+    g();\n+    drop(x);\n+}\n+\n+fn arr_box_by_move(x: Box<[String; 3]>) {\n+    let f = || {\n+        let [y, z @ ..] = *x;\n+    };\n+    f();\n+}\n+\n+fn slice_by_ref(x: &[String]) {\n+    let r = &x;\n+    let f = || {\n+        if let [ref y, ref z @ ..] = *x {}\n+    };\n+    let g = || {\n+        if let [y, z @ ..] = x {}\n+    };\n+    f();\n+    g();\n+    f();\n+    g();\n+    drop(r);\n+    drop(x);\n+}\n+\n+fn slice_by_mut(x: &mut [String]) {\n+    let mut f = || {\n+        if let [ref mut y, ref mut z @ ..] = *x {}\n+    };\n+    f();\n+    f();\n+    let mut g = || {\n+        if let [y, z @ ..] = x {\n+            // Ensure binding mode was chosen correctly:\n+            std::mem::swap(y, &mut z[0]);\n+        }\n+    };\n+    g();\n+    g();\n+    drop(x);\n+}\n+\n+fn main() {\n+    arr_by_ref(Default::default());\n+    arr_by_mut(Default::default());\n+    arr_by_move(Default::default());\n+    arr_ref_by_ref(&Default::default());\n+    arr_ref_by_mut(&mut Default::default());\n+    arr_box_by_move(Default::default());\n+    slice_by_ref(&<[_; 3]>::default());\n+    slice_by_mut(&mut <[_; 3]>::default());\n+}"}, {"sha": "984eb8804b7a2ea7be683182b4fc62e25c070ba4", "filename": "src/test/ui/borrowck/borrowck-closures-slice-patterns.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -0,0 +1,84 @@\n+// Check that closure captures for slice patterns are inferred correctly\n+\n+#![feature(slice_patterns)]\n+\n+fn arr_by_ref(mut x: [String; 3]) {\n+    let f = || {\n+        let [ref y, ref z @ ..] = x;\n+    };\n+    let r = &mut x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn arr_by_mut(mut x: [String; 3]) {\n+    let mut f = || {\n+        let [ref mut y, ref mut z @ ..] = x;\n+    };\n+    let r = &x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn arr_by_move(x: [String; 3]) {\n+    let f = || {\n+        let [y, z @ ..] = x;\n+    };\n+    &x;\n+    //~^ ERROR borrow of moved value\n+}\n+\n+fn arr_ref_by_ref(x: &mut [String; 3]) {\n+    let f = || {\n+        let [ref y, ref z @ ..] = *x;\n+    };\n+    let r = &mut *x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn arr_ref_by_uniq(x: &mut [String; 3]) {\n+    let mut f = || {\n+        let [ref mut y, ref mut z @ ..] = *x;\n+    };\n+    let r = &x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn arr_box_by_move(x: Box<[String; 3]>) {\n+    let f = || {\n+        let [y, z @ ..] = *x;\n+    };\n+    &x;\n+    //~^ ERROR borrow of moved value\n+}\n+\n+fn slice_by_ref(x: &mut [String]) {\n+    let f = || {\n+        if let [ref y, ref z @ ..] = *x {}\n+    };\n+    let r = &mut *x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn slice_by_uniq(x: &mut [String]) {\n+    let mut f = || {\n+        if let [ref mut y, ref mut z @ ..] = *x {}\n+    };\n+    let r = &x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn main() {\n+    arr_by_ref(Default::default());\n+    arr_by_mut(Default::default());\n+    arr_by_move(Default::default());\n+    arr_ref_by_ref(&mut Default::default());\n+    arr_ref_by_uniq(&mut Default::default());\n+    arr_box_by_move(Default::default());\n+    slice_by_ref(&mut <[_; 3]>::default());\n+    slice_by_uniq(&mut <[_; 3]>::default());\n+}"}, {"sha": "c5b27f5f8b4032d34ae46e4f041d5f4f67c0ad77", "filename": "src/test/ui/borrowck/borrowck-closures-slice-patterns.stderr", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.stderr?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -0,0 +1,114 @@\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-closures-slice-patterns.rs:9:13\n+   |\n+LL |     let f = || {\n+   |             -- immutable borrow occurs here\n+LL |         let [ref y, ref z @ ..] = x;\n+   |                                   - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &mut x;\n+   |             ^^^^^^ mutable borrow occurs here\n+LL |\n+LL |     f();\n+   |     - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-closures-slice-patterns.rs:18:13\n+   |\n+LL |     let mut f = || {\n+   |                 -- mutable borrow occurs here\n+LL |         let [ref mut y, ref mut z @ ..] = x;\n+   |                                           - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &x;\n+   |             ^^ immutable borrow occurs here\n+LL |\n+LL |     f();\n+   |     - mutable borrow later used here\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/borrowck-closures-slice-patterns.rs:27:5\n+   |\n+LL | fn arr_by_move(x: [String; 3]) {\n+   |                - move occurs because `x` has type `[std::string::String; 3]`, which does not implement the `Copy` trait\n+LL |     let f = || {\n+   |             -- value moved into closure here\n+LL |         let [y, z @ ..] = x;\n+   |                           - variable moved due to use in closure\n+LL |     };\n+LL |     &x;\n+   |     ^^ value borrowed here after move\n+\n+error[E0502]: cannot borrow `*x` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-closures-slice-patterns.rs:35:13\n+   |\n+LL |     let f = || {\n+   |             -- immutable borrow occurs here\n+LL |         let [ref y, ref z @ ..] = *x;\n+   |                                    - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &mut *x;\n+   |             ^^^^^^^ mutable borrow occurs here\n+LL |\n+LL |     f();\n+   |     - immutable borrow later used here\n+\n+error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n+  --> $DIR/borrowck-closures-slice-patterns.rs:44:13\n+   |\n+LL |     let mut f = || {\n+   |                 -- closure construction occurs here\n+LL |         let [ref mut y, ref mut z @ ..] = *x;\n+   |                                            - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &x;\n+   |             ^^ second borrow occurs here\n+LL |\n+LL |     f();\n+   |     - first borrow later used here\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/borrowck-closures-slice-patterns.rs:53:5\n+   |\n+LL | fn arr_box_by_move(x: Box<[String; 3]>) {\n+   |                    - move occurs because `x` has type `std::boxed::Box<[std::string::String; 3]>`, which does not implement the `Copy` trait\n+LL |     let f = || {\n+   |             -- value moved into closure here\n+LL |         let [y, z @ ..] = *x;\n+   |                            - variable moved due to use in closure\n+LL |     };\n+LL |     &x;\n+   |     ^^ value borrowed here after move\n+\n+error[E0502]: cannot borrow `*x` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-closures-slice-patterns.rs:61:13\n+   |\n+LL |     let f = || {\n+   |             -- immutable borrow occurs here\n+LL |         if let [ref y, ref z @ ..] = *x {}\n+   |                                       - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &mut *x;\n+   |             ^^^^^^^ mutable borrow occurs here\n+LL |\n+LL |     f();\n+   |     - immutable borrow later used here\n+\n+error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n+  --> $DIR/borrowck-closures-slice-patterns.rs:70:13\n+   |\n+LL |     let mut f = || {\n+   |                 -- closure construction occurs here\n+LL |         if let [ref mut y, ref mut z @ ..] = *x {}\n+   |                                               - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &x;\n+   |             ^^ second borrow occurs here\n+LL |\n+LL |     f();\n+   |     - first borrow later used here\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0382, E0501, E0502.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "2934217df346e06057d94d5d723ae2a6f1a95ead", "filename": "src/test/ui/dropck/dropck_fn_type.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fdropck%2Fdropck_fn_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fdropck%2Fdropck_fn_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck_fn_type.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -0,0 +1,20 @@\n+// run-pass\n+//! Regression test for #58311, regarding the usage of Fn types in drop impls\n+\n+// All of this Drop impls should compile.\n+\n+#[allow(dead_code)]\n+struct S<F: Fn() -> [u8; 1]>(F);\n+\n+impl<F: Fn() -> [u8; 1]> Drop for S<F> {\n+    fn drop(&mut self) {}\n+}\n+\n+#[allow(dead_code)]\n+struct P<A, F: FnOnce() -> [A; 10]>(F);\n+\n+impl<A, F: FnOnce() -> [A; 10]> Drop for P<A, F> {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "98e8e88a2599553e6c94a5e8d9ba1bce423ccba0", "filename": "src/test/ui/dropck/dropck_traits.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fdropck%2Fdropck_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fdropck%2Fdropck_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck_traits.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -0,0 +1,68 @@\n+// run-pass\n+//! Regression test for #34426, regarding HRTB in drop impls\n+\n+// All of this Drop impls should compile.\n+\n+pub trait Lifetime<'a> {}\n+impl<'a> Lifetime<'a> for i32 {}\n+\n+#[allow(dead_code)]\n+struct Foo<L>\n+where\n+    for<'a> L: Lifetime<'a>,\n+{\n+    l: L,\n+}\n+\n+impl<L> Drop for Foo<L>\n+where\n+    for<'a> L: Lifetime<'a>,\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[allow(dead_code)]\n+struct Foo2<L>\n+where\n+    for<'a> L: Lifetime<'a>,\n+{\n+    l: L,\n+}\n+\n+impl<T: for<'a> Lifetime<'a>> Drop for Foo2<T>\n+where\n+    for<'x> T: Lifetime<'x>,\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+pub trait Lifetime2<'a, 'b> {}\n+impl<'a, 'b> Lifetime2<'a, 'b> for i32 {}\n+\n+#[allow(dead_code)]\n+struct Bar<L>\n+where\n+    for<'a, 'b> L: Lifetime2<'a, 'b>,\n+{\n+    l: L,\n+}\n+\n+impl<L> Drop for Bar<L>\n+where\n+    for<'a, 'b> L: Lifetime2<'a, 'b>,\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[allow(dead_code)]\n+struct FnHolder<T: for<'a> Fn(&'a T, dyn for<'b> Lifetime2<'a, 'b>) -> u8>(T);\n+\n+impl<T: for<'a> Fn(&'a T, dyn for<'b> Lifetime2<'a, 'b>) -> u8> Drop for FnHolder<T> {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {\n+    let _foo = Foo { l: 0 };\n+\n+    let _bar = Bar { l: 0 };\n+}"}, {"sha": "4ca60ddfec27c7c941c3eaa066f7be226cf3e85d", "filename": "src/test/ui/moves/move-out-of-array-ref.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -0,0 +1,36 @@\n+// Ensure that we cannot move out of a reference to a fixed-size array\n+\n+#![feature(slice_patterns)]\n+\n+struct D { _x: u8 }\n+\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+fn move_elem(a: &[D; 4]) -> D {\n+    let [_, e, _, _] = *a;              //~ ERROR cannot move\n+    e\n+}\n+\n+fn move_subarr(a: &[D; 4]) -> [D; 2] {\n+    let [_, s @ .. , _] = *a;           //~ ERROR cannot move\n+    s\n+}\n+\n+fn move_elem_mut(a: &mut [D; 4]) -> D {\n+    let [_, e, _, _] = *a;              //~ ERROR cannot move\n+    e\n+}\n+\n+fn move_subarr_mut(a: &mut [D; 4]) -> [D; 2] {\n+    let [_, s @ .. , _] = *a;           //~ ERROR cannot move\n+    s\n+}\n+\n+fn main() {\n+    fn d() -> D { D { _x: 0 } }\n+\n+    move_elem(&[d(), d(), d(), d()]);\n+    move_subarr(&[d(), d(), d(), d()]);\n+    move_elem_mut(&mut [d(), d(), d(), d()]);\n+    move_subarr_mut(&mut [d(), d(), d(), d()]);\n+}"}, {"sha": "ae3d2f5f2826ac6fed5642bca720cdeb5dbf1c59", "filename": "src/test/ui/moves/move-out-of-array-ref.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -0,0 +1,47 @@\n+error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n+  --> $DIR/move-out-of-array-ref.rs:10:24\n+   |\n+LL |     let [_, e, _, _] = *a;\n+   |             -          ^^\n+   |             |          |\n+   |             |          cannot move out of here\n+   |             |          help: consider borrowing here: `&*a`\n+   |             data moved here\n+   |             move occurs because `e` has type `D`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n+  --> $DIR/move-out-of-array-ref.rs:15:27\n+   |\n+LL |     let [_, s @ .. , _] = *a;\n+   |             ------        ^^\n+   |             |             |\n+   |             |             cannot move out of here\n+   |             |             help: consider borrowing here: `&*a`\n+   |             data moved here\n+   |             move occurs because `s` has type `[D; 2]`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n+  --> $DIR/move-out-of-array-ref.rs:20:24\n+   |\n+LL |     let [_, e, _, _] = *a;\n+   |             -          ^^\n+   |             |          |\n+   |             |          cannot move out of here\n+   |             |          help: consider borrowing here: `&*a`\n+   |             data moved here\n+   |             move occurs because `e` has type `D`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n+  --> $DIR/move-out-of-array-ref.rs:25:27\n+   |\n+LL |     let [_, s @ .. , _] = *a;\n+   |             ------        ^^\n+   |             |             |\n+   |             |             cannot move out of here\n+   |             |             help: consider borrowing here: `&*a`\n+   |             data moved here\n+   |             move occurs because `s` has type `[D; 2]`, which does not implement the `Copy` trait\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0508`."}, {"sha": "e460246193e5b88d58e46a4c514cf0294f10b649", "filename": "src/test/ui/moves/move-out-of-slice-2.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -0,0 +1,34 @@\n+#![feature(slice_patterns, unsized_locals)]\n+\n+struct A;\n+#[derive(Clone, Copy)]\n+struct C;\n+\n+fn main() {\n+    let a: Box<[A]> = Box::new([A]);\n+    match *a {\n+        //~^ ERROR cannot move out of type `[A]`, a non-copy slice\n+        [a @ ..] => {},\n+        _ => {}\n+    }\n+    let b: Box<[A]> = Box::new([A, A, A]);\n+    match *b {\n+        //~^ ERROR cannot move out of type `[A]`, a non-copy slice\n+        [_, _, b @ .., _] => {},\n+        _ => {}\n+    }\n+\n+    // `[C]` isn't `Copy`, even if `C` is.\n+    let c: Box<[C]> = Box::new([C]);\n+    match *c {\n+        //~^ ERROR cannot move out of type `[C]`, a non-copy slice\n+        [c @ ..] => {},\n+        _ => {}\n+    }\n+    let d: Box<[C]> = Box::new([C, C, C]);\n+    match *d {\n+        //~^ ERROR cannot move out of type `[C]`, a non-copy slice\n+        [_, _, d @ .., _] => {},\n+        _ => {}\n+    }\n+}"}, {"sha": "058f34b24a3b62ab2627973bbc4f7c519f6cad05", "filename": "src/test/ui/moves/move-out-of-slice-2.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a440b159436ad3c75d25b24ce5d43086b567872/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr?ref=0a440b159436ad3c75d25b24ce5d43086b567872", "patch": "@@ -0,0 +1,51 @@\n+error[E0508]: cannot move out of type `[A]`, a non-copy slice\n+  --> $DIR/move-out-of-slice-2.rs:9:11\n+   |\n+LL |     match *a {\n+   |           ^^ cannot move out of here\n+LL |\n+LL |         [a @ ..] => {},\n+   |          ------\n+   |          |\n+   |          data moved here\n+   |          move occurs because `a` has type `[A]`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[A]`, a non-copy slice\n+  --> $DIR/move-out-of-slice-2.rs:15:11\n+   |\n+LL |     match *b {\n+   |           ^^ cannot move out of here\n+LL |\n+LL |         [_, _, b @ .., _] => {},\n+   |                ------\n+   |                |\n+   |                data moved here\n+   |                move occurs because `b` has type `[A]`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[C]`, a non-copy slice\n+  --> $DIR/move-out-of-slice-2.rs:23:11\n+   |\n+LL |     match *c {\n+   |           ^^ cannot move out of here\n+LL |\n+LL |         [c @ ..] => {},\n+   |          ------\n+   |          |\n+   |          data moved here\n+   |          move occurs because `c` has type `[C]`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[C]`, a non-copy slice\n+  --> $DIR/move-out-of-slice-2.rs:29:11\n+   |\n+LL |     match *d {\n+   |           ^^ cannot move out of here\n+LL |\n+LL |         [_, _, d @ .., _] => {},\n+   |                ------\n+   |                |\n+   |                data moved here\n+   |                move occurs because `d` has type `[C]`, which does not implement the `Copy` trait\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0508`."}]}