{"sha": "836c31742687ba4e2f857b5b698e1e9e6b67619c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNmMzMTc0MjY4N2JhNGUyZjg1N2I1YjY5OGUxZTllNmI2NzYxOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-03T06:27:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-03T06:27:03Z"}, "message": "Auto merge of #83774 - richkadel:zero-based-counters, r=tmandry\n\nTranslate counters from Rust 1-based to LLVM 0-based counter ids\n\nA colleague contacted me and asked why Rust's counters start at 1, when\nClangs appear to start at 0. There is a reason why Rust's internal\ncounters start at 1 (see the docs), and I tried to keep them consistent\nwhen codegenned to LLVM's coverage mapping format. LLVM should be\ntolerant of missing counters, but as my colleague pointed out,\n`llvm-cov` will silently fail to generate a coverage report for a\nfunction based on LLVM's assumption that the counters are 0-based.\n\nSee:\nhttps://github.com/llvm/llvm-project/blob/main/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp#L170\n\nApparently, if, for example, a function has no branches, it would have\nexactly 1 counter. `CounterValues.size()` would be 1, and (with the\n1-based index), the counter ID would be 1. This would fail the check\nand abort reporting coverage for the function.\n\nIt turns out that by correcting for this during coverage map generation,\nby subtracting 1 from the Rust Counter ID (both when generating the\ncounter increment intrinsic call, and when adding counters to the map),\nsome uncovered functions (including in tests) now appear covered! This\ncorrects the coverage for a few tests!\n\nr? `@tmandry`\nFYI: `@wesleywiser`", "tree": {"sha": "29f52f27b9fea22a5b870177880d37e76e333e05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29f52f27b9fea22a5b870177880d37e76e333e05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/836c31742687ba4e2f857b5b698e1e9e6b67619c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/836c31742687ba4e2f857b5b698e1e9e6b67619c", "html_url": "https://github.com/rust-lang/rust/commit/836c31742687ba4e2f857b5b698e1e9e6b67619c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/836c31742687ba4e2f857b5b698e1e9e6b67619c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb1713640532ca829479554459406e152213e95c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb1713640532ca829479554459406e152213e95c", "html_url": "https://github.com/rust-lang/rust/commit/cb1713640532ca829479554459406e152213e95c"}, {"sha": "7ceff6835abc3ce991e1a8cdcbe2be2730335a65", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ceff6835abc3ce991e1a8cdcbe2be2730335a65", "html_url": "https://github.com/rust-lang/rust/commit/7ceff6835abc3ce991e1a8cdcbe2be2730335a65"}], "stats": {"total": 308, "additions": 212, "deletions": 96}, "files": [{"sha": "afc2bdbfd52ecf5e81a1ebf91ad2b5a35b81ebb5", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/836c31742687ba4e2f857b5b698e1e9e6b67619c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/836c31742687ba4e2f857b5b698e1e9e6b67619c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=836c31742687ba4e2f857b5b698e1e9e6b67619c", "patch": "@@ -250,13 +250,9 @@ fn add_unused_function_coverage(\n             // Insert at least one real counter so the LLVM CoverageMappingReader will find expected\n             // definitions.\n             function_coverage.add_counter(UNUSED_FUNCTION_COUNTER_ID, code_region.clone());\n+        } else {\n+            function_coverage.add_unreachable_region(code_region.clone());\n         }\n-        // Add a Zero Counter for every code region.\n-        //\n-        // Even though the first coverage region already has an actual Counter, `llvm-cov` will not\n-        // always report it. Re-adding an unreachable region (zero counter) for the same region\n-        // seems to help produce the expected coverage.\n-        function_coverage.add_unreachable_region(code_region.clone());\n     }\n \n     if let Some(coverage_context) = cx.coverage_context() {"}, {"sha": "962c01c2ee7a6fd25cb9633523056319f21643ac", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/ffi.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/836c31742687ba4e2f857b5b698e1e9e6b67619c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/836c31742687ba4e2f857b5b698e1e9e6b67619c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs?ref=836c31742687ba4e2f857b5b698e1e9e6b67619c", "patch": "@@ -24,21 +24,39 @@ pub enum CounterKind {\n pub struct Counter {\n     // Important: The layout (order and types of fields) must match its C++ counterpart.\n     pub kind: CounterKind,\n-    pub id: u32,\n+    id: u32,\n }\n \n impl Counter {\n+    /// Constructs a new `Counter` of kind `Zero`. For this `CounterKind`, the\n+    /// `id` is not used.\n     pub fn zero() -> Self {\n         Self { kind: CounterKind::Zero, id: 0 }\n     }\n \n+    /// Constructs a new `Counter` of kind `CounterValueReference`, and converts\n+    /// the given 1-based counter_id to the required 0-based equivalent for\n+    /// the `Counter` encoding.\n     pub fn counter_value_reference(counter_id: CounterValueReference) -> Self {\n-        Self { kind: CounterKind::CounterValueReference, id: counter_id.into() }\n+        Self { kind: CounterKind::CounterValueReference, id: counter_id.zero_based_index() }\n     }\n \n+    /// Constructs a new `Counter` of kind `Expression`.\n     pub fn expression(mapped_expression_index: MappedExpressionIndex) -> Self {\n         Self { kind: CounterKind::Expression, id: mapped_expression_index.into() }\n     }\n+\n+    /// Returns true if the `Counter` kind is `Zero`.\n+    pub fn is_zero(&self) -> bool {\n+        matches!(self.kind, CounterKind::Zero)\n+    }\n+\n+    /// An explicitly-named function to get the ID value, making it more obvious\n+    /// that the stored value is now 0-based.\n+    pub fn zero_based_id(&self) -> u32 {\n+        debug_assert!(!self.is_zero(), \"`id` is undefined for CounterKind::Zero\");\n+        self.id\n+    }\n }\n \n /// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147)"}, {"sha": "4458fd686788f3857315da62dc20e015dda11d67", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/836c31742687ba4e2f857b5b698e1e9e6b67619c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/836c31742687ba4e2f857b5b698e1e9e6b67619c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=836c31742687ba4e2f857b5b698e1e9e6b67619c", "patch": "@@ -163,9 +163,7 @@ impl<'tcx> FunctionCoverage<'tcx> {\n         self.counters.iter_enumerated().filter_map(|(index, entry)| {\n             // Option::map() will return None to filter out missing counters. This may happen\n             // if, for example, a MIR-instrumented counter is removed during an optimization.\n-            entry.as_ref().map(|region| {\n-                (Counter::counter_value_reference(index as CounterValueReference), region)\n-            })\n+            entry.as_ref().map(|region| (Counter::counter_value_reference(index), region))\n         })\n     }\n \n@@ -206,9 +204,15 @@ impl<'tcx> FunctionCoverage<'tcx> {\n             if id == ExpressionOperandId::ZERO {\n                 Some(Counter::zero())\n             } else if id.index() < self.counters.len() {\n+                debug_assert!(\n+                    id.index() > 0,\n+                    \"ExpressionOperandId indexes for counters are 1-based, but this id={}\",\n+                    id.index()\n+                );\n                 // Note: Some codegen-injected Counters may be only referenced by `Expression`s,\n                 // and may not have their own `CodeRegion`s,\n                 let index = CounterValueReference::from(id.index());\n+                // Note, the conversion to LLVM `Counter` adjusts the index to be zero-based.\n                 Some(Counter::counter_value_reference(index))\n             } else {\n                 let index = self.expression_index(u32::from(id));\n@@ -233,19 +237,60 @@ impl<'tcx> FunctionCoverage<'tcx> {\n             let optional_region = &expression.region;\n             let Expression { lhs, op, rhs, .. } = *expression;\n \n-            if let Some(Some((lhs_counter, rhs_counter))) =\n-                id_to_counter(&new_indexes, lhs).map(|lhs_counter| {\n+            if let Some(Some((lhs_counter, mut rhs_counter))) = id_to_counter(&new_indexes, lhs)\n+                .map(|lhs_counter| {\n                     id_to_counter(&new_indexes, rhs).map(|rhs_counter| (lhs_counter, rhs_counter))\n                 })\n             {\n+                if lhs_counter.is_zero() && op.is_subtract() {\n+                    // The left side of a subtraction was probably optimized out. As an example,\n+                    // a branch condition might be evaluated as a constant expression, and the\n+                    // branch could be removed, dropping unused counters in the process.\n+                    //\n+                    // Since counters are unsigned, we must assume the result of the expression\n+                    // can be no more and no less than zero. An expression known to evaluate to zero\n+                    // does not need to be added to the coverage map.\n+                    //\n+                    // Coverage test `loops_branches.rs` includes multiple variations of branches\n+                    // based on constant conditional (literal `true` or `false`), and demonstrates\n+                    // that the expected counts are still correct.\n+                    debug!(\n+                        \"Expression subtracts from zero (assume unreachable): \\\n+                        original_index={:?}, lhs={:?}, op={:?}, rhs={:?}, region={:?}\",\n+                        original_index, lhs, op, rhs, optional_region,\n+                    );\n+                    rhs_counter = Counter::zero();\n+                }\n                 debug_assert!(\n-                    (lhs_counter.id as usize)\n-                        < usize::max(self.counters.len(), self.expressions.len())\n+                    lhs_counter.is_zero()\n+                        // Note: with `as usize` the ID _could_ overflow/wrap if `usize = u16`\n+                        || ((lhs_counter.zero_based_id() as usize)\n+                            <= usize::max(self.counters.len(), self.expressions.len())),\n+                    \"lhs id={} > both counters.len()={} and expressions.len()={}\n+                    ({:?} {:?} {:?})\",\n+                    lhs_counter.zero_based_id(),\n+                    self.counters.len(),\n+                    self.expressions.len(),\n+                    lhs_counter,\n+                    op,\n+                    rhs_counter,\n                 );\n+\n                 debug_assert!(\n-                    (rhs_counter.id as usize)\n-                        < usize::max(self.counters.len(), self.expressions.len())\n+                    rhs_counter.is_zero()\n+                        // Note: with `as usize` the ID _could_ overflow/wrap if `usize = u16`\n+                        || ((rhs_counter.zero_based_id() as usize)\n+                            <= usize::max(self.counters.len(), self.expressions.len())),\n+                    \"rhs id={} > both counters.len()={} and expressions.len()={}\n+                    ({:?} {:?} {:?})\",\n+                    rhs_counter.zero_based_id(),\n+                    self.counters.len(),\n+                    self.expressions.len(),\n+                    lhs_counter,\n+                    op,\n+                    rhs_counter,\n                 );\n+\n                 // Both operands exist. `Expression` operands exist in `self.expressions` and have\n                 // been assigned a `new_index`.\n                 let mapped_expression_index =\n@@ -268,11 +313,15 @@ impl<'tcx> FunctionCoverage<'tcx> {\n                     expression_regions.push((Counter::expression(mapped_expression_index), region));\n                 }\n             } else {\n-                debug!(\n-                    \"Ignoring expression with one or more missing operands: \\\n-                    original_index={:?}, lhs={:?}, op={:?}, rhs={:?}, region={:?}\",\n-                    original_index, lhs, op, rhs, optional_region,\n-                )\n+                bug!(\n+                    \"expression has one or more missing operands \\\n+                      original_index={:?}, lhs={:?}, op={:?}, rhs={:?}, region={:?}\",\n+                    original_index,\n+                    lhs,\n+                    op,\n+                    rhs,\n+                    optional_region,\n+                );\n             }\n         }\n         (counter_expressions, expression_regions.into_iter())"}, {"sha": "621ec0519c956fd5af19f145524b5c0527b99cda", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/836c31742687ba4e2f857b5b698e1e9e6b67619c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/836c31742687ba4e2f857b5b698e1e9e6b67619c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=836c31742687ba4e2f857b5b698e1e9e6b67619c", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     let fn_name = bx.get_pgo_func_name_var(instance);\n                     let hash = bx.const_u64(function_source_hash);\n                     let num_counters = bx.const_u32(coverageinfo.num_counters);\n-                    let index = bx.const_u32(u32::from(id));\n+                    let index = bx.const_u32(id.zero_based_index());\n                     debug!(\n                         \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n                         fn_name, hash, num_counters, index,"}, {"sha": "ddb1a84fe7bdffbd368cf8028572c4916a27f704", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/836c31742687ba4e2f857b5b698e1e9e6b67619c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/836c31742687ba4e2f857b5b698e1e9e6b67619c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=836c31742687ba4e2f857b5b698e1e9e6b67619c", "patch": "@@ -41,8 +41,16 @@ rustc_index::newtype_index! {\n }\n \n impl CounterValueReference {\n-    // Counters start at 1 to reserve 0 for ExpressionOperandId::ZERO.\n+    /// Counters start at 1 to reserve 0 for ExpressionOperandId::ZERO.\n     pub const START: Self = Self::from_u32(1);\n+\n+    /// Returns explicitly-requested zero-based version of the counter id, used\n+    /// during codegen. LLVM expects zero-based indexes.\n+    pub fn zero_based_index(&self) -> u32 {\n+        let one_based_index = self.as_u32();\n+        debug_assert!(one_based_index > 0);\n+        one_based_index - 1\n+    }\n }\n \n rustc_index::newtype_index! {\n@@ -175,3 +183,13 @@ pub enum Op {\n     Subtract,\n     Add,\n }\n+\n+impl Op {\n+    pub fn is_add(&self) -> bool {\n+        matches!(self, Self::Add)\n+    }\n+\n+    pub fn is_subtract(&self) -> bool {\n+        matches!(self, Self::Subtract)\n+    }\n+}"}, {"sha": "e0a5937c24686931a805b0ede3534b61469c2cc3", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.async.txt", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/836c31742687ba4e2f857b5b698e1e9e6b67619c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async.txt", "raw_url": "https://github.com/rust-lang/rust/raw/836c31742687ba4e2f857b5b698e1e9e6b67619c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async.txt?ref=836c31742687ba4e2f857b5b698e1e9e6b67619c", "patch": "@@ -10,7 +10,7 @@\n    10|       |    }\n    11|      1|}\n    12|       |\n-   13|       |async fn d() -> u8 { 1 } // should have a coverage count `0` (see below)\n+   13|      0|async fn d() -> u8 { 1 }\n    14|       |\n    15|      0|async fn e() -> u8 { 1 } // unused function; executor does not block on `g()`\n    16|       |\n@@ -66,7 +66,8 @@\n    63|      1|            0\n    64|      1|        }\n    65|      1|    }\n-   66|      1|    fn d() -> u8 { 1 }\n+   66|      1|    fn d() -> u8 { 1 } // inner function is defined in-line, but the function is not executed\n+                  ^0\n    67|      1|    fn f() -> u8 { 1 }\n    68|      1|    match x {\n    69|      1|        y if c(x) == y + 1 => { d(); }\n@@ -115,11 +116,14 @@\n   109|       |\n   110|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n   111|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n-  112|      1|\n+  112|      1|        use std::hint::unreachable_unchecked;\n   113|      1|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n-  114|      1|            |_| unimplemented!(\"clone\"),\n-  115|      1|            |_| unimplemented!(\"wake\"),\n-  116|      1|            |_| unimplemented!(\"wake_by_ref\"),\n+  114|      1|            |_| unsafe { unreachable_unchecked() }, // clone\n+                              ^0\n+  115|      1|            |_| unsafe { unreachable_unchecked() }, // wake\n+                              ^0\n+  116|      1|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+                              ^0\n   117|      1|            |_| (),\n   118|      1|        );\n   119|      1|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n@@ -132,15 +136,4 @@\n   126|       |        }\n   127|      1|    }\n   128|       |}\n-  129|       |\n-  130|       |// `llvm-cov show` shows no coverage results for the `d()`, even though the\n-  131|       |// crate's LLVM IR shows the function exists and has an InstrProf PGO counter,\n-  132|       |// and appears to be registered like all other counted functions.\n-  133|       |//\n-  134|       |// `llvm-cov show --debug` output shows there is at least one `Counter` for this\n-  135|       |// line, but counters do not appear in the `Combined regions` section (unlike\n-  136|       |// `f()`, which is similar, but does appear in `Combined regions`, and does show\n-  137|       |// coverage). The only difference is, `f()` is awaited, but the call to await\n-  138|       |// `d()` is not reached. (Note: `d()` will appear in coverage if the test is\n-  139|       |// modified to cause it to be awaited.)\n "}, {"sha": "1b6bb9ff8891de6c5ad657868580e8d31afe28ff", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.doctest.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/836c31742687ba4e2f857b5b698e1e9e6b67619c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.doctest.txt", "raw_url": "https://github.com/rust-lang/rust/raw/836c31742687ba4e2f857b5b698e1e9e6b67619c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.doctest.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.doctest.txt?ref=836c31742687ba4e2f857b5b698e1e9e6b67619c", "patch": "@@ -56,7 +56,7 @@\n    46|      1|//!     println!(\"called some_func()\");\n    47|      1|//! }\n    48|       |//!\n-   49|       |//! #[derive(Debug)]\n+   49|      0|//! #[derive(Debug)]\n    50|       |//! struct SomeError;\n    51|       |//!\n    52|       |//! extern crate doctest_crate;"}, {"sha": "31d3ddea8d95a7d7131a1f80e5ff8d1b212cbd89", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.inline.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/836c31742687ba4e2f857b5b698e1e9e6b67619c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline.txt", "raw_url": "https://github.com/rust-lang/rust/raw/836c31742687ba4e2f857b5b698e1e9e6b67619c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline.txt?ref=836c31742687ba4e2f857b5b698e1e9e6b67619c", "patch": "@@ -47,7 +47,7 @@\n    46|      6|}\n    47|       |\n    48|       |#[inline(always)]\n-   49|       |fn error() {\n-   50|       |    panic!(\"error\");\n-   51|       |}\n+   49|      0|fn error() {\n+   50|      0|    panic!(\"error\");\n+   51|      0|}\n "}, {"sha": "81d5c7d90346d08a397e577d120352dbe465f124", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.loops_branches.txt", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/836c31742687ba4e2f857b5b698e1e9e6b67619c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.loops_branches.txt", "raw_url": "https://github.com/rust-lang/rust/raw/836c31742687ba4e2f857b5b698e1e9e6b67619c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.loops_branches.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.loops_branches.txt?ref=836c31742687ba4e2f857b5b698e1e9e6b67619c", "patch": "@@ -1,7 +1,7 @@\n     1|       |#![allow(unused_assignments, unused_variables, while_true)]\n     2|       |\n-    3|       |// This test confirms an earlier problem was resolved, supporting the MIR graph generated by the\n-    4|       |// structure of this `fmt` function.\n+    3|       |// This test confirms that (1) unexecuted infinite loops are handled correctly by the\n+    4|       |// InstrumentCoverage MIR pass; and (2) Counter Expressions that subtract from zero can be dropped.\n     5|       |\n     6|       |struct DebugTest;\n     7|       |\n@@ -16,23 +16,51 @@\n                                             ^0\n    16|       |        } else {\n    17|       |        }\n-   18|      1|        Ok(())\n-   19|      1|    }\n-   20|       |}\n-   21|       |\n-   22|      1|fn main() {\n-   23|      1|    let debug_test = DebugTest;\n-   24|      1|    println!(\"{:?}\", debug_test);\n-   25|      1|}\n-   26|       |\n-   27|       |/*\n-   28|       |\n-   29|       |This is the error message generated, before the issue was fixed:\n-   30|       |\n-   31|       |error: internal compiler error: compiler/rustc_mir/src/transform/coverage/mod.rs:374:42:\n-   32|       |Error processing: DefId(0:6 ~ bug_incomplete_cov_graph_traversal_simplified[317d]::{impl#0}::fmt):\n-   33|       |Error { message: \"`TraverseCoverageGraphWithLoops` missed some `BasicCoverageBlock`s:\n-   34|       |[bcb6, bcb7, bcb9]\" }\n-   35|       |\n-   36|       |*/\n+   18|       |\n+   19|     10|        for i in 0..10 {\n+   20|     10|            if true {\n+   21|     10|                if false {\n+   22|       |                    while true {}\n+   23|     10|                }\n+   24|     10|                write!(f, \"error\")?;\n+                                                ^0\n+   25|       |            } else {\n+   26|       |            }\n+   27|       |        }\n+   28|      1|        Ok(())\n+   29|      1|    }\n+   30|       |}\n+   31|       |\n+   32|       |struct DisplayTest;\n+   33|       |\n+   34|       |impl std::fmt::Display for DisplayTest {\n+   35|      1|    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+   36|      1|        if false {\n+   37|       |        } else {\n+   38|      1|            if false {\n+   39|       |                while true {}\n+   40|      1|            }\n+   41|      1|            write!(f, \"error\")?;\n+                                            ^0\n+   42|       |        }\n+   43|     10|        for i in 0..10 {\n+   44|     10|            if false {\n+   45|       |            } else {\n+   46|     10|                if false {\n+   47|       |                    while true {}\n+   48|     10|                }\n+   49|     10|                write!(f, \"error\")?;\n+                                                ^0\n+   50|       |            }\n+   51|       |        }\n+   52|      1|        Ok(())\n+   53|      1|    }\n+   54|       |}\n+   55|       |\n+   56|      1|fn main() {\n+   57|      1|    let debug_test = DebugTest;\n+   58|      1|    println!(\"{:?}\", debug_test);\n+   59|      1|    let display_test = DisplayTest;\n+   60|      1|    println!(\"{}\", display_test);\n+   61|      1|}\n "}, {"sha": "67bf696d0729f13c0176f7f94ae5cd389b502138", "filename": "src/test/run-make-fulldeps/coverage/async.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/836c31742687ba4e2f857b5b698e1e9e6b67619c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/836c31742687ba4e2f857b5b698e1e9e6b67619c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync.rs?ref=836c31742687ba4e2f857b5b698e1e9e6b67619c", "patch": "@@ -10,7 +10,7 @@ async fn c(x: u8) -> u8 {\n     }\n }\n \n-async fn d() -> u8 { 1 } // should have a coverage count `0` (see below)\n+async fn d() -> u8 { 1 }\n \n async fn e() -> u8 { 1 } // unused function; executor does not block on `g()`\n \n@@ -63,7 +63,7 @@ fn j(x: u8) {\n             0\n         }\n     }\n-    fn d() -> u8 { 1 }\n+    fn d() -> u8 { 1 } // inner function is defined in-line, but the function is not executed\n     fn f() -> u8 { 1 }\n     match x {\n         y if c(x) == y + 1 => { d(); }\n@@ -109,11 +109,11 @@ mod executor {\n \n     pub fn block_on<F: Future>(mut future: F) -> F::Output {\n         let mut future = unsafe { Pin::new_unchecked(&mut future) };\n-\n+        use std::hint::unreachable_unchecked;\n         static VTABLE: RawWakerVTable = RawWakerVTable::new(\n-            |_| unimplemented!(\"clone\"),\n-            |_| unimplemented!(\"wake\"),\n-            |_| unimplemented!(\"wake_by_ref\"),\n+            |_| unsafe { unreachable_unchecked() }, // clone\n+            |_| unsafe { unreachable_unchecked() }, // wake\n+            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n             |_| (),\n         );\n         let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n@@ -126,14 +126,3 @@ mod executor {\n         }\n     }\n }\n-\n-// `llvm-cov show` shows no coverage results for the `d()`, even though the\n-// crate's LLVM IR shows the function exists and has an InstrProf PGO counter,\n-// and appears to be registered like all other counted functions.\n-//\n-// `llvm-cov show --debug` output shows there is at least one `Counter` for this\n-// line, but counters do not appear in the `Combined regions` section (unlike\n-// `f()`, which is similar, but does appear in `Combined regions`, and does show\n-// coverage). The only difference is, `f()` is awaited, but the call to await\n-// `d()` is not reached. (Note: `d()` will appear in coverage if the test is\n-// modified to cause it to be awaited.)"}, {"sha": "4d9bbad3367f6ef50c9d072327ab996ec5d62cb9", "filename": "src/test/run-make-fulldeps/coverage/loops_branches.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/836c31742687ba4e2f857b5b698e1e9e6b67619c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Floops_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/836c31742687ba4e2f857b5b698e1e9e6b67619c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Floops_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Floops_branches.rs?ref=836c31742687ba4e2f857b5b698e1e9e6b67619c", "patch": "@@ -1,7 +1,7 @@\n #![allow(unused_assignments, unused_variables, while_true)]\n \n-// This test confirms an earlier problem was resolved, supporting the MIR graph generated by the\n-// structure of this `fmt` function.\n+// This test confirms that (1) unexecuted infinite loops are handled correctly by the\n+// InstrumentCoverage MIR pass; and (2) Counter Expressions that subtract from zero can be dropped.\n \n struct DebugTest;\n \n@@ -15,22 +15,47 @@ impl std::fmt::Debug for DebugTest {\n             write!(f, \"error\")?;\n         } else {\n         }\n+\n+        for i in 0..10 {\n+            if true {\n+                if false {\n+                    while true {}\n+                }\n+                write!(f, \"error\")?;\n+            } else {\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+struct DisplayTest;\n+\n+impl std::fmt::Display for DisplayTest {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        if false {\n+        } else {\n+            if false {\n+                while true {}\n+            }\n+            write!(f, \"error\")?;\n+        }\n+        for i in 0..10 {\n+            if false {\n+            } else {\n+                if false {\n+                    while true {}\n+                }\n+                write!(f, \"error\")?;\n+            }\n+        }\n         Ok(())\n     }\n }\n \n fn main() {\n     let debug_test = DebugTest;\n     println!(\"{:?}\", debug_test);\n+    let display_test = DisplayTest;\n+    println!(\"{}\", display_test);\n }\n-\n-/*\n-\n-This is the error message generated, before the issue was fixed:\n-\n-error: internal compiler error: compiler/rustc_mir/src/transform/coverage/mod.rs:374:42:\n-Error processing: DefId(0:6 ~ bug_incomplete_cov_graph_traversal_simplified[317d]::{impl#0}::fmt):\n-Error { message: \"`TraverseCoverageGraphWithLoops` missed some `BasicCoverageBlock`s:\n-[bcb6, bcb7, bcb9]\" }\n-\n-*/"}]}