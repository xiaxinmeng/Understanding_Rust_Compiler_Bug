{"sha": "a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZDExNDk1ZjllNzBlZTI0NmFiNmE2MWRlYzhiZGM3NTFmYjE0MmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-25T12:59:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-25T12:59:04Z"}, "message": "Auto merge of #43700 - gaurikholkar:struct_lifetimes, r=nikomatsakis\n\nAdding E0623 for structs\n\nThis is a fix to #43275\n\nThe error message is\n```\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-both-are-structs.rs:15:12\n+   |\n+14 | fn foo(mut x: Vec<Ref>, y: Ref) {\n+   |                   ---      --- these structs are declared with different lifetimes...\n+15 |     x.push(y);\n+   |            ^ ...but data from `y` flows into `x` here\n+\n+error: aborting due to previous error\n```\n\nr? @nikomatsakis", "tree": {"sha": "6421e52337c0599438cae67f0f0bc0ad9bd6e298", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6421e52337c0599438cae67f0f0bc0ad9bd6e298"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "html_url": "https://github.com/rust-lang/rust/commit/a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba65645c78a87f1fa5c6d7132130bb3175fbe68b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba65645c78a87f1fa5c6d7132130bb3175fbe68b", "html_url": "https://github.com/rust-lang/rust/commit/ba65645c78a87f1fa5c6d7132130bb3175fbe68b"}, {"sha": "2cd13189ce328af88b61393cd567b6eb3db9ca2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cd13189ce328af88b61393cd567b6eb3db9ca2b", "html_url": "https://github.com/rust-lang/rust/commit/2cd13189ce328af88b61393cd567b6eb3db9ca2b"}], "stats": {"total": 828, "additions": 624, "deletions": 204}, "files": [{"sha": "c80ce3c96f1a98a3d44870719fd5edffcd028f4e", "filename": "src/librustc/infer/error_reporting/anon_anon_conflict.rs", "status": "modified", "additions": 171, "deletions": 69, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -27,65 +27,84 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     //    { x.push(y); }.\n     // The example gives\n     // fn foo(x: &mut Vec<&u8>, y: &u8) {\n-    //                    ---      --- these references must have the same lifetime\n+    //                    ---      --- these references are declared with different lifetimes...\n     //            x.push(y);\n-    //            ^ data from `y` flows into `x` here\n-    // It will later be extended to trait objects and structs.\n+    //            ^ ...but data from `y` flows into `x` here\n+    // It has been extended for the case of structs too.\n+    // Consider the example\n+    // struct Ref<'a> { x: &'a u32 }\n+    // fn foo(mut x: Vec<Ref>, y: Ref) {\n+    //                   ---      --- these structs are declared with different lifetimes...\n+    //               x.push(y);\n+    //               ^ ...but data from `y` flows into `x` here\n+    // }\n+    // It will later be extended to trait objects.\n     pub fn try_report_anon_anon_conflict(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-\n         let (span, sub, sup) = match *error {\n             ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n             _ => return false, // inapplicable\n         };\n \n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n-        let (ty1, ty2) = if self.is_suitable_anonymous_region(sup).is_some() &&\n-                            self.is_suitable_anonymous_region(sub).is_some() {\n-            if let (Some(anon_reg1), Some(anon_reg2)) =\n-                (self.is_suitable_anonymous_region(sup), self.is_suitable_anonymous_region(sub)) {\n-                let ((_, br1), (_, br2)) = (anon_reg1, anon_reg2);\n-                if self.find_anon_type(sup, &br1).is_some() &&\n-                   self.find_anon_type(sub, &br2).is_some() {\n-                    (self.find_anon_type(sup, &br1).unwrap(),\n-                     self.find_anon_type(sub, &br2).unwrap())\n-                } else {\n-                    return false;\n-                }\n-            } else {\n-                return false;\n-            }\n-        } else {\n-            return false; // inapplicable\n-        };\n+        let anon_reg_sup = or_false!(self.is_suitable_anonymous_region(sup));\n \n-        if let (Some(sup_arg), Some(sub_arg)) =\n+        let anon_reg_sub = or_false!(self.is_suitable_anonymous_region(sub));\n+        let scope_def_id_sup = anon_reg_sup.def_id;\n+        let bregion_sup = anon_reg_sup.boundregion;\n+        let scope_def_id_sub = anon_reg_sub.def_id;\n+        let bregion_sub = anon_reg_sub.boundregion;\n+\n+        let ty_sup = or_false!(self.find_anon_type(sup, &bregion_sup));\n+\n+        let ty_sub = or_false!(self.find_anon_type(sub, &bregion_sub));\n+\n+        let (main_label, label1, label2) = if let (Some(sup_arg), Some(sub_arg)) =\n             (self.find_arg_with_anonymous_region(sup, sup),\n              self.find_arg_with_anonymous_region(sub, sub)) {\n-            let ((anon_arg1, _, _, _), (anon_arg2, _, _, _)) = (sup_arg, sub_arg);\n \n-            let span_label_var1 = if let Some(simple_name) = anon_arg1.pat.simple_name() {\n-                format!(\" from `{}` \", simple_name)\n-            } else {\n-                format!(\" \")\n-            };\n+            let (anon_arg_sup, is_first_sup, anon_arg_sub, is_first_sub) =\n+                (sup_arg.arg, sup_arg.is_first, sub_arg.arg, sub_arg.is_first);\n+            if self.is_self_anon(is_first_sup, scope_def_id_sup) ||\n+               self.is_self_anon(is_first_sub, scope_def_id_sub) {\n+                return false;\n+            }\n \n-            let span_label_var2 = if let Some(simple_name) = anon_arg2.pat.simple_name() {\n-                format!(\" into `{}` \", simple_name)\n+            if self.is_return_type_anon(scope_def_id_sup, bregion_sup) ||\n+               self.is_return_type_anon(scope_def_id_sub, bregion_sub) {\n+                return false;\n+            }\n+\n+            if anon_arg_sup == anon_arg_sub {\n+                (format!(\"this type was declared with multiple lifetimes...\"),\n+                 format!(\" with one lifetime\"),\n+                 format!(\" into the other\"))\n             } else {\n-                format!(\" \")\n-            };\n-\n-            struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n-                .span_label(ty1.span,\n-                            format!(\"these references are not declared with the same lifetime...\"))\n-                .span_label(ty2.span, format!(\"\"))\n-                .span_label(span,\n-                            format!(\"...but data{}flows{}here\", span_label_var1, span_label_var2))\n-                .emit();\n+                let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n+                    format!(\" from `{}`\", simple_name)\n+                } else {\n+                    format!(\"\")\n+                };\n+\n+                let span_label_var2 = if let Some(simple_name) = anon_arg_sub.pat.simple_name() {\n+                    format!(\" into `{}`\", simple_name)\n+                } else {\n+                    format!(\"\")\n+                };\n+\n+                let span_label =\n+                    format!(\"these two types are declared with different lifetimes...\",);\n+\n+                (span_label, span_label_var1, span_label_var2)\n+            }\n         } else {\n             return false;\n-        }\n+        };\n \n+        struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n+            .span_label(ty_sup.span, main_label)\n+            .span_label(ty_sub.span, format!(\"\"))\n+            .span_label(span, format!(\"...but data{} flows{} here\", label1, label2))\n+            .emit();\n         return true;\n     }\n \n@@ -94,7 +113,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// contains the anonymous type.\n     ///\n     /// # Arguments\n-    ///\n     /// region - the anonymous region corresponding to the anon_anon conflict\n     /// br - the bound region corresponding to the above region which is of type `BrAnon(_)`\n     ///\n@@ -105,39 +123,56 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// ```\n     /// The function returns the nested type corresponding to the anonymous region\n     /// for e.g. `&u8` and Vec<`&u8`.\n-    fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n+    pub fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n         if let Some(anon_reg) = self.is_suitable_anonymous_region(region) {\n-            let (def_id, _) = anon_reg;\n+            let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let ret_ty = self.tcx.type_of(def_id);\n                 if let ty::TyFnDef(_, _) = ret_ty.sty {\n-                    if let hir_map::NodeItem(it) = self.tcx.hir.get(node_id) {\n-                        if let hir::ItemFn(ref fndecl, _, _, _, _, _) = it.node {\n-                            return fndecl\n-                                       .inputs\n-                                       .iter()\n-                                       .filter_map(|arg| {\n-                                let mut nested_visitor = FindNestedTypeVisitor {\n-                                    infcx: &self,\n-                                    hir_map: &self.tcx.hir,\n-                                    bound_region: *br,\n-                                    found_type: None,\n-                                };\n-                                nested_visitor.visit_ty(&**arg);\n-                                if nested_visitor.found_type.is_some() {\n-                                    nested_visitor.found_type\n-                                } else {\n-                                    None\n-                                }\n-                            })\n-                                       .next();\n-                        }\n-                    }\n+                    let inputs: &[_] =\n+                        match self.tcx.hir.get(node_id) {\n+                            hir_map::NodeItem(&hir::Item {\n+                                                  node: hir::ItemFn(ref fndecl, ..), ..\n+                                              }) => &fndecl.inputs,\n+                            hir_map::NodeTraitItem(&hir::TraitItem {\n+                                                   node: hir::TraitItemKind::Method(ref fndecl, ..),\n+                                                   ..\n+                                               }) => &fndecl.decl.inputs,\n+                            hir_map::NodeImplItem(&hir::ImplItem {\n+                                                  node: hir::ImplItemKind::Method(ref fndecl, ..),\n+                                                  ..\n+                                              }) => &fndecl.decl.inputs,\n+\n+                            _ => &[],\n+                        };\n+\n+                    return inputs\n+                               .iter()\n+                               .filter_map(|arg| {\n+                                               self.find_component_for_bound_region(&**arg, br)\n+                                           })\n+                               .next();\n                 }\n             }\n         }\n         None\n     }\n+\n+    // This method creates a FindNestedTypeVisitor which returns the type corresponding\n+    // to the anonymous region.\n+    fn find_component_for_bound_region(&self,\n+                                       arg: &'gcx hir::Ty,\n+                                       br: &ty::BoundRegion)\n+                                       -> Option<(&'gcx hir::Ty)> {\n+        let mut nested_visitor = FindNestedTypeVisitor {\n+            infcx: &self,\n+            hir_map: &self.tcx.hir,\n+            bound_region: *br,\n+            found_type: None,\n+        };\n+        nested_visitor.visit_ty(arg);\n+        nested_visitor.found_type\n+    }\n }\n \n // The FindNestedTypeVisitor captures the corresponding `hir::Ty` of the\n@@ -176,8 +211,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n             hir::TyRptr(ref lifetime, _) => {\n                 match self.infcx.tcx.named_region_map.defs.get(&lifetime.id) {\n                     // the lifetime of the TyRptr\n-                    Some(&rl::Region::LateBoundAnon(debuijn_index, anon_index)) => {\n-                        if debuijn_index.depth == 1 && anon_index == br_index {\n+                    Some(&rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n+                        if debruijn_index.depth == 1 && anon_index == br_index {\n                             self.found_type = Some(arg);\n                             return; // we can stop visiting now\n                         }\n@@ -191,10 +226,77 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+            // Checks if it is of type `hir::TyPath` which corresponds to a struct.\n+            hir::TyPath(_) => {\n+                let subvisitor = &mut TyPathVisitor {\n+                                          infcx: self.infcx,\n+                                          found_it: false,\n+                                          bound_region: self.bound_region,\n+                                          hir_map: self.hir_map,\n+                                      };\n+                intravisit::walk_ty(subvisitor, arg); // call walk_ty; as visit_ty is empty,\n+                // this will visit only outermost type\n+                if subvisitor.found_it {\n+                    self.found_type = Some(arg);\n+                }\n+            }\n             _ => {}\n         }\n         // walk the embedded contents: e.g., if we are visiting `Vec<&Foo>`,\n         // go on to visit `&Foo`\n         intravisit::walk_ty(self, arg);\n     }\n }\n+\n+// The visitor captures the corresponding `hir::Ty` of the anonymous region\n+// in the case of structs ie. `hir::TyPath`.\n+// This visitor would be invoked for each lifetime corresponding to a struct,\n+// and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n+// where that lifetime appears. This allows us to highlight the\n+// specific part of the type in the error message.\n+struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    hir_map: &'a hir::map::Map<'gcx>,\n+    found_it: bool,\n+    bound_region: ty::BoundRegion,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.hir_map)\n+    }\n+\n+    fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n+        let br_index = match self.bound_region {\n+            ty::BrAnon(index) => index,\n+            _ => return,\n+        };\n+\n+        match self.infcx.tcx.named_region_map.defs.get(&lifetime.id) {\n+            // the lifetime of the TyPath!\n+            Some(&rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n+                if debruijn_index.depth == 1 && anon_index == br_index {\n+                    self.found_it = true;\n+                }\n+            }\n+            Some(&rl::Region::Static) |\n+            Some(&rl::Region::EarlyBound(_, _)) |\n+            Some(&rl::Region::LateBound(_, _)) |\n+            Some(&rl::Region::Free(_, _)) |\n+            None => {\n+                debug!(\"no arg found\");\n+            }\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n+        // ignore nested types\n+        //\n+        // If you have a type like `Foo<'a, &Ty>` we\n+        // are only interested in the immediate lifetimes ('a).\n+        //\n+        // Making `visit_ty` empty will ignore the `&Ty` embedded\n+        // inside, it will get reached by the outer visitor.\n+        debug!(\"`Ty` corresponding to a struct is {:?}\", arg);\n+    }\n+}"}, {"sha": "edf9ca89b3394e7bc11ffd2d1758d5c8ab69ee08", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -75,8 +75,10 @@ use errors::{DiagnosticBuilder, DiagnosticStyledString};\n mod note;\n \n mod need_type_info;\n-mod util;\n+\n mod named_anon_conflict;\n+#[macro_use]\n+mod util;\n mod anon_anon_conflict;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "0aae008396a00615b09cd7386ac0baec47506c90", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 28, "deletions": 41, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -11,7 +11,6 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n use infer::InferCtxt;\n-use ty;\n use infer::region_inference::RegionResolutionError::*;\n use infer::region_inference::RegionResolutionError;\n \n@@ -30,8 +29,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // where the anonymous region appears (there must always be one; we\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n-        // with the named one.\n-        let (named, (arg, new_ty, br, is_first), (scope_def_id, _)) =\n+        // with the named one.//scope_def_id\n+        let (named, anon_arg_info, region_info) =\n             if sub.is_named_region() && self.is_suitable_anonymous_region(sup).is_some() {\n                 (sub,\n                  self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n@@ -44,50 +43,38 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 return false; // inapplicable\n             };\n \n-        // Here, we check for the case where the anonymous region\n-        // is in the return type.\n-        // FIXME(#42703) - Need to handle certain cases here.\n-        let ret_ty = self.tcx.type_of(scope_def_id);\n-        match ret_ty.sty {\n-            ty::TyFnDef(_, _) => {\n-                let sig = ret_ty.fn_sig(self.tcx);\n-                let late_bound_regions = self.tcx\n-                    .collect_referenced_late_bound_regions(&sig.output());\n-                if late_bound_regions.iter().any(|r| *r == br) {\n-                    return false;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        // Here we check for the case where anonymous region\n-        // corresponds to self and if yes, we display E0312.\n-        // FIXME(#42700) - Need to format self properly to\n-        // enable E0621 for it.\n-        if is_first &&\n-           self.tcx\n-               .opt_associated_item(scope_def_id)\n-               .map(|i| i.method_has_self_argument)\n-               .unwrap_or(false) {\n+        let (arg, new_ty, br, is_first, scope_def_id, is_impl_item) = (anon_arg_info.arg,\n+                                                                       anon_arg_info.arg_ty,\n+                                                                       anon_arg_info.bound_region,\n+                                                                       anon_arg_info.is_first,\n+                                                                       region_info.def_id,\n+                                                                       region_info.is_impl_item);\n+        if is_impl_item {\n             return false;\n         }\n \n-        let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n-            (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n+        if self.is_return_type_anon(scope_def_id, br) || self.is_self_anon(is_first, scope_def_id) {\n+            return false;\n         } else {\n-            (\"parameter type\".to_owned(), \"type\".to_owned())\n-        };\n \n-        struct_span_err!(self.tcx.sess,\n-                         span,\n-                         E0621,\n-                         \"explicit lifetime required in {}\",\n-                         error_var)\n-                .span_label(arg.pat.span,\n-                            format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n-                .span_label(span, format!(\"lifetime `{}` required\", named))\n-                .emit();\n+            let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n+                (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n+            } else {\n+                (\"parameter type\".to_owned(), \"type\".to_owned())\n+            };\n+\n+            struct_span_err!(self.tcx.sess,\n+                             span,\n+                             E0621,\n+                             \"explicit lifetime required in {}\",\n+                             error_var)\n+                    .span_label(arg.pat.span,\n+                                format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n+                    .span_label(span, format!(\"lifetime `{}` required\", named))\n+                    .emit();\n \n+\n+        }\n         return true;\n     }\n }"}, {"sha": "04153038da89faaede49e3cfdc849454a4337f67", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 116, "deletions": 40, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -16,6 +16,40 @@ use ty::{self, Region};\n use hir::def_id::DefId;\n use hir::map as hir_map;\n \n+macro_rules! or_false {\n+     ($v:expr) => {\n+          match $v {\n+               Some(v) => v,\n+               None => return false,\n+          }\n+     }\n+}\n+\n+// The struct contains the information about the anonymous region\n+// we are searching for.\n+pub struct AnonymousArgInfo<'tcx> {\n+    // the argument corresponding to the anonymous region\n+    pub arg: &'tcx hir::Arg,\n+    // the type corresponding to the anonymopus region argument\n+    pub arg_ty: ty::Ty<'tcx>,\n+    // the ty::BoundRegion corresponding to the anonymous region\n+    pub bound_region: ty::BoundRegion,\n+    // corresponds to id the argument is the first parameter\n+    // in the declaration\n+    pub is_first: bool,\n+}\n+\n+// This struct contains information regarding the\n+// Refree((FreeRegion) corresponding to lifetime conflict\n+pub struct FreeRegionInfo {\n+    // def id corresponding to FreeRegion\n+    pub def_id: DefId,\n+    // the bound region corresponding to FreeRegion\n+    pub boundregion: ty::BoundRegion,\n+    // checks if bound region is in Impl Item\n+    pub is_impl_item: bool,\n+}\n+\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // This method walks the Type of the function body arguments using\n     // `fold_regions()` function and returns the\n@@ -28,14 +62,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // i32, which is the type of y but with the anonymous region replaced\n     // with 'a, the corresponding bound region and is_first which is true if\n     // the hir::Arg is the first argument in the function declaration.\n-    pub fn find_arg_with_anonymous_region\n-        (&self,\n-         anon_region: Region<'tcx>,\n-         replace_region: Region<'tcx>)\n-         -> Option<(&hir::Arg, ty::Ty<'tcx>, ty::BoundRegion, bool)> {\n+    pub fn find_arg_with_anonymous_region(&self,\n+                                          anon_region: Region<'tcx>,\n+                                          replace_region: Region<'tcx>)\n+                                          -> Option<AnonymousArgInfo> {\n \n         if let ty::ReFree(ref free_region) = *anon_region {\n-\n             let id = free_region.scope;\n             let hir = &self.tcx.hir;\n             if let Some(node_id) = hir.as_local_node_id(id) {\n@@ -57,7 +89,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                     });\n                                 if found_anon_region {\n                                     let is_first = index == 0;\n-                                    Some((arg, new_arg_ty, free_region.bound_region, is_first))\n+                                    Some(AnonymousArgInfo {\n+                                             arg: arg,\n+                                             arg_ty: new_arg_ty,\n+                                             bound_region: free_region.bound_region,\n+                                             is_first: is_first,\n+                                         })\n                                 } else {\n                                     None\n                                 }\n@@ -79,42 +116,81 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     // This method returns whether the given Region is Anonymous\n     // and returns the DefId and the BoundRegion corresponding to the given region.\n-    pub fn is_suitable_anonymous_region(&self,\n-                                        region: Region<'tcx>)\n-                                        -> Option<(DefId, ty::BoundRegion)> {\n+    pub fn is_suitable_anonymous_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         if let ty::ReFree(ref free_region) = *region {\n-            if let ty::BrAnon(..) = free_region.bound_region{\n-                    let anonymous_region_binding_scope = free_region.scope;\n-                    let node_id = self.tcx\n-                        .hir\n-                        .as_local_node_id(anonymous_region_binding_scope)\n-                        .unwrap();\n-                    match self.tcx.hir.find(node_id) {\n-                        Some(hir_map::NodeItem(..)) |\n-                        Some(hir_map::NodeTraitItem(..)) => {\n-                            // Success -- proceed to return Some below\n-                        }\n-                        Some(hir_map::NodeImplItem(..)) => {\n-                            let container_id = self.tcx\n-                                .associated_item(anonymous_region_binding_scope)\n-                                .container\n-                                .id();\n-                            if self.tcx.impl_trait_ref(container_id).is_some() {\n-                                // For now, we do not try to target impls of traits. This is\n-                                // because this message is going to suggest that the user\n-                                // change the fn signature, but they may not be free to do so,\n-                                // since the signature must match the trait.\n-                                //\n-                                // FIXME(#42706) -- in some cases, we could do better here.\n-                                return None;\n-                            }\n-                        }\n-                        _ => return None, // inapplicable\n-                        // we target only top-level functions\n+            if let ty::BrAnon(..) = free_region.bound_region {\n+                let anonymous_region_binding_scope = free_region.scope;\n+                let node_id = self.tcx\n+                    .hir\n+                    .as_local_node_id(anonymous_region_binding_scope)\n+                    .unwrap();\n+                let mut is_impl_item = false;\n+                match self.tcx.hir.find(node_id) {\n+\n+                    Some(hir_map::NodeItem(..)) |\n+                    Some(hir_map::NodeTraitItem(..)) => {\n+                        // Success -- proceed to return Some below\n                     }\n-                    return Some((anonymous_region_binding_scope, free_region.bound_region));\n+                    Some(hir_map::NodeImplItem(..)) => {\n+                        is_impl_item =\n+                            self.is_bound_region_in_impl_item(anonymous_region_binding_scope);\n+                    }\n+                    _ => return None,\n                 }\n+                return Some(FreeRegionInfo {\n+                                def_id: anonymous_region_binding_scope,\n+                                boundregion: free_region.bound_region,\n+                                is_impl_item: is_impl_item,\n+                            });\n             }\n-            None\n         }\n+        None\n+    }\n+\n+    // Here, we check for the case where the anonymous region\n+    // is in the return type.\n+    // FIXME(#42703) - Need to handle certain cases here.\n+    pub fn is_return_type_anon(&self, scope_def_id: DefId, br: ty::BoundRegion) -> bool {\n+        let ret_ty = self.tcx.type_of(scope_def_id);\n+        match ret_ty.sty {\n+            ty::TyFnDef(_, _) => {\n+                let sig = ret_ty.fn_sig(self.tcx);\n+                let late_bound_regions = self.tcx\n+                    .collect_referenced_late_bound_regions(&sig.output());\n+                if late_bound_regions.iter().any(|r| *r == br) {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n+        false\n+    }\n+    // Here we check for the case where anonymous region\n+    // corresponds to self and if yes, we display E0312.\n+    // FIXME(#42700) - Need to format self properly to\n+    // enable E0621 for it.\n+    pub fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n+        is_first &&\n+        self.tcx\n+            .opt_associated_item(scope_def_id)\n+            .map(|i| i.method_has_self_argument) == Some(true)\n+    }\n+\n+    // Here we check if the bound region is in Impl Item.\n+    pub fn is_bound_region_in_impl_item(&self, anonymous_region_binding_scope: DefId) -> bool {\n+        let container_id = self.tcx\n+            .associated_item(anonymous_region_binding_scope)\n+            .container\n+            .id();\n+        if self.tcx.impl_trait_ref(container_id).is_some() {\n+            // For now, we do not try to target impls of traits. This is\n+            // because this message is going to suggest that the user\n+            // change the fn signature, but they may not be free to do so,\n+            // since the signature must match the trait.\n+            //\n+            // FIXME(#42706) -- in some cases, we could do better here.\n+            return true;\n+        }\n+        false\n+    }\n }"}, {"sha": "1ee0099799760d392a7bc037b3cd74c447678d36", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.stderr", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -1,25 +1,10 @@\n-error[E0308]: mismatched types\n+error[E0623]: lifetime mismatch\n   --> $DIR/ex2b-push-no-existing-names.rs:16:12\n    |\n+15 | fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n+   |                    --------      -------- these two types are declared with different lifetimes...\n 16 |     x.push(y);\n-   |            ^ lifetime mismatch\n-   |\n-   = note: expected type `Ref<'_, _>`\n-              found type `Ref<'_, _>`\n-note: the anonymous lifetime #3 defined on the function body at 15:1...\n-  --> $DIR/ex2b-push-no-existing-names.rs:15:1\n-   |\n-15 | / fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n-16 | |     x.push(y);\n-17 | | }\n-   | |_^\n-note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 15:1\n-  --> $DIR/ex2b-push-no-existing-names.rs:15:1\n-   |\n-15 | / fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n-16 | |     x.push(y);\n-17 | | }\n-   | |_^\n+   |            ^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "74a40c87c2fb1841b7a64acaa36cf7cb2c95b746", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-2.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -2,7 +2,7 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ex3-both-anon-regions-2.rs:12:9\n    |\n 11 | fn foo((v, w): (&u8, &u8), x: &u8) {\n-   |                 ---           --- these references are not declared with the same lifetime...\n+   |                 ---           --- these two types are declared with different lifetimes...\n 12 |     v = x;\n    |         ^ ...but data from `x` flows here\n "}, {"sha": "51271243bdfdcc2399ca1d0f6b251cb7c0f1e540", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-3.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo((v, w): (&u8, &u8), (x, y): (&u8, &u8)) {\n-    v = x;\n+fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n+    z.push((x,y));\n }\n \n fn main() { }\n+"}, {"sha": "898866c75f2140fccba2edc7a040a13816eec910", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-3.stderr", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -1,10 +1,18 @@\n error[E0623]: lifetime mismatch\n-  --> $DIR/ex3-both-anon-regions-3.rs:12:9\n+  --> $DIR/ex3-both-anon-regions-3.rs:12:13\n    |\n-11 | fn foo((v, w): (&u8, &u8), (x, y): (&u8, &u8)) {\n-   |                 ---                 --- these references are not declared with the same lifetime...\n-12 |     v = x;\n-   |         ^ ...but data flows here\n+11 | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n+   |                     ---                 --- these two types are declared with different lifetimes...\n+12 |     z.push((x,y));\n+   |             ^ ...but data flows into `z` here\n \n-error: aborting due to previous error\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-3.rs:12:15\n+   |\n+11 | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n+   |                         ---                  --- these two types are declared with different lifetimes...\n+12 |     z.push((x,y));\n+   |               ^ ...but data flows into `z` here\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "9c2630fc811439ea0a07cea2933b54703bd5de0a", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-4.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ba65645c78a87f1fa5c6d7132130bb3175fbe68b/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba65645c78a87f1fa5c6d7132130bb3175fbe68b/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-4.stderr?ref=ba65645c78a87f1fa5c6d7132130bb3175fbe68b", "patch": "@@ -1,20 +0,0 @@\n-error[E0601]: main function not found\n-\n-error[E0623]: lifetime mismatch\n-  --> $DIR/ex3-both-anon-regions-4.rs:12:13\n-   |\n-11 | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n-   |                     ---                 --- these references are not declared with the same lifetime...\n-12 |     z.push((x,y));\n-   |             ^ ...but data flows into `z` here\n-\n-error[E0623]: lifetime mismatch\n-  --> $DIR/ex3-both-anon-regions-4.rs:12:15\n-   |\n-11 | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n-   |                         ---                  --- these references are not declared with the same lifetime...\n-12 |     z.push((x,y));\n-   |               ^ ...but data flows into `z` here\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "2fbf31aead5edea147c45a99fbcfc85ed250e521", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+struct Ref<'a, 'b> {\n+    a: &'a u32,\n+    b: &'b u32,\n+}\n+\n+fn foo(mut x: Ref, y: Ref) {\n+    x.b = y.b;\n+}\n+\n+fn main() {}"}, {"sha": "26f31defc9eb1ff8eeabccd3553357509b870c69", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,10 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-both-are-structs-2.rs:16:11\n+   |\n+15 | fn foo(mut x: Ref, y: Ref) {\n+   |               ---     --- these two types are declared with different lifetimes...\n+16 |     x.b = y.b;\n+   |           ^^^ ...but data from `y` flows into `x` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "120a7ca74aeeed81d5c28af32933d5d562e52935", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-3.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+struct Ref<'a, 'b> {\n+    a: &'a u32,\n+    b: &'b u32,\n+}\n+\n+fn foo(mut x: Ref) {\n+    x.a = x.b;\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "1b5ac7c7b57eef542646526fd9a4e4bf07c663d7", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-3.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,12 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-both-are-structs-3.rs:16:11\n+   |\n+15 | fn foo(mut x: Ref) {\n+   |               ---\n+   |               |\n+   |               this type was declared with multiple lifetimes...\n+16 |     x.a = x.b;\n+   |           ^^^ ...but data with one lifetime flows into the other here\n+\n+error: aborting due to previous error\n+"}, {"sha": "67ba8ee532ad0fc75148102766eaa157c40f7012", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs.rs", "status": "renamed", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -7,7 +7,12 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+struct Ref<'a> {\n+    x: &'a u32,\n+}\n \n-fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n-    z.push((x,y));\n+fn foo(mut x: Vec<Ref>, y: Ref) {\n+    x.push(y);\n }\n+\n+fn main() {}", "previous_filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-4.rs"}, {"sha": "6ad795400b334e040cb0d5c5e4e22e6959170ca2", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,10 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-both-are-structs.rs:15:12\n+   |\n+14 | fn foo(mut x: Vec<Ref>, y: Ref) {\n+   |                   ---      --- these two types are declared with different lifetimes...\n+15 |     x.push(y);\n+   |            ^ ...but data from `y` flows into `x` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "a8b1f53fc98d67f7469c6d722bdbe2ca45bc92a0", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, 'b> { a: &'a u32, b: &'b u32 }\n+\n+fn foo(mut x: Ref, y: &u32) {\n+    y = x.b;\n+}\n+\n+fn main() { }"}, {"sha": "31c7ebf6504cc0bd9ebf76960aa3c11ec62421e4", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-2.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,12 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-one-is-struct-2.rs:14:9\n+   |\n+13 | fn foo(mut x: Ref, y: &u32) {\n+   |               ---     ----\n+   |               |\n+   |               these two types are declared with different lifetimes...\n+14 |     y = x.b;\n+   |         ^^^ ...but data from `x` flows into `y` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "4933dbb7e7a7a2c3ec95ffb312fa34dcd9875ee4", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-3.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, 'b> { a: &'a u32, b: &'b u32 }\n+\n+fn foo(mut y: Ref, x: &u32) {\n+    y.b = x;\n+}\n+\n+fn main() { }"}, {"sha": "d54b526aef97fc760866238c87078b8286db6f9f", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-3.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,10 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-one-is-struct-3.rs:14:11\n+   |\n+13 | fn foo(mut y: Ref, x: &u32) {\n+   |               ---     ---- these two types are declared with different lifetimes...\n+14 |     y.b = x;\n+   |           ^ ...but data from `x` flows into `y` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "e1594b1a277cdea01b4f1899eb8a4abe5455fda0", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, 'b> {\n+    a: &'a u32,\n+    b: &'b u32,\n+}\n+\n+fn foo(mut x: Ref, y: &u32) {\n+    x.b = y;\n+}\n+\n+fn main() {}"}, {"sha": "bb7b9ea68436c6f75168fb1c9edecbd846ea0af2", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,10 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-one-is-struct.rs:17:11\n+   |\n+16 | fn foo(mut x: Ref, y: &u32) {\n+   |               ---     ---- these two types are declared with different lifetimes...\n+17 |     x.b = y;\n+   |           ^ ...but data from `y` flows into `x` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "0dc257ac0921ef8b12fa5d557fbd4708a04d4ca3", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-return-type-is-anon.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+  field: i32\n+}\n+\n+impl Foo {\n+  fn foo<'a>(&self, x: &i32) -> &i32 {\n+    x\n+  }\n+}\n+\n+fn main() { }\n+"}, {"sha": "890f9b311e7d20c9f428217e2e13f18199ebe38f", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-return-type-is-anon.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,23 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:17:5\n+   |\n+17 |     x\n+   |     ^\n+   |\n+note: ...the reference is valid for the anonymous lifetime #1 defined on the method body at 16:3...\n+  --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:16:3\n+   |\n+16 | /   fn foo<'a>(&self, x: &i32) -> &i32 {\n+17 | |     x\n+18 | |   }\n+   | |___^\n+note: ...but the borrowed content is only valid for the anonymous lifetime #2 defined on the method body at 16:3\n+  --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:16:3\n+   |\n+16 | /   fn foo<'a>(&self, x: &i32) -> &i32 {\n+17 | |     x\n+18 | |   }\n+   | |___^\n+\n+error: aborting due to previous error\n+"}, {"sha": "0940ce15d1e7679d13fcc9c71c031e2b1f4c4c48", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-self-is-anon.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+    field: i32,\n+}\n+\n+impl Foo {\n+    fn foo<'a>(&self, x: &Foo) -> &Foo {\n+        if true { x } else { self }\n+    }\n+}\n+\n+fn main() {}\n+"}, {"sha": "43f00c32c62856bed949c846ba8a3b21d34ba19a", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-self-is-anon.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,23 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/ex3-both-anon-regions-self-is-anon.rs:17:19\n+   |\n+17 |         if true { x } else { self }\n+   |                   ^\n+   |\n+note: ...the reference is valid for the anonymous lifetime #1 defined on the method body at 16:5...\n+  --> $DIR/ex3-both-anon-regions-self-is-anon.rs:16:5\n+   |\n+16 | /     fn foo<'a>(&self, x: &Foo) -> &Foo {\n+17 | |         if true { x } else { self }\n+18 | |     }\n+   | |_____^\n+note: ...but the borrowed content is only valid for the anonymous lifetime #2 defined on the method body at 16:5\n+  --> $DIR/ex3-both-anon-regions-self-is-anon.rs:16:5\n+   |\n+16 | /     fn foo<'a>(&self, x: &Foo) -> &Foo {\n+17 | |         if true { x } else { self }\n+18 | |     }\n+   | |_____^\n+\n+error: aborting due to previous error\n+"}, {"sha": "3a7ba415c0ded363e73827879d3bc36882fa34cb", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-using-impl-items.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+trait Foo {\n+    fn foo<'a>(x: &mut Vec<&u8>, y: &u8);\n+}\n+impl Foo for () {\n+    fn foo(x: &mut Vec<&u8>, y: &u8) {\n+        x.push(y);\n+    }\n+}\n+fn main() {}"}, {"sha": "9591df8e8aad249277330641674ee3891653b147", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-using-impl-items.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -0,0 +1,10 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-using-impl-items.rs:15:16\n+   |\n+14 |     fn foo(x: &mut Vec<&u8>, y: &u8) {\n+   |                        ---      --- these two types are declared with different lifetimes...\n+15 |         x.push(y);\n+   |                ^ ...but data from `y` flows into `x` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "be48d07b94e06098e811eb97395cef030c37f159", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.rs?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //"}, {"sha": "d3291063859cac81ee35beaa3f6048d878864ac7", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4d11495f9e70ee246ab6a61dec8bdc751fb142a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.stderr?ref=a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "patch": "@@ -2,7 +2,7 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ex3-both-anon-regions.rs:12:12\n    |\n 11 | fn foo(x: &mut Vec<&u8>, y: &u8) {\n-   |                    ---      --- these references are not declared with the same lifetime...\n+   |                    ---      --- these two types are declared with different lifetimes...\n 12 |     x.push(y);\n    |            ^ ...but data from `y` flows into `x` here\n "}]}