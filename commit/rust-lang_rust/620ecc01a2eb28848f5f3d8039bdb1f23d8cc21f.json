{"sha": "620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMGVjYzAxYTJlYjI4ODQ4ZjVmM2Q4MDM5YmRiMWYyM2Q4Y2MyMWY=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-03-17T14:28:52Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-03-17T14:31:30Z"}, "message": "Move some test-only code to test files\n\nThis also relaxes the bounds on some structs and moves them to the impl\nblock instead.", "tree": {"sha": "e20ad511734f529cc8dfafd1e009db4ced925a86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e20ad511734f529cc8dfafd1e009db4ced925a86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f", "html_url": "https://github.com/rust-lang/rust/commit/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c6d3bf3896b465e15550f49c2861e3d18102270", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c6d3bf3896b465e15550f49c2861e3d18102270", "html_url": "https://github.com/rust-lang/rust/commit/5c6d3bf3896b465e15550f49c2861e3d18102270"}], "stats": {"total": 163, "additions": 85, "deletions": 78}, "files": [{"sha": "f99c05ce91fc8c3ce509406f17edfa8f59da5047", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f", "patch": "@@ -297,22 +297,6 @@ impl<T> TypedArena<T> {\n         }\n     }\n \n-    /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n-    pub fn clear(&mut self) {\n-        unsafe {\n-            // Clear the last chunk, which is partially filled.\n-            let mut chunks_borrow = self.chunks.borrow_mut();\n-            if let Some(mut last_chunk) = chunks_borrow.last_mut() {\n-                self.clear_last_chunk(&mut last_chunk);\n-                let len = chunks_borrow.len();\n-                // If `T` is ZST, code below has no effect.\n-                for mut chunk in chunks_borrow.drain(..len - 1) {\n-                    chunk.destroy(chunk.entries);\n-                }\n-            }\n-        }\n-    }\n-\n     // Drops the contents of the last chunk. The last chunk is partially empty, unlike all other\n     // chunks.\n     fn clear_last_chunk(&self, last_chunk: &mut TypedArenaChunk<T>) {"}, {"sha": "911e577c1edc7b5b29bea226cd68fbc7c8a80029", "filename": "compiler/rustc_arena/src/tests.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Ftests.rs?ref=620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f", "patch": "@@ -11,6 +11,24 @@ struct Point {\n     z: i32,\n }\n \n+impl<T> TypedArena<T> {\n+    /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n+    fn clear(&mut self) {\n+        unsafe {\n+            // Clear the last chunk, which is partially filled.\n+            let mut chunks_borrow = self.chunks.borrow_mut();\n+            if let Some(mut last_chunk) = chunks_borrow.last_mut() {\n+                self.clear_last_chunk(&mut last_chunk);\n+                let len = chunks_borrow.len();\n+                // If `T` is ZST, code below has no effect.\n+                for mut chunk in chunks_borrow.drain(..len - 1) {\n+                    chunk.destroy(chunk.entries);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n pub fn test_unused() {\n     let arena: TypedArena<Point> = TypedArena::default();"}, {"sha": "f88bcc294815041be52c0c166e6c9fe9be85421a", "filename": "compiler/rustc_data_structures/src/tiny_list.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs?ref=620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f", "patch": "@@ -15,7 +15,7 @@\n mod tests;\n \n #[derive(Clone)]\n-pub struct TinyList<T: PartialEq> {\n+pub struct TinyList<T> {\n     head: Option<Element<T>>,\n }\n \n@@ -56,20 +56,10 @@ impl<T: PartialEq> TinyList<T> {\n         }\n         false\n     }\n-\n-    #[inline]\n-    pub fn len(&self) -> usize {\n-        let (mut elem, mut count) = (self.head.as_ref(), 0);\n-        while let Some(ref e) = elem {\n-            count += 1;\n-            elem = e.next.as_deref();\n-        }\n-        count\n-    }\n }\n \n #[derive(Clone)]\n-struct Element<T: PartialEq> {\n+struct Element<T> {\n     data: T,\n     next: Option<Box<Element<T>>>,\n }"}, {"sha": "c0334d2e23e5544d62f6790733c6d95b91c1853d", "filename": "compiler/rustc_data_structures/src/tiny_list/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs?ref=620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f", "patch": "@@ -3,6 +3,17 @@ use super::*;\n extern crate test;\n use test::{black_box, Bencher};\n \n+impl<T> TinyList<T> {\n+    fn len(&self) -> usize {\n+        let (mut elem, mut count) = (self.head.as_ref(), 0);\n+        while let Some(ref e) = elem {\n+            count += 1;\n+            elem = e.next.as_deref();\n+        }\n+        count\n+    }\n+}\n+\n #[test]\n fn test_contains_and_insert() {\n     fn do_insert(i: u32) -> bool {"}, {"sha": "ccf8bd69ebd0664af6787c93dc2dc91af1df3ca7", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f", "patch": "@@ -9,7 +9,7 @@ use std::mem;\n mod tests;\n \n #[derive(Clone, Debug)]\n-pub struct TransitiveRelation<T: Eq + Hash> {\n+pub struct TransitiveRelation<T> {\n     // List of elements. This is used to map from a T to a usize.\n     elements: FxIndexSet<T>,\n \n@@ -49,7 +49,7 @@ struct Edge {\n     target: Index,\n }\n \n-impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n+impl<T: Eq + Hash> TransitiveRelation<T> {\n     pub fn is_empty(&self) -> bool {\n         self.edges.is_empty()\n     }\n@@ -322,12 +322,6 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n             .collect()\n     }\n \n-    /// A \"best\" parent in some sense. See `parents` and\n-    /// `postdom_upper_bound` for more details.\n-    pub fn postdom_parent(&self, a: &T) -> Option<&T> {\n-        self.mutual_immediate_postdominator(self.parents(a))\n-    }\n-\n     fn with_closure<OP, R>(&self, op: OP) -> R\n     where\n         OP: FnOnce(&BitMatrix<usize, usize>) -> R,"}, {"sha": "9fa7224376c1c35fc2f260ca6aaf7aadd2efe1e7", "filename": "compiler/rustc_data_structures/src/transitive_relation/tests.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs?ref=620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f", "patch": "@@ -1,5 +1,13 @@\n use super::*;\n \n+impl<T: Eq + Hash> TransitiveRelation<T> {\n+    /// A \"best\" parent in some sense. See `parents` and\n+    /// `postdom_upper_bound` for more details.\n+    fn postdom_parent(&self, a: &T) -> Option<&T> {\n+        self.mutual_immediate_postdominator(self.parents(a))\n+    }\n+}\n+\n #[test]\n fn test_one_step() {\n     let mut relation = TransitiveRelation::default();"}, {"sha": "f612d1425b932b9e7b0f925750ba8621b8568672", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f", "patch": "@@ -453,41 +453,6 @@ impl SourceMap {\n         }\n     }\n \n-    /// Returns `Some(span)`, a union of the LHS and RHS span. The LHS must precede the RHS. If\n-    /// there are gaps between LHS and RHS, the resulting union will cross these gaps.\n-    /// For this to work,\n-    ///\n-    ///    * the syntax contexts of both spans much match,\n-    ///    * the LHS span needs to end on the same line the RHS span begins,\n-    ///    * the LHS span must start at or before the RHS span.\n-    pub fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n-        // Ensure we're at the same expansion ID.\n-        if sp_lhs.ctxt() != sp_rhs.ctxt() {\n-            return None;\n-        }\n-\n-        let lhs_end = match self.lookup_line(sp_lhs.hi()) {\n-            Ok(x) => x,\n-            Err(_) => return None,\n-        };\n-        let rhs_begin = match self.lookup_line(sp_rhs.lo()) {\n-            Ok(x) => x,\n-            Err(_) => return None,\n-        };\n-\n-        // If we must cross lines to merge, don't merge.\n-        if lhs_end.line != rhs_begin.line {\n-            return None;\n-        }\n-\n-        // Ensure these follow the expected order and that we don't overlap.\n-        if (sp_lhs.lo() <= sp_rhs.lo()) && (sp_lhs.hi() <= sp_rhs.lo()) {\n-            Some(sp_lhs.to(sp_rhs))\n-        } else {\n-            None\n-        }\n-    }\n-\n     pub fn span_to_string(&self, sp: Span) -> String {\n         if self.files.borrow().source_files.is_empty() && sp.is_dummy() {\n             return \"no-location\".to_string();\n@@ -931,13 +896,6 @@ impl SourceMap {\n         SourceFileAndBytePos { sf, pos: offset }\n     }\n \n-    /// Converts an absolute `BytePos` to a `CharPos` relative to the `SourceFile`.\n-    pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n-        let idx = self.lookup_source_file_idx(bpos);\n-        let sf = &(*self.files.borrow().source_files)[idx];\n-        sf.bytepos_to_file_charpos(bpos)\n-    }\n-\n     // Returns the index of the `SourceFile` (in `self.files`) that contains `pos`.\n     // This index is guaranteed to be valid for the lifetime of this `SourceMap`,\n     // since `source_files` is a `MonotonicVec`"}, {"sha": "7d814f1d82c11404e840161733f0cf2f29615447", "filename": "compiler/rustc_span/src/source_map/tests.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs?ref=620ecc01a2eb28848f5f3d8039bdb1f23d8cc21f", "patch": "@@ -10,6 +10,50 @@ fn init_source_map() -> SourceMap {\n     sm\n }\n \n+impl SourceMap {\n+    /// Returns `Some(span)`, a union of the LHS and RHS span. The LHS must precede the RHS. If\n+    /// there are gaps between LHS and RHS, the resulting union will cross these gaps.\n+    /// For this to work,\n+    ///\n+    ///    * the syntax contexts of both spans much match,\n+    ///    * the LHS span needs to end on the same line the RHS span begins,\n+    ///    * the LHS span must start at or before the RHS span.\n+    fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n+        // Ensure we're at the same expansion ID.\n+        if sp_lhs.ctxt() != sp_rhs.ctxt() {\n+            return None;\n+        }\n+\n+        let lhs_end = match self.lookup_line(sp_lhs.hi()) {\n+            Ok(x) => x,\n+            Err(_) => return None,\n+        };\n+        let rhs_begin = match self.lookup_line(sp_rhs.lo()) {\n+            Ok(x) => x,\n+            Err(_) => return None,\n+        };\n+\n+        // If we must cross lines to merge, don't merge.\n+        if lhs_end.line != rhs_begin.line {\n+            return None;\n+        }\n+\n+        // Ensure these follow the expected order and that we don't overlap.\n+        if (sp_lhs.lo() <= sp_rhs.lo()) && (sp_lhs.hi() <= sp_rhs.lo()) {\n+            Some(sp_lhs.to(sp_rhs))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Converts an absolute `BytePos` to a `CharPos` relative to the `SourceFile`.\n+    fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n+        let idx = self.lookup_source_file_idx(bpos);\n+        let sf = &(*self.files.borrow().source_files)[idx];\n+        sf.bytepos_to_file_charpos(bpos)\n+    }\n+}\n+\n /// Tests `lookup_byte_offset`.\n #[test]\n fn t3() {"}]}