{"sha": "45d015c95aeac6c6b2d46a6377e7255eac3330c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZDAxNWM5NWFlYWM2YzZiMmQ0NmE2Mzc3ZTcyNTVlYWMzMzMwYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-03T22:49:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-03T22:49:16Z"}, "message": "Auto merge of #58505 - schomatis:fix/nll/remove-live-var, r=matthewjasper\n\n[NLL] Remove `LiveVar`\n\nThe `LiveVar` type (and related) made it harder to reason about the code. It seemed as an abstraction that didn't bring any useful concept to the reader (when transitioning from the RFC theory to the actual implementation code).\n\nIt achieved a compactness in the vectors storing the def/use/drop information that was related only to the `LocalUseMap`. This PR went in the other direction and favored time over memory (but this decision can be easily reverted to the other side without reintroducing `LiveVar`).\n\nWhat this PR aims at is to clarify that there's no significant transformation between the MIR `Local` and the `LiveVar` (now refactored as `live_locals: Vec<Local>`): we're just filtering (not mapping) the entire group of `Local`s into a meaningful subset that we should perform the liveness analysis on.\n\nAs a side note, there is no guarantee that the liveness analysis is performed only on (what the code calls) \"live\" variables, if the NLL facts are requested it will be performed on *any* variable so there can't be any assumptions on that regard. (Still, this PR didn't change the general naming convention to reduce the number of changes here and streamline the review process).\n\n**Acceptance criteria:** This PR attempts to do only a minor refactoring and not to change the logic so it can't have any performance impact, particularly, it can't lose any of the significant performance improvement achieved in the great work done in https://github.com/rust-lang/rust/pull/52115.\n\nr? @nikomatsakis", "tree": {"sha": "335e61a6691a75a274eedbd711ddd82adf28c618", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/335e61a6691a75a274eedbd711ddd82adf28c618"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45d015c95aeac6c6b2d46a6377e7255eac3330c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45d015c95aeac6c6b2d46a6377e7255eac3330c0", "html_url": "https://github.com/rust-lang/rust/commit/45d015c95aeac6c6b2d46a6377e7255eac3330c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45d015c95aeac6c6b2d46a6377e7255eac3330c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87a436377a7cddd1d4426c9604c48e0aa2ec0b11", "url": "https://api.github.com/repos/rust-lang/rust/commits/87a436377a7cddd1d4426c9604c48e0aa2ec0b11", "html_url": "https://github.com/rust-lang/rust/commit/87a436377a7cddd1d4426c9604c48e0aa2ec0b11"}, {"sha": "ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc", "html_url": "https://github.com/rust-lang/rust/commit/ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc"}], "stats": {"total": 446, "additions": 179, "deletions": 267}, "files": [{"sha": "2d3800dd1dda86d28f87e2a8d312e39825ab71e6", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45d015c95aeac6c6b2d46a6377e7255eac3330c0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d015c95aeac6c6b2d46a6377e7255eac3330c0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=45d015c95aeac6c6b2d46a6377e7255eac3330c0", "patch": "@@ -2,7 +2,6 @@ use crate::borrow_check::borrow_set::BorrowSet;\n use crate::borrow_check::location::{LocationIndex, LocationTable};\n use crate::borrow_check::nll::facts::AllFactsExt;\n use crate::borrow_check::nll::type_check::{MirTypeckResults, MirTypeckRegionConstraints};\n-use crate::borrow_check::nll::type_check::liveness::liveness_map::NllLivenessMap;\n use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n use crate::dataflow::indexes::BorrowIndex;\n use crate::dataflow::move_paths::MoveData;"}, {"sha": "b9f9d83161b79649a7cb9b9a885b104c69113006", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/liveness_map.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/87a436377a7cddd1d4426c9604c48e0aa2ec0b11/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a436377a7cddd1d4426c9604c48e0aa2ec0b11/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs?ref=87a436377a7cddd1d4426c9604c48e0aa2ec0b11", "patch": "@@ -1,94 +0,0 @@\n-//! For the NLL computation, we need to compute liveness, but only for those\n-//! local variables whose types contain regions. The others are not of interest\n-//! to us. This file defines a new index type (LiveVar) that indexes into\n-//! a list of \"variables whose type contain regions\". It also defines a map from\n-//! Local to LiveVar and vice versa -- this map can be given to the\n-//! liveness code so that it only operates over variables with regions in their\n-//! types, instead of all variables.\n-\n-use crate::borrow_check::nll::ToRegionVid;\n-use crate::borrow_check::nll::facts::{AllFacts, AllFactsExt};\n-use crate::util::liveness::LiveVariableMap;\n-use rustc::mir::{Local, Mir};\n-use rustc::ty::{RegionVid, TyCtxt};\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-\n-/// Map between Local and LiveVar indices: the purpose of this\n-/// map is to define the subset of local variables for which we need\n-/// to do a liveness computation. We only need to compute whether a\n-/// variable `X` is live if that variable contains some region `R` in\n-/// its type where `R` is not known to outlive a free region (i.e.,\n-/// where `R` may be valid for just a subset of the fn body).\n-crate struct NllLivenessMap {\n-    /// For each local variable, contains `Some(i)` if liveness is\n-    /// needed for this variable.\n-    pub from_local: IndexVec<Local, Option<LiveVar>>,\n-\n-    /// For each `LiveVar`, maps back to the original `Local` index.\n-    pub to_local: IndexVec<LiveVar, Local>,\n-}\n-\n-impl LiveVariableMap for NllLivenessMap {\n-    fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n-        self.from_local[local]\n-    }\n-\n-    type LiveVar = LiveVar;\n-\n-    fn from_live_var(&self, local: Self::LiveVar) -> Local {\n-        self.to_local[local]\n-    }\n-\n-    fn num_variables(&self) -> usize {\n-        self.to_local.len()\n-    }\n-}\n-\n-impl NllLivenessMap {\n-    crate fn compute(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        free_regions: &FxHashSet<RegionVid>,\n-        mir: &Mir<'tcx>,\n-    ) -> Self {\n-        let mut to_local = IndexVec::default();\n-        let facts_enabled = AllFacts::enabled(tcx);\n-        let from_local: IndexVec<Local, Option<_>> = mir.local_decls\n-            .iter_enumerated()\n-            .map(|(local, local_decl)| {\n-                if tcx.all_free_regions_meet(&local_decl.ty, |r| {\n-                    free_regions.contains(&r.to_region_vid())\n-                }) && !facts_enabled {\n-                    // If all the regions in the type are free regions\n-                    // (or there are no regions), then we don't need\n-                    // to track liveness for this variable.\n-                    None\n-                } else {\n-                    Some(to_local.push(local))\n-                }\n-            })\n-            .collect();\n-\n-        debug!(\"{} total variables\", mir.local_decls.len());\n-        debug!(\"{} variables need liveness\", to_local.len());\n-        debug!(\"{} regions outlive free regions\", free_regions.len());\n-\n-        Self {\n-            from_local,\n-            to_local,\n-        }\n-    }\n-\n-    /// Returns `true` if there are no local variables that need liveness computation.\n-    crate fn is_empty(&self) -> bool {\n-        self.to_local.is_empty()\n-    }\n-}\n-\n-/// Index given to each local variable for which we need to\n-/// compute liveness information. For many locals, we are able to\n-/// skip liveness information: for example, those variables whose\n-/// types contain no regions.\n-newtype_index! {\n-    pub struct LiveVar { .. }\n-}"}, {"sha": "9b8940098852c1bcb1f71aac390a8e31f57eadd3", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/45d015c95aeac6c6b2d46a6377e7255eac3330c0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d015c95aeac6c6b2d46a6377e7255eac3330c0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=45d015c95aeac6c6b2d46a6377e7255eac3330c0", "patch": "@@ -1,6 +1,5 @@\n use crate::borrow_check::nll::region_infer::values::{PointIndex, RegionValueElements};\n-use crate::borrow_check::nll::type_check::liveness::liveness_map::{LiveVar, NllLivenessMap};\n-use crate::util::liveness::{categorize, DefUse, LiveVariableMap};\n+use crate::util::liveness::{categorize, DefUse};\n use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::{Local, Location, Mir};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -9,26 +8,33 @@ use rustc_data_structures::vec_linked_list as vll;\n /// A map that cross references each local with the locations where it\n /// is defined (assigned), used, or dropped. Used during liveness\n /// computation.\n-crate struct LocalUseMap<'me> {\n-    liveness_map: &'me NllLivenessMap,\n-\n+///\n+/// We keep track only of `Local`s we'll do the liveness analysis later,\n+/// this means that our internal `IndexVec`s will only be sparsely populated.\n+/// In the time-memory trade-off between keeping compact vectors with new\n+/// indexes (and needing to continuously map the `Local` index to its compact\n+/// counterpart) and having `IndexVec`s that we only use a fraction of, time\n+/// (and code simplicity) was favored. The rationale is that we only keep\n+/// a small number of `IndexVec`s throughout the entire analysis while, in\n+/// contrast, we're accessing each `Local` *many* times.\n+crate struct LocalUseMap {\n     /// Head of a linked list of **definitions** of each variable --\n     /// definition in this context means assignment, e.g., `x` is\n     /// defined in `x = y` but not `y`; that first def is the head of\n     /// a linked list that lets you enumerate all places the variable\n     /// is assigned.\n-    first_def_at: IndexVec<LiveVar, Option<AppearanceIndex>>,\n+    first_def_at: IndexVec<Local, Option<AppearanceIndex>>,\n \n     /// Head of a linked list of **uses** of each variable -- use in\n     /// this context means that the existing value of the variable is\n     /// read or modified. e.g., `y` is used in `x = y` but not `x`.\n     /// Note that `DROP(x)` terminators are excluded from this list.\n-    first_use_at: IndexVec<LiveVar, Option<AppearanceIndex>>,\n+    first_use_at: IndexVec<Local, Option<AppearanceIndex>>,\n \n     /// Head of a linked list of **drops** of each variable -- these\n     /// are a special category of uses corresponding to the drop that\n     /// we add for each local variable.\n-    first_drop_at: IndexVec<LiveVar, Option<AppearanceIndex>>,\n+    first_drop_at: IndexVec<Local, Option<AppearanceIndex>>,\n \n     appearances: IndexVec<AppearanceIndex, Appearance>,\n }\n@@ -50,52 +56,68 @@ impl vll::LinkElem for Appearance {\n     }\n }\n \n-impl LocalUseMap<'me> {\n+impl LocalUseMap {\n     crate fn build(\n-        liveness_map: &'me NllLivenessMap,\n+        live_locals: &Vec<Local>,\n         elements: &RegionValueElements,\n         mir: &Mir<'_>,\n     ) -> Self {\n-        let nones = IndexVec::from_elem_n(None, liveness_map.num_variables());\n+        let nones = IndexVec::from_elem_n(None, mir.local_decls.len());\n         let mut local_use_map = LocalUseMap {\n-            liveness_map,\n             first_def_at: nones.clone(),\n             first_use_at: nones.clone(),\n             first_drop_at: nones,\n             appearances: IndexVec::new(),\n         };\n \n+        let mut locals_with_use_data: IndexVec<Local, bool> =\n+            IndexVec::from_elem_n(false, mir.local_decls.len());\n+        live_locals\n+            .iter()\n+            .for_each(|&local| locals_with_use_data[local] = true);\n+\n         LocalUseMapBuild {\n             local_use_map: &mut local_use_map,\n             elements,\n-        }.visit_mir(mir);\n+            locals_with_use_data,\n+        }\n+        .visit_mir(mir);\n \n         local_use_map\n     }\n \n-    crate fn defs(&self, local: LiveVar) -> impl Iterator<Item = PointIndex> + '_ {\n+    crate fn defs(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n         vll::iter(self.first_def_at[local], &self.appearances)\n             .map(move |aa| self.appearances[aa].point_index)\n     }\n \n-    crate fn uses(&self, local: LiveVar) -> impl Iterator<Item = PointIndex> + '_ {\n+    crate fn uses(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n         vll::iter(self.first_use_at[local], &self.appearances)\n             .map(move |aa| self.appearances[aa].point_index)\n     }\n \n-    crate fn drops(&self, local: LiveVar) -> impl Iterator<Item = PointIndex> + '_ {\n+    crate fn drops(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n         vll::iter(self.first_drop_at[local], &self.appearances)\n             .map(move |aa| self.appearances[aa].point_index)\n     }\n }\n \n-struct LocalUseMapBuild<'me, 'map: 'me> {\n-    local_use_map: &'me mut LocalUseMap<'map>,\n+struct LocalUseMapBuild<'me> {\n+    local_use_map: &'me mut LocalUseMap,\n     elements: &'me RegionValueElements,\n+\n+    // Vector used in `visit_local` to signal which `Local`s do we need\n+    // def/use/drop information on, constructed from `live_locals` (that\n+    // contains the variables we'll do the liveness analysis for).\n+    // This vector serves optimization purposes only: we could have\n+    // obtained the same information from `live_locals` but we want to\n+    // avoid repeatedly calling `Vec::contains()` (see `LocalUseMap` for\n+    // the rationale on the time-memory trade-off we're favoring here).\n+    locals_with_use_data: IndexVec<Local, bool>,\n }\n \n-impl LocalUseMapBuild<'_, '_> {\n-    fn insert_def(&mut self, local: LiveVar, location: Location) {\n+impl LocalUseMapBuild<'_> {\n+    fn insert_def(&mut self, local: Local, location: Location) {\n         Self::insert(\n             self.elements,\n             &mut self.local_use_map.first_def_at[local],\n@@ -104,7 +126,7 @@ impl LocalUseMapBuild<'_, '_> {\n         );\n     }\n \n-    fn insert_use(&mut self, local: LiveVar, location: Location) {\n+    fn insert_use(&mut self, local: Local, location: Location) {\n         Self::insert(\n             self.elements,\n             &mut self.local_use_map.first_use_at[local],\n@@ -113,7 +135,7 @@ impl LocalUseMapBuild<'_, '_> {\n         );\n     }\n \n-    fn insert_drop(&mut self, local: LiveVar, location: Location) {\n+    fn insert_drop(&mut self, local: Local, location: Location) {\n         Self::insert(\n             self.elements,\n             &mut self.local_use_map.first_drop_at[local],\n@@ -137,13 +159,13 @@ impl LocalUseMapBuild<'_, '_> {\n     }\n }\n \n-impl Visitor<'tcx> for LocalUseMapBuild<'_, '_> {\n+impl Visitor<'tcx> for LocalUseMapBuild<'_> {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, location: Location) {\n-        if let Some(local_with_region) = self.local_use_map.liveness_map.from_local(local) {\n+        if self.locals_with_use_data[local] {\n             match categorize(context) {\n-                Some(DefUse::Def) => self.insert_def(local_with_region, location),\n-                Some(DefUse::Use) => self.insert_use(local_with_region, location),\n-                Some(DefUse::Drop) => self.insert_drop(local_with_region, location),\n+                Some(DefUse::Def) => self.insert_def(local, location),\n+                Some(DefUse::Use) => self.insert_use(local, location),\n+                Some(DefUse::Drop) => self.insert_drop(local, location),\n                 _ => (),\n             }\n         }"}, {"sha": "960e75048fa1614d112fb2ec9d1a5da4862b320b", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 70, "deletions": 15, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/45d015c95aeac6c6b2d46a6377e7255eac3330c0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d015c95aeac6c6b2d46a6377e7255eac3330c0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=45d015c95aeac6c6b2d46a6377e7255eac3330c0", "patch": "@@ -1,19 +1,19 @@\n use crate::borrow_check::location::LocationTable;\n-use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n use crate::borrow_check::nll::constraints::ConstraintSet;\n-use crate::borrow_check::nll::NllLivenessMap;\n+use crate::borrow_check::nll::facts::{AllFacts, AllFactsExt};\n+use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n use crate::borrow_check::nll::universal_regions::UniversalRegions;\n+use crate::borrow_check::nll::ToRegionVid;\n use crate::dataflow::move_paths::MoveData;\n-use crate::dataflow::MaybeInitializedPlaces;\n use crate::dataflow::FlowAtLocation;\n-use rustc::mir::Mir;\n-use rustc::ty::RegionVid;\n+use crate::dataflow::MaybeInitializedPlaces;\n+use rustc::mir::{Local, Mir};\n+use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::rc::Rc;\n \n use super::TypeChecker;\n \n-crate mod liveness_map;\n mod local_use_map;\n mod trace;\n \n@@ -34,16 +34,71 @@ pub(super) fn generate<'gcx, 'tcx>(\n     location_table: &LocationTable,\n ) {\n     debug!(\"liveness::generate\");\n-    let free_regions = {\n-        let borrowck_context = typeck.borrowck_context.as_ref().unwrap();\n-        regions_that_outlive_free_regions(\n-            typeck.infcx.num_region_vars(),\n-            &borrowck_context.universal_regions,\n-            &borrowck_context.constraints.outlives_constraints,\n-        )\n+\n+    let live_locals: Vec<Local> = if AllFacts::enabled(typeck.tcx()) {\n+        // If \"dump facts from NLL analysis\" was requested perform\n+        // the liveness analysis for all `Local`s. This case opens\n+        // the possibility of the variables being analyzed in `trace`\n+        // to be *any* `Local`, not just the \"live\" ones, so we can't\n+        // make any assumptions past this point as to the characteristics\n+        // of the `live_locals`.\n+        // FIXME: Review \"live\" terminology past this point, we should\n+        // not be naming the `Local`s as live.\n+        mir.local_decls.indices().collect()\n+    } else {\n+        let free_regions = {\n+            let borrowck_context = typeck.borrowck_context.as_ref().unwrap();\n+            regions_that_outlive_free_regions(\n+                typeck.infcx.num_region_vars(),\n+                &borrowck_context.universal_regions,\n+                &borrowck_context.constraints.outlives_constraints,\n+            )\n+        };\n+        compute_live_locals(typeck.tcx(), &free_regions, mir)\n     };\n-    let liveness_map = NllLivenessMap::compute(typeck.tcx(), &free_regions, mir);\n-    trace::trace(typeck, mir, elements, flow_inits, move_data, &liveness_map, location_table);\n+\n+    if !live_locals.is_empty() {\n+        trace::trace(\n+            typeck,\n+            mir,\n+            elements,\n+            flow_inits,\n+            move_data,\n+            live_locals,\n+            location_table,\n+        );\n+    }\n+}\n+\n+// The purpose of `compute_live_locals` is to define the subset of `Local`\n+// variables for which we need to do a liveness computation. We only need\n+// to compute whether a variable `X` is live if that variable contains\n+// some region `R` in its type where `R` is not known to outlive a free\n+// region (i.e., where `R` may be valid for just a subset of the fn body).\n+fn compute_live_locals(\n+    tcx: TyCtxt<'_, '_, 'tcx>,\n+    free_regions: &FxHashSet<RegionVid>,\n+    mir: &Mir<'tcx>,\n+) -> Vec<Local> {\n+    let live_locals: Vec<Local> = mir\n+        .local_decls\n+        .iter_enumerated()\n+        .filter_map(|(local, local_decl)| {\n+            if tcx.all_free_regions_meet(&local_decl.ty, |r| {\n+                free_regions.contains(&r.to_region_vid())\n+            }) {\n+                None\n+            } else {\n+                Some(local)\n+            }\n+        })\n+        .collect();\n+\n+    debug!(\"{} total variables\", mir.local_decls.len());\n+    debug!(\"{} variables need liveness\", live_locals.len());\n+    debug!(\"{} regions outlive free regions\", free_regions.len());\n+\n+    live_locals\n }\n \n /// Computes all regions that are (currently) known to outlive free"}, {"sha": "f0df7070e6b5ab41799f5d965dd014ab0849b719", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/45d015c95aeac6c6b2d46a6377e7255eac3330c0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d015c95aeac6c6b2d46a6377e7255eac3330c0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=45d015c95aeac6c6b2d46a6377e7255eac3330c0", "patch": "@@ -1,13 +1,11 @@\n use crate::borrow_check::location::LocationTable;\n use crate::borrow_check::nll::region_infer::values::{self, PointIndex, RegionValueElements};\n-use crate::borrow_check::nll::type_check::liveness::liveness_map::{LiveVar, NllLivenessMap};\n use crate::borrow_check::nll::type_check::liveness::local_use_map::LocalUseMap;\n use crate::borrow_check::nll::type_check::NormalizeLocation;\n use crate::borrow_check::nll::type_check::TypeChecker;\n use crate::dataflow::move_paths::indexes::MovePathIndex;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::{FlowAtLocation, FlowsAtLocation, MaybeInitializedPlaces};\n-use crate::util::liveness::LiveVariableMap;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::mir::{BasicBlock, ConstraintCategory, Local, Location, Mir};\n use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n@@ -38,16 +36,12 @@ pub(super) fn trace(\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n-    liveness_map: &NllLivenessMap,\n+    live_locals: Vec<Local>,\n     location_table: &LocationTable,\n ) {\n     debug!(\"trace()\");\n \n-    if liveness_map.is_empty() {\n-        return;\n-    }\n-\n-    let local_use_map = &LocalUseMap::build(liveness_map, elements, mir);\n+    let local_use_map = &LocalUseMap::build(&live_locals, elements, mir);\n \n     let cx = LivenessContext {\n         typeck,\n@@ -56,12 +50,11 @@ pub(super) fn trace(\n         elements,\n         local_use_map,\n         move_data,\n-        liveness_map,\n         drop_data: FxHashMap::default(),\n         location_table,\n     };\n \n-    LivenessResults::new(cx).compute_for_all_locals();\n+    LivenessResults::new(cx).compute_for_all_locals(live_locals);\n }\n \n /// Contextual state for the type-liveness generator.\n@@ -93,10 +86,7 @@ where\n \n     /// Index indicating where each variable is assigned, used, or\n     /// dropped.\n-    local_use_map: &'me LocalUseMap<'me>,\n-\n-    /// Map tracking which variables need liveness computation.\n-    liveness_map: &'me NllLivenessMap,\n+    local_use_map: &'me LocalUseMap,\n \n     /// Maps between a MIR Location and a LocationIndex\n     location_table: &'me LocationTable,\n@@ -148,15 +138,12 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn compute_for_all_locals(&mut self) {\n-        for live_local in self.cx.liveness_map.to_local.indices() {\n-            let local = self.cx.liveness_map.from_live_var(live_local);\n-            debug!(\"local={:?} live_local={:?}\", local, live_local);\n-\n+    fn compute_for_all_locals(&mut self, live_locals: Vec<Local>) {\n+        for local in live_locals {\n             self.reset_local_state();\n-            self.add_defs_for(live_local);\n-            self.compute_use_live_points_for(live_local);\n-            self.compute_drop_live_points_for(live_local);\n+            self.add_defs_for(local);\n+            self.compute_use_live_points_for(local);\n+            self.compute_drop_live_points_for(local);\n \n             let local_ty = self.cx.mir.local_decls[local].ty;\n \n@@ -185,23 +172,23 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n     }\n \n     /// Adds the definitions of `local` into `self.defs`.\n-    fn add_defs_for(&mut self, live_local: LiveVar) {\n-        for def in self.cx.local_use_map.defs(live_local) {\n+    fn add_defs_for(&mut self, local: Local) {\n+        for def in self.cx.local_use_map.defs(local) {\n             debug!(\"- defined at {:?}\", def);\n             self.defs.insert(def);\n         }\n     }\n \n     /// Computes all points where local is \"use live\" -- meaning its\n     /// current value may be used later (except by a drop). This is\n-    /// done by walking backwards from each use of `live_local` until we\n+    /// done by walking backwards from each use of `local` until we\n     /// find a `def` of local.\n     ///\n-    /// Requires `add_defs_for(live_local)` to have been executed.\n-    fn compute_use_live_points_for(&mut self, live_local: LiveVar) {\n-        debug!(\"compute_use_live_points_for(live_local={:?})\", live_local);\n+    /// Requires `add_defs_for(local)` to have been executed.\n+    fn compute_use_live_points_for(&mut self, local: Local) {\n+        debug!(\"compute_use_live_points_for(local={:?})\", local);\n \n-        self.stack.extend(self.cx.local_use_map.uses(live_local));\n+        self.stack.extend(self.cx.local_use_map.uses(local));\n         while let Some(p) = self.stack.pop() {\n             if self.defs.contains(p) {\n                 continue;\n@@ -224,15 +211,14 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n     ///\n     /// Requires `compute_use_live_points_for` and `add_defs_for` to\n     /// have been executed.\n-    fn compute_drop_live_points_for(&mut self, live_local: LiveVar) {\n-        debug!(\"compute_drop_live_points_for(live_local={:?})\", live_local);\n+    fn compute_drop_live_points_for(&mut self, local: Local) {\n+        debug!(\"compute_drop_live_points_for(local={:?})\", local);\n \n-        let local = self.cx.liveness_map.from_live_var(live_local);\n         let mpi = self.cx.move_data.rev_lookup.find_local(local);\n         debug!(\"compute_drop_live_points_for: mpi = {:?}\", mpi);\n \n         // Find the drops where `local` is initialized.\n-        for drop_point in self.cx.local_use_map.drops(live_local) {\n+        for drop_point in self.cx.local_use_map.drops(local) {\n             let location = self.cx.elements.to_location(drop_point);\n             debug_assert_eq!(self.cx.mir.terminator_loc(location.block), location,);\n "}, {"sha": "6a71b58152822c9452040ea41bc7aa4dd6a9beb5", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45d015c95aeac6c6b2d46a6377e7255eac3330c0/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d015c95aeac6c6b2d46a6377e7255eac3330c0/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=45d015c95aeac6c6b2d46a6377e7255eac3330c0", "patch": "@@ -68,7 +68,7 @@ use crate::transform::no_landing_pads::no_landing_pads;\n use crate::dataflow::{do_dataflow, DebugFormatted, state_for_location};\n use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals};\n use crate::util::dump_mir;\n-use crate::util::liveness::{self, IdentityMap};\n+use crate::util::liveness;\n \n pub struct StateTransform;\n \n@@ -148,7 +148,7 @@ struct SuspensionPoint {\n     state: u32,\n     resume: BasicBlock,\n     drop: Option<BasicBlock>,\n-    storage_liveness: liveness::LiveVarSet<Local>,\n+    storage_liveness: liveness::LiveVarSet,\n }\n \n struct TransformVisitor<'a, 'tcx: 'a> {\n@@ -165,7 +165,7 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n \n     // A map from a suspension point in a block to the locals which have live storage at that point\n     // FIXME(eddyb) This should use `IndexVec<BasicBlock, Option<_>>`.\n-    storage_liveness: FxHashMap<BasicBlock, liveness::LiveVarSet<Local>>,\n+    storage_liveness: FxHashMap<BasicBlock, liveness::LiveVarSet>,\n \n     // A list of suspension points, generated during the transform\n     suspension_points: Vec<SuspensionPoint>,\n@@ -358,7 +358,7 @@ fn replace_result_variable<'tcx>(\n     new_ret_local\n }\n \n-struct StorageIgnored(liveness::LiveVarSet<Local>);\n+struct StorageIgnored(liveness::LiveVarSet);\n \n impl<'tcx> Visitor<'tcx> for StorageIgnored {\n     fn visit_statement(&mut self,\n@@ -379,8 +379,8 @@ fn locals_live_across_suspend_points(\n     source: MirSource<'tcx>,\n     movable: bool,\n ) -> (\n-    liveness::LiveVarSet<Local>,\n-    FxHashMap<BasicBlock, liveness::LiveVarSet<Local>>,\n+    liveness::LiveVarSet,\n+    FxHashMap<BasicBlock, liveness::LiveVarSet>,\n ) {\n     let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n     let node_id = tcx.hir().as_local_node_id(source.def_id()).unwrap();\n@@ -414,14 +414,12 @@ fn locals_live_across_suspend_points(\n     let mut set = liveness::LiveVarSet::new_empty(mir.local_decls.len());\n     let mut liveness = liveness::liveness_of_locals(\n         mir,\n-        &IdentityMap::new(mir),\n     );\n     liveness::dump_mir(\n         tcx,\n         \"generator_liveness\",\n         source,\n         mir,\n-        &IdentityMap::new(mir),\n         &liveness,\n     );\n \n@@ -491,7 +489,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             mir: &mut Mir<'tcx>)\n     -> (FxHashMap<Local, (Ty<'tcx>, usize)>,\n         GeneratorLayout<'tcx>,\n-        FxHashMap<BasicBlock, liveness::LiveVarSet<Local>>)\n+        FxHashMap<BasicBlock, liveness::LiveVarSet>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let (live_locals, storage_liveness) = locals_live_across_suspend_points(tcx,"}, {"sha": "9cda6cfdacbe3eab231eaae1eb1922366ba37f7a", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 34, "deletions": 88, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/45d015c95aeac6c6b2d46a6377e7255eac3330c0/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d015c95aeac6c6b2d46a6377e7255eac3330c0/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=45d015c95aeac6c6b2d46a6377e7255eac3330c0", "patch": "@@ -39,7 +39,7 @@ use std::path::{Path, PathBuf};\n use crate::transform::MirSource;\n use crate::util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n \n-pub type LiveVarSet<V> = BitSet<V>;\n+pub type LiveVarSet = BitSet<Local>;\n \n /// This gives the result of the liveness analysis at the boundary of\n /// basic blocks.\n@@ -48,66 +48,27 @@ pub type LiveVarSet<V> = BitSet<V>;\n /// liveness for. This is often `Local`, in which case we computed\n /// liveness for all variables -- but it can also be some other type,\n /// which indicates a subset of the variables within the graph.\n-pub struct LivenessResult<V: Idx> {\n+pub struct LivenessResult {\n     /// Live variables on exit to each basic block. This is equal to\n     /// the union of the `ins` for each successor.\n-    pub outs: IndexVec<BasicBlock, LiveVarSet<V>>,\n-}\n-\n-/// Defines the mapping to/from the MIR local variables (`Local`) to\n-/// the \"live variable indices\" we are using in a particular\n-/// computation.\n-pub trait LiveVariableMap {\n-    type LiveVar;\n-\n-    fn from_local(&self, local: Local) -> Option<Self::LiveVar>;\n-    fn from_live_var(&self, local: Self::LiveVar) -> Local;\n-    fn num_variables(&self) -> usize;\n-}\n-\n-#[derive(Debug)]\n-pub struct IdentityMap<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n-}\n-\n-impl<'a, 'tcx> IdentityMap<'a, 'tcx> {\n-    pub fn new(mir: &'a Mir<'tcx>) -> Self {\n-        Self { mir }\n-    }\n-}\n-\n-impl<'a, 'tcx> LiveVariableMap for IdentityMap<'a, 'tcx> {\n-    type LiveVar = Local;\n-\n-    fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n-        Some(local)\n-    }\n-\n-    fn from_live_var(&self, local: Self::LiveVar) -> Local {\n-        local\n-    }\n-\n-    fn num_variables(&self) -> usize {\n-        self.mir.local_decls.len()\n-    }\n+    pub outs: IndexVec<BasicBlock, LiveVarSet>,\n }\n \n /// Computes which local variables are live within the given function\n /// `mir`. The liveness mode `mode` determines what sorts of uses are\n /// considered to make a variable live (e.g., do drops count?).\n-pub fn liveness_of_locals<'tcx, V: Idx>(\n+pub fn liveness_of_locals<'tcx>(\n     mir: &Mir<'tcx>,\n-    map: &impl LiveVariableMap<LiveVar = V>,\n-) -> LivenessResult<V> {\n-    let num_live_vars = map.num_variables();\n+) -> LivenessResult {\n+    let num_live_vars = mir.local_decls.len();\n \n-    let def_use: IndexVec<_, DefsUses<V>> = mir\n+    let def_use: IndexVec<_, DefsUses> = mir\n         .basic_blocks()\n         .iter()\n-        .map(|b| block(map, b, num_live_vars))\n+        .map(|b| block(b, num_live_vars))\n         .collect();\n \n-    let mut outs: IndexVec<_, LiveVarSet<V>> = mir\n+    let mut outs: IndexVec<_, LiveVarSet> = mir\n         .basic_blocks()\n         .indices()\n         .map(|_| LiveVarSet::new_empty(num_live_vars))\n@@ -211,27 +172,23 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>) -> Option<DefUse> {\n     }\n }\n \n-struct DefsUsesVisitor<'lv, V, M>\n-where\n-    V: Idx,\n-    M: LiveVariableMap<LiveVar = V> + 'lv,\n+struct DefsUsesVisitor\n {\n-    map: &'lv M,\n-    defs_uses: DefsUses<V>,\n+    defs_uses: DefsUses,\n }\n \n #[derive(Eq, PartialEq, Clone)]\n-struct DefsUses<V: Idx> {\n-    defs: LiveVarSet<V>,\n-    uses: LiveVarSet<V>,\n+struct DefsUses {\n+    defs: LiveVarSet,\n+    uses: LiveVarSet,\n }\n \n-impl<V: Idx> DefsUses<V> {\n-    fn apply(&self, bits: &mut LiveVarSet<V>) -> bool {\n+impl DefsUses {\n+    fn apply(&self, bits: &mut LiveVarSet) -> bool {\n         bits.subtract(&self.defs) | bits.union(&self.uses)\n     }\n \n-    fn add_def(&mut self, index: V) {\n+    fn add_def(&mut self, index: Local) {\n         // If it was used already in the block, remove that use\n         // now that we found a definition.\n         //\n@@ -245,7 +202,7 @@ impl<V: Idx> DefsUses<V> {\n         self.defs.insert(index);\n     }\n \n-    fn add_use(&mut self, index: V) {\n+    fn add_use(&mut self, index: Local) {\n         // Inverse of above.\n         //\n         // Example:\n@@ -261,29 +218,22 @@ impl<V: Idx> DefsUses<V> {\n     }\n }\n \n-impl<'tcx, 'lv, V, M> Visitor<'tcx> for DefsUsesVisitor<'lv, V, M>\n-where\n-    V: Idx,\n-    M: LiveVariableMap<LiveVar = V>,\n+impl<'tcx> Visitor<'tcx> for DefsUsesVisitor\n {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n-        if let Some(v_index) = self.map.from_local(local) {\n-            match categorize(context) {\n-                Some(DefUse::Def) => self.defs_uses.add_def(v_index),\n-                Some(DefUse::Use) | Some(DefUse::Drop) => self.defs_uses.add_use(v_index),\n-                _ => (),\n-            }\n+        match categorize(context) {\n+            Some(DefUse::Def) => self.defs_uses.add_def(local),\n+            Some(DefUse::Use) | Some(DefUse::Drop) => self.defs_uses.add_use(local),\n+            _ => (),\n         }\n     }\n }\n \n-fn block<'tcx, V: Idx>(\n-    map: &impl LiveVariableMap<LiveVar = V>,\n+fn block<'tcx>(\n     b: &BasicBlockData<'tcx>,\n     locals: usize,\n-) -> DefsUses<V> {\n+) -> DefsUses {\n     let mut visitor = DefsUsesVisitor {\n-        map,\n         defs_uses: DefsUses {\n             defs: LiveVarSet::new_empty(locals),\n             uses: LiveVarSet::new_empty(locals),\n@@ -305,13 +255,12 @@ fn block<'tcx, V: Idx>(\n     visitor.defs_uses\n }\n \n-pub fn dump_mir<'a, 'tcx, V: Idx>(\n+pub fn dump_mir<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     source: MirSource<'tcx>,\n     mir: &Mir<'tcx>,\n-    map: &impl LiveVariableMap<LiveVar = V>,\n-    result: &LivenessResult<V>,\n+    result: &LivenessResult,\n ) {\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n@@ -320,17 +269,16 @@ pub fn dump_mir<'a, 'tcx, V: Idx>(\n         // see notes on #41697 below\n         tcx.item_path_str(source.def_id())\n     });\n-    dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, map, result);\n+    dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, result);\n }\n \n-fn dump_matched_mir_node<'a, 'tcx, V: Idx>(\n+fn dump_matched_mir_node<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     node_path: &str,\n     source: MirSource<'tcx>,\n     mir: &Mir<'tcx>,\n-    map: &dyn LiveVariableMap<LiveVar = V>,\n-    result: &LivenessResult<V>,\n+    result: &LivenessResult,\n ) {\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n@@ -342,25 +290,23 @@ fn dump_matched_mir_node<'a, 'tcx, V: Idx>(\n         writeln!(file, \"// source = {:?}\", source)?;\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n         writeln!(file, \"\")?;\n-        write_mir_fn(tcx, source, mir, map, &mut file, result)?;\n+        write_mir_fn(tcx, source, mir, &mut file, result)?;\n         Ok(())\n     });\n }\n \n-pub fn write_mir_fn<'a, 'tcx, V: Idx>(\n+pub fn write_mir_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     src: MirSource<'tcx>,\n     mir: &Mir<'tcx>,\n-    map: &dyn LiveVariableMap<LiveVar = V>,\n     w: &mut dyn Write,\n-    result: &LivenessResult<V>,\n+    result: &LivenessResult,\n ) -> io::Result<()> {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n-        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LiveVarSet<V>>| {\n+        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LiveVarSet>| {\n             let live: Vec<String> = result[block]\n                 .iter()\n-                .map(|v| map.from_live_var(v))\n                 .map(|local| format!(\"{:?}\", local))\n                 .collect();\n             writeln!(w, \"{} {{{}}}\", prefix, live.join(\", \"))"}]}