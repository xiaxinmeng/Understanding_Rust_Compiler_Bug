{"sha": "735fc12e1ad35e8789a922eb506f64756f499a32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNWZjMTJlMWFkMzVlODc4OWE5MjJlYjUwNmY2NDc1NmY0OTlhMzI=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-03-28T01:06:53Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-04-05T15:27:31Z"}, "message": "Handle variation in layout of pthread_mutex_t", "tree": {"sha": "0cb86b41caac0db090f7019609ab4c279b7da08a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cb86b41caac0db090f7019609ab4c279b7da08a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/735fc12e1ad35e8789a922eb506f64756f499a32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/735fc12e1ad35e8789a922eb506f64756f499a32", "html_url": "https://github.com/rust-lang/rust/commit/735fc12e1ad35e8789a922eb506f64756f499a32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/735fc12e1ad35e8789a922eb506f64756f499a32/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5e3256b5942a0c2e280700fff7f33bbdc803436", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5e3256b5942a0c2e280700fff7f33bbdc803436", "html_url": "https://github.com/rust-lang/rust/commit/e5e3256b5942a0c2e280700fff7f33bbdc803436"}], "stats": {"total": 86, "additions": 74, "deletions": 12}, "files": [{"sha": "6ce45e3ad4dd8a127fca843bbe6698e5931d949f", "filename": "src/shims/sync.rs", "status": "modified", "additions": 74, "deletions": 12, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/735fc12e1ad35e8789a922eb506f64756f499a32/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/735fc12e1ad35e8789a922eb506f64756f499a32/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=735fc12e1ad35e8789a922eb506f64756f499a32", "patch": "@@ -1,5 +1,7 @@\n+use std::sync::atomic::{AtomicU64, Ordering};\n+\n use rustc_middle::ty::{TyKind, TypeAndMut};\n-use rustc_target::abi::{LayoutOf, Size};\n+use rustc_target::abi::{FieldsShape, LayoutOf, Size};\n \n use crate::stacked_borrows::Tag;\n use crate::*;\n@@ -399,15 +401,67 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n // bytes 0-3: reserved for signature on macOS\n // (need to avoid this because it is set by static initializer macros)\n // bytes 4-7: count of how many times this mutex has been locked, as a u32\n-// bytes 12-15: mutex kind, as an i32\n-// (the kind has to be at this offset for compatibility with static initializer macros)\n+// bytes 12-15 or 16-19 (depending on platform): mutex kind, as an i32\n+// (the kind has to be at its offset for compatibility with static initializer macros)\n+\n+static LIBC_MUTEX_KIND_OFFSET_CACHE: AtomicU64 = AtomicU64::new(0);\n+\n+fn libc_mutex_kind_offset<'mir, 'tcx: 'mir>(\n+    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+) -> InterpResult<'tcx, u64> {\n+    // Check if this offset has already been found and memoized\n+    let cached_value = LIBC_MUTEX_KIND_OFFSET_CACHE.load(Ordering::Relaxed);\n+    if cached_value != 0 {\n+        return Ok(cached_value);\n+    }\n+\n+    // This function infers the offset of the `kind` field of libc's pthread_mutex_t\n+    // C struct by examining the array inside libc::PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP.\n+    // At time of writing, it is always all zero bytes except for a one byte at one of\n+    // four positions, depending on the target OS's C struct layout and the endianness of the\n+    // target architecture. This offset will then be used in getters and setters below, so that\n+    // mutexes created from static initializers can be emulated with the correct behavior.\n+    let initializer_path = [\"libc\", \"PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\"];\n+    let initializer_instance = ecx.resolve_path(&initializer_path);\n+    let initializer_cid = GlobalId { instance: initializer_instance, promoted: None };\n+    let initializer_const_val = ecx.const_eval_raw(initializer_cid)?;\n+    let array_mplacety = ecx.mplace_field(initializer_const_val, 0)?;\n+    let array_length = match array_mplacety.layout.fields {\n+        FieldsShape::Array { count, .. } => count,\n+        _ => bug!(\"Couldn't get array length from type {:?}\", array_mplacety.layout.ty),\n+    };\n+\n+    let kind_offset = if array_length < 20 {\n+        bug!(\"libc::PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP array was shorter than expected\");\n+    } else if ecx.read_scalar(ecx.mplace_field(array_mplacety, 16)?.into())?.to_u8()? != 0 {\n+        // for little-endian architectures\n+        16\n+    } else if ecx.read_scalar(ecx.mplace_field(array_mplacety, 19)?.into())?.to_u8()? != 0 {\n+        // for big-endian architectures\n+        // (note that the i32 spans bytes 16 through 19, so the offset of the kind field is 16)\n+        16\n+    } else if ecx.read_scalar(ecx.mplace_field(array_mplacety, 12)?.into())?.to_u8()? != 0 {\n+        // for little-endian architectures\n+        12\n+    } else if ecx.read_scalar(ecx.mplace_field(array_mplacety, 15)?.into())?.to_u8()? != 0 {\n+        // for big-endian architectures\n+        // (note that the i32 spans bytes 12 through 15, so the offset of the kind field is 12)\n+        12\n+    } else {\n+        bug!(\"Couldn't determine offset of `kind` in pthread_mutex_t\");\n+    };\n+\n+    // Save offset to memoization cache for future calls\n+    LIBC_MUTEX_KIND_OFFSET_CACHE.store(kind_offset, Ordering::Relaxed);\n+    Ok(kind_offset)\n+}\n \n fn mutex_get_locked_count<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     mutex_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>> {\n     // Ensure that the following read at an offset to the mutex pointer is within bounds\n-    assert_ptr_target_min_size(ecx, mutex_op, 16)?;\n+    assert_ptr_target_min_size(ecx, mutex_op, 20)?;\n     let mutex_place = ecx.deref_operand(mutex_op)?;\n     let u32_layout = ecx.layout_of(ecx.tcx.types.u32)?;\n     let locked_count_place =\n@@ -421,7 +475,7 @@ fn mutex_set_locked_count<'mir, 'tcx: 'mir>(\n     locked_count: impl Into<ScalarMaybeUndef<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     // Ensure that the following write at an offset to the mutex pointer is within bounds\n-    assert_ptr_target_min_size(ecx, mutex_op, 16)?;\n+    assert_ptr_target_min_size(ecx, mutex_op, 20)?;\n     let mutex_place = ecx.deref_operand(mutex_op)?;\n     let u32_layout = ecx.layout_of(ecx.tcx.types.u32)?;\n     let locked_count_place =\n@@ -430,15 +484,19 @@ fn mutex_set_locked_count<'mir, 'tcx: 'mir>(\n }\n \n fn mutex_get_kind<'mir, 'tcx: 'mir>(\n-    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     mutex_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>> {\n     // Ensure that the following read at an offset to the mutex pointer is within bounds\n-    assert_ptr_target_min_size(ecx, mutex_op, 16)?;\n+    assert_ptr_target_min_size(ecx, mutex_op, 20)?;\n     let mutex_place = ecx.deref_operand(mutex_op)?;\n     let i32_layout = ecx.layout_of(ecx.tcx.types.i32)?;\n-    let kind_place =\n-        mutex_place.offset(Size::from_bytes(12), MemPlaceMeta::None, i32_layout, ecx)?;\n+    let kind_place = mutex_place.offset(\n+        Size::from_bytes(libc_mutex_kind_offset(ecx)?),\n+        MemPlaceMeta::None,\n+        i32_layout,\n+        ecx,\n+    )?;\n     ecx.read_scalar(kind_place.into())\n }\n \n@@ -448,11 +506,15 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n     kind: impl Into<ScalarMaybeUndef<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     // Ensure that the following write at an offset to the mutex pointer is within bounds\n-    assert_ptr_target_min_size(ecx, mutex_op, 16)?;\n+    assert_ptr_target_min_size(ecx, mutex_op, 20)?;\n     let mutex_place = ecx.deref_operand(mutex_op)?;\n     let i32_layout = ecx.layout_of(ecx.tcx.types.i32)?;\n-    let kind_place =\n-        mutex_place.offset(Size::from_bytes(12), MemPlaceMeta::None, i32_layout, ecx)?;\n+    let kind_place = mutex_place.offset(\n+        Size::from_bytes(libc_mutex_kind_offset(ecx)?),\n+        MemPlaceMeta::None,\n+        i32_layout,\n+        ecx,\n+    )?;\n     ecx.write_scalar(kind.into(), kind_place.into())\n }\n "}]}