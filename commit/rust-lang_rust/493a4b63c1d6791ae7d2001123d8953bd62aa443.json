{"sha": "493a4b63c1d6791ae7d2001123d8953bd62aa443", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5M2E0YjYzYzFkNjc5MWFlN2QyMDAxMTIzZDg5NTNiZDYyYWE0NDM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-16T12:52:14Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-17T12:53:49Z"}, "message": "std: iteratize str::is_utf16 & add tests.\n\nMost of the tests are randomly generated with Python 3 and rely on it's\nUTF-16be encoder/decoder being correct.", "tree": {"sha": "7a64dbfa77d43f3cbc0b7d8d144c911bbcc49313", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a64dbfa77d43f3cbc0b7d8d144c911bbcc49313"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/493a4b63c1d6791ae7d2001123d8953bd62aa443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/493a4b63c1d6791ae7d2001123d8953bd62aa443", "html_url": "https://github.com/rust-lang/rust/commit/493a4b63c1d6791ae7d2001123d8953bd62aa443", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/493a4b63c1d6791ae7d2001123d8953bd62aa443/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8489069b43191c5298f17430933b3b88fb79c3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8489069b43191c5298f17430933b3b88fb79c3c", "html_url": "https://github.com/rust-lang/rust/commit/c8489069b43191c5298f17430933b3b88fb79c3c"}], "stats": {"total": 96, "additions": 78, "deletions": 18}, "files": [{"sha": "8214382fb0d0e0485a23c845b5fa0f9c83c05a3f", "filename": "src/libstd/str.rs", "status": "modified", "additions": 78, "deletions": 18, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/493a4b63c1d6791ae7d2001123d8953bd62aa443/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493a4b63c1d6791ae7d2001123d8953bd62aa443/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=493a4b63c1d6791ae7d2001123d8953bd62aa443", "patch": "@@ -805,23 +805,23 @@ fn first_non_utf8_index(v: &[u8]) -> Option<uint> {\n \n /// Determines if a vector of `u16` contains valid UTF-16\n pub fn is_utf16(v: &[u16]) -> bool {\n-    let len = v.len();\n-    let mut i = 0u;\n-    while i < len {\n-        let u = v[i];\n-\n-        if  u <= 0xD7FF_u16 || u >= 0xE000_u16 {\n-            i += 1u;\n+    let mut it = v.iter();\n+    macro_rules! next ( ($ret:expr) => {\n+            match it.next() { Some(u) => *u, None => return $ret }\n+        }\n+    )\n+    loop {\n+        let u = next!(true);\n \n-        } else {\n-            if i+1u < len { return false; }\n-            let u2 = v[i+1u];\n-            if u < 0xD7FF_u16 || u > 0xDBFF_u16 { return false; }\n-            if u2 < 0xDC00_u16 || u2 > 0xDFFF_u16 { return false; }\n-            i += 2u;\n+        match char::from_u32(u as u32) {\n+            Some(_) => {}\n+            None => {\n+                let u2 = next!(false);\n+                if u < 0xD7FF || u > 0xDBFF ||\n+                    u2 < 0xDC00 || u2 > 0xDFFF { return false; }\n+            }\n         }\n     }\n-    return true;\n }\n \n /// Iterates over the utf-16 characters in the specified slice, yielding each\n@@ -3511,6 +3511,65 @@ mod tests {\n         assert!(is_utf8([0xF4, 0x8F, 0xBF, 0xBF]));\n     }\n \n+    #[test]\n+    fn test_is_utf16() {\n+        macro_rules! pos ( ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } });\n+\n+        // non-surrogates\n+        pos!([0x0000],\n+             [0x0001, 0x0002],\n+             [0xD7FF],\n+             [0xE000]);\n+\n+        // surrogate pairs (randomly generated with Python 3's\n+        // .encode('utf-16be'))\n+        pos!([0xdb54, 0xdf16, 0xd880, 0xdee0, 0xdb6a, 0xdd45],\n+             [0xd91f, 0xdeb1, 0xdb31, 0xdd84, 0xd8e2, 0xde14],\n+             [0xdb9f, 0xdc26, 0xdb6f, 0xde58, 0xd850, 0xdfae]);\n+\n+        // mixtures (also random)\n+        pos!([0xd921, 0xdcc2, 0x002d, 0x004d, 0xdb32, 0xdf65],\n+             [0xdb45, 0xdd2d, 0x006a, 0xdacd, 0xddfe, 0x0006],\n+             [0x0067, 0xd8ff, 0xddb7, 0x000f, 0xd900, 0xdc80]);\n+\n+        // negative tests\n+        macro_rules! neg ( ($($e:expr),*) => { { $(assert!(!is_utf16($e));)* } });\n+\n+        neg!(\n+            // surrogate + regular unit\n+            [0xdb45, 0x0000],\n+            // surrogate + lead surrogate\n+            [0xd900, 0xd900],\n+            // unterminated surrogate\n+            [0xd8ff],\n+            // trail surrogate without a lead\n+            [0xddb7]);\n+\n+        // random byte sequences that Python 3's .decode('utf-16be')\n+        // failed on\n+        neg!([0x5b3d, 0x0141, 0xde9e, 0x8fdc, 0xc6e7],\n+             [0xdf5a, 0x82a5, 0x62b9, 0xb447, 0x92f3],\n+             [0xda4e, 0x42bc, 0x4462, 0xee98, 0xc2ca],\n+             [0xbe00, 0xb04a, 0x6ecb, 0xdd89, 0xe278],\n+             [0x0465, 0xab56, 0xdbb6, 0xa893, 0x665e],\n+             [0x6b7f, 0x0a19, 0x40f4, 0xa657, 0xdcc5],\n+             [0x9b50, 0xda5e, 0x24ec, 0x03ad, 0x6dee],\n+             [0x8d17, 0xcaa7, 0xf4ae, 0xdf6e, 0xbed7],\n+             [0xdaee, 0x2584, 0x7d30, 0xa626, 0x121a],\n+             [0xd956, 0x4b43, 0x7570, 0xccd6, 0x4f4a],\n+             [0x9dcf, 0x1b49, 0x4ba5, 0xfce9, 0xdffe],\n+             [0x6572, 0xce53, 0xb05a, 0xf6af, 0xdacf],\n+             [0x1b90, 0x728c, 0x9906, 0xdb68, 0xf46e],\n+             [0x1606, 0xbeca, 0xbe76, 0x860f, 0xdfa5],\n+             [0x8b4f, 0xde7a, 0xd220, 0x9fac, 0x2b6f],\n+             [0xb8fe, 0xebbe, 0xda32, 0x1a5f, 0x8b8b],\n+             [0x934b, 0x8956, 0xc434, 0x1881, 0xddf7],\n+             [0x5a95, 0x13fc, 0xf116, 0xd89b, 0x93f9],\n+             [0xd640, 0x71f1, 0xdd7d, 0x77eb, 0x1cd8],\n+             [0x348b, 0xaef0, 0xdb2c, 0xebf1, 0x1282],\n+             [0x50d7, 0xd824, 0x5010, 0xb369, 0x22ea]);\n+    }\n+\n     #[test]\n     fn test_raw_from_c_str() {\n         unsafe {\n@@ -3666,10 +3725,11 @@ mod tests {\n \n         for p in pairs.iter() {\n             let (s, u) = (*p).clone();\n-            assert!(s.to_utf16() == u);\n-            assert!(from_utf16(u) == s);\n-            assert!(from_utf16(s.to_utf16()) == s);\n-            assert!(from_utf16(u).to_utf16() == u);\n+            assert!(is_utf16(u));\n+            assert_eq!(s.to_utf16(), u);\n+            assert_eq!(from_utf16(u), s);\n+            assert_eq!(from_utf16(s.to_utf16()), s);\n+            assert_eq!(from_utf16(u).to_utf16(), u);\n         }\n     }\n "}]}