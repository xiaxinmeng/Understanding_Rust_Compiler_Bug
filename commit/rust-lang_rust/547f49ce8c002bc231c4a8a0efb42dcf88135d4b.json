{"sha": "547f49ce8c002bc231c4a8a0efb42dcf88135d4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0N2Y0OWNlOGMwMDJiYzIzMWM0YThhMGVmYjQyZGNmODgxMzVkNGI=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-08-07T20:44:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-07T20:44:20Z"}, "message": "Merge pull request #288 from RalfJung/mir-validate\n\nRe-do memory locking", "tree": {"sha": "cba5d5259980abaf64e441e16f34cc662adcd627", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cba5d5259980abaf64e441e16f34cc662adcd627"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/547f49ce8c002bc231c4a8a0efb42dcf88135d4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/547f49ce8c002bc231c4a8a0efb42dcf88135d4b", "html_url": "https://github.com/rust-lang/rust/commit/547f49ce8c002bc231c4a8a0efb42dcf88135d4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a98a68b2cb263abcc1763a40375ba994bc9ee39a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a98a68b2cb263abcc1763a40375ba994bc9ee39a", "html_url": "https://github.com/rust-lang/rust/commit/a98a68b2cb263abcc1763a40375ba994bc9ee39a"}, {"sha": "847396e41242b1768afed38614ca927ec481efca", "url": "https://api.github.com/repos/rust-lang/rust/commits/847396e41242b1768afed38614ca927ec481efca", "html_url": "https://github.com/rust-lang/rust/commit/847396e41242b1768afed38614ca927ec481efca"}], "stats": {"total": 546, "additions": 384, "deletions": 162}, "files": [{"sha": "7cfff2d9810b761be4a494803f81bace73dae9de", "filename": "src/librustc_mir/interpret/error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ferror.rs?ref=547f49ce8c002bc231c4a8a0efb42dcf88135d4b", "patch": "@@ -5,7 +5,7 @@ use rustc::mir;\n use rustc::ty::{FnSig, Ty, layout};\n \n use super::{\n-    MemoryPointer, LockInfo, AccessKind\n+    MemoryPointer, Lock, AccessKind\n };\n \n use rustc_const_math::ConstMathErr;\n@@ -84,23 +84,23 @@ pub enum EvalErrorKind<'tcx> {\n         len: u64,\n         frame: usize,\n         access: AccessKind,\n-        lock: LockInfo,\n+        lock: Lock,\n     },\n     MemoryAcquireConflict {\n         ptr: MemoryPointer,\n         len: u64,\n         kind: AccessKind,\n-        lock: LockInfo,\n+        lock: Lock,\n     },\n     InvalidMemoryLockRelease {\n         ptr: MemoryPointer,\n         len: u64,\n         frame: usize,\n-        lock: LockInfo,\n+        lock: Lock,\n     },\n     DeallocatedLockedMemory {\n         ptr: MemoryPointer,\n-        lock: LockInfo,\n+        lock: Lock,\n     },\n     ValidationFailure(String),\n     CalledClosureAsFunction,"}, {"sha": "88fd254a2f25ecc410b244b963337f61a24ac93d", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 173, "deletions": 127, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=547f49ce8c002bc231c4a8a0efb42dcf88135d4b", "patch": "@@ -1,6 +1,6 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n-use std::{fmt, iter, ptr, mem, io, ops};\n+use std::{fmt, iter, ptr, mem, io};\n use std::cell::Cell;\n \n use rustc::ty;\n@@ -13,66 +13,13 @@ use super::{\n     PrimVal, Pointer,\n     EvalContext, DynamicLifetime,\n     Machine,\n+    RangeMap,\n };\n \n ////////////////////////////////////////////////////////////////////////////////\n // Locks\n ////////////////////////////////////////////////////////////////////////////////\n \n-mod range {\n-    use super::*;\n-\n-    // The derived `Ord` impl sorts first by the first field, then, if the fields are the same,\n-    // by the second field.\n-    // This is exactly what we need for our purposes, since a range query on a BTReeSet/BTreeMap will give us all\n-    // `MemoryRange`s whose `start` is <= than the one we're looking for, but not > the end of the range we're checking.\n-    // At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n-    // This kind of search breaks, if `end < start`, so don't do that!\n-    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n-    pub struct MemoryRange {\n-        start: u64,\n-        end: u64,\n-    }\n-\n-    impl MemoryRange {\n-        pub fn new(offset: u64, len: u64) -> MemoryRange {\n-            assert!(len > 0);\n-            MemoryRange {\n-                start: offset,\n-                end: offset + len,\n-            }\n-        }\n-\n-        pub fn range(offset: u64, len: u64) -> ops::Range<MemoryRange> {\n-            assert!(len > 0);\n-            // We select all elements that are within\n-            // the range given by the offset into the allocation and the length.\n-            // This is sound if \"self.contains() || self.overlaps() == true\" implies that self is in-range.\n-            let left = MemoryRange {\n-                start: 0,\n-                end: offset,\n-            };\n-            let right = MemoryRange {\n-                start: offset + len + 1,\n-                end: 0,\n-            };\n-            left..right\n-        }\n-\n-        pub fn contained_in(&self, offset: u64, len: u64) -> bool {\n-            assert!(len > 0);\n-            offset <= self.start && self.end <= (offset + len)\n-        }\n-\n-        pub fn overlaps(&self, offset: u64, len: u64) -> bool {\n-            assert!(len > 0);\n-            //let non_overlap = (offset + len) <= self.start || self.end <= offset;\n-            (offset + len) > self.start && self.end > offset\n-        }\n-    }\n-}\n-use self::range::*;\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum AccessKind {\n     Read,\n@@ -81,18 +28,51 @@ pub enum AccessKind {\n \n /// Information about a lock that is currently held.\n #[derive(Clone, Debug)]\n-pub enum LockInfo {\n+struct LockInfo {\n+    suspended: Vec<SuspendedWriteLock>,\n+    active: Lock,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct SuspendedWriteLock  {\n+    /// Original lifetime of the lock that is now suspended\n+    lft: DynamicLifetime,\n+    /// Regions that all have to end to reenable this suspension\n+    suspensions: Vec<CodeExtent>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum Lock {\n+    NoLock,\n     WriteLock(DynamicLifetime),\n     ReadLock(Vec<DynamicLifetime>), // This should never be empty -- that would be a read lock held and nobody there to release it...\n }\n-use self::LockInfo::*;\n+use self::Lock::*;\n+\n+impl Default for LockInfo {\n+    fn default() -> Self {\n+        LockInfo::new(NoLock)\n+    }\n+}\n \n impl LockInfo {\n+    fn new(lock: Lock) -> LockInfo {\n+        LockInfo { suspended: Vec::new(), active: lock }\n+    }\n+\n     fn access_permitted(&self, frame: Option<usize>, access: AccessKind) -> bool {\n         use self::AccessKind::*;\n-        match (self, access) {\n-            (&ReadLock(_), Read) => true, // Read access to read-locked region is okay, no matter who's holding the read lock.\n-            (&WriteLock(ref lft), _) if Some(lft.frame) == frame => true, // All access is okay when we hold the write lock.\n+        match (&self.active, access) {\n+            (&NoLock, _) => true,\n+            (&ReadLock(ref lfts), Read) => {\n+                assert!(!lfts.is_empty(), \"Someone left an empty read lock behind.\");\n+                // Read access to read-locked region is okay, no matter who's holding the read lock.\n+                true\n+            },\n+            (&WriteLock(ref lft), _) => {\n+                // All access is okay if we are the ones holding it\n+                Some(lft.frame) == frame\n+            },\n             _ => false, // Nothing else is okay.\n         }\n     }\n@@ -130,25 +110,15 @@ pub struct Allocation<M> {\n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n     pub kind: Kind<M>,\n     /// Memory regions that are locked by some function\n-    locks: BTreeMap<MemoryRange, LockInfo>,\n+    locks: RangeMap<LockInfo>,\n }\n \n impl<M> Allocation<M> {\n-    fn iter_locks<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=(&'a MemoryRange, &'a LockInfo)> + 'a {\n-        self.locks.range(MemoryRange::range(offset, len))\n-            .filter(move |&(range, _)| range.overlaps(offset, len))\n-    }\n-\n-    fn iter_locks_mut<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item=(&'a MemoryRange, &'a mut LockInfo)> + 'a {\n-        self.locks.range_mut(MemoryRange::range(offset, len))\n-            .filter(move |&(range, _)| range.overlaps(offset, len))\n-    }\n-\n     fn check_locks<'tcx>(&self, frame: Option<usize>, offset: u64, len: u64, access: AccessKind) -> Result<(), LockInfo> {\n         if len == 0 {\n             return Ok(())\n         }\n-        for (_, lock) in self.iter_locks(offset, len) {\n+        for lock in self.locks.iter(offset, len) {\n             // Check if the lock is in conflict with the access.\n             if !lock.access_permitted(frame, access) {\n                 return Err(lock.clone());\n@@ -328,7 +298,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             align,\n             kind,\n             mutable: Mutability::Mutable,\n-            locks: BTreeMap::new(),\n+            locks: RangeMap::new(),\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n@@ -385,7 +355,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         // lock by another frame.  We *have* to permit deallocation if we hold a read lock.\n         // TODO: Figure out the exact rules here.\n         alloc.check_locks(Some(self.cur_frame), 0, alloc.bytes.len() as u64, AccessKind::Read)\n-            .map_err(|lock| EvalErrorKind::DeallocatedLockedMemory { ptr, lock })?;\n+            .map_err(|lock| EvalErrorKind::DeallocatedLockedMemory { ptr, lock: lock.active })?;\n \n         if alloc.kind != kind {\n             return err!(DeallocatedWrongMemoryKind(format!(\"{:?}\", alloc.kind), format!(\"{:?}\", kind)));\n@@ -465,70 +435,146 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let frame = self.cur_frame;\n         alloc.check_locks(Some(frame), ptr.offset, len, access)\n-            .map_err(|lock| EvalErrorKind::MemoryLockViolation { ptr, len, frame, access, lock }.into())\n+            .map_err(|lock| EvalErrorKind::MemoryLockViolation { ptr, len, frame, access, lock: lock.active }.into())\n     }\n \n     /// Acquire the lock for the given lifetime\n     pub(crate) fn acquire_lock(&mut self, ptr: MemoryPointer, len: u64, region: Option<CodeExtent>, kind: AccessKind) -> EvalResult<'tcx> {\n-        use std::collections::btree_map::Entry::*;\n-\n         let frame = self.cur_frame;\n         assert!(len > 0);\n         trace!(\"Frame {} acquiring {:?} lock at {:?}, size {} for region {:?}\", frame, kind, ptr, len, region);\n         self.check_bounds(ptr.offset(len, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n \n-        // Check if this conflicts with other locks\n-        alloc.check_locks(None, ptr.offset, len, kind)\n-            .map_err(|lock| EvalErrorKind::MemoryAcquireConflict { ptr, len, kind, lock })?;\n-\n+        // Iterate over our range and acquire the lock.  If the range is already split into pieces,\n+        // we have to manipulate all of them.\n         let lifetime = DynamicLifetime { frame, region };\n-        match (alloc.locks.entry(MemoryRange::new(ptr.offset, len)), kind) {\n-            (Vacant(entry), AccessKind::Read) => { entry.insert(ReadLock(vec![lifetime])); },\n-            (Vacant(entry), AccessKind::Write) => { entry.insert(WriteLock(lifetime)); },\n-            (Occupied(mut entry), AccessKind::Read) =>\n-                match *entry.get_mut() {\n-                    ReadLock(ref mut lifetimes) => lifetimes.push(lifetime),\n-                    WriteLock(_) => bug!(\"We already checked that there is no conflicting write lock\"),\n-                },\n-            (Occupied(_), AccessKind::Write) => bug!(\"We already checked that there is no conflicting lock\"),\n+        for lock in alloc.locks.iter_mut(ptr.offset, len) {\n+            if !lock.access_permitted(None, kind) {\n+                return err!(MemoryAcquireConflict { ptr, len, kind, lock: lock.active.clone() });\n+            }\n+            // See what we have to do\n+            match (&mut lock.active, kind) {\n+                (active @ &mut NoLock, AccessKind::Write) => {\n+                    *active = WriteLock(lifetime);\n+                }\n+                (active @ &mut NoLock, AccessKind::Read) => {\n+                    *active = ReadLock(vec![lifetime]);\n+                }\n+                (&mut ReadLock(ref mut lifetimes), AccessKind::Read) => {\n+                    lifetimes.push(lifetime);\n+                }\n+                _ => bug!(\"We already checked that there is no conflicting lock\"),\n+            }\n         };\n         Ok(())\n     }\n \n-    /// Release a write lock prematurely. If there's a read lock or someone else's lock, fail.\n-    pub(crate) fn release_write_lock(&mut self, ptr: MemoryPointer, len: u64) -> EvalResult<'tcx> {\n+    /// Release or suspend a write lock of the given lifetime prematurely.\n+    /// When releasing, if there is no write lock or someone else's write lock, that's an error.\n+    /// When suspending, the same cases are fine; we just register an additional suspension.\n+    pub(crate) fn release_write_lock(&mut self, ptr: MemoryPointer, len: u64,\n+                                     lock_region: Option<CodeExtent>, suspend: Option<CodeExtent>) -> EvalResult<'tcx> {\n         assert!(len > 0);\n         let cur_frame = self.cur_frame;\n+        let lock_lft = DynamicLifetime { frame: cur_frame, region: lock_region };\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n \n-        let mut remove_list : Vec<MemoryRange> = Vec::new();\n-        for (range, lock) in alloc.iter_locks_mut(ptr.offset, len) {\n-            match *lock {\n-                WriteLock(ref lft) => {\n-                    // Make sure we can release this lock\n-                    if lft.frame != cur_frame {\n-                        return err!(InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.clone() });\n+        'locks: for lock in alloc.locks.iter_mut(ptr.offset, len) {\n+            trace!(\"Releasing {:?}\", lock);\n+            let is_our_lock = match lock.active {\n+                WriteLock(lft) => {\n+                    lft == lock_lft\n+                }\n+                ReadLock(_) | NoLock => {\n+                    false\n+                }\n+            };\n+            if is_our_lock {\n+                // Disable the lock\n+                lock.active = NoLock;\n+            }\n+            match suspend {\n+                Some(suspend_region) => {\n+                    if is_our_lock {\n+                        // We just released this lock, so add a new suspension\n+                        lock.suspended.push(SuspendedWriteLock { lft: lock_lft, suspensions: vec![suspend_region] });\n+                    } else {\n+                        // Find our lock in the suspended ones\n+                        for suspended_lock in lock.suspended.iter_mut().rev() {\n+                            if suspended_lock.lft == lock_lft {\n+                                // Found it!\n+                                suspended_lock.suspensions.push(suspend_region);\n+                                continue 'locks;\n+                            }\n+                        }\n+                        // We did not find it.  Someone else had the lock and we have not suspended it, that's just wrong.\n+                        return err!(InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.active.clone() });\n                     }\n-                    if !range.contained_in(ptr.offset, len) {\n-                        return err!(Unimplemented(format!(\"miri does not support releasing part of a write-locked region\")));\n+                }\n+                None => {\n+                    // If we do not suspend, make sure we actually released something\n+                    if !is_our_lock {\n+                        return err!(InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.active.clone() });\n                     }\n-                    // Release it later.  We cannot do this now.\n-                    remove_list.push(*range);\n                 }\n-                ReadLock(_) => {\n-                    // Abort here and bubble the error outwards so that we do not even register a suspension.\n-                    return err!(InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.clone() });\n-                },\n             }\n         }\n \n-        for range in remove_list {\n-            trace!(\"Releasing {:?}\", alloc.locks[&range]);\n-            alloc.locks.remove(&range);\n-        }\n+        Ok(())\n+    }\n \n-        // TODO: Test that we actually released a write lock for the entire covered region.\n+    /// Release a suspension from the write lock.  If this is the last suspension or if there is no suspension, acquire the lock.\n+    pub(crate) fn recover_write_lock(&mut self, ptr: MemoryPointer, len: u64,\n+                                     lock_region: Option<CodeExtent>, suspended_region: CodeExtent, )\n+        -> EvalResult<'tcx>\n+    {\n+        assert!(len > 0);\n+        let cur_frame = self.cur_frame;\n+        let lock_lft = DynamicLifetime { frame: cur_frame, region: lock_region };\n+        let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n+\n+        for lock in alloc.locks.iter_mut(ptr.offset, len) {\n+            // If we have a suspension here, it will be the topmost one\n+            let (got_the_lock, pop_suspension) = match lock.suspended.last_mut() {\n+                None => (true, false),\n+                Some(suspended_lock) => {\n+                    if suspended_lock.lft == lock_lft {\n+                        // That's us!  Remove suspension (it should be in there).  The same suspension can\n+                        // occur multiple times (when there are multiple shared borrows of this that have the same\n+                        // lifetime); only remove one of them.\n+                        let idx = match suspended_lock.suspensions.iter().enumerate().find(|&(_, re)| re == &suspended_region) {\n+                            None => // TODO: Can the user trigger this?\n+                                bug!(\"We have this lock suspended, but not for the given region.\"),\n+                            Some((idx, _)) => idx\n+                        };\n+                        suspended_lock.suspensions.remove(idx);\n+                        let got_lock = suspended_lock.suspensions.is_empty();\n+                        (got_lock, got_lock)\n+                    } else {\n+                        // Someone else's suspension up top, we should be able to grab the lock\n+                        (true, false)\n+                    }\n+                }\n+            };\n+            if pop_suspension { // with NLL; we could do that up in the match above...\n+                lock.suspended.pop();\n+            } else {\n+                // Sanity check: Our lock should not be in the suspension list\n+                let found = lock.suspended.iter().find(|suspended_lock| suspended_lock.lft == lock_lft);\n+                assert!(found.is_none());\n+            }\n+            if got_the_lock {\n+                match lock.active {\n+                    ref mut active @ NoLock => {\n+                        *active = WriteLock(lock_lft);\n+                    }\n+                    _ => {\n+                        return err!(MemoryAcquireConflict { ptr, len, kind: AccessKind::Write, lock: lock.active.clone() })\n+                    }\n+                }\n+            }\n+        }\n \n         Ok(())\n     }\n@@ -549,28 +595,28 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         };\n \n         for alloc in self.alloc_map.values_mut() {\n-            // Collect things for removal as we cannot remove while iterating\n-            let mut remove_list : Vec<MemoryRange> = Vec::new();\n-            for (range, lock) in alloc.locks.iter_mut() {\n+            for lock in alloc.locks.iter_mut_all() {\n                 // Delete everything that ends now -- i.e., keep only all the other lifetimes.\n-                match *lock {\n+                let lock_ended = match lock.active {\n                     WriteLock(ref lft) => {\n-                        if has_ended(lft) {\n-                            remove_list.push(*range);\n-                        }\n+                        has_ended(lft)\n                     }\n                     ReadLock(ref mut lfts) => {\n                         lfts.retain(|lft| !has_ended(lft));\n-                        if lfts.is_empty() {\n-                            remove_list.push(*range);\n-                        }\n-                    },\n+                        lfts.is_empty()\n+                    }\n+                    NoLock => false,\n+                };\n+                if lock_ended {\n+                    lock.active = NoLock;\n                 }\n+                // Also clean up suspended write locks\n+                lock.suspended.retain(|suspended_lock| !has_ended(&suspended_lock.lft));\n             }\n-            // Perform delayed removal\n-            for range in remove_list {\n-                alloc.locks.remove(&range);\n-            }\n+            // Clean up the map\n+            alloc.locks.retain(|lock| {\n+                match lock.active { NoLock => lock.suspended.len() > 0, _ => true }\n+            });\n         }\n     }\n }"}, {"sha": "39a0c7d25f9e7a3c3dfa9bf5f28584cfb41d3514", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=547f49ce8c002bc231c4a8a0efb42dcf88135d4b", "patch": "@@ -14,6 +14,7 @@ mod validation;\n mod machine;\n mod memory;\n mod operator;\n+mod range_map;\n mod step;\n mod terminator;\n mod traits;\n@@ -51,10 +52,14 @@ pub use self::memory::{\n \n use self::memory::{\n     PointerArithmetic,\n-    LockInfo,\n+    Lock,\n     AccessKind,\n };\n \n+use self::range_map::{\n+    RangeMap\n+};\n+\n pub use self::value::{\n     PrimVal,\n     PrimValKind,"}, {"sha": "7c8debc270d0c1b2e1be7bb61b1f5e76481cec8f", "filename": "src/librustc_mir/interpret/range_map.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs?ref=547f49ce8c002bc231c4a8a0efb42dcf88135d4b", "patch": "@@ -0,0 +1,149 @@\n+//! Implements a map from disjoint non-empty integer ranges to data associated with those ranges\n+use std::collections::{BTreeMap};\n+use std::ops;\n+\n+#[derive(Clone, Debug)]\n+pub struct RangeMap<T> {\n+    map: BTreeMap<Range, T>\n+}\n+\n+// The derived `Ord` impl sorts first by the first field, then, if the fields are the same,\n+// by the second field.\n+// This is exactly what we need for our purposes, since a range query on a BTReeSet/BTreeMap will give us all\n+// `MemoryRange`s whose `start` is <= than the one we're looking for, but not > the end of the range we're checking.\n+// At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n+// This kind of search breaks, if `end < start`, so don't do that!\n+#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n+struct Range {\n+    start: u64,\n+    end: u64, // Invariant: end > start\n+}\n+\n+impl Range {\n+    fn range(offset: u64, len: u64) -> ops::Range<Range> {\n+        // We select all elements that are within\n+        // the range given by the offset into the allocation and the length.\n+        // This is sound if all ranges that intersect with the argument range, are in the\n+        // resulting range of ranges.\n+        let left = Range { // lowest range to include `offset`\n+            start: 0,\n+            end: offset + 1,\n+        };\n+        let right = Range { // lowest (valid) range not to include `offset+len`\n+            start: offset + len,\n+            end: offset + len + 1,\n+        };\n+        left..right\n+    }\n+\n+    fn overlaps(&self, offset: u64, len: u64) -> bool {\n+        assert!(len > 0);\n+        offset < self.end && offset+len >= self.start\n+    }\n+}\n+\n+impl<T> RangeMap<T> {\n+    pub fn new() -> RangeMap<T> {\n+        RangeMap { map: BTreeMap::new() }\n+    }\n+\n+    fn iter_with_range<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=(&'a Range, &'a T)> + 'a {\n+        self.map.range(Range::range(offset, len))\n+            .filter_map(move |(range, data)| {\n+                if range.overlaps(offset, len) {\n+                    Some((range, data))\n+                } else {\n+                    None\n+                }\n+            })\n+    }\n+\n+    pub fn iter<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=&'a T> + 'a {\n+        self.iter_with_range(offset, len).map(|(_, data)| data)\n+    }\n+\n+    fn split_entry_at(&mut self, offset: u64) where T: Clone {\n+        let range = match self.iter_with_range(offset, 0).next() {\n+            Some((&range, _)) => range,\n+            None => return,\n+        };\n+        assert!(range.start <= offset && range.end > offset, \"We got a range that doesn't even contain what we asked for.\");\n+        // There is an entry overlapping this position, see if we have to split it\n+        if range.start < offset {\n+            let data = self.map.remove(&range).unwrap();\n+            let old = self.map.insert(Range { start: range.start, end: offset }, data.clone());\n+            assert!(old.is_none());\n+            let old = self.map.insert(Range { start: offset, end: range.end }, data);\n+            assert!(old.is_none());\n+        }\n+    }\n+\n+    pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item=&'a mut T> + 'a {\n+        self.map.values_mut()\n+    }\n+\n+    /// Provide mutable iteration over everything in the given range.  As a side-effect,\n+    /// this will split entries in the map that are only partially hit by the given range,\n+    /// to make sure that when they are mutated, the effect is constrained to the given range.\n+    pub fn iter_mut_with_gaps<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item=&'a mut T> + 'a\n+        where T: Clone\n+    {\n+        // Preparation: Split first and last entry as needed.\n+        self.split_entry_at(offset);\n+        self.split_entry_at(offset+len);\n+        // Now we can provide a mutable iterator\n+        self.map.range_mut(Range::range(offset, len))\n+            .filter_map(move |(&range, data)| {\n+                if range.overlaps(offset, len) {\n+                    assert!(offset <= range.start && offset+len >= range.end, \"The splitting went wrong\");\n+                    Some(data)\n+                } else {\n+                    // Skip this one\n+                    None\n+                }\n+            })\n+    }\n+\n+    /// Provide a mutable iterator over everything in the given range, with the same side-effects as\n+    /// iter_mut_with_gaps.  Furthermore, if there are gaps between ranges, fill them with the given default.\n+    /// This is also how you insert.\n+    pub fn iter_mut<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item=&'a mut T> + 'a\n+        where T: Clone + Default\n+    {\n+        // Do a first iteration to collect the gaps\n+        let mut gaps = Vec::new();\n+        let mut last_end = None;\n+        for (range, _) in self.iter_with_range(offset, len) {\n+            if let Some(last_end) = last_end {\n+                if last_end < range.start {\n+                    gaps.push(Range { start: last_end, end: range.start });\n+                }\n+            }\n+            last_end = Some(range.end);\n+        }\n+\n+        // Add default for all gaps\n+        for gap in gaps {\n+            let old = self.map.insert(gap, Default::default());\n+            assert!(old.is_none());\n+        }\n+\n+        // Now provide mutable iteration\n+        self.iter_mut_with_gaps(offset, len)\n+    }\n+\n+    pub fn retain<F>(&mut self, mut f: F)\n+        where F: FnMut(&T) -> bool\n+    {\n+        let mut remove = Vec::new();\n+        for (range, data) in self.map.iter() {\n+            if !f(data) {\n+                remove.push(*range);\n+            }\n+        }\n+\n+        for range in remove {\n+            self.map.remove(&range);\n+        }\n+    }\n+}"}, {"sha": "83931535e599e143dc556ab39c6075bc0fee923e", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=547f49ce8c002bc231c4a8a0efb42dcf88135d4b", "patch": "@@ -10,7 +10,7 @@ use rustc::middle::region::CodeExtent;\n use super::{\n     EvalError, EvalResult, EvalErrorKind,\n     EvalContext, DynamicLifetime,\n-    AccessKind, LockInfo,\n+    AccessKind,\n     Value,\n     Lvalue, LvalueExtra,\n     Machine,\n@@ -23,15 +23,15 @@ enum ValidationMode {\n     Acquire,\n     /// Recover because the given region ended\n     Recover(CodeExtent),\n-    Release\n+    ReleaseUntil(Option<CodeExtent>),\n }\n \n impl ValidationMode {\n     fn acquiring(self) -> bool {\n         use self::ValidationMode::*;\n         match self {\n             Acquire | Recover(_) => true,\n-            Release => false,\n+            ReleaseUntil(_) => false,\n         }\n     }\n }\n@@ -81,34 +81,20 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let lval = self.eval_lvalue(&operand.lval)?;\n         let query = ValidationQuery { lval, ty, re: operand.re, mutbl: operand.mutbl };\n \n+        // Check the mode, and also perform mode-specific operations\n         let mode = match op {\n             ValidationOp::Acquire => ValidationMode::Acquire,\n-            ValidationOp::Release => ValidationMode::Release,\n-            ValidationOp::Suspend(_) => ValidationMode::Release,\n-        };\n-        match self.validate(query.clone(), mode) {\n-            Err(EvalError { kind: EvalErrorKind::InvalidMemoryLockRelease { lock: LockInfo::ReadLock(_), .. }, .. }) => {\n-                // HACK: When &x is used while x is already borrowed read-only, AddValidation still\n-                // emits suspension.  This code is legit, so just ignore the error *and*\n-                // do NOT register a suspension.\n-                // TODO: Integrate AddValidation better with borrowck so that we can/ not emit\n-                // these wrong validation statements.  This is all pretty fragile right now.\n-                return Ok(());\n-            }\n-            res => res,\n-        }?;\n-        // Now that we are here, we know things went well.  Time to register the suspension.\n-        match op {\n+            ValidationOp::Release => ValidationMode::ReleaseUntil(None),\n             ValidationOp::Suspend(ce) => {\n                 if query.mutbl == MutMutable {\n                     let lft = DynamicLifetime { frame: self.cur_frame(), region: Some(ce) };\n                     trace!(\"Suspending {:?} until {:?}\", query, ce);\n-                    self.suspended.entry(lft).or_insert_with(Vec::new).push(query);\n+                    self.suspended.entry(lft).or_insert_with(Vec::new).push(query.clone());\n                 }\n+                ValidationMode::ReleaseUntil(Some(ce))\n             }\n-            _ => {}\n         };\n-        Ok(())\n+        self.validate(query, mode)\n     }\n \n     pub(crate) fn end_region(&mut self, ce: CodeExtent) -> EvalResult<'tcx> {\n@@ -162,7 +148,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // TODO: Ideally we would know whether the destination is already initialized, and only\n             // release if it is.\n             res @ Err(EvalError{ kind: EvalErrorKind::ReadUndefBytes, ..}) => {\n-                if let ValidationMode::Release = mode {\n+                if !mode.acquiring() {\n                     return Ok(());\n                 }\n                 res\n@@ -182,8 +168,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             return Ok(());\n         }\n         // When we recover, we may see data whose validity *just* ended.  Do not acquire it.\n-        if let ValidationMode::Recover(ce) = mode {\n-            if Some(ce) == query.re {\n+        if let ValidationMode::Recover(ending_ce) = mode {\n+            if query.re == Some(ending_ce) {\n                 return Ok(());\n             }\n         }\n@@ -249,10 +235,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     if len > 0 {\n                         let ptr = ptr.to_ptr()?;\n                         let access = match query.mutbl { MutMutable => AccessKind::Write, MutImmutable => AccessKind::Read };\n-                        if mode.acquiring() {\n-                            self.memory.acquire_lock(ptr, len, query.re, access)?;\n-                        } else {\n-                            self.memory.release_write_lock(ptr, len)?;\n+                        match mode {\n+                            ValidationMode::Acquire => self.memory.acquire_lock(ptr, len, query.re, access)?,\n+                            ValidationMode::Recover(ending_ce) => self.memory.recover_write_lock(ptr, len, query.re, ending_ce)?,\n+                            ValidationMode::ReleaseUntil(suspended_ce) => self.memory.release_write_lock(ptr, len, query.re, suspended_ce)?,\n                         }\n                     }\n                 }"}, {"sha": "494c07950ab8638788a5d2eaedcf41822f7b438a", "filename": "tests/run-pass/many_shr_bor.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/tests%2Frun-pass%2Fmany_shr_bor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547f49ce8c002bc231c4a8a0efb42dcf88135d4b/tests%2Frun-pass%2Fmany_shr_bor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmany_shr_bor.rs?ref=547f49ce8c002bc231c4a8a0efb42dcf88135d4b", "patch": "@@ -0,0 +1,36 @@\n+// Make sure validation can handle many overlapping shared borrows for difference parts of a data structure\n+#![allow(unused_variables)]\n+use std::cell::RefCell;\n+\n+struct Test {\n+    a: u32,\n+    b: u32,\n+}\n+\n+fn test1() {\n+    let t = &mut Test { a: 0, b: 0 };\n+    {\n+        let x;\n+        {\n+            let y = &t.a;\n+            x = &t;\n+            let _y = *y;\n+        }\n+        let _x = x.a;\n+    }\n+    t.b = 42;\n+}\n+\n+fn test2(r: &mut RefCell<i32>) {\n+    let x = &*r; // releasing write lock, first suspension recorded\n+    let mut x_ref = x.borrow_mut();\n+    let x_inner : &mut i32 = &mut *x_ref;\n+    let x_inner_shr = &*x_inner; // releasing inner write lock, recording suspension\n+    let y = &*r; // second suspension for the outer write lock\n+    let x_inner_shr2 = &*x_inner; // 2nd suspension for inner write lock\n+}\n+\n+fn main() {\n+    test1();\n+    test2(&mut RefCell::new(0));\n+}"}]}