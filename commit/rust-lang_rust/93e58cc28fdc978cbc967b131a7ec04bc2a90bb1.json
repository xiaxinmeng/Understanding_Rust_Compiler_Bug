{"sha": "93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZTU4Y2MyOGZkYzk3OGNiYzk2N2IxMzFhN2VjMDRiYzJhOTBiYjE=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-02-09T20:24:11Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-02-12T18:28:42Z"}, "message": "Autoderef in librustc_trans", "tree": {"sha": "14b3694359f2eab0343d5fb7d345ff59979fa731", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14b3694359f2eab0343d5fb7d345ff59979fa731"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "html_url": "https://github.com/rust-lang/rust/commit/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f831d98ba2167ac19966618bfb218856e1eedc63", "url": "https://api.github.com/repos/rust-lang/rust/commits/f831d98ba2167ac19966618bfb218856e1eedc63", "html_url": "https://github.com/rust-lang/rust/commit/f831d98ba2167ac19966618bfb218856e1eedc63"}], "stats": {"total": 527, "additions": 263, "deletions": 264}, "files": [{"sha": "69a70cdf144b35eb494df8c8f51ee0878254d30d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -916,7 +916,7 @@ fn link_natively(sess: &Session, dylib: bool,\n                                          pname,\n                                          prog.status))\n                     .note(&format!(\"{:?}\", &cmd))\n-                    .note(&*escape_string(&output[..]))\n+                    .note(&escape_string(&output[..]))\n                     .emit();\n                 sess.abort_if_errors();\n             }"}, {"sha": "92d8b928ef428bd8673dc25179ff32dc0ddcaa38", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -380,7 +380,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::InlineAsm(inline) => {\n             report_inline_asm(cgcx,\n-                              &*llvm::twine_to_string(inline.message),\n+                              &llvm::twine_to_string(inline.message),\n                               inline.cookie);\n         }\n "}, {"sha": "2b3899ac03ecf84c4f91409ec7b2c23b22c4bec5", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -468,7 +468,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                             &name.as_str(),\n                             &qualname,\n                             &self.span.snippet(expr.span),\n-                            &ty_to_string(&*typ),\n+                            &ty_to_string(&typ),\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -550,7 +550,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n             for field in variant.node.data.fields() {\n                 self.process_struct_field_def(field, variant.node.data.id());\n-                self.visit_ty(&*field.node.ty);\n+                self.visit_ty(&field.node.ty);\n             }\n         }\n         self.process_generic_params(ty_params, item.span, &enum_data.qualname, enum_data.id);\n@@ -970,7 +970,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                           self.cur_scope);\n             }\n             Fn(ref decl, _, _, _, ref ty_params, ref body) =>\n-                self.process_fn(item, &**decl, ty_params, &**body),\n+                self.process_fn(item, &decl, ty_params, &body),\n             Static(ref typ, _, ref expr) =>\n                 self.process_static_or_const_item(item, typ, expr),\n             Const(ref typ, ref expr) =>\n@@ -992,11 +992,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             }\n             Ty(ref ty, ref ty_params) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n-                let value = ty_to_string(&**ty);\n+                let value = ty_to_string(&ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 self.fmt.typedef_str(item.span, sub_span, item.id, &qualname, &value);\n \n-                self.visit_ty(&**ty);\n+                self.visit_ty(&ty);\n                 self.process_generic_params(ty_params, item.span, &qualname, item.id);\n             }\n             Mac(_) => (),\n@@ -1012,7 +1012,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 }\n             }\n             if let Some(ref ty) = param.default {\n-                self.visit_ty(&**ty);\n+                self.visit_ty(&ty);\n             }\n         }\n     }\n@@ -1024,8 +1024,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 self.process_const(trait_item.id,\n                                    trait_item.ident.name,\n                                    trait_item.span,\n-                                   &*ty,\n-                                   &*expr);\n+                                   &ty,\n+                                   &expr);\n             }\n             ast::TraitItemKind::Method(ref sig, ref body) => {\n                 self.process_method(sig,\n@@ -1113,7 +1113,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::TupField(ref sub_ex, idx) => {\n-                self.visit_expr(&**sub_ex);\n+                self.visit_expr(&sub_ex);\n \n                 let hir_node = lower_expr(self.save_ctxt.lcx, sub_ex);\n                 let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n@@ -1139,15 +1139,15 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 // walk arg and return types\n                 for arg in &decl.inputs {\n-                    self.visit_ty(&*arg.ty);\n+                    self.visit_ty(&arg.ty);\n                 }\n \n                 if let ast::FunctionRetTy::Ty(ref ret_ty) = decl.output {\n-                    self.visit_ty(&**ret_ty);\n+                    self.visit_ty(&ret_ty);\n                 }\n \n                 // walk the body\n-                self.nest(ex.id, |v| v.visit_block(&**body));\n+                self.nest(ex.id, |v| v.visit_block(&body));\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n             ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {"}, {"sha": "d336ab21962de01506f27490dffb5c98743d6c4c", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -389,7 +389,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     match item.node {\n                         hir::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from(\"<\");\n-                            result.push_str(&rustc_front::print::pprust::ty_to_string(&**ty));\n+                            result.push_str(&rustc_front::print::pprust::ty_to_string(&ty));\n \n                             match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n                                 Some(def_id) => {"}, {"sha": "70f8e268f1745b30d19d005dbf3ed377c40a8cec", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n         match *self {\n             ConstantValue(ConstantExpr(lit_expr), _) => {\n                 let lit_ty = bcx.tcx().node_id_to_type(lit_expr.id);\n-                let expr = consts::const_expr(ccx, &*lit_expr, bcx.fcx.param_substs, None, Yes);\n+                let expr = consts::const_expr(ccx, &lit_expr, bcx.fcx.param_substs, None, Yes);\n                 let llval = match expr {\n                     Ok((llval, _)) => llval,\n                     Err(err) => bcx.ccx().sess().span_fatal(lit_expr.span, &err.description()),\n@@ -294,18 +294,18 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n             ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n-                let l1 = match consts::const_expr(ccx, &**l1, bcx.fcx.param_substs, None, Yes) {\n+                let l1 = match consts::const_expr(ccx, &l1, bcx.fcx.param_substs, None, Yes) {\n                     Ok((l1, _)) => l1,\n                     Err(err) => bcx.ccx().sess().span_fatal(l1.span, &err.description()),\n                 };\n-                let l2 = match consts::const_expr(ccx, &**l2, bcx.fcx.param_substs, None, Yes) {\n+                let l2 = match consts::const_expr(ccx, &l2, bcx.fcx.param_substs, None, Yes) {\n                     Ok((l2, _)) => l2,\n                     Err(err) => bcx.ccx().sess().span_fatal(l2.span, &err.description()),\n                 };\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }\n             Variant(disr_val, ref repr, _, _) => {\n-                SingleResult(Result::new(bcx, adt::trans_case(bcx, &**repr, disr_val)))\n+                SingleResult(Result::new(bcx, adt::trans_case(bcx, &repr, disr_val)))\n             }\n             SliceLengthEqual(length, _) => {\n                 SingleResult(Result::new(bcx, C_uint(ccx, length)))\n@@ -479,7 +479,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             pat = match pat.node {\n                 hir::PatIdent(_, ref path, Some(ref inner)) => {\n                     bound_ptrs.push((path.node.name, val.val));\n-                    &**inner\n+                    &inner\n                 },\n                 _ => break\n             }\n@@ -489,7 +489,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         pats[col] = pat;\n         Match {\n             pats: pats,\n-            data: &*br.data,\n+            data: &br.data,\n             bound_ptrs: bound_ptrs,\n             pat_renaming_map: br.pat_renaming_map,\n         }\n@@ -518,7 +518,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n                 hir::PatIdent(_, ref path, None) => {\n-                    if pat_is_binding(&dm.borrow(), &*this) {\n+                    if pat_is_binding(&dm.borrow(), &this) {\n                         bound_ptrs.push((path.node.name, val.val));\n                     }\n                 }\n@@ -557,7 +557,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n-        if pat_is_binding_or_wild(&dm.borrow(), &*pats[col]) {\n+        if pat_is_binding_or_wild(&dm.borrow(), &pats[col]) {\n             let mut r = pats[..col].to_vec();\n             r.extend_from_slice(&pats[col + 1..]);\n             Some(r)\n@@ -615,11 +615,11 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n \n     let ctor = match opt {\n         &ConstantValue(ConstantExpr(expr), _) => check_match::ConstantValue(\n-            const_eval::eval_const_expr(bcx.tcx(), &*expr)\n+            const_eval::eval_const_expr(bcx.tcx(), &expr)\n         ),\n         &ConstantRange(ConstantExpr(lo), ConstantExpr(hi), _) => check_match::ConstantRange(\n-            const_eval::eval_const_expr(bcx.tcx(), &*lo),\n-            const_eval::eval_const_expr(bcx.tcx(), &*hi)\n+            const_eval::eval_const_expr(bcx.tcx(), &lo),\n+            const_eval::eval_const_expr(bcx.tcx(), &hi)\n         ),\n         &SliceLengthEqual(n, _) =>\n             check_match::Slice(n),\n@@ -663,7 +663,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let opt = match cur.node {\n             hir::PatLit(ref l) => {\n-                ConstantValue(ConstantExpr(&**l), debug_loc)\n+                ConstantValue(ConstantExpr(&l), debug_loc)\n             }\n             hir::PatIdent(..) | hir::PatEnum(..) | hir::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n@@ -680,7 +680,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n             hir::PatRange(ref l1, ref l2) => {\n-                ConstantRange(ConstantExpr(&**l1), ConstantExpr(&**l2), debug_loc)\n+                ConstantRange(ConstantExpr(&l1), ConstantExpr(&l2), debug_loc)\n             }\n             hir::PatVec(ref before, None, ref after) => {\n                 SliceLengthEqual(before.len() + after.len(), debug_loc)\n@@ -849,7 +849,7 @@ impl FailureHandler {\n fn pick_column_to_specialize(def_map: &RefCell<DefMap>, m: &[Match]) -> Option<usize> {\n     fn pat_score(def_map: &RefCell<DefMap>, pat: &hir::Pat) -> usize {\n         match pat.node {\n-            hir::PatIdent(_, _, Some(ref inner)) => pat_score(def_map, &**inner),\n+            hir::PatIdent(_, _, Some(ref inner)) => pat_score(def_map, &inner),\n             _ if pat_is_refutable(&def_map.borrow(), pat) => 1,\n             _ => 0\n         }\n@@ -1143,7 +1143,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match data.arm.guard {\n                 Some(ref guard_expr) => {\n                     bcx = compile_guard(bcx,\n-                                        &**guard_expr,\n+                                        &guard_expr,\n                                         m[0].data,\n                                         &m[1..m.len()],\n                                         vals,\n@@ -1190,7 +1190,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n     let adt_vals = if any_irrefutable_adt_pat(bcx.tcx(), m, col) {\n         let repr = adt::represent_type(bcx.ccx(), left_ty);\n-        let arg_count = adt::num_args(&*repr, Disr(0));\n+        let arg_count = adt::num_args(&repr, Disr(0));\n         let (arg_count, struct_val) = if type_is_sized(bcx.tcx(), left_ty) {\n             (arg_count, val.val)\n         } else {\n@@ -1202,7 +1202,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         };\n         let mut field_vals: Vec<ValueRef> = (0..arg_count).map(|ix|\n             // By definition, these are all sized\n-            adt::trans_field_ptr(bcx, &*repr, adt::MaybeSizedValue::sized(struct_val), Disr(0), ix)\n+            adt::trans_field_ptr(bcx, &repr, adt::MaybeSizedValue::sized(struct_val), Disr(0), ix)\n         ).collect();\n \n         match left_ty.sty {\n@@ -1218,7 +1218,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 let meta = Load(bcx, expr::get_meta(bcx, val.val));\n                 let struct_val = adt::MaybeSizedValue::unsized_(struct_val, meta);\n \n-                let data = adt::trans_field_ptr(bcx, &*repr, struct_val, Disr(0), arg_count);\n+                let data = adt::trans_field_ptr(bcx, &repr, struct_val, Disr(0), arg_count);\n                 Store(bcx, data, expr::get_dataptr(bcx, scratch));\n                 Store(bcx, meta, expr::get_meta(bcx, scratch));\n                 field_vals.push(scratch);\n@@ -1385,7 +1385,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         match *opt {\n             Variant(disr_val, ref repr, _, _) => {\n                 let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n-                    extract_variant_args(opt_cx, &**repr, disr_val, val);\n+                    extract_variant_args(opt_cx, &repr, disr_val, val);\n                 size = argvals.len();\n                 unpacked = argvals;\n                 opt_cx = new_bcx;\n@@ -1534,7 +1534,7 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &hir::Pat,\n     let tcx = bcx.tcx();\n     let reassigned = is_discr_reassigned(bcx, discr, body);\n     let mut bindings_map = FnvHashMap();\n-    pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n+    pat_bindings(&tcx.def_map, &pat, |bm, p_id, span, path1| {\n         let name = path1.node;\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n@@ -1604,7 +1604,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     let arm_datas: Vec<ArmData> = arms.iter().map(|arm| ArmData {\n         bodycx: fcx.new_id_block(\"case_body\", arm.body.id),\n         arm: arm,\n-        bindings_map: create_bindings_map(bcx, &*arm.pats[0], discr_expr, &*arm.body)\n+        bindings_map: create_bindings_map(bcx, &arm.pats[0], discr_expr, &arm.body)\n     }).collect();\n \n     let mut pat_renaming_map = if scope_cx.sess().opts.debuginfo != NoDebugInfo {\n@@ -1624,7 +1624,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     let mut matches = Vec::new();\n     for (arm_data, pats) in arm_datas.iter().zip(&arm_pats) {\n         matches.extend(pats.iter().map(|p| Match {\n-            pats: vec![&**p],\n+            pats: vec![&p],\n             data: arm_data,\n             bound_ptrs: Vec::new(),\n             pat_renaming_map: pat_renaming_map.as_ref()\n@@ -1651,7 +1651,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         // insert bindings into the lllocals map and add cleanups\n         let cs = fcx.push_custom_cleanup_scope();\n         bcx = insert_lllocals(bcx, &arm_data.bindings_map, Some(cleanup::CustomScope(cs)));\n-        bcx = expr::trans_into(bcx, &*arm_data.arm.body, dest);\n+        bcx = expr::trans_into(bcx, &arm_data.arm.body, dest);\n         bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, cs);\n         arm_cxs.push(bcx);\n     }\n@@ -1668,7 +1668,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"match::store_local\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n-    let pat = &*local.pat;\n+    let pat = &local.pat;\n \n     fn create_dummy_locals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                        pat: &hir::Pat)\n@@ -1723,7 +1723,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     return mk_binding_alloca(\n                         bcx, pat.id, name, var_scope, (),\n                         \"_match::store_local\",\n-                        |(), bcx, Datum { val: v, .. }| expr::trans_into(bcx, &**init_expr,\n+                        |(), bcx, Datum { val: v, .. }| expr::trans_into(bcx, &init_expr,\n                                                                          expr::SaveIn(v)));\n                 }\n \n@@ -1732,7 +1732,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             // General path.\n             let init_datum =\n-                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, &**init_expr, \"let\"));\n+                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, &init_expr, \"let\"));\n             if bcx.sess().asm_comments() {\n                 add_comment(bcx, \"creating zeroable ref llval\");\n             }\n@@ -1813,7 +1813,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n     match pat.node {\n         hir::PatIdent(pat_binding_mode, ref path1, ref inner) => {\n-            if pat_is_binding(&tcx.def_map.borrow(), &*pat) {\n+            if pat_is_binding(&tcx.def_map.borrow(), &pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n                 // map.\n@@ -1846,7 +1846,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n \n             if let Some(ref inner_pat) = *inner {\n-                bcx = bind_irrefutable_pat(bcx, &**inner_pat, val, cleanup_scope);\n+                bcx = bind_irrefutable_pat(bcx, &inner_pat, val, cleanup_scope);\n             }\n         }\n         hir::PatEnum(_, ref sub_pats) => {\n@@ -1856,14 +1856,14 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let repr = adt::represent_node(bcx, pat.id);\n                     let vinfo = ccx.tcx().lookup_adt_def(enum_id).variant_with_id(var_id);\n                     let args = extract_variant_args(bcx,\n-                                                    &*repr,\n+                                                    &repr,\n                                                     Disr::from(vinfo.disr_val),\n                                                     val);\n                     if let Some(ref sub_pat) = *sub_pats {\n                         for (i, &argval) in args.vals.iter().enumerate() {\n                             bcx = bind_irrefutable_pat(\n                                 bcx,\n-                                &*sub_pat[i],\n+                                &sub_pat[i],\n                                 MatchInput::from_val(argval),\n                                 cleanup_scope);\n                         }\n@@ -1879,11 +1879,11 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             let repr = adt::represent_node(bcx, pat.id);\n                             let val = adt::MaybeSizedValue::sized(val.val);\n                             for (i, elem) in elems.iter().enumerate() {\n-                                let fldptr = adt::trans_field_ptr(bcx, &*repr,\n+                                let fldptr = adt::trans_field_ptr(bcx, &repr,\n                                                                   val, Disr(0), i);\n                                 bcx = bind_irrefutable_pat(\n                                     bcx,\n-                                    &**elem,\n+                                    &elem,\n                                     MatchInput::from_val(fldptr),\n                                     cleanup_scope);\n                             }\n@@ -1914,7 +1914,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let field_idx = pat_v.field_index(name);\n                 let mut fldptr = adt::trans_field_ptr(\n                     bcx,\n-                    &*pat_repr,\n+                    &pat_repr,\n                     val,\n                     pat_v.discr,\n                     field_idx);\n@@ -1930,7 +1930,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     fldptr = scratch;\n                 }\n                 bcx = bind_irrefutable_pat(bcx,\n-                                           &*f.node.pat,\n+                                           &f.node.pat,\n                                            MatchInput::from_val(fldptr),\n                                            cleanup_scope);\n             }\n@@ -1939,10 +1939,10 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let repr = adt::represent_node(bcx, pat.id);\n             let val = adt::MaybeSizedValue::sized(val.val);\n             for (i, elem) in elems.iter().enumerate() {\n-                let fldptr = adt::trans_field_ptr(bcx, &*repr, val, Disr(0), i);\n+                let fldptr = adt::trans_field_ptr(bcx, &repr, val, Disr(0), i);\n                 bcx = bind_irrefutable_pat(\n                     bcx,\n-                    &**elem,\n+                    &elem,\n                     MatchInput::from_val(fldptr),\n                     cleanup_scope);\n             }\n@@ -1964,7 +1964,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 val.val\n             };\n             bcx = bind_irrefutable_pat(\n-                bcx, &**inner, MatchInput::from_val(val), cleanup_scope);\n+                bcx, &inner, MatchInput::from_val(val), cleanup_scope);\n         }\n         hir::PatRegion(ref inner, _) => {\n             let pat_ty = node_id_type(bcx, inner.id);\n@@ -1984,7 +1984,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n             bcx = bind_irrefutable_pat(\n                 bcx,\n-                &**inner,\n+                &inner,\n                 MatchInput::from_val(val),\n                 cleanup_scope);\n         }\n@@ -2008,7 +2008,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 .fold(bcx, |bcx, (inner, elem)| {\n                     bind_irrefutable_pat(\n                         bcx,\n-                        &**inner,\n+                        &inner,\n                         MatchInput::from_val(elem),\n                         cleanup_scope)\n                 });"}, {"sha": "33370abc3fcc14e9cd4d1a04f9301611802ed8cc", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -44,10 +44,10 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     for (i, out) in ia.outputs.iter().enumerate() {\n         constraints.push(out.constraint.clone());\n \n-        let out_datum = unpack_datum!(bcx, expr::trans(bcx, &*out.expr));\n+        let out_datum = unpack_datum!(bcx, expr::trans(bcx, &out.expr));\n         if out.is_indirect {\n             bcx = callee::trans_arg_datum(bcx,\n-                                          expr_ty(bcx, &*out.expr),\n+                                          expr_ty(bcx, &out.expr),\n                                           out_datum,\n                                           cleanup::CustomScope(temp_scope),\n                                           callee::DontAutorefArg,\n@@ -61,7 +61,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n             outputs.push(out_datum.val);\n             if out.is_rw {\n                 bcx = callee::trans_arg_datum(bcx,\n-                                              expr_ty(bcx, &*out.expr),\n+                                              expr_ty(bcx, &out.expr),\n                                               out_datum,\n                                               cleanup::CustomScope(temp_scope),\n                                               callee::DontAutorefArg,\n@@ -75,9 +75,9 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     for &(ref c, ref input) in &ia.inputs {\n         constraints.push((*c).clone());\n \n-        let in_datum = unpack_datum!(bcx, expr::trans(bcx, &**input));\n+        let in_datum = unpack_datum!(bcx, expr::trans(bcx, &input));\n         bcx = callee::trans_arg_datum(bcx,\n-                                    expr_ty(bcx, &**input),\n+                                    expr_ty(bcx, &input),\n                                     in_datum,\n                                     cleanup::CustomScope(temp_scope),\n                                     callee::DontAutorefArg,\n@@ -159,4 +159,3 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     return bcx;\n \n }\n-"}, {"sha": "e36905c6d90ea22329419f1cb355540caba45194", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -513,7 +513,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n             let repr = adt::represent_type(cx.ccx(), t);\n             let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n             for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &*repr, value, Disr::from(discr), i);\n+                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr::from(discr), i);\n \n                 let val = if common::type_is_sized(cx.tcx(), field_ty) {\n                     llfld_a\n@@ -529,7 +529,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         ty::TyClosure(_, ref substs) => {\n             let repr = adt::represent_type(cx.ccx(), t);\n             for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n-                let llupvar = adt::trans_field_ptr(cx, &*repr, value, Disr(0), i);\n+                let llupvar = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n                 cx = f(cx, llupvar, upvar_ty);\n             }\n         }\n@@ -545,7 +545,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         ty::TyTuple(ref args) => {\n             let repr = adt::represent_type(cx.ccx(), t);\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &*repr, value, Disr(0), i);\n+                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n                 cx = f(cx, llfld_a, *arg);\n             }\n         }\n@@ -559,11 +559,11 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n             // NB: we must hit the discriminant first so that structural\n             // comparison know not to proceed when the discriminants differ.\n \n-            match adt::trans_switch(cx, &*repr, av, false) {\n+            match adt::trans_switch(cx, &repr, av, false) {\n                 (_match::Single, None) => {\n                     if n_variants != 0 {\n                         assert!(n_variants == 1);\n-                        cx = iter_variant(cx, &*repr, adt::MaybeSizedValue::sized(av),\n+                        cx = iter_variant(cx, &repr, adt::MaybeSizedValue::sized(av),\n                                           &en.variants[0], substs, &mut f);\n                     }\n                 }\n@@ -592,10 +592,10 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                         let variant_cx = fcx.new_temp_block(&format!(\"enum-iter-variant-{}\",\n                                                                      &variant.disr_val\n                                                                              .to_string()));\n-                        let case_val = adt::trans_case(cx, &*repr, Disr::from(variant.disr_val));\n+                        let case_val = adt::trans_case(cx, &repr, Disr::from(variant.disr_val));\n                         AddCase(llswitch, case_val, variant_cx.llbb);\n                         let variant_cx = iter_variant(variant_cx,\n-                                                      &*repr,\n+                                                      &repr,\n                                                       value,\n                                                       variant,\n                                                       substs,\n@@ -1530,7 +1530,7 @@ fn has_nested_returns(tcx: &ty::ctxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bo\n             Some(hir_map::NodeExpr(ex)) => {\n                 if let hir::ExprRet(Some(ref ret_expr)) = ex.node {\n                     let mut visitor = FindNestedReturn::new();\n-                    intravisit::walk_expr(&mut visitor, &**ret_expr);\n+                    intravisit::walk_expr(&mut visitor, &ret_expr);\n                     if visitor.found {\n                         return true;\n                     }\n@@ -2272,7 +2272,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         let repr = adt::represent_type(ccx, result_ty.unwrap());\n         let mut llarg_idx = fcx.arg_offset() as c_uint;\n         for (i, arg_ty) in arg_tys.into_iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(bcx, &*repr, dest_val, Disr::from(disr), i);\n+            let lldestptr = adt::trans_field_ptr(bcx, &repr, dest_val, Disr::from(disr), i);\n             if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n                 Store(bcx,\n                       get_param(fcx.llfn, llarg_idx),\n@@ -2292,7 +2292,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n                 }\n             }\n         }\n-        adt::trans_set_discr(bcx, &*repr, dest, disr);\n+        adt::trans_set_discr(bcx, &repr, dest, disr);\n     }\n \n     finish_fn(&fcx, bcx, result_ty, DebugLoc::None);\n@@ -2346,14 +2346,14 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span,\n \n         let sess = &ccx.tcx().sess;\n         sess.span_note_without_error(sp,\n-                                     &*format!(\"total size: {} bytes\", llsize_of_real(ccx, llty)));\n+                                     &format!(\"total size: {} bytes\", llsize_of_real(ccx, llty)));\n         match *avar {\n             adt::General(..) => {\n                 for (i, var) in enum_def.variants.iter().enumerate() {\n                     ccx.tcx()\n                        .sess\n                        .span_note_without_error(var.span,\n-                                                &*format!(\"variant data: {} bytes\", sizes[i]));\n+                                                &format!(\"variant data: {} bytes\", sizes[i]));\n                 }\n             }\n             _ => {}\n@@ -2505,17 +2505,17 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n                     if abi != Abi::Rust {\n                         foreign::trans_rust_fn_with_foreign_abi(ccx,\n-                                                                &**decl,\n-                                                                &**body,\n+                                                                &decl,\n+                                                                &body,\n                                                                 &item.attrs,\n                                                                 llfn,\n                                                                 empty_substs,\n                                                                 item.id,\n                                                                 None);\n                     } else {\n                         trans_fn(ccx,\n-                                 &**decl,\n-                                 &**body,\n+                                 &decl,\n+                                 &body,\n                                  llfn,\n                                  empty_substs,\n                                  item.id,\n@@ -2837,11 +2837,11 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 hir::ForeignItemFn(..) => {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ccx.tcx().node_id_to_type(ni.id);\n-                    let name = foreign::link_name(&*ni);\n+                    let name = foreign::link_name(&ni);\n                     foreign::register_foreign_item_fn(ccx, abi, ty, &name, &ni.attrs)\n                 }\n                 hir::ForeignItemStatic(..) => {\n-                    foreign::register_static(ccx, &*ni)\n+                    foreign::register_static(ccx, &ni)\n                 }\n             }\n         }"}, {"sha": "e8dd9840fc00583da071138ba20906e550bf1105", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -755,7 +755,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         let mut llargs = Vec::new();\n         let arg_tys = match args {\n-            ArgExprs(a) => a.iter().map(|x| common::expr_ty_adjusted(bcx, &**x)).collect(),\n+            ArgExprs(a) => a.iter().map(|x| common::expr_ty_adjusted(bcx, &x)).collect(),\n             _ => panic!(\"expected arg exprs.\")\n         };\n         bcx = trans_args(bcx,\n@@ -835,7 +835,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n \n     // Translate the `self` argument first.\n     if !ignore_self {\n-        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n+        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n         bcx = trans_arg_datum(bcx,\n                               args[0],\n                               arg_datum,\n@@ -851,14 +851,14 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n     match tuple_type.sty {\n         ty::TyTuple(ref field_types) => {\n             let tuple_datum = unpack_datum!(bcx,\n-                                            expr::trans(bcx, &**tuple_expr));\n+                                            expr::trans(bcx, &tuple_expr));\n             let tuple_lvalue_datum =\n                 unpack_datum!(bcx,\n                               tuple_datum.to_lvalue_datum(bcx,\n                                                           \"args\",\n                                                           tuple_expr.id));\n             let repr = adt::represent_type(bcx.ccx(), tuple_type);\n-            let repr_ptr = &*repr;\n+            let repr_ptr = &repr;\n             for (i, field_type) in field_types.iter().enumerate() {\n                 let arg_datum = tuple_lvalue_datum.get_element(\n                     bcx,\n@@ -971,12 +971,12 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 }\n                 let arg_ty = if i >= num_formal_args {\n                     assert!(variadic);\n-                    common::expr_ty_adjusted(cx, &**arg_expr)\n+                    common::expr_ty_adjusted(cx, &arg_expr)\n                 } else {\n                     arg_tys[i]\n                 };\n \n-                let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &**arg_expr));\n+                let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_expr));\n                 bcx = trans_arg_datum(bcx, arg_ty, arg_datum,\n                                       arg_cleanup_scope,\n                                       DontAutorefArg,"}, {"sha": "b1db196ecef0c850137deb7e78389b141905c3d4", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -243,7 +243,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     for (i, freevar) in freevars.iter().enumerate() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n         let upvar_slot_dest = adt::trans_field_ptr(\n-            bcx, &*repr, adt::MaybeSizedValue::sized(dest_addr), Disr(0), i);\n+            bcx, &repr, adt::MaybeSizedValue::sized(dest_addr), Disr(0), i);\n         let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n                                      closure_expr_id: id };\n         match tcx.upvar_capture(upvar_id).unwrap() {\n@@ -255,7 +255,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n             }\n         }\n     }\n-    adt::trans_set_discr(bcx, &*repr, dest_addr, Disr(0));\n+    adt::trans_set_discr(bcx, &repr, dest_addr, Disr(0));\n \n     Some(bcx)\n }"}, {"sha": "21cb082f0660cd8c179f3c2e64596d106521c842", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -329,7 +329,7 @@ impl<'mir, 'tcx: 'mir> CachedMir<'mir, 'tcx> {\n     fn get_ref<'a>(&'a self) -> &'a mir::Mir<'tcx> {\n         match *self {\n             CachedMir::Ref(r) => r,\n-            CachedMir::Owned(ref rc) => &**rc,\n+            CachedMir::Owned(ref rc) => &rc,\n         }\n     }\n }"}, {"sha": "4f25091d343c85e9984dce0ce2cc05f3e0cbbdb6", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -212,7 +212,7 @@ fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let substs = ccx.tcx().mk_substs(node_id_substs(ccx, node, param_substs));\n     match fn_like.body().expr {\n         Some(ref expr) => {\n-            const_expr(ccx, &**expr, substs, Some(&fn_args), trueconst).map(|(res, _)| res)\n+            const_expr(ccx, &expr, substs, Some(&fn_args), trueconst).map(|(res, _)| res)\n         },\n         None => Ok(C_nil(ccx)),\n     }\n@@ -570,27 +570,27 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let map_list = |exprs: &[P<hir::Expr>]| -> Result<Vec<ValueRef>, ConstEvalFailure> {\n         exprs.iter()\n-             .map(|e| const_expr(cx, &**e, param_substs, fn_args, trueconst).map(|(l, _)| l))\n+             .map(|e| const_expr(cx, &e, param_substs, fn_args, trueconst).map(|(l, _)| l))\n              .collect::<Vec<Result<ValueRef, ConstEvalFailure>>>()\n              .into_iter()\n              .collect()\n          // this dance is necessary to eagerly run const_expr so all errors are reported\n     };\n     let _icx = push_ctxt(\"const_expr\");\n     Ok(match e.node {\n-        hir::ExprLit(ref lit) => const_lit(cx, e, &**lit),\n+        hir::ExprLit(ref lit) => const_lit(cx, e, &lit),\n         hir::ExprBinary(b, ref e1, ref e2) => {\n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n-            let (te1, ty) = try!(const_expr(cx, &**e1, param_substs, fn_args, trueconst));\n+            let (te1, ty) = try!(const_expr(cx, &e1, param_substs, fn_args, trueconst));\n             debug!(\"const_expr_unadjusted: te1={}, ty={:?}\",\n                    cx.tn().val_to_string(te1),\n                    ty);\n             assert!(!ty.is_simd());\n             let is_float = ty.is_fp();\n             let signed = ty.is_signed();\n \n-            let (te2, _) = try!(const_expr(cx, &**e2, param_substs, fn_args, trueconst));\n+            let (te2, _) = try!(const_expr(cx, &e2, param_substs, fn_args, trueconst));\n \n             try!(check_binary_expr_validity(cx, e, ty, te1, te2, trueconst));\n \n@@ -638,7 +638,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } } // unsafe { match b.node {\n         },\n         hir::ExprUnary(u, ref inner_e) => {\n-            let (te, ty) = try!(const_expr(cx, &**inner_e, param_substs, fn_args, trueconst));\n+            let (te, ty) = try!(const_expr(cx, &inner_e, param_substs, fn_args, trueconst));\n \n             try!(check_unary_expr_validity(cx, e, ty, te, trueconst));\n \n@@ -651,20 +651,20 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } }\n         },\n         hir::ExprField(ref base, field) => {\n-            let (bv, bt) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n+            let (bv, bt) = try!(const_expr(cx, &base, param_substs, fn_args, trueconst));\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n             let ix = vinfo.field_index(field.node);\n-            adt::const_get_field(cx, &*brepr, bv, vinfo.discr, ix)\n+            adt::const_get_field(cx, &brepr, bv, vinfo.discr, ix)\n         },\n         hir::ExprTupField(ref base, idx) => {\n-            let (bv, bt) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n+            let (bv, bt) = try!(const_expr(cx, &base, param_substs, fn_args, trueconst));\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n-            adt::const_get_field(cx, &*brepr, bv, vinfo.discr, idx.node)\n+            adt::const_get_field(cx, &brepr, bv, vinfo.discr, idx.node)\n         },\n         hir::ExprIndex(ref base, ref index) => {\n-            let (bv, bt) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n+            let (bv, bt) = try!(const_expr(cx, &base, param_substs, fn_args, trueconst));\n             let iv = match eval_const_expr_partial(cx.tcx(), &index, ExprTypeChecked, None) {\n                 Ok(ConstVal::Int(i)) => i as u64,\n                 Ok(ConstVal::Uint(u)) => u,\n@@ -716,7 +716,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprCast(ref base, _) => {\n             let t_cast = ety;\n             let llty = type_of::type_of(cx, t_cast);\n-            let (v, t_expr) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n+            let (v, t_expr) = try!(const_expr(cx, &base, param_substs, fn_args, trueconst));\n             debug!(\"trans_const_cast({:?} as {:?})\", t_expr, t_cast);\n             if expr::cast_is_noop(cx.tcx(), base, t_expr, t_cast) {\n                 return Ok(v);\n@@ -741,9 +741,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             ) {\n                 (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n                     let repr = adt::represent_type(cx, t_expr);\n-                    let discr = adt::const_get_discrim(cx, &*repr, v);\n+                    let discr = adt::const_get_discrim(cx, &repr, v);\n                     let iv = C_integral(cx.int_type(), discr.0, false);\n-                    let s = adt::is_discr_signed(&*repr) as Bool;\n+                    let s = adt::is_discr_signed(&repr) as Bool;\n                     llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n                 },\n                 (CastTy::Int(_), CastTy::Int(_)) => {\n@@ -798,26 +798,26 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } else {\n                 // If this isn't the address of a static, then keep going through\n                 // normal constant evaluation.\n-                let (v, ty) = try!(const_expr(cx, &**sub, param_substs, fn_args, trueconst));\n+                let (v, ty) = try!(const_expr(cx, &sub, param_substs, fn_args, trueconst));\n                 addr_of(cx, v, type_of::align_of(cx, ty), \"ref\")\n             }\n         },\n         hir::ExprAddrOf(hir::MutMutable, ref sub) => {\n-            let (v, ty) = try!(const_expr(cx, &**sub, param_substs, fn_args, trueconst));\n+            let (v, ty) = try!(const_expr(cx, &sub, param_substs, fn_args, trueconst));\n             addr_of_mut(cx, v, type_of::align_of(cx, ty), \"ref_mut_slice\")\n         },\n         hir::ExprTup(ref es) => {\n             let repr = adt::represent_type(cx, ety);\n             let vals = try!(map_list(&es[..]));\n-            adt::trans_const(cx, &*repr, Disr(0), &vals[..])\n+            adt::trans_const(cx, &repr, Disr(0), &vals[..])\n         },\n         hir::ExprStruct(_, ref fs, ref base_opt) => {\n             let repr = adt::represent_type(cx, ety);\n \n             let base_val = match *base_opt {\n                 Some(ref base) => Some(try!(const_expr(\n                     cx,\n-                    &**base,\n+                    &base,\n                     param_substs,\n                     fn_args,\n                     trueconst,\n@@ -829,9 +829,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let cs = fields.iter().enumerate().map(|(ix, &Field(f_name, _))| {\n                 match (fs.iter().find(|f| f_name == f.name.node), base_val) {\n                     (Some(ref f), _) => {\n-                        const_expr(cx, &*f.expr, param_substs, fn_args, trueconst).map(|(l, _)| l)\n+                        const_expr(cx, &f.expr, param_substs, fn_args, trueconst).map(|(l, _)| l)\n                     },\n-                    (_, Some((bv, _))) => Ok(adt::const_get_field(cx, &*repr, bv, discr, ix)),\n+                    (_, Some((bv, _))) => Ok(adt::const_get_field(cx, &repr, bv, discr, ix)),\n                     (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),\n                 }\n             })\n@@ -842,7 +842,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if ety.is_simd() {\n                 C_vector(&cs[..])\n             } else {\n-                adt::trans_const(cx, &*repr, discr, &cs[..])\n+                adt::trans_const(cx, &repr, discr, &cs[..])\n             }\n         },\n         hir::ExprVec(ref es) => {\n@@ -851,7 +851,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let vs = es.iter()\n                        .map(|e| const_expr(\n                            cx,\n-                           &**e,\n+                           &e,\n                            param_substs,\n                            fn_args,\n                            trueconst,\n@@ -871,7 +871,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let n = cx.tcx().eval_repeat_count(count);\n-            let unit_val = try!(const_expr(cx, &**elem, param_substs, fn_args, trueconst)).0;\n+            let unit_val = try!(const_expr(cx, &elem, param_substs, fn_args, trueconst)).0;\n             let vs = vec![unit_val; n];\n             if val_ty(unit_val) != llunitty {\n                 C_struct(cx, &vs[..], false)\n@@ -900,7 +900,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     match vinfo.kind() {\n                         ty::VariantKind::Unit => {\n                             let repr = adt::represent_type(cx, ety);\n-                            adt::trans_const(cx, &*repr, Disr::from(vinfo.disr_val), &[])\n+                            adt::trans_const(cx, &repr, Disr::from(vinfo.disr_val), &[])\n                         }\n                         ty::VariantKind::Tuple => {\n                             expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n@@ -930,7 +930,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             loop {\n                 callee = match callee.node {\n                     hir::ExprBlock(ref block) => match block.expr {\n-                        Some(ref tail) => &**tail,\n+                        Some(ref tail) => &tail,\n                         None => break,\n                     },\n                     _ => break,\n@@ -954,14 +954,14 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         C_vector(&arg_vals[..])\n                     } else {\n                         let repr = adt::represent_type(cx, ety);\n-                        adt::trans_const(cx, &*repr, Disr(0), &arg_vals[..])\n+                        adt::trans_const(cx, &repr, Disr(0), &arg_vals[..])\n                     }\n                 }\n                 Def::Variant(enum_did, variant_did) => {\n                     let repr = adt::represent_type(cx, ety);\n                     let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n                     adt::trans_const(cx,\n-                                     &*repr,\n+                                     &repr,\n                                      Disr::from(vinfo.disr_val),\n                                      &arg_vals[..])\n                 }\n@@ -975,12 +975,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             try!(const_fn_call(cx, MethodCallKey(method_call),\n                                method_did, &arg_vals, param_substs, trueconst))\n         },\n-        hir::ExprType(ref e, _) => try!(const_expr(cx, &**e, param_substs, fn_args, trueconst)).0,\n+        hir::ExprType(ref e, _) => try!(const_expr(cx, &e, param_substs, fn_args, trueconst)).0,\n         hir::ExprBlock(ref block) => {\n             match block.expr {\n                 Some(ref expr) => try!(const_expr(\n                     cx,\n-                    &**expr,\n+                    &expr,\n                     param_substs,\n                     fn_args,\n                     trueconst,"}, {"sha": "e84e1b45cedcd76dcaddd7fb0d8d538ea2f22810", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -57,13 +57,13 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n     match s.node {\n         hir::StmtExpr(ref e, _) | hir::StmtSemi(ref e, _) => {\n-            bcx = trans_stmt_semi(bcx, &**e);\n+            bcx = trans_stmt_semi(bcx, &e);\n         }\n         hir::StmtDecl(ref d, _) => {\n             match d.node {\n                 hir::DeclLocal(ref local) => {\n-                    bcx = init_local(bcx, &**local);\n-                    debuginfo::create_local_var_metadata(bcx, &**local);\n+                    bcx = init_local(bcx, &local);\n+                    debuginfo::create_local_var_metadata(bcx, &local);\n                 }\n                 // Inner items are visited by `trans_item`/`trans_meth`.\n                 hir::DeclItem(_) => {},\n@@ -132,7 +132,7 @@ pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match b.expr {\n         Some(ref e) => {\n             if !bcx.unreachable.get() {\n-                bcx = expr::trans_into(bcx, &**e, dest);\n+                bcx = expr::trans_into(bcx, &e, dest);\n             }\n         }\n         None => {\n@@ -169,11 +169,11 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     if let Some(cv) = const_to_opt_uint(cond_val) {\n         if cv == 1 {\n             // if true { .. } [else { .. }]\n-            bcx = trans_block(bcx, &*thn, dest);\n+            bcx = trans_block(bcx, &thn, dest);\n             trans::debuginfo::clear_source_location(bcx.fcx);\n         } else {\n             if let Some(elexpr) = els {\n-                bcx = expr::trans_into(bcx, &*elexpr, dest);\n+                bcx = expr::trans_into(bcx, &elexpr, dest);\n                 trans::debuginfo::clear_source_location(bcx.fcx);\n             }\n         }\n@@ -183,7 +183,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let name = format!(\"then-block-{}-\", thn.id);\n     let then_bcx_in = bcx.fcx.new_id_block(&name[..], thn.id);\n-    let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n+    let then_bcx_out = trans_block(then_bcx_in, &thn, dest);\n     trans::debuginfo::clear_source_location(bcx.fcx);\n \n     let cond_source_loc = cond.debug_loc();\n@@ -192,7 +192,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match els {\n         Some(elexpr) => {\n             let else_bcx_in = bcx.fcx.new_id_block(\"else-block\", elexpr.id);\n-            let else_bcx_out = expr::trans_into(else_bcx_in, &*elexpr, dest);\n+            let else_bcx_out = expr::trans_into(else_bcx_in, &elexpr, dest);\n             next_bcx = bcx.fcx.join_blocks(if_id,\n                                            &[then_bcx_out, else_bcx_out]);\n             CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb, cond_source_loc);\n@@ -365,13 +365,13 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let dest = match (fcx.llretslotptr.get(), retval_expr) {\n         (Some(_), Some(retval_expr)) => {\n-            let ret_ty = expr_ty_adjusted(bcx, &*retval_expr);\n+            let ret_ty = expr_ty_adjusted(bcx, &retval_expr);\n             expr::SaveIn(fcx.get_ret_slot(bcx, ty::FnConverging(ret_ty), \"ret_slot\"))\n         }\n         _ => expr::Ignore,\n     };\n     if let Some(x) = retval_expr {\n-        bcx = expr::trans_into(bcx, &*x, dest);\n+        bcx = expr::trans_into(bcx, &x, dest);\n         match dest {\n             expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n                 Store(bcx, slot, fcx.llretslotptr.get().unwrap());"}, {"sha": "bbbc9c4eda46842945c36fdba984a465984f341c", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -47,7 +47,7 @@ pub fn create_scope_map(cx: &CrateContext,\n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n     for arg in args {\n-        pat_util::pat_bindings_ident(def_map, &*arg.pat, |_, node_id, _, path1| {\n+        pat_util::pat_bindings_ident(def_map, &arg.pat, |_, node_id, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n                                                name: Some(path1.node.unhygienic_name) });\n             scope_map.insert(node_id, fn_metadata);\n@@ -122,15 +122,15 @@ fn walk_block(cx: &CrateContext,\n \n         match statement.node {\n             hir::StmtDecl(ref decl, _) =>\n-                walk_decl(cx, &**decl, scope_stack, scope_map),\n+                walk_decl(cx, &decl, scope_stack, scope_map),\n             hir::StmtExpr(ref exp, _) |\n             hir::StmtSemi(ref exp, _) =>\n-                walk_expr(cx, &**exp, scope_stack, scope_map),\n+                walk_expr(cx, &exp, scope_stack, scope_map),\n         }\n     }\n \n     if let Some(ref exp) = block.expr {\n-        walk_expr(cx, &**exp, scope_stack, scope_map);\n+        walk_expr(cx, &exp, scope_stack, scope_map);\n     }\n }\n \n@@ -142,10 +142,10 @@ fn walk_decl(cx: &CrateContext,\n         codemap::Spanned { node: hir::DeclLocal(ref local), .. } => {\n             scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n \n-            walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n+            walk_pattern(cx, &local.pat, scope_stack, scope_map);\n \n             if let Some(ref exp) = local.init {\n-                walk_expr(cx, &**exp, scope_stack, scope_map);\n+                walk_expr(cx, &exp, scope_stack, scope_map);\n             }\n         }\n         _ => ()\n@@ -167,7 +167,7 @@ fn walk_pattern(cx: &CrateContext,\n \n             // Check if this is a binding. If so we need to put it on the\n             // scope stack and maybe introduce an artificial scope\n-            if pat_util::pat_is_binding(&def_map.borrow(), &*pat) {\n+            if pat_util::pat_is_binding(&def_map.borrow(), &pat) {\n \n                 let name = path1.node.unhygienic_name;\n \n@@ -231,7 +231,7 @@ fn walk_pattern(cx: &CrateContext,\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             if let Some(ref sub_pat) = *sub_pat_opt {\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n         }\n \n@@ -244,7 +244,7 @@ fn walk_pattern(cx: &CrateContext,\n \n             if let Some(ref sub_pats) = *sub_pats_opt {\n                 for p in sub_pats {\n-                    walk_pattern(cx, &**p, scope_stack, scope_map);\n+                    walk_pattern(cx, &p, scope_stack, scope_map);\n                 }\n             }\n         }\n@@ -260,47 +260,47 @@ fn walk_pattern(cx: &CrateContext,\n                 node: hir::FieldPat { pat: ref sub_pat, .. },\n                 ..\n             } in field_pats {\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n         }\n \n         hir::PatTup(ref sub_pats) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             for sub_pat in sub_pats {\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n         }\n \n         hir::PatBox(ref sub_pat) | hir::PatRegion(ref sub_pat, _) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n         }\n \n         hir::PatLit(ref exp) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            walk_expr(cx, &**exp, scope_stack, scope_map);\n+            walk_expr(cx, &exp, scope_stack, scope_map);\n         }\n \n         hir::PatRange(ref exp1, ref exp2) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            walk_expr(cx, &**exp1, scope_stack, scope_map);\n-            walk_expr(cx, &**exp2, scope_stack, scope_map);\n+            walk_expr(cx, &exp1, scope_stack, scope_map);\n+            walk_expr(cx, &exp2, scope_stack, scope_map);\n         }\n \n         hir::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             for sub_pat in front_sub_pats {\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n \n             if let Some(ref sub_pat) = *middle_sub_pats {\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n \n             for sub_pat in back_sub_pats {\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n         }\n     }\n@@ -324,73 +324,73 @@ fn walk_expr(cx: &CrateContext,\n         hir::ExprAddrOf(_, ref sub_exp)  |\n         hir::ExprField(ref sub_exp, _) |\n         hir::ExprTupField(ref sub_exp, _) =>\n-            walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+            walk_expr(cx, &sub_exp, scope_stack, scope_map),\n \n         hir::ExprBox(ref sub_expr) => {\n-            walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n+            walk_expr(cx, &sub_expr, scope_stack, scope_map);\n         }\n \n         hir::ExprRet(ref exp_opt) => match *exp_opt {\n-            Some(ref sub_exp) => walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+            Some(ref sub_exp) => walk_expr(cx, &sub_exp, scope_stack, scope_map),\n             None => ()\n         },\n \n         hir::ExprUnary(_, ref sub_exp) => {\n-            walk_expr(cx, &**sub_exp, scope_stack, scope_map);\n+            walk_expr(cx, &sub_exp, scope_stack, scope_map);\n         }\n \n         hir::ExprAssignOp(_, ref lhs, ref rhs) |\n         hir::ExprIndex(ref lhs, ref rhs) |\n         hir::ExprBinary(_, ref lhs, ref rhs)    => {\n-            walk_expr(cx, &**lhs, scope_stack, scope_map);\n-            walk_expr(cx, &**rhs, scope_stack, scope_map);\n+            walk_expr(cx, &lhs, scope_stack, scope_map);\n+            walk_expr(cx, &rhs, scope_stack, scope_map);\n         }\n \n         hir::ExprRange(ref start, ref end) => {\n-            start.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n-            end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+            start.as_ref().map(|e| walk_expr(cx, &e, scope_stack, scope_map));\n+            end.as_ref().map(|e| walk_expr(cx, &e, scope_stack, scope_map));\n         }\n \n         hir::ExprVec(ref init_expressions) |\n         hir::ExprTup(ref init_expressions) => {\n             for ie in init_expressions {\n-                walk_expr(cx, &**ie, scope_stack, scope_map);\n+                walk_expr(cx, &ie, scope_stack, scope_map);\n             }\n         }\n \n         hir::ExprAssign(ref sub_exp1, ref sub_exp2) |\n         hir::ExprRepeat(ref sub_exp1, ref sub_exp2) => {\n-            walk_expr(cx, &**sub_exp1, scope_stack, scope_map);\n-            walk_expr(cx, &**sub_exp2, scope_stack, scope_map);\n+            walk_expr(cx, &sub_exp1, scope_stack, scope_map);\n+            walk_expr(cx, &sub_exp2, scope_stack, scope_map);\n         }\n \n         hir::ExprIf(ref cond_exp, ref then_block, ref opt_else_exp) => {\n-            walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+            walk_expr(cx, &cond_exp, scope_stack, scope_map);\n \n             with_new_scope(cx,\n                            then_block.span,\n                            scope_stack,\n                            scope_map,\n                            |cx, scope_stack, scope_map| {\n-                walk_block(cx, &**then_block, scope_stack, scope_map);\n+                walk_block(cx, &then_block, scope_stack, scope_map);\n             });\n \n             match *opt_else_exp {\n                 Some(ref else_exp) =>\n-                    walk_expr(cx, &**else_exp, scope_stack, scope_map),\n+                    walk_expr(cx, &else_exp, scope_stack, scope_map),\n                 _ => ()\n             }\n         }\n \n         hir::ExprWhile(ref cond_exp, ref loop_body, _) => {\n-            walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+            walk_expr(cx, &cond_exp, scope_stack, scope_map);\n \n             with_new_scope(cx,\n                            loop_body.span,\n                            scope_stack,\n                            scope_map,\n                            |cx, scope_stack, scope_map| {\n-                walk_block(cx, &**loop_body, scope_stack, scope_map);\n+                walk_block(cx, &loop_body, scope_stack, scope_map);\n             })\n         }\n \n@@ -401,7 +401,7 @@ fn walk_expr(cx: &CrateContext,\n                            scope_stack,\n                            scope_map,\n                            |cx, scope_stack, scope_map| {\n-                walk_block(cx, &**block, scope_stack, scope_map);\n+                walk_block(cx, &block, scope_stack, scope_map);\n             })\n         }\n \n@@ -412,29 +412,29 @@ fn walk_expr(cx: &CrateContext,\n                            scope_map,\n                            |cx, scope_stack, scope_map| {\n                 for &hir::Arg { pat: ref pattern, .. } in &decl.inputs {\n-                    walk_pattern(cx, &**pattern, scope_stack, scope_map);\n+                    walk_pattern(cx, &pattern, scope_stack, scope_map);\n                 }\n \n-                walk_block(cx, &**block, scope_stack, scope_map);\n+                walk_block(cx, &block, scope_stack, scope_map);\n             })\n         }\n \n         hir::ExprCall(ref fn_exp, ref args) => {\n-            walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n+            walk_expr(cx, &fn_exp, scope_stack, scope_map);\n \n             for arg_exp in args {\n-                walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+                walk_expr(cx, &arg_exp, scope_stack, scope_map);\n             }\n         }\n \n         hir::ExprMethodCall(_, _, ref args) => {\n             for arg_exp in args {\n-                walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+                walk_expr(cx, &arg_exp, scope_stack, scope_map);\n             }\n         }\n \n         hir::ExprMatch(ref discriminant_exp, ref arms, _) => {\n-            walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n+            walk_expr(cx, &discriminant_exp, scope_stack, scope_map);\n \n             // For each arm we have to first walk the pattern as these might\n             // introduce new artificial scopes. It should be sufficient to\n@@ -450,25 +450,25 @@ fn walk_expr(cx: &CrateContext,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n                     for pat in &arm_ref.pats {\n-                        walk_pattern(cx, &**pat, scope_stack, scope_map);\n+                        walk_pattern(cx, &pat, scope_stack, scope_map);\n                     }\n \n                     if let Some(ref guard_exp) = arm_ref.guard {\n-                        walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n+                        walk_expr(cx, &guard_exp, scope_stack, scope_map)\n                     }\n \n-                    walk_expr(cx, &*arm_ref.body, scope_stack, scope_map);\n+                    walk_expr(cx, &arm_ref.body, scope_stack, scope_map);\n                 })\n             }\n         }\n \n         hir::ExprStruct(_, ref fields, ref base_exp) => {\n             for &hir::Field { expr: ref exp, .. } in fields {\n-                walk_expr(cx, &**exp, scope_stack, scope_map);\n+                walk_expr(cx, &exp, scope_stack, scope_map);\n             }\n \n             match *base_exp {\n-                Some(ref exp) => walk_expr(cx, &**exp, scope_stack, scope_map),\n+                Some(ref exp) => walk_expr(cx, &exp, scope_stack, scope_map),\n                 None => ()\n             }\n         }\n@@ -478,11 +478,11 @@ fn walk_expr(cx: &CrateContext,\n                                             .. }) => {\n             // inputs, outputs: Vec<(String, P<Expr>)>\n             for &(_, ref exp) in inputs {\n-                walk_expr(cx, &**exp, scope_stack, scope_map);\n+                walk_expr(cx, &exp, scope_stack, scope_map);\n             }\n \n             for out in outputs {\n-                walk_expr(cx, &*out.expr, scope_stack, scope_map);\n+                walk_expr(cx, &out.expr, scope_stack, scope_map);\n             }\n         }\n     }"}, {"sha": "843aebc443722c1b6e5e7614a5fe79ad660fceb4", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -1919,7 +1919,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &hir::Local) {\n     let def_map = &cx.tcx().def_map;\n     let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, var_name| {\n+    pat_util::pat_bindings(def_map, &local.pat, |_, node_id, span, var_name| {\n         let datum = match locals.get(&node_id) {\n             Some(datum) => datum,\n             None => {\n@@ -2099,7 +2099,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &hir::Arg) {\n                          .fn_metadata;\n     let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, var_name| {\n+    pat_util::pat_bindings(def_map, &arg.pat, |_, node_id, span, var_name| {\n         let datum = match locals.get(&node_id) {\n             Some(v) => v,\n             None => {"}, {"sha": "11dd631bee1fad76dc9e8dda55d86d3fa24abe78", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -399,7 +399,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let scope_map = create_scope_map::create_scope_map(cx,\n                                                        &fn_decl.inputs,\n-                                                       &*top_level_block,\n+                                                       &top_level_block,\n                                                        fn_metadata,\n                                                        fn_ast_id);\n "}, {"sha": "0c2c29724a1d72489d8cd82809ec48a7657fd4b0", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -34,7 +34,7 @@ impl NamespaceTreeNode {\n     pub fn mangled_name_of_contained_item(&self, item_name: &str) -> String {\n         fn fill_nested(node: &NamespaceTreeNode, output: &mut String) {\n             match node.parent {\n-                Some(ref parent) => fill_nested(&*parent.upgrade().unwrap(), output),\n+                Some(ref parent) => fill_nested(&parent.upgrade().unwrap(), output),\n                 None => {}\n             }\n             let string = node.name.as_str();"}, {"sha": "c1d7bb495fafdefe6001097340cb78eeeb9bfcee", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -46,7 +46,7 @@ pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n \n pub fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n     attributes.iter().any(|attr| {\n-        let meta_item: &ast::MetaItem = &*attr.node.value;\n+        let meta_item: &ast::MetaItem = &attr.node.value;\n         match meta_item.node {\n             ast::MetaItemKind::Word(ref value) => &value[..] == \"no_debug\",\n             _ => false"}, {"sha": "fac956c1ddd20ea1fd09856220fdde97518508d9", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -650,39 +650,39 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match expr.node {\n         hir::ExprType(ref e, _) => {\n-            trans(bcx, &**e)\n+            trans(bcx, &e)\n         }\n         hir::ExprPath(..) => {\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n         hir::ExprField(ref base, name) => {\n-            trans_rec_field(bcx, &**base, name.node)\n+            trans_rec_field(bcx, &base, name.node)\n         }\n         hir::ExprTupField(ref base, idx) => {\n-            trans_rec_tup_field(bcx, &**base, idx.node)\n+            trans_rec_tup_field(bcx, &base, idx.node)\n         }\n         hir::ExprIndex(ref base, ref idx) => {\n-            trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n+            trans_index(bcx, expr, &base, &idx, MethodCall::expr(expr.id))\n         }\n         hir::ExprBox(ref contents) => {\n             // Special case for `Box<T>`\n             let box_ty = expr_ty(bcx, expr);\n-            let contents_ty = expr_ty(bcx, &**contents);\n+            let contents_ty = expr_ty(bcx, &contents);\n             match box_ty.sty {\n                 ty::TyBox(..) => {\n-                    trans_uniq_expr(bcx, expr, box_ty, &**contents, contents_ty)\n+                    trans_uniq_expr(bcx, expr, box_ty, &contents, contents_ty)\n                 }\n                 _ => bcx.sess().span_bug(expr.span,\n                                          \"expected unique box\")\n             }\n \n         }\n-        hir::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, &**lit),\n+        hir::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, &lit),\n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            trans_binary(bcx, expr, op, &**lhs, &**rhs)\n+            trans_binary(bcx, expr, op, &lhs, &rhs)\n         }\n         hir::ExprUnary(op, ref x) => {\n-            trans_unary(bcx, expr, op, &**x)\n+            trans_unary(bcx, expr, op, &x)\n         }\n         hir::ExprAddrOf(_, ref x) => {\n             match x.node {\n@@ -695,18 +695,18 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                                       false);\n                     fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n                     let datum = unpack_datum!(\n-                        bcx, tvec::trans_slice_vec(bcx, expr, &**x));\n+                        bcx, tvec::trans_slice_vec(bcx, expr, &x));\n                     bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, x.id);\n                     DatumBlock::new(bcx, datum)\n                 }\n                 _ => {\n-                    trans_addr_of(bcx, expr, &**x)\n+                    trans_addr_of(bcx, expr, &x)\n                 }\n             }\n         }\n         hir::ExprCast(ref val, _) => {\n             // Datum output mode means this is a scalar cast:\n-            trans_imm_cast(bcx, &**val, expr.id)\n+            trans_imm_cast(bcx, &val, expr.id)\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -737,7 +737,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         bcx,\n         vinfo.fields[ix].1,\n         |srcval| {\n-            adt::trans_field_ptr(bcx, &*repr, srcval, vinfo.discr, ix)\n+            adt::trans_field_ptr(bcx, &repr, srcval, vinfo.discr, ix)\n         });\n \n     if type_is_sized(bcx.tcx(), d.ty) {\n@@ -938,7 +938,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_break(bcx, expr, label_opt.map(|l| l.node.name))\n         }\n         hir::ExprType(ref e, _) => {\n-            trans_into(bcx, &**e, Ignore)\n+            trans_into(bcx, &e, Ignore)\n         }\n         hir::ExprAgain(label_opt) => {\n             controlflow::trans_cont(bcx, expr, label_opt.map(|l| l.node.name))\n@@ -959,7 +959,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // directly. This avoids having to manage a return slot when\n                 // it won't actually be used anyway.\n                 if let &Some(ref x) = ex {\n-                    bcx = trans_into(bcx, &**x, Ignore);\n+                    bcx = trans_into(bcx, &x, Ignore);\n                 }\n                 // Mark the end of the block as unreachable. Once we get to\n                 // a return expression, there's no more we should be doing\n@@ -969,14 +969,14 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         hir::ExprWhile(ref cond, ref body, _) => {\n-            controlflow::trans_while(bcx, expr, &**cond, &**body)\n+            controlflow::trans_while(bcx, expr, &cond, &body)\n         }\n         hir::ExprLoop(ref body, _) => {\n-            controlflow::trans_loop(bcx, expr, &**body)\n+            controlflow::trans_loop(bcx, expr, &body)\n         }\n         hir::ExprAssign(ref dst, ref src) => {\n-            let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n-            let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &**dst, \"assign\"));\n+            let src_datum = unpack_datum!(bcx, trans(bcx, &src));\n+            let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &dst, \"assign\"));\n \n             if bcx.fcx.type_needs_drop(dst_datum.ty) {\n                 // If there are destructors involved, make sure we\n@@ -1031,12 +1031,12 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     .contains_key(&MethodCall::expr(expr.id));\n \n             if has_method_map {\n-                let dst = unpack_datum!(bcx, trans(bcx, &**dst));\n-                let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n+                let dst = unpack_datum!(bcx, trans(bcx, &dst));\n+                let src_datum = unpack_datum!(bcx, trans(bcx, &src));\n                 trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), dst,\n                                     Some((src_datum, src.id)), None, false).bcx\n             } else {\n-                trans_assign_op(bcx, expr, op, &**dst, &**src)\n+                trans_assign_op(bcx, expr, op, &dst, &src)\n             }\n         }\n         hir::ExprInlineAsm(ref a) => {\n@@ -1064,19 +1064,19 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match expr.node {\n         hir::ExprType(ref e, _) => {\n-            trans_into(bcx, &**e, dest)\n+            trans_into(bcx, &e, dest)\n         }\n         hir::ExprPath(..) => {\n             trans_def_dps_unadjusted(bcx, expr, bcx.def(expr.id), dest)\n         }\n         hir::ExprIf(ref cond, ref thn, ref els) => {\n-            controlflow::trans_if(bcx, expr.id, &**cond, &**thn, els.as_ref().map(|e| &**e), dest)\n+            controlflow::trans_if(bcx, expr.id, &cond, &thn, els.as_ref().map(|e| &**e), dest)\n         }\n         hir::ExprMatch(ref discr, ref arms, _) => {\n-            _match::trans_match(bcx, expr, &**discr, &arms[..], dest)\n+            _match::trans_match(bcx, expr, &discr, &arms[..], dest)\n         }\n         hir::ExprBlock(ref blk) => {\n-            controlflow::trans_block(bcx, &**blk, dest)\n+            controlflow::trans_block(bcx, &blk, dest)\n         }\n         hir::ExprStruct(_, ref fields, ref base) => {\n             trans_struct(bcx,\n@@ -1201,42 +1201,42 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if bcx.tcx().is_method_call(expr.id) {\n                 trans_overloaded_call(bcx,\n                                       expr,\n-                                      &**f,\n+                                      &f,\n                                       &args[..],\n                                       Some(dest))\n             } else {\n                 callee::trans_call(bcx,\n                                    expr,\n-                                   &**f,\n+                                   &f,\n                                    callee::ArgExprs(&args[..]),\n                                    dest)\n             }\n         }\n         hir::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n-                                      &*args[0],\n+                                      &args[0],\n                                       callee::ArgExprs(&args[..]),\n                                       dest)\n         }\n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            let lhs = unpack_datum!(bcx, trans(bcx, &**lhs));\n-            let rhs_datum = unpack_datum!(bcx, trans(bcx, &**rhs));\n+            let lhs = unpack_datum!(bcx, trans(bcx, &lhs));\n+            let rhs_datum = unpack_datum!(bcx, trans(bcx, &rhs));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n                                 Some((rhs_datum, rhs.id)), Some(dest),\n                                 !rustc_front::util::is_by_value_binop(op.node)).bcx\n         }\n         hir::ExprUnary(op, ref subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            let arg = unpack_datum!(bcx, trans(bcx, &**subexpr));\n+            let arg = unpack_datum!(bcx, trans(bcx, &subexpr));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id),\n                                 arg, None, Some(dest), !rustc_front::util::is_by_value_unop(op)).bcx\n         }\n         hir::ExprIndex(ref base, ref idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            let base = unpack_datum!(bcx, trans(bcx, &**base));\n-            let idx_datum = unpack_datum!(bcx, trans(bcx, &**idx));\n+            let base = unpack_datum!(bcx, trans(bcx, &base));\n+            let idx_datum = unpack_datum!(bcx, trans(bcx, &idx));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n                                 Some((idx_datum, idx.id)), Some(dest), true).bcx\n         }\n@@ -1286,7 +1286,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // Nullary variant.\n                 let ty = expr_ty(bcx, ref_expr);\n                 let repr = adt::represent_type(bcx.ccx(), ty);\n-                adt::trans_set_discr(bcx, &*repr, lldest, Disr::from(variant.disr_val));\n+                adt::trans_set_discr(bcx, &repr, lldest, Disr::from(variant.disr_val));\n                 return bcx;\n             }\n         }\n@@ -1295,7 +1295,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match ty.sty {\n                 ty::TyStruct(def, _) if def.has_dtor() => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n-                    adt::trans_set_discr(bcx, &*repr, lldest, Disr(0));\n+                    adt::trans_set_discr(bcx, &repr, lldest, Disr(0));\n                 }\n                 _ => {}\n             }\n@@ -1505,7 +1505,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         let mut vec_val = C_undef(llty);\n \n         for &(i, ref e) in fields {\n-            let block_datum = trans(bcx, &**e);\n+            let block_datum = trans(bcx, &e);\n             bcx = block_datum.bcx;\n             let position = C_uint(bcx.ccx(), i);\n             let value = block_datum.datum.to_llscalarish(bcx);\n@@ -1518,7 +1518,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n         // First, trans field expressions to temporary scratch values.\n         let scratch_vals: Vec<_> = fields.iter().map(|&(i, ref e)| {\n-            let datum = unpack_datum!(bcx, trans(bcx, &**e));\n+            let datum = unpack_datum!(bcx, trans(bcx, &e));\n             (i, datum)\n         }).collect();\n \n@@ -1528,45 +1528,45 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         assert_eq!(discr, Disr(0));\n \n         let addr = adt::MaybeSizedValue::sized(addr);\n-        match expr_kind(bcx.tcx(), &*base.expr) {\n+        match expr_kind(bcx.tcx(), &base.expr) {\n             ExprKind::RvalueDps | ExprKind::RvalueDatum if !bcx.fcx.type_needs_drop(ty) => {\n-                bcx = trans_into(bcx, &*base.expr, SaveIn(addr.value));\n+                bcx = trans_into(bcx, &base.expr, SaveIn(addr.value));\n             },\n             ExprKind::RvalueStmt => {\n                 bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\")\n             }\n             _ => {\n-                let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n+                let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &base.expr, \"base\"));\n                 for &(i, t) in &base.fields {\n                     let datum = base_datum.get_element(\n-                            bcx, t, |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, i));\n+                            bcx, t, |srcval| adt::trans_field_ptr(bcx, &repr, srcval, discr, i));\n                     assert!(type_is_sized(bcx.tcx(), datum.ty));\n-                    let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n+                    let dest = adt::trans_field_ptr(bcx, &repr, addr, discr, i);\n                     bcx = datum.store_to(bcx, dest);\n                 }\n             }\n         }\n \n         // Finally, move scratch field values into actual field locations\n         for (i, datum) in scratch_vals {\n-            let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n+            let dest = adt::trans_field_ptr(bcx, &repr, addr, discr, i);\n             bcx = datum.store_to(bcx, dest);\n         }\n     } else {\n         // No base means we can write all fields directly in place.\n         let addr = adt::MaybeSizedValue::sized(addr);\n         for &(i, ref e) in fields {\n-            let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n-            let e_ty = expr_ty_adjusted(bcx, &**e);\n-            bcx = trans_into(bcx, &**e, SaveIn(dest));\n+            let dest = adt::trans_field_ptr(bcx, &repr, addr, discr, i);\n+            let e_ty = expr_ty_adjusted(bcx, &e);\n+            bcx = trans_into(bcx, &e, SaveIn(dest));\n             let scope = cleanup::CustomScope(custom_cleanup_scope);\n             fcx.schedule_lifetime_end(scope, dest);\n             // FIXME: nonzeroing move should generalize to fields\n             fcx.schedule_drop_mem(scope, dest, e_ty, None);\n         }\n     }\n \n-    adt::trans_set_discr(bcx, &*repr, addr, discr);\n+    adt::trans_set_discr(bcx, &repr, addr, discr);\n \n     fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n \n@@ -2112,10 +2112,10 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let datum = unpack_datum!(\n             bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n         let llexpr_ptr = datum.to_llref();\n-        let discr = adt::trans_get_discr(bcx, &*repr, llexpr_ptr,\n+        let discr = adt::trans_get_discr(bcx, &repr, llexpr_ptr,\n                                          Some(Type::i64(ccx)), true);\n         ll_t_in = val_ty(discr);\n-        (discr, adt::is_discr_signed(&*repr))\n+        (discr, adt::is_discr_signed(&repr))\n     } else {\n         (datum.to_llscalarish(bcx), t_in.is_signed())\n     };\n@@ -2165,7 +2165,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let lhs = immediate_rvalue(lhs, dst.ty);\n \n     // Evaluate RHS - FIXME(#28160) this sucks\n-    let rhs = unpack_datum!(bcx, trans(bcx, &*src));\n+    let rhs = unpack_datum!(bcx, trans(bcx, &src));\n     let rhs = unpack_datum!(bcx, rhs.to_rvalue_datum(bcx, \"assign_op_rhs\"));\n \n     // Perform computation and store the result"}, {"sha": "b96f2cd45cf95244a174ea5316bedbc301edfb57", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -472,10 +472,10 @@ fn gate_simd_ffi(tcx: &ty::ctxt, decl: &hir::FnDecl, ty: &ty::BareFnTy) {\n         };\n         let sig = &ty.sig.0;\n         for (input, ty) in decl.inputs.iter().zip(&sig.inputs) {\n-            check(&*input.ty, *ty)\n+            check(&input.ty, *ty)\n         }\n         if let hir::Return(ref ty) = decl.output {\n-            check(&**ty, sig.output.unwrap())\n+            check(&ty, sig.output.unwrap())\n         }\n     }\n }\n@@ -491,7 +491,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &hir::ForeignMod) {\n                 abi => {\n                     let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n                     match ty.sty {\n-                        ty::TyBareFn(_, bft) => gate_simd_ffi(ccx.tcx(), &**decl, bft),\n+                        ty::TyBareFn(_, bft) => gate_simd_ffi(ccx.tcx(), &decl, bft),\n                         _ => ccx.tcx().sess.span_bug(foreign_item.span,\n                                                      \"foreign fn's sty isn't a bare_fn_ty?\")\n                     }"}, {"sha": "5cb6a7344f1a12f76af4fe5d8610f9b20a01acbe", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -298,7 +298,7 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     assert!(type_is_sized(bcx.tcx(), t), \"Precondition: caller must ensure t is sized\");\n \n     let repr = adt::represent_type(bcx.ccx(), t);\n-    let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, struct_data));\n+    let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &repr, struct_data));\n     let loaded = load_ty(bcx, drop_flag.val, bcx.tcx().dtor_type());\n     let drop_flag_llty = type_of(bcx.fcx.ccx, bcx.tcx().dtor_type());\n     let init_val = C_integral(drop_flag_llty, adt::DTOR_NEEDED as u64, false);\n@@ -402,7 +402,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n             assert!(!t.is_simd());\n             let repr = adt::represent_type(ccx, t);\n-            let sizing_type = adt::sizing_type_context_of(ccx, &*repr, true);\n+            let sizing_type = adt::sizing_type_context_of(ccx, &repr, true);\n             debug!(\"DST {} sizing_type: {}\", t, sizing_type.to_string());\n             let sized_size = llsize_of_alloc(ccx, sizing_type.prefix());\n             let sized_align = llalign_of_min(ccx, sizing_type.prefix());"}, {"sha": "4c647152458f410d62c9d855361be525a7733bf9", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -120,7 +120,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n                 _ => ccx.sess().bug(\"instantiate_inline: item has a \\\n                                  non-enum, non-struct parent\")\n             }\n-            trans_item(ccx, &**item);\n+            trans_item(ccx, &item);\n             my_id\n         }\n         FoundAst::FoundParent(_, _) => {"}, {"sha": "188fb7de9dd838fcf3baa5b929cb8f4d8eb9e954", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -225,7 +225,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     // efficient (these are done efficiently implicitly in C\n                     // with the `__m128i` type and so this means Rust doesn't\n                     // lose out there).\n-                    let expr = &*arg_exprs[0];\n+                    let expr = &arg_exprs[0];\n                     let datum = unpack_datum!(bcx, expr::trans(bcx, expr));\n                     let datum = unpack_datum!(bcx, datum.to_rvalue_datum(bcx, \"transmute_temp\"));\n                     let val = if datum.kind.is_by_ref() {\n@@ -253,7 +253,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         expr::SaveIn(d) => expr::SaveIn(PointerCast(bcx, d, llintype.ptr_to())),\n                         expr::Ignore => expr::Ignore\n                     };\n-                    bcx = expr::trans_into(bcx, &*arg_exprs[0], dest);\n+                    bcx = expr::trans_into(bcx, &arg_exprs[0], dest);\n                     dest\n                 };\n \n@@ -404,7 +404,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n-    let simple = get_simple_intrinsic(ccx, &*foreign_item);\n+    let simple = get_simple_intrinsic(ccx, &foreign_item);\n     let llval = match (simple, &*name) {\n         (Some(llfn), _) => {\n             Call(bcx, llfn, &llargs, None, call_debug_location)\n@@ -658,7 +658,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             match val_ty.sty {\n                 ty::TyEnum(..) => {\n                     let repr = adt::represent_type(ccx, *val_ty);\n-                    adt::trans_get_discr(bcx, &*repr, llargs[0],\n+                    adt::trans_get_discr(bcx, &repr, llargs[0],\n                                          Some(llret_ty), true)\n                 }\n                 _ => C_null(llret_ty)\n@@ -849,7 +849,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         assert!(!bcx.fcx.type_needs_drop(arg_type));\n \n                         let repr = adt::represent_type(bcx.ccx(), arg_type);\n-                        let repr_ptr = &*repr;\n+                        let repr_ptr = &repr;\n                         let arg = adt::MaybeSizedValue::sized(llarg);\n                         (0..contents.len())\n                             .map(|i| {"}, {"sha": "875f09c02e889a37c5d3a9de8b3221264644430b", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -67,7 +67,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 assert_eq!(adt_def.variants.len(), targets.len());\n                 for (adt_variant, target) in adt_def.variants.iter().zip(targets) {\n                     let llval = bcx.with_block(|bcx|\n-                        adt::trans_case(bcx, &*repr, Disr::from(adt_variant.disr_val))\n+                        adt::trans_case(bcx, &repr, Disr::from(adt_variant.disr_val))\n                     );\n                     let llbb = self.llblock(*target);\n                     build::AddCase(switch, llval, llbb)"}, {"sha": "2468601afa57a5b83f18a2a93abc83e28af94b97", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -106,15 +106,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let repr = adt::represent_type(bcx.ccx(), dest.ty.to_ty(bcx.tcx()));\n                         let disr = Disr::from(adt_def.variants[index].disr_val);\n                         bcx.with_block(|bcx| {\n-                            adt::trans_set_discr(bcx, &*repr, dest.llval, Disr::from(disr));\n+                            adt::trans_set_discr(bcx, &repr, dest.llval, Disr::from(disr));\n                         });\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n                                 let val = adt::MaybeSizedValue::sized(dest.llval);\n                                 let lldest_i = bcx.with_block(|bcx| {\n-                                    adt::trans_field_ptr(bcx, &*repr, val, disr, i)\n+                                    adt::trans_field_ptr(bcx, &repr, val, disr, i)\n                                 });\n                                 self.store_operand(&bcx, lldest_i, op);\n                             }\n@@ -234,9 +234,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             let repr = adt::represent_type(bcx.ccx(), operand.ty);\n                             let llval = operand.immediate();\n                             let discr = bcx.with_block(|bcx| {\n-                                adt::trans_get_discr(bcx, &*repr, llval, None, true)\n+                                adt::trans_get_discr(bcx, &repr, llval, None, true)\n                             });\n-                            (discr, common::val_ty(discr), adt::is_discr_signed(&*repr))\n+                            (discr, common::val_ty(discr), adt::is_discr_signed(&repr))\n                         } else {\n                             (operand.immediate(), ll_t_in, operand.ty.is_signed())\n                         };"}, {"sha": "867ac9b8376fbf3d7c578f818093f420aa07945e", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -183,12 +183,12 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   if needs_body {\n                       if abi != Abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n-                              ccx, &**decl, &**body, &[], d, psubsts, fn_node_id,\n+                              ccx, &decl, &body, &[], d, psubsts, fn_node_id,\n                               Some(&hash[..]));\n                       } else {\n                           trans_fn(ccx,\n-                                   &**decl,\n-                                   &**body,\n+                                   &decl,\n+                                   &body,\n                                    d,\n                                    psubsts,\n                                    fn_node_id,"}, {"sha": "d6573e96b02a35ba3ea7f453fd025fca15bb6d91", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -206,7 +206,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match dest {\n                 Ignore => {\n                     for element in elements {\n-                        bcx = expr::trans_into(bcx, &**element, Ignore);\n+                        bcx = expr::trans_into(bcx, &element, Ignore);\n                     }\n                 }\n \n@@ -216,7 +216,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         let lleltptr = GEPi(bcx, lldest, &[i]);\n                         debug!(\"writing index {} with lleltptr={}\",\n                                i, bcx.val_to_string(lleltptr));\n-                        bcx = expr::trans_into(bcx, &**element,\n+                        bcx = expr::trans_into(bcx, &element,\n                                                SaveIn(lleltptr));\n                         let scope = cleanup::CustomScope(temp_scope);\n                         // Issue #30822: mark memory as dropped after running destructor\n@@ -230,14 +230,14 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         hir::ExprRepeat(ref element, ref count_expr) => {\n             match dest {\n                 Ignore => {\n-                    return expr::trans_into(bcx, &**element, Ignore);\n+                    return expr::trans_into(bcx, &element, Ignore);\n                 }\n                 SaveIn(lldest) => {\n-                    match bcx.tcx().eval_repeat_count(&**count_expr) {\n-                        0 => expr::trans_into(bcx, &**element, Ignore),\n-                        1 => expr::trans_into(bcx, &**element, SaveIn(lldest)),\n+                    match bcx.tcx().eval_repeat_count(&count_expr) {\n+                        0 => expr::trans_into(bcx, &element, Ignore),\n+                        1 => expr::trans_into(bcx, &element, SaveIn(lldest)),\n                         count => {\n-                            let elem = unpack_datum!(bcx, expr::trans(bcx, &**element));\n+                            let elem = unpack_datum!(bcx, expr::trans(bcx, &element));\n                             let bcx = iter_vec_loop(bcx, lldest, vt,\n                                                     C_uint(bcx.ccx(), count),\n                                                     |set_bcx, lleltptr, _| {\n@@ -285,7 +285,7 @@ fn elements_required(bcx: Block, content_expr: &hir::Expr) -> usize {\n         },\n         hir::ExprVec(ref es) => es.len(),\n         hir::ExprRepeat(_, ref count_expr) => {\n-            bcx.tcx().eval_repeat_count(&**count_expr)\n+            bcx.tcx().eval_repeat_count(&count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n                                      \"unexpected vec content\")"}, {"sha": "0f88269a2c9e95e44f221ff755826ff2347291c8", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "patch": "@@ -226,7 +226,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n         ty::TyTuple(..) | ty::TyEnum(..) | ty::TyClosure(..) => {\n             let repr = adt::represent_type(cx, t);\n-            adt::sizing_type_of(cx, &*repr, false)\n+            adt::sizing_type_of(cx, &repr, false)\n         }\n \n         ty::TyStruct(..) => {\n@@ -243,7 +243,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n                 Type::vector(&llet, n)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n-                adt::sizing_type_of(cx, &*repr, false)\n+                adt::sizing_type_of(cx, &repr, false)\n             }\n         }\n \n@@ -359,7 +359,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n           let name = llvm_type_name(cx, def.did, tps);\n-          adt::incomplete_type_of(cx, &*repr, &name[..])\n+          adt::incomplete_type_of(cx, &repr, &name[..])\n       }\n       ty::TyClosure(..) => {\n           // Only create the named struct, but don't fill it in. We\n@@ -369,7 +369,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           // inherited from their environment, so we use entire\n           // contents of the VecPerParamSpace to construct the llvm\n           // name\n-          adt::incomplete_type_of(cx, &*repr, \"closure\")\n+          adt::incomplete_type_of(cx, &repr, \"closure\")\n       }\n \n       ty::TyBox(ty) |\n@@ -423,7 +423,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyTuple(ref tys) if tys.is_empty() => Type::nil(cx),\n       ty::TyTuple(..) => {\n           let repr = adt::represent_type(cx, t);\n-          adt::type_of(cx, &*repr)\n+          adt::type_of(cx, &repr)\n       }\n       ty::TyStruct(def, ref substs) => {\n           if t.is_simd() {\n@@ -444,7 +444,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n               let name = llvm_type_name(cx, def.did, tps);\n-              adt::incomplete_type_of(cx, &*repr, &name[..])\n+              adt::incomplete_type_of(cx, &repr, &name[..])\n           }\n       }\n \n@@ -465,7 +465,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n         ty::TyEnum(..) | ty::TyStruct(..) | ty::TyClosure(..)\n                 if !t.is_simd() => {\n             let repr = adt::represent_type(cx, t);\n-            adt::finish_type_of(cx, &*repr, &mut llty);\n+            adt::finish_type_of(cx, &repr, &mut llty);\n         }\n         _ => ()\n     }"}]}