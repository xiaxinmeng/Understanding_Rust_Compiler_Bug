{"sha": "64e5327b6e7ad79f4a3ca7de17ac105c8c59277e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZTUzMjdiNmU3YWQ3OWY0YTNjYTdkZTE3YWMxMDVjOGM1OTI3N2U=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-03-31T03:55:17Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-03-31T19:24:08Z"}, "message": "Fix double-free and undefined behaviour in libstd::syn::unix::Thread::new.", "tree": {"sha": "c2109b095525f0d33342894891d74571f1574af4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2109b095525f0d33342894891d74571f1574af4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e", "html_url": "https://github.com/rust-lang/rust/commit/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e/comments", "author": null, "committer": null, "parents": [{"sha": "2113659479a82ea69633b23ef710b58ab127755e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2113659479a82ea69633b23ef710b58ab127755e", "html_url": "https://github.com/rust-lang/rust/commit/2113659479a82ea69633b23ef710b58ab127755e"}], "stats": {"total": 61, "additions": 43, "deletions": 18}, "files": [{"sha": "a3595debaf591f604967729178656ea4a31ff4c9", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=64e5327b6e7ad79f4a3ca7de17ac105c8c59277e", "patch": "@@ -22,21 +22,28 @@ unsafe impl Sync for Thread {}\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n+        let mut p = mem::ManuallyDrop::new(box p);\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n \n         let stack_size = cmp::max(stack, min_stack_size(&attr));\n         assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(\n+            &mut native,\n+            &attr,\n+            thread_start,\n+            &mut *p as &mut Box<dyn FnOnce()> as *mut _ as *mut _,\n+        );\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to manually drop it.\n+            mem::ManuallyDrop::drop(&mut p);\n             Err(io::Error::from_raw_os_error(ret))\n         } else {\n-            mem::forget(p); // ownership passed to pthread_create\n             Ok(Thread { id: native })\n         };\n "}, {"sha": "8e15208abc246acda597aa9695bb50468606f7e2", "filename": "src/libstd/sys/hermit/thread.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs?ref=64e5327b6e7ad79f4a3ca7de17ac105c8c59277e", "patch": "@@ -49,21 +49,23 @@ impl Thread {\n         p: Box<dyn FnOnce()>,\n         core_id: isize,\n     ) -> io::Result<Thread> {\n-        let p = box p;\n+        let mut p = mem::ManuallyDrop::new(box p);\n         let mut tid: Tid = u32::MAX;\n         let ret = abi::spawn(\n             &mut tid as *mut Tid,\n             thread_start,\n-            &*p as *const _ as *const u8 as usize,\n+            &mut *p as &mut Box<dyn FnOnce()> as *mut _ as *mut u8 as usize,\n             Priority::into(NORMAL_PRIO),\n             core_id,\n         );\n \n-        return if ret == 0 {\n-            mem::forget(p); // ownership passed to pthread_create\n-            Ok(Thread { tid: tid })\n-        } else {\n+        return if ret != 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to manually drop it.\n+            mem::ManuallyDrop::drop(&mut p);\n             Err(io::Error::new(io::ErrorKind::Other, \"Unable to create thread!\"))\n+        } else {\n+            Ok(Thread { tid: tid })\n         };\n \n         extern \"C\" fn thread_start(main: usize) {"}, {"sha": "efcd6142024685468e4e1905fdf307db10643c48", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=64e5327b6e7ad79f4a3ca7de17ac105c8c59277e", "patch": "@@ -43,7 +43,7 @@ unsafe fn pthread_attr_setstacksize(\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n+        let mut p = mem::ManuallyDrop::new(box p);\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n@@ -65,13 +65,20 @@ impl Thread {\n             }\n         };\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(\n+            &mut native,\n+            &attr,\n+            thread_start,\n+            &mut *p as &mut Box<dyn FnOnce()> as *mut _ as *mut _,\n+        );\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to manually drop it.\n+            mem::ManuallyDrop::drop(&mut p);\n             Err(io::Error::from_raw_os_error(ret))\n         } else {\n-            mem::forget(p); // ownership passed to pthread_create\n             Ok(Thread { id: native })\n         };\n "}, {"sha": "81233c1975c7972897725f9b52a391c40adb477d", "filename": "src/libstd/sys/vxworks/thread.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs?ref=64e5327b6e7ad79f4a3ca7de17ac105c8c59277e", "patch": "@@ -31,7 +31,7 @@ unsafe fn pthread_attr_setstacksize(\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n+        let mut p = mem::ManuallyDrop::new(box p);\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n@@ -53,13 +53,20 @@ impl Thread {\n             }\n         };\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(\n+            &mut native,\n+            &attr,\n+            thread_start,\n+            &mut *p as &mut Box<dyn FnOnce()> as *mut _ as *mut _,\n+        );\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to manually drop it.\n+            mem::ManuallyDrop::drop(&mut p);\n             Err(io::Error::from_raw_os_error(ret))\n         } else {\n-            mem::forget(p); // ownership passed to pthread_create\n             Ok(Thread { id: native })\n         };\n "}, {"sha": "052f51a33ceeb53eb037db8f94e2c0e520aeeac5", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64e5327b6e7ad79f4a3ca7de17ac105c8c59277e/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=64e5327b6e7ad79f4a3ca7de17ac105c8c59277e", "patch": "@@ -20,7 +20,7 @@ pub struct Thread {\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n+        let mut p = mem::ManuallyDrop::new(box p);\n \n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n@@ -34,15 +34,17 @@ impl Thread {\n             ptr::null_mut(),\n             stack_size,\n             thread_start,\n-            &*p as *const _ as *mut _,\n+            &mut *p as &mut Box<dyn FnOnce()> as *mut _ as *mut _,\n             c::STACK_SIZE_PARAM_IS_A_RESERVATION,\n             ptr::null_mut(),\n         );\n \n         return if ret as usize == 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to manually drop it.\n+            mem::ManuallyDrop::drop(&mut p);\n             Err(io::Error::last_os_error())\n         } else {\n-            mem::forget(p); // ownership passed to CreateThread\n             Ok(Thread { handle: Handle::new(ret) })\n         };\n "}]}