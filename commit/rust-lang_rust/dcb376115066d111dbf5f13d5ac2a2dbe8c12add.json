{"sha": "dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "node_id": "C_kwDOAAsO6NoAKGRjYjM3NjExNTA2NmQxMTFkYmY1ZjEzZDVhYzJhMmRiZThjMTJhZGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-20T21:08:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-20T21:08:28Z"}, "message": "Auto merge of #103322 - matthiaskrgr:rollup-m9zgpft, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #103221 (Fix `SelfVisitor::is_self_ty` ICE)\n - #103230 (Clarify startup)\n - #103281 (Adjust `transmute{,_copy}` to be clearer about which of `T` and `U` is input vs output)\n - #103288 (Fixed docs typo in `library/std/src/time.rs`)\n - #103296 (+/- shortcut now only expand/collapse, not both)\n - #103297 (fix typo)\n - #103313 (Don't label `src/test` tests as `A-testsuite`)\n - #103315 (interpret: remove an incorrect assertion)\n - #103319 (Improve \"`~const` is not allowed here\" message)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9f47534866e40e8e35707253c4777a1ccfd64770", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f47534866e40e8e35707253c4777a1ccfd64770"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "html_url": "https://github.com/rust-lang/rust/commit/dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ffa67d7309047ff47b9c624ba4061fb8c004c31", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ffa67d7309047ff47b9c624ba4061fb8c004c31", "html_url": "https://github.com/rust-lang/rust/commit/5ffa67d7309047ff47b9c624ba4061fb8c004c31"}, {"sha": "f9944a9d2c3b8ec2ad2c6ebe9ca2ad34d52aa8ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9944a9d2c3b8ec2ad2c6ebe9ca2ad34d52aa8ab", "html_url": "https://github.com/rust-lang/rust/commit/f9944a9d2c3b8ec2ad2c6ebe9ca2ad34d52aa8ab"}], "stats": {"total": 365, "additions": 235, "deletions": 130}, "files": [{"sha": "f42aca685f60eaa46cdb5197b0351fac658c7079", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -38,6 +38,13 @@ enum SelfSemantic {\n     No,\n }\n \n+/// What is the context that prevents using `~const`?\n+enum DisallowTildeConstContext<'a> {\n+    TraitObject,\n+    ImplTrait,\n+    Fn(FnKind<'a>),\n+}\n+\n struct AstValidator<'a> {\n     session: &'a Session,\n \n@@ -56,7 +63,7 @@ struct AstValidator<'a> {\n     /// e.g., `impl Iterator<Item = impl Debug>`.\n     outer_impl_trait: Option<Span>,\n \n-    is_tilde_const_allowed: bool,\n+    disallow_tilde_const: Option<DisallowTildeConstContext<'a>>,\n \n     /// Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n     /// or `Foo::Bar<impl Trait>`\n@@ -93,18 +100,26 @@ impl<'a> AstValidator<'a> {\n         self.is_impl_trait_banned = old;\n     }\n \n-    fn with_tilde_const(&mut self, allowed: bool, f: impl FnOnce(&mut Self)) {\n-        let old = mem::replace(&mut self.is_tilde_const_allowed, allowed);\n+    fn with_tilde_const(\n+        &mut self,\n+        disallowed: Option<DisallowTildeConstContext<'a>>,\n+        f: impl FnOnce(&mut Self),\n+    ) {\n+        let old = mem::replace(&mut self.disallow_tilde_const, disallowed);\n         f(self);\n-        self.is_tilde_const_allowed = old;\n+        self.disallow_tilde_const = old;\n     }\n \n     fn with_tilde_const_allowed(&mut self, f: impl FnOnce(&mut Self)) {\n-        self.with_tilde_const(true, f)\n+        self.with_tilde_const(None, f)\n     }\n \n-    fn with_banned_tilde_const(&mut self, f: impl FnOnce(&mut Self)) {\n-        self.with_tilde_const(false, f)\n+    fn with_banned_tilde_const(\n+        &mut self,\n+        ctx: DisallowTildeConstContext<'a>,\n+        f: impl FnOnce(&mut Self),\n+    ) {\n+        self.with_tilde_const(Some(ctx), f)\n     }\n \n     fn with_let_management(\n@@ -172,7 +187,7 @@ impl<'a> AstValidator<'a> {\n     fn with_impl_trait(&mut self, outer: Option<Span>, f: impl FnOnce(&mut Self)) {\n         let old = mem::replace(&mut self.outer_impl_trait, outer);\n         if outer.is_some() {\n-            self.with_banned_tilde_const(f);\n+            self.with_banned_tilde_const(DisallowTildeConstContext::ImplTrait, f);\n         } else {\n             f(self);\n         }\n@@ -197,7 +212,10 @@ impl<'a> AstValidator<'a> {\n             TyKind::ImplTrait(..) => {\n                 self.with_impl_trait(Some(t.span), |this| visit::walk_ty(this, t))\n             }\n-            TyKind::TraitObject(..) => self.with_banned_tilde_const(|this| visit::walk_ty(this, t)),\n+            TyKind::TraitObject(..) => self\n+                .with_banned_tilde_const(DisallowTildeConstContext::TraitObject, |this| {\n+                    visit::walk_ty(this, t)\n+                }),\n             TyKind::Path(ref qself, ref path) => {\n                 // We allow these:\n                 //  - `Option<impl Trait>`\n@@ -1411,13 +1429,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     );\n                     err.emit();\n                 }\n-                (_, TraitBoundModifier::MaybeConst) => {\n-                    if !self.is_tilde_const_allowed {\n-                        self.err_handler()\n-                            .struct_span_err(bound.span(), \"`~const` is not allowed here\")\n-                            .note(\"only allowed on bounds on functions, traits' associated types and functions, const impls and its associated functions\")\n-                            .emit();\n-                    }\n+                (_, TraitBoundModifier::MaybeConst) if let Some(reason) = &self.disallow_tilde_const => {\n+                    let mut err = self.err_handler().struct_span_err(bound.span(), \"`~const` is not allowed here\");\n+                    match reason {\n+                        DisallowTildeConstContext::TraitObject => err.note(\"trait objects cannot have `~const` trait bounds\"),\n+                        DisallowTildeConstContext::ImplTrait => err.note(\"`impl Trait`s cannot have `~const` trait bounds\"),\n+                        DisallowTildeConstContext::Fn(FnKind::Closure(..)) => err.note(\"closures cannot have `~const` trait bounds\"),\n+                        DisallowTildeConstContext::Fn(FnKind::Fn(_, ident, ..)) => err.span_note(ident.span, \"this function is not `const`, so it cannot have `~const` trait bounds\"),\n+                    };\n+                    err.emit();\n                 }\n                 (_, TraitBoundModifier::MaybeConstMaybe) => {\n                     self.err_handler()\n@@ -1523,10 +1543,13 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             });\n         }\n \n-        let tilde_const_allowed = matches!(fk.header(), Some(FnHeader { .. }))\n-            || matches!(fk.ctxt(), Some(FnCtxt::Assoc(_)));\n+        let tilde_const_allowed =\n+            matches!(fk.header(), Some(FnHeader { constness: ast::Const::Yes(_), .. }))\n+                || matches!(fk.ctxt(), Some(FnCtxt::Assoc(_)));\n+\n+        let disallowed = (!tilde_const_allowed).then(|| DisallowTildeConstContext::Fn(fk));\n \n-        self.with_tilde_const(tilde_const_allowed, |this| visit::walk_fn(this, fk));\n+        self.with_tilde_const(disallowed, |this| visit::walk_fn(this, fk));\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n@@ -1770,7 +1793,7 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) ->\n         in_const_trait_impl: false,\n         has_proc_macro_decls: false,\n         outer_impl_trait: None,\n-        is_tilde_const_allowed: false,\n+        disallow_tilde_const: None,\n         is_impl_trait_banned: false,\n         is_assoc_ty_bound_banned: false,\n         forbidden_let_reason: Some(ForbiddenLetReason::GenericForbidden),"}, {"sha": "57e40e168fa48e0b281541ee9beaef7ce7293f95", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -35,7 +35,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert_eq!(discr.layout.ty, switch_ty);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n-                assert!(!targets.iter().is_empty());\n                 let mut target_block = targets.otherwise();\n \n                 for (const_int, target) in targets.iter() {"}, {"sha": "7edbb6f757ce16bba13623d69c73062f54aa3393", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -190,6 +190,7 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n         run_compiler(self.at_args, self.callbacks, self.file_loader, self.make_codegen_backend)\n     }\n }\n+\n fn run_compiler(\n     at_args: &[String],\n     callbacks: &mut (dyn Callbacks + Send),"}, {"sha": "89aaa0b95e41b24a680cffa4ad4b86d3b4d84612", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -25,7 +25,10 @@ use std::result;\n \n pub type Result<T> = result::Result<T, ErrorGuaranteed>;\n \n-/// Represents a compiler session.\n+/// Represents a compiler session. Note that every `Compiler` contains a\n+/// `Session`, but `Compiler` also contains some things that cannot be in\n+/// `Session`, due to `Session` being in a crate that has many fewer\n+/// dependencies than this crate.\n ///\n /// Can be used to run `rustc_interface` queries.\n /// Created by passing [`Config`] to [`run_compiler`]."}, {"sha": "519b8a7fc7c378ba8fe855fe5af803a22f1818a4", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -3,14 +3,8 @@ use libloading::Library;\n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-#[cfg(parallel_compiler)]\n-use rustc_data_structures::jobserver;\n use rustc_errors::registry::Registry;\n-#[cfg(parallel_compiler)]\n-use rustc_middle::ty::tls;\n use rustc_parse::validate_attr;\n-#[cfg(parallel_compiler)]\n-use rustc_query_impl::{QueryContext, QueryCtxt};\n use rustc_session as session;\n use rustc_session::config::CheckCfg;\n use rustc_session::config::{self, CrateType};\n@@ -25,8 +19,6 @@ use rustc_span::symbol::{sym, Symbol};\n use std::env;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n use std::mem;\n-#[cfg(not(parallel_compiler))]\n-use std::panic;\n use std::path::{Path, PathBuf};\n use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::OnceLock;\n@@ -135,13 +127,20 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     _threads: usize,\n     f: F,\n ) -> R {\n-    // The thread pool is a single thread in the non-parallel compiler.\n-    thread::scope(|s| {\n-        let mut builder = thread::Builder::new().name(\"rustc\".to_string());\n-        if let Some(size) = get_stack_size() {\n-            builder = builder.stack_size(size);\n-        }\n+    // The \"thread pool\" is a single spawned thread in the non-parallel\n+    // compiler. We run on a spawned thread instead of the main thread (a) to\n+    // provide control over the stack size, and (b) to increase similarity with\n+    // the parallel compiler, in particular to ensure there is no accidental\n+    // sharing of data between the main thread and the compilation thread\n+    // (which might cause problems for the parallel compiler).\n+    let mut builder = thread::Builder::new().name(\"rustc\".to_string());\n+    if let Some(size) = get_stack_size() {\n+        builder = builder.stack_size(size);\n+    }\n \n+    // We build the session globals and run `f` on the spawned thread, because\n+    // `SessionGlobals` does not impl `Send` in the non-parallel compiler.\n+    thread::scope(|s| {\n         // `unwrap` is ok here because `spawn_scoped` only panics if the thread\n         // name contains null bytes.\n         let r = builder\n@@ -151,55 +150,57 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n \n         match r {\n             Ok(v) => v,\n-            Err(e) => panic::resume_unwind(e),\n+            Err(e) => std::panic::resume_unwind(e),\n         }\n     })\n }\n \n-/// Creates a new thread and forwards information in thread locals to it.\n-/// The new thread runs the deadlock handler.\n-/// Must only be called when a deadlock is about to happen.\n-#[cfg(parallel_compiler)]\n-unsafe fn handle_deadlock() {\n-    let registry = rustc_rayon_core::Registry::current();\n-\n-    let query_map = tls::with(|tcx| {\n-        QueryCtxt::from_tcx(tcx)\n-            .try_collect_active_jobs()\n-            .expect(\"active jobs shouldn't be locked in deadlock handler\")\n-    });\n-    thread::spawn(move || rustc_query_impl::deadlock(query_map, &registry));\n-}\n-\n #[cfg(parallel_compiler)]\n pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     edition: Edition,\n     threads: usize,\n     f: F,\n ) -> R {\n-    let mut config = rayon::ThreadPoolBuilder::new()\n+    use rustc_data_structures::jobserver;\n+    use rustc_middle::ty::tls;\n+    use rustc_query_impl::{deadlock, QueryContext, QueryCtxt};\n+\n+    let mut builder = rayon::ThreadPoolBuilder::new()\n         .thread_name(|_| \"rustc\".to_string())\n         .acquire_thread_handler(jobserver::acquire_thread)\n         .release_thread_handler(jobserver::release_thread)\n         .num_threads(threads)\n-        .deadlock_handler(|| unsafe { handle_deadlock() });\n-\n+        .deadlock_handler(|| {\n+            // On deadlock, creates a new thread and forwards information in thread\n+            // locals to it. The new thread runs the deadlock handler.\n+            let query_map = tls::with(|tcx| {\n+                QueryCtxt::from_tcx(tcx)\n+                    .try_collect_active_jobs()\n+                    .expect(\"active jobs shouldn't be locked in deadlock handler\")\n+            });\n+            let registry = rustc_rayon_core::Registry::current();\n+            thread::spawn(move || deadlock(query_map, &registry));\n+        });\n     if let Some(size) = get_stack_size() {\n-        config = config.stack_size(size);\n+        builder = builder.stack_size(size);\n     }\n \n-    let with_pool = move |pool: &rayon::ThreadPool| pool.install(f);\n-\n+    // We create the session globals on the main thread, then create the thread\n+    // pool. Upon creation, each worker thread created gets a copy of the\n+    // session globals in TLS. This is possible because `SessionGlobals` impls\n+    // `Send` in the parallel compiler.\n     rustc_span::create_session_globals_then(edition, || {\n         rustc_span::with_session_globals(|session_globals| {\n-            // The main handler runs for each Rayon worker thread and sets up\n-            // the thread local rustc uses. `session_globals` is captured and set\n-            // on the new threads.\n-            let main_handler = move |thread: rayon::ThreadBuilder| {\n-                rustc_span::set_session_globals_then(session_globals, || thread.run())\n-            };\n-\n-            config.build_scoped(main_handler, with_pool).unwrap()\n+            builder\n+                .build_scoped(\n+                    // Initialize each new worker thread when created.\n+                    move |thread: rayon::ThreadBuilder| {\n+                        rustc_span::set_session_globals_then(session_globals, || thread.run())\n+                    },\n+                    // Run `f` on the first thread in the thread pool.\n+                    move |pool: &rayon::ThreadPool| pool.install(f),\n+                )\n+                .unwrap()\n         })\n     })\n }"}, {"sha": "ba3d8f64bbc76f10f92e962c6ff13831a549cfdd", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -1939,11 +1939,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 match ty.kind {\n                     TyKind::ImplicitSelf => true,\n                     TyKind::Path(None, _) => {\n-                        let path_res = self.r.partial_res_map[&ty.id].expect_full_res();\n-                        if let Res::SelfTyParam { .. } | Res::SelfTyAlias { .. } = path_res {\n+                        let path_res = self.r.partial_res_map[&ty.id].full_res();\n+                        if let Some(Res::SelfTyParam { .. } | Res::SelfTyAlias { .. }) = path_res {\n                             return true;\n                         }\n-                        Some(path_res) == self.impl_self\n+                        self.impl_self.is_some() && path_res == self.impl_self\n                     }\n                     _ => false,\n                 }"}, {"sha": "1589fee46bee639da97018ebcf729eadbafc5f7d", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -994,14 +994,14 @@ extern \"rust-intrinsic\" {\n     /// `transmute` is semantically equivalent to a bitwise move of one type\n     /// into another. It copies the bits from the source value into the\n     /// destination value, then forgets the original. Note that source and destination\n-    /// are passed by-value, which means if `T` or `U` contain padding, that padding\n+    /// are passed by-value, which means if `Src` or `Dst` contain padding, that padding\n     /// is *not* guaranteed to be preserved by `transmute`.\n     ///\n     /// Both the argument and the result must be [valid](../../nomicon/what-unsafe-does.html) at\n     /// their given type. Violating this condition leads to [undefined behavior][ub]. The compiler\n     /// will generate code *assuming that you, the programmer, ensure that there will never be\n     /// undefined behavior*. It is therefore your responsibility to guarantee that every value\n-    /// passed to `transmute` is valid at both types `T` and `U`. Failing to uphold this condition\n+    /// passed to `transmute` is valid at both types `Src` and `Dst`. Failing to uphold this condition\n     /// may lead to unexpected and unstable compilation results. This makes `transmute` **incredibly\n     /// unsafe**. `transmute` should be the absolute last resort.\n     ///\n@@ -1012,7 +1012,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Because `transmute` is a by-value operation, alignment of the *transmuted values\n     /// themselves* is not a concern. As with any other function, the compiler already ensures\n-    /// both `T` and `U` are properly aligned. However, when transmuting values that *point\n+    /// both `Src` and `Dst` are properly aligned. However, when transmuting values that *point\n     /// elsewhere* (such as pointers, references, boxes\u2026), the caller has to ensure proper\n     /// alignment of the pointed-to values.\n     ///\n@@ -1248,7 +1248,7 @@ extern \"rust-intrinsic\" {\n     #[rustc_allowed_through_unstable_modules]\n     #[rustc_const_stable(feature = \"const_transmute\", since = \"1.56.0\")]\n     #[rustc_diagnostic_item = \"transmute\"]\n-    pub fn transmute<T, U>(e: T) -> U;\n+    pub fn transmute<Src, Dst>(src: Src) -> Dst;\n \n     /// Returns `true` if the actual type given as `T` requires drop\n     /// glue; returns `false` if the actual type provided for `T`"}, {"sha": "9195da5a44f42bc7fe575d4916cf2d88b222594a", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -1008,18 +1008,18 @@ pub fn copy<T: Copy>(x: &T) -> T {\n     *x\n }\n \n-/// Interprets `src` as having type `&U`, and then reads `src` without moving\n+/// Interprets `src` as having type `&Dst`, and then reads `src` without moving\n /// the contained value.\n ///\n-/// This function will unsafely assume the pointer `src` is valid for [`size_of::<U>`][size_of]\n-/// bytes by transmuting `&T` to `&U` and then reading the `&U` (except that this is done in a way\n-/// that is correct even when `&U` has stricter alignment requirements than `&T`). It will also\n-/// unsafely create a copy of the contained value instead of moving out of `src`.\n+/// This function will unsafely assume the pointer `src` is valid for [`size_of::<Dst>`][size_of]\n+/// bytes by transmuting `&Src` to `&Dst` and then reading the `&Dst` (except that this is done\n+/// in a way that is correct even when `&Dst` has stricter alignment requirements than `&Src`).\n+/// It will also unsafely create a copy of the contained value instead of moving out of `src`.\n ///\n-/// It is not a compile-time error if `T` and `U` have different sizes, but it\n-/// is highly encouraged to only invoke this function where `T` and `U` have the\n-/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n-/// `T`.\n+/// It is not a compile-time error if `Src` and `Dst` have different sizes, but it\n+/// is highly encouraged to only invoke this function where `Src` and `Dst` have the\n+/// same size. This function triggers [undefined behavior][ub] if `Dst` is larger than\n+/// `Src`.\n ///\n /// [ub]: ../../reference/behavior-considered-undefined.html\n ///\n@@ -1052,19 +1052,22 @@ pub fn copy<T: Copy>(x: &T) -> T {\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_transmute_copy\", issue = \"83165\")]\n-pub const unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    assert!(size_of::<T>() >= size_of::<U>(), \"cannot transmute_copy if U is larger than T\");\n+pub const unsafe fn transmute_copy<Src, Dst>(src: &Src) -> Dst {\n+    assert!(\n+        size_of::<Src>() >= size_of::<Dst>(),\n+        \"cannot transmute_copy if Dst is larger than Src\"\n+    );\n \n-    // If U has a higher alignment requirement, src might not be suitably aligned.\n-    if align_of::<U>() > align_of::<T>() {\n+    // If Dst has a higher alignment requirement, src might not be suitably aligned.\n+    if align_of::<Dst>() > align_of::<Src>() {\n         // SAFETY: `src` is a reference which is guaranteed to be valid for reads.\n         // The caller must guarantee that the actual transmutation is safe.\n-        unsafe { ptr::read_unaligned(src as *const T as *const U) }\n+        unsafe { ptr::read_unaligned(src as *const Src as *const Dst) }\n     } else {\n         // SAFETY: `src` is a reference which is guaranteed to be valid for reads.\n-        // We just checked that `src as *const U` was properly aligned.\n+        // We just checked that `src as *const Dst` was properly aligned.\n         // The caller must guarantee that the actual transmutation is safe.\n-        unsafe { ptr::read(src as *const T as *const U) }\n+        unsafe { ptr::read(src as *const Src as *const Dst) }\n     }\n }\n "}, {"sha": "0362e1c8afb5e79c7f41c134f0852dc28cad0f02", "filename": "library/core/tests/mem.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/library%2Fcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/library%2Fcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fmem.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -130,7 +130,11 @@ fn test_transmute_copy_grow_panics() {\n             payload\n                 .downcast::<&'static str>()\n                 .and_then(|s| {\n-                    if *s == \"cannot transmute_copy if U is larger than T\" { Ok(s) } else { Err(s) }\n+                    if *s == \"cannot transmute_copy if Dst is larger than Src\" {\n+                        Ok(s)\n+                    } else {\n+                        Err(s)\n+                    }\n                 })\n                 .unwrap_or_else(|p| panic::resume_unwind(p));\n         }"}, {"sha": "d4a1b9d9b50c80ec654ba5b6e104258c4a45289e", "filename": "library/std/src/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -356,7 +356,7 @@ impl Instant {\n     ///\n     /// # Panics\n     ///\n-    /// Previous rust versions panicked when self was earlier than the current time. Currently this\n+    /// Previous rust versions panicked when the current time was earlier than self. Currently this\n     /// method returns a Duration of zero in that case. Future versions may reintroduce the panic.\n     /// See [Monotonicity].\n     ///"}, {"sha": "432e0cfc960e367674770943b1b05e4961917aac", "filename": "src/doc/rustc/src/platform-support/armeb-unknown-linux-gnueabi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmeb-unknown-linux-gnueabi.md", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmeb-unknown-linux-gnueabi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmeb-unknown-linux-gnueabi.md?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -1,7 +1,7 @@\n # armeb-unknown-linux-gnueabi\n **Tier: 3**\n \n-Target for cross-compiling Linux user-mode applications targetting the ARM BE8 architecture.\n+Target for cross-compiling Linux user-mode applications targeting the ARM BE8 architecture.\n \n ## Overview\n BE8 architecture retains the same little-endian ordered code-stream used by conventional little endian ARM systems, however the data accesses are in big-endian. BE8 is used primarily in high-performance networking applications where the ability to read packets in their native \"Network Byte Order\" is important (many network protocols transmit data in big-endian byte order for their wire formats)."}, {"sha": "0b816eace64b14ce9ed157d8cb2f38019f4b6e48", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -409,9 +409,12 @@ function loadCss(cssFileName) {\n                 break;\n \n             case \"+\":\n+                ev.preventDefault();\n+                expandAllDocs();\n+                break;\n             case \"-\":\n                 ev.preventDefault();\n-                toggleAllDocs();\n+                collapseAllDocs();\n                 break;\n \n             case \"?\":\n@@ -614,45 +617,43 @@ function loadCss(cssFileName) {\n         sidebarElems.appendChild(ul);\n     }\n \n+    function expandAllDocs() {\n+        const innerToggle = document.getElementById(toggleAllDocsId);\n+        removeClass(innerToggle, \"will-expand\");\n+        onEachLazy(document.getElementsByClassName(\"rustdoc-toggle\"), e => {\n+            if (!hasClass(e, \"type-contents-toggle\")) {\n+                e.open = true;\n+            }\n+        });\n+        innerToggle.title = \"collapse all docs\";\n+        innerToggle.children[0].innerText = \"\\u2212\"; // \"\\u2212\" is \"\u2212\" minus sign\n+    }\n \n-    function labelForToggleButton(sectionIsCollapsed) {\n-        if (sectionIsCollapsed) {\n-            // button will expand the section\n-            return \"+\";\n-        }\n-        // button will collapse the section\n-        // note that this text is also set in the HTML template in ../render/mod.rs\n-        return \"\\u2212\"; // \"\\u2212\" is \"\u2212\" minus sign\n+    function collapseAllDocs() {\n+        const innerToggle = document.getElementById(toggleAllDocsId);\n+        addClass(innerToggle, \"will-expand\");\n+        onEachLazy(document.getElementsByClassName(\"rustdoc-toggle\"), e => {\n+            if (e.parentNode.id !== \"implementations-list\" ||\n+                (!hasClass(e, \"implementors-toggle\") &&\n+                 !hasClass(e, \"type-contents-toggle\"))\n+            ) {\n+                e.open = false;\n+            }\n+        });\n+        innerToggle.title = \"expand all docs\";\n+        innerToggle.children[0].innerText = \"+\";\n     }\n \n     function toggleAllDocs() {\n         const innerToggle = document.getElementById(toggleAllDocsId);\n         if (!innerToggle) {\n             return;\n         }\n-        let sectionIsCollapsed = false;\n         if (hasClass(innerToggle, \"will-expand\")) {\n-            removeClass(innerToggle, \"will-expand\");\n-            onEachLazy(document.getElementsByClassName(\"rustdoc-toggle\"), e => {\n-                if (!hasClass(e, \"type-contents-toggle\")) {\n-                    e.open = true;\n-                }\n-            });\n-            innerToggle.title = \"collapse all docs\";\n+            expandAllDocs();\n         } else {\n-            addClass(innerToggle, \"will-expand\");\n-            onEachLazy(document.getElementsByClassName(\"rustdoc-toggle\"), e => {\n-                if (e.parentNode.id !== \"implementations-list\" ||\n-                    (!hasClass(e, \"implementors-toggle\") &&\n-                     !hasClass(e, \"type-contents-toggle\"))\n-                ) {\n-                    e.open = false;\n-                }\n-            });\n-            sectionIsCollapsed = true;\n-            innerToggle.title = \"expand all docs\";\n+            collapseAllDocs();\n         }\n-        innerToggle.children[0].innerText = labelForToggleButton(sectionIsCollapsed);\n     }\n \n     (function() {"}, {"sha": "9068680d640c18ea111b95a011d901570bc9c998", "filename": "src/test/rustdoc-gui/shortcuts.goml", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Frustdoc-gui%2Fshortcuts.goml", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Frustdoc-gui%2Fshortcuts.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fshortcuts.goml?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -11,3 +11,21 @@ press-key: \"?\"\n assert-css: (\"#help-button .popover\", {\"display\": \"block\"})\n press-key: \"Escape\"\n assert-css: (\"#help-button .popover\", {\"display\": \"none\"})\n+// Checking doc collapse and expand.\n+// It should be displaying a \"-\":\n+assert-text: (\"#toggle-all-docs\", \"[\\u2212]\")\n+press-key: \"-\"\n+wait-for-text: (\"#toggle-all-docs\", \"[+]\")\n+assert-attribute: (\"#toggle-all-docs\", {\"class\": \"will-expand\"})\n+// Pressing it again shouldn't do anything.\n+press-key: \"-\"\n+assert-text: (\"#toggle-all-docs\", \"[+]\")\n+assert-attribute: (\"#toggle-all-docs\", {\"class\": \"will-expand\"})\n+// Expanding now.\n+press-key: \"+\"\n+wait-for-text: (\"#toggle-all-docs\", \"[\\u2212]\")\n+assert-attribute: (\"#toggle-all-docs\", {\"class\": \"\"})\n+// Pressing it again shouldn't do anything.\n+press-key: \"+\"\n+assert-text: (\"#toggle-all-docs\", \"[\\u2212]\")\n+assert-attribute: (\"#toggle-all-docs\", {\"class\": \"\"})"}, {"sha": "520efccae51c4f7c2b9e77c4047345034c59eace", "filename": "src/test/ui/issues/issue-6458-3.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Fissues%2Fissue-6458-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Fissues%2Fissue-6458-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6458-3.stderr?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -2,12 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-6458-3.rs:4:5\n    |\n LL |     mem::transmute(0);\n-   |     ^^^^^^^^^^^^^^ cannot infer type of the type parameter `U` declared on the function `transmute`\n+   |     ^^^^^^^^^^^^^^ cannot infer type of the type parameter `Dst` declared on the function `transmute`\n    |\n help: consider specifying the generic arguments\n    |\n-LL |     mem::transmute::<i32, U>(0);\n-   |                   ++++++++++\n+LL |     mem::transmute::<i32, Dst>(0);\n+   |                   ++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "469d9d7c860cafff6b217253754a2462b2b5247d", "filename": "src/test/ui/resolve/issue-103202.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Fresolve%2Fissue-103202.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Fresolve%2Fissue-103202.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-103202.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -0,0 +1,7 @@\n+struct S {}\n+\n+impl S {\n+    fn f(self: &S::x) {} //~ ERROR ambiguous associated type\n+}\n+\n+fn main() {}"}, {"sha": "880389371ef701633073dee31e2ed2484c3f376c", "filename": "src/test/ui/resolve/issue-103202.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Fresolve%2Fissue-103202.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Fresolve%2Fissue-103202.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-103202.stderr?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -0,0 +1,9 @@\n+error[E0223]: ambiguous associated type\n+  --> $DIR/issue-103202.rs:4:17\n+   |\n+LL |     fn f(self: &S::x) {}\n+   |                 ^^^^ help: use fully-qualified syntax: `<S as Trait>::x`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0223`."}, {"sha": "21ddf4ab4e5f4ad2f56ebb176c6c00a666a78266", "filename": "src/test/ui/rfc-2632-const-trait-impl/issue-90052.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-90052.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-90052.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-90052.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -0,0 +1,9 @@\n+#![feature(const_trait_impl)]\n+\n+#[const_trait]\n+trait Bar {}\n+\n+fn foo<T>() where T: ~const Bar {}\n+//~^ ERROR `~const` is not allowed\n+\n+fn main() {}"}, {"sha": "b2a9365378b332c7be1a57482be214d4ecbf420d", "filename": "src/test/ui/rfc-2632-const-trait-impl/issue-90052.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-90052.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-90052.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-90052.stderr?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -0,0 +1,14 @@\n+error: `~const` is not allowed here\n+  --> $DIR/issue-90052.rs:6:22\n+   |\n+LL | fn foo<T>() where T: ~const Bar {}\n+   |                      ^^^^^^^^^^\n+   |\n+note: this function is not `const`, so it cannot have `~const` trait bounds\n+  --> $DIR/issue-90052.rs:6:4\n+   |\n+LL | fn foo<T>() where T: ~const Bar {}\n+   |    ^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "78a64b9018a564c484f5ccea76e02204bb097d3d", "filename": "src/test/ui/rfc-2632-const-trait-impl/tilde-const-and-const-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftilde-const-and-const-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftilde-const-and-const-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftilde-const-and-const-params.rs?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -1,4 +1,3 @@\n-// check-pass\n #![feature(const_trait_impl)]\n #![feature(generic_arg_infer)]\n #![feature(generic_const_exprs)]\n@@ -24,6 +23,7 @@ impl const Add42 for () {\n }\n \n fn bar<A: ~const Add42, const N: usize>(_: Foo<N>) -> Foo<{ A::add(N) }> {\n+    //~^ ERROR `~const` is not allowed here\n     Foo\n }\n "}, {"sha": "aae72f36e5778a7ccabb505d4f09476624bd600e", "filename": "src/test/ui/rfc-2632-const-trait-impl/tilde-const-and-const-params.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftilde-const-and-const-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftilde-const-and-const-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftilde-const-and-const-params.stderr?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -0,0 +1,14 @@\n+error: `~const` is not allowed here\n+  --> $DIR/tilde-const-and-const-params.rs:25:11\n+   |\n+LL | fn bar<A: ~const Add42, const N: usize>(_: Foo<N>) -> Foo<{ A::add(N) }> {\n+   |           ^^^^^^^^^^^^\n+   |\n+note: this function is not `const`, so it cannot have `~const` trait bounds\n+  --> $DIR/tilde-const-and-const-params.rs:25:4\n+   |\n+LL | fn bar<A: ~const Add42, const N: usize>(_: Foo<N>) -> Foo<{ A::add(N) }> {\n+   |    ^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "84867cb4a5342cfb7cd10fa0b37dfd568484da7b", "filename": "src/test/ui/rfc-2632-const-trait-impl/tilde-const-invalid-places.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftilde-const-invalid-places.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftilde-const-invalid-places.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftilde-const-invalid-places.stderr?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -4,31 +4,31 @@ error: `~const` is not allowed here\n LL | fn rpit() -> impl ~const T { S }\n    |                   ^^^^^^^^\n    |\n-   = note: only allowed on bounds on functions, traits' associated types and functions, const impls and its associated functions\n+   = note: `impl Trait`s cannot have `~const` trait bounds\n \n error: `~const` is not allowed here\n   --> $DIR/tilde-const-invalid-places.rs:12:17\n    |\n LL | fn apit(_: impl ~const T) {}\n    |                 ^^^^^^^^\n    |\n-   = note: only allowed on bounds on functions, traits' associated types and functions, const impls and its associated functions\n+   = note: `impl Trait`s cannot have `~const` trait bounds\n \n error: `~const` is not allowed here\n   --> $DIR/tilde-const-invalid-places.rs:15:50\n    |\n LL | fn rpit_assoc_bound() -> impl IntoIterator<Item: ~const T> { Some(S) }\n    |                                                  ^^^^^^^^\n    |\n-   = note: only allowed on bounds on functions, traits' associated types and functions, const impls and its associated functions\n+   = note: `impl Trait`s cannot have `~const` trait bounds\n \n error: `~const` is not allowed here\n   --> $DIR/tilde-const-invalid-places.rs:18:48\n    |\n LL | fn apit_assoc_bound(_: impl IntoIterator<Item: ~const T>) {}\n    |                                                ^^^^^^^^\n    |\n-   = note: only allowed on bounds on functions, traits' associated types and functions, const impls and its associated functions\n+   = note: `impl Trait`s cannot have `~const` trait bounds\n \n error: `~const` and `?` are mutually exclusive\n   --> $DIR/tilde-const-invalid-places.rs:21:25"}, {"sha": "04c2a0507acc8fd0af2e6e966cc24979a6608efa", "filename": "triagebot.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcb376115066d111dbf5f13d5ac2a2dbe8c12add/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=dcb376115066d111dbf5f13d5ac2a2dbe8c12add", "patch": "@@ -217,7 +217,6 @@ trigger_files = [\n \n [autolabel.\"A-testsuite\"]\n trigger_files = [\n-    \"src/test\",\n     \"src/ci\",\n     \"src/tools/compiletest\",\n     \"src/tools/cargotest\","}]}