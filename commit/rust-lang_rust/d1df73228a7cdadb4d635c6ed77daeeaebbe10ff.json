{"sha": "d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZGY3MzIyOGE3Y2RhZGI0ZDYzNWM2ZWQ3N2RhZWVhZWJiZTEwZmY=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2020-12-11T22:29:53Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-04-05T11:33:45Z"}, "message": "A new lint for shared code in if blocks\n\n* Added expression check for shared_code_in_if_blocks\n* Finishing touches for the shared_code_in_if_blocks lint\n* Applying PR suggestions\n* Update lints yay\n* Moved test into subfolder", "tree": {"sha": "38a5b89fa161a1d5bde60366541eaf20da9b7364", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38a5b89fa161a1d5bde60366541eaf20da9b7364"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "html_url": "https://github.com/rust-lang/rust/commit/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "232e2b79f2e76cc7e1c76e0d35968711960dedee", "url": "https://api.github.com/repos/rust-lang/rust/commits/232e2b79f2e76cc7e1c76e0d35968711960dedee", "html_url": "https://github.com/rust-lang/rust/commit/232e2b79f2e76cc7e1c76e0d35968711960dedee"}], "stats": {"total": 901, "additions": 737, "deletions": 164}, "files": [{"sha": "790bca4ac18639981d8efcf192e38b543a90692b", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -2455,6 +2455,7 @@ Released 2018-09-13\n [`shadow_reuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_reuse\n [`shadow_same`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_same\n [`shadow_unrelated`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_unrelated\n+[`shared_code_in_if_blocks`]: https://rust-lang.github.io/rust-clippy/master/index.html#shared_code_in_if_blocks\n [`short_circuit_statement`]: https://rust-lang.github.io/rust-clippy/master/index.html#short_circuit_statement\n [`should_assert_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_assert_eq\n [`should_implement_trait`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait"}, {"sha": "29ff19707055cbcec7433e2ccb1ff9e72b5401bf", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 280, "deletions": 25, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -3,7 +3,10 @@ use clippy_utils::{eq_expr_value, in_macro, search_same, SpanlessEq, SpanlessHas\n use clippy_utils::{get_parent_expr, if_sequence};\n use rustc_hir::{Block, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+use std::borrow::Cow;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for consecutive `if`s with the same condition.\n@@ -104,7 +107,45 @@ declare_clippy_lint! {\n     \"`if` with the same `then` and `else` blocks\"\n }\n \n-declare_lint_pass!(CopyAndPaste => [IFS_SAME_COND, SAME_FUNCTIONS_IN_IF_CONDITION, IF_SAME_THEN_ELSE]);\n+declare_clippy_lint! {\n+    /// **What it does:** Checks if the `if` and `else` block contain shared code that can be\n+    /// moved out of the blocks.\n+    ///\n+    /// **Why is this bad?** Duplicate code is less maintainable.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let foo = if \u2026 {\n+    ///     println!(\"Hello World\");\n+    ///     13\n+    /// } else {\n+    ///     println!(\"Hello World\");\n+    ///     42\n+    /// };\n+    /// ```\n+    ///\n+    /// Could be written as:\n+    /// ```ignore\n+    /// println!(\"Hello World\");\n+    /// let foo = if \u2026 {\n+    ///     13\n+    /// } else {\n+    ///     42\n+    /// };\n+    /// ```\n+    pub SHARED_CODE_IN_IF_BLOCKS,\n+    pedantic,\n+    \"`if` statement with shared code in all blocks\"\n+}\n+\n+declare_lint_pass!(CopyAndPaste => [\n+    IFS_SAME_COND,\n+    SAME_FUNCTIONS_IN_IF_CONDITION,\n+    IF_SAME_THEN_ELSE,\n+    SHARED_CODE_IN_IF_BLOCKS\n+]);\n \n impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n@@ -121,30 +162,256 @@ impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n             }\n \n             let (conds, blocks) = if_sequence(expr);\n-            lint_same_then_else(cx, &blocks);\n+            // Conditions\n             lint_same_cond(cx, &conds);\n             lint_same_fns_in_if_cond(cx, &conds);\n+            // Block duplication\n+            lint_same_then_else(cx, &blocks, conds.len() != blocks.len(), expr);\n         }\n     }\n }\n \n-/// Implementation of `IF_SAME_THEN_ELSE`.\n-fn lint_same_then_else(cx: &LateContext<'_>, blocks: &[&Block<'_>]) {\n-    let eq: &dyn Fn(&&Block<'_>, &&Block<'_>) -> bool =\n-        &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).eq_block(lhs, rhs) };\n+/// Implementation of `SHARED_CODE_IN_IF_BLOCKS` and `IF_SAME_THEN_ELSE` if the blocks are equal.\n+fn lint_same_then_else<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    blocks: &[&Block<'tcx>],\n+    has_unconditional_else: bool,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    // We only lint ifs with multiple blocks\n+    // TODO xFrednet 2021-01-01: Check if it's an else if block\n+    if blocks.len() < 2 {\n+        return;\n+    }\n \n-    if let Some((i, j)) = search_same_sequenced(blocks, eq) {\n-        span_lint_and_note(\n+    let has_expr = blocks[0].expr.is_some();\n+\n+    // Check if each block has shared code\n+    let mut start_eq = usize::MAX;\n+    let mut end_eq = usize::MAX;\n+    let mut expr_eq = true;\n+    for (index, win) in blocks.windows(2).enumerate() {\n+        let l_stmts = win[0].stmts;\n+        let r_stmts = win[1].stmts;\n+\n+        let mut evaluator = SpanlessEq::new(cx);\n+        let current_start_eq = count_eq(&mut l_stmts.iter(), &mut r_stmts.iter(), |l, r| evaluator.eq_stmt(l, r));\n+        let current_end_eq = count_eq(&mut l_stmts.iter().rev(), &mut r_stmts.iter().rev(), |l, r| {\n+            evaluator.eq_stmt(l, r)\n+        });\n+        let block_expr_eq = both(&win[0].expr, &win[1].expr, |l, r| evaluator.eq_expr(l, r));\n+\n+        // IF_SAME_THEN_ELSE\n+        // We only lint the first two blocks (index == 0). Further blocks will be linted when that if\n+        // statement is checked\n+        if index == 0 && block_expr_eq && l_stmts.len() == r_stmts.len() && l_stmts.len() == current_start_eq {\n+            span_lint_and_note(\n+                cx,\n+                IF_SAME_THEN_ELSE,\n+                win[0].span,\n+                \"this `if` has identical blocks\",\n+                Some(win[1].span),\n+                \"same as this\",\n+            );\n+\n+            return;\n+        }\n+\n+        start_eq = start_eq.min(current_start_eq);\n+        end_eq = end_eq.min(current_end_eq);\n+        expr_eq &= block_expr_eq;\n+\n+        // We can return if the eq count is 0 from both sides or if it has no unconditional else case\n+        if !has_unconditional_else || (start_eq == 0 && end_eq == 0 && (has_expr && !expr_eq)) {\n+            return;\n+        }\n+    }\n+\n+    if has_expr && !expr_eq {\n+        end_eq = 0;\n+    }\n+\n+    // Check if the regions are overlapping. Set `end_eq` to prevent the overlap\n+    let min_block_size = blocks.iter().map(|x| x.stmts.len()).min().unwrap();\n+    if (start_eq + end_eq) > min_block_size {\n+        end_eq = min_block_size - start_eq;\n+    }\n+\n+    // Only the start is the same\n+    if start_eq != 0 && end_eq == 0 && (!has_expr || !expr_eq) {\n+        emit_shared_code_in_if_blocks_lint(cx, start_eq, 0, false, blocks, expr);\n+    } else if end_eq != 0 && (!has_expr || !expr_eq) {\n+        let block = blocks[blocks.len() - 1];\n+        let stmts = block.stmts.split_at(start_eq).1;\n+        let (block_stmts, moved_stmts) = stmts.split_at(stmts.len() - end_eq);\n+\n+        // Scan block\n+        let mut walker = SymbolFinderVisitor::new(cx);\n+        for stmt in block_stmts {\n+            intravisit::walk_stmt(&mut walker, stmt);\n+        }\n+        let mut block_defs = walker.defs;\n+\n+        // Scan moved stmts\n+        let mut moved_start: Option<usize> = None;\n+        let mut walker = SymbolFinderVisitor::new(cx);\n+        for (index, stmt) in moved_stmts.iter().enumerate() {\n+            intravisit::walk_stmt(&mut walker, stmt);\n+\n+            for value in &walker.uses {\n+                // Well we can't move this and all prev statements. So reset\n+                if block_defs.contains(&value) {\n+                    moved_start = Some(index + 1);\n+                    walker.defs.drain().for_each(|x| {\n+                        block_defs.insert(x);\n+                    });\n+                }\n+            }\n+\n+            walker.uses.clear();\n+        }\n+\n+        if let Some(moved_start) = moved_start {\n+            end_eq -= moved_start;\n+        }\n+\n+        let mut end_linable = true;\n+        if let Some(expr) = block.expr {\n+            intravisit::walk_expr(&mut walker, expr);\n+            end_linable = walker.uses.iter().any(|x| !block_defs.contains(x));\n+        }\n+\n+        emit_shared_code_in_if_blocks_lint(cx, start_eq, end_eq, end_linable, blocks, expr);\n+    }\n+}\n+\n+fn emit_shared_code_in_if_blocks_lint(\n+    cx: &LateContext<'tcx>,\n+    start_stmts: usize,\n+    end_stmts: usize,\n+    lint_end: bool,\n+    blocks: &[&Block<'tcx>],\n+    if_expr: &'tcx Expr<'_>,\n+) {\n+    if start_stmts == 0 && !lint_end {\n+        return;\n+    }\n+\n+    // (help, span, suggestion)\n+    let mut suggestions: Vec<(&str, Span, String)> = vec![];\n+\n+    if start_stmts > 0 {\n+        let block = blocks[0];\n+        let span_start = first_line_of_span(cx, if_expr.span).shrink_to_lo();\n+        let span_end = block.stmts[start_stmts - 1].span.source_callsite();\n+\n+        let cond_span = first_line_of_span(cx, if_expr.span).until(block.span);\n+        let cond_snippet = reindent_multiline(snippet(cx, cond_span, \"_\"), false, None);\n+        let cond_indent = indent_of(cx, cond_span);\n+        let moved_span = block.stmts[0].span.source_callsite().to(span_end);\n+        let moved_snippet = reindent_multiline(snippet(cx, moved_span, \"_\"), true, None);\n+        let suggestion = moved_snippet.to_string() + \"\\n\" + &cond_snippet + \"{\";\n+        let suggestion = reindent_multiline(Cow::Borrowed(&suggestion), true, cond_indent);\n+\n+        let span = span_start.to(span_end);\n+        suggestions.push((\"START HELP\", span, suggestion.to_string()));\n+    }\n+\n+    if lint_end {\n+        let block = blocks[blocks.len() - 1];\n+        let span_end = block.span.shrink_to_hi();\n+\n+        let moved_start = if end_stmts == 0 && block.expr.is_some() {\n+            block.expr.unwrap().span\n+        } else {\n+            block.stmts[block.stmts.len() - end_stmts].span\n+        }\n+        .source_callsite();\n+        let moved_end = if let Some(expr) = block.expr {\n+            expr.span\n+        } else {\n+            block.stmts[block.stmts.len() - 1].span\n+        }\n+        .source_callsite();\n+\n+        let moved_span = moved_start.to(moved_end);\n+        let moved_snipped = reindent_multiline(snippet(cx, moved_span, \"_\"), true, None);\n+        let indent = indent_of(cx, if_expr.span.shrink_to_hi());\n+        let suggestion = \"}\\n\".to_string() + &moved_snipped;\n+        let suggestion = reindent_multiline(Cow::Borrowed(&suggestion), true, indent);\n+\n+        let span = moved_start.to(span_end);\n+        suggestions.push((\"END_RANGE\", span, suggestion.to_string()));\n+    }\n+\n+    if suggestions.len() == 1 {\n+        let (_, span, sugg) = &suggestions[0];\n+        span_lint_and_sugg(\n             cx,\n-            IF_SAME_THEN_ELSE,\n-            j.span,\n-            \"this `if` has identical blocks\",\n-            Some(i.span),\n-            \"same as this\",\n+            SHARED_CODE_IN_IF_BLOCKS,\n+            *span,\n+            \"All code blocks contain the same code\",\n+            \"Consider moving the code out like this\",\n+            sugg.clone(),\n+            Applicability::Unspecified,\n+        );\n+    } else {\n+        span_lint_and_then(\n+            cx,\n+            SHARED_CODE_IN_IF_BLOCKS,\n+            if_expr.span,\n+            \"All if blocks contain the same code\",\n+            move |diag| {\n+                for (help, span, sugg) in suggestions {\n+                    diag.span_suggestion(span, help, sugg, Applicability::Unspecified);\n+                }\n+            },\n         );\n     }\n }\n \n+pub struct SymbolFinderVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    defs: FxHashSet<HirId>,\n+    uses: FxHashSet<HirId>,\n+}\n+\n+impl<'a, 'tcx> SymbolFinderVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        SymbolFinderVisitor {\n+            cx,\n+            defs: FxHashSet::default(),\n+            uses: FxHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SymbolFinderVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::All(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx rustc_hir::Local<'tcx>) {\n+        let local_id = l.pat.hir_id;\n+        self.defs.insert(local_id);\n+        if let Some(expr) = l.init {\n+            intravisit::walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn visit_qpath(&mut self, qpath: &'tcx rustc_hir::QPath<'tcx>, id: HirId, _span: rustc_span::Span) {\n+        if let rustc_hir::QPath::Resolved(_, ref path) = *qpath {\n+            if path.segments.len() == 1 {\n+                if let rustc_hir::def::Res::Local(var) = self.cx.qpath_res(qpath, id) {\n+                    self.uses.insert(var);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Implementation of `IFS_SAME_COND`.\n fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n     let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n@@ -198,15 +465,3 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n         );\n     }\n }\n-\n-fn search_same_sequenced<T, Eq>(exprs: &[T], eq: Eq) -> Option<(&T, &T)>\n-where\n-    Eq: Fn(&T, &T) -> bool,\n-{\n-    for win in exprs.windows(2) {\n-        if eq(&win[0], &win[1]) {\n-            return Some((&win[0], &win[1]));\n-        }\n-    }\n-    None\n-}"}, {"sha": "ba98a2a2607d75cdfd045cbe485daf0389df8df1", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -616,6 +616,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &copies::IFS_SAME_COND,\n         &copies::IF_SAME_THEN_ELSE,\n         &copies::SAME_FUNCTIONS_IN_IF_CONDITION,\n+        &copies::SHARED_CODE_IN_IF_BLOCKS,\n         &copy_iterator::COPY_ITERATOR,\n         &create_dir::CREATE_DIR,\n         &dbg_macro::DBG_MACRO,\n@@ -1365,6 +1366,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&casts::PTR_AS_PTR),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::SAME_FUNCTIONS_IN_IF_CONDITION),\n+        LintId::of(&copies::SHARED_CODE_IN_IF_BLOCKS),\n         LintId::of(&copy_iterator::COPY_ITERATOR),\n         LintId::of(&default::DEFAULT_TRAIT_ACCESS),\n         LintId::of(&dereference::EXPLICIT_DEREF_METHODS),"}, {"sha": "b736eeff6bf7ec4476658eac9bdff7e480b33c4b", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -464,32 +464,28 @@ impl DecimalLiteralRepresentation {\n             {\n                 return Err(WarningType::DecimalRepresentation);\n             }\n-        } else if digits.len() < 4 {\n-            // Lint for Literals with a hex-representation of 2 or 3 digits\n-            let f = &digits[0..1]; // first digit\n-            let s = &digits[1..]; // suffix\n-\n-            // Powers of 2\n-            if ((f.eq(\"1\") || f.eq(\"2\") || f.eq(\"4\") || f.eq(\"8\")) && s.chars().all(|c| c == '0'))\n-                // Powers of 2 minus 1\n-                || ((f.eq(\"1\") || f.eq(\"3\") || f.eq(\"7\") || f.eq(\"F\")) && s.chars().all(|c| c == 'F'))\n-            {\n-                return Err(WarningType::DecimalRepresentation);\n-            }\n         } else {\n-            // Lint for Literals with a hex-representation of 4 digits or more\n             let f = &digits[0..1]; // first digit\n             let m = &digits[1..digits.len() - 1]; // middle digits, except last\n             let s = &digits[1..]; // suffix\n-\n-            // Powers of 2 with a margin of +15/-16\n-            if ((f.eq(\"1\") || f.eq(\"2\") || f.eq(\"4\") || f.eq(\"8\")) && m.chars().all(|c| c == '0'))\n-                || ((f.eq(\"1\") || f.eq(\"3\") || f.eq(\"7\") || f.eq(\"F\")) && m.chars().all(|c| c == 'F'))\n-                // Lint for representations with only 0s and Fs, while allowing 7 as the first\n-                // digit\n-                || ((f.eq(\"7\") || f.eq(\"F\")) && s.chars().all(|c| c == '0' || c == 'F'))\n-            {\n-                return Err(WarningType::DecimalRepresentation);\n+            if digits.len() < 4 {\n+                // Powers of 2\n+                if ((f.eq(\"1\") || f.eq(\"2\") || f.eq(\"4\") || f.eq(\"8\")) && s.chars().all(|c| c == '0'))\n+                    // Powers of 2 minus 1\n+                    || ((f.eq(\"1\") || f.eq(\"3\") || f.eq(\"7\") || f.eq(\"F\")) && s.chars().all(|c| c == 'F'))\n+                {\n+                    return Err(WarningType::DecimalRepresentation);\n+                }\n+            } else {\n+                // Powers of 2 with a margin of +15/-16\n+                if ((f.eq(\"1\") || f.eq(\"2\") || f.eq(\"4\") || f.eq(\"8\")) && m.chars().all(|c| c == '0'))\n+                    || ((f.eq(\"1\") || f.eq(\"3\") || f.eq(\"7\") || f.eq(\"F\")) && m.chars().all(|c| c == 'F'))\n+                    // Lint for representations with only 0s and Fs, while allowing 7 as the first\n+                    // digit\n+                    || ((f.eq(\"7\") || f.eq(\"F\")) && s.chars().all(|c| c == '0' || c == 'F'))\n+                {\n+                    return Err(WarningType::DecimalRepresentation);\n+                }\n             }\n         }\n "}, {"sha": "ecb8b72ef46105b28838b2893c5e41e0946e5157", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -44,44 +44,28 @@ pub fn check(\n             // \"mul\" is omitted because lhs can be negative.\n             _ => return,\n         }\n-\n-        let mut applicability = Applicability::MachineApplicable;\n-        span_lint_and_sugg(\n-            cx,\n-            super::MANUAL_SATURATING_ARITHMETIC,\n-            expr.span,\n-            \"manual saturating arithmetic\",\n-            &format!(\"try using `saturating_{}`\", arith),\n-            format!(\n-                \"{}.saturating_{}({})\",\n-                snippet_with_applicability(cx, arith_lhs.span, \"..\", &mut applicability),\n-                arith,\n-                snippet_with_applicability(cx, arith_rhs.span, \"..\", &mut applicability),\n-            ),\n-            applicability,\n-        );\n     } else {\n         match (mm, arith) {\n             (MinMax::Max, \"add\" | \"mul\") | (MinMax::Min, \"sub\") => (),\n             _ => return,\n         }\n-\n-        let mut applicability = Applicability::MachineApplicable;\n-        span_lint_and_sugg(\n-            cx,\n-            super::MANUAL_SATURATING_ARITHMETIC,\n-            expr.span,\n-            \"manual saturating arithmetic\",\n-            &format!(\"try using `saturating_{}`\", arith),\n-            format!(\n-                \"{}.saturating_{}({})\",\n-                snippet_with_applicability(cx, arith_lhs.span, \"..\", &mut applicability),\n-                arith,\n-                snippet_with_applicability(cx, arith_rhs.span, \"..\", &mut applicability),\n-            ),\n-            applicability,\n-        );\n     }\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+    span_lint_and_sugg(\n+        cx,\n+        super::MANUAL_SATURATING_ARITHMETIC,\n+        expr.span,\n+        \"manual saturating arithmetic\",\n+        &format!(\"try using `saturating_{}`\", arith),\n+        format!(\n+            \"{}.saturating_{}({})\",\n+            snippet_with_applicability(cx, arith_lhs.span, \"..\", &mut applicability),\n+            arith,\n+            snippet_with_applicability(cx, arith_rhs.span, \"..\", &mut applicability),\n+        ),\n+        applicability,\n+    );\n }\n \n #[derive(PartialEq, Eq)]"}, {"sha": "8b90fedbafeffefc3db9324b79e5280a922ebf41", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -483,6 +483,15 @@ pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n \n+/// Counts how many elements of the slices are equal as per `eq_fn`.\n+pub fn count_eq<X: Sized>(\n+    left: &mut dyn Iterator<Item = X>,\n+    right: &mut dyn Iterator<Item = X>,\n+    mut eq_fn: impl FnMut(&X, &X) -> bool,\n+) -> usize {\n+    left.zip(right).take_while(|(l, r)| eq_fn(l, r)).count()\n+}\n+\n /// Checks if two expressions evaluate to the same value, and don't contain any side effects.\n pub fn eq_expr_value(cx: &LateContext<'_>, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n     SpanlessEq::new(cx).deny_side_effects().eq_expr(left, right)"}, {"sha": "bb5b6f5ec04361165ecb85f52934c68f71b534a6", "filename": "tests/ui/checked_unwrap/complex_conditionals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -1,5 +1,5 @@\n #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n-#![allow(clippy::if_same_then_else)]\n+#![allow(clippy::if_same_then_else, clippy::shared_code_in_if_blocks)]\n \n fn test_complex_conditions() {\n     let x: Result<(), ()> = Ok(());"}, {"sha": "35a2e139c11d8b5d8bb5d2b8c26e1806e2876189", "filename": "tests/ui/if_same_then_else.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fif_same_then_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fif_same_then_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -5,7 +5,8 @@\n     clippy::never_loop,\n     clippy::no_effect,\n     clippy::unused_unit,\n-    clippy::zero_divided_by_zero\n+    clippy::zero_divided_by_zero,\n+    clippy::shared_code_in_if_blocks\n )]\n \n struct Foo {"}, {"sha": "2f38052fc209e957e76bb06f97000d40bb45c15f", "filename": "tests/ui/if_same_then_else.stderr", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fif_same_then_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fif_same_then_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else.stderr?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -1,111 +1,111 @@\n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:28:12\n+  --> $DIR/if_same_then_else.rs:21:13\n    |\n-LL |       } else {\n-   |  ____________^\n-LL | |         //~ ERROR same body as `if` block\n+LL |       if true {\n+   |  _____________^\n LL | |         Foo { bar: 42 };\n LL | |         0..10;\n+LL | |         ..;\n ...  |\n LL | |         foo();\n-LL | |     }\n+LL | |     } else {\n    | |_____^\n    |\n    = note: `-D clippy::if-same-then-else` implied by `-D warnings`\n note: same as this\n-  --> $DIR/if_same_then_else.rs:20:13\n+  --> $DIR/if_same_then_else.rs:29:12\n    |\n-LL |       if true {\n-   |  _____________^\n+LL |       } else {\n+   |  ____________^\n+LL | |         //~ ERROR same body as `if` block\n LL | |         Foo { bar: 42 };\n LL | |         0..10;\n-LL | |         ..;\n ...  |\n LL | |         foo();\n-LL | |     } else {\n+LL | |     }\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:66:12\n-   |\n-LL |       } else {\n-   |  ____________^\n-LL | |         //~ ERROR same body as `if` block\n-LL | |         0.0\n-LL | |     };\n-   | |_____^\n-   |\n-note: same as this\n-  --> $DIR/if_same_then_else.rs:64:21\n+  --> $DIR/if_same_then_else.rs:65:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n LL | |         0.0\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:73:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else.rs:67:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n-LL | |         -0.0\n+LL | |         0.0\n LL | |     };\n    | |_____^\n-   |\n-note: same as this\n-  --> $DIR/if_same_then_else.rs:71:21\n+\n+error: this `if` has identical blocks\n+  --> $DIR/if_same_then_else.rs:72:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n LL | |         -0.0\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:89:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else.rs:74:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n-LL | |         42\n+LL | |         -0.0\n LL | |     };\n    | |_____^\n-   |\n-note: same as this\n-  --> $DIR/if_same_then_else.rs:87:21\n+\n+error: this `if` has identical blocks\n+  --> $DIR/if_same_then_else.rs:88:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n LL | |         42\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:101:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else.rs:90:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n+LL | |         42\n+LL | |     };\n+   | |_____^\n+\n+error: this `if` has identical blocks\n+  --> $DIR/if_same_then_else.rs:95:13\n+   |\n+LL |       if true {\n+   |  _____________^\n LL | |         let bar = if true { 42 } else { 43 };\n LL | |\n+LL | |         while foo() {\n ...  |\n LL | |         bar + 1;\n-LL | |     }\n+LL | |     } else {\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else.rs:94:13\n+  --> $DIR/if_same_then_else.rs:102:12\n    |\n-LL |       if true {\n-   |  _____________^\n+LL |       } else {\n+   |  ____________^\n+LL | |         //~ ERROR same body as `if` block\n LL | |         let bar = if true { 42 } else { 43 };\n LL | |\n-LL | |         while foo() {\n ...  |\n LL | |         bar + 1;\n-LL | |     } else {\n+LL | |     }\n    | |_____^\n \n error: aborting due to 5 previous errors"}, {"sha": "8164b125570dfdd8e6f957db128df011d36d842c", "filename": "tests/ui/if_same_then_else2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fif_same_then_else2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fif_same_then_else2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -5,7 +5,8 @@\n     clippy::collapsible_if,\n     clippy::ifs_same_cond,\n     clippy::needless_return,\n-    clippy::single_element_loop\n+    clippy::single_element_loop,\n+    clippy::shared_code_in_if_blocks\n )]\n \n fn if_same_then_else2() -> Result<&'static str, ()> {"}, {"sha": "941b92f23f357af7f7846ace81e0008d48a20775", "filename": "tests/ui/if_same_then_else2.stderr", "status": "modified", "additions": 47, "deletions": 33, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fif_same_then_else2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fif_same_then_else2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.stderr?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -24,94 +24,98 @@ LL | |             if foo.is_some() {\n LL | |         }\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:35:12\n+   |\n+   = note: `-D clippy::if-same-then-else` implied by `-D warnings`\n+note: same as this\n+  --> $DIR/if_same_then_else2.rs:21:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n-LL | |         if let Some(a) = Some(42) {}\n+LL | |         for _ in &[42] {\n+LL | |             let foo: &Option<_> = &Some::<u8>(42);\n+...  |\n+LL | |         }\n LL | |     }\n    | |_____^\n-   |\n-note: same as this\n+\n+error: this `if` has identical blocks\n   --> $DIR/if_same_then_else2.rs:33:13\n    |\n LL |       if true {\n    |  _____________^\n LL | |         if let Some(a) = Some(42) {}\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:42:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else2.rs:35:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n-LL | |         if let (1, .., 3) = (1, 2, 3) {}\n+LL | |         if let Some(a) = Some(42) {}\n LL | |     }\n    | |_____^\n-   |\n-note: same as this\n+\n+error: this `if` has identical blocks\n   --> $DIR/if_same_then_else2.rs:40:13\n    |\n LL |       if true {\n    |  _____________^\n LL | |         if let (1, .., 3) = (1, 2, 3) {}\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:92:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else2.rs:42:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n-LL | |         f32::NAN\n-LL | |     };\n+LL | |         if let (1, .., 3) = (1, 2, 3) {}\n+LL | |     }\n    | |_____^\n-   |\n-note: same as this\n+\n+error: this `if` has identical blocks\n   --> $DIR/if_same_then_else2.rs:90:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n LL | |         f32::NAN\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:99:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else2.rs:92:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n-LL | |         Ok(\"foo\")?;\n-LL | |     }\n+LL | |         f32::NAN\n+LL | |     };\n    | |_____^\n-   |\n-note: same as this\n+\n+error: this `if` has identical blocks\n   --> $DIR/if_same_then_else2.rs:97:13\n    |\n LL |       if true {\n    |  _____________^\n LL | |         Ok(\"foo\")?;\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:124:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else2.rs:99:12\n    |\n LL |       } else {\n    |  ____________^\n-LL | |         let foo = \"\";\n-LL | |         return Ok(&foo[0..]);\n+LL | |         //~ ERROR same body as `if` block\n+LL | |         Ok(\"foo\")?;\n LL | |     }\n    | |_____^\n-   |\n-note: same as this\n+\n+error: this `if` has identical blocks\n   --> $DIR/if_same_then_else2.rs:121:20\n    |\n LL |       } else if true {\n@@ -120,6 +124,16 @@ LL | |         let foo = \"\";\n LL | |         return Ok(&foo[0..]);\n LL | |     } else {\n    | |_____^\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else2.rs:124:12\n+   |\n+LL |       } else {\n+   |  ____________^\n+LL | |         let foo = \"\";\n+LL | |         return Ok(&foo[0..]);\n+LL | |     }\n+   | |_____^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "9fd3f875a5f186c150b4f1c060abf221233c1d8a", "filename": "tests/ui/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_if_seq.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -2,7 +2,8 @@\n     unused_variables,\n     unused_assignments,\n     clippy::similar_names,\n-    clippy::blacklisted_name\n+    clippy::blacklisted_name,\n+    clippy::shared_code_in_if_blocks\n )]\n #![warn(clippy::useless_let_if_seq)]\n "}, {"sha": "9cf2e10a5ee56940e5a06d103a6bcd01323dbf05", "filename": "tests/ui/let_if_seq.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Flet_if_seq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Flet_if_seq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_if_seq.stderr?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -1,5 +1,5 @@\n error: `if _ { .. } else { .. }` is an expression\n-  --> $DIR/let_if_seq.rs:64:5\n+  --> $DIR/let_if_seq.rs:65:5\n    |\n LL | /     let mut foo = 0;\n LL | |     if f() {\n@@ -11,7 +11,7 @@ LL | |     }\n    = note: you might not need `mut` at all\n \n error: `if _ { .. } else { .. }` is an expression\n-  --> $DIR/let_if_seq.rs:69:5\n+  --> $DIR/let_if_seq.rs:70:5\n    |\n LL | /     let mut bar = 0;\n LL | |     if f() {\n@@ -25,7 +25,7 @@ LL | |     }\n    = note: you might not need `mut` at all\n \n error: `if _ { .. } else { .. }` is an expression\n-  --> $DIR/let_if_seq.rs:77:5\n+  --> $DIR/let_if_seq.rs:78:5\n    |\n LL | /     let quz;\n LL | |     if f() {\n@@ -36,7 +36,7 @@ LL | |     }\n    | |_____^ help: it is more idiomatic to write: `let quz = if f() { 42 } else { 0 };`\n \n error: `if _ { .. } else { .. }` is an expression\n-  --> $DIR/let_if_seq.rs:106:5\n+  --> $DIR/let_if_seq.rs:107:5\n    |\n LL | /     let mut baz = 0;\n LL | |     if f() {"}, {"sha": "22f1fe95f79226f57d99ab8046619f53414bb2dd", "filename": "tests/ui/shared_code_in_if_blocks/shared_at_bot.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_bot.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -0,0 +1,47 @@\n+#![allow(dead_code)]\n+#![deny(clippy::if_same_then_else, clippy::shared_code_in_if_blocks)]\n+\n+// This tests the shared_code_in_if_blocks lint at the end of blocks\n+\n+fn simple_examples() {\n+    // TODO xFrednet 2021-01-06: Test with const literals at the end\n+    let x = 1;\n+\n+    let _ = if x == 7 {\n+        println!(\"Branch I\");\n+        let start_value = 0;\n+        println!(\"=^.^=\");\n+\n+        // Same but not moveable due to `start_value`\n+        let _ = start_value;\n+\n+        // The rest is self contained and moveable => Only lint the rest\n+        let result = false;\n+        println!(\"Block end!\");\n+        result\n+    } else {\n+        println!(\"Branch II\");\n+        let start_value = 8;\n+        println!(\"xD\");\n+\n+        // Same but not moveable due to `start_value`\n+        let _ = start_value;\n+\n+        // The rest is self contained and moveable => Only lint the rest\n+        let result = false;\n+        println!(\"Block end!\");\n+        result\n+    };\n+}\n+\n+/// Simple examples where the move can cause some problems due to moved values\n+fn simple_but_suggestion_is_invalid() {\n+    // TODO xFrednet 2021-01-12: This\n+}\n+\n+/// Tests where the blocks are not linted due to the used value scope\n+fn not_moveable_due_to_value_scope() {\n+    // TODO xFrednet 2021-01-12: This\n+}\n+\n+fn main() {}"}, {"sha": "0a6828127e99bf7c2f878b54506e040881633631", "filename": "tests/ui/shared_code_in_if_blocks/shared_at_top.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_top.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_top.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_top.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -0,0 +1,83 @@\n+#![allow(dead_code, clippy::eval_order_dependence)]\n+#![deny(clippy::if_same_then_else, clippy::shared_code_in_if_blocks)]\n+\n+// This tests the shared_code_in_if_blocks lint at the start of blocks\n+\n+fn simple_examples() {\n+    let x = 0;\n+\n+    // Simple\n+    if true {\n+        println!(\"Hello World!\");\n+        println!(\"I'm branch nr: 1\");\n+    } else {\n+        println!(\"Hello World!\");\n+        println!(\"I'm branch nr: 2\");\n+    }\n+\n+    // Else if\n+    if x == 0 {\n+        let y = 9;\n+        println!(\"The value y was set to: `{}`\", y);\n+        let _z = y;\n+\n+        println!(\"I'm the true start index of arrays\");\n+    } else if x == 1 {\n+        let y = 9;\n+        println!(\"The value y was set to: `{}`\", y);\n+        let _z = y;\n+\n+        println!(\"I start counting from 1 so my array starts from `1`\");\n+    } else {\n+        let y = 9;\n+        println!(\"The value y was set to: `{}`\", y);\n+        let _z = y;\n+\n+        println!(\"Ha, Pascal allows you to start the array where you want\")\n+    }\n+\n+    // Return a value\n+    let _ = if x == 7 {\n+        let y = 16;\n+        println!(\"What can I say except: \\\"you're welcome?\\\"\");\n+        let _ = y;\n+        x\n+    } else {\n+        let y = 16;\n+        println!(\"Thank you\");\n+        y\n+    };\n+}\n+\n+/// Simple examples where the move can cause some problems due to moved values\n+fn simple_but_suggestion_is_invalid() {\n+    let x = 10;\n+\n+    // Can't be automatically moved because used_value_name is getting used again\n+    let used_value_name = 19;\n+    if x == 10 {\n+        let used_value_name = \"Different type\";\n+        println!(\"Str: {}\", used_value_name);\n+        let _ = 1;\n+    } else {\n+        let used_value_name = \"Different type\";\n+        println!(\"Str: {}\", used_value_name);\n+        let _ = 2;\n+    }\n+    let _ = used_value_name;\n+\n+    // This can be automatically moved as `can_be_overridden` is not used again\n+    let can_be_overridden = 8;\n+    let _ = can_be_overridden;\n+    if x == 11 {\n+        let can_be_overridden = \"Move me\";\n+        println!(\"I'm also moveable\");\n+        let _ = 111;\n+    } else {\n+        let can_be_overridden = \"Move me\";\n+        println!(\"I'm also moveable\");\n+        let _ = 222;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "8de69623e5d2d514ade3bca86e2f4c93fe21dc17", "filename": "tests/ui/shared_code_in_if_blocks/shared_at_top_and_bot.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_top_and_bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_top_and_bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_top_and_bot.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -0,0 +1,22 @@\n+#![allow(dead_code)]\n+#![deny(clippy::if_same_then_else, clippy::shared_code_in_if_blocks)]\n+\n+// shared_code_in_if_blocks at the top and bottom of the if blocks\n+\n+fn main() {\n+    // TODO xFrednet 2021-01-12: This\n+}\n+\n+// General TODOs By xFrednet:\n+\n+// \n+// * Make a test with overlapping eq regions (else ifs)\n+// * Test if as function parameter, tuple constructor, index, while loop condition\n+// * Test where only the expression is the same\n+// * Test where the block only has an expression\n+// * Test with let on a previous line let _ = \\n if...\n+// * Tests with unreadable formatting (Inline if, Not indented)\n+// * Test multiline condition if x == 9 \\n x == 8 {}\n+// * Test if for return/break (Only move to front)\n+// * Test in inline closures\n+// * Test with structs and tuples"}, {"sha": "1f12e9348d473f1bfebbf0f4e6a4084be9fa0988", "filename": "tests/ui/shared_code_in_if_blocks/valid_if_blocks.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fshared_code_in_if_blocks%2Fvalid_if_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1df73228a7cdadb4d635c6ed77daeeaebbe10ff/tests%2Fui%2Fshared_code_in_if_blocks%2Fvalid_if_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshared_code_in_if_blocks%2Fvalid_if_blocks.rs?ref=d1df73228a7cdadb4d635c6ed77daeeaebbe10ff", "patch": "@@ -0,0 +1,157 @@\n+#![allow(dead_code, clippy::eval_order_dependence)]\n+#![deny(clippy::if_same_then_else, clippy::shared_code_in_if_blocks)]\n+\n+// This tests the shared_code_in_if_blocks lint at the start of blocks\n+\n+// Tests with value references are includes in \"shared_code_at_bot.rs\"\n+\n+fn valid_examples() {\n+    let x = 2;\n+\n+    // The edge statements are different\n+    if x == 9 {\n+        let y = 1 << 5;\n+\n+        println!(\"This is the same: vvv\");\n+        let _z = y;\n+        println!(\"The block expression is different\");\n+\n+        println!(\"Different end 1\");\n+    } else {\n+        let y = 1 << 7;\n+\n+        println!(\"This is the same: vvv\");\n+        let _z = y;\n+        println!(\"The block expression is different\");\n+\n+        println!(\"Different end 2\");\n+    }\n+\n+    // No else\n+    if x == 2 {\n+        println!(\"Hello world!\");\n+        println!(\"Hello back, how are you?\");\n+\n+        // This is different vvvv\n+        println!(\"Howdy stranger =^.^=\");\n+\n+        println!(\"Bye Bye World\");\n+    } else if x == 9 {\n+        println!(\"Hello world!\");\n+        println!(\"Hello back, how are you?\");\n+\n+        // This is different vvvv\n+        println!(\"Hello reviewer :D\");\n+\n+        println!(\"Bye Bye World\");\n+    }\n+\n+    // Overlapping statements only in else if blocks -> Don't lint\n+    if x == 0 {\n+        println!(\"I'm important!\")\n+    } else if x == 17 {\n+        println!(\"I share code in else if\");\n+\n+        println!(\"x is 17\");\n+    } else {\n+        println!(\"I share code in else if\");\n+\n+        println!(\"x is nether x nor 17\");\n+    }\n+\n+    // Mutability is different\n+    if x == 13 {\n+        let mut y = 9;\n+        println!(\"Value y is: {}\", y);\n+        y += 16;\n+        let _z1 = y;\n+    } else {\n+        let y = 9;\n+        println!(\"Value y is: {}\", y);\n+        let _z2 = y;\n+    }\n+\n+    // Same blocks but at start and bottom so no `if_same_then_else` lint\n+    if x == 418 {\n+        let y = 9;\n+        let z = 8;\n+        let _ = (x, y, z);\n+        // Don't tell the programmer, my code is also in the else block\n+    } else if x == 419 {\n+        println!(\"+-----------+\");\n+        println!(\"|           |\");\n+        println!(\"|  O     O  |\");\n+        println!(\"|     \u00b0     |\");\n+        println!(\"|  \\\\_____/  |\");\n+        println!(\"|           |\");\n+        println!(\"+-----------+\");\n+    } else {\n+        let y = 9;\n+        let z = 8;\n+        let _ = (x, y, z);\n+        // I'm so much better than the x == 418 block. Trust me\n+    }\n+}\n+\n+/// This makes sure that the `if_same_then_else` masks the `shared_code_in_if_blocks` lint\n+fn trigger_other_lint() {\n+    let x = 0;\n+    let y = 1;\n+\n+    // Same block\n+    if x == 0 {\n+        let u = 19;\n+        println!(\"How are u today?\");\n+        let _ = \"This is a string\";\n+    } else {\n+        let u = 19;\n+        println!(\"How are u today?\");\n+        let _ = \"This is a string\";\n+    }\n+\n+    // More complex same blocks\n+    if x == 17 {\n+        #[derive(Debug)]\n+        struct Duck {\n+            num: u64,\n+        };\n+        let pet = Duck { num: 18 };\n+        println!(\"{:?}\", pet);\n+    } else {\n+        #[derive(Debug)]\n+        struct Duck {\n+            num: u64,\n+        };\n+        let pet = Duck { num: 18 };\n+        println!(\"{:?}\", pet);\n+    }\n+\n+    // Only same expression\n+    let _ = if x == 6 { 7 } else { 7 };\n+\n+    // Same in else if block\n+    let _ = if x == 67 {\n+        println!(\"Well I'm the most important block\");\n+        \"I'm a pretty string\"\n+    } else if x == 68 {\n+        println!(\"I'm a doppelg\u00e4nger\");\n+        // Don't listen to my clone below\n+\n+        if y == 90 {\n+            \"=^.^=\"\n+        } else {\n+            \":D\"\n+        }\n+    } else {\n+        // Don't listen to my clone above\n+        println!(\"I'm a doppelg\u00e4nger\");\n+\n+        if y == 90 {\n+            \"=^.^=\"\n+        } else {\n+            \":D\"\n+        }\n+    };\n+}\n+\n+fn main() {}"}]}