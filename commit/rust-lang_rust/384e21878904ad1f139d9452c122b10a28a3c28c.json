{"sha": "384e21878904ad1f139d9452c122b10a28a3c28c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NGUyMTg3ODkwNGFkMWYxMzlkOTQ1MmMxMjJiMTBhMjhhM2MyOGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:55:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:55:41Z"}, "message": "Merge remote-tracking branch 'nrc/sized-2' into rollup\n\nConflicts:\n\tsrc/liballoc/boxed.rs\n\tsrc/libcollections/btree/map.rs\n\tsrc/libcollections/slice.rs\n\tsrc/libcore/borrow.rs\n\tsrc/libcore/cmp.rs\n\tsrc/libcore/ops.rs\n\tsrc/libstd/c_str.rs\n\tsrc/libstd/collections/hash/map.rs\n\tsrc/libsyntax/parse/obsolete.rs\n\tsrc/test/compile-fail/unboxed-closure-sugar-default.rs\n\tsrc/test/compile-fail/unboxed-closure-sugar-equiv.rs\n\tsrc/test/compile-fail/unboxed-closure-sugar-lifetime-elision.rs\n\tsrc/test/compile-fail/unboxed-closure-sugar-region.rs\n\tsrc/test/compile-fail/unsized3.rs\n\tsrc/test/run-pass/associated-types-conditional-dispatch.rs", "tree": {"sha": "fa915ac71411765c8c5b38dc421980033005ebd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa915ac71411765c8c5b38dc421980033005ebd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/384e21878904ad1f139d9452c122b10a28a3c28c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/384e21878904ad1f139d9452c122b10a28a3c28c", "html_url": "https://github.com/rust-lang/rust/commit/384e21878904ad1f139d9452c122b10a28a3c28c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/384e21878904ad1f139d9452c122b10a28a3c28c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afbce050ca3748a66b9e9783dc50f6c77f9bdf8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/afbce050ca3748a66b9e9783dc50f6c77f9bdf8b", "html_url": "https://github.com/rust-lang/rust/commit/afbce050ca3748a66b9e9783dc50f6c77f9bdf8b"}, {"sha": "8f3a424322f5609f75aab2313dc93b0ad73e2670", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f3a424322f5609f75aab2313dc93b0ad73e2670", "html_url": "https://github.com/rust-lang/rust/commit/8f3a424322f5609f75aab2313dc93b0ad73e2670"}], "stats": {"total": 496, "additions": 251, "deletions": 245}, "files": [{"sha": "6df8bb5f7aaf4b146b76b88ea00850932c17b7e3", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -75,14 +75,14 @@ impl<T: Clone> Clone for Box<T> {\n }\n \n #[stable]\n-impl<Sized? T: PartialEq> PartialEq for Box<T> {\n+impl<T: ?Sized + PartialEq> PartialEq for Box<T> {\n     #[inline]\n     fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n #[stable]\n-impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n+impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n@@ -97,16 +97,16 @@ impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n     fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }\n }\n #[stable]\n-impl<Sized? T: Ord> Ord for Box<T> {\n+impl<T: ?Sized + Ord> Ord for Box<T> {\n     #[inline]\n     fn cmp(&self, other: &Box<T>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n \n #[stable]}\n-impl<Sized? T: Eq> Eq for Box<T> {}\n+impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n-impl<S: hash::Writer, Sized? T: Hash<S>> Hash<S> for Box<T> {\n+impl<S: hash::Writer, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n@@ -143,7 +143,7 @@ impl BoxAny for Box<Any> {\n     }\n }\n \n-impl<Sized? T: fmt::Show> fmt::Show for Box<T> {\n+impl<T: ?Sized + fmt::Show> fmt::Show for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         (**self).fmt(f)\n     }\n@@ -156,14 +156,14 @@ impl fmt::Show for Box<Any> {\n }\n \n #[stable]\n-impl<Sized? T> Deref for Box<T> {\n+impl<T: ?Sized> Deref for Box<T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { &**self }\n }\n \n #[stable]\n-impl<Sized? T> DerefMut for Box<T> {\n+impl<T: ?Sized> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }\n "}, {"sha": "b85ea65f5ce5880140611f8be2d09687be61c5d0", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -130,7 +130,7 @@ pub struct Values<'a, K: 'a, V: 'a> {\n \n #[stable]\n /// A view into a single entry in a map, which may either be vacant or occupied.\n-pub enum Entry<'a, Sized? Q:'a, K:'a, V:'a> {\n+pub enum Entry<'a, Q: ?Sized +'a, K:'a, V:'a> {\n     /// A vacant Entry\n     Vacant(VacantEntry<'a, Q, K, V>),\n     /// An occupied Entry\n@@ -139,7 +139,7 @@ pub enum Entry<'a, Sized? Q:'a, K:'a, V:'a> {\n \n #[stable]\n /// A vacant Entry.\n-pub struct VacantEntry<'a, Sized? Q:'a, K:'a, V:'a> {\n+pub struct VacantEntry<'a, Q: ?Sized +'a, K:'a, V:'a> {\n     key: &'a Q,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n@@ -214,7 +214,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable]\n-    pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n+    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n             match Node::search(cur_node, key) {\n@@ -246,7 +246,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable]\n-    pub fn contains_key<Sized? Q>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n+    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n         self.get(key).is_some()\n     }\n \n@@ -270,7 +270,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable]\n-    pub fn get_mut<Sized? Q>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n+    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n@@ -440,7 +440,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable]\n-    pub fn remove<Sized? Q>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -878,7 +878,7 @@ impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n }\n \n #[stable]\n-impl<K: Ord, Sized? Q, V> Index<Q> for BTreeMap<K, V>\n+impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n     type Output = V;\n@@ -889,7 +889,7 @@ impl<K: Ord, Sized? Q, V> Index<Q> for BTreeMap<K, V>\n }\n \n #[stable]\n-impl<K: Ord, Sized? Q, V> IndexMut<Q> for BTreeMap<K, V>\n+impl<K: Ord, Q: ?Sized, V> IndexMut<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n     type Output = V;\n@@ -1111,7 +1111,7 @@ impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n #[stable]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n-impl<'a, Sized? Q, K: Ord, V> Entry<'a, Q, K, V> {\n+impl<'a, Q: ?Sized, K: Ord, V> Entry<'a, Q, K, V> {\n     #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n@@ -1122,7 +1122,7 @@ impl<'a, Sized? Q, K: Ord, V> Entry<'a, Q, K, V> {\n     }\n }\n \n-impl<'a, Sized? Q: ToOwned<K>, K: Ord, V> VacantEntry<'a, Q, K, V> {\n+impl<'a, Q: ?Sized + ToOwned<K>, K: Ord, V> VacantEntry<'a, Q, K, V> {\n     #[stable]\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n@@ -1362,7 +1362,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     /// The key must have the same ordering before or after `.to_owned()` is called.\n     #[stable]\n-    pub fn entry<'a, Sized? Q>(&'a mut self, mut key: &'a Q) -> Entry<'a, Q, K, V>\n+    pub fn entry<'a, Q: ?Sized>(&'a mut self, mut key: &'a Q) -> Entry<'a, Q, K, V>\n         where Q: Ord + ToOwned<K>\n     {\n         // same basic logic of `swap` and `pop`, blended together"}, {"sha": "0a93bbf89c9971dea74fe7c5fadc95e614f35f06", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -517,7 +517,7 @@ impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search<Sized? Q, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)\n+    pub fn search<Q: ?Sized, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)\n                   -> SearchResult<NodeRef> where Q: BorrowFrom<K> + Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n@@ -536,7 +536,7 @@ impl<K: Ord, V> Node<K, V> {\n         }\n     }\n \n-    fn search_linear<Sized? Q>(&self, key: &Q) -> (bool, uint) where Q: BorrowFrom<K> + Ord {\n+    fn search_linear<Q: ?Sized>(&self, key: &Q) -> (bool, uint) where Q: BorrowFrom<K> + Ord {\n         for (i, k) in self.keys().iter().enumerate() {\n             match key.cmp(BorrowFrom::borrow_from(k)) {\n                 Greater => {},"}, {"sha": "82cef9b3549de8dd8d333c1fe5aef364b1229ca0", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -299,7 +299,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[stable]\n-    pub fn contains<Sized? Q>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n+    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.contains_key(value)\n     }\n \n@@ -429,7 +429,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[stable]\n-    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.remove(value).is_some()\n     }\n }"}, {"sha": "f286b99e04536f7d6bfb7b4fc145500b619e968d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -1008,7 +1008,7 @@ impl<T: Ord> OrdSliceExt<T> for [T] {\n \n #[unstable = \"U should be an associated type\"]\n /// An extension trait for concatenating slices\n-pub trait SliceConcatExt<Sized? T, U> {\n+pub trait SliceConcatExt<T: ?Sized, U> {\n     /// Flattens a slice of `T` into a single value `U`.\n     #[stable]\n     fn concat(&self) -> U;"}, {"sha": "2c08b97635580c0504df846247a117644a491602", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -54,52 +54,52 @@ use self::Cow::*;\n \n /// A trait for borrowing data.\n #[old_orphan_check]\n-pub trait BorrowFrom<Sized? Owned> {\n+pub trait BorrowFrom<Owned: ?Sized> {\n     /// Immutably borrow from an owned value.\n     fn borrow_from(owned: &Owned) -> &Self;\n }\n \n /// A trait for mutably borrowing data.\n #[old_orphan_check]\n-pub trait BorrowFromMut<Sized? Owned> : BorrowFrom<Owned> {\n+pub trait BorrowFromMut<Owned: ?Sized> : BorrowFrom<Owned> {\n     /// Mutably borrow from an owned value.\n     fn borrow_from_mut(owned: &mut Owned) -> &mut Self;\n }\n \n-impl<Sized? T> BorrowFrom<T> for T {\n+impl<T: ?Sized> BorrowFrom<T> for T {\n     fn borrow_from(owned: &T) -> &T { owned }\n }\n \n-impl<Sized? T> BorrowFromMut<T> for T {\n+impl<T: ?Sized> BorrowFromMut<T> for T {\n     fn borrow_from_mut(owned: &mut T) -> &mut T { owned }\n }\n \n-impl<'a, Sized? T> BorrowFrom<&'a T> for T {\n+impl<'a, T: ?Sized> BorrowFrom<&'a T> for T {\n     fn borrow_from<'b>(owned: &'b &'a T) -> &'b T { &**owned }\n }\n \n-impl<'a, Sized? T> BorrowFrom<&'a mut T> for T {\n+impl<'a, T: ?Sized> BorrowFrom<&'a mut T> for T {\n     fn borrow_from<'b>(owned: &'b &'a mut T) -> &'b T { &**owned }\n }\n \n-impl<'a, Sized? T> BorrowFromMut<&'a mut T> for T {\n+impl<'a, T: ?Sized> BorrowFromMut<&'a mut T> for T {\n     fn borrow_from_mut<'b>(owned: &'b mut &'a mut T) -> &'b mut T { &mut **owned }\n }\n \n-impl<'a, T, Sized? B> BorrowFrom<Cow<'a, T, B>> for B where B: ToOwned<T> {\n+impl<'a, T, B: ?Sized> BorrowFrom<Cow<'a, T, B>> for B where B: ToOwned<T> {\n     fn borrow_from<'b>(owned: &'b Cow<'a, T, B>) -> &'b B {\n         &**owned\n     }\n }\n \n /// Trait for moving into a `Cow`\n #[old_orphan_check]\n-pub trait IntoCow<'a, T, Sized? B> {\n+pub trait IntoCow<'a, T, B: ?Sized> {\n     /// Moves `self` into `Cow`\n     fn into_cow(self) -> Cow<'a, T, B>;\n }\n \n-impl<'a, T, Sized? B> IntoCow<'a, T, B> for Cow<'a, T, B> where B: ToOwned<T> {\n+impl<'a, T, B: ?Sized> IntoCow<'a, T, B> for Cow<'a, T, B> where B: ToOwned<T> {\n     fn into_cow(self) -> Cow<'a, T, B> {\n         self\n     }\n@@ -133,7 +133,7 @@ impl<T> ToOwned<T> for T where T: Clone {\n ///     }\n /// }\n /// ```\n-pub enum Cow<'a, T, Sized? B: 'a> where B: ToOwned<T> {\n+pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     /// Borrowed data.\n     Borrowed(&'a B),\n \n@@ -142,7 +142,7 @@ pub enum Cow<'a, T, Sized? B: 'a> where B: ToOwned<T> {\n }\n \n #[stable]\n-impl<'a, T, Sized? B> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n+impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     fn clone(&self) -> Cow<'a, T, B> {\n         match *self {\n             Borrowed(b) => Borrowed(b),\n@@ -154,7 +154,7 @@ impl<'a, T, Sized? B> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     }\n }\n \n-impl<'a, T, Sized? B> Cow<'a, T, B> where B: ToOwned<T> {\n+impl<'a, T, B: ?Sized> Cow<'a, T, B> where B: ToOwned<T> {\n     /// Acquire a mutable reference to the owned form of the data.\n     ///\n     /// Copies the data if it is not already owned.\n@@ -196,7 +196,7 @@ impl<'a, T, Sized? B> Cow<'a, T, B> where B: ToOwned<T> {\n }\n \n #[stable]\n-impl<'a, T, Sized? B> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n+impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n     type Target = B;\n \n     fn deref(&self) -> &B {\n@@ -208,18 +208,18 @@ impl<'a, T, Sized? B> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n }\n \n #[stable]\n-impl<'a, T, Sized? B> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n+impl<'a, T, B: ?Sized> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n \n #[stable]\n-impl<'a, T, Sized? B> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n+impl<'a, T, B: ?Sized> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n     #[inline]\n     fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n \n #[stable]\n-impl<'a, 'b, T, U, Sized? B, Sized? C> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n+impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n     B: PartialEq<C> + ToOwned<T>,\n     C: ToOwned<U>,\n {\n@@ -230,14 +230,14 @@ impl<'a, 'b, T, U, Sized? B, Sized? C> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B\n }\n \n #[stable]\n-impl<'a, T, Sized? B> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n+impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n-impl<'a, T, Sized? B> fmt::Show for Cow<'a, T, B> where B: fmt::Show + ToOwned<T>, T: fmt::Show {\n+impl<'a, T, B: ?Sized> fmt::Show for Cow<'a, T, B> where B: fmt::Show + ToOwned<T>, T: fmt::Show {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             Borrowed(ref b) => fmt::Show::fmt(b, f),"}, {"sha": "17991659f97899c6027021eae8a8dceecccd54a6", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -43,7 +43,7 @@ pub trait Clone : Sized {\n }\n \n #[stable]\n-impl<'a, Sized? T> Clone for &'a T {\n+impl<'a, T: ?Sized> Clone for &'a T {\n     /// Return a shallow copy of the reference.\n     #[inline]\n     fn clone(&self) -> &'a T { *self }"}, {"sha": "af5e98ed303240a9684c8207d9f4375eb208ccac", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -70,7 +70,7 @@ use option::Option::{self, Some, None};\n #[lang=\"eq\"]\n #[stable]\n #[old_orphan_check]\n-pub trait PartialEq<Sized? Rhs = Self> {\n+pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n     #[stable]\n     fn eq(&self, other: &Rhs) -> bool;\n@@ -225,7 +225,7 @@ impl PartialOrd for Ordering {\n /// 5.11).\n #[lang=\"ord\"]\n #[stable]\n-pub trait PartialOrd<Sized? Rhs = Self>: PartialEq<Rhs> {\n+pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values\n     /// if one exists.\n     #[stable]\n@@ -429,14 +429,14 @@ mod impls {\n     // & pointers\n \n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n@@ -451,24 +451,24 @@ mod impls {\n         fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, Sized? A> Ord for &'a A where A: Ord {\n+    impl<'a, A: ?Sized> Ord for &'a A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, Sized? A> Eq for &'a A where A: Eq {}\n+    impl<'a, A: ?Sized> Eq for &'a A where A: Eq {}\n \n     // &mut pointers\n \n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n@@ -483,23 +483,23 @@ mod impls {\n         fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, Sized? A> Ord for &'a mut A where A: Ord {\n+    impl<'a, A: ?Sized> Ord for &'a mut A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, Sized? A> Eq for &'a mut A where A: Eq {}\n+    impl<'a, A: ?Sized> Eq for &'a mut A where A: Eq {}\n \n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n \n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]"}, {"sha": "7d92b707f98c37b7d9deefe14f9526a75e1e961e", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -78,9 +78,9 @@ pub trait Writer {\n         // This Adapter is needed to allow `self` (of type `&mut\n         // Self`) to be cast to a FormatWriter (below) without\n         // requiring a `Sized` bound.\n-        struct Adapter<'a,Sized? T:'a>(&'a mut T);\n+        struct Adapter<'a,T: ?Sized +'a>(&'a mut T);\n \n-        impl<'a, Sized? T> Writer for Adapter<'a, T>\n+        impl<'a, T: ?Sized> Writer for Adapter<'a, T>\n             where T: Writer\n         {\n             fn write_str(&mut self, s: &str) -> Result {\n@@ -592,10 +592,10 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n \n // Implementations of the core formatting traits\n \n-impl<'a, Sized? T: Show> Show for &'a T {\n+impl<'a, T: ?Sized + Show> Show for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n-impl<'a, Sized? T: Show> Show for &'a mut T {\n+impl<'a, T: ?Sized + Show> Show for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n "}, {"sha": "d8b9cf9594d6aab4cfb7ed4eedf15a06ef00aa08", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -85,7 +85,7 @@ pub trait Hash<S = sip::SipState> {\n /// containers like `HashMap`, which need a generic way hash multiple types.\n pub trait Hasher<S> {\n     /// Compute the hash of a value.\n-    fn hash<Sized? T: Hash<S>>(&self, value: &T) -> u64;\n+    fn hash<T: ?Sized + Hash<S>>(&self, value: &T) -> u64;\n }\n \n #[allow(missing_docs)]\n@@ -194,14 +194,14 @@ impl<S: Writer, T: Hash<S>> Hash<S> for [T] {\n }\n \n \n-impl<'a, S: Writer, Sized? T: Hash<S>> Hash<S> for &'a T {\n+impl<'a, S: Writer, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n \n-impl<'a, S: Writer, Sized? T: Hash<S>> Hash<S> for &'a mut T {\n+impl<'a, S: Writer, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n@@ -233,7 +233,7 @@ impl<S: Writer> Hash<S> for TypeId {\n     }\n }\n \n-impl<'a, T, Sized? B, S> Hash<S> for Cow<'a, T, B> where B: Hash<S> + ToOwned<T> {\n+impl<'a, T, B: ?Sized, S> Hash<S> for Cow<'a, T, B> where B: Hash<S> + ToOwned<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         Hash::hash(&**self, state)"}, {"sha": "c4d45e9c2c80454802496457b1f8e3b17dc3762f", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -239,7 +239,7 @@ impl SipHasher {\n \n impl Hasher<SipState> for SipHasher {\n     #[inline]\n-    fn hash<Sized? T: Hash<SipState>>(&self, value: &T) -> u64 {\n+    fn hash<T: ?Sized + Hash<SipState>>(&self, value: &T) -> u64 {\n         let mut state = SipState::new_with_keys(self.k0, self.k1);\n         value.hash(&mut state);\n         state.result()\n@@ -255,15 +255,15 @@ impl Default for SipHasher {\n \n /// Hashes a value using the SipHash algorithm.\n #[inline]\n-pub fn hash<Sized? T: Hash<SipState>>(value: &T) -> u64 {\n+pub fn hash<T: ?Sized + Hash<SipState>>(value: &T) -> u64 {\n     let mut state = SipState::new();\n     value.hash(&mut state);\n     state.result()\n }\n \n /// Hashes a value with the SipHash algorithm with the provided keys.\n #[inline]\n-pub fn hash_with_keys<Sized? T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n+pub fn hash_with_keys<T: ?Sized + Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n     let mut state = SipState::new_with_keys(k0, k1);\n     value.hash(&mut state);\n     state.result()"}, {"sha": "5d69938fccff702adc1d8184f4503c3c899a26af", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -133,10 +133,10 @@ pub mod marker {\n     /// for some lifetime `'a`, but not the other way around).\n     #[lang=\"covariant_type\"]\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct CovariantType<Sized? T>;\n+    pub struct CovariantType<T: ?Sized>;\n \n-    impl<Sized? T> Copy for CovariantType<T> {}\n-    impl<Sized? T> Clone for CovariantType<T> {\n+    impl<T: ?Sized> Copy for CovariantType<T> {}\n+    impl<T: ?Sized> Clone for CovariantType<T> {\n         fn clone(&self) -> CovariantType<T> { *self }\n     }\n \n@@ -181,10 +181,10 @@ pub mod marker {\n     /// arguments of type `U`, hence such a conversion is safe.\n     #[lang=\"contravariant_type\"]\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct ContravariantType<Sized? T>;\n+    pub struct ContravariantType<T: ?Sized>;\n \n-    impl<Sized? T> Copy for ContravariantType<T> {}\n-    impl<Sized? T> Clone for ContravariantType<T> {\n+    impl<T: ?Sized> Copy for ContravariantType<T> {}\n+    impl<T: ?Sized> Clone for ContravariantType<T> {\n         fn clone(&self) -> ContravariantType<T> { *self }\n     }\n \n@@ -211,10 +211,10 @@ pub mod marker {\n     /// interior mutability.\n     #[lang=\"invariant_type\"]\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct InvariantType<Sized? T>;\n+    pub struct InvariantType<T: ?Sized>;\n \n-    impl<Sized? T> Copy for InvariantType<T> {}\n-    impl<Sized? T> Clone for InvariantType<T> {\n+    impl<T: ?Sized> Copy for InvariantType<T> {}\n+    impl<T: ?Sized> Clone for InvariantType<T> {\n         fn clone(&self) -> InvariantType<T> { *self }\n     }\n "}, {"sha": "a8f8802de5982fc7fbe0577783874385a9658b4e", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -320,7 +320,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n #[inline]\n #[unstable = \"this function may be removed in the future due to its \\\n               questionable utility\"]\n-pub unsafe fn copy_lifetime<'a, Sized? S, Sized? T: 'a>(_ptr: &'a S,\n+pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n                                                         ptr: &T) -> &'a T {\n     transmute(ptr)\n }\n@@ -329,7 +329,7 @@ pub unsafe fn copy_lifetime<'a, Sized? S, Sized? T: 'a>(_ptr: &'a S,\n #[inline]\n #[unstable = \"this function may be removed in the future due to its \\\n               questionable utility\"]\n-pub unsafe fn copy_mut_lifetime<'a, Sized? S, Sized? T: 'a>(_ptr: &'a mut S,\n+pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a mut S,\n                                                             ptr: &mut T)\n                                                             -> &'a mut T {\n     transmute(ptr)"}, {"sha": "97d94e73bb33a0625764ba677ebdf97e49f8fe6f", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -802,8 +802,8 @@ shr_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"index\"]\n-pub trait Index<Sized? Index> {\n-    type Sized? Output;\n+pub trait Index<Index: ?Sized> {\n+    type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index<'a>(&'a self, index: &Index) -> &'a Self::Output;\n@@ -839,8 +839,8 @@ pub trait Index<Sized? Index> {\n /// }\n /// ```\n #[lang=\"index_mut\"]\n-pub trait IndexMut<Sized? Index> {\n-    type Sized? Output;\n+pub trait IndexMut<Index: ?Sized> {\n+    type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n@@ -884,7 +884,7 @@ pub trait IndexMut<Sized? Index> {\n /// }\n /// ```\n #[lang=\"slice\"]\n-pub trait Slice<Sized? Idx, Sized? Result> {\n+pub trait Slice<Idx: ?Sized, Result: ?Sized> {\n     /// The method for the slicing operation foo[]\n     fn as_slice_<'a>(&'a self) -> &'a Result;\n     /// The method for the slicing operation foo[from..]\n@@ -933,7 +933,7 @@ pub trait Slice<Sized? Idx, Sized? Result> {\n /// }\n /// ```\n #[lang=\"slice_mut\"]\n-pub trait SliceMut<Sized? Idx, Sized? Result> {\n+pub trait SliceMut<Idx: ?Sized, Result: ?Sized> {\n     /// The method for the slicing operation foo[]\n     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Result;\n     /// The method for the slicing operation foo[from..]\n@@ -1071,22 +1071,22 @@ pub struct RangeTo<Idx> {\n #[stable]\n pub trait Deref {\n     #[stable]\n-    type Sized? Target;\n+    type Target: ?Sized;\n \n     /// The method called to dereference a value\n     #[stable]\n     fn deref<'a>(&'a self) -> &'a Self::Target;\n }\n \n #[stable]\n-impl<'a, Sized? T> Deref for &'a T {\n+impl<'a, T: ?Sized> Deref for &'a T {\n     type Target = T;\n \n     fn deref(&self) -> &T { *self }\n }\n \n #[stable]\n-impl<'a, Sized? T> Deref for &'a mut T {\n+impl<'a, T: ?Sized> Deref for &'a mut T {\n     type Target = T;\n \n     fn deref(&self) -> &T { *self }\n@@ -1138,7 +1138,7 @@ pub trait DerefMut: Deref {\n }\n \n #[stable]\n-impl<'a, Sized? T> DerefMut for &'a mut T {\n+impl<'a, T: ?Sized> DerefMut for &'a mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }\n \n@@ -1166,8 +1166,8 @@ pub trait FnOnce<Args,Result> {\n     extern \"rust-call\" fn call_once(self, args: Args) -> Result;\n }\n \n-impl<Sized? F,A,R> FnMut<A,R> for F\n-    where F : Fn<A,R>\n+impl<F: ?Sized, A, R> FnMut<A, R> for F\n+    where F : Fn<A, R>\n {\n     extern \"rust-call\" fn call_mut(&mut self, args: A) -> R {\n         self.call(args)"}, {"sha": "093ed0b242f5f4d5583f839a7534ee8e697d9912", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -626,13 +626,13 @@ impl<T> AsSlice<T> for [T] {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a U {\n+impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a mut U {\n+impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }"}, {"sha": "d9749899b22103a86751dd47dacf7341a05b8262", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -1155,7 +1155,7 @@ impl Str for str {\n     fn as_slice<'a>(&'a self) -> &'a str { self }\n }\n \n-impl<'a, Sized? S> Str for &'a S where S: Str {\n+impl<'a, S: ?Sized> Str for &'a S where S: Str {\n     #[inline]\n     fn as_slice(&self) -> &str { Str::as_slice(*self) }\n }"}, {"sha": "a4bafe754ffdd812c011fafbb03f6a02fb57494f", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -16,7 +16,7 @@ use core::hash::{Hash, Hasher, Writer};\n struct MyWriterHasher;\n \n impl Hasher<MyWriter> for MyWriterHasher {\n-    fn hash<Sized? T: Hash<MyWriter>>(&self, value: &T) -> u64 {\n+    fn hash<T: ?Sized + Hash<MyWriter>>(&self, value: &T) -> u64 {\n         let mut state = MyWriter { hash: 0 };\n         value.hash(&mut state);\n         state.hash"}, {"sha": "567fe04c5afbc659df4ccb13f6b344b385bdb969", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -25,7 +25,7 @@ use std::slice;\n \n // Note 2: Once Dynamically Sized Types (DST) lands, it might be\n // reasonable to replace this with something like `enum MaybeOwned<'a,\n-// Sized? U>{ Owned(Box<U>), Borrowed(&'a U) }`; and then `U` could be\n+// U: ?Sized>{ Owned(Box<U>), Borrowed(&'a U) }`; and then `U` could be\n // instantiated with `[T]` or `str`, etc.  Of course, that would imply\n // removing the `Growable` variant, which relates to note 1 above.\n // Alternatively, we might add `MaybeOwned` for the general case but"}, {"sha": "a83416667abdc331eaf8534011977c4826e8fa00", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         // However, it's not as simple as checking whether `T :\n         // Sized`, because even if `T : Sized` does not hold, that\n         // just means that `T` *may* not be sized.  After all, even a\n-        // type parameter `Sized? T` could be bound to a sized\n+        // type parameter `T: ?Sized` could be bound to a sized\n         // type. (Issue #20116)\n         //\n         // To handle this, we first check for \"interior\" type\n@@ -139,16 +139,16 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         // exhaustively checking all possible combinations. Here are some examples:\n         //\n         // ```\n-        // fn foo<T,U>() {\n+        // fn foo<T, U>() {\n         //     // T=int, U=int\n         // }\n         //\n-        // fn bar<Sized? T,U>() {\n+        // fn bar<T: ?Sized, U>() {\n         //     // T=int, U=int\n         //     // T=[int], U=int\n         // }\n         //\n-        // fn baz<Sized? T, Sized?U>() {\n+        // fn baz<T: ?Sized, U: ?Sized>() {\n         //     // T=int, U=int\n         //     // T=[int], U=int\n         //     // T=int, U=[int]"}, {"sha": "ee224d1ec80fe0361a1b52506accf6e55c1f08a4", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -75,7 +75,7 @@ pub struct FnvHasher;\n pub struct FnvState(u64);\n \n impl Hasher<FnvState> for FnvHasher {\n-    fn hash<Sized? T: Hash<FnvState>>(&self, t: &T) -> u64 {\n+    fn hash<T: ?Sized + Hash<FnvState>>(&self, t: &T) -> u64 {\n         let mut state = FnvState(0xcbf29ce484222325);\n         t.hash(&mut state);\n         let FnvState(ret) = state;"}, {"sha": "8c2a9993004d99c4e6d96ff2ca49181aa2d5108f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -601,7 +601,7 @@ impl<'tcx> Repr<'tcx> for () {\n     }\n }\n \n-impl<'a, 'tcx, Sized? T:Repr<'tcx>> Repr<'tcx> for &'a T {\n+impl<'a, 'tcx, T: ?Sized +Repr<'tcx>> Repr<'tcx> for &'a T {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         Repr::repr(*self, tcx)\n     }"}, {"sha": "a04f67f765108e1a0a0aec7c9202fcdc5828696a", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -396,13 +396,13 @@ impl Decodable for () {\n     }\n }\n \n-impl<'a, Sized? T: Encodable> Encodable for &'a T {\n+impl<'a, T: ?Sized + Encodable> Encodable for &'a T {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<Sized? T: Encodable> Encodable for Box<T> {\n+impl<T: ?Sized + Encodable> Encodable for Box<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }"}, {"sha": "c4317b99dce06c085522b724d35013a47d99983a", "filename": "src/libserialize/serialize_stage0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibserialize%2Fserialize_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibserialize%2Fserialize_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize_stage0.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -378,13 +378,13 @@ impl<E, D:Decoder<E>> Decodable<D, E> for () {\n     }\n }\n \n-impl<'a, E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for &'a T {\n+impl<'a, E, S: Encoder<E>, T: ?Sized + Encodable<S, E>> Encodable<S, E> for &'a T {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n \n-impl<E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for Box<T> {\n+impl<E, S: Encoder<E>, T: ?Sized + Encodable<S, E>> Encodable<S, E> for Box<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }"}, {"sha": "a3fc38c34e84fb70deb3f094cfdf0f745b32e29c", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -440,22 +440,22 @@ impl<K, V, M> SearchResult<K, V, M> {\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n-    fn make_hash<Sized? X: Hash<S>>(&self, x: &X) -> SafeHash {\n+    fn make_hash<X: ?Sized + Hash<S>>(&self, x: &X) -> SafeHash {\n         table::make_hash(&self.hasher, x)\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n-    fn search<'a, Sized? Q>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n+    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n         where Q: BorrowFrom<K> + Eq + Hash<S>\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n             .into_option()\n     }\n \n-    fn search_mut<'a, Sized? Q>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n+    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n         where Q: BorrowFrom<K> + Eq + Hash<S>\n     {\n         let hash = self.make_hash(q);\n@@ -923,7 +923,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     #[stable]\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n     /// Regardless of whether or not `to_owned()` has been called, the key must hash the same way.\n-    pub fn entry<'a, Sized? Q>(&'a mut self, key: &'a Q) -> Entry<'a, Q, K, V>\n+    pub fn entry<'a, Q: ?Sized>(&'a mut self, key: &'a Q) -> Entry<'a, Q, K, V>\n         where Q: Eq + Hash<S> + ToOwned<K>\n     {\n         // Gotta resize now.\n@@ -1030,7 +1030,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable]\n-    pub fn get<Sized? Q>(&self, k: &Q) -> Option<&V>\n+    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n         self.search(k).map(|bucket| bucket.into_refs().1)\n@@ -1053,7 +1053,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable]\n-    pub fn contains_key<Sized? Q>(&self, k: &Q) -> bool\n+    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n         self.search(k).is_some()\n@@ -1079,7 +1079,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     #[stable]\n-    pub fn get_mut<Sized? Q>(&mut self, k: &Q) -> Option<&mut V>\n+    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n         self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n@@ -1131,7 +1131,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable]\n-    pub fn remove<Sized? Q>(&mut self, k: &Q) -> Option<V>\n+    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n         if self.table.size() == 0 {\n@@ -1142,7 +1142,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-fn search_entry_hashed<'a, K, V, Sized? Q>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: &'a Q)\n+fn search_entry_hashed<'a, K, V, Q: ?Sized>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: &'a Q)\n         -> Entry<'a, Q, K, V>\n     where Q: Eq + ToOwned<K>\n {\n@@ -1227,7 +1227,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n }\n \n #[stable]\n-impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V, H>\n+impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V, H>\n     where Q: BorrowFrom<K> + Hash<S> + Eq\n {\n     type Output = V;\n@@ -1239,7 +1239,7 @@ impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V, H\n }\n \n #[stable]\n-impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q> for HashMap<K, V, H>\n+impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> IndexMut<Q> for HashMap<K, V, H>\n     where Q: BorrowFrom<K> + Hash<S> + Eq\n {\n     type Output = V;\n@@ -1331,15 +1331,15 @@ pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n \n #[stable]\n /// A view into a single empty location in a HashMap\n-pub struct VacantEntry<'a, Sized? Q: 'a, K: 'a, V: 'a> {\n+pub struct VacantEntry<'a, Q: ?Sized + 'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n     key: &'a Q,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n #[stable]\n /// A view into a single location in a map, which may be vacant or occupied\n-pub enum Entry<'a, Sized? Q: 'a, K: 'a, V: 'a> {\n+pub enum Entry<'a, Q: ?Sized + 'a, K: 'a, V: 'a> {\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n     /// A vacant Entry\n@@ -1409,7 +1409,7 @@ impl<'a, K: 'a, V: 'a> Iterator for Drain<'a, K, V> {\n     }\n }\n \n-impl<'a, Sized? Q, K, V> Entry<'a, Q, K, V> {\n+impl<'a, Q: ?Sized, K, V> Entry<'a, Q, K, V> {\n     #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n@@ -1455,7 +1455,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     }\n }\n \n-impl<'a, Sized? Q: 'a + ToOwned<K>, K: 'a, V: 'a> VacantEntry<'a, Q, K, V> {\n+impl<'a, Q: ?Sized + 'a + ToOwned<K>, K: 'a, V: 'a> VacantEntry<'a, Q, K, V> {\n     #[stable]\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it"}, {"sha": "91a5db2ba763157349beb7a50b9c33c0e52a72d0", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -451,7 +451,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[stable]\n-    pub fn contains<Sized? Q>(&self, value: &Q) -> bool\n+    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<S> + Eq\n     {\n         self.map.contains_key(value)\n@@ -561,7 +561,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[stable]\n-    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool\n+    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<S> + Eq\n     {\n         self.map.remove(value).is_some()"}, {"sha": "1eb4408eedc403d4d4fb0e273e9bd9d52ad88eeb", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -138,7 +138,7 @@ impl SafeHash {\n /// We need to remove hashes of 0. That's reserved for empty buckets.\n /// This function wraps up `hash_keyed` to be the only way outside this\n /// module to generate a SafeHash.\n-pub fn make_hash<Sized? T: Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash {\n+pub fn make_hash<T: ?Sized + Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash {\n     // We need to avoid 0u64 in order to prevent collisions with\n     // EMPTY_HASH. We can maintain our precious uniform distribution\n     // of initial indexes by unconditionally setting the MSB,"}, {"sha": "ac2b01e995e2c62b5b17cea4e589659149bff133", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -90,7 +90,7 @@ impl RandomSipHasher {\n \n impl Hasher<sip::SipState> for RandomSipHasher {\n     #[inline]\n-    fn hash<Sized? T: Hash<sip::SipState>>(&self, value: &T) -> u64 {\n+    fn hash<T: ?Sized + Hash<sip::SipState>>(&self, value: &T) -> u64 {\n         self.hasher.hash(value)\n     }\n }"}, {"sha": "66416a21dd9a449e87fe9f5de7ffa31a5922ec3e", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -1012,12 +1012,12 @@ pub trait Writer {\n     fn write_fmt(&mut self, fmt: fmt::Arguments) -> IoResult<()> {\n         // Create a shim which translates a Writer to a fmt::Writer and saves\n         // off I/O errors. instead of discarding them\n-        struct Adaptor<'a, Sized? T:'a> {\n+        struct Adaptor<'a, T: ?Sized +'a> {\n             inner: &'a mut T,\n             error: IoResult<()>,\n         }\n \n-        impl<'a, Sized? T: Writer> fmt::Writer for Adaptor<'a, T> {\n+        impl<'a, T: ?Sized + Writer> fmt::Writer for Adaptor<'a, T> {\n             fn write_str(&mut self, s: &str) -> fmt::Result {\n                 match self.inner.write(s.as_bytes()) {\n                     Ok(()) => Ok(()),\n@@ -1597,11 +1597,11 @@ pub trait Acceptor<T> {\n /// `Some`. The `Some` contains the `IoResult` representing whether the\n /// connection attempt was successful.  A successful connection will be wrapped\n /// in `Ok`. A failed connection is represented as an `Err`.\n-pub struct IncomingConnections<'a, Sized? A:'a> {\n+pub struct IncomingConnections<'a, A: ?Sized +'a> {\n     inc: &'a mut A,\n }\n \n-impl<'a, T, Sized? A: Acceptor<T>> Iterator for IncomingConnections<'a, A> {\n+impl<'a, T, A: ?Sized + Acceptor<T>> Iterator for IncomingConnections<'a, A> {\n     type Item = IoResult<T>;\n \n     fn next(&mut self) -> Option<IoResult<T>> {"}, {"sha": "b020164158cff2d5d2e876b58403cc3016b7d244", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -896,7 +896,7 @@ impl BytesContainer for CString {\n     }\n }\n \n-impl<'a, Sized? T: BytesContainer> BytesContainer for &'a T {\n+impl<'a, T: ?Sized + BytesContainer> BytesContainer for &'a T {\n     #[inline]\n     fn container_as_bytes(&self) -> &[u8] {\n         (**self).container_as_bytes()"}, {"sha": "1df02101ed0b0060df3b9f3c3a5f319c0feceb36", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -321,7 +321,7 @@ impl Path {\n \n     /// Returns a normalized byte vector representation of a path, by removing all empty\n     /// components, and unnecessary . and .. components.\n-    fn normalize<Sized? V: AsSlice<u8>>(v: &V) -> Vec<u8> {\n+    fn normalize<V: ?Sized + AsSlice<u8>>(v: &V) -> Vec<u8> {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;"}, {"sha": "a49680d7e1c0344a682098a6270ede9214650f4c", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -13,8 +13,6 @@\n //!\n //! Obsolete syntax that becomes too hard to parse can be removed.\n \n-pub use self::ObsoleteSyntax::*;\n-\n use ast::{Expr, ExprTup};\n use codemap::Span;\n use parse::parser;\n@@ -24,18 +22,19 @@ use ptr::P;\n /// The specific types of unsupported syntax\n #[derive(Copy, PartialEq, Eq, Hash)]\n pub enum ObsoleteSyntax {\n-    ObsoleteForSized,\n-    ObsoleteOwnedType,\n-    ObsoleteOwnedExpr,\n-    ObsoleteOwnedPattern,\n-    ObsoleteOwnedVector,\n-    ObsoleteOwnedSelf,\n-    ObsoleteImportRenaming,\n-    ObsoleteSubsliceMatch,\n-    ObsoleteExternCrateRenaming,\n-    ObsoleteProcType,\n-    ObsoleteProcExpr,\n-    ObsoleteClosureType,\n+    Sized,\n+    ForSized,\n+    OwnedType,\n+    OwnedExpr,\n+    OwnedPattern,\n+    OwnedVector,\n+    OwnedSelf,\n+    ImportRenaming,\n+    SubsliceMatch,\n+    ExternCrateRenaming,\n+    ProcType,\n+    ProcExpr,\n+    ClosureType,\n }\n \n pub trait ParserObsoleteMethods {\n@@ -57,55 +56,59 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     /// Reports an obsolete syntax non-fatal error.\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {\n-            ObsoleteForSized => (\n+            ObsoleteSyntax::ForSized => (\n                 \"for Sized?\",\n                 \"no longer required. Traits (and their `Self` type) do not have the `Sized` bound \\\n                  by default\",\n             ),\n-            ObsoleteProcType => (\n+            ObsoleteSyntax::ProcType => (\n                 \"the `proc` type\",\n                 \"use unboxed closures instead\",\n             ),\n-            ObsoleteProcExpr => (\n+            ObsoleteSyntax::ProcExpr => (\n                 \"`proc` expression\",\n                 \"use a `move ||` expression instead\",\n             ),\n-            ObsoleteOwnedType => (\n+            ObsoleteSyntax::OwnedType => (\n                 \"`~` notation for owned pointers\",\n                 \"use `Box<T>` in `std::owned` instead\"\n             ),\n-            ObsoleteOwnedExpr => (\n+            ObsoleteSyntax::OwnedExpr => (\n                 \"`~` notation for owned pointer allocation\",\n                 \"use the `box` operator instead of `~`\"\n             ),\n-            ObsoleteOwnedPattern => (\n+            ObsoleteSyntax::OwnedPattern => (\n                 \"`~` notation for owned pointer patterns\",\n                 \"use the `box` operator instead of `~`\"\n             ),\n-            ObsoleteOwnedVector => (\n+            ObsoleteSyntax::OwnedVector => (\n                 \"`~[T]` is no longer a type\",\n                 \"use the `Vec` type instead\"\n             ),\n-            ObsoleteOwnedSelf => (\n+            ObsoleteSyntax::OwnedSelf => (\n                 \"`~self` is no longer supported\",\n                 \"write `self: Box<Self>` instead\"\n             ),\n-            ObsoleteImportRenaming => (\n+            ObsoleteSyntax::ImportRenaming => (\n                 \"`use foo = bar` syntax\",\n                 \"write `use bar as foo` instead\"\n             ),\n-            ObsoleteSubsliceMatch => (\n+            ObsoleteSyntax::SubsliceMatch => (\n                 \"subslice match syntax\",\n                 \"instead of `..xs`, write `xs..` in a pattern\"\n             ),\n-            ObsoleteExternCrateRenaming => (\n+            ObsoleteSyntax::ExternCrateRenaming => (\n                 \"`extern crate foo = bar` syntax\",\n                 \"write `extern crate bar as foo` instead\"\n             ),\n-            ObsoleteClosureType => (\n+            ObsoleteSyntax::ClosureType => (\n                 \"`|uint| -> bool` closure type syntax\",\n                 \"use unboxed closures instead, no type annotation needed\"\n-            )\n+            ),\n+            ObsoleteSyntax::Sized => (\n+                \"`Sized? T` syntax for removing the `Sized` bound\",\n+                \"write `T: ?Sized` instead\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "58b08757cdfb6f3d0b4fbbcf01527bd13a3d2872", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -1155,7 +1155,7 @@ impl<'a> Parser<'a> {\n         let _ = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n         let _ = self.parse_ret_ty();\n \n-        self.obsolete(proc_span, ObsoleteProcType);\n+        self.obsolete(proc_span, ObsoleteSyntax::ProcType);\n \n         TyInfer\n     }\n@@ -1511,8 +1511,10 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let last_span = self.last_span;\n             match self.token {\n-                token::OpenDelim(token::Bracket) => self.obsolete(last_span, ObsoleteOwnedVector),\n-                _ => self.obsolete(last_span, ObsoleteOwnedType)\n+                token::OpenDelim(token::Bracket) => {\n+                    self.obsolete(last_span, ObsoleteSyntax::OwnedVector)\n+                }\n+                _ => self.obsolete(last_span, ObsoleteSyntax::OwnedType)\n             }\n             TyTup(vec![self.parse_ty()])\n         } else if self.check(&token::BinOp(token::Star)) {\n@@ -2275,7 +2277,7 @@ impl<'a> Parser<'a> {\n                     let span = self.last_span;\n                     let _ = self.parse_proc_decl();\n                     let _ = self.parse_expr();\n-                    return self.obsolete_expr(span, ObsoleteProcExpr);\n+                    return self.obsolete_expr(span, ObsoleteSyntax::ProcExpr);\n                 }\n                 if self.eat_keyword(keywords::If) {\n                     return self.parse_if_expr();\n@@ -2850,9 +2852,9 @@ impl<'a> Parser<'a> {\n             let last_span = self.last_span;\n             match self.token {\n                 token::OpenDelim(token::Bracket) => {\n-                    self.obsolete(last_span, ObsoleteOwnedVector)\n+                    self.obsolete(last_span, ObsoleteSyntax::OwnedVector)\n                 },\n-                _ => self.obsolete(last_span, ObsoleteOwnedExpr)\n+                _ => self.obsolete(last_span, ObsoleteSyntax::OwnedExpr)\n             }\n \n             let e = self.parse_prefix_expr();\n@@ -3227,7 +3229,7 @@ impl<'a> Parser<'a> {\n                     } else {\n                         let _ = self.parse_pat();\n                         let span = self.span;\n-                        self.obsolete(span, ObsoleteSubsliceMatch);\n+                        self.obsolete(span, ObsoleteSyntax::SubsliceMatch);\n                     }\n                     continue\n                 }\n@@ -3343,7 +3345,7 @@ impl<'a> Parser<'a> {\n             pat = PatBox(sub);\n             let last_span = self.last_span;\n             hi = last_span.hi;\n-            self.obsolete(last_span, ObsoleteOwnedPattern);\n+            self.obsolete(last_span, ObsoleteSyntax::OwnedPattern);\n             return P(ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n@@ -4090,8 +4092,8 @@ impl<'a> Parser<'a> {\n         // unbound, and it may only be `Sized`. To avoid backtracking and other\n         // complications, we parse an ident, then check for `?`. If we find it,\n         // we use the ident as the unbound, otherwise, we use it as the name of\n-        // type param. Even worse, for now, we need to check for `?` before or\n-        // after the bound.\n+        // type param. Even worse, we need to check for `?` before or after the\n+        // bound.\n         let mut span = self.span;\n         let mut ident = self.parse_ident();\n         let mut unbound = None;\n@@ -4100,6 +4102,7 @@ impl<'a> Parser<'a> {\n             unbound = Some(tref);\n             span = self.span;\n             ident = self.parse_ident();\n+            self.obsolete(span, ObsoleteSyntax::Sized);\n         }\n \n         let mut bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Modified);\n@@ -4463,7 +4466,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     drop(self.expect_self_ident());\n                     let last_span = self.last_span;\n-                    self.obsolete(last_span, ObsoleteOwnedSelf)\n+                    self.obsolete(last_span, ObsoleteSyntax::OwnedSelf)\n                 }\n                 SelfStatic\n             }\n@@ -4514,7 +4517,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     drop(self.expect_self_ident());\n                     let last_span = self.last_span;\n-                    self.obsolete(last_span, ObsoleteOwnedSelf);\n+                    self.obsolete(last_span, ObsoleteSyntax::OwnedSelf);\n                     SelfStatic\n                 } else {\n                     SelfStatic\n@@ -5396,7 +5399,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     let path = self.parse_str();\n                     let span = self.span;\n-                    self.obsolete(span, ObsoleteExternCrateRenaming);\n+                    self.obsolete(span, ObsoleteSyntax::ExternCrateRenaming);\n                     Some(path)\n                 } else if self.eat_keyword(keywords::As) {\n                     // skip the ident if there is one\n@@ -6053,7 +6056,7 @@ impl<'a> Parser<'a> {\n                 path.push(id);\n             }\n             let span = mk_sp(path_lo, self.span.hi);\n-            self.obsolete(span, ObsoleteImportRenaming);\n+            self.obsolete(span, ObsoleteSyntax::ImportRenaming);\n             let path = ast::Path {\n                 span: span,\n                 global: false,"}, {"sha": "85eea2d9daf27226f889f7c80b4c3643587fbd48", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -77,7 +77,7 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n         (*vect).len()\n     }\n \n-    pub fn find<Sized? Q>(&self, val: &Q) -> Option<Name>\n+    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n     where Q: BorrowFrom<T> + Eq + Hash {\n         let map = self.map.borrow();\n         match (*map).get(val) {\n@@ -202,7 +202,7 @@ impl StrInterner {\n         self.vect.borrow().len()\n     }\n \n-    pub fn find<Sized? Q>(&self, val: &Q) -> Option<Name>\n+    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n     where Q: BorrowFrom<RcStr> + Eq + Hash {\n         match (*self.map.borrow()).get(val) {\n             Some(v) => Some(*v),"}, {"sha": "db39eafc1912bb5064679d2af3ec8fecb5a8b4cc", "filename": "src/test/compile-fail/associated-types-unsized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n trait Get {\n-    type Sized? Value;\n+    type Value: ?Sized;\n     fn get(&self) -> <Self as Get>::Value;\n }\n "}, {"sha": "5e360b6ab9bad8fa2d4e40dd5fbdc022bc7ee17b", "filename": "src/test/compile-fail/dst-bad-assign-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -10,7 +10,7 @@\n \n // Forbid assignment into a dynamically sized type.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     f1: int,\n     f2: &'static str,\n     ptr: T"}, {"sha": "cc709be99002ea2a35ca44d04f6c9823409a30fd", "filename": "src/test/compile-fail/dst-bad-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -10,7 +10,7 @@\n \n // Forbid assignment into a dynamically sized type.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     f1: int,\n     f2: &'static str,\n     ptr: T"}, {"sha": "75bd94331b11d591b431c31d1872106fd2d839b9", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -10,7 +10,7 @@\n \n // Attempt to change the type as well as unsizing.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     ptr: T\n }\n "}, {"sha": "54c625221ba7d0216270ca705c30179ec57b1450", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -10,7 +10,7 @@\n \n // Attempt to change the mutability as well as unsizing.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     ptr: T\n }\n "}, {"sha": "192d43e32fd27523dc43d60fb41dbe53a2eb55d3", "filename": "src/test/compile-fail/dst-bad-coerce3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -10,7 +10,7 @@\n \n // Attempt to extend the lifetime as well as unsizing.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     ptr: T\n }\n "}, {"sha": "53ce18c73a08845e011927466a983e99f822653e", "filename": "src/test/compile-fail/dst-bad-coerce4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -10,7 +10,7 @@\n \n // Attempt to coerce from unsized to sized.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     ptr: T\n }\n "}, {"sha": "b30eada162b84707134573888de917956f8ca50c", "filename": "src/test/compile-fail/dst-bad-coercions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -14,7 +14,7 @@ struct S;\n trait T {}\n impl T for S {}\n \n-struct Foo<Sized? T> {\n+struct Foo<T: ?Sized> {\n     f: T\n }\n "}, {"sha": "b169824cb3aca2e40a44473aca31a23bee64e319", "filename": "src/test/compile-fail/dst-bad-deep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -13,7 +13,7 @@\n // because it would require stack allocation of an unsized temporary (*g in the\n // test).\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     ptr: T\n }\n "}, {"sha": "3c75b5b6eddb8b77cacbd767680f76ddb01c546b", "filename": "src/test/compile-fail/dst-object-from-unsized-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -13,12 +13,12 @@\n trait Foo {}\n impl Foo for str {}\n \n-fn test1<Sized? T: Foo>(t: &T) {\n+fn test1<T: ?Sized + Foo>(t: &T) {\n     let u: &Foo = t;\n     //~^ ERROR `core::kinds::Sized` is not implemented for the type `T`\n }\n \n-fn test2<Sized? T: Foo>(t: &T) {\n+fn test2<T: ?Sized + Foo>(t: &T) {\n     let v: &Foo = t as &Foo;\n     //~^ ERROR `core::kinds::Sized` is not implemented for the type `T`\n }"}, {"sha": "31456853e1c0f1543207f7c0776e36861700fe91", "filename": "src/test/compile-fail/transmute-fat-pointers.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Ftransmute-fat-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Ftransmute-fat-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-fat-pointers.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -14,11 +14,11 @@\n \n use std::mem::transmute;\n \n-fn a<T, Sized? U>(x: &[T]) -> &U {\n+fn a<T, U: ?Sized>(x: &[T]) -> &U {\n     unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n }\n \n-fn b<Sized? T, Sized? U>(x: &T) -> &U {\n+fn b<T: ?Sized, U: ?Sized>(x: &T) -> &U {\n     unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n }\n \n@@ -30,11 +30,11 @@ fn d<T, U>(x: &[T]) -> &[U] {\n     unsafe { transmute(x) }\n }\n \n-fn e<Sized? T, U>(x: &T) -> &U {\n+fn e<T: ?Sized, U>(x: &T) -> &U {\n     unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n }\n \n-fn f<T, Sized? U>(x: &T) -> &U {\n+fn f<T, U: ?Sized>(x: &T) -> &U {\n     unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n }\n "}, {"sha": "a68bba285df29b39741ca7db9a78a5c4771715e4", "filename": "src/test/compile-fail/transmute-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Ftransmute-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Ftransmute-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-impl.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -14,11 +14,11 @@\n \n use std::mem::transmute;\n \n-struct Foo<Sized? T> {\n+struct Foo<T: ?Sized> {\n     t: Box<T>\n }\n \n-impl<Sized? T> Foo<T> {\n+impl<T: ?Sized> Foo<T> {\n     fn m(x: &T) -> &int where T : Sized {\n         // OK here, because T : Sized is in scope.\n         unsafe { transmute(x) }"}, {"sha": "82355ddf68176e751436e36385dab837c3c1adfb", "filename": "src/test/compile-fail/unboxed-closure-sugar-default.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -18,9 +18,9 @@ trait Foo<T,U,V=T> {\n     fn dummy(&self, t: T, u: U, v: V);\n }\n \n-trait Eq<Sized? X> { }\n-impl<Sized? X> Eq<X> for X { }\n-fn eq<Sized? A,Sized? B>() where A : Eq<B> { }\n+trait Eq<X: ?Sized> { }\n+impl<X: ?Sized> Eq<X> for X { }\n+fn eq<A: ?Sized,B: ?Sized>() where A : Eq<B> { }\n \n fn test<'a,'b>() {\n     // Parens are equivalent to omitting default in angle."}, {"sha": "f36fad306704ff14dc732badf019a0824cc4b559", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -20,9 +20,9 @@ trait Foo<T,U> {\n     fn dummy(&self, t: T, u: U);\n }\n \n-trait Eq<Sized? X> { }\n-impl<Sized? X> Eq<X> for X { }\n-fn eq<Sized? A,Sized? B:Eq<A>>() { }\n+trait Eq<X: ?Sized> { }\n+impl<X: ?Sized> Eq<X> for X { }\n+fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n \n fn test<'a,'b>() {\n     // No errors expected:"}, {"sha": "2617be295cd2a0542f8528ff2842d276da0e754d", "filename": "src/test/compile-fail/unboxed-closure-sugar-lifetime-elision.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -20,9 +20,9 @@ trait Foo<T,U> {\n     fn dummy(&self, t: T, u: U);\n }\n \n-trait Eq<Sized? X> { }\n-impl<Sized? X> Eq<X> for X { }\n-fn eq<Sized? A,Sized? B:Eq<A>>() { }\n+trait Eq<X: ?Sized> { }\n+impl<X: ?Sized> Eq<X> for X { }\n+fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n \n fn main() {\n     eq::< for<'a> Foo<(&'a int,), &'a int>,"}, {"sha": "5ace9e115ec78bc79b1adafe3b6615e1135ae94b", "filename": "src/test/compile-fail/unboxed-closure-sugar-region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -21,9 +21,9 @@ trait Foo<'a,T,U> {\n     fn dummy(&'a self) -> &'a (T,U);\n }\n \n-trait Eq<Sized? X> { }\n-impl<Sized? X> Eq<X> for X { }\n-fn eq<Sized? A,Sized? B:Eq<A>>() { }\n+trait Eq<X: ?Sized> { }\n+impl<X: ?Sized> Eq<X> for X { }\n+fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n \n fn same_type<A,B:Eq<A>>(a: A, b: B) { }\n "}, {"sha": "2de490e018b44de240f5a898585840aac5946ce5", "filename": "src/test/compile-fail/unsized-bare-typaram.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized-bare-typaram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized-bare-typaram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-bare-typaram.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn bar<T: Sized>() { }\n-fn foo<Sized? T>() { bar::<T>() } //~ ERROR the trait `core::kinds::Sized` is not implemented\n+fn foo<T: ?Sized>() { bar::<T>() } //~ ERROR the trait `core::kinds::Sized` is not implemented\n fn main() { }"}, {"sha": "aea236c9268157928593407a3e2bc85a4ccd4bbe", "filename": "src/test/compile-fail/unsized-enum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-enum.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -10,18 +10,18 @@\n \n \n fn is_sized<T:Sized>() { }\n-fn not_sized<Sized? T>() { }\n+fn not_sized<T: ?Sized>() { }\n \n enum Foo<U> { FooSome(U), FooNone }\n fn foo1<T>() { not_sized::<Foo<T>>() } // Hunky dory.\n-fn foo2<Sized? T>() { not_sized::<Foo<T>>() }\n+fn foo2<T: ?Sized>() { not_sized::<Foo<T>>() }\n //~^ ERROR the trait `core::kinds::Sized` is not implemented\n //\n // Not OK: `T` is not sized.\n \n-enum Bar<Sized? U> { BarSome(U), BarNone }\n-fn bar1<Sized? T>() { not_sized::<Bar<T>>() }\n-fn bar2<Sized? T>() { is_sized::<Bar<T>>() }\n+enum Bar<U: ?Sized> { BarSome(U), BarNone }\n+fn bar1<T: ?Sized>() { not_sized::<Bar<T>>() }\n+fn bar2<T: ?Sized>() { is_sized::<Bar<T>>() }\n //~^ ERROR the trait `core::kinds::Sized` is not implemented\n //\n // Not OK: `Bar<T>` is not sized, but it should be."}, {"sha": "8740346a21750c8918af9545e4ceda6d20a0286b", "filename": "src/test/compile-fail/unsized-inherent-impl-self-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized-inherent-impl-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized-inherent-impl-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-inherent-impl-self-type.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -14,7 +14,7 @@\n \n struct S5<Y>;\n \n-impl<Sized? X> S5<X> { //~ ERROR not implemented\n+impl<X: ?Sized> S5<X> { //~ ERROR not implemented\n }\n \n fn main() { }"}, {"sha": "89c711036977a68addd796bfedd63652ad312293", "filename": "src/test/compile-fail/unsized-struct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-struct.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -10,18 +10,18 @@\n \n \n fn is_sized<T:Sized>() { }\n-fn not_sized<Sized? T>() { }\n+fn not_sized<T: ?Sized>() { }\n \n struct Foo<T> { data: T }\n fn foo1<T>() { not_sized::<Foo<T>>() } // Hunky dory.\n-fn foo2<Sized? T>() { not_sized::<Foo<T>>() }\n+fn foo2<T: ?Sized>() { not_sized::<Foo<T>>() }\n //~^ ERROR the trait `core::kinds::Sized` is not implemented\n //\n // Not OK: `T` is not sized.\n \n-struct Bar<Sized? T> { data: T }\n-fn bar1<Sized? T>() { not_sized::<Bar<T>>() }\n-fn bar2<Sized? T>() { is_sized::<Bar<T>>() }\n+struct Bar<T: ?Sized> { data: T }\n+fn bar1<T: ?Sized>() { not_sized::<Bar<T>>() }\n+fn bar2<T: ?Sized>() { is_sized::<Bar<T>>() }\n //~^ ERROR the trait `core::kinds::Sized` is not implemented\n //\n // Not OK: `Bar<T>` is not sized, but it should be."}, {"sha": "3dd55b0ba7d23401d7c75e5922efd5c2f23038b5", "filename": "src/test/compile-fail/unsized-trait-impl-self-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-self-type.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -11,12 +11,12 @@\n // Test sized-ness checking in substitution in impls.\n \n // impl - struct\n-trait T3<Sized? Z> {\n+trait T3<Z: ?Sized> {\n }\n \n struct S5<Y>;\n \n-impl<Sized? X> T3<X> for S5<X> { //~ ERROR not implemented\n+impl<X: ?Sized> T3<X> for S5<X> { //~ ERROR not implemented\n }\n \n fn main() { }"}, {"sha": "7ae74fc2600c84d71416e431f997c6840278b901", "filename": "src/test/compile-fail/unsized-trait-impl-trait-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-trait-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-trait-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-trait-arg.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -13,8 +13,8 @@\n // impl - unbounded\n trait T2<Z> {\n }\n-struct S4<Sized? Y>;\n-impl<Sized? X> T2<X> for S4<X> {\n+struct S4<Y: ?Sized>;\n+impl<X: ?Sized> T2<X> for S4<X> {\n     //~^ ERROR `core::kinds::Sized` is not implemented for the type `X`\n }\n "}, {"sha": "1b0368a351abcb09aeebf5337f4bcd051b213d1a", "filename": "src/test/compile-fail/unsized3.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized3.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -12,54 +12,54 @@\n \n \n // Unbounded.\n-fn f1<Sized? X>(x: &X) {\n+fn f1<X: ?Sized>(x: &X) {\n     f2::<X>(x);\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }\n fn f2<X>(x: &X) {\n }\n \n // Bounded.\n-trait T {}\n-fn f3<Sized? X: T>(x: &X) {\n+trait T for {}\n+fn f3<X: ?Sized + T>(x: &X) {\n     f4::<X>(x);\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }\n fn f4<X: T>(x: &X) {\n }\n \n // Test with unsized enum.\n-enum E<Sized? X> {\n+enum E<X: ?Sized> {\n     V(X),\n }\n \n fn f5<Y>(x: &Y) {}\n-fn f6<Sized? X>(x: &X) {}\n-fn f7<Sized? X>(x1: &E<X>, x2: &E<X>) {\n+fn f6<X: ?Sized>(x: &X) {}\n+fn f7<X: ?Sized>(x1: &E<X>, x2: &E<X>) {\n     f5(x1);\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented\n     f6(x2); // ok\n }\n \n \n // Test with unsized struct.\n-struct S<Sized? X> {\n+struct S<X: ?Sized> {\n     x: X,\n }\n \n-fn f8<Sized? X>(x1: &S<X>, x2: &S<X>) {\n+fn f8<X: ?Sized>(x1: &S<X>, x2: &S<X>) {\n     f5(x1);\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented\n     f6(x2); // ok\n }\n \n // Test some tuples.\n-fn f9<Sized? X>(x1: Box<S<X>>, x2: Box<E<X>>) {\n+fn f9<X: ?Sized>(x1: Box<S<X>>, x2: Box<E<X>>) {\n     f5(&(*x1, 34i));\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }\n \n-fn f10<Sized? X>(x1: Box<S<X>>, x2: Box<E<X>>) {\n+fn f10<X: ?Sized>(x1: Box<S<X>>, x2: Box<E<X>>) {\n     f5(&(32i, *x2));\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }"}, {"sha": "f8b8ad2bf2efa4ee0b749ec7393599ba57e032c7", "filename": "src/test/compile-fail/unsized4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized4.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -11,7 +11,7 @@\n // Test that bounds are sized-compatible.\n \n trait T : Sized {}\n-fn f<Sized? Y: T>() {\n+fn f<Y: ?Sized + T>() {\n //~^ERROR incompatible bounds on `Y`, bound `T` does not allow unsized type\n }\n "}, {"sha": "f7477d746fae42faac883697deb0af0e5b681b28", "filename": "src/test/compile-fail/unsized5.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized5.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -10,11 +10,11 @@\n \n // Test `Sized?` types not allowed in fields (except the last one).\n \n-struct S1<Sized? X> {\n+struct S1<X: ?Sized> {\n     f1: X, //~ ERROR `core::kinds::Sized` is not implemented\n     f2: int,\n }\n-struct S2<Sized? X> {\n+struct S2<X: ?Sized> {\n     f: int,\n     g: X, //~ ERROR `core::kinds::Sized` is not implemented\n     h: int,\n@@ -27,10 +27,10 @@ struct S4 {\n     f: str, //~ ERROR `core::kinds::Sized` is not implemented\n     g: uint\n }\n-enum E<Sized? X> {\n+enum E<X: ?Sized> {\n     V1(X, int), //~ERROR `core::kinds::Sized` is not implemented\n }\n-enum F<Sized? X> {\n+enum F<X: ?Sized> {\n     V2{f1: X, f: int}, //~ERROR `core::kinds::Sized` is not implemented\n }\n "}, {"sha": "b4f0a4912cf3019152bb6b9d1c1f359a9dc803aa", "filename": "src/test/compile-fail/unsized6.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized6.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -13,30 +13,30 @@\n \n trait T {}\n \n-fn f1<Sized? X>(x: &X) {\n+fn f1<X: ?Sized>(x: &X) {\n     let _: X; // <-- this is OK, no bindings created, no initializer.\n     let _: (int, (X, int)); // same\n     let y: X; //~ERROR the trait `core::kinds::Sized` is not implemented\n     let y: (int, (X, int)); //~ERROR the trait `core::kinds::Sized` is not implemented\n }\n-fn f2<Sized? X: T>(x: &X) {\n+fn f2<X: ?Sized + T>(x: &X) {\n     let y: X; //~ERROR the trait `core::kinds::Sized` is not implemented\n     let y: (int, (X, int)); //~ERROR the trait `core::kinds::Sized` is not implemented\n }\n \n-fn f3<Sized? X>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n+fn f3<X: ?Sized>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n     let y: X = *x1; //~ERROR the trait `core::kinds::Sized` is not implemented\n     let y = *x2; //~ERROR the trait `core::kinds::Sized` is not implemented\n     let (y, z) = (*x3, 4i); //~ERROR the trait `core::kinds::Sized` is not implemented\n }\n-fn f4<Sized? X: T>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n+fn f4<X: ?Sized + T>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n     let y: X = *x1;         //~ERROR the trait `core::kinds::Sized` is not implemented\n     let y = *x2;            //~ERROR the trait `core::kinds::Sized` is not implemented\n     let (y, z) = (*x3, 4i); //~ERROR the trait `core::kinds::Sized` is not implemented\n }\n \n-fn g1<Sized? X>(x: X) {} //~ERROR the trait `core::kinds::Sized` is not implemented\n-fn g2<Sized? X: T>(x: X) {} //~ERROR the trait `core::kinds::Sized` is not implemented\n+fn g1<X: ?Sized>(x: X) {} //~ERROR the trait `core::kinds::Sized` is not implemented\n+fn g2<X: ?Sized + T>(x: X) {} //~ERROR the trait `core::kinds::Sized` is not implemented\n \n pub fn main() {\n }"}, {"sha": "8a54771112f8e4189c77abee87a57b0428ac23d7", "filename": "src/test/compile-fail/unsized7.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized7.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -16,8 +16,8 @@ trait T {}\n // impl - bounded\n trait T1<Z: T> {\n }\n-struct S3<Sized? Y>;\n-impl<Sized? X: T> T1<X> for S3<X> {\n+struct S3<Y: ?Sized>;\n+impl<X: ?Sized + T> T1<X> for S3<X> {\n     //~^ ERROR `core::kinds::Sized` is not implemented for the type `X`\n }\n "}, {"sha": "8b8b7f169c5a0274f85fcfadea6add6dc98bb225", "filename": "src/test/run-pass-valgrind/dst-dtor-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-1.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -20,7 +20,7 @@ impl Drop for Foo {\n trait Trait {}\n impl Trait for Foo {}\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     f: T\n }\n "}, {"sha": "743293c23f6adbb0c1e6ad8c55f19015fb4e99e9", "filename": "src/test/run-pass-valgrind/dst-dtor-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-2.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -17,7 +17,7 @@ impl Drop for Foo {\n     }\n }\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     f: T\n }\n "}, {"sha": "6d59161ff93456fdaf1163bc02cc17033d8b30e2", "filename": "src/test/run-pass/associated-types-conditional-dispatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -16,7 +16,7 @@\n \n use std::ops::Deref;\n \n-pub trait MyEq<Sized? U=Self> {\n+pub trait MyEq<U: ?Sized=Self> {\n     fn eq(&self, u: &U) -> bool;\n }\n "}, {"sha": "11ffb4198dad8c6b838a3ad1f0dcab79eb4ba9d5", "filename": "src/test/run-pass/issue-18906.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Frun-pass%2Fissue-18906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384e21878904ad1f139d9452c122b10a28a3c28c/src%2Ftest%2Frun-pass%2Fissue-18906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18906.rs?ref=384e21878904ad1f139d9452c122b10a28a3c28c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait Borrow<Sized? Borrowed> {\n+pub trait Borrow<Borrowed: ?Sized> {\n         fn borrow(&self) -> &Borrowed;\n }\n "}]}