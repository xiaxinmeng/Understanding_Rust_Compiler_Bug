{"sha": "fb6cfde5bad603193d1ae42786a725bd5dc01a40", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNmNmZGU1YmFkNjAzMTkzZDFhZTQyNzg2YTcyNWJkNWRjMDFhNDA=", "commit": {"author": {"name": "Gabriel Smith", "email": "gsmith@d3engineering.com", "date": "2019-11-18T19:30:01Z"}, "committer": {"name": "Gabriel Smith", "email": "gsmith@d3engineering.com", "date": "2019-11-18T22:23:22Z"}, "message": "rustc: lowering: Lower type args as const args when resolved in value\nnamespace", "tree": {"sha": "df694fa4e493a6e9ff50371bbb795fbfa2d35832", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df694fa4e493a6e9ff50371bbb795fbfa2d35832"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb6cfde5bad603193d1ae42786a725bd5dc01a40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb6cfde5bad603193d1ae42786a725bd5dc01a40", "html_url": "https://github.com/rust-lang/rust/commit/fb6cfde5bad603193d1ae42786a725bd5dc01a40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb6cfde5bad603193d1ae42786a725bd5dc01a40/comments", "author": null, "committer": null, "parents": [{"sha": "7b4642f44178403770cc35166fb676b7fa051bec", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b4642f44178403770cc35166fb676b7fa051bec", "html_url": "https://github.com/rust-lang/rust/commit/7b4642f44178403770cc35166fb676b7fa051bec"}], "stats": {"total": 61, "additions": 56, "deletions": 5}, "files": [{"sha": "06a7a6bb301de717154b165717ef4391ad9fcdb5", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fb6cfde5bad603193d1ae42786a725bd5dc01a40/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb6cfde5bad603193d1ae42786a725bd5dc01a40/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fb6cfde5bad603193d1ae42786a725bd5dc01a40", "patch": "@@ -1155,13 +1155,64 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_generic_arg(&mut self,\n-                         arg: &ast::GenericArg,\n-                         itctx: ImplTraitContext<'_>)\n-                         -> hir::GenericArg {\n+    fn lower_generic_arg(\n+        &mut self,\n+        arg: &ast::GenericArg,\n+        itctx: ImplTraitContext<'_>\n+    ) -> hir::GenericArg {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n-            ast::GenericArg::Type(ty) => GenericArg::Type(self.lower_ty_direct(&ty, itctx)),\n+            ast::GenericArg::Type(ty) => {\n+                // We parse const arguments as path types as we cannot distiguish them durring\n+                // parsing. We try to resolve that ambiguity by attempting resolution in both the\n+                // type and value namespaces. If we resolved the path in the value namespace, we\n+                // transform it into a generic const argument.\n+                if let TyKind::Path(ref qself, ref path) = ty.kind {\n+                    if let Some(partial_res) = self.resolver.get_partial_res(ty.id) {\n+                        let res = partial_res.base_res();\n+                        if !res.matches_ns(Namespace::TypeNS) {\n+                            debug!(\n+                                \"lower_generic_arg: Lowering type argument as const argument: {:?}\",\n+                                ty,\n+                            );\n+\n+                            // Construct a AnonConst where the expr is the \"ty\"'s path.\n+\n+                            let parent_def_index =\n+                                self.current_hir_id_owner.last().unwrap().0;\n+                            let node_id = self.resolver.next_node_id();\n+\n+                            // Add a definition for the in-band const def.\n+                            self.resolver.definitions().create_def_with_parent(\n+                                parent_def_index,\n+                                node_id,\n+                                DefPathData::AnonConst,\n+                                ExpnId::root(),\n+                                ty.span,\n+                            );\n+\n+                            let path_expr = Expr {\n+                                id: ty.id,\n+                                kind: ExprKind::Path(qself.clone(), path.clone()),\n+                                span: ty.span,\n+                                attrs: ThinVec::new(),\n+                            };\n+\n+                            let ct = self.with_new_scopes(|this| {\n+                                hir::AnonConst {\n+                                    hir_id: this.lower_node_id(node_id),\n+                                    body: this.lower_const_body(&path_expr),\n+                                }\n+                            });\n+                            return GenericArg::Const(ConstArg {\n+                                value: ct,\n+                                span: ty.span,\n+                            });\n+                        }\n+                    }\n+                }\n+                GenericArg::Type(self.lower_ty_direct(&ty, itctx))\n+            }\n             ast::GenericArg::Const(ct) => {\n                 GenericArg::Const(ConstArg {\n                     value: self.lower_anon_const(&ct),"}]}