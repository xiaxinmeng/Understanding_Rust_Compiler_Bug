{"sha": "99483be1c7629a17fad45b9c208982c3891639e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NDgzYmUxYzc2MjlhMTdmYWQ0NWI5YzIwODk4MmMzODkxNjM5ZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-29T08:41:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-29T08:41:39Z"}, "message": "Auto merge of #6093 - ebroto:6089_renamed_lifetimes, r=Manishearth\n\nneedless arbitrary self: handle macros\n\nThis fixes two cases related to macros:\n\n* If the parameter comes from expansion, do not lint as the user has no possibility of changing it. This is not directly related to the fixed issue, but we should probably do that.\n* If *only* the lifetime name comes from expansion, lint, but allow the user decide the name of the lifetime. In the related issue, the lifetime was unnamed and then renamed by `async_trait`, so just removing the name in the suggestion would work, but in the general case a macro can rename a lifetime that was named differently, and we can't reliably know that name anymore.\n\nAs a hint for the reviewer, the expanded code for the test can be checked with this command (from the root dir of the repo):\n```sh\nrustc -L target/debug/test_build_base/needless_arbitrary_self_type_unfixable.stage-id.aux -Zunpretty=expanded tests/ui/needless_arbitrary_self_type_unfixable.rs\n```\n\nchangelog: [`needless_arbitrary_self_type`]: handle macros\n\nFixes #6089", "tree": {"sha": "c2d87a0d0ac3a060f00dcb6aa17a0a829a8d035e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2d87a0d0ac3a060f00dcb6aa17a0a829a8d035e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99483be1c7629a17fad45b9c208982c3891639e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99483be1c7629a17fad45b9c208982c3891639e3", "html_url": "https://github.com/rust-lang/rust/commit/99483be1c7629a17fad45b9c208982c3891639e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99483be1c7629a17fad45b9c208982c3891639e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce678b9ac1aac0cb32a36f88294cabf88de316fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce678b9ac1aac0cb32a36f88294cabf88de316fc", "html_url": "https://github.com/rust-lang/rust/commit/ce678b9ac1aac0cb32a36f88294cabf88de316fc"}, {"sha": "101e76f117eeefcd2e901bab707de199b030f201", "url": "https://api.github.com/repos/rust-lang/rust/commits/101e76f117eeefcd2e901bab707de199b030f201", "html_url": "https://github.com/rust-lang/rust/commit/101e76f117eeefcd2e901bab707de199b030f201"}], "stats": {"total": 146, "additions": 139, "deletions": 7}, "files": [{"sha": "7687962bdd9bf1bfffe8cd772fd164421ed7a204", "filename": "clippy_lints/src/needless_arbitrary_self_type.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/99483be1c7629a17fad45b9c208982c3891639e3/clippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99483be1c7629a17fad45b9c208982c3891639e3/clippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs?ref=99483be1c7629a17fad45b9c208982c3891639e3", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::span_lint_and_sugg;\n+use crate::utils::{in_macro, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_ast::ast::{BindingMode, Lifetime, Mutability, Param, PatKind, Path, TyKind};\n use rustc_errors::Applicability;\n@@ -69,11 +69,30 @@ fn check_param_inner(cx: &EarlyContext<'_>, path: &Path, span: Span, binding_mod\n         if let [segment] = &path.segments[..];\n         if segment.ident.name == kw::SelfUpper;\n         then {\n+            // In case we have a named lifetime, we check if the name comes from expansion.\n+            // If it does, at this point we know the rest of the parameter was written by the user,\n+            // so let them decide what the name of the lifetime should be.\n+            // See #6089 for more details.\n+            let mut applicability = Applicability::MachineApplicable;\n             let self_param = match (binding_mode, mutbl) {\n                 (Mode::Ref(None), Mutability::Mut) => \"&mut self\".to_string(),\n-                (Mode::Ref(Some(lifetime)), Mutability::Mut) => format!(\"&{} mut self\", &lifetime.ident.name),\n+                (Mode::Ref(Some(lifetime)), Mutability::Mut) => {\n+                    if in_macro(lifetime.ident.span) {\n+                        applicability = Applicability::HasPlaceholders;\n+                        \"&'_ mut self\".to_string()\n+                    } else {\n+                        format!(\"&{} mut self\", &lifetime.ident.name)\n+                    }\n+                },\n                 (Mode::Ref(None), Mutability::Not) => \"&self\".to_string(),\n-                (Mode::Ref(Some(lifetime)), Mutability::Not) => format!(\"&{} self\", &lifetime.ident.name),\n+                (Mode::Ref(Some(lifetime)), Mutability::Not) => {\n+                    if in_macro(lifetime.ident.span) {\n+                        applicability = Applicability::HasPlaceholders;\n+                        \"&'_ self\".to_string()\n+                    } else {\n+                        format!(\"&{} self\", &lifetime.ident.name)\n+                    }\n+                },\n                 (Mode::Value, Mutability::Mut) => \"mut self\".to_string(),\n                 (Mode::Value, Mutability::Not) => \"self\".to_string(),\n             };\n@@ -85,15 +104,16 @@ fn check_param_inner(cx: &EarlyContext<'_>, path: &Path, span: Span, binding_mod\n                 \"the type of the `self` parameter does not need to be arbitrary\",\n                 \"consider to change this parameter to\",\n                 self_param,\n-                Applicability::MachineApplicable,\n+                applicability,\n             )\n         }\n     }\n }\n \n impl EarlyLintPass for NeedlessArbitrarySelfType {\n     fn check_param(&mut self, cx: &EarlyContext<'_>, p: &Param) {\n-        if !p.is_self() {\n+        // Bail out if the parameter it's not a receiver or was not written by the user\n+        if !p.is_self() || in_macro(p.span) {\n             return;\n         }\n "}, {"sha": "de670cdfc31f10b8de21317752752216674bf152", "filename": "tests/ui/auxiliary/proc_macro_attr.rs", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/99483be1c7629a17fad45b9c208982c3891639e3/tests%2Fui%2Fauxiliary%2Fproc_macro_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99483be1c7629a17fad45b9c208982c3891639e3/tests%2Fui%2Fauxiliary%2Fproc_macro_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macro_attr.rs?ref=99483be1c7629a17fad45b9c208982c3891639e3", "patch": "@@ -2,7 +2,7 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(repr128, proc_macro_hygiene, proc_macro_quote)]\n+#![feature(repr128, proc_macro_hygiene, proc_macro_quote, box_patterns)]\n #![allow(clippy::useless_conversion)]\n \n extern crate proc_macro;\n@@ -12,7 +12,11 @@ extern crate syn;\n use proc_macro::TokenStream;\n use quote::{quote, quote_spanned};\n use syn::parse_macro_input;\n-use syn::{parse_quote, ItemTrait, TraitItem};\n+use syn::spanned::Spanned;\n+use syn::token::Star;\n+use syn::{\n+    parse_quote, FnArg, ImplItem, ItemImpl, ItemTrait, Lifetime, Pat, PatIdent, PatType, Signature, TraitItem, Type,\n+};\n \n #[proc_macro_attribute]\n pub fn fake_async_trait(_args: TokenStream, input: TokenStream) -> TokenStream {\n@@ -36,3 +40,56 @@ pub fn fake_async_trait(_args: TokenStream, input: TokenStream) -> TokenStream {\n     }\n     TokenStream::from(quote!(#item))\n }\n+\n+#[proc_macro_attribute]\n+pub fn rename_my_lifetimes(_args: TokenStream, input: TokenStream) -> TokenStream {\n+    fn make_name(count: usize) -> String {\n+        format!(\"'life{}\", count)\n+    }\n+\n+    fn mut_receiver_of(sig: &mut Signature) -> Option<&mut FnArg> {\n+        let arg = sig.inputs.first_mut()?;\n+        if let FnArg::Typed(PatType { pat, .. }) = arg {\n+            if let Pat::Ident(PatIdent { ident, .. }) = &**pat {\n+                if ident == \"self\" {\n+                    return Some(arg);\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    let mut elided = 0;\n+    let mut item = parse_macro_input!(input as ItemImpl);\n+\n+    // Look for methods having arbitrary self type taken by &mut ref\n+    for inner in &mut item.items {\n+        if let ImplItem::Method(method) = inner {\n+            if let Some(FnArg::Typed(pat_type)) = mut_receiver_of(&mut method.sig) {\n+                if let box Type::Reference(reference) = &mut pat_type.ty {\n+                    // Target only unnamed lifetimes\n+                    let name = match &reference.lifetime {\n+                        Some(lt) if lt.ident == \"_\" => make_name(elided),\n+                        None => make_name(elided),\n+                        _ => continue,\n+                    };\n+                    elided += 1;\n+\n+                    // HACK: Syn uses `Span` from the proc_macro2 crate, and does not seem to reexport it.\n+                    // In order to avoid adding the dependency, get a default span from a non-existent token.\n+                    // A default span is needed to mark the code as coming from expansion.\n+                    let span = Star::default().span();\n+\n+                    // Replace old lifetime with the named one\n+                    let lifetime = Lifetime::new(&name, span);\n+                    reference.lifetime = Some(parse_quote!(#lifetime));\n+\n+                    // Add lifetime to the generics of the method\n+                    method.sig.generics.params.push(parse_quote!(#lifetime));\n+                }\n+            }\n+        }\n+    }\n+\n+    TokenStream::from(quote!(#item))\n+}"}, {"sha": "a39d96109f17d8d03e38c4701cc4345d1e51ed30", "filename": "tests/ui/needless_arbitrary_self_type_unfixable.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/99483be1c7629a17fad45b9c208982c3891639e3/tests%2Fui%2Fneedless_arbitrary_self_type_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99483be1c7629a17fad45b9c208982c3891639e3/tests%2Fui%2Fneedless_arbitrary_self_type_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_arbitrary_self_type_unfixable.rs?ref=99483be1c7629a17fad45b9c208982c3891639e3", "patch": "@@ -0,0 +1,45 @@\n+// aux-build:proc_macro_attr.rs\n+\n+#![warn(clippy::needless_arbitrary_self_type)]\n+\n+#[macro_use]\n+extern crate proc_macro_attr;\n+\n+mod issue_6089 {\n+    // Check that we don't lint if the `self` parameter comes from expansion\n+\n+    macro_rules! test_from_expansion {\n+        () => {\n+            trait T1 {\n+                fn test(self: &Self);\n+            }\n+\n+            struct S1 {}\n+\n+            impl T1 for S1 {\n+                fn test(self: &Self) {}\n+            }\n+        };\n+    }\n+\n+    test_from_expansion!();\n+\n+    // If only the lifetime name comes from expansion we will lint, but the suggestion will have\n+    // placeholders and will not be applied automatically, as we can't reliably know the original name.\n+    // This specific case happened with async_trait.\n+\n+    trait T2 {\n+        fn call_with_mut_self(&mut self);\n+    }\n+\n+    struct S2 {}\n+\n+    // The method's signature will be expanded to:\n+    //  fn call_with_mut_self<'life0>(self: &'life0 mut Self) {}\n+    #[rename_my_lifetimes]\n+    impl T2 for S2 {\n+        fn call_with_mut_self(self: &mut Self) {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "44a0e6ddeace63bcd54bc6f7284eff4a336ec4e9", "filename": "tests/ui/needless_arbitrary_self_type_unfixable.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99483be1c7629a17fad45b9c208982c3891639e3/tests%2Fui%2Fneedless_arbitrary_self_type_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99483be1c7629a17fad45b9c208982c3891639e3/tests%2Fui%2Fneedless_arbitrary_self_type_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_arbitrary_self_type_unfixable.stderr?ref=99483be1c7629a17fad45b9c208982c3891639e3", "patch": "@@ -0,0 +1,10 @@\n+error: the type of the `self` parameter does not need to be arbitrary\n+  --> $DIR/needless_arbitrary_self_type_unfixable.rs:41:31\n+   |\n+LL |         fn call_with_mut_self(self: &mut Self) {}\n+   |                               ^^^^^^^^^^^^^^^ help: consider to change this parameter to: `&'_ mut self`\n+   |\n+   = note: `-D clippy::needless-arbitrary-self-type` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}]}