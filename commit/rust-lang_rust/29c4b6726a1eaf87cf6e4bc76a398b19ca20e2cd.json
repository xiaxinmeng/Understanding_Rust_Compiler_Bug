{"sha": "29c4b6726a1eaf87cf6e4bc76a398b19ca20e2cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YzRiNjcyNmExZWFmODdjZjZlNGJjNzZhMzk4YjE5Y2EyMGUyY2Q=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-01T02:13:45Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-11T03:13:48Z"}, "message": "Refactor away the `CfgFolder` trait.", "tree": {"sha": "ae2157bb40b5016fb147fc9d6e87d1a8d3eb0a35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae2157bb40b5016fb147fc9d6e87d1a8d3eb0a35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29c4b6726a1eaf87cf6e4bc76a398b19ca20e2cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29c4b6726a1eaf87cf6e4bc76a398b19ca20e2cd", "html_url": "https://github.com/rust-lang/rust/commit/29c4b6726a1eaf87cf6e4bc76a398b19ca20e2cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29c4b6726a1eaf87cf6e4bc76a398b19ca20e2cd/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c89846c271e0e1d98c6f97655f6ac0eac4474cd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c89846c271e0e1d98c6f97655f6ac0eac4474cd2", "html_url": "https://github.com/rust-lang/rust/commit/c89846c271e0e1d98c6f97655f6ac0eac4474cd2"}], "stats": {"total": 52, "additions": 18, "deletions": 34}, "files": [{"sha": "021f417279ef492ab063040af6e1180ac344b34c", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 18, "deletions": 34, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/29c4b6726a1eaf87cf6e4bc76a398b19ca20e2cd/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c4b6726a1eaf87cf6e4bc76a398b19ca20e2cd/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=29c4b6726a1eaf87cf6e4bc76a398b19ca20e2cd", "patch": "@@ -19,27 +19,7 @@ use ptr::P;\n \n use util::small_vector::SmallVector;\n \n-pub trait CfgFolder: fold::Folder {\n-    // Check if a node with the given attributes is in this configuration.\n-    fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool;\n-\n-    // Update a node before checking if it is in this configuration (used to implement `cfg_attr`).\n-    fn process_attrs<T: HasAttrs>(&mut self, node: T) -> T { node }\n-\n-    // Visit attributes on expression and statements (but not attributes on items in blocks).\n-    fn visit_stmt_or_expr_attrs(&mut self, _attrs: &[ast::Attribute]) {}\n-\n-    // Visit unremovable (non-optional) expressions -- c.f. `fold_expr` vs `fold_opt_expr`.\n-    fn visit_unremovable_expr(&mut self, _expr: &ast::Expr) {}\n-\n-    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n-        let node = self.process_attrs(node);\n-        if self.in_cfg(node.attrs()) { Some(node) } else { None }\n-    }\n-}\n-\n-/// A folder that strips out items that do not belong in the current\n-/// configuration.\n+/// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n     diag: CfgDiagReal<'a, 'a>,\n     should_test: bool,\n@@ -59,6 +39,17 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n+    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n+        let node = self.process_cfg_attrs(node);\n+        if self.in_cfg(node.attrs()) { Some(node) } else { None }\n+    }\n+\n+    fn process_cfg_attrs<T: HasAttrs>(&mut self, node: T) -> T {\n+        node.map_attrs(|attrs| {\n+            attrs.into_iter().filter_map(|attr| self.process_cfg_attr(attr)).collect()\n+        })\n+    }\n+\n     fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> {\n         if !attr.check_name(\"cfg_attr\") {\n             return Some(attr);\n@@ -92,11 +83,8 @@ impl<'a> StripUnconfigured<'a> {\n             None\n         }\n     }\n-}\n \n-impl<'a> CfgFolder for StripUnconfigured<'a> {\n-    // Determine if an item should be translated in the current crate\n-    // configuration based on the item's attributes\n+    // Determine if a node with the given attributes should be included in this configuation.\n     fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n             // When not compiling with --test we should not compile the #[test] functions\n@@ -120,19 +108,15 @@ impl<'a> CfgFolder for StripUnconfigured<'a> {\n         })\n     }\n \n-    fn process_attrs<T: HasAttrs>(&mut self, node: T) -> T {\n-        node.map_attrs(|attrs| {\n-            attrs.into_iter().filter_map(|attr| self.process_cfg_attr(attr)).collect()\n-        })\n-    }\n-\n+    // Visit attributes on expression and statements (but not attributes on items in blocks).\n     fn visit_stmt_or_expr_attrs(&mut self, attrs: &[ast::Attribute]) {\n         // flag the offending attributes\n         for attr in attrs.iter() {\n             self.diag.feature_gated_cfgs.push(GatedCfgAttr::GatedAttr(attr.span));\n         }\n     }\n \n+    // Visit unremovable (non-optional) expressions -- c.f. `fold_expr` vs `fold_opt_expr`.\n     fn visit_unremovable_expr(&mut self, expr: &ast::Expr) {\n         if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a) || is_test_or_bench(a)) {\n             let msg = \"removing an expression is not supported in this position\";\n@@ -151,7 +135,7 @@ pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate, should_\n     StripUnconfigured::new(config, should_test, diagnostic, feature_gated_cfgs).fold_crate(krate)\n }\n \n-impl<T: CfgFolder> fold::Folder for T {\n+impl<'a> fold::Folder for StripUnconfigured<'a> {\n     fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         ast::ForeignMod {\n             abi: foreign_mod.abi,\n@@ -212,7 +196,7 @@ impl<T: CfgFolder> fold::Folder for T {\n         // NB: This is intentionally not part of the fold_expr() function\n         //     in order for fold_opt_expr() to be able to avoid this check\n         self.visit_unremovable_expr(&expr);\n-        let expr = self.process_attrs(expr);\n+        let expr = self.process_cfg_attrs(expr);\n         fold_expr(self, expr)\n     }\n \n@@ -264,7 +248,7 @@ impl<T: CfgFolder> fold::Folder for T {\n     }\n }\n \n-fn fold_expr<F: CfgFolder>(folder: &mut F, expr: P<ast::Expr>) -> P<ast::Expr> {\n+fn fold_expr(folder: &mut StripUnconfigured, expr: P<ast::Expr>) -> P<ast::Expr> {\n     expr.map(|ast::Expr {id, span, node, attrs}| {\n         fold::noop_fold_expr(ast::Expr {\n             id: id,"}]}