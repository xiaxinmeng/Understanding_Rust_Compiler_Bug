{"sha": "eab2d7519a3f1c11ddaff3d19f8b7727354c6362", "node_id": "C_kwDOAAsO6NoAKGVhYjJkNzUxOWEzZjFjMTFkZGFmZjNkMTlmOGI3NzI3MzU0YzYzNjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-15T11:18:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-15T11:18:44Z"}, "message": "Auto merge of #90717 - kit-981:fix-ld64-flags, r=petrochenkov\n\nFix ld64 flags\n\n- The `-exported_symbols_list` argument appears to be malformed for `ld64` (if you are not going through `clang`).\n- The `-dynamiclib` argument isn't support for `ld64`. It should be guarded behind a compiler flag.\n\nThese problems are fixed by these changes. I have also refactored the way linker arguments are generated to be ld/compiler agnostic and therefore less error prone.\n\nThese changes are necessary to support cross-compilation to darwin targets.", "tree": {"sha": "00fae71c3006528687a52a66f22721bcce0fa4d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00fae71c3006528687a52a66f22721bcce0fa4d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eab2d7519a3f1c11ddaff3d19f8b7727354c6362", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eab2d7519a3f1c11ddaff3d19f8b7727354c6362", "html_url": "https://github.com/rust-lang/rust/commit/eab2d7519a3f1c11ddaff3d19f8b7727354c6362", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eab2d7519a3f1c11ddaff3d19f8b7727354c6362/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5a0c7cb036032288a4a5443b54ba061ec12ee26", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5a0c7cb036032288a4a5443b54ba061ec12ee26", "html_url": "https://github.com/rust-lang/rust/commit/d5a0c7cb036032288a4a5443b54ba061ec12ee26"}, {"sha": "f44fa6348f48403a79b506823286444b453267cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f44fa6348f48403a79b506823286444b453267cb", "html_url": "https://github.com/rust-lang/rust/commit/f44fa6348f48403a79b506823286444b453267cb"}], "stats": {"total": 92, "additions": 50, "deletions": 42}, "files": [{"sha": "15d16e7d3d61aea74ead8c0e3a9a9110c083ceb8", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/eab2d7519a3f1c11ddaff3d19f8b7727354c6362/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab2d7519a3f1c11ddaff3d19f8b7727354c6362/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=eab2d7519a3f1c11ddaff3d19f8b7727354c6362", "patch": "@@ -219,19 +219,36 @@ pub struct GccLinker<'a> {\n }\n \n impl<'a> GccLinker<'a> {\n-    /// Argument that must be passed *directly* to the linker\n+    /// Passes an argument directly to the linker.\n     ///\n-    /// These arguments need to be prepended with `-Wl`, when a GCC-style linker is used.\n-    fn linker_arg<S>(&mut self, arg: S) -> &mut Self\n-    where\n-        S: AsRef<OsStr>,\n-    {\n-        if !self.is_ld {\n-            let mut os = OsString::from(\"-Wl,\");\n-            os.push(arg.as_ref());\n-            self.cmd.arg(os);\n+    /// When the linker is not ld-like such as when using a compiler as a linker, the argument is\n+    /// prepended by `-Wl,`.\n+    fn linker_arg(&mut self, arg: impl AsRef<OsStr>) -> &mut Self {\n+        self.linker_args(&[arg]);\n+        self\n+    }\n+\n+    /// Passes a series of arguments directly to the linker.\n+    ///\n+    /// When the linker is ld-like, the arguments are simply appended to the command. When the\n+    /// linker is not ld-like such as when using a compiler as a linker, the arguments are joined by\n+    /// commas to form an argument that is then prepended with `-Wl`. In this situation, only a\n+    /// single argument is appended to the command to ensure that the order of the arguments is\n+    /// preserved by the compiler.\n+    fn linker_args(&mut self, args: &[impl AsRef<OsStr>]) -> &mut Self {\n+        if self.is_ld {\n+            args.into_iter().for_each(|a| {\n+                self.cmd.arg(a);\n+            });\n         } else {\n-            self.cmd.arg(arg);\n+            if !args.is_empty() {\n+                let mut s = OsString::from(\"-Wl\");\n+                for a in args {\n+                    s.push(\",\");\n+                    s.push(a);\n+                }\n+                self.cmd.arg(s);\n+            }\n         }\n         self\n     }\n@@ -289,25 +306,29 @@ impl<'a> GccLinker<'a> {\n         if let Some(path) = &self.sess.opts.debugging_opts.profile_sample_use {\n             self.linker_arg(&format!(\"-plugin-opt=sample-profile={}\", path.display()));\n         };\n-        self.linker_arg(&format!(\"-plugin-opt={}\", opt_level));\n-        self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", self.target_cpu));\n+        self.linker_args(&[\n+            &format!(\"-plugin-opt={}\", opt_level),\n+            &format!(\"-plugin-opt=mcpu={}\", self.target_cpu),\n+        ]);\n     }\n \n     fn build_dylib(&mut self, out_filename: &Path) {\n         // On mac we need to tell the linker to let this library be rpathed\n         if self.sess.target.is_like_osx {\n-            self.cmd.arg(\"-dynamiclib\");\n+            if !self.is_ld {\n+                self.cmd.arg(\"-dynamiclib\");\n+            }\n+\n             self.linker_arg(\"-dylib\");\n \n             // Note that the `osx_rpath_install_name` option here is a hack\n             // purely to support rustbuild right now, we should get a more\n             // principled solution at some point to force the compiler to pass\n             // the right `-Wl,-install_name` with an `@rpath` in it.\n             if self.sess.opts.cg.rpath || self.sess.opts.debugging_opts.osx_rpath_install_name {\n-                self.linker_arg(\"-install_name\");\n-                let mut v = OsString::from(\"@rpath/\");\n-                v.push(out_filename.file_name().unwrap());\n-                self.linker_arg(&v);\n+                let mut rpath = OsString::from(\"@rpath/\");\n+                rpath.push(out_filename.file_name().unwrap());\n+                self.linker_args(&[OsString::from(\"-install_name\"), rpath]);\n             }\n         } else {\n             self.cmd.arg(\"-shared\");\n@@ -381,8 +402,7 @@ impl<'a> Linker for GccLinker<'a> {\n                 self.build_dylib(out_filename);\n             }\n             LinkOutputKind::WasiReactorExe => {\n-                self.linker_arg(\"--entry\");\n-                self.linker_arg(\"_initialize\");\n+                self.linker_args(&[\"--entry\", \"_initialize\"]);\n             }\n         }\n         // VxWorks compiler driver introduced `--static-crt` flag specifically for rustc,\n@@ -454,8 +474,7 @@ impl<'a> Linker for GccLinker<'a> {\n         self.cmd.arg(path);\n     }\n     fn full_relro(&mut self) {\n-        self.linker_arg(\"-zrelro\");\n-        self.linker_arg(\"-znow\");\n+        self.linker_args(&[\"-zrelro\", \"-znow\"]);\n     }\n     fn partial_relro(&mut self) {\n         self.linker_arg(\"-zrelro\");\n@@ -639,7 +658,6 @@ impl<'a> Linker for GccLinker<'a> {\n         }\n \n         let is_windows = self.sess.target.is_like_windows;\n-        let mut arg = OsString::new();\n         let path = tmpdir.join(if is_windows { \"list.def\" } else { \"list\" });\n \n         debug!(\"EXPORTED SYMBOLS:\");\n@@ -691,27 +709,18 @@ impl<'a> Linker for GccLinker<'a> {\n         }\n \n         if self.sess.target.is_like_osx {\n-            if !self.is_ld {\n-                arg.push(\"-Wl,\")\n-            }\n-            arg.push(\"-exported_symbols_list,\");\n+            self.linker_args(&[OsString::from(\"-exported_symbols_list\"), path.into()]);\n         } else if self.sess.target.is_like_solaris {\n-            if !self.is_ld {\n-                arg.push(\"-Wl,\")\n-            }\n-            arg.push(\"-M,\");\n+            self.linker_args(&[OsString::from(\"-M\"), path.into()]);\n         } else {\n-            if !self.is_ld {\n-                arg.push(\"-Wl,\")\n-            }\n-            // Both LD and LLD accept export list in *.def file form, there are no flags required\n-            if !is_windows {\n-                arg.push(\"--version-script=\")\n+            if is_windows {\n+                self.linker_arg(path);\n+            } else {\n+                let mut arg = OsString::from(\"--version-script=\");\n+                arg.push(path);\n+                self.linker_arg(arg);\n             }\n         }\n-\n-        arg.push(&path);\n-        self.cmd.arg(arg);\n     }\n \n     fn subsystem(&mut self, subsystem: &str) {\n@@ -769,8 +778,7 @@ impl<'a> Linker for GccLinker<'a> {\n             self.linker_arg(\"--as-needed\");\n         } else if self.sess.target.is_like_solaris {\n             // -z ignore is the Solaris equivalent to the GNU ld --as-needed option\n-            self.linker_arg(\"-z\");\n-            self.linker_arg(\"ignore\");\n+            self.linker_args(&[\"-z\", \"ignore\"]);\n         }\n     }\n }"}]}