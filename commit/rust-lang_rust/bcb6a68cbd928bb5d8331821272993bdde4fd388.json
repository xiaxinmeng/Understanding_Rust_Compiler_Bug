{"sha": "bcb6a68cbd928bb5d8331821272993bdde4fd388", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYjZhNjhjYmQ5MjhiYjVkODMzMTgyMTI3Mjk5M2JkZGU0ZmQzODg=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-10T00:22:43Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-10T00:29:34Z"}, "message": "sync: Add rwlocks (half-done) and test cases", "tree": {"sha": "f07beac79fdc045807be8124de796578e0aa847f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f07beac79fdc045807be8124de796578e0aa847f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcb6a68cbd928bb5d8331821272993bdde4fd388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcb6a68cbd928bb5d8331821272993bdde4fd388", "html_url": "https://github.com/rust-lang/rust/commit/bcb6a68cbd928bb5d8331821272993bdde4fd388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcb6a68cbd928bb5d8331821272993bdde4fd388/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef32a99f261091c677a0370cc9d0d00098478efd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef32a99f261091c677a0370cc9d0d00098478efd", "html_url": "https://github.com/rust-lang/rust/commit/ef32a99f261091c677a0370cc9d0d00098478efd"}], "stats": {"total": 195, "additions": 177, "deletions": 18}, "files": [{"sha": "d0092df4f16a32d64dc25d6f8f38554b5b940c74", "filename": "src/libcore/sync.rs", "status": "modified", "additions": 177, "deletions": 18, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/bcb6a68cbd928bb5d8331821272993bdde4fd388/src%2Flibcore%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcb6a68cbd928bb5d8331821272993bdde4fd388/src%2Flibcore%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync.rs?ref=bcb6a68cbd928bb5d8331821272993bdde4fd388", "patch": "@@ -8,6 +8,7 @@\n export condvar;\n export semaphore, new_semaphore;\n export mutex, new_mutex;\n+export rwlock;\n \n // FIXME (#3119) This shouldn't be a thing exported from core.\n import arc::exclusive;\n@@ -58,6 +59,17 @@ enum sem<Q: send> = exclusive<{\n     blocked:   Q,\n }>;\n \n+fn new_sem<Q: send>(count: int, +q: Q) -> sem<Q> {\n+    let (wait_tail, wait_head)  = pipes::stream();\n+    sem(exclusive({ mut count: count,\n+                    waiters: { head: wait_head, tail: wait_tail },\n+                    blocked: q }))\n+}\n+fn new_sem_and_signal(count: int) -> sem<waitqueue> {\n+    let (block_tail, block_head) = pipes::stream();\n+    new_sem(count, { head: block_head, tail: block_tail })\n+}\n+\n impl<Q: send> &sem<Q> {\n     fn acquire() {\n         let mut waiter_nobe = none;\n@@ -217,12 +229,7 @@ impl &sem<waitqueue> {\n enum semaphore = sem<()>;\n \n /// Create a new semaphore with the specified count.\n-fn new_semaphore(count: int) -> semaphore {\n-    let (wait_tail, wait_head)  = pipes::stream();\n-    semaphore(sem(exclusive({ mut count: count,\n-                              waiters: { head: wait_head, tail: wait_tail },\n-                              blocked: () })))\n-}\n+fn new_semaphore(count: int) -> semaphore { semaphore(new_sem(count, ())) }\n \n impl &semaphore {\n     /// Create a new handle to the semaphore.\n@@ -257,13 +264,7 @@ impl &semaphore {\n enum mutex = sem<waitqueue>;\n \n /// Create a new mutex.\n-fn new_mutex() -> mutex {\n-    let (wait_tail,  wait_head)  = pipes::stream();\n-    let (block_tail, block_head) = pipes::stream();\n-    mutex(sem(exclusive({ mut count: 1,\n-                          waiters: { head: wait_head,  tail: wait_tail  },\n-                          blocked: { head: block_head, tail: block_tail } })))\n-}\n+fn new_mutex() -> mutex { mutex(new_sem_and_signal(1)) }\n \n impl &mutex {\n     /// Create a new handle to the mutex.\n@@ -282,7 +283,86 @@ impl &mutex {\n  * Reader-writer locks\n  ****************************************************************************/\n \n-// FIXME(#3145) implement\n+// NB: Wikipedia - Readers-writers_problem#The_third_readers-writers_problem\n+\n+struct rwlock_inner {\n+    read_mode:  bool;\n+    read_count: uint;\n+}\n+\n+/// A blocking, no-starvation, reader-writer lock with an associated condvar.\n+struct rwlock {\n+    order_lock:  semaphore;\n+    access_lock: sem<waitqueue>;\n+    state:       arc::exclusive<rwlock_inner>;\n+}\n+\n+fn rwlock() -> rwlock {\n+    rwlock { order_lock: new_semaphore(1), access_lock: new_sem_and_signal(1),\n+             state: arc::exclusive(rwlock_inner { read_mode:  false,\n+                                                  read_count: 0 }) }\n+}\n+\n+impl &rwlock {\n+    // Create a new handle to the rwlock.\n+    fn clone() -> rwlock {\n+        rwlock { order_lock:  (&(self.order_lock)).clone(),\n+                 access_lock: sem((*self.access_lock).clone()),\n+                 state:       self.state.clone() }\n+    }\n+\n+    /**\n+     * Run a function with the rwlock in read mode. Calls to 'read' from other\n+     * tasks may run concurrently with this one.\n+     */\n+    fn read<U>(blk: fn() -> U) -> U {\n+        do (&self.order_lock).access {\n+            let mut first_reader = false;\n+            do self.state.with |state| {\n+                state.read_mode = true;\n+                first_reader = (state.read_count == 0);\n+                state.read_count += 1;\n+            }\n+            if first_reader {\n+                (&self.access_lock).acquire();\n+            }\n+        }\n+        let result = blk();\n+        let mut last_reader = false;\n+        do self.state.with |state| {\n+            assert state.read_mode;\n+            state.read_count -= 1;\n+            last_reader = (state.read_count == 0);\n+        }\n+        if last_reader {\n+            (&self.access_lock).release();\n+        }\n+        result\n+    }\n+\n+    /**\n+     * Run a function with the rwlock in write mode. No calls to 'read' or\n+     * 'write' from other tasks will run concurrently with this one.\n+     */\n+    fn write<U>(blk: fn() -> U) -> U {\n+        (&self.order_lock).acquire();\n+        do (&self.access_lock).access {\n+            (&self.order_lock).release();\n+            blk()\n+        }\n+    }\n+\n+    /**\n+     * As write(), but also with a handle to a condvar. Waiting on this\n+     * condvar will allow readers and writers alike to take the rwlock before\n+     * the waiting task is signalled.\n+     */\n+    fn write_cond<U>(_blk: fn(condvar) -> U) -> U {\n+        fail ~\"Need implement lock order lock before access lock\";\n+    }\n+\n+    // to-do implement downgrade\n+}\n \n /****************************************************************************\n  * Tests\n@@ -443,9 +523,8 @@ mod tests {\n         }\n         let _ = port.recv(); // Wait until child wakes up\n     }\n-    #[test]\n-    fn test_mutex_cond_broadcast() {\n-        let num_waiters: uint = 12;\n+    #[cfg(test)]\n+    fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n         let m = ~new_mutex();\n         let mut ports = ~[];\n \n@@ -471,6 +550,25 @@ mod tests {\n         // wait until all children wake up\n         for ports.each |port| { let _ = port.recv(); }\n     }\n+    #[test]\n+    fn test_mutex_cond_broadcast() {\n+        test_mutex_cond_broadcast_helper(12);\n+    }\n+    #[test]\n+    fn test_mutex_cond_broadcast_none() {\n+        test_mutex_cond_broadcast_helper(0);\n+    }\n+    #[test]\n+    fn test_mutex_cond_no_waiter() {\n+        let m = ~new_mutex();\n+        let m2 = ~m.clone();\n+        do task::try {\n+            do m.lock_cond |_x| { }\n+        };\n+        do m2.lock_cond |cond| {\n+            assert !cond.signal();\n+        }\n+    }\n     #[test] #[ignore(cfg(windows))]\n     fn test_mutex_killed_simple() {\n         // Mutex must get automatically unlocked if failed/killed within.\n@@ -508,11 +606,72 @@ mod tests {\n         assert result.is_err();\n         // child task must have finished by the time try returns\n         do m.lock_cond |cond| {\n-            let woken = cond.signal();\n+            let _woken = cond.signal();\n             // FIXME(#3145) - The semantics of pipes are not quite what I want\n             // here - the pipe doesn't get 'terminated' if the child was\n             // punted awake during failure.\n             // assert !woken;\n         }\n     }\n+    #[cfg(test)]\n+    fn test_rwlock_exclusion(reader1: bool, reader2: bool) {\n+        // Test mutual exclusion between readers and writers. Just like the\n+        // mutex mutual exclusion test, a ways above.\n+        let (c,p) = pipes::stream();\n+        let m = ~rwlock();\n+        let m2 = ~m.clone();\n+        let sharedstate = ~0;\n+        let ptr = ptr::addr_of(*sharedstate);\n+        do task::spawn {\n+            let sharedstate = unsafe { unsafe::reinterpret_cast(ptr) };\n+            access_shared(sharedstate, m2, reader1, 10);\n+            c.send(());\n+        }\n+        access_shared(sharedstate, m, reader2, 10);\n+        let _ = p.recv();\n+\n+        assert *sharedstate == 20;\n+\n+        fn access_shared(sharedstate: &mut int, m: &rwlock, reader: bool,\n+                         n: uint) {\n+            let lock_fn = fn@(m: &rwlock, blk: fn()) {\n+                if reader { m.read(blk); } else { m.write(blk); }\n+            };\n+            for n.times {\n+                do lock_fn(m) {\n+                    let oldval = *sharedstate;\n+                    task::yield();\n+                    *sharedstate = oldval + 1;\n+                }\n+            }\n+        }\n+    }\n+    #[test]\n+    fn test_rwlock_readers_wont_modify_the_data() {\n+        test_rwlock_exclusion(true, false);\n+        test_rwlock_exclusion(false, true);\n+    }\n+    #[test]\n+    fn test_rwlock_writers_and_writers() {\n+        test_rwlock_exclusion(false, false);\n+    }\n+    #[test]\n+    fn test_rwlock_readers_and_readers() {\n+        // Much like sem_multi_resource.\n+        let x = ~rwlock();\n+        let x2 = ~x.clone();\n+        let (c1,p1) = pipes::stream();\n+        let (c2,p2) = pipes::stream();\n+        do task::spawn {\n+            do x2.read {\n+                let _ = p2.recv();\n+                c1.send(());\n+            }\n+        }\n+        do x.read {\n+            c2.send(());\n+            let _ = p1.recv();\n+        }\n+\n+    }\n }"}]}