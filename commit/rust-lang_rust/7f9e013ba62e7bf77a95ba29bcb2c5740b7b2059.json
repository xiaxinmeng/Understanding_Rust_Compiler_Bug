{"sha": "7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "node_id": "C_kwDOAAsO6NoAKDdmOWUwMTNiYTYyZTdiZjc3YTk1YmEyOWJjYjJjNTc0MGI3YjIwNTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-06T07:20:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-06T07:20:04Z"}, "message": "Auto merge of #96510 - m-ou-se:futex-bsd, r=Amanieu\n\nUse futex-based locks and thread parker on {Free, Open, DragonFly}BSD.\n\nThis switches *BSD to our futex-based locks and thread parker.\n\nTracking issue: https://github.com/rust-lang/rust/issues/93740\n\nThis is a draft, because this still needs a new version of the `libc` crate to be published that includes https://github.com/rust-lang/libc/pull/2770.\n\nr? `@Amanieu`", "tree": {"sha": "ac78fcfbc9aed27520cc386b90a57f0d4f166acc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac78fcfbc9aed27520cc386b90a57f0d4f166acc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "html_url": "https://github.com/rust-lang/rust/commit/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9714e139ffb25f3b96b28110ae81677c8c1a7cf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9714e139ffb25f3b96b28110ae81677c8c1a7cf2", "html_url": "https://github.com/rust-lang/rust/commit/9714e139ffb25f3b96b28110ae81677c8c1a7cf2"}, {"sha": "21c5f780f464b27802d0ee0f86c95eb29881096b", "url": "https://api.github.com/repos/rust-lang/rust/commits/21c5f780f464b27802d0ee0f86c95eb29881096b", "html_url": "https://github.com/rust-lang/rust/commit/21c5f780f464b27802d0ee0f86c95eb29881096b"}], "stats": {"total": 220, "additions": 171, "deletions": 49}, "files": [{"sha": "f5aacba20cd2363675a0f022b5f69c97f384986d", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "patch": "@@ -2073,9 +2073,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.121\"\n+version = \"0.2.125\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"efaa7b300f3b5fe8eb6bf21ce3895e1751d9665086af2d64b42f19701015ff4f\"\n+checksum = \"5916d2ae698f6de9bfb891ad7a8d65c09d232dc58cc4ac433c7da3b2fd84bc2b\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "d0d7d480fe8e23d1fe77bce06829fda56987c072", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "patch": "@@ -15,7 +15,7 @@ cfg-if = { version = \"0.1.8\", features = ['rustc-dep-of-std'] }\n panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n-libc = { version = \"0.2.116\", default-features = false, features = ['rustc-dep-of-std'] }\n+libc = { version = \"0.2.125\", default-features = false, features = ['rustc-dep-of-std'] }\n compiler_builtins = { version = \"0.1.71\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }"}, {"sha": "24f467f0b03d7a3c750348e9b969b3ae72cbd799", "filename": "library/std/src/sync/condvar/tests.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2Fsrc%2Fsync%2Fcondvar%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2Fsrc%2Fsync%2Fcondvar%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar%2Ftests.rs?ref=7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "patch": "@@ -188,24 +188,3 @@ fn wait_timeout_wake() {\n         break;\n     }\n }\n-\n-#[test]\n-#[should_panic]\n-#[cfg(all(unix, not(target_os = \"linux\"), not(target_os = \"android\")))]\n-fn two_mutexes() {\n-    let m = Arc::new(Mutex::new(()));\n-    let m2 = m.clone();\n-    let c = Arc::new(Condvar::new());\n-    let c2 = c.clone();\n-\n-    let mut g = m.lock().unwrap();\n-    let _t = thread::spawn(move || {\n-        let _g = m2.lock().unwrap();\n-        c2.notify_one();\n-    });\n-    g = c.wait(g).unwrap();\n-    drop(g);\n-\n-    let m = Mutex::new(());\n-    let _ = c.wait(m.lock().unwrap()).unwrap();\n-}"}, {"sha": "678c6f0d6ead1b6ab299a196ba10974517d551d1", "filename": "library/std/src/sys/unix/futex.rs", "status": "modified", "additions": 154, "deletions": 24, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "patch": "@@ -1,7 +1,10 @@\n #![cfg(any(\n     target_os = \"linux\",\n     target_os = \"android\",\n-    all(target_os = \"emscripten\", target_feature = \"atomics\")\n+    all(target_os = \"emscripten\", target_feature = \"atomics\"),\n+    target_os = \"freebsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"dragonfly\",\n ))]\n \n use crate::sync::atomic::AtomicU32;\n@@ -12,7 +15,7 @@ use crate::time::Duration;\n /// Returns directly if the futex doesn't hold the expected value.\n ///\n /// Returns false on timeout, and true in all other cases.\n-#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+#[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"freebsd\"))]\n pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {\n     use super::time::Timespec;\n     use crate::ptr::null;\n@@ -30,18 +33,43 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n             return true;\n         }\n \n-        // Use FUTEX_WAIT_BITSET rather than FUTEX_WAIT to be able to give an\n-        // absolute time rather than a relative time.\n         let r = unsafe {\n-            libc::syscall(\n-                libc::SYS_futex,\n-                futex as *const AtomicU32,\n-                libc::FUTEX_WAIT_BITSET | libc::FUTEX_PRIVATE_FLAG,\n-                expected,\n-                timespec.as_ref().map_or(null(), |t| &t.t as *const libc::timespec),\n-                null::<u32>(), // This argument is unused for FUTEX_WAIT_BITSET.\n-                !0u32,         // A full bitmask, to make it behave like a regular FUTEX_WAIT.\n-            )\n+            cfg_if::cfg_if! {\n+                if #[cfg(target_os = \"freebsd\")] {\n+                    // FreeBSD doesn't have futex(), but it has\n+                    // _umtx_op(UMTX_OP_WAIT_UINT_PRIVATE), which is nearly\n+                    // identical. It supports absolute timeouts through a flag\n+                    // in the _umtx_time struct.\n+                    let umtx_timeout = timespec.map(|t| libc::_umtx_time {\n+                        _timeout: t.t,\n+                        _flags: libc::UMTX_ABSTIME,\n+                        _clockid: libc::CLOCK_MONOTONIC as u32,\n+                    });\n+                    let umtx_timeout_ptr = umtx_timeout.as_ref().map_or(null(), |t| t as *const _);\n+                    let umtx_timeout_size = umtx_timeout.as_ref().map_or(0, |t| crate::mem::size_of_val(t));\n+                    libc::_umtx_op(\n+                        futex as *const AtomicU32 as *mut _,\n+                        libc::UMTX_OP_WAIT_UINT_PRIVATE,\n+                        expected as libc::c_ulong,\n+                        crate::ptr::invalid_mut(umtx_timeout_size),\n+                        umtx_timeout_ptr as *mut _,\n+                    )\n+                } else if #[cfg(any(target_os = \"linux\", target_os = \"android\"))] {\n+                    // Use FUTEX_WAIT_BITSET rather than FUTEX_WAIT to be able to give an\n+                    // absolute time rather than a relative time.\n+                    libc::syscall(\n+                        libc::SYS_futex,\n+                        futex as *const AtomicU32,\n+                        libc::FUTEX_WAIT_BITSET | libc::FUTEX_PRIVATE_FLAG,\n+                        expected,\n+                        timespec.as_ref().map_or(null(), |t| &t.t as *const libc::timespec),\n+                        null::<u32>(), // This argument is unused for FUTEX_WAIT_BITSET.\n+                        !0u32,         // A full bitmask, to make it behave like a regular FUTEX_WAIT.\n+                    )\n+                } else {\n+                    compile_error!(\"unknown target_os\");\n+                }\n+            }\n         };\n \n         match (r < 0).then(super::os::errno) {\n@@ -56,31 +84,133 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n ///\n /// Returns true if this actually woke up such a thread,\n /// or false if no thread was waiting on this futex.\n+///\n+/// On some platforms, this always returns false.\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+pub fn futex_wake(futex: &AtomicU32) -> bool {\n+    let ptr = futex as *const AtomicU32;\n+    let op = libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG;\n+    unsafe { libc::syscall(libc::SYS_futex, ptr, op, 1) > 0 }\n+}\n+\n+/// Wake up all threads that are waiting on futex_wait on this futex.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+pub fn futex_wake_all(futex: &AtomicU32) {\n+    let ptr = futex as *const AtomicU32;\n+    let op = libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG;\n+    unsafe {\n+        libc::syscall(libc::SYS_futex, ptr, op, i32::MAX);\n+    }\n+}\n+\n+// FreeBSD doesn't tell us how many threads are woken up, so this always returns false.\n+#[cfg(target_os = \"freebsd\")]\n pub fn futex_wake(futex: &AtomicU32) -> bool {\n+    use crate::ptr::null_mut;\n     unsafe {\n-        libc::syscall(\n-            libc::SYS_futex,\n-            futex as *const AtomicU32,\n-            libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,\n+        libc::_umtx_op(\n+            futex as *const AtomicU32 as *mut _,\n+            libc::UMTX_OP_WAKE_PRIVATE,\n             1,\n-        ) > 0\n+            null_mut(),\n+            null_mut(),\n+        )\n+    };\n+    false\n+}\n+\n+#[cfg(target_os = \"freebsd\")]\n+pub fn futex_wake_all(futex: &AtomicU32) {\n+    use crate::ptr::null_mut;\n+    unsafe {\n+        libc::_umtx_op(\n+            futex as *const AtomicU32 as *mut _,\n+            libc::UMTX_OP_WAKE_PRIVATE,\n+            i32::MAX as libc::c_ulong,\n+            null_mut(),\n+            null_mut(),\n+        )\n+    };\n+}\n+\n+#[cfg(target_os = \"openbsd\")]\n+pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {\n+    use crate::convert::TryInto;\n+    use crate::ptr::{null, null_mut};\n+    let timespec = timeout.and_then(|d| {\n+        Some(libc::timespec {\n+            // Sleep forever if the timeout is longer than fits in a timespec.\n+            tv_sec: d.as_secs().try_into().ok()?,\n+            // This conversion never truncates, as subsec_nanos is always <1e9.\n+            tv_nsec: d.subsec_nanos() as _,\n+        })\n+    });\n+\n+    let r = unsafe {\n+        libc::futex(\n+            futex as *const AtomicU32 as *mut u32,\n+            libc::FUTEX_WAIT,\n+            expected as i32,\n+            timespec.as_ref().map_or(null(), |t| t as *const libc::timespec),\n+            null_mut(),\n+        )\n+    };\n+\n+    r == 0 || super::os::errno() != libc::ETIMEDOUT\n+}\n+\n+#[cfg(target_os = \"openbsd\")]\n+pub fn futex_wake(futex: &AtomicU32) -> bool {\n+    use crate::ptr::{null, null_mut};\n+    unsafe {\n+        libc::futex(futex as *const AtomicU32 as *mut u32, libc::FUTEX_WAKE, 1, null(), null_mut())\n+            > 0\n     }\n }\n \n-/// Wake up all threads that are waiting on futex_wait on this futex.\n-#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+#[cfg(target_os = \"openbsd\")]\n pub fn futex_wake_all(futex: &AtomicU32) {\n+    use crate::ptr::{null, null_mut};\n     unsafe {\n-        libc::syscall(\n-            libc::SYS_futex,\n-            futex as *const AtomicU32,\n-            libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,\n+        libc::futex(\n+            futex as *const AtomicU32 as *mut u32,\n+            libc::FUTEX_WAKE,\n             i32::MAX,\n+            null(),\n+            null_mut(),\n         );\n     }\n }\n \n+#[cfg(target_os = \"dragonfly\")]\n+pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {\n+    use crate::convert::TryFrom;\n+\n+    // A timeout of 0 means infinite.\n+    // We round smaller timeouts up to 1 millisecond.\n+    // Overflows are rounded up to an infinite timeout.\n+    let timeout_ms =\n+        timeout.and_then(|d| Some(i32::try_from(d.as_millis()).ok()?.max(1))).unwrap_or(0);\n+\n+    let r = unsafe {\n+        libc::umtx_sleep(futex as *const AtomicU32 as *const i32, expected as i32, timeout_ms)\n+    };\n+\n+    r == 0 || super::os::errno() != libc::ETIMEDOUT\n+}\n+\n+// DragonflyBSD doesn't tell us how many threads are woken up, so this always returns false.\n+#[cfg(target_os = \"dragonfly\")]\n+pub fn futex_wake(futex: &AtomicU32) -> bool {\n+    unsafe { libc::umtx_wakeup(futex as *const AtomicU32 as *const i32, 1) };\n+    false\n+}\n+\n+#[cfg(target_os = \"dragonfly\")]\n+pub fn futex_wake_all(futex: &AtomicU32) {\n+    unsafe { libc::umtx_wakeup(futex as *const AtomicU32 as *const i32, i32::MAX) };\n+}\n+\n #[cfg(target_os = \"emscripten\")]\n extern \"C\" {\n     fn emscripten_futex_wake(addr: *const AtomicU32, count: libc::c_int) -> libc::c_int;"}, {"sha": "57f6d58840db18eb3800fc216a49ce4e09beba36", "filename": "library/std/src/sys/unix/locks/futex_rwlock.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs?ref=7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "patch": "@@ -284,6 +284,10 @@ impl RwLock {\n     fn wake_writer(&self) -> bool {\n         self.writer_notify.fetch_add(1, Release);\n         futex_wake(&self.writer_notify)\n+        // Note that FreeBSD and DragonFlyBSD don't tell us whether they woke\n+        // up any threads or not, and always return `false` here. That still\n+        // results in correct behaviour: it just means readers get woken up as\n+        // well in case both readers and writers were waiting.\n     }\n \n     /// Spin for a while, but stop directly at the given condition."}, {"sha": "04c5c489fc9b94bb44fc97a40e265e88416bdb28", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "patch": "@@ -3,6 +3,9 @@ cfg_if::cfg_if! {\n         target_os = \"linux\",\n         target_os = \"android\",\n         all(target_os = \"emscripten\", target_feature = \"atomics\"),\n+        target_os = \"freebsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"dragonfly\",\n     ))] {\n         mod futex;\n         mod futex_rwlock;"}, {"sha": "cf37c01598bf30efb9c86600559654dc494b9f96", "filename": "library/std/src/sys/unix/thread_parker.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs?ref=7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "patch": "@@ -3,7 +3,10 @@\n #![cfg(not(any(\n     target_os = \"linux\",\n     target_os = \"android\",\n-    all(target_os = \"emscripten\", target_feature = \"atomics\")\n+    all(target_os = \"emscripten\", target_feature = \"atomics\"),\n+    target_os = \"freebsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"dragonfly\",\n )))]\n \n use crate::cell::UnsafeCell;"}, {"sha": "c789a388e05adf77e5992c424a1db6d25813616c", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "patch": "@@ -3,6 +3,9 @@ cfg_if::cfg_if! {\n         target_os = \"linux\",\n         target_os = \"android\",\n         all(target_arch = \"wasm32\", target_feature = \"atomics\"),\n+        target_os = \"freebsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"dragonfly\",\n     ))] {\n         mod futex;\n         pub use futex::Parker;"}]}