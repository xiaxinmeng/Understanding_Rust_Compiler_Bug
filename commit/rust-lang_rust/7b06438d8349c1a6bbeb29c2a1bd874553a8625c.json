{"sha": "7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMDY0MzhkODM0OWMxYTZiYmViMjljMmExYmQ4NzQ1NTNhODYyNWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-07T23:06:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-07T23:06:10Z"}, "message": "Auto merge of #38191 - oli-obk:clippy_is_sad, r=eddyb\n\nannotate stricter lifetimes on LateLintPass methods to allow them to forward to a Visitor\n\nthis unblocks clippy (rustup blocked after #37918)\n\nclippy has lots of lints that internally call an `intravisit::Visitor`, but the current lifetimes on `LateLintPass` methods conflicted with the required lifetimes (there was no connection between the HIR elements and the `TyCtxt`)\n\nr? @Manishearth", "tree": {"sha": "054b593a28773c1e2836fa954029d441b4b6b0e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/054b593a28773c1e2836fa954029d441b4b6b0e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "html_url": "https://github.com/rust-lang/rust/commit/7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "535b6d397f735ff72064462be38f733d2637cd6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/535b6d397f735ff72064462be38f733d2637cd6f", "html_url": "https://github.com/rust-lang/rust/commit/535b6d397f735ff72064462be38f733d2637cd6f"}, {"sha": "0f7a18b85d89737a3aab62982ac754ec25ada503", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f7a18b85d89737a3aab62982ac754ec25ada503", "html_url": "https://github.com/rust-lang/rust/commit/0f7a18b85d89737a3aab62982ac754ec25ada503"}], "stats": {"total": 782, "additions": 417, "deletions": 365}, "files": [{"sha": "6f5f548aa7802de93df4aa1d1068ec6d4f301113", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -129,8 +129,8 @@ impl<'a> CheckAttrVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor for CheckAttrVisitor<'a> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+impl<'a> Visitor<'a> for CheckAttrVisitor<'a> {\n+    fn visit_item(&mut self, item: &'a ast::Item) {\n         let target = Target::from_item(item);\n         for attr in &item.attrs {\n             self.check_attribute(attr, target);"}, {"sha": "74876eb59ee9a12eac05a524cff6393fc00ef507", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -143,14 +143,14 @@ impl<'a> LoweringContext<'a> {\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n \n-        impl<'lcx, 'interner> Visitor for ItemLowerer<'lcx, 'interner> {\n-            fn visit_item(&mut self, item: &Item) {\n+        impl<'lcx, 'interner> Visitor<'lcx> for ItemLowerer<'lcx, 'interner> {\n+            fn visit_item(&mut self, item: &'lcx Item) {\n                 let hir_item = self.lctx.lower_item(item);\n                 self.lctx.items.insert(item.id, hir_item);\n                 visit::walk_item(self, item);\n             }\n \n-            fn visit_impl_item(&mut self, item: &ImplItem) {\n+            fn visit_impl_item(&mut self, item: &'lcx ImplItem) {\n                 let id = self.lctx.lower_impl_item_ref(item).id;\n                 let hir_item = self.lctx.lower_impl_item(item);\n                 self.lctx.impl_items.insert(id, hir_item);"}, {"sha": "eb5a89f320e7b3d325e9741e5e4802766dd4e599", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -135,8 +135,8 @@ impl<'a> DefCollector<'a> {\n     }\n }\n \n-impl<'a> visit::Visitor for DefCollector<'a> {\n-    fn visit_item(&mut self, i: &Item) {\n+impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n+    fn visit_item(&mut self, i: &'a Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n         // Pick the def data. This need not be unique, but the more\n@@ -211,7 +211,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n                                   DefPathData::ValueNs(foreign_item.ident.name.as_str()));\n \n@@ -220,15 +220,15 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_generics(&mut self, generics: &Generics) {\n+    fn visit_generics(&mut self, generics: &'a Generics) {\n         for ty_param in generics.ty_params.iter() {\n             self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.ident.name.as_str()));\n         }\n \n         visit::walk_generics(self, generics);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n         let def_data = match ti.node {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n                 DefPathData::ValueNs(ti.ident.name.as_str()),\n@@ -246,7 +246,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_impl_item(&mut self, ii: &ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n                 DefPathData::ValueNs(ii.ident.name.as_str()),\n@@ -264,7 +264,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_pat(&mut self, pat: &Pat) {\n+    fn visit_pat(&mut self, pat: &'a Pat) {\n         let parent_def = self.parent_def;\n \n         match pat.node {\n@@ -280,7 +280,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         self.parent_def = parent_def;\n     }\n \n-    fn visit_expr(&mut self, expr: &Expr) {\n+    fn visit_expr(&mut self, expr: &'a Expr) {\n         let parent_def = self.parent_def;\n \n         match expr.node {\n@@ -297,7 +297,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         self.parent_def = parent_def;\n     }\n \n-    fn visit_ty(&mut self, ty: &Ty) {\n+    fn visit_ty(&mut self, ty: &'a Ty) {\n         match ty.node {\n             TyKind::Mac(..) => return self.visit_macro_invoc(ty.id, false),\n             TyKind::Array(_, ref length) => self.visit_ast_const_integer(length),\n@@ -309,15 +309,15 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         visit::walk_ty(self, ty);\n     }\n \n-    fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, def: &'a LifetimeDef) {\n         self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n+    fn visit_macro_def(&mut self, macro_def: &'a MacroDef) {\n         self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name.as_str()));\n     }\n \n-    fn visit_stmt(&mut self, stmt: &Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'a Stmt) {\n         match stmt.node {\n             StmtKind::Mac(..) => self.visit_macro_invoc(stmt.id, false),\n             _ => visit::walk_stmt(self, stmt),"}, {"sha": "02c1ece163497665e1a57207f0a2337a78284300", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -262,4 +262,4 @@ impl LintPass for HardwiredLints {\n     }\n }\n \n-impl LateLintPass for HardwiredLints {}\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HardwiredLints {}"}, {"sha": "3ff2abac277b580fc14e66990ff1338a6fc45d53", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -496,13 +496,13 @@ pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n     err\n }\n \n-pub trait LintContext: Sized {\n+pub trait LintContext<'tcx>: Sized {\n     fn sess(&self) -> &Session;\n     fn lints(&self) -> &LintStore;\n     fn mut_lints(&mut self) -> &mut LintStore;\n     fn level_stack(&mut self) -> &mut Vec<(LintId, LevelSource)>;\n-    fn enter_attrs(&mut self, attrs: &[ast::Attribute]);\n-    fn exit_attrs(&mut self, attrs: &[ast::Attribute]);\n+    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]);\n+    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]);\n \n     /// Get the level of `lint` at the current position of the lint\n     /// traversal.\n@@ -606,7 +606,7 @@ pub trait LintContext: Sized {\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n     fn with_lint_attrs<F>(&mut self,\n-                          attrs: &[ast::Attribute],\n+                          attrs: &'tcx [ast::Attribute],\n                           f: F)\n         where F: FnOnce(&mut Self),\n     {\n@@ -729,7 +729,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> LintContext for LateContext<'a, 'tcx> {\n+impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n     /// Get the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n         &self.tcx.sess\n@@ -747,18 +747,18 @@ impl<'a, 'tcx> LintContext for LateContext<'a, 'tcx> {\n         &mut self.level_stack\n     }\n \n-    fn enter_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n         debug!(\"late context: enter_attrs({:?})\", attrs);\n         run_lints!(self, enter_lint_attrs, late_passes, attrs);\n     }\n \n-    fn exit_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n         debug!(\"late context: exit_attrs({:?})\", attrs);\n         run_lints!(self, exit_lint_attrs, late_passes, attrs);\n     }\n }\n \n-impl<'a> LintContext for EarlyContext<'a> {\n+impl<'a> LintContext<'a> for EarlyContext<'a> {\n     /// Get the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n         &self.sess\n@@ -776,12 +776,12 @@ impl<'a> LintContext for EarlyContext<'a> {\n         &mut self.level_stack\n     }\n \n-    fn enter_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn enter_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n         debug!(\"early context: enter_attrs({:?})\", attrs);\n         run_lints!(self, enter_lint_attrs, early_passes, attrs);\n     }\n \n-    fn exit_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn exit_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n         debug!(\"early context: exit_attrs({:?})\", attrs);\n         run_lints!(self, exit_lint_attrs, early_passes, attrs);\n     }\n@@ -949,80 +949,80 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::walk_path(self, p);\n     }\n \n-    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+    fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n         check_lint_name_attribute(self, attr);\n         run_lints!(self, check_attribute, late_passes, attr);\n     }\n }\n \n-impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n-    fn visit_item(&mut self, it: &ast::Item) {\n+impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n+    fn visit_item(&mut self, it: &'a ast::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, early_passes, it);\n             ast_visit::walk_item(cx, it);\n             run_lints!(cx, check_item_post, early_passes, it);\n         })\n     }\n \n-    fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, it: &'a ast::ForeignItem) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_foreign_item, early_passes, it);\n             ast_visit::walk_foreign_item(cx, it);\n             run_lints!(cx, check_foreign_item_post, early_passes, it);\n         })\n     }\n \n-    fn visit_pat(&mut self, p: &ast::Pat) {\n+    fn visit_pat(&mut self, p: &'a ast::Pat) {\n         run_lints!(self, check_pat, early_passes, p);\n         ast_visit::walk_pat(self, p);\n     }\n \n-    fn visit_expr(&mut self, e: &ast::Expr) {\n+    fn visit_expr(&mut self, e: &'a ast::Expr) {\n         self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, early_passes, e);\n             ast_visit::walk_expr(cx, e);\n         })\n     }\n \n-    fn visit_stmt(&mut self, s: &ast::Stmt) {\n+    fn visit_stmt(&mut self, s: &'a ast::Stmt) {\n         run_lints!(self, check_stmt, early_passes, s);\n         ast_visit::walk_stmt(self, s);\n     }\n \n-    fn visit_fn(&mut self, fk: ast_visit::FnKind, decl: &ast::FnDecl,\n+    fn visit_fn(&mut self, fk: ast_visit::FnKind<'a>, decl: &'a ast::FnDecl,\n                 span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, early_passes, fk, decl, span, id);\n         ast_visit::walk_fn(self, fk, decl, span);\n         run_lints!(self, check_fn_post, early_passes, fk, decl, span, id);\n     }\n \n     fn visit_variant_data(&mut self,\n-                        s: &ast::VariantData,\n+                        s: &'a ast::VariantData,\n                         ident: ast::Ident,\n-                        g: &ast::Generics,\n+                        g: &'a ast::Generics,\n                         item_id: ast::NodeId,\n                         _: Span) {\n         run_lints!(self, check_struct_def, early_passes, s, ident, g, item_id);\n         ast_visit::walk_struct_def(self, s);\n         run_lints!(self, check_struct_def_post, early_passes, s, ident, g, item_id);\n     }\n \n-    fn visit_struct_field(&mut self, s: &ast::StructField) {\n+    fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n         self.with_lint_attrs(&s.attrs, |cx| {\n             run_lints!(cx, check_struct_field, early_passes, s);\n             ast_visit::walk_struct_field(cx, s);\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, item_id: ast::NodeId) {\n+    fn visit_variant(&mut self, v: &'a ast::Variant, g: &'a ast::Generics, item_id: ast::NodeId) {\n         self.with_lint_attrs(&v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, early_passes, v, g);\n             ast_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, early_passes, v, g);\n         })\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty) {\n+    fn visit_ty(&mut self, t: &'a ast::Ty) {\n         run_lints!(self, check_ty, early_passes, t);\n         ast_visit::walk_ty(self, t);\n     }\n@@ -1031,74 +1031,74 @@ impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n         run_lints!(self, check_ident, early_passes, sp, id);\n     }\n \n-    fn visit_mod(&mut self, m: &ast::Mod, s: Span, n: ast::NodeId) {\n+    fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, n: ast::NodeId) {\n         run_lints!(self, check_mod, early_passes, m, s, n);\n         ast_visit::walk_mod(self, m);\n         run_lints!(self, check_mod_post, early_passes, m, s, n);\n     }\n \n-    fn visit_local(&mut self, l: &ast::Local) {\n+    fn visit_local(&mut self, l: &'a ast::Local) {\n         self.with_lint_attrs(&l.attrs, |cx| {\n             run_lints!(cx, check_local, early_passes, l);\n             ast_visit::walk_local(cx, l);\n         })\n     }\n \n-    fn visit_block(&mut self, b: &ast::Block) {\n+    fn visit_block(&mut self, b: &'a ast::Block) {\n         run_lints!(self, check_block, early_passes, b);\n         ast_visit::walk_block(self, b);\n         run_lints!(self, check_block_post, early_passes, b);\n     }\n \n-    fn visit_arm(&mut self, a: &ast::Arm) {\n+    fn visit_arm(&mut self, a: &'a ast::Arm) {\n         run_lints!(self, check_arm, early_passes, a);\n         ast_visit::walk_arm(self, a);\n     }\n \n-    fn visit_expr_post(&mut self, e: &ast::Expr) {\n+    fn visit_expr_post(&mut self, e: &'a ast::Expr) {\n         run_lints!(self, check_expr_post, early_passes, e);\n     }\n \n-    fn visit_generics(&mut self, g: &ast::Generics) {\n+    fn visit_generics(&mut self, g: &'a ast::Generics) {\n         run_lints!(self, check_generics, early_passes, g);\n         ast_visit::walk_generics(self, g);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'a ast::TraitItem) {\n         self.with_lint_attrs(&trait_item.attrs, |cx| {\n             run_lints!(cx, check_trait_item, early_passes, trait_item);\n             ast_visit::walk_trait_item(cx, trait_item);\n             run_lints!(cx, check_trait_item_post, early_passes, trait_item);\n         });\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'a ast::ImplItem) {\n         self.with_lint_attrs(&impl_item.attrs, |cx| {\n             run_lints!(cx, check_impl_item, early_passes, impl_item);\n             ast_visit::walk_impl_item(cx, impl_item);\n             run_lints!(cx, check_impl_item_post, early_passes, impl_item);\n         });\n     }\n \n-    fn visit_lifetime(&mut self, lt: &ast::Lifetime) {\n+    fn visit_lifetime(&mut self, lt: &'a ast::Lifetime) {\n         run_lints!(self, check_lifetime, early_passes, lt);\n     }\n \n-    fn visit_lifetime_def(&mut self, lt: &ast::LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lt: &'a ast::LifetimeDef) {\n         run_lints!(self, check_lifetime_def, early_passes, lt);\n     }\n \n-    fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, p: &'a ast::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, early_passes, p, id);\n         ast_visit::walk_path(self, p);\n     }\n \n-    fn visit_path_list_item(&mut self, prefix: &ast::Path, item: &ast::PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &'a ast::Path, item: &'a ast::PathListItem) {\n         run_lints!(self, check_path_list_item, early_passes, item);\n         ast_visit::walk_path_list_item(self, prefix, item);\n     }\n \n-    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+    fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n         run_lints!(self, check_attribute, early_passes, attr);\n     }\n }"}, {"sha": "ccf53f01cd5323112bfe2b3e9d21bde83ef65e58", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 74, "deletions": 42, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -129,53 +129,85 @@ pub trait LintPass {\n //\n // FIXME: eliminate the duplication with `Visitor`. But this also\n // contains a few lint-specific methods with no equivalent in `Visitor`.\n-pub trait LateLintPass: LintPass {\n+pub trait LateLintPass<'a, 'tcx>: LintPass {\n     fn check_name(&mut self, _: &LateContext, _: Span, _: ast::Name) { }\n-    fn check_crate(&mut self, _: &LateContext, _: &hir::Crate) { }\n-    fn check_crate_post(&mut self, _: &LateContext, _: &hir::Crate) { }\n-    fn check_mod(&mut self, _: &LateContext, _: &hir::Mod, _: Span, _: ast::NodeId) { }\n-    fn check_mod_post(&mut self, _: &LateContext, _: &hir::Mod, _: Span, _: ast::NodeId) { }\n-    fn check_foreign_item(&mut self, _: &LateContext, _: &hir::ForeignItem) { }\n-    fn check_foreign_item_post(&mut self, _: &LateContext, _: &hir::ForeignItem) { }\n-    fn check_item(&mut self, _: &LateContext, _: &hir::Item) { }\n-    fn check_item_post(&mut self, _: &LateContext, _: &hir::Item) { }\n-    fn check_local(&mut self, _: &LateContext, _: &hir::Local) { }\n-    fn check_block(&mut self, _: &LateContext, _: &hir::Block) { }\n-    fn check_block_post(&mut self, _: &LateContext, _: &hir::Block) { }\n-    fn check_stmt(&mut self, _: &LateContext, _: &hir::Stmt) { }\n-    fn check_arm(&mut self, _: &LateContext, _: &hir::Arm) { }\n-    fn check_pat(&mut self, _: &LateContext, _: &hir::Pat) { }\n-    fn check_decl(&mut self, _: &LateContext, _: &hir::Decl) { }\n-    fn check_expr(&mut self, _: &LateContext, _: &hir::Expr) { }\n-    fn check_expr_post(&mut self, _: &LateContext, _: &hir::Expr) { }\n-    fn check_ty(&mut self, _: &LateContext, _: &hir::Ty) { }\n-    fn check_generics(&mut self, _: &LateContext, _: &hir::Generics) { }\n-    fn check_fn(&mut self, _: &LateContext,\n-        _: FnKind, _: &hir::FnDecl, _: &hir::Expr, _: Span, _: ast::NodeId) { }\n-    fn check_fn_post(&mut self, _: &LateContext,\n-        _: FnKind, _: &hir::FnDecl, _: &hir::Expr, _: Span, _: ast::NodeId) { }\n-    fn check_trait_item(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n-    fn check_trait_item_post(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n-    fn check_impl_item(&mut self, _: &LateContext, _: &hir::ImplItem) { }\n-    fn check_impl_item_post(&mut self, _: &LateContext, _: &hir::ImplItem) { }\n-    fn check_struct_def(&mut self, _: &LateContext,\n-        _: &hir::VariantData, _: ast::Name, _: &hir::Generics, _: ast::NodeId) { }\n-    fn check_struct_def_post(&mut self, _: &LateContext,\n-        _: &hir::VariantData, _: ast::Name, _: &hir::Generics, _: ast::NodeId) { }\n-    fn check_struct_field(&mut self, _: &LateContext, _: &hir::StructField) { }\n-    fn check_variant(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n-    fn check_variant_post(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n-    fn check_lifetime(&mut self, _: &LateContext, _: &hir::Lifetime) { }\n-    fn check_lifetime_def(&mut self, _: &LateContext, _: &hir::LifetimeDef) { }\n-    fn check_path(&mut self, _: &LateContext, _: &hir::Path, _: ast::NodeId) { }\n-    fn check_attribute(&mut self, _: &LateContext, _: &ast::Attribute) { }\n+    fn check_crate(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Crate) { }\n+    fn check_crate_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Crate) { }\n+    fn check_mod(&mut self,\n+                 _: &LateContext<'a, 'tcx>,\n+                 _: &'tcx hir::Mod,\n+                 _: Span,\n+                 _: ast::NodeId) { }\n+    fn check_mod_post(&mut self,\n+                      _: &LateContext<'a, 'tcx>,\n+                      _: &'tcx hir::Mod,\n+                      _: Span,\n+                      _: ast::NodeId) { }\n+    fn check_foreign_item(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::ForeignItem) { }\n+    fn check_foreign_item_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::ForeignItem) { }\n+    fn check_item(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Item) { }\n+    fn check_item_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Item) { }\n+    fn check_local(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Local) { }\n+    fn check_block(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Block) { }\n+    fn check_block_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Block) { }\n+    fn check_stmt(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Stmt) { }\n+    fn check_arm(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Arm) { }\n+    fn check_pat(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Pat) { }\n+    fn check_decl(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Decl) { }\n+    fn check_expr(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Expr) { }\n+    fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Expr) { }\n+    fn check_ty(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Ty) { }\n+    fn check_generics(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Generics) { }\n+    fn check_fn(&mut self,\n+                _: &LateContext<'a, 'tcx>,\n+                _: FnKind<'tcx>,\n+                _: &'tcx hir::FnDecl,\n+                _: &'tcx hir::Expr,\n+                _: Span,\n+                _: ast::NodeId) { }\n+    fn check_fn_post(&mut self,\n+                     _: &LateContext<'a, 'tcx>,\n+                     _: FnKind<'tcx>,\n+                     _: &'tcx hir::FnDecl,\n+                     _: &'tcx hir::Expr,\n+                     _: Span,\n+                     _: ast::NodeId) { }\n+    fn check_trait_item(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::TraitItem) { }\n+    fn check_trait_item_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::TraitItem) { }\n+    fn check_impl_item(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::ImplItem) { }\n+    fn check_impl_item_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::ImplItem) { }\n+    fn check_struct_def(&mut self,\n+                        _: &LateContext<'a, 'tcx>,\n+                        _: &'tcx hir::VariantData,\n+                        _: ast::Name,\n+                        _: &'tcx hir::Generics,\n+                        _: ast::NodeId) { }\n+    fn check_struct_def_post(&mut self,\n+                             _: &LateContext<'a, 'tcx>,\n+                             _: &'tcx hir::VariantData,\n+                             _: ast::Name,\n+                             _: &'tcx hir::Generics,\n+                             _: ast::NodeId) { }\n+    fn check_struct_field(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::StructField) { }\n+    fn check_variant(&mut self,\n+                     _: &LateContext<'a, 'tcx>,\n+                     _: &'tcx hir::Variant,\n+                     _: &'tcx hir::Generics) { }\n+    fn check_variant_post(&mut self,\n+                          _: &LateContext<'a, 'tcx>,\n+                          _: &'tcx hir::Variant,\n+                          _: &'tcx hir::Generics) { }\n+    fn check_lifetime(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Lifetime) { }\n+    fn check_lifetime_def(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::LifetimeDef) { }\n+    fn check_path(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Path, _: ast::NodeId) { }\n+    fn check_attribute(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx ast::Attribute) { }\n \n     /// Called when entering a syntax node that can have lint attributes such\n     /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n-    fn enter_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) { }\n+    fn enter_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx [ast::Attribute]) { }\n \n     /// Counterpart to `enter_lint_attrs`.\n-    fn exit_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) { }\n+    fn exit_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx [ast::Attribute]) { }\n }\n \n pub trait EarlyLintPass: LintPass {\n@@ -229,7 +261,7 @@ pub trait EarlyLintPass: LintPass {\n \n /// A lint pass boxed up as a trait object.\n pub type EarlyLintPassObject = Box<EarlyLintPass + 'static>;\n-pub type LateLintPassObject = Box<LateLintPass + 'static>;\n+pub type LateLintPassObject = Box<for<'a, 'tcx> LateLintPass<'a, 'tcx> + 'static>;\n \n /// Identifies a lint known to the compiler.\n #[derive(Clone, Copy, Debug)]"}, {"sha": "2aa74407afc5b087fe64c4804f1e0b279b4e3e1d", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -99,7 +99,7 @@ impl LintPass for NonCamelCaseTypes {\n     }\n }\n \n-impl LateLintPass for NonCamelCaseTypes {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCamelCaseTypes {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let extern_repr_count = it.attrs\n             .iter()\n@@ -226,7 +226,7 @@ impl LintPass for NonSnakeCase {\n     }\n }\n \n-impl LateLintPass for NonSnakeCase {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     fn check_crate(&mut self, cx: &LateContext, cr: &hir::Crate) {\n         let attr_crate_name = cr.attrs\n             .iter()\n@@ -348,7 +348,7 @@ impl LintPass for NonUpperCaseGlobals {\n     }\n }\n \n-impl LateLintPass for NonUpperCaseGlobals {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemStatic(..) => {"}, {"sha": "cd414846af4fb610f0f9dc56157218542daed3d6", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -69,7 +69,7 @@ impl LintPass for WhileTrue {\n     }\n }\n \n-impl LateLintPass for WhileTrue {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprWhile(ref cond, ..) = e.node {\n             if let hir::ExprLit(ref lit) = cond.node {\n@@ -93,7 +93,7 @@ declare_lint! {\n pub struct BoxPointers;\n \n impl BoxPointers {\n-    fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext<'a, 'tcx>, span: Span, ty: Ty<'tcx>) {\n+    fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext, span: Span, ty: Ty) {\n         for leaf_ty in ty.walk() {\n             if let ty::TyBox(_) = leaf_ty.sty {\n                 let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n@@ -109,7 +109,7 @@ impl LintPass for BoxPointers {\n     }\n }\n \n-impl LateLintPass for BoxPointers {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemFn(..) |\n@@ -158,7 +158,7 @@ impl LintPass for NonShorthandFieldPatterns {\n     }\n }\n \n-impl LateLintPass for NonShorthandFieldPatterns {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n         if let PatKind::Struct(_, ref field_pats, _) = pat.node {\n             for fieldpat in field_pats {\n@@ -194,7 +194,7 @@ impl LintPass for UnsafeCode {\n     }\n }\n \n-impl LateLintPass for UnsafeCode {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n@@ -220,7 +220,7 @@ impl LateLintPass for UnsafeCode {\n \n     fn check_fn(&mut self,\n                 cx: &LateContext,\n-                fk: FnKind,\n+                fk: FnKind<'tcx>,\n                 _: &hir::FnDecl,\n                 _: &hir::Expr,\n                 span: Span,\n@@ -327,7 +327,7 @@ impl LintPass for MissingDoc {\n     }\n }\n \n-impl LateLintPass for MissingDoc {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() ||\n                          attrs.iter().any(|attr| {\n@@ -340,7 +340,7 @@ impl LateLintPass for MissingDoc {\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n-    fn exit_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) {\n+    fn exit_lint_attrs(&mut self, _: &LateContext, _attrs: &[ast::Attribute]) {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n@@ -494,7 +494,7 @@ impl LintPass for MissingCopyImplementations {\n     }\n }\n \n-impl LateLintPass for MissingCopyImplementations {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if !cx.access_levels.is_reachable(item.id) {\n             return;\n@@ -563,7 +563,7 @@ impl LintPass for MissingDebugImplementations {\n     }\n }\n \n-impl LateLintPass for MissingDebugImplementations {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if !cx.access_levels.is_reachable(item.id) {\n             return;\n@@ -669,7 +669,7 @@ impl LintPass for UnconditionalRecursion {\n     }\n }\n \n-impl LateLintPass for UnconditionalRecursion {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n     fn check_fn(&mut self,\n                 cx: &LateContext,\n                 fn_kind: FnKind,\n@@ -932,7 +932,7 @@ impl LintPass for PluginAsLibrary {\n     }\n }\n \n-impl LateLintPass for PluginAsLibrary {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if cx.sess().plugin_registrar_fn.get().is_some() {\n             // We're compiling a plugin; it's fine to link other plugins.\n@@ -998,7 +998,7 @@ impl LintPass for InvalidNoMangleItems {\n     }\n }\n \n-impl LateLintPass for InvalidNoMangleItems {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemFn(.., ref generics, _) => {\n@@ -1052,7 +1052,7 @@ impl LintPass for MutableTransmutes {\n     }\n }\n \n-impl LateLintPass for MutableTransmutes {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n     fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n         use syntax::abi::Abi::RustIntrinsic;\n \n@@ -1120,7 +1120,7 @@ impl LintPass for UnstableFeatures {\n     }\n }\n \n-impl LateLintPass for UnstableFeatures {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n     fn check_attribute(&mut self, ctx: &LateContext, attr: &ast::Attribute) {\n         if attr.meta().check_name(\"feature\") {\n             if let Some(items) = attr.meta().meta_item_list() {\n@@ -1147,7 +1147,7 @@ impl LintPass for UnionsWithDropFields {\n     }\n }\n \n-impl LateLintPass for UnionsWithDropFields {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     fn check_item(&mut self, ctx: &LateContext, item: &hir::Item) {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);"}, {"sha": "5e9fdbfa07314b9d9a88fd520a082cd2f0c601ae", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -103,7 +103,7 @@ impl LintPass for TypeLimits {\n     }\n }\n \n-impl LateLintPass for TypeLimits {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n             hir::ExprUnary(hir::UnNeg, ref expr) => {\n@@ -706,7 +706,7 @@ impl LintPass for ImproperCTypes {\n     }\n }\n \n-impl LateLintPass for ImproperCTypes {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let mut vis = ImproperCTypesVisitor { cx: cx };\n         if let hir::ItemForeignMod(ref nmod) = it.node {\n@@ -734,7 +734,7 @@ impl LintPass for VariantSizeDifferences {\n     }\n }\n \n-impl LateLintPass for VariantSizeDifferences {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {"}, {"sha": "429bfb8e3d60667bc683ee829c17d5ce76fb7b59", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -77,7 +77,7 @@ impl LintPass for UnusedMut {\n     }\n }\n \n-impl LateLintPass for UnusedMut {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedMut {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms {\n@@ -128,7 +128,7 @@ impl LintPass for UnusedResults {\n     }\n }\n \n-impl LateLintPass for UnusedResults {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         let expr = match s.node {\n             hir::StmtSemi(ref expr, _) => &**expr,\n@@ -187,7 +187,7 @@ impl LintPass for UnusedUnsafe {\n     }\n }\n \n-impl LateLintPass for UnusedUnsafe {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedUnsafe {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n@@ -214,7 +214,7 @@ impl LintPass for PathStatements {\n     }\n }\n \n-impl LateLintPass for PathStatements {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         if let hir::StmtSemi(ref expr, _) = s.node {\n             if let hir::ExprPath(_) = expr.node {\n@@ -239,7 +239,7 @@ impl LintPass for UnusedAttributes {\n     }\n }\n \n-impl LateLintPass for UnusedAttributes {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n     fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n         debug!(\"checking attribute: {:?}\", attr);\n \n@@ -433,7 +433,7 @@ impl LintPass for UnusedAllocation {\n     }\n }\n \n-impl LateLintPass for UnusedAllocation {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n             hir::ExprBox(_) => {}"}, {"sha": "2d0f0864752ab5739f064b3bc237301369c80cd0", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -101,8 +101,8 @@ impl<'a> AstValidator<'a> {\n     }\n }\n \n-impl<'a> Visitor for AstValidator<'a> {\n-    fn visit_lifetime(&mut self, lt: &Lifetime) {\n+impl<'a> Visitor<'a> for AstValidator<'a> {\n+    fn visit_lifetime(&mut self, lt: &'a Lifetime) {\n         if lt.name == \"'_\" {\n             self.session.add_lint(lint::builtin::LIFETIME_UNDERSCORE,\n                                   lt.id,\n@@ -113,7 +113,7 @@ impl<'a> Visitor for AstValidator<'a> {\n         visit::walk_lifetime(self, lt)\n     }\n \n-    fn visit_expr(&mut self, expr: &Expr) {\n+    fn visit_expr(&mut self, expr: &'a Expr) {\n         match expr.node {\n             ExprKind::While(.., Some(ident)) |\n             ExprKind::Loop(_, Some(ident)) |\n@@ -129,7 +129,7 @@ impl<'a> Visitor for AstValidator<'a> {\n         visit::walk_expr(self, expr)\n     }\n \n-    fn visit_ty(&mut self, ty: &Ty) {\n+    fn visit_ty(&mut self, ty: &'a Ty) {\n         match ty.node {\n             TyKind::BareFn(ref bfty) => {\n                 self.check_decl_no_pat(&bfty.decl, |span, _| {\n@@ -153,7 +153,7 @@ impl<'a> Visitor for AstValidator<'a> {\n         visit::walk_ty(self, ty)\n     }\n \n-    fn visit_path(&mut self, path: &Path, id: NodeId) {\n+    fn visit_path(&mut self, path: &'a Path, id: NodeId) {\n         if path.global && path.segments.len() > 0 {\n             let ident = path.segments[0].identifier;\n             if token::Ident(ident).is_path_segment_keyword() {\n@@ -167,7 +167,7 @@ impl<'a> Visitor for AstValidator<'a> {\n         visit::walk_path(self, path)\n     }\n \n-    fn visit_item(&mut self, item: &Item) {\n+    fn visit_item(&mut self, item: &'a Item) {\n         match item.node {\n             ItemKind::Use(ref view_path) => {\n                 let path = view_path.node.path();\n@@ -249,7 +249,7 @@ impl<'a> Visitor for AstValidator<'a> {\n         visit::walk_item(self, item)\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &ForeignItem) {\n+    fn visit_foreign_item(&mut self, fi: &'a ForeignItem) {\n         match fi.node {\n             ForeignItemKind::Fn(ref decl, _) => {\n                 self.check_decl_no_pat(decl, |span, is_recent| {\n@@ -272,7 +272,7 @@ impl<'a> Visitor for AstValidator<'a> {\n         visit::walk_foreign_item(self, fi)\n     }\n \n-    fn visit_vis(&mut self, vis: &Visibility) {\n+    fn visit_vis(&mut self, vis: &'a Visibility) {\n         match *vis {\n             Visibility::Restricted { ref path, .. } => {\n                 if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {"}, {"sha": "f7e026866e2df04d0bbc7820f0124b78fbf3216a", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -48,7 +48,7 @@ pub fn print_hir_stats(krate: &hir::Crate) {\n     collector.print(\"HIR STATS\");\n }\n \n-pub fn print_ast_stats(krate: &ast::Crate, title: &str) {\n+pub fn print_ast_stats<'v>(krate: &'v ast::Crate, title: &str) {\n     let mut collector = StatCollector {\n         krate: None,\n         data: FxHashMap(),\n@@ -245,133 +245,133 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n }\n \n-impl<'v> ast_visit::Visitor for StatCollector<'v> {\n+impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n \n-    fn visit_mod(&mut self, m: &ast::Mod, _s: Span, _n: NodeId) {\n+    fn visit_mod(&mut self, m: &'v ast::Mod, _s: Span, _n: NodeId) {\n         self.record(\"Mod\", Id::None, m);\n         ast_visit::walk_mod(self, m)\n     }\n \n-    fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &'v ast::ForeignItem) {\n         self.record(\"ForeignItem\", Id::None, i);\n         ast_visit::walk_foreign_item(self, i)\n     }\n \n-    fn visit_item(&mut self, i: &ast::Item) {\n+    fn visit_item(&mut self, i: &'v ast::Item) {\n         self.record(\"Item\", Id::None, i);\n         ast_visit::walk_item(self, i)\n     }\n \n-    fn visit_local(&mut self, l: &ast::Local) {\n+    fn visit_local(&mut self, l: &'v ast::Local) {\n         self.record(\"Local\", Id::None, l);\n         ast_visit::walk_local(self, l)\n     }\n \n-    fn visit_block(&mut self, b: &ast::Block) {\n+    fn visit_block(&mut self, b: &'v ast::Block) {\n         self.record(\"Block\", Id::None, b);\n         ast_visit::walk_block(self, b)\n     }\n \n-    fn visit_stmt(&mut self, s: &ast::Stmt) {\n+    fn visit_stmt(&mut self, s: &'v ast::Stmt) {\n         self.record(\"Stmt\", Id::None, s);\n         ast_visit::walk_stmt(self, s)\n     }\n \n-    fn visit_arm(&mut self, a: &ast::Arm) {\n+    fn visit_arm(&mut self, a: &'v ast::Arm) {\n         self.record(\"Arm\", Id::None, a);\n         ast_visit::walk_arm(self, a)\n     }\n \n-    fn visit_pat(&mut self, p: &ast::Pat) {\n+    fn visit_pat(&mut self, p: &'v ast::Pat) {\n         self.record(\"Pat\", Id::None, p);\n         ast_visit::walk_pat(self, p)\n     }\n \n-    fn visit_expr(&mut self, ex: &ast::Expr) {\n+    fn visit_expr(&mut self, ex: &'v ast::Expr) {\n         self.record(\"Expr\", Id::None, ex);\n         ast_visit::walk_expr(self, ex)\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty) {\n+    fn visit_ty(&mut self, t: &'v ast::Ty) {\n         self.record(\"Ty\", Id::None, t);\n         ast_visit::walk_ty(self, t)\n     }\n \n     fn visit_fn(&mut self,\n-                fk: ast_visit::FnKind,\n-                fd: &ast::FnDecl,\n+                fk: ast_visit::FnKind<'v>,\n+                fd: &'v ast::FnDecl,\n                 s: Span,\n                 _: NodeId) {\n         self.record(\"FnDecl\", Id::None, fd);\n         ast_visit::walk_fn(self, fk, fd, s)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n         self.record(\"TraitItem\", Id::None, ti);\n         ast_visit::walk_trait_item(self, ti)\n     }\n \n-    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n         self.record(\"ImplItem\", Id::None, ii);\n         ast_visit::walk_impl_item(self, ii)\n     }\n \n-    fn visit_ty_param_bound(&mut self, bounds: &ast::TyParamBound) {\n+    fn visit_ty_param_bound(&mut self, bounds: &'v ast::TyParamBound) {\n         self.record(\"TyParamBound\", Id::None, bounds);\n         ast_visit::walk_ty_param_bound(self, bounds)\n     }\n \n-    fn visit_struct_field(&mut self, s: &ast::StructField) {\n+    fn visit_struct_field(&mut self, s: &'v ast::StructField) {\n         self.record(\"StructField\", Id::None, s);\n         ast_visit::walk_struct_field(self, s)\n     }\n \n     fn visit_variant(&mut self,\n-                     v: &ast::Variant,\n-                     g: &ast::Generics,\n+                     v: &'v ast::Variant,\n+                     g: &'v ast::Generics,\n                      item_id: NodeId) {\n         self.record(\"Variant\", Id::None, v);\n         ast_visit::walk_variant(self, v, g, item_id)\n     }\n \n-    fn visit_lifetime(&mut self, lifetime: &ast::Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &'v ast::Lifetime) {\n         self.record(\"Lifetime\", Id::None, lifetime);\n         ast_visit::walk_lifetime(self, lifetime)\n     }\n \n-    fn visit_lifetime_def(&mut self, lifetime: &ast::LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lifetime: &'v ast::LifetimeDef) {\n         self.record(\"LifetimeDef\", Id::None, lifetime);\n         ast_visit::walk_lifetime_def(self, lifetime)\n     }\n \n-    fn visit_mac(&mut self, mac: &ast::Mac) {\n+    fn visit_mac(&mut self, mac: &'v ast::Mac) {\n         self.record(\"Mac\", Id::None, mac);\n     }\n \n     fn visit_path_list_item(&mut self,\n-                            prefix: &ast::Path,\n-                            item: &ast::PathListItem) {\n+                            prefix: &'v ast::Path,\n+                            item: &'v ast::PathListItem) {\n         self.record(\"PathListItem\", Id::None, item);\n         ast_visit::walk_path_list_item(self, prefix, item)\n     }\n \n     fn visit_path_segment(&mut self,\n                           path_span: Span,\n-                          path_segment: &ast::PathSegment) {\n+                          path_segment: &'v ast::PathSegment) {\n         self.record(\"PathSegment\", Id::None, path_segment);\n         ast_visit::walk_path_segment(self, path_span, path_segment)\n     }\n \n-    fn visit_assoc_type_binding(&mut self, type_binding: &ast::TypeBinding) {\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'v ast::TypeBinding) {\n         self.record(\"TypeBinding\", Id::None, type_binding);\n         ast_visit::walk_assoc_type_binding(self, type_binding)\n     }\n \n-    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+    fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n         self.record(\"Attribute\", Id::None, attr);\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &ast::MacroDef) {\n+    fn visit_macro_def(&mut self, macro_def: &'v ast::MacroDef) {\n         self.record(\"MacroDef\", Id::None, macro_def);\n         ast_visit::walk_macro_def(self, macro_def)\n     }"}, {"sha": "4dbf57a99bcbe1395e060ecd59eb48bd863b8078", "filename": "src/librustc_passes/no_asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_passes%2Fno_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_passes%2Fno_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fno_asm.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -31,8 +31,8 @@ struct CheckNoAsm<'a> {\n     sess: &'a Session,\n }\n \n-impl<'a> Visitor for CheckNoAsm<'a> {\n-    fn visit_expr(&mut self, e: &ast::Expr) {\n+impl<'a> Visitor<'a> for CheckNoAsm<'a> {\n+    fn visit_expr(&mut self, e: &'a ast::Expr) {\n         match e.node {\n             ast::ExprKind::InlineAsm(_) => {\n                 span_err!(self.sess,"}, {"sha": "25a37931ba31fd05cb870ca2aae423ab1221c045", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -678,7 +678,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n macro_rules! method {\n     ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n-        fn $visit(&mut self, node: &$ty) {\n+        fn $visit(&mut self, node: &'a $ty) {\n             if let $invoc(..) = node.node {\n                 self.visit_invoc(node.id);\n             } else {\n@@ -688,13 +688,13 @@ macro_rules! method {\n     }\n }\n \n-impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n+impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n     method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item);\n     method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr);\n     method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat);\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n \n-    fn visit_item(&mut self, item: &Item) {\n+    fn visit_item(&mut self, item: &'a Item) {\n         let macro_use = match item.node {\n             ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => return, // Scope placeholder\n             ItemKind::Mac(..) => {\n@@ -713,28 +713,28 @@ impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n         }\n     }\n \n-    fn visit_stmt(&mut self, stmt: &ast::Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'a ast::Stmt) {\n         if let ast::StmtKind::Mac(..) = stmt.node {\n             self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(stmt.id));\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         self.resolver.build_reduced_graph_for_foreign_item(foreign_item, self.expansion);\n         visit::walk_foreign_item(self, foreign_item);\n     }\n \n-    fn visit_block(&mut self, block: &Block) {\n+    fn visit_block(&mut self, block: &'a Block) {\n         let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n         self.resolver.build_reduced_graph_for_block(block);\n         visit::walk_block(self, block);\n         self.resolver.current_module = parent;\n         self.legacy_scope = legacy_scope;\n     }\n \n-    fn visit_trait_item(&mut self, item: &TraitItem) {\n+    fn visit_trait_item(&mut self, item: &'a TraitItem) {\n         let parent = self.resolver.current_module;\n         let def_id = parent.def_id().unwrap();\n "}, {"sha": "41391c65a128d7396196ce9aaf2dfd2e12e45466", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -74,8 +74,8 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b> Visitor for UnusedImportCheckVisitor<'a, 'b> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n+    fn visit_item(&mut self, item: &'a ast::Item) {\n         visit::walk_item(self, item);\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span"}, {"sha": "f7aaf2475f65ef982a230b5f9d761084929aa2ec", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -557,35 +557,37 @@ impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n     }\n }\n \n-impl<'a> Visitor for Resolver<'a> {\n-    fn visit_item(&mut self, item: &Item) {\n+impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n+    fn visit_item(&mut self, item: &'tcx Item) {\n         self.resolve_item(item);\n     }\n-    fn visit_arm(&mut self, arm: &Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx Arm) {\n         self.resolve_arm(arm);\n     }\n-    fn visit_block(&mut self, block: &Block) {\n+    fn visit_block(&mut self, block: &'tcx Block) {\n         self.resolve_block(block);\n     }\n-    fn visit_expr(&mut self, expr: &Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         self.resolve_expr(expr, None);\n     }\n-    fn visit_local(&mut self, local: &Local) {\n+    fn visit_local(&mut self, local: &'tcx Local) {\n         self.resolve_local(local);\n     }\n-    fn visit_ty(&mut self, ty: &Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx Ty) {\n         self.resolve_type(ty);\n     }\n-    fn visit_poly_trait_ref(&mut self, tref: &ast::PolyTraitRef, m: &ast::TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self,\n+                            tref: &'tcx ast::PolyTraitRef,\n+                            m: &'tcx ast::TraitBoundModifier) {\n         let ast::Path { ref segments, span, global } = tref.trait_ref.path;\n         let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n         let def = self.resolve_trait_reference(&path, global, None, span);\n         self.record_def(tref.trait_ref.ref_id, def);\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_variant(&mut self,\n-                     variant: &ast::Variant,\n-                     generics: &Generics,\n+                     variant: &'tcx ast::Variant,\n+                     generics: &'tcx Generics,\n                      item_id: ast::NodeId) {\n         if let Some(ref dis_expr) = variant.node.disr_expr {\n             // resolve the discriminator expr as a constant\n@@ -601,7 +603,7 @@ impl<'a> Visitor for Resolver<'a> {\n                                 item_id,\n                                 variant.span);\n     }\n-    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &'tcx ForeignItem) {\n         let type_parameters = match foreign_item.node {\n             ForeignItemKind::Fn(_, ref generics) => {\n                 HasTypeParameters(generics, ItemRibKind)\n@@ -613,8 +615,8 @@ impl<'a> Visitor for Resolver<'a> {\n         });\n     }\n     fn visit_fn(&mut self,\n-                function_kind: FnKind,\n-                declaration: &FnDecl,\n+                function_kind: FnKind<'tcx>,\n+                declaration: &'tcx FnDecl,\n                 _: Span,\n                 node_id: NodeId) {\n         let rib_kind = match function_kind {"}, {"sha": "ec368c6bc1fa287eb97c2077f4b17c6689eea880", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 52, "deletions": 49, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -345,7 +345,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n     }\n \n-    fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str) {\n+    fn process_formals(&mut self, formals: &'l [ast::Arg], qualname: &str) {\n         for arg in formals {\n             self.visit_pat(&arg.pat);\n             let mut collector = PathCollector::new();\n@@ -379,12 +379,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n \n     fn process_method(&mut self,\n-                      sig: &ast::MethodSig,\n-                      body: Option<&ast::Block>,\n+                      sig: &'l ast::MethodSig,\n+                      body: Option<&'l ast::Block>,\n                       id: ast::NodeId,\n                       name: ast::Name,\n                       vis: Visibility,\n-                      attrs: &[Attribute],\n+                      attrs: &'l [Attribute],\n                       span: Span) {\n         debug!(\"process_method: {}:{}\", id, name);\n \n@@ -465,7 +465,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n     }\n \n-    fn process_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n+    fn process_trait_ref(&mut self, trait_ref: &'l ast::TraitRef) {\n         let trait_ref_data = self.save_ctxt.get_trait_ref_data(trait_ref, self.cur_scope);\n         if let Some(trait_ref_data) = trait_ref_data {\n             if !self.span.filter_generated(Some(trait_ref_data.span), trait_ref.path.span) {\n@@ -488,7 +488,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n     // Dump generic params bindings, then visit_generics\n     fn process_generic_params(&mut self,\n-                              generics: &ast::Generics,\n+                              generics: &'l ast::Generics,\n                               full_span: Span,\n                               prefix: &str,\n                               id: NodeId) {\n@@ -522,10 +522,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n \n     fn process_fn(&mut self,\n-                  item: &ast::Item,\n-                  decl: &ast::FnDecl,\n-                  ty_params: &ast::Generics,\n-                  body: &ast::Block) {\n+                  item: &'l ast::Item,\n+                  decl: &'l ast::FnDecl,\n+                  ty_params: &'l ast::Generics,\n+                  body: &'l ast::Block) {\n         if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(fn_data, FunctionData, item.span);\n             if !self.span.filter_generated(Some(fn_data.span), item.span) {\n@@ -547,7 +547,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         self.nest(item.id, |v| v.visit_block(&body));\n     }\n \n-    fn process_static_or_const_item(&mut self, item: &ast::Item, typ: &ast::Ty, expr: &ast::Expr) {\n+    fn process_static_or_const_item(&mut self,\n+                                    item: &'l ast::Item,\n+                                    typ: &'l ast::Ty,\n+                                    expr: &'l ast::Expr) {\n         if let Some(var_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(var_data, VariableData, item.span);\n             if !self.span.filter_generated(Some(var_data.span), item.span) {\n@@ -562,11 +565,11 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                            id: ast::NodeId,\n                            name: ast::Name,\n                            span: Span,\n-                           typ: &ast::Ty,\n-                           expr: &ast::Expr,\n+                           typ: &'l ast::Ty,\n+                           expr: &'l ast::Expr,\n                            parent_id: DefId,\n                            vis: Visibility,\n-                           attrs: &[Attribute]) {\n+                           attrs: &'l [Attribute]) {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n \n         let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n@@ -594,9 +597,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n     // FIXME tuple structs should generate tuple-specific data.\n     fn process_struct(&mut self,\n-                      item: &ast::Item,\n-                      def: &ast::VariantData,\n-                      ty_params: &ast::Generics) {\n+                      item: &'l ast::Item,\n+                      def: &'l ast::VariantData,\n+                      ty_params: &'l ast::Generics) {\n         let name = item.ident.to_string();\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n@@ -641,9 +644,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n \n     fn process_enum(&mut self,\n-                    item: &ast::Item,\n-                    enum_definition: &ast::EnumDef,\n-                    ty_params: &ast::Generics) {\n+                    item: &'l ast::Item,\n+                    enum_definition: &'l ast::EnumDef,\n+                    ty_params: &'l ast::Generics) {\n         let enum_data = self.save_ctxt.get_item_data(item);\n         let enum_data = match enum_data {\n             None => return,\n@@ -721,11 +724,11 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n \n     fn process_impl(&mut self,\n-                    item: &ast::Item,\n-                    type_parameters: &ast::Generics,\n-                    trait_ref: &Option<ast::TraitRef>,\n-                    typ: &ast::Ty,\n-                    impl_items: &[ast::ImplItem]) {\n+                    item: &'l ast::Item,\n+                    type_parameters: &'l ast::Generics,\n+                    trait_ref: &'l Option<ast::TraitRef>,\n+                    typ: &'l ast::Ty,\n+                    impl_items: &'l [ast::ImplItem]) {\n         let mut has_self_ref = false;\n         if let Some(impl_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(impl_data, ImplData, item.span);\n@@ -764,10 +767,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n \n     fn process_trait(&mut self,\n-                     item: &ast::Item,\n-                     generics: &ast::Generics,\n-                     trait_refs: &ast::TyParamBounds,\n-                     methods: &[ast::TraitItem]) {\n+                     item: &'l ast::Item,\n+                     generics: &'l ast::Generics,\n+                     trait_refs: &'l ast::TyParamBounds,\n+                     methods: &'l [ast::TraitItem]) {\n         let name = item.ident.to_string();\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n         let mut val = name.clone();\n@@ -938,11 +941,11 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n \n     fn process_struct_lit(&mut self,\n-                          ex: &ast::Expr,\n-                          path: &ast::Path,\n-                          fields: &Vec<ast::Field>,\n-                          variant: &ty::VariantDef,\n-                          base: &Option<P<ast::Expr>>) {\n+                          ex: &'l ast::Expr,\n+                          path: &'l ast::Path,\n+                          fields: &'l [ast::Field],\n+                          variant: &'l ty::VariantDef,\n+                          base: &'l Option<P<ast::Expr>>) {\n         self.write_sub_paths_truncated(path, false);\n \n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n@@ -969,7 +972,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         walk_list!(self, visit_expr, base);\n     }\n \n-    fn process_method_call(&mut self, ex: &ast::Expr, args: &Vec<P<ast::Expr>>) {\n+    fn process_method_call(&mut self, ex: &'l ast::Expr, args: &'l [P<ast::Expr>]) {\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(mcd, MethodCallData, ex.span);\n             if !self.span.filter_generated(Some(mcd.span), ex.span) {\n@@ -981,7 +984,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         walk_list!(self, visit_expr, args);\n     }\n \n-    fn process_pat(&mut self, p: &ast::Pat) {\n+    fn process_pat(&mut self, p: &'l ast::Pat) {\n         match p.node {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n@@ -1014,7 +1017,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n \n \n-    fn process_var_decl(&mut self, p: &ast::Pat, value: String) {\n+    fn process_var_decl(&mut self, p: &'l ast::Pat, value: String) {\n         // The local could declare multiple new vars, we must walk the\n         // pattern and collect them all.\n         let mut collector = PathCollector::new();\n@@ -1105,7 +1108,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n     }\n \n-    fn process_trait_item(&mut self, trait_item: &ast::TraitItem, trait_id: DefId) {\n+    fn process_trait_item(&mut self, trait_item: &'l ast::TraitItem, trait_id: DefId) {\n         self.process_macro_use(trait_item.span, trait_item.id);\n         match trait_item.node {\n             ast::TraitItemKind::Const(ref ty, Some(ref expr)) => {\n@@ -1133,7 +1136,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n     }\n \n-    fn process_impl_item(&mut self, impl_item: &ast::ImplItem, impl_id: DefId) {\n+    fn process_impl_item(&mut self, impl_item: &'l ast::ImplItem, impl_id: DefId) {\n         self.process_macro_use(impl_item.span, impl_item.id);\n         match impl_item.node {\n             ast::ImplItemKind::Const(ref ty, ref expr) => {\n@@ -1161,8 +1164,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n }\n \n-impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll, D> {\n+    fn visit_item(&mut self, item: &'l ast::Item) {\n         use syntax::ast::ItemKind::*;\n         self.process_macro_use(item.span, item.id);\n         match item.node {\n@@ -1306,7 +1309,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n         }\n     }\n \n-    fn visit_generics(&mut self, generics: &ast::Generics) {\n+    fn visit_generics(&mut self, generics: &'l ast::Generics) {\n         for param in generics.ty_params.iter() {\n             for bound in param.bounds.iter() {\n                 if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n@@ -1319,7 +1322,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n         }\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty) {\n+    fn visit_ty(&mut self, t: &'l ast::Ty) {\n         self.process_macro_use(t.span, t.id);\n         match t.node {\n             ast::TyKind::Path(_, ref path) => {\n@@ -1343,7 +1346,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n         }\n     }\n \n-    fn visit_expr(&mut self, ex: &ast::Expr) {\n+    fn visit_expr(&mut self, ex: &'l ast::Expr) {\n         self.process_macro_use(ex.span, ex.id);\n         match ex.node {\n             ast::ExprKind::Call(ref _f, ref _args) => {\n@@ -1451,17 +1454,17 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n         }\n     }\n \n-    fn visit_mac(&mut self, mac: &ast::Mac) {\n+    fn visit_mac(&mut self, mac: &'l ast::Mac) {\n         // These shouldn't exist in the AST at this point, log a span bug.\n         span_bug!(mac.span, \"macro invocation should have been expanded out of AST\");\n     }\n \n-    fn visit_pat(&mut self, p: &ast::Pat) {\n+    fn visit_pat(&mut self, p: &'l ast::Pat) {\n         self.process_macro_use(p.span, p.id);\n         self.process_pat(p);\n     }\n \n-    fn visit_arm(&mut self, arm: &ast::Arm) {\n+    fn visit_arm(&mut self, arm: &'l ast::Arm) {\n         let mut collector = PathCollector::new();\n         for pattern in &arm.pats {\n             // collect paths from the arm's patterns\n@@ -1524,12 +1527,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n         self.visit_expr(&arm.body);\n     }\n \n-    fn visit_stmt(&mut self, s: &ast::Stmt) {\n+    fn visit_stmt(&mut self, s: &'l ast::Stmt) {\n         self.process_macro_use(s.span, s.id);\n         visit::walk_stmt(self, s)\n     }\n \n-    fn visit_local(&mut self, l: &ast::Local) {\n+    fn visit_local(&mut self, l: &'l ast::Local) {\n         self.process_macro_use(l.span, l.id);\n         let value = l.init.as_ref().map(|i| self.span.snippet(i.span)).unwrap_or(String::new());\n         self.process_var_decl(&l.pat, value);"}, {"sha": "b5cf8141da29c2697c7f3b455ca54b580130e64e", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -741,7 +741,7 @@ impl PathCollector {\n     }\n }\n \n-impl Visitor for PathCollector {\n+impl<'a> Visitor<'a> for PathCollector {\n     fn visit_pat(&mut self, p: &ast::Pat) {\n         match p.node {\n             PatKind::Struct(ref path, ..) => {"}, {"sha": "e3979926680a1f1af227477cf8ac323edba878ed", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -85,7 +85,7 @@ macro_rules! expansions {\n                 }\n             }\n \n-            pub fn visit_with<V: Visitor>(&self, visitor: &mut V) {\n+            pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n                 match *self {\n                     Expansion::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n                     Expansion::OptExpr(None) => {}"}, {"sha": "77c53542dcbec3233b3480e812d52feb91ce967b", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -1007,7 +1007,7 @@ fn starts_with_digit(s: &str) -> bool {\n     s.as_bytes().first().cloned().map_or(false, |b| b >= b'0' && b <= b'9')\n }\n \n-impl<'a> Visitor for PostExpansionVisitor<'a> {\n+impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         if !self.context.cm.span_allows_unstable(attr.span) {\n             // check for gated attributes\n@@ -1028,7 +1028,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         }\n     }\n \n-    fn visit_item(&mut self, i: &ast::Item) {\n+    fn visit_item(&mut self, i: &'a ast::Item) {\n         match i.node {\n             ast::ItemKind::ExternCrate(_) => {\n                 if attr::contains_name(&i.attrs[..], \"macro_reexport\") {\n@@ -1121,7 +1121,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         visit::walk_item(self, i);\n     }\n \n-    fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n         let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs, \"link_name\") {\n             Some(val) => val.as_str().starts_with(\"llvm.\"),\n             _ => false\n@@ -1134,7 +1134,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         visit::walk_foreign_item(self, i)\n     }\n \n-    fn visit_ty(&mut self, ty: &ast::Ty) {\n+    fn visit_ty(&mut self, ty: &'a ast::Ty) {\n         match ty.node {\n             ast::TyKind::BareFn(ref bare_fn_ty) => {\n                 self.check_abi(bare_fn_ty.abi, ty.span);\n@@ -1152,7 +1152,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         visit::walk_ty(self, ty)\n     }\n \n-    fn visit_fn_ret_ty(&mut self, ret_ty: &ast::FunctionRetTy) {\n+    fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FunctionRetTy) {\n         if let ast::FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n             match output_ty.node {\n                 ast::TyKind::Never => return,\n@@ -1162,7 +1162,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         }\n     }\n \n-    fn visit_expr(&mut self, e: &ast::Expr) {\n+    fn visit_expr(&mut self, e: &'a ast::Expr) {\n         match e.node {\n             ast::ExprKind::Box(_) => {\n                 gate_feature_post!(&self, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n@@ -1201,7 +1201,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         visit::walk_expr(self, e);\n     }\n \n-    fn visit_pat(&mut self, pattern: &ast::Pat) {\n+    fn visit_pat(&mut self, pattern: &'a ast::Pat) {\n         match pattern.node {\n             PatKind::Slice(_, Some(_), ref last) if !last.is_empty() => {\n                 gate_feature_post!(&self, advanced_slice_patterns,\n@@ -1235,8 +1235,8 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_fn(&mut self,\n-                fn_kind: FnKind,\n-                fn_decl: &ast::FnDecl,\n+                fn_kind: FnKind<'a>,\n+                fn_decl: &'a ast::FnDecl,\n                 span: Span,\n                 _node_id: NodeId) {\n         // check for const fn declarations\n@@ -1262,7 +1262,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         visit::walk_fn(self, fn_kind, fn_decl, span);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'a ast::TraitItem) {\n         match ti.node {\n             ast::TraitItemKind::Const(..) => {\n                 gate_feature_post!(&self, associated_consts,\n@@ -1286,7 +1286,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         visit::walk_trait_item(self, ti);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'a ast::ImplItem) {\n         if ii.defaultness == ast::Defaultness::Default {\n             gate_feature_post!(&self, specialization,\n                               ii.span,\n@@ -1309,7 +1309,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         visit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_vis(&mut self, vis: &ast::Visibility) {\n+    fn visit_vis(&mut self, vis: &'a ast::Visibility) {\n         let span = match *vis {\n             ast::Visibility::Crate(span) => span,\n             ast::Visibility::Restricted { ref path, .. } => path.span,\n@@ -1320,7 +1320,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         visit::walk_vis(self, vis)\n     }\n \n-    fn visit_generics(&mut self, g: &ast::Generics) {\n+    fn visit_generics(&mut self, g: &'a ast::Generics) {\n         for t in &g.ty_params {\n             if !t.attrs.is_empty() {\n                 gate_feature_post!(&self, generic_param_attrs, t.attrs[0].span,\n@@ -1330,7 +1330,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         visit::walk_generics(self, g)\n     }\n \n-    fn visit_lifetime_def(&mut self, lifetime_def: &ast::LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lifetime_def: &'a ast::LifetimeDef) {\n         if !lifetime_def.attrs.is_empty() {\n             gate_feature_post!(&self, generic_param_attrs, lifetime_def.attrs[0].span,\n                                \"attributes on lifetime bindings are experimental\");"}, {"sha": "e5b66f889583add747b692fe04e74297cad04930", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -940,8 +940,8 @@ mod tests {\n         struct PatIdentVisitor {\n             spans: Vec<Span>\n         }\n-        impl ::visit::Visitor for PatIdentVisitor {\n-            fn visit_pat(&mut self, p: &ast::Pat) {\n+        impl<'a> ::visit::Visitor<'a> for PatIdentVisitor {\n+            fn visit_pat(&mut self, p: &'a ast::Pat) {\n                 match p.node {\n                     PatKind::Ident(_ , ref spannedident, _) => {\n                         self.spans.push(spannedident.span.clone());"}, {"sha": "263a4f13c1b290b69d4ba0746b8a60493147174c", "filename": "src/libsyntax/show_span.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fshow_span.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -44,29 +44,29 @@ struct ShowSpanVisitor<'a> {\n     mode: Mode,\n }\n \n-impl<'a> Visitor for ShowSpanVisitor<'a> {\n-    fn visit_expr(&mut self, e: &ast::Expr) {\n+impl<'a> Visitor<'a> for ShowSpanVisitor<'a> {\n+    fn visit_expr(&mut self, e: &'a ast::Expr) {\n         if let Mode::Expression = self.mode {\n             self.span_diagnostic.span_warn(e.span, \"expression\");\n         }\n         visit::walk_expr(self, e);\n     }\n \n-    fn visit_pat(&mut self, p: &ast::Pat) {\n+    fn visit_pat(&mut self, p: &'a ast::Pat) {\n         if let Mode::Pattern = self.mode {\n             self.span_diagnostic.span_warn(p.span, \"pattern\");\n         }\n         visit::walk_pat(self, p);\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty) {\n+    fn visit_ty(&mut self, t: &'a ast::Ty) {\n         if let Mode::Type = self.mode {\n             self.span_diagnostic.span_warn(t.span, \"type\");\n         }\n         visit::walk_ty(self, t);\n     }\n \n-    fn visit_mac(&mut self, mac: &ast::Mac) {\n+    fn visit_mac(&mut self, mac: &'a ast::Mac) {\n         visit::walk_mac(self, mac);\n     }\n }"}, {"sha": "b90802d1e7eb8f908b5a5de1ac6957789712c7db", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -26,7 +26,7 @@ impl NodeCounter {\n     }\n }\n \n-impl Visitor for NodeCounter {\n+impl<'ast> Visitor<'ast> for NodeCounter {\n     fn visit_ident(&mut self, span: Span, ident: Ident) {\n         self.count += 1;\n         walk_ident(self, span, ident);"}, {"sha": "3e0353d532d88fb558cfb2cdd461bfc8ec6e89f5", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 94, "deletions": 81, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -49,86 +49,86 @@ pub enum FnKind<'a> {\n /// explicitly, you need to override each method.  (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n-pub trait Visitor: Sized {\n+pub trait Visitor<'ast>: Sized {\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n     fn visit_ident(&mut self, span: Span, ident: Ident) {\n         walk_ident(self, span, ident);\n     }\n-    fn visit_mod(&mut self, m: &Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n-    fn visit_foreign_item(&mut self, i: &ForeignItem) { walk_foreign_item(self, i) }\n-    fn visit_item(&mut self, i: &Item) { walk_item(self, i) }\n-    fn visit_local(&mut self, l: &Local) { walk_local(self, l) }\n-    fn visit_block(&mut self, b: &Block) { walk_block(self, b) }\n-    fn visit_stmt(&mut self, s: &Stmt) { walk_stmt(self, s) }\n-    fn visit_arm(&mut self, a: &Arm) { walk_arm(self, a) }\n-    fn visit_pat(&mut self, p: &Pat) { walk_pat(self, p) }\n-    fn visit_expr(&mut self, ex: &Expr) { walk_expr(self, ex) }\n-    fn visit_expr_post(&mut self, _ex: &Expr) { }\n-    fn visit_ty(&mut self, t: &Ty) { walk_ty(self, t) }\n-    fn visit_generics(&mut self, g: &Generics) { walk_generics(self, g) }\n-    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, s: Span, _: NodeId) {\n+    fn visit_mod(&mut self, m: &'ast Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n+    fn visit_foreign_item(&mut self, i: &'ast ForeignItem) { walk_foreign_item(self, i) }\n+    fn visit_item(&mut self, i: &'ast Item) { walk_item(self, i) }\n+    fn visit_local(&mut self, l: &'ast Local) { walk_local(self, l) }\n+    fn visit_block(&mut self, b: &'ast Block) { walk_block(self, b) }\n+    fn visit_stmt(&mut self, s: &'ast Stmt) { walk_stmt(self, s) }\n+    fn visit_arm(&mut self, a: &'ast Arm) { walk_arm(self, a) }\n+    fn visit_pat(&mut self, p: &'ast Pat) { walk_pat(self, p) }\n+    fn visit_expr(&mut self, ex: &'ast Expr) { walk_expr(self, ex) }\n+    fn visit_expr_post(&mut self, _ex: &'ast Expr) { }\n+    fn visit_ty(&mut self, t: &'ast Ty) { walk_ty(self, t) }\n+    fn visit_generics(&mut self, g: &'ast Generics) { walk_generics(self, g) }\n+    fn visit_fn(&mut self, fk: FnKind<'ast>, fd: &'ast FnDecl, s: Span, _: NodeId) {\n         walk_fn(self, fk, fd, s)\n     }\n-    fn visit_trait_item(&mut self, ti: &TraitItem) { walk_trait_item(self, ti) }\n-    fn visit_impl_item(&mut self, ii: &ImplItem) { walk_impl_item(self, ii) }\n-    fn visit_trait_ref(&mut self, t: &TraitRef) { walk_trait_ref(self, t) }\n-    fn visit_ty_param_bound(&mut self, bounds: &TyParamBound) {\n+    fn visit_trait_item(&mut self, ti: &'ast TraitItem) { walk_trait_item(self, ti) }\n+    fn visit_impl_item(&mut self, ii: &'ast ImplItem) { walk_impl_item(self, ii) }\n+    fn visit_trait_ref(&mut self, t: &'ast TraitRef) { walk_trait_ref(self, t) }\n+    fn visit_ty_param_bound(&mut self, bounds: &'ast TyParamBound) {\n         walk_ty_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &PolyTraitRef, m: &TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n-    fn visit_variant_data(&mut self, s: &VariantData, _: Ident,\n-                          _: &Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, s: &'ast VariantData, _: Ident,\n+                          _: &'ast Generics, _: NodeId, _: Span) {\n         walk_struct_def(self, s)\n     }\n-    fn visit_struct_field(&mut self, s: &StructField) { walk_struct_field(self, s) }\n-    fn visit_enum_def(&mut self, enum_definition: &EnumDef,\n-                      generics: &Generics, item_id: NodeId, _: Span) {\n+    fn visit_struct_field(&mut self, s: &'ast StructField) { walk_struct_field(self, s) }\n+    fn visit_enum_def(&mut self, enum_definition: &'ast EnumDef,\n+                      generics: &'ast Generics, item_id: NodeId, _: Span) {\n         walk_enum_def(self, enum_definition, generics, item_id)\n     }\n-    fn visit_variant(&mut self, v: &Variant, g: &Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &'ast Variant, g: &'ast Generics, item_id: NodeId) {\n         walk_variant(self, v, g, item_id)\n     }\n-    fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_lifetime_def(&mut self, lifetime: &LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lifetime: &'ast LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n     }\n-    fn visit_mac(&mut self, _mac: &Mac) {\n+    fn visit_mac(&mut self, _mac: &'ast Mac) {\n         panic!(\"visit_mac disabled by default\");\n         // NB: see note about macros above.\n         // if you really want a visitor that\n         // works on macros, use this\n         // definition in your trait impl:\n         // visit::walk_mac(self, _mac)\n     }\n-    fn visit_path(&mut self, path: &Path, _id: NodeId) {\n+    fn visit_path(&mut self, path: &'ast Path, _id: NodeId) {\n         walk_path(self, path)\n     }\n-    fn visit_path_list_item(&mut self, prefix: &Path, item: &PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &'ast Path, item: &'ast PathListItem) {\n         walk_path_list_item(self, prefix, item)\n     }\n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &PathSegment) {\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) {\n         walk_path_segment(self, path_span, path_segment)\n     }\n-    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &PathParameters) {\n+    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'ast PathParameters) {\n         walk_path_parameters(self, path_span, path_parameters)\n     }\n-    fn visit_assoc_type_binding(&mut self, type_binding: &TypeBinding) {\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'ast TypeBinding) {\n         walk_assoc_type_binding(self, type_binding)\n     }\n-    fn visit_attribute(&mut self, _attr: &Attribute) {}\n-    fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n+    fn visit_attribute(&mut self, _attr: &'ast Attribute) {}\n+    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n         walk_macro_def(self, macro_def)\n     }\n-    fn visit_vis(&mut self, vis: &Visibility) {\n+    fn visit_vis(&mut self, vis: &'ast Visibility) {\n         walk_vis(self, vis)\n     }\n-    fn visit_fn_ret_ty(&mut self, ret_ty: &FunctionRetTy) {\n+    fn visit_fn_ret_ty(&mut self, ret_ty: &'ast FunctionRetTy) {\n         walk_fn_ret_ty(self, ret_ty)\n     }\n }\n@@ -147,45 +147,46 @@ macro_rules! walk_list {\n     }\n }\n \n-pub fn walk_opt_name<V: Visitor>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n+pub fn walk_opt_name<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n     if let Some(name) = opt_name {\n         visitor.visit_name(span, name);\n     }\n }\n \n-pub fn walk_opt_ident<V: Visitor>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n+pub fn walk_opt_ident<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n     if let Some(ident) = opt_ident {\n         visitor.visit_ident(span, ident);\n     }\n }\n \n-pub fn walk_opt_sp_ident<V: Visitor>(visitor: &mut V, opt_sp_ident: &Option<Spanned<Ident>>) {\n+pub fn walk_opt_sp_ident<'a, V: Visitor<'a>>(visitor: &mut V,\n+                                             opt_sp_ident: &Option<Spanned<Ident>>) {\n     if let Some(ref sp_ident) = *opt_sp_ident {\n         visitor.visit_ident(sp_ident.span, sp_ident.node);\n     }\n }\n \n-pub fn walk_ident<V: Visitor>(visitor: &mut V, span: Span, ident: Ident) {\n+pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, ident: Ident) {\n     visitor.visit_name(span, ident.name);\n }\n \n-pub fn walk_crate<V: Visitor>(visitor: &mut V, krate: &Crate) {\n+pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n     walk_list!(visitor, visit_attribute, &krate.attrs);\n     walk_list!(visitor, visit_macro_def, &krate.exported_macros);\n }\n \n-pub fn walk_macro_def<V: Visitor>(visitor: &mut V, macro_def: &MacroDef) {\n+pub fn walk_macro_def<'a, V: Visitor<'a>>(visitor: &mut V, macro_def: &'a MacroDef) {\n     visitor.visit_ident(macro_def.span, macro_def.ident);\n     walk_opt_ident(visitor, macro_def.span, macro_def.imported_from);\n     walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n \n-pub fn walk_mod<V: Visitor>(visitor: &mut V, module: &Mod) {\n+pub fn walk_mod<'a, V: Visitor<'a>>(visitor: &mut V, module: &'a Mod) {\n     walk_list!(visitor, visit_item, &module.items);\n }\n \n-pub fn walk_local<V: Visitor>(visitor: &mut V, local: &Local) {\n+pub fn walk_local<'a, V: Visitor<'a>>(visitor: &mut V, local: &'a Local) {\n     for attr in local.attrs.iter() {\n         visitor.visit_attribute(attr);\n     }\n@@ -194,28 +195,30 @@ pub fn walk_local<V: Visitor>(visitor: &mut V, local: &Local) {\n     walk_list!(visitor, visit_expr, &local.init);\n }\n \n-pub fn walk_lifetime<V: Visitor>(visitor: &mut V, lifetime: &Lifetime) {\n+pub fn walk_lifetime<'a, V: Visitor<'a>>(visitor: &mut V, lifetime: &'a Lifetime) {\n     visitor.visit_name(lifetime.span, lifetime.name);\n }\n \n-pub fn walk_lifetime_def<V: Visitor>(visitor: &mut V, lifetime_def: &LifetimeDef) {\n+pub fn walk_lifetime_def<'a, V: Visitor<'a>>(visitor: &mut V, lifetime_def: &'a LifetimeDef) {\n     visitor.visit_lifetime(&lifetime_def.lifetime);\n     walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n     walk_list!(visitor, visit_attribute, &*lifetime_def.attrs);\n }\n \n-pub fn walk_poly_trait_ref<V>(visitor: &mut V, trait_ref: &PolyTraitRef, _: &TraitBoundModifier)\n-    where V: Visitor,\n+pub fn walk_poly_trait_ref<'a, V>(visitor: &mut V,\n+                                  trait_ref: &'a PolyTraitRef,\n+                                  _: &TraitBoundModifier)\n+    where V: Visitor<'a>,\n {\n     walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n-pub fn walk_trait_ref<V: Visitor>(visitor: &mut V, trait_ref: &TraitRef) {\n+pub fn walk_trait_ref<'a, V: Visitor<'a>>(visitor: &mut V, trait_ref: &'a TraitRef) {\n     visitor.visit_path(&trait_ref.path, trait_ref.ref_id)\n }\n \n-pub fn walk_item<V: Visitor>(visitor: &mut V, item: &Item) {\n+pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n@@ -294,15 +297,18 @@ pub fn walk_item<V: Visitor>(visitor: &mut V, item: &Item) {\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }\n \n-pub fn walk_enum_def<V: Visitor>(visitor: &mut V,\n-                                 enum_definition: &EnumDef,\n-                                 generics: &Generics,\n+pub fn walk_enum_def<'a, V: Visitor<'a>>(visitor: &mut V,\n+                                 enum_definition: &'a EnumDef,\n+                                 generics: &'a Generics,\n                                  item_id: NodeId) {\n     walk_list!(visitor, visit_variant, &enum_definition.variants, generics, item_id);\n }\n \n-pub fn walk_variant<V>(visitor: &mut V, variant: &Variant, generics: &Generics, item_id: NodeId)\n-    where V: Visitor,\n+pub fn walk_variant<'a, V>(visitor: &mut V,\n+                           variant: &'a Variant,\n+                           generics: &'a Generics,\n+                           item_id: NodeId)\n+    where V: Visitor<'a>,\n {\n     visitor.visit_ident(variant.span, variant.node.name);\n     visitor.visit_variant_data(&variant.node.data, variant.node.name,\n@@ -311,7 +317,7 @@ pub fn walk_variant<V>(visitor: &mut V, variant: &Variant, generics: &Generics,\n     walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n \n-pub fn walk_ty<V: Visitor>(visitor: &mut V, typ: &Ty) {\n+pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n     match typ.node {\n         TyKind::Slice(ref ty) | TyKind::Paren(ref ty) => {\n             visitor.visit_ty(ty)\n@@ -361,24 +367,30 @@ pub fn walk_ty<V: Visitor>(visitor: &mut V, typ: &Ty) {\n     }\n }\n \n-pub fn walk_path<V: Visitor>(visitor: &mut V, path: &Path) {\n+pub fn walk_path<'a, V: Visitor<'a>>(visitor: &mut V, path: &'a Path) {\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n     }\n }\n \n-pub fn walk_path_list_item<V: Visitor>(visitor: &mut V, _prefix: &Path, item: &PathListItem) {\n+pub fn walk_path_list_item<'a, V: Visitor<'a>>(visitor: &mut V,\n+                                               _prefix: &Path,\n+                                               item: &'a PathListItem) {\n     visitor.visit_ident(item.span, item.node.name);\n     walk_opt_ident(visitor, item.span, item.node.rename);\n }\n \n-pub fn walk_path_segment<V: Visitor>(visitor: &mut V, path_span: Span, segment: &PathSegment) {\n+pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V,\n+                                             path_span: Span,\n+                                             segment: &'a PathSegment) {\n     visitor.visit_ident(path_span, segment.identifier);\n     visitor.visit_path_parameters(path_span, &segment.parameters);\n }\n \n-pub fn walk_path_parameters<V>(visitor: &mut V, _path_span: Span, path_parameters: &PathParameters)\n-    where V: Visitor,\n+pub fn walk_path_parameters<'a, V>(visitor: &mut V,\n+                                   _path_span: Span,\n+                                   path_parameters: &'a PathParameters)\n+    where V: Visitor<'a>,\n {\n     match *path_parameters {\n         PathParameters::AngleBracketed(ref data) => {\n@@ -393,12 +405,13 @@ pub fn walk_path_parameters<V>(visitor: &mut V, _path_span: Span, path_parameter\n     }\n }\n \n-pub fn walk_assoc_type_binding<V: Visitor>(visitor: &mut V, type_binding: &TypeBinding) {\n+pub fn walk_assoc_type_binding<'a, V: Visitor<'a>>(visitor: &mut V,\n+                                                   type_binding: &'a TypeBinding) {\n     visitor.visit_ident(type_binding.span, type_binding.ident);\n     visitor.visit_ty(&type_binding.ty);\n }\n \n-pub fn walk_pat<V: Visitor>(visitor: &mut V, pattern: &Pat) {\n+pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n     match pattern.node {\n         PatKind::TupleStruct(ref path, ref children, _) => {\n             visitor.visit_path(path, pattern.id);\n@@ -443,7 +456,7 @@ pub fn walk_pat<V: Visitor>(visitor: &mut V, pattern: &Pat) {\n     }\n }\n \n-pub fn walk_foreign_item<V: Visitor>(visitor: &mut V, foreign_item: &ForeignItem) {\n+pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, foreign_item: &'a ForeignItem) {\n     visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_ident(foreign_item.span, foreign_item.ident);\n \n@@ -458,7 +471,7 @@ pub fn walk_foreign_item<V: Visitor>(visitor: &mut V, foreign_item: &ForeignItem\n     walk_list!(visitor, visit_attribute, &foreign_item.attrs);\n }\n \n-pub fn walk_ty_param_bound<V: Visitor>(visitor: &mut V, bound: &TyParamBound) {\n+pub fn walk_ty_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a TyParamBound) {\n     match *bound {\n         TraitTyParamBound(ref typ, ref modifier) => {\n             visitor.visit_poly_trait_ref(typ, modifier);\n@@ -469,7 +482,7 @@ pub fn walk_ty_param_bound<V: Visitor>(visitor: &mut V, bound: &TyParamBound) {\n     }\n }\n \n-pub fn walk_generics<V: Visitor>(visitor: &mut V, generics: &Generics) {\n+pub fn walk_generics<'a, V: Visitor<'a>>(visitor: &mut V, generics: &'a Generics) {\n     for param in &generics.ty_params {\n         visitor.visit_ident(param.span, param.ident);\n         walk_list!(visitor, visit_ty_param_bound, &param.bounds);\n@@ -504,22 +517,22 @@ pub fn walk_generics<V: Visitor>(visitor: &mut V, generics: &Generics) {\n     }\n }\n \n-pub fn walk_fn_ret_ty<V: Visitor>(visitor: &mut V, ret_ty: &FunctionRetTy) {\n+pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FunctionRetTy) {\n     if let FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n         visitor.visit_ty(output_ty)\n     }\n }\n \n-pub fn walk_fn_decl<V: Visitor>(visitor: &mut V, function_declaration: &FnDecl) {\n+pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &'a FnDecl) {\n     for argument in &function_declaration.inputs {\n         visitor.visit_pat(&argument.pat);\n         visitor.visit_ty(&argument.ty)\n     }\n     visitor.visit_fn_ret_ty(&function_declaration.output)\n }\n \n-pub fn walk_fn<V>(visitor: &mut V, kind: FnKind, declaration: &FnDecl, _span: Span)\n-    where V: Visitor,\n+pub fn walk_fn<'a, V>(visitor: &mut V, kind: FnKind<'a>, declaration: &'a FnDecl, _span: Span)\n+    where V: Visitor<'a>,\n {\n     match kind {\n         FnKind::ItemFn(_, generics, _, _, _, _, body) => {\n@@ -539,7 +552,7 @@ pub fn walk_fn<V>(visitor: &mut V, kind: FnKind, declaration: &FnDecl, _span: Sp\n     }\n }\n \n-pub fn walk_trait_item<V: Visitor>(visitor: &mut V, trait_item: &TraitItem) {\n+pub fn walk_trait_item<'a, V: Visitor<'a>>(visitor: &mut V, trait_item: &'a TraitItem) {\n     visitor.visit_ident(trait_item.span, trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     match trait_item.node {\n@@ -565,7 +578,7 @@ pub fn walk_trait_item<V: Visitor>(visitor: &mut V, trait_item: &TraitItem) {\n     }\n }\n \n-pub fn walk_impl_item<V: Visitor>(visitor: &mut V, impl_item: &ImplItem) {\n+pub fn walk_impl_item<'a, V: Visitor<'a>>(visitor: &mut V, impl_item: &'a ImplItem) {\n     visitor.visit_vis(&impl_item.vis);\n     visitor.visit_ident(impl_item.span, impl_item.ident);\n     walk_list!(visitor, visit_attribute, &impl_item.attrs);\n@@ -587,22 +600,22 @@ pub fn walk_impl_item<V: Visitor>(visitor: &mut V, impl_item: &ImplItem) {\n     }\n }\n \n-pub fn walk_struct_def<V: Visitor>(visitor: &mut V, struct_definition: &VariantData) {\n+pub fn walk_struct_def<'a, V: Visitor<'a>>(visitor: &mut V, struct_definition: &'a VariantData) {\n     walk_list!(visitor, visit_struct_field, struct_definition.fields());\n }\n \n-pub fn walk_struct_field<V: Visitor>(visitor: &mut V, struct_field: &StructField) {\n+pub fn walk_struct_field<'a, V: Visitor<'a>>(visitor: &mut V, struct_field: &'a StructField) {\n     visitor.visit_vis(&struct_field.vis);\n     walk_opt_ident(visitor, struct_field.span, struct_field.ident);\n     visitor.visit_ty(&struct_field.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.attrs);\n }\n \n-pub fn walk_block<V: Visitor>(visitor: &mut V, block: &Block) {\n+pub fn walk_block<'a, V: Visitor<'a>>(visitor: &mut V, block: &'a Block) {\n     walk_list!(visitor, visit_stmt, &block.stmts);\n }\n \n-pub fn walk_stmt<V: Visitor>(visitor: &mut V, statement: &Stmt) {\n+pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) {\n     match statement.node {\n         StmtKind::Local(ref local) => visitor.visit_local(local),\n         StmtKind::Item(ref item) => visitor.visit_item(item),\n@@ -619,11 +632,11 @@ pub fn walk_stmt<V: Visitor>(visitor: &mut V, statement: &Stmt) {\n     }\n }\n \n-pub fn walk_mac<V: Visitor>(_: &mut V, _: &Mac) {\n+pub fn walk_mac<'a, V: Visitor<'a>>(_: &mut V, _: &Mac) {\n     // Empty!\n }\n \n-pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n+pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     for attr in expression.attrs.iter() {\n         visitor.visit_attribute(attr);\n     }\n@@ -776,14 +789,14 @@ pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n     visitor.visit_expr_post(expression)\n }\n \n-pub fn walk_arm<V: Visitor>(visitor: &mut V, arm: &Arm) {\n+pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {\n     walk_list!(visitor, visit_pat, &arm.pats);\n     walk_list!(visitor, visit_expr, &arm.guard);\n     visitor.visit_expr(&arm.body);\n     walk_list!(visitor, visit_attribute, &arm.attrs);\n }\n \n-pub fn walk_vis<V: Visitor>(visitor: &mut V, vis: &Visibility) {\n+pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n     if let Visibility::Restricted { ref path, id } = *vis {\n         visitor.visit_path(path, id);\n     }"}, {"sha": "6f02a348f91dc674cf13a0d57ec29f2523c77d26", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -21,7 +21,7 @@ use syntax::visit::Visitor;\n \n struct MarkAttrs<'a>(&'a [ast::Name]);\n \n-impl<'a> Visitor for MarkAttrs<'a> {\n+impl<'a> Visitor<'a> for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {\n         if self.0.contains(&attr.name()) {\n             mark_used(attr);\n@@ -101,4 +101,3 @@ impl MultiItemModifier for CustomDerive {\n         res\n     }\n }\n-"}, {"sha": "51199819dfcd7dec64c15568222460ae7703e47b", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -361,8 +361,8 @@ fn find_type_parameters(ty: &ast::Ty,\n         types: Vec<P<ast::Ty>>,\n     }\n \n-    impl<'a, 'b> visit::Visitor for Visitor<'a, 'b> {\n-        fn visit_ty(&mut self, ty: &ast::Ty) {\n+    impl<'a, 'b> visit::Visitor<'a> for Visitor<'a, 'b> {\n+        fn visit_ty(&mut self, ty: &'a ast::Ty) {\n             match ty.node {\n                 ast::TyKind::Path(_, ref path) if !path.global => {\n                     if let Some(segment) = path.segments.first() {"}, {"sha": "8fbd11a7a6e03342b83acba1b4991343a4db8df5", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -52,14 +52,17 @@ pub fn modify(sess: &ParseSess,\n     let ecfg = ExpansionConfig::default(\"proc_macro\".to_string());\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver);\n \n-    let mut collect = CollectCustomDerives {\n-        derives: Vec::new(),\n-        in_root: true,\n-        handler: handler,\n-        is_proc_macro_crate: is_proc_macro_crate,\n-        is_test_crate: is_test_crate,\n+    let derives = {\n+        let mut collect = CollectCustomDerives {\n+            derives: Vec::new(),\n+            in_root: true,\n+            handler: handler,\n+            is_proc_macro_crate: is_proc_macro_crate,\n+            is_test_crate: is_test_crate,\n+        };\n+        visit::walk_crate(&mut collect, &krate);\n+        collect.derives\n     };\n-    visit::walk_crate(&mut collect, &krate);\n \n     if !is_proc_macro_crate {\n         return krate\n@@ -79,7 +82,7 @@ pub fn modify(sess: &ParseSess,\n         return krate;\n     }\n \n-    krate.module.items.push(mk_registrar(&mut cx, &collect.derives));\n+    krate.module.items.push(mk_registrar(&mut cx, &derives));\n \n     if krate.exported_macros.len() > 0 {\n         handler.err(\"cannot export macro_rules! macros from a `proc-macro` \\\n@@ -103,8 +106,8 @@ impl<'a> CollectCustomDerives<'a> {\n     }\n }\n \n-impl<'a> Visitor for CollectCustomDerives<'a> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+impl<'a> Visitor<'a> for CollectCustomDerives<'a> {\n+    fn visit_item(&mut self, item: &'a ast::Item) {\n         // First up, make sure we're checking a bare function. If we're not then\n         // we're just not interested in this item.\n         //\n@@ -240,7 +243,7 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n         visit::walk_item(self, item);\n     }\n \n-    fn visit_mod(&mut self, m: &ast::Mod, _s: Span, id: NodeId) {\n+    fn visit_mod(&mut self, m: &'a ast::Mod, _s: Span, id: NodeId) {\n         let mut prev_in_root = self.in_root;\n         if id != ast::CRATE_NODE_ID {\n             prev_in_root = mem::replace(&mut self.in_root, false);"}, {"sha": "fc53031e7f22662f8e442cd8bcccb9bc86e9d6ea", "filename": "src/test/compile-fail-fulldeps/auxiliary/lint_for_crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_for_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_for_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_for_crate.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -32,7 +32,7 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n         if !attr::contains_name(&krate.attrs, \"crate_okay\") {\n             cx.span_lint(CRATE_NOT_OKAY, krate.span,\n@@ -43,5 +43,5 @@ impl LateLintPass for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_late_lint_pass(box Pass as LateLintPassObject);\n+    reg.register_late_lint_pass(box Pass);\n }"}, {"sha": "490aa0d469312d30b92af1bf28e57d489634159e", "filename": "src/test/compile-fail-fulldeps/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -34,7 +34,7 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match &*it.name.as_str() {\n             \"lintme\" => cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\"),\n@@ -46,6 +46,6 @@ impl LateLintPass for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_late_lint_pass(box Pass as LateLintPassObject);\n+    reg.register_late_lint_pass(box Pass);\n     reg.register_lint_group(\"lint_me\", vec![TEST_LINT, PLEASE_LINT]);\n }"}, {"sha": "fc53031e7f22662f8e442cd8bcccb9bc86e9d6ea", "filename": "src/test/run-pass-fulldeps/auxiliary/lint_for_crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_for_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_for_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_for_crate.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -32,7 +32,7 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n         if !attr::contains_name(&krate.attrs, \"crate_okay\") {\n             cx.span_lint(CRATE_NOT_OKAY, krate.span,\n@@ -43,5 +43,5 @@ impl LateLintPass for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_late_lint_pass(box Pass as LateLintPassObject);\n+    reg.register_late_lint_pass(box Pass);\n }"}, {"sha": "490aa0d469312d30b92af1bf28e57d489634159e", "filename": "src/test/run-pass-fulldeps/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -34,7 +34,7 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match &*it.name.as_str() {\n             \"lintme\" => cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\"),\n@@ -46,6 +46,6 @@ impl LateLintPass for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_late_lint_pass(box Pass as LateLintPassObject);\n+    reg.register_late_lint_pass(box Pass);\n     reg.register_lint_group(\"lint_me\", vec![TEST_LINT, PLEASE_LINT]);\n }"}, {"sha": "c6892757c682f22cbc4d5d2c60b8d7ab9f69e71d", "filename": "src/test/run-pass-fulldeps/issue-37290/auxiliary/lint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b06438d8349c1a6bbeb29c2a1bd874553a8625c/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs?ref=7b06438d8349c1a6bbeb29c2a1bd874553a8625c", "patch": "@@ -39,10 +39,10 @@ impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray { lint_array!(REGION_HIERARCHY) }\n }\n \n-impl LateLintPass for Pass {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_fn(&mut self, cx: &LateContext,\n-                fk: FnKind, _: &hir::FnDecl, expr: &hir::Expr,\n-                span: Span, node: ast::NodeId)\n+                              fk: FnKind, _: &hir::FnDecl, expr: &hir::Expr,\n+                              span: Span, node: ast::NodeId)\n     {\n         if let FnKind::Closure(..) = fk { return }\n "}]}