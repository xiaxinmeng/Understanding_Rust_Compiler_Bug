{"sha": "d1298f768c1a1cefa119fccffc7029c6110098d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMjk4Zjc2OGMxYTFjZWZhMTE5ZmNjZmZjNzAyOWM2MTEwMDk4ZDA=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-28T01:39:57Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-28T01:46:46Z"}, "message": "Have bind support non-alias parametric non-bound arguments.\n\nThis was previously disallowed by the typechecker and not properly handled\nin trans. I removed the typechecker check (replacing it with a simpler\ncheck that spawned functions don't have type params) and fixed trans.\nCloses #756.", "tree": {"sha": "2b38793ee1f68fee900a0eac4d42c57495921279", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b38793ee1f68fee900a0eac4d42c57495921279"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1298f768c1a1cefa119fccffc7029c6110098d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1298f768c1a1cefa119fccffc7029c6110098d0", "html_url": "https://github.com/rust-lang/rust/commit/d1298f768c1a1cefa119fccffc7029c6110098d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1298f768c1a1cefa119fccffc7029c6110098d0/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4de0b3d9474eb4b1284a8abf4bd03a5135a19a83", "url": "https://api.github.com/repos/rust-lang/rust/commits/4de0b3d9474eb4b1284a8abf4bd03a5135a19a83", "html_url": "https://github.com/rust-lang/rust/commit/4de0b3d9474eb4b1284a8abf4bd03a5135a19a83"}], "stats": {"total": 84, "additions": 37, "deletions": 47}, "files": [{"sha": "2e3c2a414460475d3691870880f83fac426d9178", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d1298f768c1a1cefa119fccffc7029c6110098d0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1298f768c1a1cefa119fccffc7029c6110098d0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d1298f768c1a1cefa119fccffc7029c6110098d0", "patch": "@@ -4499,12 +4499,20 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n \n           // Arg will be provided when the thunk is invoked.\n           none. {\n-            let passed_arg: ValueRef = llvm::LLVMGetParam(llthunk, a);\n+            let arg: ValueRef = llvm::LLVMGetParam(llthunk, a);\n             if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n-                assert (!is_val);\n-                passed_arg = bcx.build.PointerCast(passed_arg, llout_arg_ty);\n+                // If the argument was passed by value and isn't a\n+                // pointer type, we need to spill it to an alloca in\n+                // order to do a pointer cast. Argh.\n+                if is_val && !ty::type_is_boxed(cx.ccx.tcx, out_arg.ty) {\n+                    let argp = do_spill(bcx, arg);\n+                    argp = bcx.build.PointerCast(argp, T_ptr(llout_arg_ty));\n+                    arg = bcx.build.Load(argp);\n+                } else {\n+                    arg = bcx.build.PointerCast(arg, llout_arg_ty);\n+                }\n             }\n-            llargs += ~[passed_arg];\n+            llargs += ~[arg];\n             a += 1u;\n           }\n         }\n@@ -5348,7 +5356,6 @@ fn type_is_immediate(ccx: &@crate_ctxt, t: &ty::t) -> bool {\n \n fn do_spill(cx: &@block_ctxt, v: ValueRef) -> ValueRef {\n     // We have a value but we have to spill it to pass by alias.\n-\n     let llptr = alloca(cx, val_ty(v));\n     cx.build.Store(v, llptr);\n     ret llptr;\n@@ -6310,8 +6317,6 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, args: &ast::arg[],\n     let arg_n: uint = 0u;\n     for aarg: ast::arg  in args {\n         if aarg.mode == ast::val {\n-            let arg_t = type_of_arg(bcx.fcx.lcx, fcx.sp, arg_tys.(arg_n));\n-            let a = alloca(bcx, arg_t);\n             let argval;\n             alt bcx.fcx.llargs.find(aarg.id) {\n               some(x) { argval = x; }\n@@ -6320,9 +6325,9 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, args: &ast::arg[],\n                     (aarg.ty.span, \"unbound arg ID in copy_args_to_allocas\");\n               }\n             }\n-            bcx.build.Store(argval, a);\n-            // Overwrite the llargs entry for this arg with its alloca.\n+            let a = do_spill(bcx, argval);\n \n+            // Overwrite the llargs entry for this arg with its alloca.\n             bcx.fcx.llargs.insert(aarg.id, a);\n         }\n         arg_n += 1u;"}, {"sha": "5ff5a018f8805ca5d8203d70f7e7e72ef62afe0d", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1298f768c1a1cefa119fccffc7029c6110098d0/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1298f768c1a1cefa119fccffc7029c6110098d0/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=d1298f768c1a1cefa119fccffc7029c6110098d0", "patch": "@@ -1744,8 +1744,7 @@ fn node_id_to_type_params(cx: &ctxt, id: &ast::node_id) -> t[] {\n }\n \n fn node_id_has_type_params(cx: &ctxt, id: &ast::node_id) -> bool {\n-    let tpt = node_id_to_ty_param_substs_opt_and_ty(cx, id);\n-    ret !option::is_none[t[]](tpt.substs);\n+    ret ivec::len(node_id_to_type_params(cx, id)) > 0u;\n }\n \n "}, {"sha": "2ec020fdb876892f428a70db1a583e798be37452", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 11, "deletions": 31, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d1298f768c1a1cefa119fccffc7029c6110098d0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1298f768c1a1cefa119fccffc7029c6110098d0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=d1298f768c1a1cefa119fccffc7029c6110098d0", "patch": "@@ -1532,7 +1532,6 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n-\n     fn check_call_or_bind(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n                           args: &(option::t[@ast::expr])[],\n                           call_kind: call_kind) {\n@@ -1585,38 +1584,14 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         // TODO: iter2\n         let i = 0u;\n         for a_opt: option::t[@ast::expr]  in args {\n-            let check_ty_vars = call_kind == kind_spawn;\n             alt a_opt {\n               some(a) {\n                 check_expr(fcx, a);\n                 demand::full(fcx, a.span, arg_tys.(i).ty,\n                              expr_ty(fcx.ccx.tcx, a), ~[],\n                              AUTODEREF_BLOCK_COERCE);\n               }\n-              none. { check_ty_vars = true; }\n-            }\n-            /* If this argument is going to be a thunk argument\n-               (that is, it's an underscore-bind thing or a spawn\n-               argument), then it has to be either passed by reference,\n-               or have a statically known size. */\n-            alt call_kind {\n-              kind_call. { }\n-              _ {\n-                 /* bind or spawn */\n-                if check_ty_vars &&\n-                       (ty::type_contains_params(fcx.ccx.tcx, arg_tys.(i).ty)\n-                            ||\n-                            ty::type_contains_vars(fcx.ccx.tcx,\n-                                                   arg_tys.(i).ty)) &&\n-                       arg_tys.(i).mode == mo_val {\n-                    // For why the check is necessary, see the\n-                    // none case in trans_bind_thunk\n-                    fcx.ccx.tcx.sess.span_fatal\n-                        (sp, call_kind_str(call_kind) +\n-                         \" arguments with types containing parameters \\\n-                          must be passed by alias\");\n-                }\n-              }\n+              none. { }\n             }\n             i += 1u;\n         }\n@@ -1639,8 +1614,8 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         for arg: @ast::expr  in args {\n             args_opt_0 += ~[some[@ast::expr](arg)];\n         }\n-        // Call the generic checker.\n \n+        // Call the generic checker.\n         check_call_or_bind(fcx, sp, f, args_opt_0, call_kind);\n     }\n     // A generic function for checking for or for-each loops\n@@ -2059,10 +2034,9 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n       }\n       ast::expr_bind(f, args) {\n         // Call the generic checker.\n-\n         check_call_or_bind(fcx, expr.span, f, args, kind_bind);\n-        // Pull the argument and return types out.\n \n+        // Pull the argument and return types out.\n         let proto_1;\n         let arg_tys_1: ty::arg[] = ~[];\n         let rt_1;\n@@ -2078,7 +2052,6 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n \n             // For each blank argument, add the type of that argument\n             // to the resulting function type.\n-\n             let i = 0u;\n             while i < ivec::len[option::t[@ast::expr]](args) {\n                 alt args.(i) {\n@@ -2180,8 +2153,15 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         let fty = expr_ty(fcx.ccx.tcx, f);\n         let ret_ty = ty::ret_ty_of_fn_ty(fcx.ccx.tcx, fty);\n         demand::simple(fcx, f.span, ty::mk_nil(fcx.ccx.tcx), ret_ty);\n-        // FIXME: Other typechecks needed\n \n+        // make sure they aren't spawning a function with type params\n+        if ty::expr_has_ty_params(fcx.ccx.tcx, f) {\n+            fcx.ccx.tcx.sess.span_fatal(\n+                f.span,\n+                \"spawning functions with type params not allowed (for now)\");\n+        }\n+\n+        // FIXME: Other typechecks needed\n         let typ = ty::mk_task(fcx.ccx.tcx);\n         write::ty_only_fixup(fcx, id, typ);\n       }"}, {"sha": "4c62dffcab2b6b2fb2c43511b3d6a02beaf59cb9", "filename": "src/test/compile-fail/chan-parameterized-args.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1298f768c1a1cefa119fccffc7029c6110098d0/src%2Ftest%2Fcompile-fail%2Fchan-parameterized-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1298f768c1a1cefa119fccffc7029c6110098d0/src%2Ftest%2Fcompile-fail%2Fchan-parameterized-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchan-parameterized-args.rs?ref=d1298f768c1a1cefa119fccffc7029c6110098d0", "patch": "@@ -1,7 +1,6 @@\n // xfail-stage0\n-// error-pattern:Spawn arguments with types containing parameters must be\n+// error-pattern:spawning functions with type params not allowed\n fn main() {\n-    // Similar to bind-parameterized-args\n     fn echo[T](c: chan[T], oc: chan[chan[T]]) {\n         let p: port[T] = port();\n         oc <| chan(p);\n@@ -15,4 +14,4 @@ fn main() {\n     let p2 = port[chan[int]]();\n \n     spawn echo(chan(p), chan(p2));\n-}\n\\ No newline at end of file\n+}"}, {"sha": "476cef93e2fb30e470df893ad3ce9bff605a62c1", "filename": "src/test/run-pass/bind-parameterized-args-2.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1298f768c1a1cefa119fccffc7029c6110098d0/src%2Ftest%2Frun-pass%2Fbind-parameterized-args-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1298f768c1a1cefa119fccffc7029c6110098d0/src%2Ftest%2Frun-pass%2Fbind-parameterized-args-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-parameterized-args-2.rs?ref=d1298f768c1a1cefa119fccffc7029c6110098d0", "patch": "@@ -0,0 +1,8 @@\n+// xfail-stage0\n+fn main() {\n+    fn echo[T](c: int, x: fn(&T)) { log_err \"wee\"; }\n+\n+    let y = bind echo(42, _);\n+\n+    y(fn(i: &str){});\n+}"}, {"sha": "7274cd48972276b5d39dd8b9a274bb212181c8b2", "filename": "src/test/run-pass/bind-parameterized-args.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1298f768c1a1cefa119fccffc7029c6110098d0/src%2Ftest%2Frun-pass%2Fbind-parameterized-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1298f768c1a1cefa119fccffc7029c6110098d0/src%2Ftest%2Frun-pass%2Fbind-parameterized-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-parameterized-args.rs?ref=d1298f768c1a1cefa119fccffc7029c6110098d0", "patch": "@@ -1,9 +1,8 @@\n // xfail-stage0\n-// error-pattern:Bind arguments with types containing parameters must be\n fn main() {\n     fn echo[T](c: int, x: vec[T]) { }\n \n     let y: fn(vec[int])  = bind echo(42, _);\n \n     y([1]);\n-}\n\\ No newline at end of file\n+}", "previous_filename": "src/test/compile-fail/bind-parameterized-args.rs"}]}