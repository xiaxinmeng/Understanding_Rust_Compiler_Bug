{"sha": "6210dcdddb7d7dab3f8fd0e9016b119f82408324", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMTBkY2RkZGI3ZDdkYWIzZjhmZDBlOTAxNmIxMTlmODI0MDgzMjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-05T08:52:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-05T08:52:06Z"}, "message": "Auto merge of #27530 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #27519, #27521, #27525, #27527, #27528\n- Failed merges:", "tree": {"sha": "3cc74d0f5aadfab5bdb181b69c2272a4bd69cec3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cc74d0f5aadfab5bdb181b69c2272a4bd69cec3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6210dcdddb7d7dab3f8fd0e9016b119f82408324", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6210dcdddb7d7dab3f8fd0e9016b119f82408324", "html_url": "https://github.com/rust-lang/rust/commit/6210dcdddb7d7dab3f8fd0e9016b119f82408324", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6210dcdddb7d7dab3f8fd0e9016b119f82408324/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76ff835ca0b6669b185e6a4aeedc144432db91f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/76ff835ca0b6669b185e6a4aeedc144432db91f8", "html_url": "https://github.com/rust-lang/rust/commit/76ff835ca0b6669b185e6a4aeedc144432db91f8"}, {"sha": "eee286dfdd17d4109c32ceece5abf4bccbf1364e", "url": "https://api.github.com/repos/rust-lang/rust/commits/eee286dfdd17d4109c32ceece5abf4bccbf1364e", "html_url": "https://github.com/rust-lang/rust/commit/eee286dfdd17d4109c32ceece5abf4bccbf1364e"}], "stats": {"total": 299, "additions": 151, "deletions": 148}, "files": [{"sha": "d781e59d7c9e044b0eaf72f1f8b871e7824740cb", "filename": "src/doc/nomicon/atomics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fatomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fatomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fatomics.md?ref=6210dcdddb7d7dab3f8fd0e9016b119f82408324", "patch": "@@ -127,7 +127,7 @@ fundamentally unsynchronized and compilers are free to aggressively optimize\n them. In particular, data accesses are free to be reordered by the compiler on\n the assumption that the program is single-threaded. The hardware is also free to\n propagate the changes made in data accesses to other threads as lazily and\n-inconsistently as it wants. Mostly critically, data accesses are how data races\n+inconsistently as it wants. Most critically, data accesses are how data races\n happen. Data accesses are very friendly to the hardware and compiler, but as\n we've seen they offer *awful* semantics to try to write synchronized code with.\n Actually, that's too weak."}, {"sha": "802f3204cd4527f377153349ac025913a16f3292", "filename": "src/doc/nomicon/concurrency.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fconcurrency.md?ref=6210dcdddb7d7dab3f8fd0e9016b119f82408324", "patch": "@@ -7,7 +7,7 @@ an abstraction over them in a relatively uncontroversial way. Message passing,\n green threads, and async APIs are all diverse enough that any abstraction over\n them tends to involve trade-offs that we weren't willing to commit to for 1.0.\n \n-However the way Rust models concurrency makes it relatively easy design your own\n+However the way Rust models concurrency makes it relatively easy to design your own\n concurrency paradigm as a library and have everyone else's code Just Work\n with yours. Just require the right lifetimes and Send and Sync where appropriate\n and you're off to the races. Or rather, off to the... not... having... races."}, {"sha": "29a866063e99674e7fd33738ff15001f30b992d3", "filename": "src/doc/nomicon/destructors.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdestructors.md?ref=6210dcdddb7d7dab3f8fd0e9016b119f82408324", "patch": "@@ -120,7 +120,7 @@ enum Link {\n will have its inner Box field dropped if and only if an instance stores the\n Next variant.\n \n-In general this works really nice because you don't need to worry about\n+In general this works really nicely because you don't need to worry about\n adding/removing drops when you refactor your data layout. Still there's\n certainly many valid usecases for needing to do trickier things with\n destructors."}, {"sha": "5655c5d245ce0638658550e82814e7a6d2389d4b", "filename": "src/doc/nomicon/drop-flags.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fdrop-flags.md", "raw_url": "https://github.com/rust-lang/rust/raw/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fdrop-flags.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdrop-flags.md?ref=6210dcdddb7d7dab3f8fd0e9016b119f82408324", "patch": "@@ -1,7 +1,7 @@\n % Drop Flags\n \n The examples in the previous section introduce an interesting problem for Rust.\n-We have seen that's possible to conditionally initialize, deinitialize, and\n+We have seen that it's possible to conditionally initialize, deinitialize, and\n reinitialize locations of memory totally safely. For Copy types, this isn't\n particularly notable since they're just a random pile of bits. However types\n with destructors are a different story: Rust needs to know whether to call a"}, {"sha": "98d269ff76282a389848b76b9f1e5006753bedc9", "filename": "src/doc/nomicon/dropck.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdropck.md?ref=6210dcdddb7d7dab3f8fd0e9016b119f82408324", "patch": "@@ -1,7 +1,7 @@\n % Drop Check\n \n We have seen how lifetimes provide us some fairly simple rules for ensuring\n-that never read dangling references. However up to this point we have only ever\n+that we never read dangling references. However up to this point we have only ever\n interacted with the *outlives* relationship in an inclusive manner. That is,\n when we talked about `'a: 'b`, it was ok for `'a` to live *exactly* as long as\n `'b`. At first glance, this seems to be a meaningless distinction. Nothing ever"}, {"sha": "8724b97546ea118d5b14993e18144e088a4f429d", "filename": "src/doc/nomicon/send-and-sync.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md?ref=6210dcdddb7d7dab3f8fd0e9016b119f82408324", "patch": "@@ -3,15 +3,15 @@\n Not everything obeys inherited mutability, though. Some types allow you to\n multiply alias a location in memory while mutating it. Unless these types use\n synchronization to manage this access, they are absolutely not thread safe. Rust\n-captures this with through the `Send` and `Sync` traits.\n+captures this through the `Send` and `Sync` traits.\n \n * A type is Send if it is safe to send it to another thread.\n * A type is Sync if it is safe to share between threads (`&T` is Send).\n \n Send and Sync are fundamental to Rust's concurrency story. As such, a\n substantial amount of special tooling exists to make them work right. First and\n foremost, they're [unsafe traits][]. This means that they are unsafe to\n-implement, and other unsafe code can  that they are correctly\n+implement, and other unsafe code can assume that they are correctly\n implemented. Since they're *marker traits* (they have no associated items like\n methods), correctly implemented simply means that they have the intrinsic\n properties an implementor should have. Incorrectly implementing Send or Sync can"}, {"sha": "65dcb6a94e13ccbf9aec33415fc638525202f9b9", "filename": "src/doc/nomicon/subtyping.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fsubtyping.md", "raw_url": "https://github.com/rust-lang/rust/raw/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Fsubtyping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsubtyping.md?ref=6210dcdddb7d7dab3f8fd0e9016b119f82408324", "patch": "@@ -93,8 +93,8 @@ fn main() {\n \n The signature of `overwrite` is clearly valid: it takes mutable references to\n two values of the same type, and overwrites one with the other. If `&mut T` was\n-variant over T, then `&mut &'a str` would be a subtype of `&mut &'static str`,\n-since `&'a str` is a subtype of `&'static str`. Therefore the lifetime of\n+variant over T, then `&mut &'static str` would be a subtype of `&mut &'a str`,\n+since `&'static str` is a subtype of `&'a str`. Therefore the lifetime of\n `forever_str` would successfully be \"shrunk\" down to the shorter lifetime of\n `string`, and `overwrite` would be called successfully. `string` would\n subsequently be dropped, and `forever_str` would point to freed memory when we"}, {"sha": "5ae1818dc630690de2a99a811c7c950f3c03460c", "filename": "src/doc/nomicon/unchecked-uninit.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Funchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Fnomicon%2Funchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Funchecked-uninit.md?ref=6210dcdddb7d7dab3f8fd0e9016b119f82408324", "patch": "@@ -77,7 +77,7 @@ contain any `Drop` types.\n However when working with uninitialized memory you need to be ever-vigilant for\n Rust trying to drop values you make like this before they're fully initialized.\n Every control path through that variable's scope must initialize the value\n-before it ends, if has a destructor.\n+before it ends, if it has a destructor.\n *[This includes code panicking](unwinding.html)*.\n \n And that's about it for working with uninitialized memory! Basically nothing"}, {"sha": "fdb45c32a1d608eeb7d84eda0fcc849d2fc98e62", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=6210dcdddb7d7dab3f8fd0e9016b119f82408324", "patch": "@@ -538,8 +538,9 @@ balanced, but they are otherwise not special.\n In the matcher, `$` _name_ `:` _designator_ matches the nonterminal in the Rust\n syntax named by _designator_. Valid designators are `item`, `block`, `stmt`,\n `pat`, `expr`, `ty` (type), `ident`, `path`, `tt` (either side of the `=>`\n-in macro rules). In the transcriber, the designator is already known, and so\n-only the name of a matched nonterminal comes after the dollar sign.\n+in macro rules), and `meta` (contents of an attribute). In the transcriber, the\n+designator is already known, and so only the name of a matched nonterminal comes\n+after the dollar sign.\n \n In both the matcher and transcriber, the Kleene star-like operator indicates\n repetition. The Kleene star operator consists of `$` and parentheses, optionally"}, {"sha": "26574f15c2c62542475730ea746f5df62b1caf09", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 122, "deletions": 122, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=6210dcdddb7d7dab3f8fd0e9016b119f82408324", "patch": "@@ -39,79 +39,81 @@ match x {\n \n This prints `one or two`.\n \n-# Ranges\n+# Destructuring\n \n-You can match a range of values with `...`:\n+If you have a compound data type, like a [`struct`][struct], you can destructure it\n+inside of a pattern:\n \n ```rust\n-let x = 1;\n-\n-match x {\n-    1 ... 5 => println!(\"one through five\"),\n-    _ => println!(\"anything\"),\n+struct Point {\n+    x: i32,\n+    y: i32,\n }\n-```\n-\n-This prints `one through five`.\n \n-Ranges are mostly used with integers and `char`s:\n-\n-```rust\n-let x = '\ud83d\udc85';\n+let origin = Point { x: 0, y: 0 };\n \n-match x {\n-    'a' ... 'j' => println!(\"early letter\"),\n-    'k' ... 'z' => println!(\"late letter\"),\n-    _ => println!(\"something else\"),\n+match origin {\n+    Point { x, y } => println!(\"({},{})\", x, y),\n }\n ```\n \n-This prints `something else`.\n-\n-# Bindings\n+[struct]: structs.html\n \n-You can bind values to names with `@`:\n+We can use `:` to give a value a different name.\n \n ```rust\n-let x = 1;\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n \n-match x {\n-    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n-    _ => println!(\"anything\"),\n+let origin = Point { x: 0, y: 0 };\n+\n+match origin {\n+    Point { x: x1, y: y1 } => println!(\"({},{})\", x1, y1),\n }\n ```\n \n-This prints `got a range element 1`. This is useful when you want to\n-do a complicated match of part of a data structure:\n+If we only care about some of the values, we don\u2019t have to give them all names:\n \n ```rust\n-#[derive(Debug)]\n-struct Person {\n-    name: Option<String>,\n+struct Point {\n+    x: i32,\n+    y: i32,\n }\n \n-let name = \"Steve\".to_string();\n-let mut x: Option<Person> = Some(Person { name: Some(name) });\n-match x {\n-    Some(Person { name: ref a @ Some(_), .. }) => println!(\"{:?}\", a),\n-    _ => {}\n+let origin = Point { x: 0, y: 0 };\n+\n+match origin {\n+    Point { x, .. } => println!(\"x is {}\", x),\n }\n ```\n \n-This prints `Some(\"Steve\")`: We\u2019ve bound the inner `name` to `a`.\n+This prints `x is 0`.\n \n-If you use `@` with `|`, you need to make sure the name is bound in each part\n-of the pattern:\n+You can do this kind of match on any member, not just the first:\n \n ```rust\n-let x = 5;\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n \n-match x {\n-    e @ 1 ... 5 | e @ 8 ... 10 => println!(\"got a range element {}\", e),\n-    _ => println!(\"anything\"),\n+let origin = Point { x: 0, y: 0 };\n+\n+match origin {\n+    Point { y, .. } => println!(\"y is {}\", y),\n }\n ```\n \n+This prints `y is 0`.\n+\n+This \u2018destructuring\u2019 behavior works on any compound data type, like\n+[tuples][tuples] or [enums][enums].\n+\n+[tuples]: primitive-types.html#tuples\n+[enums]: enums.html\n+\n # Ignoring bindings\n \n You can use `_` in a pattern to disregard the type and value.\n@@ -162,154 +164,152 @@ match x {\n \n This prints `Got a tuple!`.\n \n-# Guards\n+# ref and ref mut\n \n-You can introduce \u2018match guards\u2019 with `if`:\n+If you want to get a [reference][ref], use the `ref` keyword:\n \n ```rust\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-\n-let x = OptionalInt::Value(5);\n+let x = 5;\n \n match x {\n-    OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"),\n-    OptionalInt::Value(..) => println!(\"Got an int!\"),\n-    OptionalInt::Missing => println!(\"No such luck.\"),\n+    ref r => println!(\"Got a reference to {}\", r),\n }\n ```\n \n-This prints `Got an int!`.\n+This prints `Got a reference to 5`.\n \n-If you\u2019re using `if` with multiple patterns, the `if` applies to both sides:\n+[ref]: references-and-borrowing.html\n+\n+Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n+keyword _creates_ a reference, for use in the pattern. If you need a mutable\n+reference, `ref mut` will work in the same way:\n \n ```rust\n-let x = 4;\n-let y = false;\n+let mut x = 5;\n \n match x {\n-    4 | 5 if y => println!(\"yes\"),\n-    _ => println!(\"no\"),\n+    ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n }\n ```\n \n-This prints `no`, because the `if` applies to the whole of `4 | 5`, and not to\n-just the `5`, In other words, the the precedence of `if` behaves like this:\n+# Ranges\n \n-```text\n-(4 | 5) if y => ...\n-```\n+You can match a range of values with `...`:\n \n-not this:\n+```rust\n+let x = 1;\n \n-```text\n-4 | (5 if y) => ...\n+match x {\n+    1 ... 5 => println!(\"one through five\"),\n+    _ => println!(\"anything\"),\n+}\n ```\n \n-# ref and ref mut\n+This prints `one through five`.\n \n-If you want to get a [reference][ref], use the `ref` keyword:\n+Ranges are mostly used with integers and `char`s:\n \n ```rust\n-let x = 5;\n+let x = '\ud83d\udc85';\n \n match x {\n-    ref r => println!(\"Got a reference to {}\", r),\n+    'a' ... 'j' => println!(\"early letter\"),\n+    'k' ... 'z' => println!(\"late letter\"),\n+    _ => println!(\"something else\"),\n }\n ```\n \n-This prints `Got a reference to 5`.\n+This prints `something else`.\n \n-[ref]: references-and-borrowing.html\n+# Bindings\n \n-Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n-keyword _creates_ a reference, for use in the pattern. If you need a mutable\n-reference, `ref mut` will work in the same way:\n+You can bind values to names with `@`:\n \n ```rust\n-let mut x = 5;\n+let x = 1;\n \n match x {\n-    ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n+    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n+    _ => println!(\"anything\"),\n }\n ```\n \n-# Destructuring\n-\n-If you have a compound data type, like a [`struct`][struct], you can destructure it\n-inside of a pattern:\n+This prints `got a range element 1`. This is useful when you want to\n+do a complicated match of part of a data structure:\n \n ```rust\n-struct Point {\n-    x: i32,\n-    y: i32,\n+#[derive(Debug)]\n+struct Person {\n+    name: Option<String>,\n }\n \n-let origin = Point { x: 0, y: 0 };\n-\n-match origin {\n-    Point { x, y } => println!(\"({},{})\", x, y),\n+let name = \"Steve\".to_string();\n+let mut x: Option<Person> = Some(Person { name: Some(name) });\n+match x {\n+    Some(Person { name: ref a @ Some(_), .. }) => println!(\"{:?}\", a),\n+    _ => {}\n }\n ```\n \n-[struct]: structs.html\n+This prints `Some(\"Steve\")`: We\u2019ve bound the inner `name` to `a`.\n \n-We can use `:` to give a value a different name.\n+If you use `@` with `|`, you need to make sure the name is bound in each part\n+of the pattern:\n \n ```rust\n-struct Point {\n-    x: i32,\n-    y: i32,\n-}\n-\n-let origin = Point { x: 0, y: 0 };\n+let x = 5;\n \n-match origin {\n-    Point { x: x1, y: y1 } => println!(\"({},{})\", x1, y1),\n+match x {\n+    e @ 1 ... 5 | e @ 8 ... 10 => println!(\"got a range element {}\", e),\n+    _ => println!(\"anything\"),\n }\n ```\n \n-If we only care about some of the values, we don\u2019t have to give them all names:\n+# Guards\n+\n+You can introduce \u2018match guards\u2019 with `if`:\n \n ```rust\n-struct Point {\n-    x: i32,\n-    y: i32,\n+enum OptionalInt {\n+    Value(i32),\n+    Missing,\n }\n \n-let origin = Point { x: 0, y: 0 };\n+let x = OptionalInt::Value(5);\n \n-match origin {\n-    Point { x, .. } => println!(\"x is {}\", x),\n+match x {\n+    OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"),\n+    OptionalInt::Value(..) => println!(\"Got an int!\"),\n+    OptionalInt::Missing => println!(\"No such luck.\"),\n }\n ```\n \n-This prints `x is 0`.\n+This prints `Got an int!`.\n \n-You can do this kind of match on any member, not just the first:\n+If you\u2019re using `if` with multiple patterns, the `if` applies to both sides:\n \n ```rust\n-struct Point {\n-    x: i32,\n-    y: i32,\n-}\n-\n-let origin = Point { x: 0, y: 0 };\n+let x = 4;\n+let y = false;\n \n-match origin {\n-    Point { y, .. } => println!(\"y is {}\", y),\n+match x {\n+    4 | 5 if y => println!(\"yes\"),\n+    _ => println!(\"no\"),\n }\n ```\n \n-This prints `y is 0`.\n+This prints `no`, because the `if` applies to the whole of `4 | 5`, and not to\n+just the `5`, In other words, the the precedence of `if` behaves like this:\n \n-This \u2018destructuring\u2019 behavior works on any compound data type, like\n-[tuples][tuples] or [enums][enums].\n+```text\n+(4 | 5) if y => ...\n+```\n \n-[tuples]: primitive-types.html#tuples\n-[enums]: enums.html\n+not this:\n+\n+```text\n+4 | (5 if y) => ...\n+```\n \n # Mix and Match\n "}, {"sha": "86b331d220a3b30e0b55ab2d6a672e2271145a14", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6210dcdddb7d7dab3f8fd0e9016b119f82408324/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=6210dcdddb7d7dab3f8fd0e9016b119f82408324", "patch": "@@ -29,6 +29,19 @@ pub use intrinsics::transmute;\n /// `mem::drop` function in that it **does not run the destructor**, leaking the\n /// value and any resources that it owns.\n ///\n+/// There's only a few reasons to use this function. They mainly come\n+/// up in unsafe code or FFI code.\n+///\n+/// * You have an uninitialized value, perhaps for performance reasons, and\n+///   need to prevent the destructor from running on it.\n+/// * You have two copies of a value (like when writing something like\n+///   [`mem::swap`][swap]), but need the destructor to only run once to\n+///   prevent a double `free`.\n+/// * Transferring resources across [FFI][ffi] boundries.\n+///\n+/// [swap]: fn.swap.html\n+/// [ffi]: ../../book/ffi.html\n+///\n /// # Safety\n ///\n /// This function is not marked as `unsafe` as Rust does not guarantee that the\n@@ -52,20 +65,9 @@ pub use intrinsics::transmute;\n /// * `mpsc::{Sender, Receiver}` cycles (they use `Arc` internally)\n /// * Panicking destructors are likely to leak local resources\n ///\n-/// # When To Use\n-///\n-/// There's only a few reasons to use this function. They mainly come\n-/// up in unsafe code or FFI code.\n-///\n-/// * You have an uninitialized value, perhaps for performance reasons, and\n-///   need to prevent the destructor from running on it.\n-/// * You have two copies of a value (like `std::mem::swap`), but need the\n-///   destructor to only run once to prevent a double free.\n-/// * Transferring resources across FFI boundries.\n-///\n /// # Example\n ///\n-/// Leak some heap memory by never deallocating it.\n+/// Leak some heap memory by never deallocating it:\n ///\n /// ```rust\n /// use std::mem;\n@@ -74,7 +76,7 @@ pub use intrinsics::transmute;\n /// mem::forget(heap_memory);\n /// ```\n ///\n-/// Leak an I/O object, never closing the file.\n+/// Leak an I/O object, never closing the file:\n ///\n /// ```rust,no_run\n /// use std::mem;\n@@ -84,7 +86,7 @@ pub use intrinsics::transmute;\n /// mem::forget(file);\n /// ```\n ///\n-/// The swap function uses forget to good effect.\n+/// The `mem::swap` function uses `mem::forget` to good effect:\n ///\n /// ```rust\n /// use std::mem;"}]}