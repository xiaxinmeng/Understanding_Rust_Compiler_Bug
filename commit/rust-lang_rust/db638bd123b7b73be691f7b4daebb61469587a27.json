{"sha": "db638bd123b7b73be691f7b4daebb61469587a27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNjM4YmQxMjNiN2I3M2JlNjkxZjdiNGRhZWJiNjE0Njk1ODdhMjc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-13T22:36:46Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-15T21:29:42Z"}, "message": "hygiene: `modern` -> `normalize_to_macros_2_0`\n\n`modern_and_legacy` -> `normalize_to_macro_rules`", "tree": {"sha": "0560f656fa7f3ada10b04b0e43ff299dd4b0f180", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0560f656fa7f3ada10b04b0e43ff299dd4b0f180"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db638bd123b7b73be691f7b4daebb61469587a27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db638bd123b7b73be691f7b4daebb61469587a27", "html_url": "https://github.com/rust-lang/rust/commit/db638bd123b7b73be691f7b4daebb61469587a27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db638bd123b7b73be691f7b4daebb61469587a27/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c9a38f679a0dd70c65e094f3063318616eb8387", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c9a38f679a0dd70c65e094f3063318616eb8387", "html_url": "https://github.com/rust-lang/rust/commit/8c9a38f679a0dd70c65e094f3063318616eb8387"}], "stats": {"total": 251, "additions": 141, "deletions": 110}, "files": [{"sha": "e1df0e6cde3c88a1ef29dbbf5a48f8d3dabd8be3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -3083,7 +3083,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn hygienic_eq(self, use_name: Ident, def_name: Ident, def_parent_def_id: DefId) -> bool {\n         // We could use `Ident::eq` here, but we deliberately don't. The name\n         // comparison fails frequently, and we want to avoid the expensive\n-        // `modern()` calls required for the span comparison whenever possible.\n+        // `normalize_to_macros_2_0()` calls required for the span comparison whenever possible.\n         use_name.name == def_name.name\n             && use_name\n                 .span\n@@ -3099,7 +3099,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId) -> Ident {\n-        ident.span.modernize_and_adjust(self.expansion_that_defined(scope));\n+        ident.span.normalize_to_macros_2_0_and_adjust(self.expansion_that_defined(scope));\n         ident\n     }\n \n@@ -3109,12 +3109,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         scope: DefId,\n         block: hir::HirId,\n     ) -> (Ident, DefId) {\n-        let scope = match ident.span.modernize_and_adjust(self.expansion_that_defined(scope)) {\n-            Some(actual_expansion) => {\n-                self.hir().definitions().parent_module_of_macro_def(actual_expansion)\n-            }\n-            None => self.parent_module(block),\n-        };\n+        let scope =\n+            match ident.span.normalize_to_macros_2_0_and_adjust(self.expansion_that_defined(scope))\n+            {\n+                Some(actual_expansion) => {\n+                    self.hir().definitions().parent_module_of_macro_def(actual_expansion)\n+                }\n+                None => self.parent_module(block),\n+            };\n         (ident, scope)\n     }\n "}, {"sha": "38089167f5c39e0165e27ff4cac687de9b0f9dad", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -115,7 +115,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             _ => &[],\n         };\n         let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => Some(param.name.modern()),\n+            hir::GenericParamKind::Lifetime { .. } => Some(param.name.normalize_to_macros_2_0()),\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);"}, {"sha": "97711d8c8ffeb7fb78d11b8ffa3d2c558438db01", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -153,7 +153,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// against this list to see if it is already in-scope, or if a definition\n     /// needs to be created for it.\n     ///\n-    /// We always store a `modern()` version of the param-name in this\n+    /// We always store a `normalize_to_macros_2_0()` version of the param-name in this\n     /// vector.\n     in_scope_lifetimes: Vec<ParamName>,\n \n@@ -805,14 +805,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             return;\n         }\n \n-        if self.in_scope_lifetimes.contains(&ParamName::Plain(ident.modern())) {\n+        if self.in_scope_lifetimes.contains(&ParamName::Plain(ident.normalize_to_macros_2_0())) {\n             return;\n         }\n \n         let hir_name = ParamName::Plain(ident);\n \n-        if self.lifetimes_to_define.iter().any(|(_, lt_name)| lt_name.modern() == hir_name.modern())\n-        {\n+        if self.lifetimes_to_define.iter().any(|(_, lt_name)| {\n+            lt_name.normalize_to_macros_2_0() == hir_name.normalize_to_macros_2_0()\n+        }) {\n             return;\n         }\n \n@@ -840,7 +841,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => Some(ParamName::Plain(param.ident.modern())),\n+            GenericParamKind::Lifetime { .. } => {\n+                Some(ParamName::Plain(param.ident.normalize_to_macros_2_0()))\n+            }\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);"}, {"sha": "797387cdced2178846beb6faa256dc1f8a9758a2", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -79,9 +79,9 @@ impl ParamName {\n         }\n     }\n \n-    pub fn modern(&self) -> ParamName {\n+    pub fn normalize_to_macros_2_0(&self) -> ParamName {\n         match *self {\n-            ParamName::Plain(ident) => ParamName::Plain(ident.modern()),\n+            ParamName::Plain(ident) => ParamName::Plain(ident.normalize_to_macros_2_0()),\n             param_name => param_name,\n         }\n     }\n@@ -151,9 +151,11 @@ impl LifetimeName {\n         self == &LifetimeName::Static\n     }\n \n-    pub fn modern(&self) -> LifetimeName {\n+    pub fn normalize_to_macros_2_0(&self) -> LifetimeName {\n         match *self {\n-            LifetimeName::Param(param_name) => LifetimeName::Param(param_name.modern()),\n+            LifetimeName::Param(param_name) => {\n+                LifetimeName::Param(param_name.normalize_to_macros_2_0())\n+            }\n             lifetime_name => lifetime_name,\n         }\n     }"}, {"sha": "28fafb126f4c606fe259be4b29108f89df989f56", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -1088,9 +1088,9 @@ fn create_mono_items_for_default_impls<'tcx>(\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n                 let overridden_methods: FxHashSet<_> =\n-                    items.iter().map(|iiref| iiref.ident.modern()).collect();\n+                    items.iter().map(|iiref| iiref.ident.normalize_to_macros_2_0()).collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n-                    if overridden_methods.contains(&method.ident.modern()) {\n+                    if overridden_methods.contains(&method.ident.normalize_to_macros_2_0()) {\n                         continue;\n                     }\n "}, {"sha": "ce3b1233a74737d94df369fd6caa8ab9c5bad79a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -645,7 +645,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.potentially_unused_imports.push(import);\n                 let imported_binding = self.r.import(binding, import);\n                 if ptr::eq(parent, self.r.graph_root) {\n-                    if let Some(entry) = self.r.extern_prelude.get(&ident.modern()) {\n+                    if let Some(entry) = self.r.extern_prelude.get(&ident.normalize_to_macros_2_0())\n+                    {\n                         if expansion != ExpnId::root()\n                             && orig_name.is_some()\n                             && entry.extern_crate_item.is_none()\n@@ -656,10 +657,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         }\n                     }\n                     let entry =\n-                        self.r.extern_prelude.entry(ident.modern()).or_insert(ExternPreludeEntry {\n-                            extern_crate_item: None,\n-                            introduced_by_item: true,\n-                        });\n+                        self.r.extern_prelude.entry(ident.normalize_to_macros_2_0()).or_insert(\n+                            ExternPreludeEntry {\n+                                extern_crate_item: None,\n+                                introduced_by_item: true,\n+                            },\n+                        );\n                     entry.extern_crate_item = Some(imported_binding);\n                     if orig_name.is_some() {\n                         entry.introduced_by_item = true;\n@@ -1119,7 +1122,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         self.r.local_macro_def_scopes.insert(item.id, parent_scope.module);\n \n         if macro_rules {\n-            let ident = ident.modern();\n+            let ident = ident.normalize_to_macros_2_0();\n             self.r.macro_names.insert(ident);\n             let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {"}, {"sha": "63fbc800ff7067fb280615202ddb4c92f4c2a2c1", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -758,7 +758,7 @@ impl<'a> Resolver<'a> {\n             let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", ident);\n             err.span_note(ident.span, &msg);\n         }\n-        if self.macro_names.contains(&ident.modern()) {\n+        if self.macro_names.contains(&ident.normalize_to_macros_2_0()) {\n             err.help(\"have you added the `#[macro_use]` on the module/import?\");\n         }\n     }"}, {"sha": "681c039211892e3ee01f214572aa259ab73ac445", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -416,7 +416,8 @@ impl<'a> Resolver<'a> {\n                 None => return Err((Undetermined, Weak::Yes)),\n             };\n             let tmp_parent_scope;\n-            let (mut adjusted_parent_scope, mut ident) = (parent_scope, ident.modern());\n+            let (mut adjusted_parent_scope, mut ident) =\n+                (parent_scope, ident.normalize_to_macros_2_0());\n             match ident.span.glob_adjust(module.expansion, glob_import.span) {\n                 Some(Some(def)) => {\n                     tmp_parent_scope ="}, {"sha": "867aa8c63216839d8714821b412589d0e1bb3eaa", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -935,7 +935,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 _ => unreachable!(),\n             };\n \n-            let ident = param.ident.modern();\n+            let ident = param.ident.normalize_to_macros_2_0();\n             debug!(\"with_generic_param_rib: {}\", param.id);\n \n             if seen_bindings.contains_key(&ident) {\n@@ -1464,7 +1464,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // Add the binding to the local ribs, if it doesn't already exist in the bindings map.\n         // (We must not add it if it's in the bindings map because that breaks the assumptions\n         // later passes make about or-patterns.)\n-        let ident = ident.modern_and_legacy();\n+        let ident = ident.normalize_to_macro_rules();\n \n         let mut bound_iter = bindings.iter().filter(|(_, set)| set.contains(&ident));\n         // Already bound in a product pattern? e.g. `(a, a)` which is not allowed.\n@@ -1873,7 +1873,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.diagnostic_metadata.unused_labels.insert(id, label.ident.span);\n             }\n             self.with_label_rib(NormalRibKind, |this| {\n-                let ident = label.ident.modern_and_legacy();\n+                let ident = label.ident.normalize_to_macro_rules();\n                 this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n                 f(this);\n             });\n@@ -1949,7 +1949,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n                 let node_id = self.search_label(label.ident, |rib, ident| {\n-                    rib.bindings.get(&ident.modern_and_legacy()).cloned()\n+                    rib.bindings.get(&ident.normalize_to_macro_rules()).cloned()\n                 });\n                 match node_id {\n                     None => {\n@@ -2115,7 +2115,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n         }\n \n-        ident.span = ident.span.modern();\n+        ident.span = ident.span.normalize_to_macros_2_0();\n         let mut search_module = self.parent_scope.module;\n         loop {\n             self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);"}, {"sha": "7c5b35381f0ec77fab8eed7be3c7de46f244431b", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -62,7 +62,7 @@ impl RegionExt for Region {\n         let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (param.name.modern(), Region::EarlyBound(i, def_id, origin))\n+        (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id, origin))\n     }\n \n     fn late(hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n@@ -73,7 +73,7 @@ impl RegionExt for Region {\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n             param, depth, def_id, origin,\n         );\n-        (param.name.modern(), Region::LateBound(depth, def_id, origin))\n+        (param.name.normalize_to_macros_2_0(), Region::LateBound(depth, def_id, origin))\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -1174,7 +1174,9 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n \n                 Scope::Binder { ref lifetimes, s, .. } => {\n                     // FIXME (#24278): non-hygienic comparison\n-                    if let Some(def) = lifetimes.get(&hir::ParamName::Plain(label.modern())) {\n+                    if let Some(def) =\n+                        lifetimes.get(&hir::ParamName::Plain(label.normalize_to_macros_2_0()))\n+                    {\n                         let hir_id = tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n@@ -1253,7 +1255,7 @@ fn object_lifetime_defaults_for_item(\n     fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound<'_>]) {\n         for bound in bounds {\n             if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n-                set.insert(lifetime.name.modern());\n+                set.insert(lifetime.name.normalize_to_macros_2_0());\n             }\n         }\n     }\n@@ -1791,7 +1793,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Binder { ref lifetimes, s, .. } => {\n                     match lifetime_ref.name {\n                         LifetimeName::Param(param_name) => {\n-                            if let Some(&def) = lifetimes.get(&param_name.modern()) {\n+                            if let Some(&def) = lifetimes.get(&param_name.normalize_to_macros_2_0())\n+                            {\n                                 break Some(def.shifted(late_depth));\n                             }\n                         }\n@@ -2544,7 +2547,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let lifetimes: Vec<_> = params\n             .iter()\n             .filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => Some((param, param.name.modern())),\n+                GenericParamKind::Lifetime { .. } => {\n+                    Some((param, param.name.normalize_to_macros_2_0()))\n+                }\n                 _ => None,\n             })\n             .collect();\n@@ -2661,7 +2666,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n \n                 Scope::Binder { ref lifetimes, s, .. } => {\n-                    if let Some(&def) = lifetimes.get(&param.name.modern()) {\n+                    if let Some(&def) = lifetimes.get(&param.name.normalize_to_macros_2_0()) {\n                         let hir_id = self.tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n@@ -2799,7 +2804,7 @@ fn insert_late_bound_lifetimes(\n                 // `'a: 'b` means both `'a` and `'b` are referenced\n                 appears_in_where_clause\n                     .regions\n-                    .insert(hir::LifetimeName::Param(param.name.modern()));\n+                    .insert(hir::LifetimeName::Param(param.name.normalize_to_macros_2_0()));\n             }\n         }\n     }\n@@ -2821,7 +2826,7 @@ fn insert_late_bound_lifetimes(\n             hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => continue,\n         }\n \n-        let lt_name = hir::LifetimeName::Param(param.name.modern());\n+        let lt_name = hir::LifetimeName::Param(param.name.normalize_to_macros_2_0());\n         // appears in the where clauses? early-bound.\n         if appears_in_where_clause.regions.contains(&lt_name) {\n             continue;\n@@ -2885,7 +2890,7 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name.modern());\n+            self.regions.insert(lifetime_ref.name.normalize_to_macros_2_0());\n         }\n     }\n \n@@ -2902,7 +2907,7 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name.modern());\n+            self.regions.insert(lifetime_ref.name.normalize_to_macros_2_0());\n         }\n     }\n }"}, {"sha": "05d0f2064503364118d708552a2373385b85fc37", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -424,7 +424,7 @@ impl ModuleKind {\n /// program) if all but one of them come from glob imports.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n struct BindingKey {\n-    /// The identifier for the binding, aways the `modern` version of the\n+    /// The identifier for the binding, aways the `normalize_to_macros_2_0` version of the\n     /// identifier.\n     ident: Ident,\n     ns: Namespace,\n@@ -1362,7 +1362,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn new_key(&mut self, ident: Ident, ns: Namespace) -> BindingKey {\n-        let ident = ident.modern();\n+        let ident = ident.normalize_to_macros_2_0();\n         let disambiguator = if ident.name == kw::Underscore {\n             self.underscore_disambiguator += 1;\n             self.underscore_disambiguator\n@@ -1413,7 +1413,7 @@ impl<'a> Resolver<'a> {\n             // Avoid marking `extern crate` items that refer to a name from extern prelude,\n             // but not introduce it, as used if they are accessed from lexical scope.\n             if is_lexical_scope {\n-                if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n+                if let Some(entry) = self.extern_prelude.get(&ident.normalize_to_macros_2_0()) {\n                     if let Some(crate_item) = entry.extern_crate_item {\n                         if ptr::eq(used_binding, crate_item) && !entry.introduced_by_item {\n                             return;\n@@ -1500,7 +1500,7 @@ impl<'a> Resolver<'a> {\n             TypeNS | ValueNS => Scope::Module(module),\n             MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n         };\n-        let mut ident = ident.modern();\n+        let mut ident = ident.normalize_to_macros_2_0();\n         let mut use_prelude = !module.no_implicit_prelude;\n \n         loop {\n@@ -1622,27 +1622,27 @@ impl<'a> Resolver<'a> {\n         if ident.name == kw::Invalid {\n             return Some(LexicalScopeBinding::Res(Res::Err));\n         }\n-        let (general_span, modern_span) = if ident.name == kw::SelfUpper {\n+        let (general_span, normalized_span) = if ident.name == kw::SelfUpper {\n             // FIXME(jseyfried) improve `Self` hygiene\n             let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n             (empty_span, empty_span)\n         } else if ns == TypeNS {\n-            let modern_span = ident.span.modern();\n-            (modern_span, modern_span)\n+            let normalized_span = ident.span.normalize_to_macros_2_0();\n+            (normalized_span, normalized_span)\n         } else {\n-            (ident.span.modern_and_legacy(), ident.span.modern())\n+            (ident.span.normalize_to_macro_rules(), ident.span.normalize_to_macros_2_0())\n         };\n         ident.span = general_span;\n-        let modern_ident = Ident { span: modern_span, ..ident };\n+        let normalized_ident = Ident { span: normalized_span, ..ident };\n \n         // Walk backwards up the ribs in scope.\n         let record_used = record_used_id.is_some();\n         let mut module = self.graph_root;\n         for i in (0..ribs.len()).rev() {\n             debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n             // Use the rib kind to determine whether we are resolving parameters\n-            // (modern hygiene) or local variables (`macro_rules` hygiene).\n-            let rib_ident = if ribs[i].kind.contains_params() { modern_ident } else { ident };\n+            // (macro 2.0 hygiene) or local variables (`macro_rules` hygiene).\n+            let rib_ident = if ribs[i].kind.contains_params() { normalized_ident } else { ident };\n             if let Some(res) = ribs[i].bindings.get(&rib_ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::Res(self.validate_res_from_ribs(\n@@ -1685,7 +1685,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        ident = modern_ident;\n+        ident = normalized_ident;\n         let mut poisoned = None;\n         loop {\n             let opt_module = if let Some(node_id) = record_used_id {\n@@ -1854,14 +1854,14 @@ impl<'a> Resolver<'a> {\n         let mut adjusted_parent_scope = parent_scope;\n         match module {\n             ModuleOrUniformRoot::Module(m) => {\n-                if let Some(def) = ident.span.modernize_and_adjust(m.expansion) {\n+                if let Some(def) = ident.span.normalize_to_macros_2_0_and_adjust(m.expansion) {\n                     tmp_parent_scope =\n                         ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n             }\n             ModuleOrUniformRoot::ExternPrelude => {\n-                ident.span.modernize_and_adjust(ExpnId::root());\n+                ident.span.normalize_to_macros_2_0_and_adjust(ExpnId::root());\n             }\n             ModuleOrUniformRoot::CrateRootAndExternPrelude | ModuleOrUniformRoot::CurrentScope => {\n                 // No adjustments\n@@ -1884,14 +1884,14 @@ impl<'a> Resolver<'a> {\n         let mark = if ident.name == kw::DollarCrate {\n             // When resolving `$crate` from a `macro_rules!` invoked in a `macro`,\n             // we don't want to pretend that the `macro_rules!` definition is in the `macro`\n-            // as described in `SyntaxContext::apply_mark`, so we ignore prepended modern marks.\n+            // as described in `SyntaxContext::apply_mark`, so we ignore prepended opaque marks.\n             // FIXME: This is only a guess and it doesn't work correctly for `macro_rules!`\n             // definitions actually produced by `macro` and `macro` definitions produced by\n             // `macro_rules!`, but at least such configurations are not stable yet.\n-            ctxt = ctxt.modern_and_legacy();\n+            ctxt = ctxt.normalize_to_macro_rules();\n             let mut iter = ctxt.marks().into_iter().rev().peekable();\n             let mut result = None;\n-            // Find the last modern mark from the end if it exists.\n+            // Find the last opaque mark from the end if it exists.\n             while let Some(&(mark, transparency)) = iter.peek() {\n                 if transparency == Transparency::Opaque {\n                     result = Some(mark);\n@@ -1910,7 +1910,7 @@ impl<'a> Resolver<'a> {\n             }\n             result\n         } else {\n-            ctxt = ctxt.modern();\n+            ctxt = ctxt.normalize_to_macros_2_0();\n             ctxt.adjust(ExpnId::root())\n         };\n         let module = match mark {\n@@ -1922,7 +1922,7 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_self(&mut self, ctxt: &mut SyntaxContext, module: Module<'a>) -> Module<'a> {\n         let mut module = self.get_module(module.normal_ancestor_id);\n-        while module.span.ctxt().modern() != *ctxt {\n+        while module.span.ctxt().normalize_to_macros_2_0() != *ctxt {\n             let parent = module.parent.unwrap_or_else(|| self.macro_def_scope(ctxt.remove_mark()));\n             module = self.get_module(parent.normal_ancestor_id);\n         }\n@@ -1990,7 +1990,7 @@ impl<'a> Resolver<'a> {\n \n             if ns == TypeNS {\n                 if allow_super && name == kw::Super {\n-                    let mut ctxt = ident.span.ctxt().modern();\n+                    let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n                     let self_module = match i {\n                         0 => Some(self.resolve_self(&mut ctxt, parent_scope.module)),\n                         _ => match module {\n@@ -2016,7 +2016,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 if i == 0 {\n                     if name == kw::SelfLower {\n-                        let mut ctxt = ident.span.ctxt().modern();\n+                        let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n                         module = Some(ModuleOrUniformRoot::Module(\n                             self.resolve_self(&mut ctxt, parent_scope.module),\n                         ));\n@@ -2430,7 +2430,7 @@ impl<'a> Resolver<'a> {\n         macro_rules: &'a NameBinding<'a>,\n         modularized: &'a NameBinding<'a>,\n     ) -> bool {\n-        // Some non-controversial subset of ambiguities \"modern macro name\" vs \"macro_rules\"\n+        // Some non-controversial subset of ambiguities \"modularized macro name\" vs \"macro_rules\"\n         // is disambiguated to mitigate regressions from macro modularization.\n         // Scoping for `macro_rules` behaves like scoping for `let` at module level, in general.\n         match (\n@@ -2769,7 +2769,7 @@ impl<'a> Resolver<'a> {\n             // Make sure `self`, `super` etc produce an error when passed to here.\n             return None;\n         }\n-        self.extern_prelude.get(&ident.modern()).cloned().and_then(|entry| {\n+        self.extern_prelude.get(&ident.normalize_to_macros_2_0()).cloned().and_then(|entry| {\n             if let Some(binding) = entry.extern_crate_item {\n                 if !speculative && entry.introduced_by_item {\n                     self.record_use(ident, TypeNS, binding, false);"}, {"sha": "058ead95f50bd7494f790cbb85aac3c7f8893909", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -258,7 +258,13 @@ impl<'a> base::Resolver for Resolver<'a> {\n                             force,\n                         ) {\n                             Ok((Some(ext), _)) => {\n-                                let span = path.segments.last().unwrap().ident.span.modern();\n+                                let span = path\n+                                    .segments\n+                                    .last()\n+                                    .unwrap()\n+                                    .ident\n+                                    .span\n+                                    .normalize_to_macros_2_0();\n                                 helper_attrs.extend(\n                                     ext.helper_attrs.iter().map(|name| Ident::new(*name, span)),\n                                 );"}, {"sha": "e073d735a1225a3db7194125b30ebca7ac2533c6", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -201,11 +201,11 @@ impl HygieneData {\n         true\n     }\n \n-    fn modern(&self, ctxt: SyntaxContext) -> SyntaxContext {\n+    fn normalize_to_macros_2_0(&self, ctxt: SyntaxContext) -> SyntaxContext {\n         self.syntax_context_data[ctxt.0 as usize].opaque\n     }\n \n-    fn modern_and_legacy(&self, ctxt: SyntaxContext) -> SyntaxContext {\n+    fn normalize_to_macro_rules(&self, ctxt: SyntaxContext) -> SyntaxContext {\n         self.syntax_context_data[ctxt.0 as usize].opaque_and_semitransparent\n     }\n \n@@ -266,9 +266,9 @@ impl HygieneData {\n \n         let call_site_ctxt = self.expn_data(expn_id).call_site.ctxt();\n         let mut call_site_ctxt = if transparency == Transparency::SemiTransparent {\n-            self.modern(call_site_ctxt)\n+            self.normalize_to_macros_2_0(call_site_ctxt)\n         } else {\n-            self.modern_and_legacy(call_site_ctxt)\n+            self.normalize_to_macro_rules(call_site_ctxt)\n         };\n \n         if call_site_ctxt == SyntaxContext::root() {\n@@ -491,10 +491,10 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.adjust(self, expn_id))\n     }\n \n-    /// Like `SyntaxContext::adjust`, but also modernizes `self`.\n-    pub fn modernize_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n+    /// Like `SyntaxContext::adjust`, but also normalizes `self` to macros 2.0.\n+    pub fn normalize_to_macros_2_0_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n         HygieneData::with(|data| {\n-            *self = data.modern(*self);\n+            *self = data.normalize_to_macros_2_0(*self);\n             data.adjust(self, expn_id)\n         })\n     }\n@@ -527,7 +527,7 @@ impl SyntaxContext {\n     pub fn glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {\n         HygieneData::with(|data| {\n             let mut scope = None;\n-            let mut glob_ctxt = data.modern(glob_span.ctxt());\n+            let mut glob_ctxt = data.normalize_to_macros_2_0(glob_span.ctxt());\n             while !data.is_descendant_of(expn_id, data.outer_expn(glob_ctxt)) {\n                 scope = Some(data.remove_mark(&mut glob_ctxt).0);\n                 if data.remove_mark(self).0 != scope.unwrap() {\n@@ -558,7 +558,7 @@ impl SyntaxContext {\n                 return None;\n             }\n \n-            let mut glob_ctxt = data.modern(glob_span.ctxt());\n+            let mut glob_ctxt = data.normalize_to_macros_2_0(glob_span.ctxt());\n             let mut marks = Vec::new();\n             while !data.is_descendant_of(expn_id, data.outer_expn(glob_ctxt)) {\n                 marks.push(data.remove_mark(&mut glob_ctxt));\n@@ -574,20 +574,20 @@ impl SyntaxContext {\n \n     pub fn hygienic_eq(self, other: SyntaxContext, expn_id: ExpnId) -> bool {\n         HygieneData::with(|data| {\n-            let mut self_modern = data.modern(self);\n-            data.adjust(&mut self_modern, expn_id);\n-            self_modern == data.modern(other)\n+            let mut self_normalized = data.normalize_to_macros_2_0(self);\n+            data.adjust(&mut self_normalized, expn_id);\n+            self_normalized == data.normalize_to_macros_2_0(other)\n         })\n     }\n \n     #[inline]\n-    pub fn modern(self) -> SyntaxContext {\n-        HygieneData::with(|data| data.modern(self))\n+    pub fn normalize_to_macros_2_0(self) -> SyntaxContext {\n+        HygieneData::with(|data| data.normalize_to_macros_2_0(self))\n     }\n \n     #[inline]\n-    pub fn modern_and_legacy(self) -> SyntaxContext {\n-        HygieneData::with(|data| data.modern_and_legacy(self))\n+    pub fn normalize_to_macro_rules(self) -> SyntaxContext {\n+        HygieneData::with(|data| data.normalize_to_macro_rules(self))\n     }\n \n     #[inline]"}, {"sha": "caa50e9a41c0c0998c3c31e4518fbd295d313e38", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -548,9 +548,9 @@ impl Span {\n     }\n \n     #[inline]\n-    pub fn modernize_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n+    pub fn normalize_to_macros_2_0_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n         let mut span = self.data();\n-        let mark = span.ctxt.modernize_and_adjust(expn_id);\n+        let mark = span.ctxt.normalize_to_macros_2_0_and_adjust(expn_id);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n@@ -576,15 +576,15 @@ impl Span {\n     }\n \n     #[inline]\n-    pub fn modern(self) -> Span {\n+    pub fn normalize_to_macros_2_0(self) -> Span {\n         let span = self.data();\n-        span.with_ctxt(span.ctxt.modern())\n+        span.with_ctxt(span.ctxt.normalize_to_macros_2_0())\n     }\n \n     #[inline]\n-    pub fn modern_and_legacy(self) -> Span {\n+    pub fn normalize_to_macro_rules(self) -> Span {\n         let span = self.data();\n-        span.with_ctxt(span.ctxt.modern_and_legacy())\n+        span.with_ctxt(span.ctxt.normalize_to_macro_rules())\n     }\n }\n "}, {"sha": "5760e1d004e038734d200bc76f8e32716d1663dd", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -853,21 +853,21 @@ impl Ident {\n     }\n \n     /// \"Normalize\" ident for use in comparisons using \"item hygiene\".\n-    /// Identifiers with same string value become same if they came from the same \"modern\" macro\n+    /// Identifiers with same string value become same if they came from the same macro 2.0 macro\n     /// (e.g., `macro` item, but not `macro_rules` item) and stay different if they came from\n-    /// different \"modern\" macros.\n+    /// different macro 2.0 macros.\n     /// Technically, this operation strips all non-opaque marks from ident's syntactic context.\n-    pub fn modern(self) -> Ident {\n-        Ident::new(self.name, self.span.modern())\n+    pub fn normalize_to_macros_2_0(self) -> Ident {\n+        Ident::new(self.name, self.span.normalize_to_macros_2_0())\n     }\n \n     /// \"Normalize\" ident for use in comparisons using \"local variable hygiene\".\n     /// Identifiers with same string value become same if they came from the same non-transparent\n     /// macro (e.g., `macro` or `macro_rules!` items) and stay different if they came from different\n     /// non-transparent macros.\n     /// Technically, this operation strips all transparent marks from ident's syntactic context.\n-    pub fn modern_and_legacy(self) -> Ident {\n-        Ident::new(self.name, self.span.modern_and_legacy())\n+    pub fn normalize_to_macro_rules(self) -> Ident {\n+        Ident::new(self.name, self.span.normalize_to_macro_rules())\n     }\n \n     /// Convert the name to a `SymbolStr`. This is a slowish operation because"}, {"sha": "b273efa78276d562903069caed48745f304c7919", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -1441,12 +1441,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n \n-        // We have already adjusted the item name above, so compare with `ident.modern()` instead\n+        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n         // of calling `filter_by_name_and_kind`.\n         let assoc_ty = tcx\n             .associated_items(candidate.def_id())\n             .filter_by_name_unhygienic(assoc_ident.name)\n-            .find(|i| i.kind == ty::AssocKind::Type && i.ident.modern() == assoc_ident)\n+            .find(|i| {\n+                i.kind == ty::AssocKind::Type && i.ident.normalize_to_macros_2_0() == assoc_ident\n+            })\n             .expect(\"missing associated type\");\n \n         if !assoc_ty.vis.is_accessible_from(def_scope, tcx) {\n@@ -2298,12 +2300,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(assoc_ident, trait_did, hir_ref_id);\n \n-        // We have already adjusted the item name above, so compare with `ident.modern()` instead\n+        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n         // of calling `filter_by_name_and_kind`.\n         let item = tcx\n             .associated_items(trait_did)\n             .in_definition_order()\n-            .find(|i| i.kind.namespace() == Namespace::TypeNS && i.ident.modern() == assoc_ident)\n+            .find(|i| {\n+                i.kind.namespace() == Namespace::TypeNS\n+                    && i.ident.normalize_to_macros_2_0() == assoc_ident\n+            })\n             .expect(\"missing associated type\");\n \n         let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, assoc_segment, bound);"}, {"sha": "4531d93c01d27404331ae9000b96f91b55cb45c5", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -1203,7 +1203,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .fields\n             .iter()\n             .enumerate()\n-            .map(|(i, field)| (field.ident.modern(), (i, field)))\n+            .map(|(i, field)| (field.ident.normalize_to_macros_2_0(), (i, field)))\n             .collect::<FxHashMap<_, _>>();\n \n         let mut seen_fields = FxHashMap::default();\n@@ -1469,7 +1469,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let (ident, def_scope) =\n                         self.tcx.adjust_ident_and_get_scope(field, base_def.did, self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;\n-                    if let Some(index) = fields.iter().position(|f| f.ident.modern() == ident) {\n+                    if let Some(index) =\n+                        fields.iter().position(|f| f.ident.normalize_to_macros_2_0() == ident)\n+                    {\n                         let field = &fields[index];\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         // Save the index of all fields regardless of their visibility in case"}, {"sha": "0f3884de84e1282048189a45a90147d4487439bd", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -1023,7 +1023,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .fields\n             .iter()\n             .enumerate()\n-            .map(|(i, field)| (field.ident.modern(), (i, field)))\n+            .map(|(i, field)| (field.ident.normalize_to_macros_2_0(), (i, field)))\n             .collect::<FxHashMap<_, _>>();\n \n         // Keep track of which fields have already appeared in the pattern.\n@@ -1064,7 +1064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut unmentioned_fields = variant\n             .fields\n             .iter()\n-            .map(|field| field.ident.modern())\n+            .map(|field| field.ident.normalize_to_macros_2_0())\n             .filter(|ident| !used_fields.contains_key(&ident))\n             .collect::<Vec<_>>();\n "}, {"sha": "7513759c76b015ffe8675b757592cb26655b93a8", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -26,7 +26,8 @@ impl InherentOverlapChecker<'tcx> {\n             let collision = impl_items2.filter_by_name_unhygienic(item1.ident.name).any(|item2| {\n                 // Symbols and namespace match, compare hygienically.\n                 item1.kind.namespace() == item2.kind.namespace()\n-                    && item1.ident.modern() == item2.ident.modern()\n+                    && item1.ident.normalize_to_macros_2_0()\n+                        == item2.ident.normalize_to_macros_2_0()\n             });\n \n             if collision {\n@@ -50,11 +51,12 @@ impl InherentOverlapChecker<'tcx> {\n             let collision = impl_items2.filter_by_name_unhygienic(item1.ident.name).find(|item2| {\n                 // Symbols and namespace match, compare hygienically.\n                 item1.kind.namespace() == item2.kind.namespace()\n-                    && item1.ident.modern() == item2.ident.modern()\n+                    && item1.ident.normalize_to_macros_2_0()\n+                        == item2.ident.normalize_to_macros_2_0()\n             });\n \n             if let Some(item2) = collision {\n-                let name = item1.ident.modern();\n+                let name = item1.ident.normalize_to_macros_2_0();\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     self.tcx.span_of_impl(item1.def_id).unwrap(),"}, {"sha": "1ffcd7f271ef926c33f8d0c07eac041a08f816bd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -828,7 +828,7 @@ fn convert_variant(\n         .iter()\n         .map(|f| {\n             let fid = tcx.hir().local_def_id(f.hir_id);\n-            let dup_span = seen_fields.get(&f.ident.modern()).cloned();\n+            let dup_span = seen_fields.get(&f.ident.normalize_to_macros_2_0()).cloned();\n             if let Some(prev_span) = dup_span {\n                 struct_span_err!(\n                     tcx.sess,\n@@ -841,7 +841,7 @@ fn convert_variant(\n                 .span_label(prev_span, format!(\"`{}` first declared here\", f.ident))\n                 .emit();\n             } else {\n-                seen_fields.insert(f.ident.modern(), f.span);\n+                seen_fields.insert(f.ident.normalize_to_macros_2_0(), f.span);\n             }\n \n             ty::FieldDef {"}, {"sha": "5fb510d6e33df6d46318da38f69905b785472597", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db638bd123b7b73be691f7b4daebb61469587a27/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=db638bd123b7b73be691f7b4daebb61469587a27", "patch": "@@ -227,7 +227,7 @@ fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_item_refs: &[hir::ImplI\n             hir::ImplItemKind::TyAlias(_) => &mut seen_type_items,\n             _ => &mut seen_value_items,\n         };\n-        match seen_items.entry(impl_item.ident.modern()) {\n+        match seen_items.entry(impl_item.ident.normalize_to_macros_2_0()) {\n             Occupied(entry) => {\n                 let mut err = struct_span_err!(\n                     tcx.sess,"}]}