{"sha": "374ea14412fbb35ca344b7d7cbe67405d63e0e42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NGVhMTQ0MTJmYmIzNWNhMzQ0YjdkN2NiZTY3NDA1ZDYzZTBlNDI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-08T09:16:14Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T15:07:59Z"}, "message": "rustc_mir: expose MIR building through ty::maps::Provider.", "tree": {"sha": "9e4dff90bc33e2b1763b850b6011e613e98e0743", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e4dff90bc33e2b1763b850b6011e613e98e0743"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/374ea14412fbb35ca344b7d7cbe67405d63e0e42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/374ea14412fbb35ca344b7d7cbe67405d63e0e42", "html_url": "https://github.com/rust-lang/rust/commit/374ea14412fbb35ca344b7d7cbe67405d63e0e42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/374ea14412fbb35ca344b7d7cbe67405d63e0e42/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5c4244c6c46df22bb55531b629f4c314fe2ab22", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5c4244c6c46df22bb55531b629f4c314fe2ab22", "html_url": "https://github.com/rust-lang/rust/commit/b5c4244c6c46df22bb55531b629f4c314fe2ab22"}], "stats": {"total": 163, "additions": 104, "deletions": 59}, "files": [{"sha": "c1cfc0234e141c7f8ce2b58515a3b902b164ad4c", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/374ea14412fbb35ca344b7d7cbe67405d63e0e42/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/374ea14412fbb35ca344b7d7cbe67405d63e0e42/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=374ea14412fbb35ca344b7d7cbe67405d63e0e42", "patch": "@@ -872,9 +872,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let index = stability::Index::new(&hir_map);\n \n-    let local_providers = ty::maps::Providers::default();\n-    let mut extern_providers = ty::maps::Providers::default();\n+    let mut local_providers = ty::maps::Providers::default();\n+    mir::mir_map::provide(&mut local_providers);\n \n+    let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n \n     TyCtxt::create_and_enter(sess,"}, {"sha": "dedc55404496a651ce4e6f951068fc6fa8271de9", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 101, "deletions": 57, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/374ea14412fbb35ca344b7d7cbe67405d63e0e42/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/374ea14412fbb35ca344b7d7cbe67405d63e0e42/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=374ea14412fbb35ca344b7d7cbe67405d63e0e42", "patch": "@@ -17,23 +17,25 @@\n //! - `#[rustc_mir(pretty=\"file.mir\")]`\n \n use build;\n+use rustc::hir::def_id::DefId;\n use rustc::dep_graph::DepNode;\n use rustc::mir::Mir;\n use rustc::mir::transform::MirSource;\n use rustc::mir::visit::MutVisitor;\n use pretty;\n use hair::cx::Cx;\n \n-use rustc::infer::InferCtxt;\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::maps::Providers;\n use rustc::ty::subst::Substs;\n use rustc::hir;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n \n+use std::cell::RefCell;\n use std::mem;\n \n pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -42,6 +44,103 @@ pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }.as_deep_visitor());\n }\n \n+pub fn provide(providers: &mut Providers) {\n+    providers.mir = build_mir;\n+}\n+\n+fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                       -> &'tcx RefCell<Mir<'tcx>> {\n+    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let unsupported = || {\n+        span_bug!(tcx.hir.span(id), \"can't build MIR for {:?}\", def_id);\n+    };\n+\n+    // Figure out what primary body this item has.\n+    let body_id = match tcx.hir.get(id) {\n+        hir::map::NodeItem(item) => {\n+            match item.node {\n+                hir::ItemConst(_, body) |\n+                hir::ItemStatic(_, _, body) |\n+                hir::ItemFn(.., body) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeTraitItem(item) => {\n+            match item.node {\n+                hir::TraitItemKind::Const(_, Some(body)) |\n+                hir::TraitItemKind::Method(_,\n+                    hir::TraitMethod::Provided(body)) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeImplItem(item) => {\n+            match item.node {\n+                hir::ImplItemKind::Const(_, body) |\n+                hir::ImplItemKind::Method(_, body) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeExpr(expr) => {\n+            // FIXME(eddyb) Closures should have separate\n+            // function definition IDs and expression IDs.\n+            // Type-checking should not let closures get\n+            // this far in a constant position.\n+            // Assume that everything other than closures\n+            // is a constant \"initializer\" expression.\n+            match expr.node {\n+                hir::ExprClosure(_, _, body, _) => body,\n+                _ => hir::BodyId { node_id: expr.id }\n+            }\n+        }\n+        _ => unsupported()\n+    };\n+\n+    let src = MirSource::from_node(tcx, id);\n+    tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n+        let cx = Cx::new(&infcx, src);\n+        let mut mir = if let MirSource::Fn(id) = src {\n+            // fetch the fully liberated fn signature (that is, all bound\n+            // types/lifetimes replaced)\n+            let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n+\n+            let ty = tcx.item_type(tcx.hir.local_def_id(id));\n+            let (abi, implicit_argument) = if let ty::TyClosure(..) = ty.sty {\n+                (Abi::Rust, Some((closure_self_ty(tcx, id, body_id), None)))\n+            } else {\n+                (ty.fn_abi(), None)\n+            };\n+\n+            let body = tcx.hir.body(body_id);\n+            let explicit_arguments =\n+                body.arguments\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(index, arg)| {\n+                        (fn_sig.inputs()[index], Some(&*arg.pat))\n+                    });\n+\n+            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n+        } else {\n+            build::construct_const(cx, body_id)\n+        };\n+\n+        // Convert the Mir to global types.\n+        let mut globalizer = GlobalizeMir {\n+            tcx: tcx,\n+            span: mir.span\n+        };\n+        globalizer.visit_mir(&mut mir);\n+        let mir = unsafe {\n+            mem::transmute::<Mir, Mir<'tcx>>(mir)\n+        };\n+\n+        pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n+\n+        tcx.alloc_mir(mir)\n+    })\n+}\n+\n /// A pass to lift all the types and substitutions in a Mir\n /// to the global tcx. Sadly, we don't have a \"folder\" that\n /// can change 'tcx so we have to transmute afterwards.\n@@ -79,68 +178,13 @@ struct BuildMir<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n-fn build<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                         body_id: hir::BodyId)\n-                         -> (Mir<'tcx>, MirSource) {\n-    let tcx = infcx.tcx.global_tcx();\n-\n-    let item_id = tcx.hir.body_owner(body_id);\n-    let src = MirSource::from_node(tcx, item_id);\n-    let cx = Cx::new(infcx, src);\n-    if let MirSource::Fn(id) = src {\n-        // fetch the fully liberated fn signature (that is, all bound\n-        // types/lifetimes replaced)\n-        let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n-\n-        let ty = tcx.item_type(tcx.hir.local_def_id(id));\n-        let (abi, implicit_argument) = if let ty::TyClosure(..) = ty.sty {\n-            (Abi::Rust, Some((closure_self_ty(tcx, id, body_id), None)))\n-        } else {\n-            (ty.fn_abi(), None)\n-        };\n-\n-        let body = tcx.hir.body(body_id);\n-        let explicit_arguments =\n-            body.arguments\n-                .iter()\n-                .enumerate()\n-                .map(|(index, arg)| {\n-                    (fn_sig.inputs()[index], Some(&*arg.pat))\n-                });\n-\n-        let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n-        (build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body), src)\n-    } else {\n-        (build::construct_const(cx, body_id), src)\n-    }\n-}\n-\n impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n-        self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n-            let (mut mir, src) = build(&infcx, body_id);\n-\n-            // Convert the Mir to global types.\n-            let tcx = infcx.tcx.global_tcx();\n-            let mut globalizer = GlobalizeMir {\n-                tcx: tcx,\n-                span: mir.span\n-            };\n-            globalizer.visit_mir(&mut mir);\n-            let mir = unsafe {\n-                mem::transmute::<Mir, Mir<'tcx>>(mir)\n-            };\n-\n-            pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n-\n-            let mir = tcx.alloc_mir(mir);\n-            let def_id = tcx.hir.local_def_id(src.item_id());\n-            tcx.maps.mir.borrow_mut().insert(def_id, mir);\n-        });\n+        self.tcx.item_mir(self.tcx.hir.body_owner_def_id(body_id));\n \n         let body = self.tcx.hir.body(body_id);\n         self.visit_body(body);"}]}