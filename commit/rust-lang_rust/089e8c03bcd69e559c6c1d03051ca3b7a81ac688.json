{"sha": "089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "node_id": "C_kwDOAAsO6NoAKDA4OWU4YzAzYmNkNjllNTU5YzZjMWQwMzA1MWNhM2I3YTgxYWM2ODg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-16T23:19:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-16T23:19:34Z"}, "message": "Rollup merge of #107489 - compiler-errors:non_lifetime_binders, r=cjgillot\n\nImplement partial support for non-lifetime binders\n\nThis implements support for non-lifetime binders. It's pretty useless currently, but I wanted to put this up so the implementation can be discussed.\n\nSpecifically, this piggybacks off of the late-bound lifetime collection code in `rustc_hir_typeck::collect::lifetimes`. This seems like a necessary step given the fact we don't resolve late-bound regions until this point, and binders are sometimes merged.\n\nQ: I'm not sure if I should go along this route, or try to modify the earlier nameres code to compute the right bound var indices for type and const binders eagerly... If so, I'll need to rename all these queries to something more appropriate (I've done this for `resolve_lifetime::Region` -> `resolve_lifetime::ResolvedArg`)\n\ncc rust-lang/types-team#81\n\nr? `@ghost`", "tree": {"sha": "e8a41d945816db9e92171388ed76a00ba2394734", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8a41d945816db9e92171388ed76a00ba2394734"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj7roGCRBK7hj4Ov3rIwAAORkIAF575ptKOmj8bJrWm9IrDeWu\nI8NVa1HI7Xg4+Bh0iOUhXM7nJG4smUA4ayXt5f3aIBfXDAN1tuOS8li9X2793wiZ\n4gXJVmFp6JVhONSdl7F4e+PpbMA+iaoJTeJebQCqoiKubPIoeMo53aFlOOTaOvz+\n29maAsBjV01WQ3W9AsDgp7UhyBsy8IvJb/Npx2ZFd2DZ+yg6FKu7IAEGaF/7E8lR\nw6RUFI5VO2OxfYz8bdOt3wPHk/f2lxw+V0lvmyZCoJrEHrSzsRSCmEf2DEfo1Tb7\n1ZTnt/cGrxgv8fre6b9d19ZiyojrnqOlGZp9LUm+AHgS+vZ35ePk06QS7nj79RY=\n=obRg\n-----END PGP SIGNATURE-----\n", "payload": "tree e8a41d945816db9e92171388ed76a00ba2394734\nparent 6379c727ace0cfc1eaab093f297b97e1ffb8bb30\nparent 95f35fe443afd8a0437390973fbd206db9fd7fd4\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1676589574 +0100\ncommitter GitHub <noreply@github.com> 1676589574 +0100\n\nRollup merge of #107489 - compiler-errors:non_lifetime_binders, r=cjgillot\n\nImplement partial support for non-lifetime binders\n\nThis implements support for non-lifetime binders. It's pretty useless currently, but I wanted to put this up so the implementation can be discussed.\n\nSpecifically, this piggybacks off of the late-bound lifetime collection code in `rustc_hir_typeck::collect::lifetimes`. This seems like a necessary step given the fact we don't resolve late-bound regions until this point, and binders are sometimes merged.\n\nQ: I'm not sure if I should go along this route, or try to modify the earlier nameres code to compute the right bound var indices for type and const binders eagerly... If so, I'll need to rename all these queries to something more appropriate (I've done this for `resolve_lifetime::Region` -> `resolve_lifetime::ResolvedArg`)\n\ncc rust-lang/types-team#81\n\nr? `@ghost`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "html_url": "https://github.com/rust-lang/rust/commit/089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6379c727ace0cfc1eaab093f297b97e1ffb8bb30", "url": "https://api.github.com/repos/rust-lang/rust/commits/6379c727ace0cfc1eaab093f297b97e1ffb8bb30", "html_url": "https://github.com/rust-lang/rust/commit/6379c727ace0cfc1eaab093f297b97e1ffb8bb30"}, {"sha": "95f35fe443afd8a0437390973fbd206db9fd7fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/95f35fe443afd8a0437390973fbd206db9fd7fd4", "html_url": "https://github.com/rust-lang/rust/commit/95f35fe443afd8a0437390973fbd206db9fd7fd4"}], "stats": {"total": 1052, "additions": 709, "deletions": 343}, "files": [{"sha": "d1ae8c1fdbd9e246c987adcf9a9e9f6cd667271b", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -294,27 +294,6 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn check_late_bound_lifetime_defs(&self, params: &[GenericParam]) {\n-        // Check only lifetime parameters are present and that the lifetime\n-        // parameters that are present have no bounds.\n-        let non_lt_param_spans: Vec<_> = params\n-            .iter()\n-            .filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => {\n-                    if !param.bounds.is_empty() {\n-                        let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-                        self.session.emit_err(ForbiddenLifetimeBound { spans });\n-                    }\n-                    None\n-                }\n-                _ => Some(param.ident.span),\n-            })\n-            .collect();\n-        if !non_lt_param_spans.is_empty() {\n-            self.session.emit_err(ForbiddenNonLifetimeParam { spans: non_lt_param_spans });\n-        }\n-    }\n-\n     fn check_fn_decl(&self, fn_decl: &FnDecl, self_semantic: SelfSemantic) {\n         self.check_decl_num_args(fn_decl);\n         self.check_decl_cvaradic_pos(fn_decl);\n@@ -745,7 +724,6 @@ impl<'a> AstValidator<'a> {\n                     )\n                     .emit();\n                 });\n-                self.check_late_bound_lifetime_defs(&bfty.generic_params);\n                 if let Extern::Implicit(_) = bfty.ext {\n                     let sig_span = self.session.source_map().next_point(ty.span.shrink_to_lo());\n                     self.maybe_lint_missing_abi(sig_span, ty.id);\n@@ -1318,9 +1296,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 WherePredicate::BoundPredicate(bound_pred) => {\n-                    // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n-                    self.check_late_bound_lifetime_defs(&bound_pred.bound_generic_params);\n-\n                     // This is slightly complicated. Our representation for poly-trait-refs contains a single\n                     // binder and thus we only allow a single level of quantification. However,\n                     // the syntax of Rust permits quantification in two places in where clauses,\n@@ -1396,11 +1371,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_param_bound(self, bound)\n     }\n \n-    fn visit_poly_trait_ref(&mut self, t: &'a PolyTraitRef) {\n-        self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n-        visit::walk_poly_trait_ref(self, t);\n-    }\n-\n     fn visit_variant_data(&mut self, s: &'a VariantData) {\n         self.with_banned_assoc_ty_bound(|this| visit::walk_struct_def(this, s))\n     }\n@@ -1437,10 +1407,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 .emit();\n         }\n \n-        if let FnKind::Closure(ClosureBinder::For { generic_params, .. }, ..) = fk {\n-            self.check_late_bound_lifetime_defs(generic_params);\n-        }\n-\n         if let FnKind::Fn(\n             _,\n             _,"}, {"sha": "3af2ef4e7271eae2db53c73473882d5f205e8750", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -11,6 +11,8 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi;\n \n+use crate::errors::ForbiddenLifetimeBound;\n+\n macro_rules! gate_feature_fn {\n     ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $help: expr) => {{\n         let (visitor, has_feature, span, name, explain, help) =\n@@ -136,6 +138,34 @@ impl<'a> PostExpansionVisitor<'a> {\n         }\n         ImplTraitVisitor { vis: self }.visit_ty(ty);\n     }\n+\n+    fn check_late_bound_lifetime_defs(&self, params: &[ast::GenericParam]) {\n+        // Check only lifetime parameters are present and that the lifetime\n+        // parameters that are present have no bounds.\n+        let non_lt_param_spans: Vec<_> = params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                ast::GenericParamKind::Lifetime { .. } => None,\n+                _ => Some(param.ident.span),\n+            })\n+            .collect();\n+        // FIXME: gate_feature_post doesn't really handle multispans...\n+        if !non_lt_param_spans.is_empty() && !self.features.non_lifetime_binders {\n+            feature_err(\n+                &self.sess.parse_sess,\n+                sym::non_lifetime_binders,\n+                non_lt_param_spans,\n+                rustc_errors::fluent::ast_passes_forbidden_non_lifetime_param,\n+            )\n+            .emit();\n+        }\n+        for param in params {\n+            if !param.bounds.is_empty() {\n+                let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n+                self.sess.emit_err(ForbiddenLifetimeBound { spans });\n+            }\n+        }\n+    }\n }\n \n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n@@ -147,7 +177,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ..\n         }) = attr_info\n         {\n-            gate_feature_fn!(self, has_feature, attr.span, *name, descr);\n+            gate_feature_fn!(self, has_feature, attr.span, *name, *descr);\n         }\n         // Check unstable flavors of the `#[doc]` attribute.\n         if attr.has_name(sym::doc) {\n@@ -306,6 +336,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::TyKind::BareFn(bare_fn_ty) => {\n                 // Function pointers cannot be `const`\n                 self.check_extern(bare_fn_ty.ext, ast::Const::No);\n+                self.check_late_bound_lifetime_defs(&bare_fn_ty.generic_params);\n             }\n             ast::TyKind::Never => {\n                 gate_feature_post!(&self, never_type, ty.span, \"the `!` type is experimental\");\n@@ -318,6 +349,19 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_ty(self, ty)\n     }\n \n+    fn visit_generics(&mut self, g: &'a ast::Generics) {\n+        for predicate in &g.where_clause.predicates {\n+            match predicate {\n+                ast::WherePredicate::BoundPredicate(bound_pred) => {\n+                    // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n+                    self.check_late_bound_lifetime_defs(&bound_pred.bound_generic_params);\n+                }\n+                _ => {}\n+            }\n+        }\n+        visit::walk_generics(self, g);\n+    }\n+\n     fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FnRetTy) {\n         if let ast::FnRetTy::Ty(output_ty) = ret_ty {\n             if let ast::TyKind::Never = output_ty.kind {\n@@ -437,12 +481,21 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_pat(self, pattern)\n     }\n \n+    fn visit_poly_trait_ref(&mut self, t: &'a ast::PolyTraitRef) {\n+        self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n+        visit::walk_poly_trait_ref(self, t);\n+    }\n+\n     fn visit_fn(&mut self, fn_kind: FnKind<'a>, span: Span, _: NodeId) {\n         if let Some(header) = fn_kind.header() {\n             // Stability of const fn methods are covered in `visit_assoc_item` below.\n             self.check_extern(header.ext, header.constness);\n         }\n \n+        if let FnKind::Closure(ast::ClosureBinder::For { generic_params, .. }, ..) = fn_kind {\n+            self.check_late_bound_lifetime_defs(generic_params);\n+        }\n+\n         if fn_kind.ctxt() != Some(FnCtxt::Foreign) && fn_kind.decl().c_variadic() {\n             gate_feature_post!(&self, c_variadic, span, \"C-variadic functions are unstable\");\n         }"}, {"sha": "3d240108b4ab103585579176758d4c8e330a2377", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -731,7 +731,7 @@ pub fn eval_condition(\n                             sess,\n                             sym::cfg_target_compact,\n                             cfg.span,\n-                            &\"compact `cfg(target(..))` is experimental and subject to change\"\n+                            \"compact `cfg(target(..))` is experimental and subject to change\"\n                         ).emit();\n                     }\n "}, {"sha": "7122ccdcd2e9f692acbd17e15d17334e2dd55074", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -473,6 +473,8 @@ declare_features! (\n     (active, no_sanitize, \"1.42.0\", Some(39699), None),\n     /// Allows using the `non_exhaustive_omitted_patterns` lint.\n     (active, non_exhaustive_omitted_patterns_lint, \"1.57.0\", Some(89554), None),\n+    /// Allows `for<T>` binders in where-clauses\n+    (incomplete, non_lifetime_binders, \"CURRENT_RUSTC_VERSION\", Some(1), None),\n     /// Allows making `dyn Trait` well-formed even if `Trait` is not object safe.\n     /// In that case, `dyn Trait: Trait` does not hold. Moreover, coercions and\n     /// casts in safe Rust to `dyn Trait` for such a `Trait` is also forbidden."}, {"sha": "221721f5909b8e7e16ba4c63f235935687834f05", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 75, "deletions": 16, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -14,7 +14,7 @@ use crate::errors::{\n     AmbiguousLifetimeBound, MultipleRelaxedDefaultBounds, TraitObjectDeclaredWithNoTraits,\n     TypeofReservedKeywordUsed, ValueOfAssociatedStructAlreadySpecified,\n };\n-use crate::middle::resolve_lifetime as rl;\n+use crate::middle::resolve_bound_vars as rbv;\n use crate::require_c_abi_if_c_variadic;\n use rustc_ast::TraitObjectSyntax;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -225,10 +225,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let tcx = self.tcx();\n         let lifetime_name = |def_id| tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id));\n \n-        match tcx.named_region(lifetime.hir_id) {\n-            Some(rl::Region::Static) => tcx.lifetimes.re_static,\n+        match tcx.named_bound_var(lifetime.hir_id) {\n+            Some(rbv::ResolvedArg::StaticLifetime) => tcx.lifetimes.re_static,\n \n-            Some(rl::Region::LateBound(debruijn, index, def_id)) => {\n+            Some(rbv::ResolvedArg::LateBound(debruijn, index, def_id)) => {\n                 let name = lifetime_name(def_id.expect_local());\n                 let br = ty::BoundRegion {\n                     var: ty::BoundVar::from_u32(index),\n@@ -237,15 +237,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.mk_re_late_bound(debruijn, br)\n             }\n \n-            Some(rl::Region::EarlyBound(def_id)) => {\n+            Some(rbv::ResolvedArg::EarlyBound(def_id)) => {\n                 let name = tcx.hir().ty_param_name(def_id.expect_local());\n                 let item_def_id = tcx.hir().ty_param_owner(def_id.expect_local());\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n                 tcx.mk_re_early_bound(ty::EarlyBoundRegion { def_id, index, name })\n             }\n \n-            Some(rl::Region::Free(scope, id)) => {\n+            Some(rbv::ResolvedArg::Free(scope, id)) => {\n                 let name = lifetime_name(id.expect_local());\n                 tcx.mk_re_free(scope, ty::BrNamed(id, name))\n \n@@ -1607,7 +1607,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             self.ast_region_to_region(lifetime, None)\n         } else {\n             self.compute_object_lifetime_bound(span, existential_predicates).unwrap_or_else(|| {\n-                if tcx.named_region(lifetime.hir_id).is_some() {\n+                if tcx.named_bound_var(lifetime.hir_id).is_some() {\n                     self.ast_region_to_region(lifetime, None)\n                 } else {\n                     self.re_infer(None, span).unwrap_or_else(|| {\n@@ -2600,6 +2600,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         opt_self_ty: Option<Ty<'tcx>>,\n         path: &hir::Path<'_>,\n+        hir_id: hir::HirId,\n         permit_variants: bool,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n@@ -2663,11 +2664,25 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 });\n \n-                let def_id = def_id.expect_local();\n-                let item_def_id = tcx.hir().ty_param_owner(def_id);\n-                let generics = tcx.generics_of(item_def_id);\n-                let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n-                tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id))\n+                match tcx.named_bound_var(hir_id) {\n+                    Some(rbv::ResolvedArg::LateBound(debruijn, index, _)) => {\n+                        let name =\n+                            tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n+                        let br = ty::BoundTy {\n+                            var: ty::BoundVar::from_u32(index),\n+                            kind: ty::BoundTyKind::Param(def_id, name),\n+                        };\n+                        tcx.mk_ty(ty::Bound(debruijn, br))\n+                    }\n+                    Some(rbv::ResolvedArg::EarlyBound(_)) => {\n+                        let def_id = def_id.expect_local();\n+                        let item_def_id = tcx.hir().ty_param_owner(def_id);\n+                        let generics = tcx.generics_of(item_def_id);\n+                        let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n+                        tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id))\n+                    }\n+                    arg => bug!(\"unexpected bound var resolution for {hir_id:?}: {arg:?}\"),\n+                }\n             }\n             Res::SelfTyParam { .. } => {\n                 // `Self` in trait or type alias.\n@@ -2870,27 +2885,50 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::TyKind::BareFn(bf) => {\n                 require_c_abi_if_c_variadic(tcx, bf.decl, bf.abi, ast_ty.span);\n \n-                tcx.mk_fn_ptr(self.ty_of_fn(\n+                let fn_ptr_ty = tcx.mk_fn_ptr(self.ty_of_fn(\n                     ast_ty.hir_id,\n                     bf.unsafety,\n                     bf.abi,\n                     bf.decl,\n                     None,\n                     Some(ast_ty),\n-                ))\n+                ));\n+\n+                if let Some(guar) =\n+                    deny_non_region_late_bound(tcx, bf.generic_params, \"function pointer\")\n+                {\n+                    tcx.ty_error_with_guaranteed(guar)\n+                } else {\n+                    fn_ptr_ty\n+                }\n             }\n             hir::TyKind::TraitObject(bounds, lifetime, repr) => {\n                 self.maybe_lint_bare_trait(ast_ty, in_path);\n                 let repr = match repr {\n                     TraitObjectSyntax::Dyn | TraitObjectSyntax::None => ty::Dyn,\n                     TraitObjectSyntax::DynStar => ty::DynStar,\n                 };\n-                self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime, borrowed, repr)\n+\n+                let object_ty = self.conv_object_ty_poly_trait_ref(\n+                    ast_ty.span,\n+                    bounds,\n+                    lifetime,\n+                    borrowed,\n+                    repr,\n+                );\n+\n+                if let Some(guar) = bounds.iter().find_map(|trait_ref| {\n+                    deny_non_region_late_bound(tcx, trait_ref.bound_generic_params, \"trait object\")\n+                }) {\n+                    tcx.ty_error_with_guaranteed(guar)\n+                } else {\n+                    object_ty\n+                }\n             }\n             hir::TyKind::Path(hir::QPath::Resolved(maybe_qself, path)) => {\n                 debug!(?maybe_qself, ?path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.ast_ty_to_ty(qself));\n-                self.res_to_ty(opt_self_ty, path, false)\n+                self.res_to_ty(opt_self_ty, path, ast_ty.hir_id, false)\n             }\n             &hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n                 let opaque_ty = tcx.hir().item(item_id);\n@@ -3346,3 +3384,24 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n }\n+\n+fn deny_non_region_late_bound(\n+    tcx: TyCtxt<'_>,\n+    params: &[hir::GenericParam<'_>],\n+    where_: &str,\n+) -> Option<ErrorGuaranteed> {\n+    params.iter().find_map(|bad_param| {\n+        let what = match bad_param.kind {\n+            hir::GenericParamKind::Type { .. } => \"type\",\n+            hir::GenericParamKind::Const { .. } => \"const\",\n+            hir::GenericParamKind::Lifetime { .. } => return None,\n+        };\n+\n+        let mut diag = tcx.sess.struct_span_err(\n+            bad_param.span,\n+            format!(\"late-bound {what} parameter not allowed on {where_} types\"),\n+        );\n+\n+        Some(if tcx.features().non_lifetime_binders { diag.emit() } else { diag.delay_as_bug() })\n+    })\n+}"}, {"sha": "8ebe576a224b3ad6f81c71e9d792f549a0d047a3", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -41,8 +41,8 @@ use std::iter;\n \n mod generics_of;\n mod item_bounds;\n-mod lifetimes;\n mod predicates_of;\n+mod resolve_bound_vars;\n mod type_of;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -53,7 +53,7 @@ fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n }\n \n pub fn provide(providers: &mut Providers) {\n-    lifetimes::provide(providers);\n+    resolve_bound_vars::provide(providers);\n     *providers = Providers {\n         opt_const_param_of: type_of::opt_const_param_of,\n         type_of: type_of::type_of,"}, {"sha": "7bcaeadbcf67b0d0fa648eb7359bdd378587327b", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -1,4 +1,4 @@\n-use crate::middle::resolve_lifetime as rl;\n+use crate::middle::resolve_bound_vars as rbv;\n use hir::{\n     intravisit::{self, Visitor},\n     GenericParamKind, HirId, Node,\n@@ -394,10 +394,11 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n                 return;\n             }\n \n-            match self.tcx.named_region(lt.hir_id) {\n-                Some(rl::Region::Static | rl::Region::EarlyBound(..)) => {}\n-                Some(rl::Region::LateBound(debruijn, _, _)) if debruijn < self.outer_index => {}\n-                Some(rl::Region::LateBound(..) | rl::Region::Free(..)) | None => {\n+            match self.tcx.named_bound_var(lt.hir_id) {\n+                Some(rbv::ResolvedArg::StaticLifetime | rbv::ResolvedArg::EarlyBound(..)) => {}\n+                Some(rbv::ResolvedArg::LateBound(debruijn, _, _))\n+                    if debruijn < self.outer_index => {}\n+                Some(rbv::ResolvedArg::LateBound(..) | rbv::ResolvedArg::Free(..)) | None => {\n                     self.has_late_bound_regions = Some(lt.ident.span);\n                 }\n             }"}, {"sha": "8c388040fbf8676d5d6e8e72ab0ba6a818fd0312", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "renamed", "additions": 223, "deletions": 180, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -16,67 +16,69 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericArg, GenericParam, GenericParamKind, HirIdMap, LifetimeName, Node};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::resolve_lifetime::*;\n+use rustc_middle::middle::resolve_bound_vars::*;\n use rustc_middle::ty::{self, ir::TypeVisitor, DefIdTree, TyCtxt, TypeSuperVisitable};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use std::fmt;\n \n trait RegionExt {\n-    fn early(param: &GenericParam<'_>) -> (LocalDefId, Region);\n+    fn early(param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg);\n \n-    fn late(index: u32, param: &GenericParam<'_>) -> (LocalDefId, Region);\n+    fn late(index: u32, param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg);\n \n     fn id(&self) -> Option<DefId>;\n \n-    fn shifted(self, amount: u32) -> Region;\n+    fn shifted(self, amount: u32) -> ResolvedArg;\n }\n \n-impl RegionExt for Region {\n-    fn early(param: &GenericParam<'_>) -> (LocalDefId, Region) {\n-        debug!(\"Region::early: def_id={:?}\", param.def_id);\n-        (param.def_id, Region::EarlyBound(param.def_id.to_def_id()))\n+impl RegionExt for ResolvedArg {\n+    fn early(param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg) {\n+        debug!(\"ResolvedArg::early: def_id={:?}\", param.def_id);\n+        (param.def_id, ResolvedArg::EarlyBound(param.def_id.to_def_id()))\n     }\n \n-    fn late(idx: u32, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n+    fn late(idx: u32, param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg) {\n         let depth = ty::INNERMOST;\n         debug!(\n-            \"Region::late: idx={:?}, param={:?} depth={:?} def_id={:?}\",\n+            \"ResolvedArg::late: idx={:?}, param={:?} depth={:?} def_id={:?}\",\n             idx, param, depth, param.def_id,\n         );\n-        (param.def_id, Region::LateBound(depth, idx, param.def_id.to_def_id()))\n+        (param.def_id, ResolvedArg::LateBound(depth, idx, param.def_id.to_def_id()))\n     }\n \n     fn id(&self) -> Option<DefId> {\n         match *self {\n-            Region::Static => None,\n+            ResolvedArg::StaticLifetime => None,\n \n-            Region::EarlyBound(id) | Region::LateBound(_, _, id) | Region::Free(_, id) => Some(id),\n+            ResolvedArg::EarlyBound(id)\n+            | ResolvedArg::LateBound(_, _, id)\n+            | ResolvedArg::Free(_, id) => Some(id),\n         }\n     }\n \n-    fn shifted(self, amount: u32) -> Region {\n+    fn shifted(self, amount: u32) -> ResolvedArg {\n         match self {\n-            Region::LateBound(debruijn, idx, id) => {\n-                Region::LateBound(debruijn.shifted_in(amount), idx, id)\n+            ResolvedArg::LateBound(debruijn, idx, id) => {\n+                ResolvedArg::LateBound(debruijn.shifted_in(amount), idx, id)\n             }\n             _ => self,\n         }\n     }\n }\n \n-/// Maps the id of each lifetime reference to the lifetime decl\n+/// Maps the id of each bound variable reference to the variable decl\n /// that it corresponds to.\n ///\n-/// FIXME. This struct gets converted to a `ResolveLifetimes` for\n+/// FIXME. This struct gets converted to a `ResolveBoundVars` for\n /// actual use. It has the same data, but indexed by `LocalDefId`. This\n /// is silly.\n #[derive(Debug, Default)]\n-struct NamedRegionMap {\n-    // maps from every use of a named (not anonymous) lifetime to a\n-    // `Region` describing how that region is bound\n-    defs: HirIdMap<Region>,\n+struct NamedVarMap {\n+    // maps from every use of a named (not anonymous) bound var to a\n+    // `ResolvedArg` describing how that variable is bound\n+    defs: HirIdMap<ResolvedArg>,\n \n     // Maps relevant hir items to the bound vars on them. These include:\n     // - function defs\n@@ -87,9 +89,9 @@ struct NamedRegionMap {\n     late_bound_vars: HirIdMap<Vec<ty::BoundVariableKind>>,\n }\n \n-struct LifetimeContext<'a, 'tcx> {\n+struct BoundVarContext<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    map: &'a mut NamedRegionMap,\n+    map: &'a mut NamedVarMap,\n     scope: ScopeRef<'a>,\n }\n \n@@ -102,7 +104,7 @@ enum Scope<'a> {\n     Binder {\n         /// We use an IndexMap here because we want these lifetimes in order\n         /// for diagnostics.\n-        lifetimes: FxIndexMap<LocalDefId, Region>,\n+        bound_vars: FxIndexMap<LocalDefId, ResolvedArg>,\n \n         scope_type: BinderScopeType,\n \n@@ -141,7 +143,7 @@ enum Scope<'a> {\n     /// inferred in a function body or potentially error outside one),\n     /// for the default choice of lifetime in a trait object type.\n     ObjectLifetimeDefault {\n-        lifetime: Option<Region>,\n+        lifetime: Option<ResolvedArg>,\n         s: ScopeRef<'a>,\n     },\n \n@@ -150,7 +152,7 @@ enum Scope<'a> {\n     /// lifetimes encountered when identifying the trait that an associated type\n     /// is declared on.\n     Supertrait {\n-        lifetimes: Vec<ty::BoundVariableKind>,\n+        bound_vars: Vec<ty::BoundVariableKind>,\n         s: ScopeRef<'a>,\n     },\n \n@@ -185,9 +187,9 @@ struct TruncatedScopeDebug<'a>(&'a Scope<'a>);\n impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.0 {\n-            Scope::Binder { lifetimes, scope_type, hir_id, where_bound_origin, s: _ } => f\n+            Scope::Binder { bound_vars, scope_type, hir_id, where_bound_origin, s: _ } => f\n                 .debug_struct(\"Binder\")\n-                .field(\"lifetimes\", lifetimes)\n+                .field(\"bound_vars\", bound_vars)\n                 .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n                 .field(\"where_bound_origin\", where_bound_origin)\n@@ -202,9 +204,9 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"lifetime\", lifetime)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n-            Scope::Supertrait { lifetimes, s: _ } => f\n+            Scope::Supertrait { bound_vars, s: _ } => f\n                 .debug_struct(\"Supertrait\")\n-                .field(\"lifetimes\", lifetimes)\n+                .field(\"bound_vars\", bound_vars)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::TraitRefBoundary { s: _ } => f.debug_struct(\"TraitRefBoundary\").finish(),\n@@ -219,27 +221,27 @@ type ScopeRef<'a> = &'a Scope<'a>;\n \n pub(crate) fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n-        resolve_lifetimes,\n+        resolve_bound_vars,\n \n-        named_region_map: |tcx, id| tcx.resolve_lifetimes(id).defs.get(&id),\n+        named_variable_map: |tcx, id| tcx.resolve_bound_vars(id).defs.get(&id),\n         is_late_bound_map,\n         object_lifetime_default,\n-        late_bound_vars_map: |tcx, id| tcx.resolve_lifetimes(id).late_bound_vars.get(&id),\n+        late_bound_vars_map: |tcx, id| tcx.resolve_bound_vars(id).late_bound_vars.get(&id),\n \n         ..*providers\n     };\n }\n \n-/// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n+/// Computes the `ResolveBoundVars` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n-/// `named_region_map`, `is_late_bound_map`, etc.\n+/// `named_variable_map`, `is_late_bound_map`, etc.\n #[instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLifetimes {\n-    let mut named_region_map =\n-        NamedRegionMap { defs: Default::default(), late_bound_vars: Default::default() };\n-    let mut visitor = LifetimeContext {\n+fn resolve_bound_vars(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveBoundVars {\n+    let mut named_variable_map =\n+        NamedVarMap { defs: Default::default(), late_bound_vars: Default::default() };\n+    let mut visitor = BoundVarContext {\n         tcx,\n-        map: &mut named_region_map,\n+        map: &mut named_variable_map,\n         scope: &Scope::Root { opt_parent_item: None },\n     };\n     match tcx.hir().owner(local_def_id) {\n@@ -260,13 +262,13 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLife\n         hir::OwnerNode::Crate(_) => {}\n     }\n \n-    let mut rl = ResolveLifetimes::default();\n+    let mut rl = ResolveBoundVars::default();\n \n-    for (hir_id, v) in named_region_map.defs {\n+    for (hir_id, v) in named_variable_map.defs {\n         let map = rl.defs.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n-    for (hir_id, v) in named_region_map.late_bound_vars {\n+    for (hir_id, v) in named_variable_map.late_bound_vars {\n         let map = rl.late_bound_vars.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n@@ -276,21 +278,33 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLife\n     rl\n }\n \n-fn late_region_as_bound_region(tcx: TyCtxt<'_>, region: &Region) -> ty::BoundVariableKind {\n-    match region {\n-        Region::LateBound(_, _, def_id) => {\n+fn late_arg_as_bound_arg<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    arg: &ResolvedArg,\n+    param: &GenericParam<'tcx>,\n+) -> ty::BoundVariableKind {\n+    match arg {\n+        ResolvedArg::LateBound(_, _, def_id) => {\n             let name = tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n-            ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n+                }\n+                GenericParamKind::Type { .. } => {\n+                    ty::BoundVariableKind::Ty(ty::BoundTyKind::Param(*def_id, name))\n+                }\n+                GenericParamKind::Const { .. } => ty::BoundVariableKind::Const,\n+            }\n         }\n-        _ => bug!(\"{:?} is not a late region\", region),\n+        _ => bug!(\"{:?} is not a late argument\", arg),\n     }\n }\n \n-impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n+impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n     /// Returns the binders in scope and the type of `Binder` that should be created for a poly trait ref.\n     fn poly_trait_ref_binder_info(&mut self) -> (Vec<ty::BoundVariableKind>, BinderScopeType) {\n         let mut scope = self.scope;\n-        let mut supertrait_lifetimes = vec![];\n+        let mut supertrait_bound_vars = vec![];\n         loop {\n             match scope {\n                 Scope::Body { .. } | Scope::Root { .. } => {\n@@ -301,29 +315,29 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Supertrait { s, lifetimes } => {\n-                    supertrait_lifetimes = lifetimes.clone();\n+                Scope::Supertrait { s, bound_vars } => {\n+                    supertrait_bound_vars = bound_vars.clone();\n                     scope = s;\n                 }\n \n                 Scope::TraitRefBoundary { .. } => {\n                     // We should only see super trait lifetimes if there is a `Binder` above\n-                    assert!(supertrait_lifetimes.is_empty());\n+                    assert!(supertrait_bound_vars.is_empty());\n                     break (vec![], BinderScopeType::Normal);\n                 }\n \n                 Scope::Binder { hir_id, .. } => {\n                     // Nested poly trait refs have the binders concatenated\n                     let mut full_binders =\n                         self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                    full_binders.extend(supertrait_lifetimes.into_iter());\n+                    full_binders.extend(supertrait_bound_vars.into_iter());\n                     break (full_binders, BinderScopeType::Concatenating);\n                 }\n             }\n         }\n     }\n }\n-impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n     type NestedFilter = nested_filter::OnlyBodies;\n \n     fn nested_visit_map(&mut self) -> Self::Map {\n@@ -386,22 +400,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) =\n+            let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) =\n                 bound_generic_params\n                     .iter()\n-                    .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n                     .enumerate()\n                     .map(|(late_bound_idx, param)| {\n-                        let pair = Region::late(late_bound_idx as u32, param);\n-                        let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                        let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                        let r = late_arg_as_bound_arg(self.tcx, &pair.1, param);\n                         (pair, r)\n                     })\n                     .unzip();\n \n             self.record_late_bound_vars(e.hir_id, binders);\n             let scope = Scope::Binder {\n                 hir_id: e.hir_id,\n-                lifetimes,\n+                bound_vars,\n                 s: self.scope,\n                 scope_type: BinderScopeType::Normal,\n                 where_bound_origin: None,\n@@ -461,7 +474,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // conservatively add all resolved lifetimes. Otherwise we run into problems in\n                 // cases like `type Foo<'a> = impl Bar<As = impl Baz + 'a>`.\n                 let parent_item = self.tcx.hir().get_parent_item(item.hir_id());\n-                let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(parent_item);\n+                let resolved_lifetimes: &ResolveBoundVars =\n+                    self.tcx.resolve_bound_vars(parent_item);\n                 // We need to add *all* deps, since opaque tys may want them from *us*\n                 for (&owner, defs) in resolved_lifetimes.defs.iter() {\n                     defs.iter().for_each(|(&local_id, region)| {\n@@ -478,35 +492,33 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                origin: hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_),\n+                origin: hir::OpaqueTyOrigin::FnReturn(parent) | hir::OpaqueTyOrigin::AsyncFn(parent),\n                 generics,\n                 ..\n             }) => {\n                 // We want to start our early-bound indices at the end of the parent scope,\n                 // not including any parent `impl Trait`s.\n-                let mut lifetimes = FxIndexMap::default();\n+                let mut bound_vars = FxIndexMap::default();\n                 debug!(?generics.params);\n                 for param in generics.params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let (def_id, reg) = Region::early(&param);\n-                            lifetimes.insert(def_id, reg);\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n-                    }\n+                    let (def_id, reg) = ResolvedArg::early(&param);\n+                    bound_vars.insert(def_id, reg);\n                 }\n \n-                let scope = Scope::Binder {\n-                    hir_id: item.hir_id(),\n-                    lifetimes,\n-                    s: self.scope,\n-                    scope_type: BinderScopeType::Normal,\n-                    where_bound_origin: None,\n-                };\n+                let scope = Scope::Root { opt_parent_item: Some(parent) };\n                 self.with(scope, |this| {\n-                    let scope = Scope::TraitRefBoundary { s: this.scope };\n-                    this.with(scope, |this| intravisit::walk_item(this, item))\n-                });\n+                    let scope = Scope::Binder {\n+                        hir_id: item.hir_id(),\n+                        bound_vars,\n+                        s: this.scope,\n+                        scope_type: BinderScopeType::Normal,\n+                        where_bound_origin: None,\n+                    };\n+                    this.with(scope, |this| {\n+                        let scope = Scope::TraitRefBoundary { s: this.scope };\n+                        this.with(scope, |this| intravisit::walk_item(this, item))\n+                    });\n+                })\n             }\n             hir::ItemKind::TyAlias(_, generics)\n             | hir::ItemKind::Enum(_, generics)\n@@ -516,18 +528,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::TraitAlias(generics, ..)\n             | hir::ItemKind::Impl(&hir::Impl { generics, .. }) => {\n                 // These kinds of items have only early-bound lifetime parameters.\n-                let lifetimes = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(Region::early(param)),\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n-                    })\n-                    .collect();\n+                let bound_vars = generics.params.iter().map(ResolvedArg::early).collect();\n                 self.record_late_bound_vars(item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     scope_type: BinderScopeType::Normal,\n                     s: self.scope,\n                     where_bound_origin: None,\n@@ -562,21 +567,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         match ty.kind {\n             hir::TyKind::BareFn(c) => {\n-                let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n+                let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n-                    .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n                     .enumerate()\n                     .map(|(late_bound_idx, param)| {\n-                        let pair = Region::late(late_bound_idx as u32, param);\n-                        let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                        let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                        let r = late_arg_as_bound_arg(self.tcx, &pair.1, param);\n                         (pair, r)\n                     })\n                     .unzip();\n                 self.record_late_bound_vars(ty.hir_id, binders);\n                 let scope = Scope::Binder {\n                     hir_id: ty.hir_id,\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -674,7 +678,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     // well-supported at the moment, so this doesn't work.\n                     // In the future, this should be fixed and this error should be removed.\n                     let def = self.map.defs.get(&lifetime.hir_id).cloned();\n-                    let Some(Region::LateBound(_, _, def_id)) = def else {\n+                    let Some(ResolvedArg::LateBound(_, _, def_id)) = def else {\n                         continue\n                     };\n                     let Some(def_id) = def_id.as_local() else {\n@@ -722,18 +726,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             Type(bounds, ty) => {\n                 let generics = &trait_item.generics;\n-                let lifetimes = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(Region::early(param)),\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n-                    })\n-                    .collect();\n+                let bound_vars = generics.params.iter().map(ResolvedArg::early).collect();\n                 self.record_late_bound_vars(trait_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: trait_item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -768,18 +765,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }),\n             Type(ty) => {\n                 let generics = &impl_item.generics;\n-                let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(Region::early(param)),\n-                        GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => None,\n-                    })\n-                    .collect();\n+                let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> =\n+                    generics.params.iter().map(ResolvedArg::early).collect();\n                 self.record_late_bound_vars(impl_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: impl_item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -803,7 +794,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         match lifetime_ref.res {\n-            hir::LifetimeName::Static => self.insert_lifetime(lifetime_ref, Region::Static),\n+            hir::LifetimeName::Static => {\n+                self.insert_lifetime(lifetime_ref, ResolvedArg::StaticLifetime)\n+            }\n             hir::LifetimeName::Param(param_def_id) => {\n                 self.resolve_lifetime_ref(param_def_id, lifetime_ref)\n             }\n@@ -814,13 +807,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_path(&mut self, path: &hir::Path<'tcx>, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &hir::Path<'tcx>, hir_id: hir::HirId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n             if let Some(args) = segment.args {\n                 self.visit_segment_args(path.res, depth, args);\n             }\n         }\n+        if let Res::Def(DefKind::TyParam | DefKind::ConstParam, param_def_id) = path.res {\n+            self.resolve_type_ref(param_def_id.expect_local(), hir_id);\n+        }\n     }\n \n     fn visit_fn(\n@@ -869,32 +865,25 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         origin,\n                         ..\n                     }) => {\n-                        let lifetimes: FxIndexMap<LocalDefId, Region> =\n+\n+                        let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) =\n                             bound_generic_params\n-                                .iter()\n-                                .filter(|param| {\n-                                    matches!(param.kind, GenericParamKind::Lifetime { .. })\n-                                })\n-                                .enumerate()\n-                                .map(|(late_bound_idx, param)| {\n-                                        Region::late(late_bound_idx as u32, param)\n-                                })\n-                                .collect();\n-                        let binders: Vec<_> =\n-                            lifetimes\n-                                .iter()\n-                                .map(|(_, region)| {\n-                                     late_region_as_bound_region(this.tcx, region)\n-                                })\n-                                .collect();\n+                            .iter()\n+                            .enumerate()\n+                            .map(|(late_bound_idx, param)| {\n+                                let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                                let r = late_arg_as_bound_arg(this.tcx, &pair.1, param);\n+                                (pair, r)\n+                            })\n+                            .unzip();\n                         this.record_late_bound_vars(hir_id, binders.clone());\n                         // Even if there are no lifetimes defined here, we still wrap it in a binder\n                         // scope. If there happens to be a nested poly trait ref (an error), that\n                         // will be `Concatenating` anyways, so we don't have to worry about the depth\n                         // being wrong.\n                         let scope = Scope::Binder {\n                             hir_id,\n-                            lifetimes,\n+                            bound_vars,\n                             s: this.scope,\n                             scope_type: BinderScopeType::Normal,\n                             where_bound_origin: Some(origin),\n@@ -920,7 +909,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 if lt.res != hir::LifetimeName::Static {\n                                     continue;\n                                 }\n-                                this.insert_lifetime(lt, Region::Static);\n+                                this.insert_lifetime(lt, ResolvedArg::StaticLifetime);\n                                 this.tcx\n                                     .sess\n                                     .struct_span_warn(\n@@ -964,7 +953,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.record_late_bound_vars(*hir_id, binders);\n                 let scope = Scope::Binder {\n                     hir_id: *hir_id,\n-                    lifetimes: FxIndexMap::default(),\n+                    bound_vars: FxIndexMap::default(),\n                     s: self.scope,\n                     scope_type,\n                     where_bound_origin: None,\n@@ -983,16 +972,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n         let initial_bound_vars = binders.len() as u32;\n-        let mut lifetimes: FxIndexMap<LocalDefId, Region> = FxIndexMap::default();\n-        let binders_iter = trait_ref\n-            .bound_generic_params\n-            .iter()\n-            .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n-            .enumerate()\n-            .map(|(late_bound_idx, param)| {\n-                let pair = Region::late(initial_bound_vars + late_bound_idx as u32, param);\n-                let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                lifetimes.insert(pair.0, pair.1);\n+        let mut bound_vars: FxIndexMap<LocalDefId, ResolvedArg> = FxIndexMap::default();\n+        let binders_iter =\n+            trait_ref.bound_generic_params.iter().enumerate().map(|(late_bound_idx, param)| {\n+                let pair = ResolvedArg::late(initial_bound_vars + late_bound_idx as u32, param);\n+                let r = late_arg_as_bound_arg(self.tcx, &pair.1, param);\n+                bound_vars.insert(pair.0, pair.1);\n                 r\n             });\n         binders.extend(binders_iter);\n@@ -1006,7 +991,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         // refs.\n         let scope = Scope::Binder {\n             hir_id: trait_ref.trait_ref.hir_ref_id,\n-            lifetimes,\n+            bound_vars,\n             s: self.scope,\n             scope_type,\n             where_bound_origin: None,\n@@ -1063,13 +1048,13 @@ fn object_lifetime_default(tcx: TyCtxt<'_>, param_def_id: DefId) -> ObjectLifeti\n     }\n }\n \n-impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n+impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n     fn with<F>(&mut self, wrap_scope: Scope<'_>, f: F)\n     where\n-        F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n+        F: for<'b> FnOnce(&mut BoundVarContext<'b, 'tcx>),\n     {\n-        let LifetimeContext { tcx, map, .. } = self;\n-        let mut this = LifetimeContext { tcx: *tcx, map, scope: &wrap_scope };\n+        let BoundVarContext { tcx, map, .. } = self;\n+        let mut this = BoundVarContext { tcx: *tcx, map, scope: &wrap_scope };\n         let span = debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n@@ -1110,23 +1095,25 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n     ) where\n-        F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n+        F: for<'b, 'c> FnOnce(&'b mut BoundVarContext<'c, 'tcx>),\n     {\n         let mut named_late_bound_vars = 0;\n-        let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n+        let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> = generics\n             .params\n             .iter()\n-            .filter_map(|param| match param.kind {\n+            .map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n                     if self.tcx.is_late_bound(param.hir_id) {\n                         let late_bound_idx = named_late_bound_vars;\n                         named_late_bound_vars += 1;\n-                        Some(Region::late(late_bound_idx, param))\n+                        ResolvedArg::late(late_bound_idx, param)\n                     } else {\n-                        Some(Region::early(param))\n+                        ResolvedArg::early(param)\n                     }\n                 }\n-                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n+                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n+                    ResolvedArg::early(param)\n+                }\n             })\n             .collect();\n \n@@ -1139,14 +1126,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             })\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n-                let pair = Region::late(late_bound_idx as u32, param);\n-                late_region_as_bound_region(self.tcx, &pair.1)\n+                let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                late_arg_as_bound_arg(self.tcx, &pair.1, param)\n             })\n             .collect();\n         self.record_late_bound_vars(hir_id, binders);\n         let scope = Scope::Binder {\n             hir_id,\n-            lifetimes,\n+            bound_vars,\n             s: self.scope,\n             scope_type: BinderScopeType::Normal,\n             where_bound_origin: None,\n@@ -1177,15 +1164,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Root { opt_parent_item } => {\n                     if let Some(parent_item) = opt_parent_item\n                         && let parent_generics = self.tcx.generics_of(parent_item)\n-                        && parent_generics.param_def_id_to_index.contains_key(&region_def_id.to_def_id())\n+                        && parent_generics.param_def_id_to_index(self.tcx, region_def_id.to_def_id()).is_some()\n                     {\n-                        break Some(Region::EarlyBound(region_def_id.to_def_id()));\n+                        break Some(ResolvedArg::EarlyBound(region_def_id.to_def_id()));\n                     }\n                     break None;\n                 }\n \n-                Scope::Binder { ref lifetimes, scope_type, s, where_bound_origin, .. } => {\n-                    if let Some(&def) = lifetimes.get(&region_def_id) {\n+                Scope::Binder { ref bound_vars, scope_type, s, where_bound_origin, .. } => {\n+                    if let Some(&def) = bound_vars.get(&region_def_id) {\n                         break Some(def.shifted(late_depth));\n                     }\n                     match scope_type {\n@@ -1259,7 +1246,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         };\n \n         if let Some(mut def) = result {\n-            if let Region::EarlyBound(..) = def {\n+            if let ResolvedArg::EarlyBound(..) = def {\n                 // Do not free early-bound regions, only late-bound ones.\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n@@ -1275,10 +1262,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         kind: hir::ImplItemKind::Fn(..),\n                         ..\n                     }) => {\n-                        def = Region::Free(owner_id.to_def_id(), def.id().unwrap());\n+                        def = ResolvedArg::Free(owner_id.to_def_id(), def.id().unwrap());\n                     }\n                     Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(closure), .. }) => {\n-                        def = Region::Free(closure.def_id.to_def_id(), def.id().unwrap());\n+                        def = ResolvedArg::Free(closure.def_id.to_def_id(), def.id().unwrap());\n                     }\n                     _ => {}\n                 }\n@@ -1329,6 +1316,57 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         );\n     }\n \n+    fn resolve_type_ref(&mut self, param_def_id: LocalDefId, hir_id: hir::HirId) {\n+        // Walk up the scope chain, tracking the number of fn scopes\n+        // that we pass through, until we find a lifetime with the\n+        // given name or we run out of scopes.\n+        // search.\n+        let mut late_depth = 0;\n+        let mut scope = self.scope;\n+        let result = loop {\n+            match *scope {\n+                Scope::Body { s, .. } => {\n+                    scope = s;\n+                }\n+\n+                Scope::Root { opt_parent_item } => {\n+                    if let Some(parent_item) = opt_parent_item\n+                        && let parent_generics = self.tcx.generics_of(parent_item)\n+                        && parent_generics.param_def_id_to_index(self.tcx, param_def_id.to_def_id()).is_some()\n+                    {\n+                        break Some(ResolvedArg::EarlyBound(param_def_id.to_def_id()));\n+                    }\n+                    break None;\n+                }\n+\n+                Scope::Binder { ref bound_vars, scope_type, s, .. } => {\n+                    if let Some(&def) = bound_vars.get(&param_def_id) {\n+                        break Some(def.shifted(late_depth));\n+                    }\n+                    match scope_type {\n+                        BinderScopeType::Normal => late_depth += 1,\n+                        BinderScopeType::Concatenating => {}\n+                    }\n+                    scope = s;\n+                }\n+\n+                Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => {\n+                    scope = s;\n+                }\n+            }\n+        };\n+\n+        if let Some(def) = result {\n+            self.map.defs.insert(hir_id, def);\n+            return;\n+        }\n+\n+        span_bug!(self.tcx.hir().span(hir_id), \"could not resolve {param_def_id:?}\",);\n+    }\n+\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_segment_args(\n         &mut self,\n@@ -1415,10 +1453,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     if in_body {\n                         None\n                     } else {\n-                        Some(Region::Static)\n+                        Some(ResolvedArg::StaticLifetime)\n                     }\n                 }\n-                ObjectLifetimeDefault::Static => Some(Region::Static),\n+                ObjectLifetimeDefault::Static => Some(ResolvedArg::StaticLifetime),\n                 ObjectLifetimeDefault::Param(param_def_id) => {\n                     // This index can be used with `generic_args` since `parent_count == 0`.\n                     let index = generics.param_def_id_to_index[&param_def_id] as usize;\n@@ -1507,18 +1545,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // in the trait ref `YY<...>` in `Item: YY<...>`.\n         for binding in generic_args.bindings {\n             let scope = Scope::ObjectLifetimeDefault {\n-                lifetime: if has_lifetime_parameter { None } else { Some(Region::Static) },\n+                lifetime: if has_lifetime_parameter {\n+                    None\n+                } else {\n+                    Some(ResolvedArg::StaticLifetime)\n+                },\n                 s: self.scope,\n             };\n             if let Some(type_def_id) = type_def_id {\n-                let lifetimes = LifetimeContext::supertrait_hrtb_lifetimes(\n-                    self.tcx,\n-                    type_def_id,\n-                    binding.ident,\n-                );\n+                let bound_vars =\n+                    BoundVarContext::supertrait_hrtb_vars(self.tcx, type_def_id, binding.ident);\n                 self.with(scope, |this| {\n                     let scope = Scope::Supertrait {\n-                        lifetimes: lifetimes.unwrap_or_default(),\n+                        bound_vars: bound_vars.unwrap_or_default(),\n                         s: this.scope,\n                     };\n                     this.with(scope, |this| this.visit_assoc_type_binding(binding));\n@@ -1541,7 +1580,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ```\n     /// In this case, if we wanted to the supertrait HRTB lifetimes for `As` on\n     /// the starting trait `Bar`, we would return `Some(['b, 'a])`.\n-    fn supertrait_hrtb_lifetimes(\n+    fn supertrait_hrtb_vars(\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         assoc_name: Ident,\n@@ -1626,7 +1665,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root { .. } | Scope::Elision { .. } => break Region::Static,\n+                Scope::Root { .. } | Scope::Elision { .. } => break ResolvedArg::StaticLifetime,\n \n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n@@ -1641,15 +1680,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: Region) {\n+    fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: ResolvedArg) {\n         debug!(span = ?lifetime_ref.ident.span);\n         self.map.defs.insert(lifetime_ref.hir_id, def);\n     }\n \n     /// Sometimes we resolve a lifetime, but later find that it is an\n     /// error (esp. around impl trait). In that case, we remove the\n     /// entry into `map.defs` so as not to confuse later code.\n-    fn uninsert_lifetime_on_error(&mut self, lifetime_ref: &'tcx hir::Lifetime, bad_def: Region) {\n+    fn uninsert_lifetime_on_error(\n+        &mut self,\n+        lifetime_ref: &'tcx hir::Lifetime,\n+        bad_def: ResolvedArg,\n+    ) {\n         let old_value = self.map.defs.remove(&lifetime_ref.hir_id);\n         assert_eq!(old_value, Some(bad_def));\n     }", "previous_filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs"}, {"sha": "69a7235802bb3d29fcc177f85a43ca6e6fc4faba", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -1740,7 +1740,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match *qpath {\n             QPath::Resolved(ref maybe_qself, ref path) => {\n                 let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself).raw);\n-                let ty = self.astconv().res_to_ty(self_ty, path, true);\n+                let ty = self.astconv().res_to_ty(self_ty, path, hir_id, true);\n                 (path.res, self.handle_raw_ty(path_span, ty))\n             }\n             QPath::TypeRelative(ref qself, ref segment) => {"}, {"sha": "4fe6c6618f69851f7a20aabb8c0b570ab9237d5c", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -2,7 +2,7 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::resolve_lifetime as rl;\n+use rustc_middle::middle::resolve_bound_vars as rbv;\n use rustc_middle::ty::{self, Region, TyCtxt};\n \n /// This function calls the `visit_ty` method for the parameters\n@@ -99,11 +99,11 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n             hir::TyKind::Ref(ref lifetime, _) => {\n                 // the lifetime of the Ref\n                 let hir_id = lifetime.hir_id;\n-                match (self.tcx.named_region(hir_id), self.bound_region) {\n+                match (self.tcx.named_bound_var(hir_id), self.bound_region) {\n                     // Find the index of the named region that was part of the\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n-                    (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n+                    (Some(rbv::ResolvedArg::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                         debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                         if id == def_id {\n                             self.found_type = Some(arg);\n@@ -115,7 +115,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n                     (\n-                        Some(rl::Region::LateBound(debruijn_index, _, id)),\n+                        Some(rbv::ResolvedArg::LateBound(debruijn_index, _, id)),\n                         ty::BrNamed(def_id, _),\n                     ) => {\n                         debug!(\n@@ -131,10 +131,10 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n \n                     (\n                         Some(\n-                            rl::Region::Static\n-                            | rl::Region::Free(_, _)\n-                            | rl::Region::EarlyBound(_)\n-                            | rl::Region::LateBound(_, _, _),\n+                            rbv::ResolvedArg::StaticLifetime\n+                            | rbv::ResolvedArg::Free(_, _)\n+                            | rbv::ResolvedArg::EarlyBound(_)\n+                            | rbv::ResolvedArg::LateBound(_, _, _),\n                         )\n                         | None,\n                         _,\n@@ -186,17 +186,17 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n-        match (self.tcx.named_region(lifetime.hir_id), self.bound_region) {\n+        match (self.tcx.named_bound_var(lifetime.hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n-            (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rbv::ResolvedArg::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                 if id == def_id {\n                     self.found_it = true;\n                     return; // we can stop visiting now\n                 }\n             }\n \n-            (Some(rl::Region::LateBound(debruijn_index, _, id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rbv::ResolvedArg::LateBound(debruijn_index, _, id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\", debruijn_index,);\n                 debug!(\"id={:?}\", id);\n                 debug!(\"def_id={:?}\", def_id);\n@@ -208,10 +208,10 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n \n             (\n                 Some(\n-                    rl::Region::Static\n-                    | rl::Region::EarlyBound(_)\n-                    | rl::Region::LateBound(_, _, _)\n-                    | rl::Region::Free(_, _),\n+                    rbv::ResolvedArg::StaticLifetime\n+                    | rbv::ResolvedArg::EarlyBound(_)\n+                    | rbv::ResolvedArg::LateBound(_, _, _)\n+                    | rbv::ResolvedArg::Free(_, _),\n                 )\n                 | None,\n                 _,"}, {"sha": "cd793d36de6726cb738698ff432c98db5b6d14b1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -2007,7 +2007,7 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives: &[ty::Region<'tcx>],\n         predicate_span: Span,\n     ) -> Vec<(usize, Span)> {\n-        use rustc_middle::middle::resolve_lifetime::Region;\n+        use rustc_middle::middle::resolve_bound_vars::ResolvedArg;\n \n         bounds\n             .iter()\n@@ -2017,8 +2017,8 @@ impl ExplicitOutlivesRequirements {\n                     return None;\n                 };\n \n-                let is_inferred = match tcx.named_region(lifetime.hir_id) {\n-                    Some(Region::EarlyBound(def_id)) => inferred_outlives\n+                let is_inferred = match tcx.named_bound_var(lifetime.hir_id) {\n+                    Some(ResolvedArg::EarlyBound(def_id)) => inferred_outlives\n                         .iter()\n                         .any(|r| matches!(**r, ty::ReEarlyBound(ebr) if { ebr.def_id == def_id })),\n                     _ => false,\n@@ -2097,7 +2097,7 @@ impl ExplicitOutlivesRequirements {\n \n impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        use rustc_middle::middle::resolve_lifetime::Region;\n+        use rustc_middle::middle::resolve_bound_vars::ResolvedArg;\n \n         let def_id = item.owner_id.def_id;\n         if let hir::ItemKind::Struct(_, hir_generics)\n@@ -2120,8 +2120,8 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                 let (relevant_lifetimes, bounds, predicate_span, in_where_clause) =\n                     match where_predicate {\n                         hir::WherePredicate::RegionPredicate(predicate) => {\n-                            if let Some(Region::EarlyBound(region_def_id)) =\n-                                cx.tcx.named_region(predicate.lifetime.hir_id)\n+                            if let Some(ResolvedArg::EarlyBound(region_def_id)) =\n+                                cx.tcx.named_bound_var(predicate.lifetime.hir_id)\n                             {\n                                 (\n                                     Self::lifetimes_outliving_lifetime("}, {"sha": "a9fb8b246c679e48893c09862fce71e8a4a5b4b5", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -18,7 +18,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n-use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use rustc_middle::middle::resolve_bound_vars::ObjectLifetimeDefault;\n use rustc_middle::mir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;"}, {"sha": "0b6774f1b1fe1d0582314b50fa764028cb2a3467", "filename": "compiler/rustc_middle/src/middle/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -29,7 +29,7 @@ pub mod lib_features {\n pub mod limits;\n pub mod privacy;\n pub mod region;\n-pub mod resolve_lifetime;\n+pub mod resolve_bound_vars;\n pub mod stability;\n \n pub fn provide(providers: &mut crate::ty::query::Providers) {"}, {"sha": "b96d07e7dc831cd43ec4156b1ade0d1f38d66c4c", "filename": "compiler/rustc_middle/src/middle/resolve_bound_vars.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -1,4 +1,4 @@\n-//! Name resolution for lifetimes: type declarations.\n+//! Name resolution for lifetimes and late-bound type and const variables: type declarations.\n \n use crate::ty;\n \n@@ -8,10 +8,10 @@ use rustc_hir::{ItemLocalId, OwnerId};\n use rustc_macros::HashStable;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n-pub enum Region {\n-    Static,\n-    EarlyBound(/* lifetime decl */ DefId),\n-    LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* lifetime decl */ DefId),\n+pub enum ResolvedArg {\n+    StaticLifetime,\n+    EarlyBound(/* decl */ DefId),\n+    LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* decl */ DefId),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n \n@@ -46,10 +46,10 @@ pub enum ObjectLifetimeDefault {\n /// Maps the id of each lifetime reference to the lifetime decl\n /// that it corresponds to.\n #[derive(Default, HashStable, Debug)]\n-pub struct ResolveLifetimes {\n+pub struct ResolveBoundVars {\n     /// Maps from every use of a named (not anonymous) lifetime to a\n     /// `Region` describing how that region is bound\n-    pub defs: FxHashMap<OwnerId, FxHashMap<ItemLocalId, Region>>,\n+    pub defs: FxHashMap<OwnerId, FxHashMap<ItemLocalId, ResolvedArg>>,\n \n     pub late_bound_vars: FxHashMap<OwnerId, FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>>,\n }", "previous_filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs"}, {"sha": "c793676146dada41d79cdb742fbad1b58c876415", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -1641,12 +1641,12 @@ rustc_queries! {\n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n     /// See `rustc_resolve::late::lifetimes for details.\n-    query resolve_lifetimes(_: hir::OwnerId) -> &'tcx ResolveLifetimes {\n+    query resolve_bound_vars(_: hir::OwnerId) -> &'tcx ResolveBoundVars {\n         arena_cache\n         desc { \"resolving lifetimes\" }\n     }\n-    query named_region_map(_: hir::OwnerId) ->\n-        Option<&'tcx FxHashMap<ItemLocalId, Region>> {\n+    query named_variable_map(_: hir::OwnerId) ->\n+        Option<&'tcx FxHashMap<ItemLocalId, ResolvedArg>> {\n         desc { \"looking up a named region\" }\n     }\n     query is_late_bound_map(_: hir::OwnerId) -> Option<&'tcx FxIndexSet<ItemLocalId>> {"}, {"sha": "c7268d561e5ea9f5c18cff4d5e266f18fc2bf0e1", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -1,7 +1,9 @@\n+use crate::middle::resolve_bound_vars as rbv;\n use crate::mir::interpret::LitToConstInput;\n use crate::ty::{self, DefIdTree, InternalSubsts, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_macros::HashStable;\n use std::fmt;\n@@ -125,16 +127,27 @@ impl<'tcx> Const<'tcx> {\n             }\n         }\n \n-        use hir::{def::DefKind::ConstParam, def::Res, ExprKind, Path, QPath};\n         match expr.kind {\n-            ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n-                // Find the name and index of the const parameter by indexing the generics of\n-                // the parent item and construct a `ParamConst`.\n-                let item_def_id = tcx.parent(def_id);\n-                let generics = tcx.generics_of(item_def_id);\n-                let index = generics.param_def_id_to_index[&def_id];\n-                let name = tcx.item_name(def_id);\n-                Some(tcx.mk_const(ty::ParamConst::new(index, name), ty))\n+            hir::ExprKind::Path(hir::QPath::Resolved(\n+                _,\n+                &hir::Path { res: Res::Def(DefKind::ConstParam, def_id), .. },\n+            )) => {\n+                match tcx.named_bound_var(expr.hir_id) {\n+                    Some(rbv::ResolvedArg::EarlyBound(_)) => {\n+                        // Find the name and index of the const parameter by indexing the generics of\n+                        // the parent item and construct a `ParamConst`.\n+                        let item_def_id = tcx.parent(def_id);\n+                        let generics = tcx.generics_of(item_def_id);\n+                        let index = generics.param_def_id_to_index[&def_id];\n+                        let name = tcx.item_name(def_id);\n+                        Some(tcx.mk_const(ty::ParamConst::new(index, name), ty))\n+                    }\n+                    Some(rbv::ResolvedArg::LateBound(debruijn, index, _)) => Some(tcx.mk_const(\n+                        ty::ConstKind::Bound(debruijn, ty::BoundVar::from_u32(index)),\n+                        ty,\n+                    )),\n+                    arg => bug!(\"unexpected bound var resolution for {:?}: {arg:?}\", expr.hir_id),\n+                }\n             }\n             _ => None,\n         }"}, {"sha": "f5322006bec0449a34d9497a9f4ca594ec43066c", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -9,7 +9,7 @@ use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::struct_lint_level;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use crate::middle::resolve_lifetime;\n+use crate::middle::resolve_bound_vars;\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstAllocation};\n use crate::mir::{\n@@ -2368,9 +2368,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         Some(&*candidates)\n     }\n \n-    pub fn named_region(self, id: HirId) -> Option<resolve_lifetime::Region> {\n+    pub fn named_bound_var(self, id: HirId) -> Option<resolve_bound_vars::ResolvedArg> {\n         debug!(?id, \"named_region\");\n-        self.named_region_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n+        self.named_variable_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n     }\n \n     pub fn is_late_bound(self, id: HirId) -> bool {"}, {"sha": "106ce9990e1ed1c79f973ccafb43b5e507f6b268", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -290,7 +290,7 @@ impl DeepRejectCtxt {\n             // Impls cannot contain these types as these cannot be named directly.\n             ty::FnDef(..) | ty::Closure(..) | ty::Generator(..) => false,\n \n-            ty::Placeholder(..) => false,\n+            ty::Placeholder(..) | ty::Bound(..) => false,\n \n             // Depending on the value of `treat_obligation_params`, we either\n             // treat generic parameters like placeholders or like inference variables.\n@@ -310,7 +310,7 @@ impl DeepRejectCtxt {\n \n             ty::Error(_) => true,\n \n-            ty::GeneratorWitness(..) | ty::GeneratorWitnessMIR(..) | ty::Bound(..) => {\n+            ty::GeneratorWitness(..) | ty::GeneratorWitnessMIR(..) => {\n                 bug!(\"unexpected obligation type: {:?}\", obligation_ty)\n             }\n         }"}, {"sha": "8849e7eab335c6b100068acc0d7aaf5c6e30bae1", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -57,7 +57,7 @@ trivially_parameterized_over_tcx! {\n     crate::metadata::ModChild,\n     crate::middle::codegen_fn_attrs::CodegenFnAttrs,\n     crate::middle::exported_symbols::SymbolExportInfo,\n-    crate::middle::resolve_lifetime::ObjectLifetimeDefault,\n+    crate::middle::resolve_bound_vars::ObjectLifetimeDefault,\n     crate::mir::ConstQualifs,\n     ty::AssocItemContainer,\n     ty::DeducedParamAttrs,"}, {"sha": "f1128d7c8bb7d39ba09b8919098d74ac1c22483d", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -6,7 +6,7 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use crate::middle::lib_features::LibFeatures;\n use crate::middle::privacy::EffectiveVisibilities;\n-use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLifetimes};\n+use crate::middle::resolve_bound_vars::{ObjectLifetimeDefault, ResolveBoundVars, ResolvedArg};\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;\n use crate::mir::interpret::GlobalId;"}, {"sha": "c1e7f62dea5c82276ddf7298b16d5f8437bc04e0", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -2,7 +2,7 @@ use either::Either;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::middle::resolve_lifetime::Set1;\n+use rustc_middle::middle::resolve_bound_vars::Set1;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{ParamEnv, TyCtxt};"}, {"sha": "7cff8996d248dbdd8e051f0d333ffd4430aa9207", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -18,7 +18,7 @@ use rustc_hir::{\n };\n use rustc_hir::{MethodKind, Target, Unsafety};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use rustc_middle::middle::resolve_bound_vars::ObjectLifetimeDefault;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{ParamEnv, TyCtxt};"}, {"sha": "0a0c94e1dfb6a132f68e4691e4b688c783103d73", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -270,10 +270,11 @@ where\n             | ty::Ref(..)\n             | ty::FnPtr(..)\n             | ty::Param(..)\n+            | ty::Bound(..)\n             | ty::Error(_)\n             | ty::GeneratorWitness(..)\n             | ty::GeneratorWitnessMIR(..) => {}\n-            ty::Bound(..) | ty::Placeholder(..) | ty::Infer(..) => {\n+            ty::Placeholder(..) | ty::Infer(..) => {\n                 bug!(\"unexpected type: {:?}\", ty)\n             }\n         }"}, {"sha": "324de7461cd95431a0a2a6f1e92e4d831d929b55", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -21,7 +21,7 @@ use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::{BindingAnnotation, PrimTy, TraitCandidate};\n-use rustc_middle::middle::resolve_lifetime::Set1;\n+use rustc_middle::middle::resolve_bound_vars::Set1;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::{CrateType, ResolveDocLinks};\n@@ -2505,7 +2505,13 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             let res = match kind {\n                 ItemRibKind(..) | AssocItemRibKind => Res::Def(def_kind, def_id.to_def_id()),\n-                NormalRibKind => Res::Err,\n+                NormalRibKind => {\n+                    if self.r.session.features_untracked().non_lifetime_binders {\n+                        Res::Def(def_kind, def_id.to_def_id())\n+                    } else {\n+                        Res::Err\n+                    }\n+                }\n                 _ => span_bug!(param.ident.span, \"Unexpected rib kind {:?}\", kind),\n             };\n             self.r.record_partial_res(param.id, PartialRes::new(res));"}, {"sha": "bd32adbbdbb54b21f0dff197c86d88ae73bead47", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -4,7 +4,7 @@ use crate::cgu_reuse_tracker::CguReuse;\n use crate::parse::ParseSess;\n use rustc_ast::token;\n use rustc_ast::util::literal::LitError;\n-use rustc_errors::MultiSpan;\n+use rustc_errors::{error_code, DiagnosticMessage, EmissionGuarantee, IntoDiagnostic, MultiSpan};\n use rustc_macros::Diagnostic;\n use rustc_span::{Span, Symbol};\n use rustc_target::spec::{SplitDebuginfo, StackProtector, TargetTriple};\n@@ -27,12 +27,22 @@ pub struct CguNotRecorded<'a> {\n     pub cgu_name: &'a str,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(session_feature_gate_error, code = \"E0658\")]\n-pub struct FeatureGateError<'a> {\n-    #[primary_span]\n+pub struct FeatureGateError {\n     pub span: MultiSpan,\n-    pub explain: &'a str,\n+    pub explain: DiagnosticMessage,\n+}\n+\n+impl<'a, T: EmissionGuarantee> IntoDiagnostic<'a, T> for FeatureGateError {\n+    #[track_caller]\n+    fn into_diagnostic(\n+        self,\n+        handler: &'a rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'a, T> {\n+        let mut diag = handler.struct_diagnostic(self.explain);\n+        diag.set_span(self.span);\n+        diag.code(error_code!(E0658));\n+        diag\n+    }\n }\n \n #[derive(Subdiagnostic)]"}, {"sha": "cbdcc5581e5eea3146980c55f926b278c95bf79b", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -88,7 +88,7 @@ pub fn feature_err<'a>(\n     sess: &'a ParseSess,\n     feature: Symbol,\n     span: impl Into<MultiSpan>,\n-    explain: &str,\n+    explain: impl Into<DiagnosticMessage>,\n ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     feature_err_issue(sess, feature, span, GateIssue::Language, explain)\n }\n@@ -103,7 +103,7 @@ pub fn feature_err_issue<'a>(\n     feature: Symbol,\n     span: impl Into<MultiSpan>,\n     issue: GateIssue,\n-    explain: &str,\n+    explain: impl Into<DiagnosticMessage>,\n ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     let span = span.into();\n \n@@ -114,7 +114,7 @@ pub fn feature_err_issue<'a>(\n             .map(|err| err.cancel());\n     }\n \n-    let mut err = sess.create_err(FeatureGateError { span, explain });\n+    let mut err = sess.create_err(FeatureGateError { span, explain: explain.into() });\n     add_feature_diagnostics_for_issue(&mut err, sess, feature, issue);\n     err\n }"}, {"sha": "37d2aea42ad8f40284609a8d118e61700373bf9c", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -1016,6 +1016,7 @@ symbols! {\n         non_ascii_idents,\n         non_exhaustive,\n         non_exhaustive_omitted_patterns_lint,\n+        non_lifetime_binders,\n         non_modrs_mods,\n         nontemporal_store,\n         noop_method_borrow,"}, {"sha": "91d96655b64e2f532e5c6213c2c701f0984a34fd", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -60,7 +60,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     ) -> Option<(DefId, SubstsRef<'tcx>)> {\n         let tcx = self.tcx;\n         let param_env = obligation.param_env;\n-        let trait_ref = tcx.erase_late_bound_regions(trait_ref);\n+        let trait_ref = self.instantiate_binder_with_placeholders(trait_ref);\n         let trait_self_ty = trait_ref.self_ty();\n \n         let mut self_match_impls = vec![];"}, {"sha": "45a4cf2a083102e14f39114d0562a0eba5a8e68b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -1056,7 +1056,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n         let self_ty = self.resolve_vars_if_possible(trait_pred.self_ty());\n-        let ty = self.tcx.erase_late_bound_regions(self_ty);\n+        let ty = self.instantiate_binder_with_placeholders(self_ty);\n         let Some(generics) = self.tcx.hir().get_generics(obligation.cause.body_id) else { return false };\n         let ty::Ref(_, inner_ty, hir::Mutability::Not) = ty.kind() else { return false };\n         let ty::Param(param) = inner_ty.kind() else { return false };"}, {"sha": "dae602908a31f6edf7da836778e8e8055e1b81c6", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -396,7 +396,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // still be provided by a manual implementation for\n                     // this trait and type.\n                 }\n-                ty::Param(..) | ty::Alias(ty::Projection, ..) => {\n+                ty::Param(..)\n+                | ty::Alias(ty::Projection, ..)\n+                | ty::Placeholder(..)\n+                | ty::Bound(..) => {\n                     // In these cases, we don't know what the actual\n                     // type is. Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n@@ -448,6 +451,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         );\n \n         self.infcx.probe(|_snapshot| {\n+            if obligation.has_non_region_late_bound() {\n+                return;\n+            }\n+\n             // The code below doesn't care about regions, and the\n             // self-ty here doesn't escape this probe, so just erase\n             // any LBR."}, {"sha": "10af968e34f883f2557ec7f8460f9aa8c2b38747", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -21,7 +21,7 @@ use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::PredicateOrigin;\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n-use rustc_middle::middle::resolve_lifetime as rl;\n+use rustc_middle::middle::resolve_bound_vars as rbv;\n use rustc_middle::ty::fold::ir::TypeFolder;\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::TypeVisitable;\n@@ -200,11 +200,11 @@ fn clean_poly_trait_ref_with_bindings<'tcx>(\n }\n \n fn clean_lifetime<'tcx>(lifetime: &hir::Lifetime, cx: &mut DocContext<'tcx>) -> Lifetime {\n-    let def = cx.tcx.named_region(lifetime.hir_id);\n+    let def = cx.tcx.named_bound_var(lifetime.hir_id);\n     if let Some(\n-        rl::Region::EarlyBound(node_id)\n-        | rl::Region::LateBound(_, _, node_id)\n-        | rl::Region::Free(_, node_id),\n+        rbv::ResolvedArg::EarlyBound(node_id)\n+        | rbv::ResolvedArg::LateBound(_, _, node_id)\n+        | rbv::ResolvedArg::Free(_, node_id),\n     ) = def\n     {\n         if let Some(lt) = cx.substs.get(&node_id).and_then(|p| p.as_lt()).cloned() {"}, {"sha": "fc550936165e63e21fadaf8a66f30d67549e31f1", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -505,13 +505,13 @@ fn check_mut_from_ref<'tcx>(cx: &LateContext<'tcx>, sig: &FnSig<'_>, body: Optio\n     if let FnRetTy::Return(ty) = sig.decl.output\n         && let Some((out, Mutability::Mut, _)) = get_ref_lm(ty)\n     {\n-        let out_region = cx.tcx.named_region(out.hir_id);\n+        let out_region = cx.tcx.named_bound_var(out.hir_id);\n         let args: Option<Vec<_>> = sig\n             .decl\n             .inputs\n             .iter()\n             .filter_map(get_ref_lm)\n-            .filter(|&(lt, _, _)| cx.tcx.named_region(lt.hir_id) == out_region)\n+            .filter(|&(lt, _, _)| cx.tcx.named_bound_var(lt.hir_id) == out_region)\n             .map(|(_, mutability, span)| (mutability == Mutability::Not).then_some(span))\n             .collect();\n         if let Some(args) = args"}, {"sha": "a3427e21cde2d7e957b3b33a75c93f5290172238", "filename": "tests/ui/bounds-lifetime.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Fbounds-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Fbounds-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbounds-lifetime.stderr?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -16,17 +16,24 @@ error: lifetime bounds cannot be used in this context\n LL | type C = for<'b, 'a: 'b +> fn();\n    |                      ^^\n \n-error: only lifetime parameters can be used in this context\n+error[E0658]: only lifetime parameters can be used in this context\n   --> $DIR/bounds-lifetime.rs:4:18\n    |\n LL | type D = for<'a, T> fn();\n    |                  ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n \n-error: only lifetime parameters can be used in this context\n+error[E0658]: only lifetime parameters can be used in this context\n   --> $DIR/bounds-lifetime.rs:5:18\n    |\n LL | type E = dyn for<T> Fn();\n    |                  ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n \n error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "9f4deaa774dd76ba2e18ffa7344624127463fa31", "filename": "tests/ui/closures/binder/disallow-const.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Fclosures%2Fbinder%2Fdisallow-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Fclosures%2Fbinder%2Fdisallow-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2Fbinder%2Fdisallow-const.stderr?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -1,8 +1,12 @@\n-error: only lifetime parameters can be used in this context\n+error[E0658]: only lifetime parameters can be used in this context\n   --> $DIR/disallow-const.rs:4:15\n    |\n LL |     for<const N: i32> || -> () {};\n    |               ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "22882ca2ba67ac4af6de0f7919edae809ffb6b4d", "filename": "tests/ui/closures/binder/disallow-ty.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Fclosures%2Fbinder%2Fdisallow-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Fclosures%2Fbinder%2Fdisallow-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2Fbinder%2Fdisallow-ty.stderr?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -1,8 +1,12 @@\n-error: only lifetime parameters can be used in this context\n+error[E0658]: only lifetime parameters can be used in this context\n   --> $DIR/disallow-ty.rs:4:9\n    |\n LL |     for<T> || -> () {};\n    |         ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "69b0f74115684fc2de26ee4dad1fd41735a05f7e", "filename": "tests/ui/conditional-compilation/cfg-generic-params.stderr", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Fconditional-compilation%2Fcfg-generic-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Fconditional-compilation%2Fcfg-generic-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconditional-compilation%2Fcfg-generic-params.stderr?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -1,21 +1,3 @@\n-error: only lifetime parameters can be used in this context\n-  --> $DIR/cfg-generic-params.rs:7:45\n-   |\n-LL | type FnBad = for<#[cfg(no)] 'a, #[cfg(yes)] T> fn();\n-   |                                             ^\n-\n-error: only lifetime parameters can be used in this context\n-  --> $DIR/cfg-generic-params.rs:11:51\n-   |\n-LL | type PolyBad = dyn for<#[cfg(no)] 'a, #[cfg(yes)] T> Copy;\n-   |                                                   ^\n-\n-error: only lifetime parameters can be used in this context\n-  --> $DIR/cfg-generic-params.rs:15:54\n-   |\n-LL | struct WhereBad where for<#[cfg(no)] 'a, #[cfg(yes)] T> u8: Copy;\n-   |                                                      ^\n-\n error: cannot find attribute `unknown` in this scope\n   --> $DIR/cfg-generic-params.rs:19:29\n    |\n@@ -46,5 +28,33 @@ error: cannot find attribute `unknown` in this scope\n LL | struct WhereYes where for<#[cfg_attr(yes, unknown)] 'a> u8: Copy;\n    |                                           ^^^^^^^\n \n+error[E0658]: only lifetime parameters can be used in this context\n+  --> $DIR/cfg-generic-params.rs:7:45\n+   |\n+LL | type FnBad = for<#[cfg(no)] 'a, #[cfg(yes)] T> fn();\n+   |                                             ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n+\n+error[E0658]: only lifetime parameters can be used in this context\n+  --> $DIR/cfg-generic-params.rs:11:51\n+   |\n+LL | type PolyBad = dyn for<#[cfg(no)] 'a, #[cfg(yes)] T> Copy;\n+   |                                                   ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n+\n+error[E0658]: only lifetime parameters can be used in this context\n+  --> $DIR/cfg-generic-params.rs:15:54\n+   |\n+LL | struct WhereBad where for<#[cfg(no)] 'a, #[cfg(yes)] T> u8: Copy;\n+   |                                                      ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n+\n error: aborting due to 8 previous errors\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "221e9133fcc6b67750d064b8b19907c3dd2282b0", "filename": "tests/ui/feature-gates/feature-gate-non_lifetime_binders.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_lifetime_binders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_lifetime_binders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_lifetime_binders.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -0,0 +1,4 @@\n+fn foo() where for<T> T:, {}\n+//~^ ERROR only lifetime parameters can be used in this context\n+\n+fn main() {}"}, {"sha": "75645e324017d833f833c52d1237662558940c4a", "filename": "tests/ui/feature-gates/feature-gate-non_lifetime_binders.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_lifetime_binders.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_lifetime_binders.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_lifetime_binders.stderr?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: only lifetime parameters can be used in this context\n+  --> $DIR/feature-gate-non_lifetime_binders.rs:1:20\n+   |\n+LL | fn foo() where for<T> T:, {}\n+   |                    ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "d605c9e0df7e41af48c57f9ebe5e601d0abb6f6a", "filename": "tests/ui/higher-rank-trait-bounds/hrtb-wrong-kind.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-wrong-kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-wrong-kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-wrong-kind.stderr?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -1,14 +1,21 @@\n-error: only lifetime parameters can be used in this context\n+error[E0658]: only lifetime parameters can be used in this context\n   --> $DIR/hrtb-wrong-kind.rs:1:18\n    |\n LL | fn a() where for<T> T: Copy {}\n    |                  ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n \n-error: only lifetime parameters can be used in this context\n+error[E0658]: only lifetime parameters can be used in this context\n   --> $DIR/hrtb-wrong-kind.rs:4:24\n    |\n LL | fn b() where for<const C: usize> [(); C]: Copy {}\n    |                        ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "069fcffe9a0dfbed581f0441ce4698b6e4964804", "filename": "tests/ui/parser/recover-fn-ptr-with-generics.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Fparser%2Frecover-fn-ptr-with-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Fparser%2Frecover-fn-ptr-with-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Frecover-fn-ptr-with-generics.stderr?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -88,12 +88,6 @@ error: expected identifier, found `>`\n LL |     type QuiteBroken = fn<const>();\n    |                                ^ expected identifier\n \n-error: lifetime bounds cannot be used in this context\n-  --> $DIR/recover-fn-ptr-with-generics.rs:22:26\n-   |\n-LL |     let _: extern fn<'a: 'static>();\n-   |                          ^^^^^^^\n-\n error[E0412]: cannot find type `T` in this scope\n   --> $DIR/recover-fn-ptr-with-generics.rs:5:27\n    |\n@@ -106,6 +100,12 @@ error[E0412]: cannot find type `T` in this scope\n LL |     type Identity = fn<T>(T) -> T;\n    |                                 ^ not found in this scope\n \n+error: lifetime bounds cannot be used in this context\n+  --> $DIR/recover-fn-ptr-with-generics.rs:22:26\n+   |\n+LL |     let _: extern fn<'a: 'static>();\n+   |                          ^^^^^^^\n+\n error: aborting due to 12 previous errors\n \n For more information about this error, try `rustc --explain E0412`."}, {"sha": "a797aae65dba24335d5f7bd406f0cd0ead76d049", "filename": "tests/ui/traits/non_lifetime_binders/basic.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbasic.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+// Basic test that show's we can succesfully typeck a `for<T>` where clause.\n+\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+trait Trait {}\n+\n+impl<T: ?Sized> Trait for T {}\n+\n+fn foo()\n+where\n+    for<T> T: Trait,\n+{\n+}\n+\n+fn main() {\n+    foo();\n+}"}, {"sha": "fddc5d9fc2548bd2306849b43a6ee7e8b1bbdfa8", "filename": "tests/ui/traits/non_lifetime_binders/basic.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbasic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbasic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbasic.stderr?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/basic.rs:4:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "460f68907e889c344f6d463bd67c8a3365f9208a", "filename": "tests/ui/traits/non_lifetime_binders/fail.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Ffail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Ffail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Ffail.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -0,0 +1,23 @@\n+// Error reporting for where `for<T> T: Trait` doesn't hold\n+\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+trait Trait {}\n+\n+fn fail()\n+where\n+    for<T> T: Trait,\n+{}\n+\n+fn auto_trait()\n+where\n+    for<T> T: Send,\n+{}\n+\n+fn main() {\n+    fail();\n+    //~^ ERROR the trait bound `T: Trait` is not satisfied\n+    auto_trait();\n+    //~^ ERROR `T` cannot be sent between threads safely\n+}"}, {"sha": "ba5953193a47bed948a457aa897ba7a135f89daf", "filename": "tests/ui/traits/non_lifetime_binders/fail.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Ffail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Ffail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Ffail.stderr?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -0,0 +1,43 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/fail.rs:3:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0277]: the trait bound `T: Trait` is not satisfied\n+  --> $DIR/fail.rs:19:5\n+   |\n+LL |     fail();\n+   |     ^^^^ the trait `Trait` is not implemented for `T`\n+   |\n+note: required by a bound in `fail`\n+  --> $DIR/fail.rs:10:15\n+   |\n+LL | fn fail()\n+   |    ---- required by a bound in this\n+LL | where\n+LL |     for<T> T: Trait,\n+   |               ^^^^^ required by this bound in `fail`\n+\n+error[E0277]: `T` cannot be sent between threads safely\n+  --> $DIR/fail.rs:21:5\n+   |\n+LL |     auto_trait();\n+   |     ^^^^^^^^^^ `T` cannot be sent between threads safely\n+   |\n+   = help: the trait `Send` is not implemented for `T`\n+note: required by a bound in `auto_trait`\n+  --> $DIR/fail.rs:15:15\n+   |\n+LL | fn auto_trait()\n+   |    ---------- required by a bound in this\n+LL | where\n+LL |     for<T> T: Send,\n+   |               ^^^^ required by this bound in `auto_trait`\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8fb7dd27605f931492beff78ec15f9fdf3d01a8f", "filename": "tests/ui/traits/non_lifetime_binders/on-dyn.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-dyn.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -0,0 +1,13 @@\n+// Tests to make sure that we reject polymorphic dyn trait.\n+\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+trait Test<T> {}\n+\n+fn foo() -> &'static dyn for<T> Test<T> {\n+    //~^ ERROR late-bound type parameter not allowed on trait object types\n+    todo!()\n+}\n+\n+fn main() {}"}, {"sha": "44071107de4119aa2f5115a4e9589b4af1faa7b2", "filename": "tests/ui/traits/non_lifetime_binders/on-dyn.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-dyn.stderr?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -0,0 +1,17 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/on-dyn.rs:3:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: late-bound type parameter not allowed on trait object types\n+  --> $DIR/on-dyn.rs:8:30\n+   |\n+LL | fn foo() -> &'static dyn for<T> Test<T> {\n+   |                              ^\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "0aaff52b6d8cda6eb4af0905844401c848da21b0", "filename": "tests/ui/traits/non_lifetime_binders/on-ptr.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-ptr.rs?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -0,0 +1,13 @@\n+// Tests to make sure that we reject polymorphic fn ptrs.\n+\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+fn foo() -> for<T> fn(T) {\n+    //~^ ERROR late-bound type parameter not allowed on function pointer types\n+    todo!()\n+}\n+\n+fn main() {\n+    foo()(1i32);\n+}"}, {"sha": "bb7dccaf07d5f0f001deebc3440f8d9a1be6cd6d", "filename": "tests/ui/traits/non_lifetime_binders/on-ptr.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/089e8c03bcd69e559c6c1d03051ca3b7a81ac688/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-ptr.stderr?ref=089e8c03bcd69e559c6c1d03051ca3b7a81ac688", "patch": "@@ -0,0 +1,17 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/on-ptr.rs:3:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: late-bound type parameter not allowed on function pointer types\n+  --> $DIR/on-ptr.rs:6:17\n+   |\n+LL | fn foo() -> for<T> fn(T) {\n+   |                 ^\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}]}