{"sha": "cacc75c82ebe15cf63d31034fcf7f1016cddf0e2", "node_id": "C_kwDOAAsO6NoAKGNhY2M3NWM4MmViZTE1Y2Y2M2QzMTAzNGZjZjdmMTAxNmNkZGYwZTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-16T21:09:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-16T21:09:30Z"}, "message": "Auto merge of #97936 - nnethercote:compile-unicode_normalization-faster, r=oli-obk\n\nCompile `unicode-normalization` faster\n\nVarious optimizations and cleanups aimed at improving compilation of `unicode-normalization`, which is notable for having several very large `match`es with many char ranges.\n\nBest reviewed one commit at a time.\n\nr? `@oli-obk`", "tree": {"sha": "719c53fb234600332277aea52fd4f3a475b539c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/719c53fb234600332277aea52fd4f3a475b539c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cacc75c82ebe15cf63d31034fcf7f1016cddf0e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cacc75c82ebe15cf63d31034fcf7f1016cddf0e2", "html_url": "https://github.com/rust-lang/rust/commit/cacc75c82ebe15cf63d31034fcf7f1016cddf0e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cacc75c82ebe15cf63d31034fcf7f1016cddf0e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bebee73397b692e84b9cc1b6af439fae78918c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bebee73397b692e84b9cc1b6af439fae78918c9", "html_url": "https://github.com/rust-lang/rust/commit/3bebee73397b692e84b9cc1b6af439fae78918c9"}, {"sha": "bdbf9b297b2d3372dfe70763643942e008933207", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdbf9b297b2d3372dfe70763643942e008933207", "html_url": "https://github.com/rust-lang/rust/commit/bdbf9b297b2d3372dfe70763643942e008933207"}], "stats": {"total": 202, "additions": 87, "deletions": 115}, "files": [{"sha": "c6298904140c39ef9166191ac078d9b597ba18ed", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cacc75c82ebe15cf63d31034fcf7f1016cddf0e2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cacc75c82ebe15cf63d31034fcf7f1016cddf0e2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=cacc75c82ebe15cf63d31034fcf7f1016cddf0e2", "patch": "@@ -227,15 +227,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     _ => (None, 0),\n                 };\n                 if let Some((min, max, sz)) = range {\n-                    if let (Some(lo), Some(hi)) = (lo.try_to_bits(sz), hi.try_to_bits(sz)) {\n-                        // We want to compare ranges numerically, but the order of the bitwise\n-                        // representation of signed integers does not match their numeric order.\n-                        // Thus, to correct the ordering, we need to shift the range of signed\n-                        // integers to correct the comparison. This is achieved by XORing with a\n-                        // bias (see pattern/_match.rs for another pertinent example of this\n-                        // pattern).\n-                        let (lo, hi) = (lo ^ bias, hi ^ bias);\n-                        if lo <= min && (hi > max || hi == max && end == RangeEnd::Included) {\n+                    // We want to compare ranges numerically, but the order of the bitwise\n+                    // representation of signed integers does not match their numeric order. Thus,\n+                    // to correct the ordering, we need to shift the range of signed integers to\n+                    // correct the comparison. This is achieved by XORing with a bias (see\n+                    // pattern/_match.rs for another pertinent example of this pattern).\n+                    //\n+                    // Also, for performance, it's important to only do the second `try_to_bits` if\n+                    // necessary.\n+                    let lo = lo.try_to_bits(sz).unwrap() ^ bias;\n+                    if lo <= min {\n+                        let hi = hi.try_to_bits(sz).unwrap() ^ bias;\n+                        if hi > max || hi == max && end == RangeEnd::Included {\n                             // Irrefutable pattern match.\n                             return Ok(());\n                         }"}, {"sha": "598da80c574aff45ba7d4684fb4d307c86f16dd0", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cacc75c82ebe15cf63d31034fcf7f1016cddf0e2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cacc75c82ebe15cf63d31034fcf7f1016cddf0e2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=cacc75c82ebe15cf63d31034fcf7f1016cddf0e2", "patch": "@@ -632,39 +632,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             (&TestKind::Range(test), &PatKind::Range(pat)) => {\n+                use std::cmp::Ordering::*;\n+\n                 if test == pat {\n                     self.candidate_without_match_pair(match_pair_index, candidate);\n                     return Some(0);\n                 }\n \n-                let no_overlap = (|| {\n-                    use rustc_hir::RangeEnd::*;\n-                    use std::cmp::Ordering::*;\n-\n-                    let tcx = self.tcx;\n-\n-                    let test_ty = test.lo.ty();\n-                    let lo = compare_const_vals(tcx, test.lo, pat.hi, self.param_env, test_ty)?;\n-                    let hi = compare_const_vals(tcx, test.hi, pat.lo, self.param_env, test_ty)?;\n-\n-                    match (test.end, pat.end, lo, hi) {\n-                        // pat < test\n-                        (_, _, Greater, _) |\n-                        (_, Excluded, Equal, _) |\n-                        // pat > test\n-                        (_, _, _, Less) |\n-                        (Excluded, _, _, Equal) => Some(true),\n-                        _ => Some(false),\n-                    }\n-                })();\n-\n-                if let Some(true) = no_overlap {\n-                    // Testing range does not overlap with pattern range,\n-                    // so the pattern can be matched only if this test fails.\n+                // For performance, it's important to only do the second\n+                // `compare_const_vals` if necessary.\n+                let no_overlap = if matches!(\n+                    (compare_const_vals(self.tcx, test.hi, pat.lo, self.param_env)?, test.end),\n+                    (Less, _) | (Equal, RangeEnd::Excluded) // test < pat\n+                ) || matches!(\n+                    (compare_const_vals(self.tcx, test.lo, pat.hi, self.param_env)?, pat.end),\n+                    (Greater, _) | (Equal, RangeEnd::Excluded) // test > pat\n+                ) {\n                     Some(1)\n                 } else {\n                     None\n-                }\n+                };\n+\n+                // If the testing range does not overlap with pattern range,\n+                // the pattern can be matched only if this test fails.\n+                no_overlap\n             }\n \n             (&TestKind::Range(range), &PatKind::Constant { value }) => {\n@@ -768,15 +759,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> Option<bool> {\n         use std::cmp::Ordering::*;\n \n-        let tcx = self.tcx;\n-\n-        let a = compare_const_vals(tcx, range.lo, value, self.param_env, range.lo.ty())?;\n-        let b = compare_const_vals(tcx, value, range.hi, self.param_env, range.lo.ty())?;\n-\n-        match (b, range.end) {\n-            (Less, _) | (Equal, RangeEnd::Included) if a != Greater => Some(true),\n-            _ => Some(false),\n-        }\n+        // For performance, it's important to only do the second\n+        // `compare_const_vals` if necessary.\n+        Some(\n+            matches!(compare_const_vals(self.tcx, range.lo, value, self.param_env)?, Less | Equal)\n+                && matches!(\n+                    (compare_const_vals(self.tcx, value, range.hi, self.param_env)?, range.end),\n+                    (Less, _) | (Equal, RangeEnd::Included)\n+                ),\n+        )\n     }\n \n     fn values_not_contained_in_range("}, {"sha": "60db98073a3b91776504b854718a6f88ffb494ad", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cacc75c82ebe15cf63d31034fcf7f1016cddf0e2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cacc75c82ebe15cf63d31034fcf7f1016cddf0e2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=cacc75c82ebe15cf63d31034fcf7f1016cddf0e2", "patch": "@@ -828,14 +828,8 @@ impl<'tcx> Constructor<'tcx> {\n                 FloatRange(other_from, other_to, other_end),\n             ) => {\n                 match (\n-                    compare_const_vals(pcx.cx.tcx, *self_to, *other_to, pcx.cx.param_env, pcx.ty),\n-                    compare_const_vals(\n-                        pcx.cx.tcx,\n-                        *self_from,\n-                        *other_from,\n-                        pcx.cx.param_env,\n-                        pcx.ty,\n-                    ),\n+                    compare_const_vals(pcx.cx.tcx, *self_to, *other_to, pcx.cx.param_env),\n+                    compare_const_vals(pcx.cx.tcx, *self_from, *other_from, pcx.cx.param_env),\n                 ) {\n                     (Some(to), Some(from)) => {\n                         (from == Ordering::Greater || from == Ordering::Equal)\n@@ -848,16 +842,7 @@ impl<'tcx> Constructor<'tcx> {\n             (Str(self_val), Str(other_val)) => {\n                 // FIXME Once valtrees are available we can directly use the bytes\n                 // in the `Str` variant of the valtree for the comparison here.\n-                match compare_const_vals(\n-                    pcx.cx.tcx,\n-                    *self_val,\n-                    *other_val,\n-                    pcx.cx.param_env,\n-                    pcx.ty,\n-                ) {\n-                    Some(comparison) => comparison == Ordering::Equal,\n-                    None => false,\n-                }\n+                self_val == other_val\n             }\n             (Slice(self_slice), Slice(other_slice)) => self_slice.is_covered_by(*other_slice),\n "}, {"sha": "a13748a2d474ad1b92e74f24de438222379b376b", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 47, "deletions": 54, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/cacc75c82ebe15cf63d31034fcf7f1016cddf0e2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cacc75c82ebe15cf63d31034fcf7f1016cddf0e2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=cacc75c82ebe15cf63d31034fcf7f1016cddf0e2", "patch": "@@ -15,8 +15,9 @@ use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::RangeEnd;\n use rustc_index::vec::Idx;\n-use rustc_middle::mir::interpret::{get_slice_bytes, ConstValue};\n-use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n+use rustc_middle::mir::interpret::{\n+    ConstValue, ErrorHandled, LitToConstError, LitToConstInput, Scalar,\n+};\n use rustc_middle::mir::{self, UserTypeProjection};\n use rustc_middle::mir::{BorrowKind, Field, Mutability};\n use rustc_middle::thir::{Ascription, BindingMode, FieldPat, LocalVarId, Pat, PatKind, PatRange};\n@@ -129,7 +130,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     ) -> PatKind<'tcx> {\n         assert_eq!(lo.ty(), ty);\n         assert_eq!(hi.ty(), ty);\n-        let cmp = compare_const_vals(self.tcx, lo, hi, self.param_env, ty);\n+        let cmp = compare_const_vals(self.tcx, lo, hi, self.param_env);\n         match (end, cmp) {\n             // `x..y` where `x < y`.\n             // Non-empty because the range includes at least `x`.\n@@ -753,57 +754,49 @@ pub(crate) fn compare_const_vals<'tcx>(\n     a: mir::ConstantKind<'tcx>,\n     b: mir::ConstantKind<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n ) -> Option<Ordering> {\n-    let from_bool = |v: bool| v.then_some(Ordering::Equal);\n-\n-    let fallback = || from_bool(a == b);\n-\n-    // Use the fallback if any type differs\n-    if a.ty() != b.ty() || a.ty() != ty {\n-        return fallback();\n-    }\n-\n-    if a == b {\n-        return from_bool(true);\n-    }\n-\n-    let a_bits = a.try_eval_bits(tcx, param_env, ty);\n-    let b_bits = b.try_eval_bits(tcx, param_env, ty);\n-\n-    if let (Some(a), Some(b)) = (a_bits, b_bits) {\n-        use rustc_apfloat::Float;\n-        return match *ty.kind() {\n-            ty::Float(ty::FloatTy::F32) => {\n-                let l = rustc_apfloat::ieee::Single::from_bits(a);\n-                let r = rustc_apfloat::ieee::Single::from_bits(b);\n-                l.partial_cmp(&r)\n-            }\n-            ty::Float(ty::FloatTy::F64) => {\n-                let l = rustc_apfloat::ieee::Double::from_bits(a);\n-                let r = rustc_apfloat::ieee::Double::from_bits(b);\n-                l.partial_cmp(&r)\n-            }\n-            ty::Int(ity) => {\n-                use rustc_middle::ty::layout::IntegerExt;\n-                let size = rustc_target::abi::Integer::from_int_ty(&tcx, ity).size();\n-                let a = size.sign_extend(a);\n-                let b = size.sign_extend(b);\n-                Some((a as i128).cmp(&(b as i128)))\n-            }\n-            _ => Some(a.cmp(&b)),\n-        };\n-    }\n-\n-    if let ty::Str = ty.kind() && let (\n-        Some(a_val @ ConstValue::Slice { .. }),\n-        Some(b_val @ ConstValue::Slice { .. }),\n-    ) = (a.try_to_value(tcx), b.try_to_value(tcx))\n-    {\n-        let a_bytes = get_slice_bytes(&tcx, a_val);\n-        let b_bytes = get_slice_bytes(&tcx, b_val);\n-        return from_bool(a_bytes == b_bytes);\n+    assert_eq!(a.ty(), b.ty());\n+\n+    let ty = a.ty();\n+\n+    // This code is hot when compiling matches with many ranges. So we\n+    // special-case extraction of evaluated scalars for speed, for types where\n+    // raw data comparisons are appropriate. E.g. `unicode-normalization` has\n+    // many ranges such as '\\u{037A}'..='\\u{037F}', and chars can be compared\n+    // in this way.\n+    match ty.kind() {\n+        ty::Float(_) | ty::Int(_) => {} // require special handling, see below\n+        _ => match (a, b) {\n+            (\n+                mir::ConstantKind::Val(ConstValue::Scalar(Scalar::Int(a)), _a_ty),\n+                mir::ConstantKind::Val(ConstValue::Scalar(Scalar::Int(b)), _b_ty),\n+            ) => return Some(a.cmp(&b)),\n+            _ => {}\n+        },\n+    }\n+\n+    let a = a.eval_bits(tcx, param_env, ty);\n+    let b = b.eval_bits(tcx, param_env, ty);\n+\n+    use rustc_apfloat::Float;\n+    match *ty.kind() {\n+        ty::Float(ty::FloatTy::F32) => {\n+            let a = rustc_apfloat::ieee::Single::from_bits(a);\n+            let b = rustc_apfloat::ieee::Single::from_bits(b);\n+            a.partial_cmp(&b)\n+        }\n+        ty::Float(ty::FloatTy::F64) => {\n+            let a = rustc_apfloat::ieee::Double::from_bits(a);\n+            let b = rustc_apfloat::ieee::Double::from_bits(b);\n+            a.partial_cmp(&b)\n+        }\n+        ty::Int(ity) => {\n+            use rustc_middle::ty::layout::IntegerExt;\n+            let size = rustc_target::abi::Integer::from_int_ty(&tcx, ity).size();\n+            let a = size.sign_extend(a);\n+            let b = size.sign_extend(b);\n+            Some((a as i128).cmp(&(b as i128)))\n+        }\n+        _ => Some(a.cmp(&b)),\n     }\n-\n-    fallback()\n }"}]}