{"sha": "9f45484db5cc4570b4e489e82646efc5c628b6ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNDU0ODRkYjVjYzQ1NzBiNGU0ODllODI2NDZlZmM1YzYyOGI2ZWE=", "commit": {"author": {"name": "Clark Gaebel", "email": "cg.wowus.cg@gmail.com", "date": "2014-03-27T01:58:08Z"}, "committer": {"name": "Clark Gaebel", "email": "cg.wowus.cg@gmail.com", "date": "2014-04-19T00:15:41Z"}, "message": "Reduce HashMap allocations.", "tree": {"sha": "54102b238bcabee223a61d96c754e23d0360fde2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54102b238bcabee223a61d96c754e23d0360fde2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f45484db5cc4570b4e489e82646efc5c628b6ea", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f45484db5cc4570b4e489e82646efc5c628b6ea", "html_url": "https://github.com/rust-lang/rust/commit/9f45484db5cc4570b4e489e82646efc5c628b6ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f45484db5cc4570b4e489e82646efc5c628b6ea/comments", "author": null, "committer": null, "parents": [{"sha": "b75683cadf6c4c55360202cd6a0106be80532451", "url": "https://api.github.com/repos/rust-lang/rust/commits/b75683cadf6c4c55360202cd6a0106be80532451", "html_url": "https://github.com/rust-lang/rust/commit/b75683cadf6c4c55360202cd6a0106be80532451"}], "stats": {"total": 102, "additions": 72, "deletions": 30}, "files": [{"sha": "7ca00cb5f9a217f751c36e8114445f2e409bbb75", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 66, "deletions": 30, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9f45484db5cc4570b4e489e82646efc5c628b6ea/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f45484db5cc4570b4e489e82646efc5c628b6ea/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=9f45484db5cc4570b4e489e82646efc5c628b6ea", "patch": "@@ -33,16 +33,17 @@ mod table {\n     extern crate libc;\n \n     use std::clone::Clone;\n+    use std::cmp;\n     use std::cmp::Eq;\n     use std::hash::{Hash, Hasher};\n     use std::kinds::marker;\n-    use std::num::CheckedMul;\n+    use std::num::{CheckedMul, is_power_of_two};\n     use std::option::{Option, Some, None};\n     use std::prelude::Drop;\n     use std::ptr;\n     use std::ptr::RawPtr;\n     use std::rt::global_heap;\n-    use std::intrinsics::{size_of, transmute, move_val_init};\n+    use std::intrinsics::{size_of, min_align_of, transmute, move_val_init};\n     use std::iter::{Iterator, range_step_inclusive};\n \n     static EMPTY_BUCKET: u64 = 0u64;\n@@ -163,6 +164,42 @@ mod table {\n         }\n     }\n \n+    fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint {\n+        assert!(is_power_of_two(target_alignment));\n+        (unrounded + target_alignment - 1) & !(target_alignment - 1)\n+    }\n+\n+    #[test]\n+    fn test_rounding() {\n+        assert!(round_up_to_next(0, 4) == 0);\n+        assert!(round_up_to_next(1, 4) == 4);\n+        assert!(round_up_to_next(2, 4) == 4);\n+        assert!(round_up_to_next(3, 4) == 4);\n+        assert!(round_up_to_next(4, 4) == 4);\n+        assert!(round_up_to_next(5, 4) == 8);\n+    }\n+\n+    // Returns a tuple of (minimum required malloc alignment, hash_offset,\n+    // key_offset, val_offset, array_size), from the start of a mallocated array.\n+    fn calculate_offsets(\n+        hash_size: uint, hash_align: uint,\n+        keys_size: uint, keys_align: uint,\n+        vals_size: uint, vals_align: uint) -> (uint, uint, uint, uint, uint) {\n+\n+        let hash_offset   = 0;\n+        let end_of_hashes = hash_offset + hash_size;\n+\n+        let keys_offset   = round_up_to_next(end_of_hashes, keys_align);\n+        let end_of_keys   = keys_offset + keys_size;\n+\n+        let vals_offset   = round_up_to_next(end_of_keys, vals_align);\n+        let end_of_vals   = vals_offset + vals_size;\n+\n+        let min_align = cmp::max(hash_align, cmp::max(keys_align, vals_align));\n+\n+        (min_align, hash_offset, keys_offset, vals_offset, end_of_vals)\n+    }\n+\n     impl<K, V> RawTable<K, V> {\n \n         /// Does not initialize the buckets. The caller should ensure they,\n@@ -175,32 +212,31 @@ mod table {\n             let vals_size   =\n                 capacity.checked_mul(&size_of::< V >()).expect(\"capacity overflow\");\n \n-            /*\n-            The following code was my first pass at making RawTable only\n-            allocate a single buffer, since that's all it needs. There's\n-            no logical reason for this to require three calls to malloc.\n-\n-            However, I'm not convinced the code below is correct. If you\n-            want to take a stab at it, please do! The alignment is\n-            especially tricky to get right, especially if you need more\n-            alignment than malloc guarantees.\n-\n-            let hashes_offset = 0;\n-            let keys_offset   = align_size(hashes_offset + hashes_size, keys_align);\n-            let vals_offset   = align_size(keys_offset + keys_size, vals_align);\n-            let end = vals_offset + vals_size;\n-\n-            let buffer = global_heap::malloc_raw(end);\n-\n-            let hashes = buffer.offset(hashes_offset) as *mut u64;\n-            let keys   = buffer.offset(keys_offset)   as *mut K;\n-            let vals   = buffer.offset(vals_offset)   as *mut V;\n-\n-            */\n-\n-            let hashes = global_heap::malloc_raw(hashes_size) as *mut u64;\n-            let keys   = global_heap::malloc_raw(keys_size)   as *mut K;\n-            let vals   = global_heap::malloc_raw(vals_size)   as *mut V;\n+            // Allocating hashmaps is a little tricky. We need to allocate three\n+            // arrays here, but since we know their sizes and alignments up front,\n+            // we could theoretically allocate only a single array, and then have\n+            // the subarrays just point into it.\n+            //\n+            // This is great in theory, but in practice getting the alignment\n+            // right is a little subtle. Therefore, calculating offsets has been\n+            // factored out into a different function.\n+            let (malloc_alignment, hash_offset, keys_offset, vals_offset, size) =\n+                calculate_offsets(\n+                    hashes_size, min_align_of::<u64>(),\n+                    keys_size,   min_align_of::< K >(),\n+                    vals_size,   min_align_of::< V >());\n+\n+            let buffer = global_heap::malloc_raw(size) as *mut u8;\n+\n+            // FIXME #13094: If malloc was not at as aligned as we expected,\n+            // our offset calculations are just plain wrong. We could support\n+            // any alignment if we switched from `malloc` to `posix_memalign`.\n+            assert!(round_up_to_next(buffer as uint, malloc_alignment)\n+                == (buffer as uint));\n+\n+            let hashes = buffer.offset(hash_offset as int) as *mut u64;\n+            let keys   = buffer.offset(keys_offset as int) as *mut K;\n+            let vals   = buffer.offset(vals_offset as int) as *mut V;\n \n             RawTable {\n                 capacity: capacity,\n@@ -513,9 +549,9 @@ mod table {\n             assert!(self.size == 0);\n \n             unsafe {\n-                libc::free(self.vals   as *mut libc::c_void);\n-                libc::free(self.keys   as *mut libc::c_void);\n                 libc::free(self.hashes as *mut libc::c_void);\n+                // Remember how everything was allocated out of one buffer\n+                // during initialization? We only need one call to free here.\n             }\n         }\n     }"}, {"sha": "b21a80cfd235b857c27bc04429bae5abed22b222", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f45484db5cc4570b4e489e82646efc5c628b6ea/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f45484db5cc4570b4e489e82646efc5c628b6ea/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=9f45484db5cc4570b4e489e82646efc5c628b6ea", "patch": "@@ -311,6 +311,12 @@ pub fn next_power_of_two<T: Unsigned + Int>(n: T) -> T {\n     tmp + one()\n }\n \n+// Returns `true` iff `n == 2^k` for some k.\n+#[inline]\n+pub fn is_power_of_two<T: Unsigned + Int>(n: T) -> bool {\n+    (n - one()) & n == zero()\n+}\n+\n /// Returns the smallest power of 2 greater than or equal to `n`. If the next\n /// power of two is greater than the type's maximum value, `None` is returned,\n /// otherwise the power of 2 is wrapped in `Some`."}]}