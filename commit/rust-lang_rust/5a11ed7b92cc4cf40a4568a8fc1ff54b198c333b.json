{"sha": "5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMTFlZDdiOTJjYzRjZjQwYTQ1NjhhOGZjMWZmNTRiMTk4YzMzM2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-21T10:33:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-21T10:33:53Z"}, "message": "Auto merge of #4223 - mikerite:fix-breakage-2019-06-21, r=flip1995\n\nFix breakage due to rust-lang/rust#61968\n\n<!--\nThank you for making Clippy better!\n\nWe're collecting our changelog from pull request descriptions.\nIf your PR only updates to the latest nightly, you can leave the\n`changelog` entry as `none`. Otherwise, please write a short comment\nexplaining your change.\n\nIf your PR fixes an issue, you can add \"fixes #issue_number\" into this\nPR description. This way the issue will be automatically closed when\nyour PR is merged.\n\nIf you added a new lint, here's a checklist for things that will be\nchecked during review or continuous integration.\n\n- [ ] Followed [lint naming conventions][lint_naming]\n- [ ] Added passing UI tests (including committed `.stderr` file)\n- [ ] `cargo test` passes locally\n- [ ] Executed `util/dev update_lints`\n- [ ] Added lint documentation\n- [ ] Run `cargo fmt`\n\nNote that you can skip the above if you are just opening a WIP PR in\norder to get feedback.\n\nDelete this line and everything above before opening your PR -->\n\nchangelog: none", "tree": {"sha": "cf1a1335cc26d2a3698cc41355939d498a98b91e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf1a1335cc26d2a3698cc41355939d498a98b91e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b", "html_url": "https://github.com/rust-lang/rust/commit/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7db5d0e6de112440dd13e78e2cc0bb1a7be25641", "url": "https://api.github.com/repos/rust-lang/rust/commits/7db5d0e6de112440dd13e78e2cc0bb1a7be25641", "html_url": "https://github.com/rust-lang/rust/commit/7db5d0e6de112440dd13e78e2cc0bb1a7be25641"}, {"sha": "ca2ba973a7b101088e5b07d1e77ed3b6ef1c1fd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca2ba973a7b101088e5b07d1e77ed3b6ef1c1fd2", "html_url": "https://github.com/rust-lang/rust/commit/ca2ba973a7b101088e5b07d1e77ed3b6ef1c1fd2"}], "stats": {"total": 78, "additions": 37, "deletions": 41}, "files": [{"sha": "caf418c9b5b4bbd9a8668cbd746b6c4d8edfe105", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b", "patch": "@@ -2,14 +2,14 @@ use crate::utils::{\n     get_trait_def_id, implements_trait, in_macro, in_macro_or_desugar, match_type, paths, snippet_opt,\n     span_lint_and_then, SpanlessEq,\n };\n+use if_chain::if_chain;\n use rustc::hir::intravisit::*;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n-use syntax::source_map::{dummy_spanned, Span, DUMMY_SP};\n+use syntax::source_map::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for boolean expressions that can be written more\n@@ -93,6 +93,18 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n     }\n \n     fn run(&mut self, e: &'v Expr) -> Result<Bool, String> {\n+        fn negate(bin_op_kind: BinOpKind) -> Option<BinOpKind> {\n+            match bin_op_kind {\n+                BinOpKind::Eq => Some(BinOpKind::Ne),\n+                BinOpKind::Ne => Some(BinOpKind::Eq),\n+                BinOpKind::Gt => Some(BinOpKind::Le),\n+                BinOpKind::Ge => Some(BinOpKind::Lt),\n+                BinOpKind::Lt => Some(BinOpKind::Ge),\n+                BinOpKind::Le => Some(BinOpKind::Gt),\n+                _ => None,\n+            }\n+        }\n+\n         // prevent folding of `cfg!` macros and the like\n         if !in_macro_or_desugar(e.span) {\n             match &e.node {\n@@ -115,33 +127,18 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 #[allow(clippy::cast_possible_truncation)]\n                 return Ok(Bool::Term(n as u8));\n             }\n-            let negated = match &e.node {\n-                ExprKind::Binary(binop, lhs, rhs) => {\n-                    if !implements_ord(self.cx, lhs) {\n-                        continue;\n-                    }\n \n-                    let mk_expr = |op| Expr {\n-                        hir_id: DUMMY_HIR_ID,\n-                        span: DUMMY_SP,\n-                        attrs: ThinVec::new(),\n-                        node: ExprKind::Binary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n-                    };\n-                    match binop.node {\n-                        BinOpKind::Eq => mk_expr(BinOpKind::Ne),\n-                        BinOpKind::Ne => mk_expr(BinOpKind::Eq),\n-                        BinOpKind::Gt => mk_expr(BinOpKind::Le),\n-                        BinOpKind::Ge => mk_expr(BinOpKind::Lt),\n-                        BinOpKind::Lt => mk_expr(BinOpKind::Ge),\n-                        BinOpKind::Le => mk_expr(BinOpKind::Gt),\n-                        _ => continue,\n-                    }\n-                },\n-                _ => continue,\n-            };\n-            if SpanlessEq::new(self.cx).ignore_fn().eq_expr(&negated, expr) {\n-                #[allow(clippy::cast_possible_truncation)]\n-                return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));\n+            if_chain! {\n+                if let ExprKind::Binary(e_binop, e_lhs, e_rhs) = &e.node;\n+                if implements_ord(self.cx, e_lhs);\n+                if let ExprKind::Binary(expr_binop, expr_lhs, expr_rhs) = &expr.node;\n+                if negate(e_binop.node) == Some(expr_binop.node);\n+                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_lhs, expr_lhs);\n+                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_rhs, expr_rhs);\n+                then {\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));\n+                }\n             }\n         }\n         let n = self.terminals.len();"}, {"sha": "228d53ff11303cfd2b876113624479e0bc54af6f", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b", "patch": "@@ -36,7 +36,7 @@ declare_lint_pass!(DoubleComparisons => [DOUBLE_COMPARISONS]);\n impl<'a, 'tcx> DoubleComparisons {\n     #[allow(clippy::similar_names)]\n     fn check_binop(self, cx: &LateContext<'a, 'tcx>, op: BinOpKind, lhs: &'tcx Expr, rhs: &'tcx Expr, span: Span) {\n-        let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (lhs.node.clone(), rhs.node.clone()) {\n+        let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.node, &rhs.node) {\n             (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n                 (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n             },"}, {"sha": "27170817def190679fe8070f99bb1a88e6893fa6", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b", "patch": "@@ -42,7 +42,7 @@ declare_clippy_lint! {\n #[allow(clippy::module_name_repetitions)]\n #[derive(Default)]\n pub struct MultipleInherentImpl {\n-    impls: FxHashMap<def_id::DefId, (Span, Generics)>,\n+    impls: FxHashMap<def_id::DefId, Span>,\n }\n \n impl_lint_pass!(MultipleInherentImpl => [MULTIPLE_INHERENT_IMPL]);\n@@ -51,8 +51,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MultipleInherentImpl {\n     fn check_item(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Impl(_, _, _, ref generics, None, _, _) = item.node {\n             // Remember for each inherent implementation encoutered its span and generics\n-            self.impls\n-                .insert(item.hir_id.owner_def_id(), (item.span, generics.clone()));\n+            // but filter out implementations that have generic params (type or lifetime)\n+            if generics.params.len() == 0 {\n+                self.impls.insert(item.hir_id.owner_def_id(), item.span);\n+            }\n         }\n     }\n \n@@ -66,10 +68,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MultipleInherentImpl {\n                 .values()\n             {\n                 // Filter out implementations that have generic params (type or lifetime)\n-                let mut impl_spans = impls\n-                    .iter()\n-                    .filter_map(|impl_def| self.impls.get(impl_def))\n-                    .filter_map(|(span, generics)| if generics.params.len() == 0 { Some(span) } else { None });\n+                let mut impl_spans = impls.iter().filter_map(|impl_def| self.impls.get(impl_def));\n                 if let Some(initial_span) = impl_spans.nth(0) {\n                     impl_spans.for_each(|additional_span| {\n                         span_lint_and_then("}, {"sha": "9e0f7d0f3c2e1abe7b8de0cfbcaedb57cc1faaea", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b", "patch": "@@ -129,7 +129,7 @@ impl QuestionMark {\n         }\n     }\n \n-    fn return_expression(block: &Block) -> Option<P<Expr>> {\n+    fn return_expression(block: &Block) -> Option<&P<Expr>> {\n         // Check if last expression is a return statement. Then, return the expression\n         if_chain! {\n             if block.stmts.len() == 1;\n@@ -139,7 +139,7 @@ impl QuestionMark {\n             if let &Some(ref ret_expr) = ret_expr;\n \n             then {\n-                return Some(ret_expr.clone());\n+                return Some(ret_expr);\n             }\n         }\n \n@@ -148,7 +148,7 @@ impl QuestionMark {\n             if block.stmts.len() == 0;\n             if let Some(ExprKind::Ret(Some(ret_expr))) = block.expr.as_ref().map(|e| &e.node);\n             then {\n-                return Some(ret_expr.clone());\n+                return Some(ret_expr);\n             }\n         }\n "}, {"sha": "004a54346a6d02b042e5d077225a26492e752192", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=5a11ed7b92cc4cf40a4568a8fc1ff54b198c333b", "patch": "@@ -315,14 +315,14 @@ pub fn implements_trait<'a, 'tcx>(\n ///     }\n /// }\n /// ```\n-pub fn trait_ref_of_method(cx: &LateContext<'_, '_>, hir_id: HirId) -> Option<TraitRef> {\n+pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'_, 'tcx>, hir_id: HirId) -> Option<&'tcx TraitRef> {\n     // Get the implemented trait for the current function\n     let parent_impl = cx.tcx.hir().get_parent_item(hir_id);\n     if_chain! {\n         if parent_impl != hir::CRATE_HIR_ID;\n         if let hir::Node::Item(item) = cx.tcx.hir().get_by_hir_id(parent_impl);\n         if let hir::ItemKind::Impl(_, _, _, _, trait_ref, _, _) = &item.node;\n-        then { return trait_ref.clone(); }\n+        then { return trait_ref.as_ref(); }\n     }\n     None\n }"}]}