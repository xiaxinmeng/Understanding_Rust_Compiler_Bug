{"sha": "0d3160c1f1467b82e791b9902165a7054554cb38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMzE2MGMxZjE0NjdiODJlNzkxYjk5MDIxNjVhNzA1NDU1NGNiMzg=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2015-08-12T07:18:41Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2016-01-05T10:02:43Z"}, "message": "Rework Arena structure\n\nImplements in-place growth. Removes the use of Rc within Arena.\nCloses #22847", "tree": {"sha": "8a190ab39a972ce3941463f1de693e05729ec095", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a190ab39a972ce3941463f1de693e05729ec095"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d3160c1f1467b82e791b9902165a7054554cb38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d3160c1f1467b82e791b9902165a7054554cb38", "html_url": "https://github.com/rust-lang/rust/commit/0d3160c1f1467b82e791b9902165a7054554cb38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d3160c1f1467b82e791b9902165a7054554cb38/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d42693a52b9486a9ba7ad059c49cae21ab593c00", "url": "https://api.github.com/repos/rust-lang/rust/commits/d42693a52b9486a9ba7ad059c49cae21ab593c00", "html_url": "https://github.com/rust-lang/rust/commit/d42693a52b9486a9ba7ad059c49cae21ab593c00"}], "stats": {"total": 70, "additions": 36, "deletions": 34}, "files": [{"sha": "532979ddeb0aac7af8b95b5803f057cd8271b8cd", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0d3160c1f1467b82e791b9902165a7054554cb38/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3160c1f1467b82e791b9902165a7054554cb38/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=0d3160c1f1467b82e791b9902165a7054554cb38", "patch": "@@ -29,13 +29,11 @@\n        test(no_crate_inject, attr(deny(warnings))))]\n \n #![feature(alloc)]\n-#![feature(box_syntax)]\n #![feature(core_intrinsics)]\n #![feature(drop_in_place)]\n-#![feature(raw)]\n #![feature(heap_api)]\n-#![feature(oom)]\n #![feature(raw)]\n+#![feature(heap_api)]\n #![feature(staged_api)]\n #![feature(dropck_parametricity)]\n #![cfg_attr(test, feature(test))]\n@@ -48,31 +46,34 @@ use std::intrinsics;\n use std::marker::{PhantomData, Send};\n use std::mem;\n use std::ptr;\n-use std::raw;\n-use std::raw::Repr;\n-use std::rc::Rc;\n-use std::slice;\n \n use alloc::heap;\n use alloc::raw_vec::RawVec;\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n-#[derive(Clone, PartialEq)]\n struct Chunk {\n-    data: Rc<RefCell<Vec<u8>>>,\n+    data: RawVec<u8>,\n     fill: Cell<usize>,\n     is_copy: Cell<bool>,\n }\n \n impl Chunk {\n+    fn new(size: usize, is_copy: bool) -> Chunk {\n+        Chunk {\n+            data: RawVec::with_capacity(size),\n+            fill: Cell::new(0),\n+            is_copy: Cell::new(is_copy),\n+        }\n+    }\n+\n     fn capacity(&self) -> usize {\n-        self.data.borrow().capacity()\n+        self.data.cap()\n     }\n \n     unsafe fn as_ptr(&self) -> *const u8 {\n-        self.data.borrow().as_ptr()\n+        self.data.ptr()\n     }\n }\n \n@@ -115,22 +116,14 @@ impl<'a> Arena<'a> {\n     /// Allocates a new Arena with `initial_size` bytes preallocated.\n     pub fn new_with_size(initial_size: usize) -> Arena<'a> {\n         Arena {\n-            head: RefCell::new(chunk(initial_size, false)),\n-            copy_head: RefCell::new(chunk(initial_size, true)),\n+            head: RefCell::new(Chunk::new(initial_size, false)),\n+            copy_head: RefCell::new(Chunk::new(initial_size, true)),\n             chunks: RefCell::new(Vec::new()),\n             _marker: PhantomData,\n         }\n     }\n }\n \n-fn chunk(size: usize, is_copy: bool) -> Chunk {\n-    Chunk {\n-        data: Rc::new(RefCell::new(Vec::with_capacity(size))),\n-        fill: Cell::new(0),\n-        is_copy: Cell::new(is_copy),\n-    }\n-}\n-\n impl<'longer_than_self> Drop for Arena<'longer_than_self> {\n     fn drop(&mut self) {\n         unsafe {\n@@ -165,8 +158,6 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n \n         let start = round_up(after_tydesc, align);\n \n-        // debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n-        //        start, size, align, is_done);\n         if is_done {\n             ((*tydesc).drop_glue)(buf.offset(start as isize) as *const i8);\n         }\n@@ -215,28 +206,34 @@ unsafe fn get_tydesc<T>() -> *const TyDesc {\n }\n \n impl<'longer_than_self> Arena<'longer_than_self> {\n+    #[inline]\n     fn chunk_size(&self) -> usize {\n         self.copy_head.borrow().capacity()\n     }\n \n     // Functions for the POD part of the arena\n+    #[cold]\n     fn alloc_copy_grow(&self, n_bytes: usize, align: usize) -> *const u8 {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n-        self.chunks.borrow_mut().push(self.copy_head.borrow().clone());\n-\n-        *self.copy_head.borrow_mut() = chunk((new_min_chunk_size + 1).next_power_of_two(), true);\n+        let new_chunk = Chunk::new((new_min_chunk_size + 1).next_power_of_two(), true);\n+        let mut copy_head = self.copy_head.borrow_mut();\n+        let old_chunk = mem::replace(&mut *copy_head, new_chunk);\n+        self.chunks.borrow_mut().push(old_chunk);\n \n         self.alloc_copy_inner(n_bytes, align)\n     }\n \n     #[inline]\n     fn alloc_copy_inner(&self, n_bytes: usize, align: usize) -> *const u8 {\n         let start = round_up(self.copy_head.borrow().fill.get(), align);\n+        let chunk_size = self.chunk_size();\n \n         let end = start + n_bytes;\n-        if end > self.chunk_size() {\n-            return self.alloc_copy_grow(n_bytes, align);\n+        if end > chunk_size {\n+            if !self.copy_head.borrow_mut().data.reserve_in_place(start, n_bytes) {\n+                return self.alloc_copy_grow(n_bytes, align);\n+            }\n         }\n \n         let copy_head = self.copy_head.borrow();\n@@ -261,9 +258,10 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n     fn alloc_noncopy_grow(&self, n_bytes: usize, align: usize) -> (*const u8, *const u8) {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n-        self.chunks.borrow_mut().push(self.head.borrow().clone());\n-\n-        *self.head.borrow_mut() = chunk((new_min_chunk_size + 1).next_power_of_two(), false);\n+        let new_chunk = Chunk::new((new_min_chunk_size + 1).next_power_of_two(), false);\n+        let mut head = self.head.borrow_mut();\n+        let old_chunk = mem::replace(&mut *head, new_chunk);\n+        self.chunks.borrow_mut().push(old_chunk);\n \n         self.alloc_noncopy_inner(n_bytes, align)\n     }\n@@ -606,7 +604,11 @@ mod tests {\n     #[bench]\n     pub fn bench_copy_nonarena(b: &mut Bencher) {\n         b.iter(|| {\n-            let _: Box<_> = box Point { x: 1, y: 2, z: 3 };\n+            let _: Box<_> = Box::new(Point {\n+                x: 1,\n+                y: 2,\n+                z: 3\n+            });\n         })\n     }\n \n@@ -647,10 +649,10 @@ mod tests {\n     #[bench]\n     pub fn bench_noncopy_nonarena(b: &mut Bencher) {\n         b.iter(|| {\n-            let _: Box<_> = box Noncopy {\n+            let _: Box<_> = Box::new(Noncopy {\n                 string: \"hello world\".to_string(),\n                 array: vec![1, 2, 3, 4, 5],\n-            };\n+            });\n         })\n     }\n "}]}