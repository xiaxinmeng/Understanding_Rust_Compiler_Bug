{"sha": "09919c2b596b19ad36850b77d8f6ea00b3b60612", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5OTE5YzJiNTk2YjE5YWQzNjg1MGI3N2Q4ZjZlYTAwYjNiNjA2MTI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-07T13:56:25Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-15T08:35:40Z"}, "message": "Retag is the only operation that generates new tags", "tree": {"sha": "08ea1812207b684e061e51b39c19f7c7e8b499b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08ea1812207b684e061e51b39c19f7c7e8b499b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09919c2b596b19ad36850b77d8f6ea00b3b60612", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09919c2b596b19ad36850b77d8f6ea00b3b60612", "html_url": "https://github.com/rust-lang/rust/commit/09919c2b596b19ad36850b77d8f6ea00b3b60612", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09919c2b596b19ad36850b77d8f6ea00b3b60612/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3554d1acdc5dfecf9abb6fb5d03dcaf8f6e0e255", "url": "https://api.github.com/repos/rust-lang/rust/commits/3554d1acdc5dfecf9abb6fb5d03dcaf8f6e0e255", "html_url": "https://github.com/rust-lang/rust/commit/3554d1acdc5dfecf9abb6fb5d03dcaf8f6e0e255"}], "stats": {"total": 263, "additions": 161, "deletions": 102}, "files": [{"sha": "ca23de4208823d9cea12afd4974f260b60763f8a", "filename": ".gitignore", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09919c2b596b19ad36850b77d8f6ea00b3b60612/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/09919c2b596b19ad36850b77d8f6ea00b3b60612/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=09919c2b596b19ad36850b77d8f6ea00b3b60612", "patch": "@@ -2,6 +2,5 @@ target\n /doc\n tex/*/out\n *.dot\n-*.mir\n *.rs.bk\n Cargo.lock"}, {"sha": "150cf7402a6dde831862db3fbeb7c5e586969a2d", "filename": "src/fn_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09919c2b596b19ad36850b77d8f6ea00b3b60612/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09919c2b596b19ad36850b77d8f6ea00b3b60612/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=09919c2b596b19ad36850b77d8f6ea00b3b60612", "patch": "@@ -555,7 +555,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n             \"pthread_attr_getstack\" => {\n                 // second argument is where we are supposed to write the stack size\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[1])?)?;\n+                let ptr = self.deref_operand(args[1])?;\n                 let stackaddr = Scalar::from_int(0x80000, args[1].layout.size); // just any address\n                 self.write_scalar(stackaddr, ptr.into())?;\n                 // return 0"}, {"sha": "e23cadfcaf0b764a3a2a5465f7c2d047b21261c4", "filename": "src/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/09919c2b596b19ad36850b77d8f6ea00b3b60612/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09919c2b596b19ad36850b77d8f6ea00b3b60612/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=09919c2b596b19ad36850b77d8f6ea00b3b60612", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             \"atomic_load_relaxed\" |\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let ptr = self.deref_operand(args[0])?;\n                 let val = self.read_scalar(ptr.into())?; // make sure it fits into a scalar; otherwise it cannot be atomic\n                 self.write_scalar(val, dest)?;\n             }\n@@ -68,7 +68,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             \"atomic_store_relaxed\" |\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let ptr = self.deref_operand(args[0])?;\n                 let val = self.read_scalar(args[1])?; // make sure it fits into a scalar; otherwise it cannot be atomic\n                 self.write_scalar(val, ptr.into())?;\n             }\n@@ -78,18 +78,18 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let ptr = self.deref_operand(args[0])?;\n                 let new = self.read_scalar(args[1])?;\n                 let old = self.read_scalar(ptr.into())?;\n                 self.write_scalar(old, dest)?; // old value is returned\n                 self.write_scalar(new, ptr.into())?;\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n-                let expect_old = self.read_immediate(args[1])?; // read as value for the sake of `binary_op_imm()`\n+                let ptr = self.deref_operand(args[0])?;\n+                let expect_old = self.read_immediate(args[1])?; // read as immediate for the sake of `binary_op_imm()`\n                 let new = self.read_scalar(args[2])?;\n-                let old = self.read_immediate(ptr.into())?; // read as value for the sake of `binary_op_imm()`\n+                let old = self.read_immediate(ptr.into())?; // read as immediate for the sake of `binary_op_imm()`\n                 // binary_op_imm will bail if either of them is not a scalar\n                 let (eq, _) = self.binary_op_imm(mir::BinOp::Eq, old, expect_old)?;\n                 let res = Immediate::ScalarPair(old.to_scalar_or_undef(), eq.into());\n@@ -125,7 +125,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             \"atomic_xsub_rel\" |\n             \"atomic_xsub_acqrel\" |\n             \"atomic_xsub_relaxed\" => {\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let ptr = self.deref_operand(args[0])?;\n                 if !ptr.layout.ty.is_integral() {\n                     return err!(Unimplemented(format!(\"Atomic arithmetic operations only work on integer types\")));\n                 }\n@@ -167,7 +167,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             \"discriminant_value\" => {\n-                let place = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let place = self.deref_operand(args[0])?;\n                 let discr_val = self.read_discriminant(place.into())?.0;\n                 self.write_scalar(Scalar::from_uint(discr_val, dest.layout.size), dest)?;\n             }\n@@ -279,7 +279,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             \"move_val_init\" => {\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let ptr = self.deref_operand(args[0])?;\n                 self.copy_op(args[1], ptr.into())?;\n             }\n \n@@ -347,7 +347,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             \"size_of_val\" => {\n-                let mplace = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let mplace = self.deref_operand(args[0])?;\n                 let (size, _) = self.size_and_align_of_mplace(mplace)?\n                     .expect(\"size_of_val called on extern type\");\n                 let ptr_size = self.pointer_size();\n@@ -359,7 +359,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n \n             \"min_align_of_val\" |\n             \"align_of_val\" => {\n-                let mplace = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let mplace = self.deref_operand(args[0])?;\n                 let (_, align) = self.size_and_align_of_mplace(mplace)?\n                     .expect(\"size_of_val called on extern type\");\n                 let ptr_size = self.pointer_size();"}, {"sha": "e8691409b1ab4f0dd8c3cabf1395365d7eec7f68", "filename": "src/lib.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/09919c2b596b19ad36850b77d8f6ea00b3b60612/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09919c2b596b19ad36850b77d8f6ea00b3b60612/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=09919c2b596b19ad36850b77d8f6ea00b3b60612", "patch": "@@ -296,7 +296,6 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n \n     type AllocExtra = stacked_borrows::Stacks;\n     type PointerTag = Borrow;\n-    const ENABLE_PTR_TRACKING_HOOKS: bool = true;\n \n     type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Borrow, Self::AllocExtra>)>;\n \n@@ -446,26 +445,6 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         Cow::Owned(alloc)\n     }\n \n-    #[inline(always)]\n-    fn tag_reference(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        place: MPlaceTy<'tcx, Borrow>,\n-        mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Scalar<Borrow>> {\n-        let (size, _) = ecx.size_and_align_of_mplace(place)?\n-            // for extern types, just cover what we can\n-            .unwrap_or_else(|| place.layout.size_and_align());\n-        if !ecx.machine.validate || size == Size::ZERO {\n-            // No tracking\n-            Ok(place.ptr)\n-        } else {\n-            let ptr = place.ptr.to_ptr()?;\n-            let tag = ecx.tag_reference(place, size, mutability.into())?;\n-            Ok(Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag)))\n-        }\n-    }\n-\n-    #[inline(always)]\n     fn tag_dereference(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         place: MPlaceTy<'tcx, Borrow>,\n@@ -478,7 +457,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             // No tracking\n             Ok(place.ptr)\n         } else {\n-            let ptr = place.ptr.to_ptr()?;\n+            let ptr = place.ptr.to_ptr()?; // assert this is not a scalar\n             let tag = ecx.tag_dereference(place, size, mutability.into())?;\n             Ok(Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag)))\n         }\n@@ -499,19 +478,46 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    fn escape_to_raw(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: OpTy<'tcx, Self::PointerTag>,\n+    ) -> EvalResult<'tcx> {\n+        // It is tempting to check the type here, but drop glue does EscapeToRaw\n+        // on a raw pointer.\n+        // This is deliberately NOT `deref_operand` as we do not want `tag_dereference`\n+        // to be called!  That would kill the original tag if we got a raw ptr.\n+        let place = ecx.ref_to_mplace(ecx.read_immediate(ptr)?)?;\n+        let (size, _) = ecx.size_and_align_of_mplace(place)?\n+            // for extern types, just cover what we can\n+            .unwrap_or_else(|| place.layout.size_and_align());\n+        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag ||\n+            !ecx.machine.validate || size == Size::ZERO\n+        {\n+            // No tracking, or no retagging. The latter is possible because a dependency of ours\n+            // might be called with different flags than we are, so there are `Retag`\n+            // statements but we do not want to execute them.\n+            Ok(())\n+        } else {\n+            ecx.escape_to_raw(place, size)\n+        }\n+    }\n+\n     #[inline(always)]\n     fn retag(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         fn_entry: bool,\n         place: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx> {\n         if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n-            // No tracking, or no retagging. This is possible because a dependency of ours might be\n-            // called with different flags than we are,\n+            // No tracking, or no retagging. The latter is possible because a dependency of ours\n+            // might be called with different flags than we are, so there are `Retag`\n+            // statements but we do not want to execute them.\n             // Also, honor the whitelist in `enforce_validity` because otherwise we might retag\n             // uninitialized data.\n-            return Ok(())\n+             Ok(())\n+        } else {\n+            ecx.retag(fn_entry, place)\n         }\n-        ecx.retag(fn_entry, place)\n     }\n }"}, {"sha": "e7c595f1c6ccc840126bdb3b4e009a6e37cc80f9", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 77, "deletions": 50, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/09919c2b596b19ad36850b77d8f6ea00b3b60612/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09919c2b596b19ad36850b77d8f6ea00b3b60612/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=09919c2b596b19ad36850b77d8f6ea00b3b60612", "patch": "@@ -6,7 +6,7 @@ use rustc::hir;\n use crate::{\n     EvalResult, MiriEvalContext, HelpersEvalContextExt,\n     MemoryKind, MiriMemoryKind, RangeMap, AllocId, Allocation, AllocationExtra,\n-    Pointer, PlaceTy, MPlaceTy,\n+    Pointer, MemPlace, Scalar, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n pub type Timestamp = u64;\n@@ -395,13 +395,6 @@ impl<'tcx> Stacks {\n \n \n pub trait EvalContextExt<'tcx> {\n-    fn tag_reference(\n-        &mut self,\n-        place: MPlaceTy<'tcx, Borrow>,\n-        size: Size,\n-        usage: UsageKind,\n-    ) -> EvalResult<'tcx, Borrow>;\n-\n     fn tag_dereference(\n         &self,\n         place: MPlaceTy<'tcx, Borrow>,\n@@ -415,47 +408,27 @@ pub trait EvalContextExt<'tcx> {\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> Borrow;\n \n+    /// Retag an indidual pointer, returning the retagged version.\n+    fn retag_ptr(\n+        &mut self,\n+        ptr: ImmTy<'tcx, Borrow>,\n+        mutbl: hir::Mutability,\n+    ) -> EvalResult<'tcx, Immediate<Borrow>>;\n+\n     fn retag(\n         &mut self,\n         fn_entry: bool,\n         place: PlaceTy<'tcx, Borrow>\n     ) -> EvalResult<'tcx>;\n-}\n \n-impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n-    /// Called for place-to-value conversion.\n-    fn tag_reference(\n+    fn escape_to_raw(\n         &mut self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n-        usage: UsageKind,\n-    ) -> EvalResult<'tcx, Borrow> {\n-        let ptr = place.ptr.to_ptr()?;\n-        let time = self.machine.stacked_borrows.increment_clock();\n-        let new_bor = match usage {\n-            UsageKind::Write => Borrow::Uniq(time),\n-            UsageKind::Read => Borrow::Shr(Some(time)),\n-            UsageKind::Raw => Borrow::Shr(None),\n-        };\n-        trace!(\"tag_reference: Creating new reference ({:?}) for {:?} (pointee {}): {:?}\",\n-            usage, ptr, place.layout.ty, new_bor);\n-\n-        // Update the stacks.  First create the new ref as usual, then maybe freeze stuff.\n-        self.memory().check_bounds(ptr, size, false)?;\n-        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        alloc.extra.use_and_maybe_re_borrow(ptr, size, usage, Some(new_bor))?;\n-        // Maybe freeze stuff\n-        if let Borrow::Shr(Some(bor_t)) = new_bor {\n-            self.visit_frozen(place, size, |frz_ptr, size| {\n-                debug_assert_eq!(frz_ptr.alloc_id, ptr.alloc_id);\n-                // Be frozen!\n-                alloc.extra.freeze(frz_ptr, size, bor_t)\n-            })?;\n-        }\n-\n-        Ok(new_bor)\n-    }\n+    ) -> EvalResult<'tcx>;\n+}\n \n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n     /// Called for value-to-place conversion.\n     ///\n     /// Note that this does NOT mean that all this memory will actually get accessed/referenced!\n@@ -466,9 +439,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         size: Size,\n         usage: UsageKind,\n     ) -> EvalResult<'tcx, Borrow> {\n-        let ptr = place.ptr.to_ptr()?;\n         trace!(\"tag_dereference: Accessing reference ({:?}) for {:?} (pointee {})\",\n-            usage, ptr, place.layout.ty);\n+            usage, place.ptr, place.layout.ty);\n+        let ptr = place.ptr.to_ptr()?;\n         // In principle we should not have to do anything here.  However, with transmutes involved,\n         // it can happen that the tag of `ptr` does not actually match `usage`, and we\n         // should adjust for that.\n@@ -551,27 +524,81 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         Borrow::Uniq(time)\n     }\n \n+    fn retag_ptr(\n+        &mut self,\n+        val: ImmTy<'tcx, Borrow>,\n+        mutbl: hir::Mutability,\n+    ) -> EvalResult<'tcx, Immediate<Borrow>> {\n+        // We want a place for where the ptr *points to*, so we get one.\n+        let place = self.ref_to_mplace(val)?;\n+        let size = self.size_and_align_of_mplace(place)?\n+            .map(|(size, _)| size)\n+            .unwrap_or_else(|| place.layout.size);\n+        if size == Size::ZERO {\n+            // Nothing to do for ZSTs.\n+            return Ok(*val);\n+        }\n+\n+        // Prepare to re-borrow this place.\n+        let ptr = place.ptr.to_ptr()?;\n+        let time = self.machine.stacked_borrows.increment_clock();\n+        let new_bor = match mutbl {\n+            hir::MutMutable => Borrow::Uniq(time),\n+            hir::MutImmutable => Borrow::Shr(Some(time)),\n+        };\n+        trace!(\"retag: Creating new reference ({:?}) for {:?} (pointee {}): {:?}\",\n+            mutbl, ptr, place.layout.ty, new_bor);\n+\n+        // Update the stacks.  First create a new borrow, then maybe freeze stuff.\n+        self.memory().check_bounds(ptr, size, false)?; // `ptr_dereference` wouldn't do any checks if this is a raw ptr\n+        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        alloc.extra.use_and_maybe_re_borrow(ptr, size, Some(mutbl).into(), Some(new_bor))?;\n+        // Maybe freeze stuff\n+        if let Borrow::Shr(Some(bor_t)) = new_bor {\n+            self.visit_frozen(place, size, |frz_ptr, size| {\n+                debug_assert_eq!(frz_ptr.alloc_id, ptr.alloc_id);\n+                // Be frozen!\n+                alloc.extra.freeze(frz_ptr, size, bor_t)\n+            })?;\n+        }\n+\n+        // Compute the new value and return that\n+        let new_ptr = Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, new_bor));\n+        let new_place = MemPlace { ptr: new_ptr, ..*place };\n+        Ok(new_place.to_ref())\n+    }\n+\n     fn retag(\n         &mut self,\n         _fn_entry: bool,\n         place: PlaceTy<'tcx, Borrow>\n     ) -> EvalResult<'tcx> {\n         // For now, we only retag if the toplevel type is a reference.\n         // TODO: Recurse into structs and enums, sharing code with validation.\n+        // TODO: Honor `fn_entry`.\n         let mutbl = match place.layout.ty.sty {\n             ty::Ref(_, _, mutbl) => mutbl, // go ahead\n-            _ => return Ok(()), // don't do a thing\n+            _ => return Ok(()), // do nothing, for now\n         };\n-        // We want to reborrow the reference stored there. This will call the hooks\n-        // above.  First deref, which will call `tag_dereference`.\n-        // (This is somewhat redundant because validation already did the same thing,\n-        // but what can you do.)\n+        // Retag the pointer and write it back.\n         let val = self.read_immediate(self.place_to_op(place)?)?;\n-        let dest = self.ref_to_mplace(val)?;\n-        // Now put a new ref into the old place, which will call `tag_reference`.\n-        // FIXME: Honor `fn_entry`!\n-        let val = self.create_ref(dest, Some(mutbl))?;\n+        let val = self.retag_ptr(val, mutbl)?;\n         self.write_immediate(val, place)?;\n         Ok(())\n     }\n+\n+    fn escape_to_raw(\n+        &mut self,\n+        place: MPlaceTy<'tcx, Borrow>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"self: {:?} is now accessible by raw pointers\", *place);\n+        // Re-borrow to raw.  This is a NOP for shared borrows, but we do not know the borrow\n+        // type here and that's also okay.\n+        let ptr = place.ptr.to_ptr()?;\n+        self.memory().check_bounds(ptr, size, false)?; // `ptr_dereference` wouldn't do any checks if this is a raw ptr\n+        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        alloc.extra.use_and_maybe_re_borrow(ptr, size, UsageKind::Raw, Some(Borrow::default()))?;\n+        Ok(())\n+    }\n }"}, {"sha": "2f3d0793f63e1535cb7b7dc5d333a41463084f82", "filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09919c2b596b19ad36850b77d8f6ea00b3b60612/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09919c2b596b19ad36850b77d8f6ea00b3b60612/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=09919c2b596b19ad36850b77d8f6ea00b3b60612", "patch": "@@ -1,4 +1,4 @@\n-#![allow(unused_variables)]\n+// error-pattern: mutable reference with frozen tag\n \n mod safe {\n     use std::slice::from_raw_parts_mut;\n@@ -12,8 +12,10 @@ mod safe {\n \n fn main() {\n     let v = vec![0,1,2];\n-    let v1 = safe::as_mut_slice(&v);\n+    let _v1 = safe::as_mut_slice(&v);\n+/*\n     let v2 = safe::as_mut_slice(&v);\n-    v1[1] = 5; //~ ERROR does not exist on the stack\n+    v1[1] = 5;\n     v1[1] = 6;\n+*/\n }"}, {"sha": "711544f80149c28c3cf4cc3a6fc181a4f043157c", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09919c2b596b19ad36850b77d8f6ea00b3b60612/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09919c2b596b19ad36850b77d8f6ea00b3b60612/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=09919c2b596b19ad36850b77d8f6ea00b3b60612", "patch": "@@ -11,7 +11,6 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            //~^ ERROR does not exist on the stack\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }\n@@ -20,6 +19,7 @@ mod safe {\n fn main() {\n     let mut array = [1,2,3,4];\n     let (a, b) = safe::split_at_mut(&mut array, 0);\n+    //~^ ERROR does not exist on the stack\n     a[1] = 5;\n     b[1] = 6;\n }"}, {"sha": "5c605eff678436eb2934021acac69f9039e397e9", "filename": "tests/compile-fail/stacked_borrows/static_memory_modification.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09919c2b596b19ad36850b77d8f6ea00b3b60612/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09919c2b596b19ad36850b77d8f6ea00b3b60612/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs?ref=09919c2b596b19ad36850b77d8f6ea00b3b60612", "patch": "@@ -1,3 +1,6 @@\n+// FIXME still considering whether we are okay with this not being an error\n+// ignore-test\n+\n static X: usize = 5;\n \n #[allow(mutable_transmutes)]"}, {"sha": "1ab005e3fa17dd711bae157f869eb2ba77929001", "filename": "tests/compile-fail/stacked_borrows/transmute-is-no-escape.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09919c2b596b19ad36850b77d8f6ea00b3b60612/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09919c2b596b19ad36850b77d8f6ea00b3b60612/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs?ref=09919c2b596b19ad36850b77d8f6ea00b3b60612", "patch": "@@ -0,0 +1,12 @@\n+// Make sure we cannot use raw ptrs that got transmuted from mutable references\n+// (i.e, no EscapeToRaw happened).\n+// We could, in principle, to EscapeToRaw lazily to allow this code, but that\n+// would no alleviate the need for EscapeToRaw (see `ref_raw_int_raw` in\n+// `run-pass/stacked-borrows.rs`), and thus increase overall complexity.\n+use std::mem;\n+\n+fn main() {\n+    let mut x: i32 = 42;\n+    let raw: *mut i32 = unsafe { mem::transmute(&mut x) };\n+    unsafe { *raw = 13; } //~ ERROR does not exist on the stack\n+}"}, {"sha": "054697b04a09d8ea45b3db3b233f4c3efa480351", "filename": "tests/compile-fail/stacked_borrows/unescaped_local.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09919c2b596b19ad36850b77d8f6ea00b3b60612/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09919c2b596b19ad36850b77d8f6ea00b3b60612/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs?ref=09919c2b596b19ad36850b77d8f6ea00b3b60612", "patch": "@@ -1,10 +1,8 @@\n-use std::mem;\n-\n // Make sure we cannot use raw ptrs to access a local that\n-// has never been escaped to the raw world.\n+// we took the direct address of.\n fn main() {\n     let mut x = 42;\n-    let ptr = &mut x;\n-    let raw: *mut i32 = unsafe { mem::transmute(ptr) };\n+    let raw = &mut x as *mut i32 as usize as *mut i32;\n+    let _ptr = &mut x;\n     unsafe { *raw = 13; } //~ ERROR does not exist on the stack\n }"}, {"sha": "adab2b5a5683abea9f66fe40c7e2cbdeb997377f", "filename": "tests/run-pass/stacked-borrows.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/09919c2b596b19ad36850b77d8f6ea00b3b60612/tests%2Frun-pass%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09919c2b596b19ad36850b77d8f6ea00b3b60612/tests%2Frun-pass%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows.rs?ref=09919c2b596b19ad36850b77d8f6ea00b3b60612", "patch": "@@ -3,15 +3,17 @@ fn main() {\n     deref_partially_dangling_raw();\n     read_does_not_invalidate1();\n     read_does_not_invalidate2();\n+    ref_raw_int_raw();\n }\n \n // Deref a raw ptr to access a field of a large struct, where the field\n // is allocated but not the entire struct is.\n // For now, we want to allow this.\n fn deref_partially_dangling_raw() {\n-    let x = (1, 1);\n+    let x = (1, 13);\n     let xptr = &x as *const _ as *const (i32, i32, i32);\n-    let _val = unsafe { (*xptr).1 };\n+    let val = unsafe { (*xptr).1 };\n+    assert_eq!(val, 13);\n }\n \n // Make sure that reading from an `&mut` does, like reborrowing to `&`,\n@@ -23,7 +25,7 @@ fn read_does_not_invalidate1() {\n         let _val = x.1; // we just read, this does NOT invalidate the reborrows.\n         ret\n     }\n-    foo(&mut (1, 2));\n+    assert_eq!(*foo(&mut (1, 2)), 2);\n }\n // Same as above, but this time we first create a raw, then read from `&mut`\n // and then freeze from the raw.\n@@ -34,5 +36,15 @@ fn read_does_not_invalidate2() {\n         let ret = unsafe { &(*xraw).1 };\n         ret\n     }\n-    foo(&mut (1, 2));\n+    assert_eq!(*foo(&mut (1, 2)), 2);\n+}\n+\n+// Just to make sure that casting a ref to raw, to int and back to raw\n+// and only then using it works.  This rules out ideas like \"do escape-to-raw lazily\":\n+// After casting to int and back, we lost the tag that could have let us do that.\n+fn ref_raw_int_raw() {\n+    let mut x = 3;\n+    let xref = &mut x;\n+    let xraw = xref as *mut i32 as usize as *mut i32;\n+    assert_eq!(unsafe { *xraw }, 3);\n }"}]}