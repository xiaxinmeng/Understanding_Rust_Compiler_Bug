{"sha": "154ca0838868ca08a8aae20f6af245e2b970a3de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NGNhMDgzODg2OGNhMDhhOGFhZTIwZjZhZjI0NWUyYjk3MGEzZGU=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-14T23:27:54Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-15T21:33:14Z"}, "message": "use trait rather than fns\n\nplease note the snapshot-waiting unpleasantness. I'm\nunable to use the traditional #[cfg(stage0)] mechanism\nto swap the new style in for later compiler stages,\nbecause macros invocations in method positions cause\nthe parser to choke before cfg can strip it out.\n\nParenthetical note: this problem wouldn't arise with\nan interleaved parsing/expansion....", "tree": {"sha": "3a56d499d99bd753d7a2056f80543e56cc6104fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a56d499d99bd753d7a2056f80543e56cc6104fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/154ca0838868ca08a8aae20f6af245e2b970a3de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/154ca0838868ca08a8aae20f6af245e2b970a3de", "html_url": "https://github.com/rust-lang/rust/commit/154ca0838868ca08a8aae20f6af245e2b970a3de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/154ca0838868ca08a8aae20f6af245e2b970a3de/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b422373d862082b1a27bd7d0e2319a31ad745aae", "url": "https://api.github.com/repos/rust-lang/rust/commits/b422373d862082b1a27bd7d0e2319a31ad745aae", "html_url": "https://github.com/rust-lang/rust/commit/b422373d862082b1a27bd7d0e2319a31ad745aae"}], "stats": {"total": 102, "additions": 81, "deletions": 21}, "files": [{"sha": "5431a3db16ecb24a437f29161f47ff15fab16232", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 81, "deletions": 21, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/154ca0838868ca08a8aae20f6af245e2b970a3de/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154ca0838868ca08a8aae20f6af245e2b970a3de/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=154ca0838868ca08a8aae20f6af245e2b970a3de", "patch": "@@ -742,37 +742,98 @@ pub fn static_has_significant_address(mutbl: ast::Mutability,\n     inline == InlineNever || inline == InlineNone\n }\n \n-\n /// Macro invocations are guaranteed not to occur after expansion is complete.\n-/// extracting fields of a method requires a dynamic check to make sure that it's\n-/// not a macro invocation, though this check is guaranteed to succeed, assuming\n+/// Extracting fields of a method requires a dynamic check to make sure that it's\n+/// not a macro invocation. This check is guaranteed to succeed, assuming\n /// that the invocations are indeed gone.\n-macro_rules! method_field_extractor {\n-    ($fn_name:ident, $field_ty:ty, $field_pat:pat, $result:ident) => {\n-        /// Returns the ident of a Method. To be used after expansion is complete\n-        pub fn $fn_name<'a>(method: &'a ast::Method) -> $field_ty {\n-            match method.node {\n+pub trait PostExpansionMethod {\n+    fn pe_ident(&self) -> ast::Ident;\n+    fn pe_generics<'a>(&'a self) -> &'a ast::Generics;\n+    fn pe_explicit_self<'a>(&'a self) -> &'a ast::ExplicitSelf;\n+    fn pe_fn_style(&self) -> ast::FnStyle;\n+    fn pe_fn_decl(&self) -> P<ast::FnDecl>;\n+    fn pe_body(&self) -> P<ast::Block>;\n+    fn pe_vis(&self) -> ast::Visibility;\n+}\n+\n+\n+/// can't use the standard cfg(stage0) tricks here, because the error occurs in\n+/// parsing, before cfg gets a chance to save the day. (yes, interleaved parsing\n+/// / expansion / configuring would solve this problem...)\n+\n+// NOTE: remove after next snapshot\n+/// to be more specific: after a snapshot, swap out the \"PRE\" stuff, and\n+// swap in the \"POST\" stuff.\n+\n+/// PRE\n+macro_rules! mf_method_body{\n+    ($slf:ident, $field_pat:pat, $result:ident) => {\n+        match $slf.node {\n+            $field_pat => $result,\n+                MethMac(_) => {\n+                    fail!(\"expected an AST without macro invocations\");\n+                }\n+        }\n+    }\n+}\n+\n+/// POST\n+/*\n+#[cfg(not(stage0))]\n+macro_rules! mf_method{\n+    ($meth_name:ident, $field_ty:ty, $field_pat:pat, $result:ident) => {\n+        fn $meth_name<'a>(&'a self) -> $field_ty {\n+            match self.node {\n                 $field_pat => $result,\n                 MethMac(_) => {\n                     fail!(\"expected an AST without macro invocations\");\n                 }\n             }\n         }\n     }\n+}*/\n+\n+\n+// PRE\n+impl PostExpansionMethod for Method {\n+    fn pe_ident(&self) -> ast::Ident {\n+        mf_method_body!(self,MethDecl(ident,_,_,_,_,_,_),ident)\n+    }\n+    fn pe_generics<'a>(&'a self) -> &'a ast::Generics {\n+        mf_method_body!(self,MethDecl(_,ref generics,_,_,_,_,_),generics)\n+    }\n+    fn pe_explicit_self<'a>(&'a self) -> &'a ast::ExplicitSelf {\n+        mf_method_body!(self,MethDecl(_,_,ref explicit_self,_,_,_,_),explicit_self)\n+    }\n+    fn pe_fn_style(&self) -> ast::FnStyle{\n+        mf_method_body!(self,MethDecl(_,_,_,fn_style,_,_,_),fn_style)\n+    }\n+    fn pe_fn_decl(&self) -> P<ast::FnDecl> {\n+        mf_method_body!(self,MethDecl(_,_,_,_,decl,_,_),decl)\n+    }\n+    fn pe_body(&self) -> P<ast::Block> {\n+        mf_method_body!(self,MethDecl(_,_,_,_,_,body,_),body)\n+    }\n+    fn pe_vis(&self) -> ast::Visibility {\n+        mf_method_body!(self,MethDecl(_,_,_,_,_,_,vis),vis)\n+    }\n }\n \n-// Note: this is unhygienic in the lifetime 'a. In order to fix this, we'd have to\n-// add :lifetime as a macro argument type, so that the 'a could be supplied by the macro\n-// invocation.\n-pub method_field_extractor!(method_ident,ast::Ident,MethDecl(ident,_,_,_,_,_,_),ident)\n-pub method_field_extractor!(method_generics,&'a ast::Generics,\n-                            MethDecl(_,ref generics,_,_,_,_,_),generics)\n-pub method_field_extractor!(method_explicit_self,&'a ast::ExplicitSelf,\n-                            MethDecl(_,_,ref explicit_self,_,_,_,_),explicit_self)\n-pub method_field_extractor!(method_fn_style,ast::FnStyle,MethDecl(_,_,_,fn_style,_,_,_),fn_style)\n-pub method_field_extractor!(method_fn_decl,P<ast::FnDecl>,MethDecl(_,_,_,_,decl,_,_),decl)\n-pub method_field_extractor!(method_body,P<ast::Block>,MethDecl(_,_,_,_,_,body,_),body)\n-pub method_field_extractor!(method_vis,ast::Visibility,MethDecl(_,_,_,_,_,_,vis),vis)\n+// POST\n+/*\n+#[cfg(not(stage0))]\n+impl PostExpansionMethod for Method {\n+    mf_method!(pe_ident,ast::Ident,MethDecl(ident,_,_,_,_,_,_),ident)\n+    mf_method!(pe_generics,&'a ast::Generics,\n+               MethDecl(_,ref generics,_,_,_,_,_),generics)\n+    mf_method!(pe_explicit_self,&'a ast::ExplicitSelf,\n+               MethDecl(_,_,ref explicit_self,_,_,_,_),explicit_self)\n+    mf_method!(pe_fn_style,ast::FnStyle,MethDecl(_,_,_,fn_style,_,_,_),fn_style)\n+    mf_method!(pe_fn_decl,P<ast::FnDecl>,MethDecl(_,_,_,_,decl,_,_),decl)\n+    mf_method!(pe_body,P<ast::Block>,MethDecl(_,_,_,_,_,body,_),body)\n+    mf_method!(pe_vis,ast::Visibility,MethDecl(_,_,_,_,_,_,vis),vis)\n+}\n+*/\n \n #[cfg(test)]\n mod test {\n@@ -799,4 +860,3 @@ mod test {\n                 .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice()));\n     }\n }\n-"}]}