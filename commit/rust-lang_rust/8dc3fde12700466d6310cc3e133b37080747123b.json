{"sha": "8dc3fde12700466d6310cc3e133b37080747123b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYzNmZGUxMjcwMDQ2NmQ2MzEwY2MzZTEzM2IzNzA4MDc0NzEyM2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-04T10:53:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-04T10:53:03Z"}, "message": "Auto merge of #5246 - JarredAllen:master, r=flip1995\n\nDetect usage of custom floating-point abs implementation\n\nCloses #5224\n\nchangelog: Enhance [`suboptimal_flops`] lint to detect manual implementations of the `abs` method", "tree": {"sha": "a50286084b038ba0a2a20cd4def94a69d2d690e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a50286084b038ba0a2a20cd4def94a69d2d690e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dc3fde12700466d6310cc3e133b37080747123b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dc3fde12700466d6310cc3e133b37080747123b", "html_url": "https://github.com/rust-lang/rust/commit/8dc3fde12700466d6310cc3e133b37080747123b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dc3fde12700466d6310cc3e133b37080747123b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74eae9dc602bf8f1c54525bf3113e4b6508f0ade", "url": "https://api.github.com/repos/rust-lang/rust/commits/74eae9dc602bf8f1c54525bf3113e4b6508f0ade", "html_url": "https://github.com/rust-lang/rust/commit/74eae9dc602bf8f1c54525bf3113e4b6508f0ade"}, {"sha": "c3e96d14ab1b90b7e4ff1ea2222419a22c011ed5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3e96d14ab1b90b7e4ff1ea2222419a22c011ed5", "html_url": "https://github.com/rust-lang/rust/commit/c3e96d14ab1b90b7e4ff1ea2222419a22c011ed5"}], "stats": {"total": 431, "additions": 429, "deletions": 2}, "files": [{"sha": "0fcfb7b88497028668dcc28dc409df773afb5790", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 125, "deletions": 2, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/8dc3fde12700466d6310cc3e133b37080747123b/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dc3fde12700466d6310cc3e133b37080747123b/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=8dc3fde12700466d6310cc3e133b37080747123b", "patch": "@@ -1,8 +1,8 @@\n use crate::consts::{\n-    constant, Constant,\n+    constant, constant_simple, Constant,\n     Constant::{F32, F64},\n };\n-use crate::utils::{span_lint_and_sugg, sugg};\n+use crate::utils::{higher, span_lint_and_sugg, sugg, SpanlessEq};\n use if_chain::if_chain;\n use rustc::ty;\n use rustc_errors::Applicability;\n@@ -72,6 +72,16 @@ declare_clippy_lint! {\n     /// let _ = a.log(E);\n     /// let _ = a.powf(2.0);\n     /// let _ = a * 2.0 + 4.0;\n+    /// let _ = if a < 0.0 {\n+    ///     -a\n+    /// } else {\n+    ///     a\n+    /// };\n+    /// let _ = if a < 0.0 {\n+    ///     a\n+    /// } else {\n+    ///     -a\n+    /// };\n     /// ```\n     ///\n     /// is better expressed as\n@@ -88,6 +98,8 @@ declare_clippy_lint! {\n     /// let _ = a.ln();\n     /// let _ = a.powi(2);\n     /// let _ = a.mul_add(2.0, 4.0);\n+    /// let _ = a.abs();\n+    /// let _ = -a.abs();\n     /// ```\n     pub SUBOPTIMAL_FLOPS,\n     nursery,\n@@ -359,6 +371,116 @@ fn check_mul_add(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     }\n }\n \n+/// Returns true iff expr is an expression which tests whether or not\n+/// test is positive or an expression which tests whether or not test\n+/// is nonnegative.\n+/// Used for check-custom-abs function below\n+fn is_testing_positive(cx: &LateContext<'_, '_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n+    if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n+        match op {\n+            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n+            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+/// See [`is_testing_positive`]\n+fn is_testing_negative(cx: &LateContext<'_, '_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n+    if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n+        match op {\n+            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n+            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+fn are_exprs_equal(cx: &LateContext<'_, '_>, expr1: &Expr<'_>, expr2: &Expr<'_>) -> bool {\n+    SpanlessEq::new(cx).ignore_fn().eq_expr(expr1, expr2)\n+}\n+\n+/// Returns true iff expr is some zero literal\n+fn is_zero(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+    match constant_simple(cx, cx.tables, expr) {\n+        Some(Constant::Int(i)) => i == 0,\n+        Some(Constant::F32(f)) => f == 0.0,\n+        Some(Constant::F64(f)) => f == 0.0,\n+        _ => false,\n+    }\n+}\n+\n+/// If the two expressions are negations of each other, then it returns\n+/// a tuple, in which the first element is true iff expr1 is the\n+/// positive expressions, and the second element is the positive\n+/// one of the two expressions\n+/// If the two expressions are not negations of each other, then it\n+/// returns None.\n+fn are_negated<'a>(cx: &LateContext<'_, '_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a>) -> Option<(bool, &'a Expr<'a>)> {\n+    if let ExprKind::Unary(UnOp::UnNeg, expr1_negated) = &expr1.kind {\n+        if are_exprs_equal(cx, expr1_negated, expr2) {\n+            return Some((false, expr2));\n+        }\n+    }\n+    if let ExprKind::Unary(UnOp::UnNeg, expr2_negated) = &expr2.kind {\n+        if are_exprs_equal(cx, expr1, expr2_negated) {\n+            return Some((true, expr1));\n+        }\n+    }\n+    None\n+}\n+\n+fn check_custom_abs(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let Some((cond, body, Some(else_body))) = higher::if_block(&expr);\n+        if let ExprKind::Block(block, _) = body.kind;\n+        if block.stmts.is_empty();\n+        if let Some(if_body_expr) = block.expr;\n+        if let ExprKind::Block(else_block, _) = else_body.kind;\n+        if else_block.stmts.is_empty();\n+        if let Some(else_body_expr) = else_block.expr;\n+        if let Some((if_expr_positive, body)) = are_negated(cx, if_body_expr, else_body_expr);\n+        then {\n+            let positive_abs_sugg = (\n+                \"manual implementation of `abs` method\",\n+                format!(\"{}.abs()\", Sugg::hir(cx, body, \"..\")),\n+            );\n+            let negative_abs_sugg = (\n+                \"manual implementation of negation of `abs` method\",\n+                format!(\"-{}.abs()\", Sugg::hir(cx, body, \"..\")),\n+            );\n+            let sugg = if is_testing_positive(cx, cond, body) {\n+                if if_expr_positive {\n+                    positive_abs_sugg\n+                } else {\n+                    negative_abs_sugg\n+                }\n+            } else if is_testing_negative(cx, cond, body) {\n+                if if_expr_positive {\n+                    negative_abs_sugg\n+                } else {\n+                    positive_abs_sugg\n+                }\n+            } else {\n+                return;\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                SUBOPTIMAL_FLOPS,\n+                expr.span,\n+                sugg.0,\n+                \"try\",\n+                sugg.1,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatingPointArithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, args) = &expr.kind {\n@@ -375,6 +497,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatingPointArithmetic {\n         } else {\n             check_expm1(cx, expr);\n             check_mul_add(cx, expr);\n+            check_custom_abs(cx, expr);\n         }\n     }\n }"}, {"sha": "b623e4988e7d464528647b42477c0bc88c1783a9", "filename": "tests/ui/floating_point_abs.fixed", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/8dc3fde12700466d6310cc3e133b37080747123b/tests%2Fui%2Ffloating_point_abs.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8dc3fde12700466d6310cc3e133b37080747123b/tests%2Fui%2Ffloating_point_abs.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_abs.fixed?ref=8dc3fde12700466d6310cc3e133b37080747123b", "patch": "@@ -0,0 +1,98 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+struct A {\n+    a: f64,\n+    b: f64,\n+}\n+\n+fn fake_abs1(num: f64) -> f64 {\n+    num.abs()\n+}\n+\n+fn fake_abs2(num: f64) -> f64 {\n+    num.abs()\n+}\n+\n+fn fake_abs3(a: A) -> f64 {\n+    a.a.abs()\n+}\n+\n+fn fake_abs4(num: f64) -> f64 {\n+    num.abs()\n+}\n+\n+fn fake_abs5(a: A) -> f64 {\n+    a.a.abs()\n+}\n+\n+fn fake_nabs1(num: f64) -> f64 {\n+    -num.abs()\n+}\n+\n+fn fake_nabs2(num: f64) -> f64 {\n+    -num.abs()\n+}\n+\n+fn fake_nabs3(a: A) -> A {\n+    A {\n+        a: -a.a.abs(),\n+        b: a.b,\n+    }\n+}\n+\n+fn not_fake_abs1(num: f64) -> f64 {\n+    if num > 0.0 {\n+        num\n+    } else {\n+        -num - 1f64\n+    }\n+}\n+\n+fn not_fake_abs2(num: f64) -> f64 {\n+    if num > 0.0 {\n+        num + 1.0\n+    } else {\n+        -(num + 1.0)\n+    }\n+}\n+\n+fn not_fake_abs3(num1: f64, num2: f64) -> f64 {\n+    if num1 > 0.0 {\n+        num2\n+    } else {\n+        -num2\n+    }\n+}\n+\n+fn not_fake_abs4(a: A) -> f64 {\n+    if a.a > 0.0 {\n+        a.b\n+    } else {\n+        -a.b\n+    }\n+}\n+\n+fn not_fake_abs5(a: A) -> f64 {\n+    if a.a > 0.0 {\n+        a.a\n+    } else {\n+        -a.b\n+    }\n+}\n+\n+fn main() {\n+    fake_abs1(5.0);\n+    fake_abs2(5.0);\n+    fake_abs3(A { a: 5.0, b: 5.0 });\n+    fake_abs4(5.0);\n+    fake_abs5(A { a: 5.0, b: 5.0 });\n+    fake_nabs1(5.0);\n+    fake_nabs2(5.0);\n+    fake_nabs3(A { a: 5.0, b: 5.0 });\n+    not_fake_abs1(5.0);\n+    not_fake_abs2(5.0);\n+    not_fake_abs3(5.0, 5.0);\n+    not_fake_abs4(A { a: 5.0, b: 5.0 });\n+    not_fake_abs5(A { a: 5.0, b: 5.0 });\n+}"}, {"sha": "cbf9c94e41e6a125aa8f3877c55c93b287c4b1cd", "filename": "tests/ui/floating_point_abs.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8dc3fde12700466d6310cc3e133b37080747123b/tests%2Fui%2Ffloating_point_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dc3fde12700466d6310cc3e133b37080747123b/tests%2Fui%2Ffloating_point_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_abs.rs?ref=8dc3fde12700466d6310cc3e133b37080747123b", "patch": "@@ -0,0 +1,126 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+struct A {\n+    a: f64,\n+    b: f64,\n+}\n+\n+fn fake_abs1(num: f64) -> f64 {\n+    if num >= 0.0 {\n+        num\n+    } else {\n+        -num\n+    }\n+}\n+\n+fn fake_abs2(num: f64) -> f64 {\n+    if 0.0 < num {\n+        num\n+    } else {\n+        -num\n+    }\n+}\n+\n+fn fake_abs3(a: A) -> f64 {\n+    if a.a > 0.0 {\n+        a.a\n+    } else {\n+        -a.a\n+    }\n+}\n+\n+fn fake_abs4(num: f64) -> f64 {\n+    if 0.0 >= num {\n+        -num\n+    } else {\n+        num\n+    }\n+}\n+\n+fn fake_abs5(a: A) -> f64 {\n+    if a.a < 0.0 {\n+        -a.a\n+    } else {\n+        a.a\n+    }\n+}\n+\n+fn fake_nabs1(num: f64) -> f64 {\n+    if num < 0.0 {\n+        num\n+    } else {\n+        -num\n+    }\n+}\n+\n+fn fake_nabs2(num: f64) -> f64 {\n+    if 0.0 >= num {\n+        num\n+    } else {\n+        -num\n+    }\n+}\n+\n+fn fake_nabs3(a: A) -> A {\n+    A {\n+        a: if a.a >= 0.0 { -a.a } else { a.a },\n+        b: a.b,\n+    }\n+}\n+\n+fn not_fake_abs1(num: f64) -> f64 {\n+    if num > 0.0 {\n+        num\n+    } else {\n+        -num - 1f64\n+    }\n+}\n+\n+fn not_fake_abs2(num: f64) -> f64 {\n+    if num > 0.0 {\n+        num + 1.0\n+    } else {\n+        -(num + 1.0)\n+    }\n+}\n+\n+fn not_fake_abs3(num1: f64, num2: f64) -> f64 {\n+    if num1 > 0.0 {\n+        num2\n+    } else {\n+        -num2\n+    }\n+}\n+\n+fn not_fake_abs4(a: A) -> f64 {\n+    if a.a > 0.0 {\n+        a.b\n+    } else {\n+        -a.b\n+    }\n+}\n+\n+fn not_fake_abs5(a: A) -> f64 {\n+    if a.a > 0.0 {\n+        a.a\n+    } else {\n+        -a.b\n+    }\n+}\n+\n+fn main() {\n+    fake_abs1(5.0);\n+    fake_abs2(5.0);\n+    fake_abs3(A { a: 5.0, b: 5.0 });\n+    fake_abs4(5.0);\n+    fake_abs5(A { a: 5.0, b: 5.0 });\n+    fake_nabs1(5.0);\n+    fake_nabs2(5.0);\n+    fake_nabs3(A { a: 5.0, b: 5.0 });\n+    not_fake_abs1(5.0);\n+    not_fake_abs2(5.0);\n+    not_fake_abs3(5.0, 5.0);\n+    not_fake_abs4(A { a: 5.0, b: 5.0 });\n+    not_fake_abs5(A { a: 5.0, b: 5.0 });\n+}"}, {"sha": "74a71f2ca7c574f8fc5750115aef190bc373e097", "filename": "tests/ui/floating_point_abs.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8dc3fde12700466d6310cc3e133b37080747123b/tests%2Fui%2Ffloating_point_abs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8dc3fde12700466d6310cc3e133b37080747123b/tests%2Fui%2Ffloating_point_abs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_abs.stderr?ref=8dc3fde12700466d6310cc3e133b37080747123b", "patch": "@@ -0,0 +1,80 @@\n+error: manual implementation of `abs` method\n+  --> $DIR/floating_point_abs.rs:10:5\n+   |\n+LL | /     if num >= 0.0 {\n+LL | |         num\n+LL | |     } else {\n+LL | |         -num\n+LL | |     }\n+   | |_____^ help: try: `num.abs()`\n+   |\n+   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n+\n+error: manual implementation of `abs` method\n+  --> $DIR/floating_point_abs.rs:18:5\n+   |\n+LL | /     if 0.0 < num {\n+LL | |         num\n+LL | |     } else {\n+LL | |         -num\n+LL | |     }\n+   | |_____^ help: try: `num.abs()`\n+\n+error: manual implementation of `abs` method\n+  --> $DIR/floating_point_abs.rs:26:5\n+   |\n+LL | /     if a.a > 0.0 {\n+LL | |         a.a\n+LL | |     } else {\n+LL | |         -a.a\n+LL | |     }\n+   | |_____^ help: try: `a.a.abs()`\n+\n+error: manual implementation of `abs` method\n+  --> $DIR/floating_point_abs.rs:34:5\n+   |\n+LL | /     if 0.0 >= num {\n+LL | |         -num\n+LL | |     } else {\n+LL | |         num\n+LL | |     }\n+   | |_____^ help: try: `num.abs()`\n+\n+error: manual implementation of `abs` method\n+  --> $DIR/floating_point_abs.rs:42:5\n+   |\n+LL | /     if a.a < 0.0 {\n+LL | |         -a.a\n+LL | |     } else {\n+LL | |         a.a\n+LL | |     }\n+   | |_____^ help: try: `a.a.abs()`\n+\n+error: manual implementation of negation of `abs` method\n+  --> $DIR/floating_point_abs.rs:50:5\n+   |\n+LL | /     if num < 0.0 {\n+LL | |         num\n+LL | |     } else {\n+LL | |         -num\n+LL | |     }\n+   | |_____^ help: try: `-num.abs()`\n+\n+error: manual implementation of negation of `abs` method\n+  --> $DIR/floating_point_abs.rs:58:5\n+   |\n+LL | /     if 0.0 >= num {\n+LL | |         num\n+LL | |     } else {\n+LL | |         -num\n+LL | |     }\n+   | |_____^ help: try: `-num.abs()`\n+\n+error: manual implementation of negation of `abs` method\n+  --> $DIR/floating_point_abs.rs:67:12\n+   |\n+LL |         a: if a.a >= 0.0 { -a.a } else { a.a },\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `-a.a.abs()`\n+\n+error: aborting due to 8 previous errors\n+"}]}