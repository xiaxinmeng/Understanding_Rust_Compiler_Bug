{"sha": "9a48bd2f2133a76371cb92488620146be990a82c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNDhiZDJmMjEzM2E3NjM3MWNiOTI0ODg2MjAxNDZiZTk5MGE4MmM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-23T04:26:34Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-23T05:13:42Z"}, "message": "Compute typestate properly for move\n\ntypestate now drops constraints correctly in the post-state of\na move expression or a declaration whose op is a move. It doesn't\nyet drop constraints mentioning variables that get updated.\n\nTo do this, I had to change typestate to use trit-vectors instead\nof bit-vectors, because for every constraint, there are three\npossible values: known-to-be-false (e.g. after x <- y, init(y) is\nknown-to-be-false), known-to-be-true, and unknown. Before, we\nconflated known-to-be-false with unknown. But move requires them\nto be treated differently. Consider:\n\n(program a)\n(a1) x = 1;\n(a2) y <- x;\n(a3) log x;\n\n(program b)\n(b1) x = 1;\n(b2) y <- z;\n(b3) log x;\n\nWith only two values, the postcondition of statement a2 for\nconstraint init(x) is the same as that of b2: 0. But in (a2)'s\npostcondition, init(x) *must* be false, but in (b2)'s condition,\nit's just whatever it was in the postcondition of the preceding statement.", "tree": {"sha": "4664e8f3de63d83e5497e857a7a0f27bc24b3625", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4664e8f3de63d83e5497e857a7a0f27bc24b3625"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a48bd2f2133a76371cb92488620146be990a82c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a48bd2f2133a76371cb92488620146be990a82c", "html_url": "https://github.com/rust-lang/rust/commit/9a48bd2f2133a76371cb92488620146be990a82c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a48bd2f2133a76371cb92488620146be990a82c/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7105cd1761c9ad84f95381f021ca4960e2bd0641", "url": "https://api.github.com/repos/rust-lang/rust/commits/7105cd1761c9ad84f95381f021ca4960e2bd0641", "html_url": "https://github.com/rust-lang/rust/commit/7105cd1761c9ad84f95381f021ca4960e2bd0641"}], "stats": {"total": 844, "additions": 625, "deletions": 219}, "files": [{"sha": "a894dde11a644ecf4d4cf0295e63c6506fb04269", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 69, "deletions": 61, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=9a48bd2f2133a76371cb92488620146be990a82c", "patch": "@@ -1,36 +1,36 @@\n \n import front::ast::ident;\n import std::vec;\n-import std::bitv;\n+import tritv::*;\n \n+type precond = t;\n \n-/* \n-   This says: this expression requires the idents in <pre> to be initialized,\n-   and given the precondition, it guarantees that the idents in <post> are\n-   initialized.\n- */\n-type precond = bitv::t;\n+/* 2 means \"this constraint may or may not be true after execution\" \n+   1 means \"this constraint is definitely true after execution\"\n+   0 means \"this constraint is definitely false after execution\" */\n+type postcond = t;\n \n \n-/* 1 means \"this variable must be initialized\"\n-  0 means \"don't care about this variable\" */\n-type postcond = bitv::t;\n+/* 2 means \"don't know about this constraint\"\n+   1 means \"this constraint is definitely true before entry\"\n+   0 means \"this constraint is definitely false on entry\" */\n+type prestate = t;\n \n \n-/* 1 means \"this variable is initialized\"\n-  0 means \"don't know about this variable */\n-type prestate = bitv::t;\n+/* similar to postcond */\n+type poststate = t;\n \n \n /* 1 means \"this variable is definitely initialized\"\n   0 means \"don't know whether this variable is\n   initialized\" */\n-type poststate = bitv::t;\n-\n \n-/* 1 means \"this variable is definitely initialized\"\n-  0 means \"don't know whether this variable is\n-  initialized\" */\n+/* \n+   This says: this expression requires the constraints whose value is 1 in\n+   <pre> to be true, and given the precondition, it guarantees that the\n+   constraints in <post> whose values are 1 are true, and that the constraints\n+   in <post> whose values are 0 are false.\n+ */\n \n /* named thus so as not to confuse with prestate and poststate */\n type pre_and_post = @rec(precond precondition, postcond postcondition);\n@@ -44,7 +44,7 @@ type pre_and_post_state = rec(prestate prestate, poststate poststate);\n type ts_ann = @rec(pre_and_post conditions, pre_and_post_state states);\n \n fn true_precond(uint num_vars) -> precond {\n-    be bitv::create(num_vars, false);\n+    be create_tritv(num_vars);\n }\n \n fn true_postcond(uint num_vars) -> postcond { be true_precond(num_vars); }\n@@ -54,7 +54,9 @@ fn empty_prestate(uint num_vars) -> prestate { be true_precond(num_vars); }\n fn empty_poststate(uint num_vars) -> poststate { be true_precond(num_vars); }\n \n fn false_postcond(uint num_vars) -> postcond {\n-    be bitv::create(num_vars, true);\n+    auto res = create_tritv(num_vars);\n+    tritv_set_all(res);\n+    ret res;\n }\n \n fn empty_pre_post(uint num_vars) -> pre_and_post {\n@@ -77,12 +79,16 @@ fn get_pre(&pre_and_post p) -> precond { ret p.precondition; }\n fn get_post(&pre_and_post p) -> postcond { ret p.postcondition; }\n \n fn difference(&precond p1, &precond p2) -> bool {\n-    be bitv::difference(p1, p2);\n+    ret tritv_difference(p1, p2);\n }\n \n-fn union(&precond p1, &precond p2) -> bool { be bitv::union(p1, p2); }\n+fn union(&precond p1, &precond p2) -> bool {\n+    ret tritv_union(p1, p2);\n+}\n \n-fn intersect(&precond p1, &precond p2) -> bool { be bitv::intersect(p1, p2); }\n+fn intersect(&precond p1, &precond p2) -> bool {\n+    ret tritv_intersect(p1, p2);\n+}\n \n fn pps_len(&pre_and_post p) -> uint {\n     // gratuitous check\n@@ -93,86 +99,88 @@ fn pps_len(&pre_and_post p) -> uint {\n \n fn require(uint i, &pre_and_post p) {\n     // sets the ith bit in p's pre\n-\n-    bitv::set(p.precondition, i, true);\n+    tritv_set(i, p.precondition, ttrue);\n }\n \n fn require_and_preserve(uint i, &pre_and_post p) {\n     // sets the ith bit in p's pre and post\n-\n-    bitv::set(p.precondition, i, true);\n-    bitv::set(p.postcondition, i, true);\n+    tritv_set(i, p.precondition, ttrue);\n+    tritv_set(i, p.postcondition, ttrue);\n }\n \n fn set_in_postcond(uint i, &pre_and_post p) -> bool {\n     // sets the ith bit in p's post\n-\n-    auto was_set = bitv::get(p.postcondition, i);\n-    bitv::set(p.postcondition, i, true);\n-    ret !was_set;\n+    auto was_set = tritv_get(p.postcondition, i);\n+    tritv_set(i, p.postcondition, ttrue);\n+    ret was_set != ttrue;\n }\n \n fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n     // sets the ith bit in p's post\n-\n-    auto was_set = bitv::get(s.poststate, i);\n-    bitv::set(s.poststate, i, true);\n-    ret !was_set;\n+    auto was_set = tritv_get(s.poststate, i);\n+    tritv_set(i, s.poststate, ttrue);\n+    ret was_set != ttrue;\n }\n \n fn clear_in_poststate(uint i, &pre_and_post_state s) -> bool {\n     // sets the ith bit in p's post\n-\n-    auto was_set = bitv::get(s.poststate, i);\n-    bitv::set(s.poststate, i, false);\n-    ret was_set;\n+    auto was_set = tritv_get(s.poststate, i);\n+    tritv_set(i, s.poststate, tfalse);\n+    ret was_set != tfalse;\n }\n \n+fn clear_in_postcond(uint i, &pre_and_post s) -> bool {\n+    // sets the ith bit in p's post\n+    auto was_set = tritv_get(s.postcondition, i);\n+    tritv_set(i, s.postcondition, tfalse);\n+    ret was_set != tfalse;\n+}\n \n // Sets all the bits in a's precondition to equal the\n // corresponding bit in p's precondition.\n fn set_precondition(ts_ann a, &precond p) {\n-    bitv::copy(a.conditions.precondition, p);\n+    tritv_copy(a.conditions.precondition, p);\n }\n \n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n fn set_postcondition(ts_ann a, &postcond p) {\n-    bitv::copy(a.conditions.postcondition, p);\n+    tritv_copy(a.conditions.postcondition, p);\n }\n \n \n // Sets all the bits in a's prestate to equal the\n // corresponding bit in p's prestate.\n fn set_prestate(ts_ann a, &prestate p) -> bool {\n-    ret bitv::copy(a.states.prestate, p);\n+    ret tritv_copy(a.states.prestate, p);\n }\n \n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n fn set_poststate(ts_ann a, &poststate p) -> bool {\n-    ret bitv::copy(a.states.poststate, p);\n+    ret tritv_copy(a.states.poststate, p);\n }\n \n \n // Set all the bits in p that are set in new\n fn extend_prestate(&prestate p, &poststate new) -> bool {\n-    ret bitv::union(p, new);\n+    ret tritv_union(p, new);\n }\n \n \n // Set all the bits in p that are set in new\n fn extend_poststate(&poststate p, &poststate new) -> bool {\n-    ret bitv::union(p, new);\n+    ret tritv_union(p, new);\n }\n \n-// Clears the given bit in p\n+// Sets the given bit in p to \"don't care\"\n+// FIXME: is this correct?\n fn relax_prestate(uint i, &prestate p) -> bool {\n-    auto was_set = bitv::get(p, i);\n-    bitv::set(p, i, false);\n-    ret was_set;\n+    auto was_set = tritv_get(p, i);\n+    tritv_set(i, p, dont_care);\n+    ret was_set != dont_care;\n }\n \n // Clears the given bit in p\n@@ -185,12 +193,11 @@ fn relax_precond(uint i, &precond p) {\n     relax_prestate(i, p);\n }\n \n-// Clears all the bits in p\n-fn clear(&precond p) { bitv::clear(p); }\n-\n+// Sets all the bits in p to \"don't care\"\n+fn clear(&precond p) { tritv_clear(p); }\n \n-// Sets all the bits in p\n-fn set(&precond p) { bitv::set_all(p); }\n+// Sets all the bits in p to true\n+fn set(&precond p) { tritv_set_all(p); }\n \n fn ann_precond(&ts_ann a) -> precond { ret a.conditions.precondition; }\n \n@@ -203,16 +210,17 @@ fn pp_clone(&pre_and_post p) -> pre_and_post {\n              postcondition=clone(p.postcondition));\n }\n \n-fn clone(prestate p) -> prestate { ret bitv::clone(p); }\n+fn clone(prestate p) -> prestate { ret tritv_clone(p); }\n \n \n // returns true if a implies b\n // that is, returns true except if for some bits c and d,\n-// c = 1 and d = 0\n-fn implies(bitv::t a, bitv::t b) -> bool {\n-    auto tmp = bitv::clone(b);\n-    bitv::difference(tmp, a);\n-    ret bitv::is_false(tmp);\n+// c = 1 and d = either 0 or \"don't know\"\n+// FIXME: is this correct?\n+fn implies(t a, t b) -> bool {\n+    auto tmp = tritv_clone(b);\n+    tritv_difference(tmp, a);\n+    ret tritv_doesntcare(tmp);\n }\n //\n // Local Variables:"}, {"sha": "a21db0407b2813dd38f0ec9cf7d9c9469157a5fe", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 122, "deletions": 41, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=9a48bd2f2133a76371cb92488620146be990a82c", "patch": "@@ -1,5 +1,3 @@\n-\n-import std::bitv;\n import std::str;\n import std::vec;\n import std::vec::len;\n@@ -39,6 +37,10 @@ import tstate::ann::extend_poststate;\n import tstate::ann::set_precondition;\n import tstate::ann::set_postcondition;\n import tstate::ann::ts_ann;\n+import tstate::ann::clear_in_postcond;\n+import tstate::ann::clear_in_poststate;\n+import tritv::*;\n+\n import pretty::ppaux::constr_args_to_str;\n import pretty::ppaux::lit_to_str;\n \n@@ -53,7 +55,7 @@ fn comma_str(vec[@constr_arg_use] args) -> str {\n         if (comma) { res += \", \"; } else { comma = true; }\n         alt (a.node) {\n             case (carg_base) { res += \"*\"; }\n-            case (carg_ident(?i)) { res += i; }\n+            case (carg_ident(?i)) { res += i._0; }\n             case (carg_lit(?l)) { res += lit_to_str(l); }\n         }\n     }\n@@ -72,29 +74,33 @@ fn constraint_to_str(&ty::ctxt tcx, &constr c) -> str {\n     }\n }\n \n-fn bitv_to_str(fn_ctxt fcx, bitv::t v) -> str {\n+fn tritv_to_str(fn_ctxt fcx, &tritv::t v) -> str {\n     auto s = \"\";\n     auto comma = false;\n     for (norm_constraint p in constraints(fcx)) {\n-        if (bitv::get(v, p.bit_num)) {\n-            s +=\n-                if (comma) { \", \" } else { comma = true; \"\" } +\n-                    aux::constraint_to_str(fcx.ccx.tcx, p.c);\n+        alt (tritv_get(v, p.bit_num)) {\n+            case (dont_care) { }\n+            case (?t) {\n+                s +=\n+                    if (comma) { \", \" } else { comma = true; \"\" } +\n+                    if (t == tfalse) { \"!\" } else { \"\" } +                  \n+                    constraint_to_str(fcx.ccx.tcx, p.c);\n+            }\n         }\n     }\n     ret s;\n }\n \n-fn log_bitv(&fn_ctxt fcx, &bitv::t v) { log bitv_to_str(fcx, v); }\n+fn log_tritv(&fn_ctxt fcx, &tritv::t v) { log tritv_to_str(fcx, v); }\n \n-fn first_difference_string(&fn_ctxt fcx, &bitv::t expected, &bitv::t actual)\n+fn first_difference_string(&fn_ctxt fcx, &tritv::t expected, &tritv::t actual)\n    -> str {\n     let str s = \"\";\n     auto done = false;\n     for (norm_constraint c in constraints(fcx)) {\n         if (!done) {\n-            if (bitv::get(expected, c.bit_num) &&\n-                    !bitv::get(actual, c.bit_num)) {\n+            if (tritv_get(expected, c.bit_num) == ttrue &&\n+                tritv_get(actual, c.bit_num) != ttrue) {\n                 /*\n                   FIXME\n                   for fun, try either:\n@@ -111,11 +117,13 @@ fn first_difference_string(&fn_ctxt fcx, &bitv::t expected, &bitv::t actual)\n     ret s;\n }\n \n-fn log_bitv_err(fn_ctxt fcx, bitv::t v) { log_err bitv_to_str(fcx, v); }\n+fn log_tritv_err(fn_ctxt fcx, tritv::t v) { log_err tritv_to_str(fcx, v); }\n \n fn tos(vec[uint] v) -> str {\n     auto res = \"\";\n-    for (uint i in v) { if (i == 0u) { res += \"0\"; } else { res += \"1\"; } }\n+    for (uint i in v) { if (i == 0u) { res += \"0\"; } \n+        else if (i == 1u) { res += \"1\"; }\n+        else { res += \"?\"; } }\n     ret res;\n }\n \n@@ -124,35 +132,35 @@ fn log_cond(vec[uint] v) { log tos(v); }\n fn log_cond_err(vec[uint] v) { log_err tos(v); }\n \n fn log_pp(&pre_and_post pp) {\n-    auto p1 = bitv::to_vec(pp.precondition);\n-    auto p2 = bitv::to_vec(pp.postcondition);\n+    auto p1 = tritv::to_vec(pp.precondition);\n+    auto p2 = tritv::to_vec(pp.postcondition);\n     log \"pre:\";\n     log_cond(p1);\n     log \"post:\";\n     log_cond(p2);\n }\n \n fn log_pp_err(&pre_and_post pp) {\n-    auto p1 = bitv::to_vec(pp.precondition);\n-    auto p2 = bitv::to_vec(pp.postcondition);\n+    auto p1 = tritv::to_vec(pp.precondition);\n+    auto p2 = tritv::to_vec(pp.postcondition);\n     log_err \"pre:\";\n     log_cond_err(p1);\n     log_err \"post:\";\n     log_cond_err(p2);\n }\n \n fn log_states(&pre_and_post_state pp) {\n-    auto p1 = bitv::to_vec(pp.prestate);\n-    auto p2 = bitv::to_vec(pp.poststate);\n+    auto p1 = tritv::to_vec(pp.prestate);\n+    auto p2 = tritv::to_vec(pp.poststate);\n     log \"prestate:\";\n     log_cond(p1);\n     log \"poststate:\";\n     log_cond(p2);\n }\n \n fn log_states_err(&pre_and_post_state pp) {\n-    auto p1 = bitv::to_vec(pp.prestate);\n-    auto p2 = bitv::to_vec(pp.poststate);\n+    auto p1 = tritv::to_vec(pp.prestate);\n+    auto p2 = tritv::to_vec(pp.poststate);\n     log_err \"prestate:\";\n     log_cond_err(p1);\n     log_err \"poststate:\";\n@@ -202,7 +210,7 @@ type pred_desc_ = rec(vec[@constr_arg_use] args, uint bit_num);\n \n type pred_desc = spanned[pred_desc_];\n \n-type constr_arg_use = constr_arg_general[ident];\n+type constr_arg_use = constr_arg_general[tup(ident, def_id)];\n \n tag constraint {\n     cinit(uint, span, ident);\n@@ -377,12 +385,6 @@ fn block_poststate(&crate_ctxt ccx, &block b) -> poststate {\n     ret block_states(ccx, b).poststate;\n }\n \n-\n-/* sets the pre_and_post for an ann */\n-fn with_pp(&crate_ctxt ccx, node_id id, pre_and_post p) {\n-    add_node(ccx, id, @rec(conditions=p, states=empty_states(pps_len(p))));\n-}\n-\n fn set_prestate_ann(&crate_ctxt ccx, node_id id, &prestate pre) -> bool {\n     log \"set_prestate_ann\";\n     ret set_prestate(node_id_to_ts_ann(ccx, id), pre);\n@@ -519,17 +521,16 @@ fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n     ret res;\n }\n \n-\n-// FIXME:\n-// this probably doesn't handle name shadowing well (or at all)\n-// variables should really always be id'd by def_id and not ident\n fn match_args(&fn_ctxt fcx, vec[pred_desc] occs, vec[@constr_arg_use] occ) ->\n    uint {\n     log \"match_args: looking at \" +\n-            pretty::ppaux::constr_args_to_str(std::util::id[str], occ);\n+        pretty::ppaux::constr_args_to_str(std::util::fst[ident, def_id], occ);\n     for (pred_desc pd in occs) {\n         log \"match_args: candidate \" + pred_desc_to_str(pd);\n-        if (ty::args_eq(str::eq, pd.node.args, occ)) { ret pd.node.bit_num; }\n+        fn eq(&tup(ident, def_id) p, &tup(ident, def_id) q) -> bool {\n+            ret p._1 == q._1;\n+        }\n+        if (ty::args_eq(eq, pd.node.args, occ)) { ret pd.node.bit_num; }\n     }\n     fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");\n }\n@@ -549,11 +550,20 @@ fn node_id_for_constr(ty::ctxt tcx, node_id t) -> node_id {\n fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n     alt (e.node) {\n         case (expr_path(?p)) {\n-            if (vec::len(p.node.idents) == 1u) {\n-                ret @respan(p.span, carg_ident[ident](p.node.idents.(0)));\n-            } else {\n-                tcx.sess.bug(\"exprs_to_constr_args: non-local variable \" +\n+            alt (tcx.def_map.find(e.id)) {\n+                case (some(def_local(?l_id))) {\n+                    ret @respan(p.span, carg_ident(tup(p.node.idents.(0),\n+                                                       l_id)));\n+                }\n+                case (some(def_arg(?a_id))) {\n+                    ret @respan(p.span, carg_ident(tup(p.node.idents.(0),\n+                                                       a_id)));\n+                }\n+                case (_) {\n+                    tcx.sess.bug(\"exprs_to_constr_args: non-local variable \" +\n                                  \"as pred arg\");\n+                        \n+                }\n             }\n         }\n         case (expr_lit(?l)) { ret @respan(e.span, carg_lit(l)); }\n@@ -601,8 +611,8 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n \n fn pred_desc_to_str(&pred_desc p) -> str {\n     ret \"<\" + uistr(p.node.bit_num) + \", \" +\n-            pretty::ppaux::constr_args_to_str(std::util::id[str], p.node.args)\n-            + \">\";\n+        pretty::ppaux::constr_args_to_str(std::util::fst[ident, def_id],\n+                                          p.node.args) + \">\";\n }\n \n fn substitute_constr_args(&ty::ctxt cx, &vec[@expr] actuals,\n@@ -644,6 +654,77 @@ tag if_ty {\n     if_check;\n     plain_if;\n }\n+\n+fn local_node_id_to_def_id(&fn_ctxt fcx, &span sp, &node_id i) -> def_id {\n+    alt (fcx.ccx.tcx.def_map.find(i)) {\n+        case (some(def_local(?d_id))) {\n+            ret d_id;\n+        }\n+        case (some (def_arg(?a_id))) {\n+            ret a_id;\n+        }\n+        case (some(_)) {\n+            fcx.ccx.tcx.sess.span_fatal(sp, \"local_node_id_to_def_id: id \\\n+               isn't a local\");\n+        }\n+        case (none) {\n+            // should really be bug. span_bug()?\n+            fcx.ccx.tcx.sess.span_fatal(sp, \"local_node_id_to_def_id: id \\\n+               is unbound\");\n+        }\n+    }\n+}\n+\n+fn forget_in_postcond(&fn_ctxt fcx, &span dead_sp,\n+                      node_id parent_exp, node_id dead_v) {\n+    // In the postcondition given by parent_exp, clear the bits\n+    // for any constraints mentioning dead_v\n+    auto d_id = local_node_id_to_def_id(fcx, dead_sp, dead_v);\n+    for (norm_constraint c in constraints(fcx)) {\n+        if (constraint_mentions(fcx, c, d_id)) {\n+            clear_in_postcond(c.bit_num,\n+              node_id_to_ts_ann(fcx.ccx, parent_exp).conditions);\n+        }\n+    }\n+}\n+\n+fn forget_in_poststate(&fn_ctxt fcx, &span dead_sp, \n+                       node_id parent_exp, node_id dead_v) -> bool {\n+    // In the poststate given by parent_exp, clear the bits\n+    // for any constraints mentioning dead_v\n+    auto d_id = local_node_id_to_def_id(fcx, dead_sp, dead_v);\n+    auto changed = false;\n+    for (norm_constraint c in constraints(fcx)) {\n+        if (constraint_mentions(fcx, c, d_id)) {\n+            changed = clear_in_poststate(c.bit_num,\n+              node_id_to_ts_ann(fcx.ccx, parent_exp).states) || changed;\n+        }\n+    }\n+    ret changed;\n+}\n+\n+fn constraint_mentions(&fn_ctxt fcx, &norm_constraint c, &def_id v) -> bool {\n+    ret (alt (c.c.node.c) {\n+            case (ninit(_)) {\n+                v == local_def(c.c.node.id)\n+            }\n+            case (npred(_, ?args)) {\n+                args_mention(args, v)\n+            }\n+        });\n+}\n+\n+\n+fn args_mention(&vec[@constr_arg_use] args, &def_id v) -> bool {\n+    fn mentions(&def_id v, &@constr_arg_use a) -> bool {\n+        alt (a.node) {\n+            case (carg_ident(?p1)) { p1._1 == v }\n+            case (_)               { false }\n+        }\n+    }\n+    ret util::common::any[@constr_arg_use](bind mentions(v,_), args);\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "d29e57c7d30102049cdc09cf848dbe8953ffe719", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 66, "deletions": 42, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=9a48bd2f2133a76371cb92488620146be990a82c", "patch": "@@ -1,12 +1,11 @@\n-\n-import std::bitv;\n+import front::ast::*;\n import std::vec;\n import std::vec::len;\n import std::vec::slice;\n-import front::ast::*;\n import aux::fn_ctxt;\n import aux::fn_info;\n-import aux::log_bitv;\n+import aux::log_tritv;\n+import aux::log_tritv_err;\n import aux::num_constraints;\n import aux::cinit;\n import aux::cpred;\n@@ -40,6 +39,7 @@ import tstate::ann::clone;\n import tstate::ann::set_in_postcond;\n import tstate::ann::set_in_poststate;\n import tstate::ann::clear_in_poststate;\n+import tritv::*;\n \n fn bit_num(&fn_ctxt fcx, &constr_ c) -> uint {\n     assert (fcx.enclosing.constrs.contains_key(c.id));\n@@ -67,57 +67,81 @@ fn bit_num(&fn_ctxt fcx, &constr_ c) -> uint {\n }\n \n fn promises(&fn_ctxt fcx, &poststate p, &constr_ c) -> bool {\n-    ret bitv::get(p, bit_num(fcx, c));\n+    ret tritv_get(p, bit_num(fcx, c)) == ttrue;\n+}\n+\n+// v \"happens after\" u\n+fn seq_trit(trit u, trit v) -> trit {\n+    alt (v) {\n+        case (ttrue)     { ttrue }\n+        case (tfalse)    { tfalse }\n+        case (dont_care) { u }\n+    }\n }\n \n+// idea: q \"happens after\" p -- so if something is\n+// 1 in q and 0 in p, it's 1 in the result; however,\n+// if it's 0 in q and 1 in p, it's 0 in the result\n+fn seq_tritv(&postcond p, &postcond q) {\n+    auto i = 0u;\n+    assert (p.nbits == q.nbits);\n+    while (i < p.nbits) {\n+        tritv_set(i, p, seq_trit(tritv_get(p, i), tritv_get(q, i)));\n+        i += 1u;\n+    }\n+}\n+\n+fn seq_postconds(&fn_ctxt fcx, &vec[postcond] ps) -> postcond {\n+    auto sz = vec::len(ps);\n+    if (sz >= 1u) {\n+        auto prev = tritv_clone(ps.(0));\n+        for (postcond p in slice(ps, 1u, sz)) {\n+            seq_tritv(prev, p);\n+        }\n+        ret prev;\n+    }\n+    else {\n+        ret ann::empty_poststate(num_constraints(fcx.enclosing));\n+    }\n+}\n \n // Given a list of pres and posts for exprs e0 ... en,\n // return the precondition for evaluating each expr in order.\n // So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n // precondition shouldn't include x.\n-fn seq_preconds(fn_ctxt fcx, vec[pre_and_post] pps) -> precond {\n-    let uint sz = len[pre_and_post](pps);\n+fn seq_preconds(&fn_ctxt fcx, &vec[pre_and_post] pps) -> precond {\n+    let uint sz = len(pps);\n     let uint num_vars = num_constraints(fcx.enclosing);\n+\n+    fn seq_preconds_go(&fn_ctxt fcx, &vec[pre_and_post] pps,\n+                       &pre_and_post first)\n+        -> precond {\n+        let uint sz = len(pps);\n+        if (sz >= 1u) {\n+            auto second = pps.(0);\n+            assert (pps_len(second) == num_constraints(fcx.enclosing));\n+            auto second_pre = clone(second.precondition);\n+            difference(second_pre, first.postcondition);\n+            auto next_first = clone(first.precondition);\n+            union(next_first, second_pre);\n+            auto next_first_post = clone(first.postcondition);\n+            seq_tritv(next_first_post, second.postcondition); \n+            ret seq_preconds_go(fcx, slice(pps, 1u, sz), \n+                                @rec(precondition=next_first,\n+                                     postcondition=next_first_post));\n+        }\n+        else {\n+            ret first.precondition;\n+        }\n+    }\n+\n     if (sz >= 1u) {\n         auto first = pps.(0);\n         assert (pps_len(first) == num_vars);\n-        let precond rest =\n-            seq_preconds(fcx, slice[pre_and_post](pps, 1u, sz));\n-        difference(rest, first.postcondition);\n-        auto res = clone(first.precondition);\n-        union(res, rest);\n-        log \"seq_preconds:\";\n-        log \"first.postcondition =\";\n-        log_bitv(fcx, first.postcondition);\n-        log \"rest =\";\n-        log_bitv(fcx, rest);\n-        log \"returning\";\n-        log_bitv(fcx, res);\n-        ret res;\n+        ret seq_preconds_go(fcx, slice(pps, 1u, sz), first);\n     } else { ret true_precond(num_vars); }\n }\n \n-\n-/* works on either postconds or preconds\n- should probably rethink the whole type synonym situation */\n-fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-    auto sz = vec::len[postcond](rest);\n-    if (sz > 0u) {\n-        auto other = rest.(0);\n-        union(first, other);\n-        union_postconds_go(first,\n-                           slice[postcond](rest, 1u, len[postcond](rest)));\n-    }\n-    ret first;\n-}\n-\n-fn union_postconds(uint nv, &vec[postcond] pcs) -> postcond {\n-    if (len[postcond](pcs) > 0u) {\n-        ret union_postconds_go(bitv::clone(pcs.(0)), pcs);\n-    } else { ret empty_prestate(nv); }\n-}\n-\n-\n /* Gee, maybe we could use foldl or something */\n fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n     auto sz = vec::len[postcond](rest);\n@@ -133,7 +157,7 @@ fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n \n fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n     assert (len[postcond](pcs) > 0u);\n-    ret intersect_postconds_go(bitv::clone(pcs.(0)), pcs);\n+    ret intersect_postconds_go(tritv_clone(pcs.(0)), pcs);\n }\n \n fn gen(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {"}, {"sha": "444880e02cacd17d1f8fec9bfb3ec90e81dea67b", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=9a48bd2f2133a76371cb92488620146be990a82c", "patch": "@@ -51,11 +51,11 @@ import aux::stmt_poststate;\n import aux::stmt_to_ann;\n import aux::num_constraints;\n import aux::fixed_point_states;\n-import aux::bitv_to_str;\n+import aux::tritv_to_str;\n import aux::first_difference_string;\n import pretty::pprust::ty_to_str;\n import util::common::log_stmt_err;\n-import aux::log_bitv_err;\n+import aux::log_tritv_err;\n import bitvectors::promises;\n import annotate::annotate_crate;\n import collect_locals::mk_f_to_fn_info;\n@@ -83,9 +83,9 @@ fn check_states_expr(&fn_ctxt fcx, &@expr e) {\n                 \") for expression:\\n\";\n         s += pretty::pprust::expr_to_str(e);\n         s += \"\\nPrecondition:\\n\";\n-        s += bitv_to_str(fcx, prec);\n+        s += tritv_to_str(fcx, prec);\n         s += \"\\nPrestate:\\n\";\n-        s += bitv_to_str(fcx, pres);\n+        s += tritv_to_str(fcx, pres);\n         fcx.ccx.tcx.sess.span_fatal(e.span, s);\n     }\n }\n@@ -112,9 +112,9 @@ fn check_states_stmt(&fn_ctxt fcx, &@stmt s) {\n                 \") for statement:\\n\";\n         ss += pretty::pprust::stmt_to_str(*s);\n         ss += \"\\nPrecondition:\\n\";\n-        ss += bitv_to_str(fcx, prec);\n+        ss += tritv_to_str(fcx, prec);\n         ss += \"\\nPrestate: \\n\";\n-        ss += bitv_to_str(fcx, pres);\n+        ss += tritv_to_str(fcx, pres);\n         fcx.ccx.tcx.sess.span_fatal(s.span, ss);\n     }\n }"}, {"sha": "91d1f82f366d8e2d86c261260767b6f01709af7e", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=9a48bd2f2133a76371cb92488620146be990a82c", "patch": "@@ -47,18 +47,23 @@ import aux::expr_to_constr;\n import aux::if_ty;\n import aux::if_check;\n import aux::plain_if;\n+import aux::forget_in_postcond;\n \n import aux::constraints_expr;\n import aux::substitute_constr_args;\n import aux::ninit;\n import aux::npred;\n import aux::path_to_ident;\n+import bitvectors::bit_num;\n+import bitvectors::promises;\n import bitvectors::seq_preconds;\n-import bitvectors::union_postconds;\n+import bitvectors::seq_postconds;\n import bitvectors::intersect_postconds;\n-import bitvectors::bit_num;\n-import bitvectors::gen;\n+import bitvectors::declare_var;\n+import bitvectors::gen_poststate;\n+import bitvectors::kill_poststate;\n import bitvectors::relax_precond_block;\n+import bitvectors::gen;\n import front::ast::*;\n import util::common::new_int_hash;\n import util::common::new_def_hash;\n@@ -153,9 +158,7 @@ fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, node_id id) {\n     auto pps = vec::map[@expr, pre_and_post](g, args);\n     auto h = get_post;\n     set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n-                     union_postconds(nv,\n-                                     vec::map[pre_and_post,\n-                                              postcond](h, pps)));\n+                     seq_postconds(fcx, vec::map(h, pps)));\n }\n \n fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n@@ -212,9 +215,8 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                              [expr_pp(fcx.ccx, antec),\n                               expr_pp(fcx.ccx, altern)]);\n             auto postcond_false_case =\n-                union_postconds(num_local_vars,\n-                                [expr_postcond(fcx.ccx, antec),\n-                                 expr_postcond(fcx.ccx, altern)]);\n+                seq_postconds(fcx, [expr_postcond(fcx.ccx, antec),\n+                                    expr_postcond(fcx.ccx, altern)]);\n \n             /* Be sure to set the bit for the check condition here,\n              so that it's *not* set in the alternative. */\n@@ -230,14 +232,12 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                              [expr_pp(fcx.ccx, antec),\n                               block_pp(fcx.ccx, conseq)]);\n             auto postcond_true_case =\n-                union_postconds(num_local_vars,\n-                                [expr_postcond(fcx.ccx, antec),\n-                                 block_postcond(fcx.ccx, conseq)]);\n+                seq_postconds(fcx, [expr_postcond(fcx.ccx, antec),\n+                                    block_postcond(fcx.ccx, conseq)]);\n \n             auto precond_res =\n-                union_postconds(num_local_vars,\n-                                [precond_true_case,\n-                                 precond_false_case]);\n+                seq_postconds(fcx, [precond_true_case,\n+                                    precond_false_case]);\n             auto postcond_res =\n                 intersect_postconds([postcond_true_case,\n                                      postcond_false_case]);\n@@ -274,7 +274,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n     auto num_local_vars = num_constraints(enclosing);\n     fn do_rand_(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n     log \"find_pre_post_expr (num_constraints =\" + uistr(num_local_vars) +\n-            \"):\";\n+        \"):\";\n     log_expr(*e);\n     alt (e.node) {\n         case (expr_call(?operator, ?operands)) {\n@@ -288,13 +288,13 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             auto pp = expr_pp(fcx.ccx, e);\n             for (@ty::constr_def c in constraints_expr(fcx.ccx.tcx, operator))\n                 {\n-                auto i =\n-                    bit_num(fcx,\n-                            rec(id=c.node.id._1,\n-                                c=substitute_constr_args(fcx.ccx.tcx,\n-                                                         operands, c)));\n-                require(i, pp);\n-            }\n+                    auto i =\n+                        bit_num(fcx,\n+                                rec(id=c.node.id._1,\n+                                    c=substitute_constr_args(fcx.ccx.tcx,\n+                                                             operands, c)));\n+                    require(i, pp);\n+                }\n \n             /* if this is a failing call, its postcondition sets everything */\n             alt (controlflow_expr(fcx.ccx, operator)) {\n@@ -359,17 +359,17 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             find_pre_post_exprs(fcx, es, e.id);\n         }\n         case (expr_move(?lhs, ?rhs)) {\n-            // FIXME: this needs to deinitialize the rhs\n             alt (lhs.node) {\n                 case (expr_path(?p)) {\n                     gen_if_local(fcx, lhs, rhs, e.id, lhs.id, p);\n                 }\n                 case (_) { find_pre_post_exprs(fcx, [lhs, rhs], e.id); }\n             }\n+            forget_in_postcond(fcx, rhs.span, e.id, rhs.id);\n         }\n         case (expr_swap(?lhs, ?rhs)) {\n             // Both sides must already be initialized\n-\n+            \n             find_pre_post_exprs(fcx, [lhs, rhs], e.id);\n         }\n         case (expr_assign(?lhs, ?rhs)) {\n@@ -455,9 +455,8 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             find_pre_post_block(fcx, body);\n             find_pre_post_expr(fcx, test);\n             auto loop_postcond =\n-                union_postconds(num_local_vars,\n-                                [block_postcond(fcx.ccx, body),\n-                                 expr_postcond(fcx.ccx, test)]);\n+                seq_postconds(fcx, [block_postcond(fcx.ccx, body),\n+                                    expr_postcond(fcx.ccx, test)]);\n             /* conservative approximination: if the body\n                could break or cont, the test may never be executed */\n \n@@ -566,6 +565,9 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n                 case (decl_local(?alocal)) {\n                     alt (alocal.node.init) {\n                         case (some(?an_init)) {\n+                            /* LHS always becomes initialized,\n+                             whether or not this is a move */\n+\n                             find_pre_post_expr(fcx, an_init.expr);\n                             copy_pre_post(fcx.ccx, alocal.node.id, \n                                           an_init.expr);\n@@ -576,6 +578,15 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n                             gen(fcx, id,\n                                 rec(id=alocal.node.id, \n                                     c=ninit(alocal.node.ident)));\n+                            \n+                            alt (an_init.op) {\n+                                case (init_move) {\n+                                    forget_in_postcond(fcx, an_init.expr.span,\n+                                                       id, an_init.expr.id);\n+                                }\n+                                case (_) { /* nothing gets deinitialized */ } \n+                            }\n+\n                         }\n                         case (none) {\n                             clear_pp(node_id_to_ts_ann(fcx.ccx,\n@@ -643,6 +654,7 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) {\n     plus_option[pre_and_post](pps,\n                               option::map[@expr,\n                                           pre_and_post](g, b.node.expr));\n+\n     auto block_precond = seq_preconds(fcx, pps);\n     auto h = get_post;\n     auto postconds = vec::map[pre_and_post, postcond](h, pps);\n@@ -654,7 +666,7 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) {\n     /* conservative approximation */\n \n     if (!has_nonlocal_exits(b)) {\n-        block_postcond = union_postconds(nv, postconds);\n+        block_postcond = seq_postconds(fcx, postconds);\n     }\n     set_pre_and_post(fcx.ccx, b.node.id, block_precond, block_postcond);\n }"}, {"sha": "1637924d0a59a39cdeede4bf51dd0a2f31d235f8", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 59, "deletions": 40, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=9a48bd2f2133a76371cb92488620146be990a82c", "patch": "@@ -1,5 +1,3 @@\n-\n-import std::bitv;\n import std::vec;\n import std::vec::plus_option;\n import std::vec::cat_options;\n@@ -15,7 +13,6 @@ import tstate::ann::postcond;\n import tstate::ann::empty_pre_post;\n import tstate::ann::empty_poststate;\n import tstate::ann::require_and_preserve;\n-import tstate::ann::union;\n import tstate::ann::intersect;\n import tstate::ann::empty_prestate;\n import tstate::ann::prestate;\n@@ -48,8 +45,8 @@ import aux::extend_poststate_ann;\n import aux::set_prestate_ann;\n import aux::set_poststate_ann;\n import aux::pure_exp;\n-import aux::log_bitv;\n-import aux::log_bitv_err;\n+import aux::log_tritv;\n+import aux::log_tritv_err;\n import aux::stmt_to_ann;\n import aux::log_states;\n import aux::log_states_err;\n@@ -63,9 +60,12 @@ import aux::path_to_ident;\n import aux::if_ty;\n import aux::if_check;\n import aux::plain_if;\n+import aux::forget_in_poststate;\n+import tritv::tritv_clone;\n+import tritv::tritv_set;\n+import tritv::ttrue;\n \n import bitvectors::seq_preconds;\n-import bitvectors::union_postconds;\n import bitvectors::intersect_postconds;\n import bitvectors::declare_var;\n import bitvectors::bit_num;\n@@ -193,8 +193,8 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n             alt (chk) {\n                 case (if_check) {\n                     let aux::constr c = expr_to_constr(fcx.ccx.tcx, antec);\n-                    conseq_prestate = bitv::clone(conseq_prestate);\n-                    bitv::set(conseq_prestate, bit_num(fcx, c.node), true);\n+                    conseq_prestate = tritv_clone(conseq_prestate);\n+                    tritv_set(bit_num(fcx, c.node), conseq_prestate, ttrue);\n                 }\n                 case (_) {}\n             }\n@@ -352,8 +352,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             ret changed;\n         }\n         case (expr_move(?lhs, ?rhs)) {\n-            // FIXME: this needs to deinitialize the rhs\n-\n+        \n             extend_prestate_ann(fcx.ccx, e.id, pres);\n             alt (lhs.node) {\n                 case (expr_path(?p)) {\n@@ -362,9 +361,8 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                     changed = pure_exp(fcx.ccx, lhs.id, pres) || changed;\n                     changed = find_pre_post_state_expr\n                         (fcx, pres, rhs) || changed;\n-                    changed = extend_poststate_ann\n-                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, rhs)) ||\n-                        changed;\n+                    // not extending e's poststate,\n+                    // because rhs is getting deinit'd anyway\n                     changed = gen_if_local(fcx, lhs.id, e.id, p) || changed;\n                 }\n                 case (_) {\n@@ -381,6 +379,9 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                         || changed;\n                 }\n             }\n+\n+            changed = forget_in_poststate(fcx, rhs.span, e.id, rhs.id)\n+                || changed;\n             ret changed;\n         }\n         case (expr_assign(?lhs, ?rhs)) {\n@@ -725,25 +726,42 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n                                 find_pre_post_state_expr(fcx, pres,\n                                                          an_init.expr)\n                                 || changed;\n-                            changed =\n-                                extend_poststate(stmt_ann.states.poststate,\n-                                                 expr_poststate(fcx.ccx,\n-                                                                an_init.expr))\n-                                    || changed;\n+\n+\n+                            /* FIXME less copypasta */\n+                            alt (an_init.op) {\n+                                case (init_move) {\n+                                    changed = forget_in_poststate(fcx,\n+                                      an_init.expr.span, id, an_init.expr.id)\n+                                        || changed;\n+                /* Safe to forget rhs's poststate here 'cause it's a var. */\n+                                }\n+                                case (_) { /* nothing gets deinitialized */ \n+                                    changed =\n+                                      extend_poststate(\n+                                        stmt_ann.states.poststate,\n+                                        expr_poststate(fcx.ccx, an_init.expr))\n+                                        || changed;\n+                                } \n+                            }\n+\n                             changed =\n                                 gen_poststate(fcx, id,\n                                               rec(id=alocal.node.id,\n                                                   c=ninit(alocal.node.ident)))\n                                 || changed;\n-                            log \"Summary: stmt = \";\n-                            log_stmt(*s);\n-                            log \"prestate = \";\n-                            log bitv::to_str(stmt_ann.states.prestate);\n-                            log_bitv(fcx, stmt_ann.states.prestate);\n-                            log \"poststate =\";\n-                            log_bitv(fcx, stmt_ann.states.poststate);\n-                            log \"changed =\";\n-                            log changed;\n+                            \n+                            /*\n+                            log_err \"Summary: stmt = \";\n+                            log_stmt_err(*s);\n+                            log_err \"prestate = \";\n+                            log_tritv_err(fcx, stmt_ann.states.prestate);\n+                            log_err \"poststate =\";\n+                            log_tritv_err(fcx, stmt_ann.states.poststate);\n+                            log_err \"changed =\";\n+                            log_err changed;\n+                            */\n+\n                             ret changed;\n                         }\n                         case (none) {\n@@ -778,17 +796,18 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n             changed =\n                 extend_poststate(stmt_ann.states.poststate,\n                                  expr_poststate(fcx.ccx, ex)) || changed;\n+            \n             /*\n-              log(\"Summary: stmt = \");\n-              log_stmt(*s);\n-              log(\"prestate = \");\n-              log(bitv::to_str(stmt_ann.states.prestate));\n-              log_bitv(enclosing, stmt_ann.states.prestate);\n-              log(\"poststate =\");\n-              log(bitv::to_str(stmt_ann.states.poststate));\n-              log_bitv(enclosing, stmt_ann.states.poststate);\n-              log(\"changed =\");\n-              log(changed);\n+              log_err(\"Summary: stmt = \");\n+              log_stmt_err(*s);\n+              log_err(\"prestate = \");\n+              //              log_err(bitv::to_str(stmt_ann.states.prestate));\n+              log_tritv_err(fcx, stmt_ann.states.prestate);\n+              log_err(\"poststate =\");\n+              //   log_err(bitv::to_str(stmt_ann.states.poststate));\n+              log_tritv_err(fcx, stmt_ann.states.poststate);\n+              log_err(\"changed =\");\n+              log_err(changed);\n             */\n \n             ret changed;\n@@ -833,9 +852,9 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b) ->\n     log_err \"poststate = \";\n     log_states_err(block_states(fcx.ccx, b));\n     log_err \"pres0:\";\n-    log_bitv_err(fcx, pres0);\n+    log_tritv_err(fcx, pres0);\n     log_err \"post:\";\n-    log_bitv_err(fcx, post);\n+    log_tritv_err(fcx, post);\n     */\n \n     ret changed;\n@@ -844,7 +863,7 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b) ->\n fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n     auto num_local_vars = num_constraints(fcx.enclosing);\n     auto changed =\n-        find_pre_post_state_block(fcx, empty_prestate(num_local_vars),\n+        find_pre_post_state_block(fcx, block_prestate(fcx.ccx, f.body),\n                                   f.body);\n     // Treat the tail expression as a return statement\n "}, {"sha": "bf4a08ad9863003af8b8c1c182ae9934f7e04817", "filename": "src/comp/middle/tstate/tritv.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=9a48bd2f2133a76371cb92488620146be990a82c", "patch": "@@ -0,0 +1,246 @@\n+import std::bitv;\n+\n+export t;\n+export create_tritv;\n+export tritv_clone;\n+export tritv_set;\n+export to_vec;\n+export trit;\n+export dont_care;\n+export ttrue;\n+export tfalse;\n+export tritv_get;\n+export tritv_set_all;\n+export tritv_difference;\n+export tritv_union;\n+export tritv_intersect;\n+export tritv_copy;\n+export tritv_clear;\n+export tritv_doesntcare;\n+\n+/* for a fixed index: \n+   10 = \"this constraint may or may not be true after execution\"\n+   01 = \"this constraint is definitely true\"\n+   00 = \"this constraint is definitely false\"\n+   11 should never appear\n+ FIXME: typestate precondition (uncertain and val must\n+ have the same length; 11 should never appear in a given position)\n+*/\n+\n+type t = rec(bitv::t uncertain, bitv::t val, uint nbits);\n+tag trit {\n+    ttrue;\n+    tfalse;\n+    dont_care;\n+}\n+\n+fn create_tritv(uint len) -> t {\n+  ret rec(uncertain=bitv::create(len, true),\n+          val=bitv::create(len, false),\n+          nbits=len);\n+}\n+\n+\n+fn trit_minus(trit a, trit b) -> trit {\n+    /*   2 - anything = 2\n+         1 - 1 = 2\n+         1 - 0 is an error\n+         1 - 2 = 1\n+         0 - 1 is an error\n+         0 - anything else - 0\n+     */\n+  alt (a) {\n+    case (dont_care) { dont_care }\n+    case (ttrue) {\n+      alt (b) {\n+        case (ttrue)     { dont_care }\n+        case (tfalse)    { ttrue } /* internally contradictory, but\n+                                      I guess it'll get flagged? */\n+        case (dont_care) { ttrue }\n+      }\n+    }\n+    case (tfalse) {\n+      alt (b) {\n+        case (ttrue) { tfalse } /* see above comment */\n+        case (_)     { tfalse }\n+      }\n+    }\n+  }\n+}\n+\n+fn trit_or(trit a, trit b) -> trit {\n+  alt (a) {\n+    case (dont_care) { b }\n+    case (ttrue)     { ttrue }\n+    case (tfalse)    {\n+      alt (b) {\n+        case (ttrue)  { dont_care } /* FIXME: ?????? */\n+        case (_)      { tfalse }\n+      }\n+    }\n+  }\n+}\n+\n+// FIXME: not sure about this\n+fn trit_and(trit a, trit b) -> trit {\n+  alt (a) {\n+    case (dont_care) { dont_care }\n+    case (ttrue)     {\n+      alt (b) {\n+        case (dont_care) { dont_care }\n+        case (ttrue)     { ttrue }\n+        case (tfalse)    { tfalse } // FIXME: ???\n+      }\n+    }\n+    case (tfalse) { tfalse }\n+  }\n+}\n+\n+fn tritv_difference(&t p1, &t p2) -> bool {\n+    let uint i = 0u;\n+    assert (p1.nbits == p2.nbits);\n+    let uint sz = p1.nbits;\n+    auto changed = false;\n+    while (i < sz) {\n+      auto old = tritv_get(p1, i);\n+      auto new = trit_minus(old, tritv_get(p2, i));\n+      changed = changed || (old != new);\n+      tritv_set(i, p1, new);\n+      i += 1u;\n+    }\n+    ret changed;\n+}\n+\n+fn tritv_union(&t p1, &t p2) -> bool {\n+    let uint i = 0u;\n+    assert (p1.nbits == p2.nbits);\n+    let uint sz = p1.nbits;\n+    auto changed = false;\n+    while (i < sz) {\n+      auto old = tritv_get(p1, i);\n+      auto new = trit_or(old, tritv_get(p2, i));\n+      changed = changed || (old != new);\n+      tritv_set(i, p1, new);\n+      i += 1u;\n+    }\n+    ret changed;\n+}\n+\n+fn tritv_intersect(&t p1, &t p2) -> bool {\n+    let uint i = 0u;\n+    assert (p1.nbits == p2.nbits);\n+    let uint sz = p1.nbits;\n+    auto changed = false;\n+    while (i < sz) {\n+      auto old = tritv_get(p1, i);\n+      auto new = trit_and(old, tritv_get(p2, i));\n+      changed = changed || (old != new);\n+      tritv_set(i, p1, new);\n+      i += 1u;\n+    }\n+    ret changed;\n+}\n+\n+fn tritv_get(&t v, uint i) -> trit {\n+  auto b1 = bitv::get(v.uncertain, i);\n+  auto b2 = bitv::get(v.val, i);\n+  assert (! (b1 && b2));\n+  if (b1)      { dont_care }\n+  else if (b2) { ttrue }\n+  else         { tfalse}\n+}\n+ \n+fn tritv_set(uint i, &t v, trit t) -> bool {\n+  auto old = tritv_get(v, i);\n+  alt (t) {\n+    case (dont_care) {\n+      bitv::set(v.uncertain, i, true);\n+      bitv::set(v.val, i, false);\n+    }\n+    case (ttrue) {\n+      bitv::set(v.uncertain, i, false);\n+      bitv::set(v.val, i, true);\n+    }\n+    case (tfalse) {\n+      bitv::set(v.uncertain, i, false);\n+      bitv::set(v.val, i, false);\n+    }\n+  }\n+  ret (old != t);\n+}\n+\n+fn tritv_copy(&t target, &t source) -> bool {\n+  let uint i = 0u;\n+  assert (target.nbits == source.nbits);\n+  auto changed = false;\n+  auto old;\n+  auto new;\n+  while (i < target.nbits) {\n+    old = bitv::get(target.uncertain, i);\n+    new = bitv::get(source.uncertain, i);\n+    bitv::set(target.uncertain, i, new);\n+    changed = changed || (old != new);\n+    old = bitv::get(target.val, i);\n+    new = bitv::get(source.val, i);\n+    bitv::set(target.val, i, new);\n+    changed = changed || (old != new);\n+    i += 1u;\n+  }\n+  ret changed;\n+}\n+\n+fn tritv_set_all(&t v) {\n+  let uint i = 0u;\n+  while (i < v.nbits) {\n+    tritv_set(i, v, ttrue);\n+    i += 1u;\n+  }\n+}\n+\n+fn tritv_clear(&t v) {\n+  let uint i = 0u;\n+  while (i < v.nbits) {\n+    tritv_set(i, v, dont_care);\n+    i += 1u;\n+  }\n+}\n+\n+fn tritv_clone(&t v) -> t {\n+  ret rec(uncertain=bitv::clone(v.uncertain),\n+          val=bitv::clone(v.val),\n+          nbits=v.nbits);\n+}\n+\n+fn tritv_doesntcare(&t v) -> bool {\n+  let uint i = 0u;\n+  while (i < v.nbits) {\n+    if (tritv_get(v, i) != dont_care) {\n+      ret false;\n+    }\n+    i += 1u;\n+  }\n+  ret true;\n+}\n+\n+fn to_vec(&t v) -> vec[uint] {\n+  let uint i = 0u;\n+  let vec[uint] res = [];\n+  while (i < v.nbits) {\n+    res += [alt (tritv_get(v, i)) {\n+        case (dont_care) { 2u }\n+        case (ttrue)     { 1u }\n+        case (tfalse)    { 0u } }];\n+    i += 1u;\n+  }\n+  ret res;\n+}\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "3a96e03f0c5159933d5c1518870179f32bab4ef6", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=9a48bd2f2133a76371cb92488620146be990a82c", "patch": "@@ -33,6 +33,7 @@ mod middle {\n         mod pre_post_conditions;\n         mod states;\n         mod ann;\n+        mod tritv;\n     }\n }\n "}, {"sha": "87a1908f8e06c6722baf76b7335bc5bc6baf2b3e", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a48bd2f2133a76371cb92488620146be990a82c/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=9a48bd2f2133a76371cb92488620146be990a82c", "patch": "@@ -252,6 +252,15 @@ fn is_hex_digit(char c) -> bool {\n }\n \n fn is_bin_digit(char c) -> bool { ret c == '0' || c == '1'; }\n+\n+// FIXME move to vec\n+fn any[T](&fn(&T) -> bool f, &vec[T] v) -> bool {\n+    for (T t in v) {\n+        if (f(t)) { ret true; } \n+    }\n+    ret false;\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "6c26279c581ac5957d2a352ed903a32d23d20b5a", "filename": "src/test/compile-fail/use-after-move.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a48bd2f2133a76371cb92488620146be990a82c/src%2Ftest%2Fcompile-fail%2Fuse-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a48bd2f2133a76371cb92488620146be990a82c/src%2Ftest%2Fcompile-fail%2Fuse-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move.rs?ref=9a48bd2f2133a76371cb92488620146be990a82c", "patch": "@@ -0,0 +1,6 @@\n+// error-pattern: Unsatisfied precondition constraint (for example, init(x\n+fn main() {\n+  auto x = @5;\n+  auto y <- x;\n+  log *x;\n+}\n\\ No newline at end of file"}]}