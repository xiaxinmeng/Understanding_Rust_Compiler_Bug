{"sha": "4a894dae8ec784480cc7d8b127a79f9418e8fa7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhODk0ZGFlOGVjNzg0NDgwY2M3ZDhiMTI3YTc5Zjk0MThlOGZhN2Q=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-19T01:08:36Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-19T01:09:45Z"}, "message": "rustllvm: Emit a stack map for frames with only static type descriptors", "tree": {"sha": "eec0f27322f603be45c40c208acd7ac86d869dbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eec0f27322f603be45c40c208acd7ac86d869dbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a894dae8ec784480cc7d8b127a79f9418e8fa7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a894dae8ec784480cc7d8b127a79f9418e8fa7d", "html_url": "https://github.com/rust-lang/rust/commit/4a894dae8ec784480cc7d8b127a79f9418e8fa7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a894dae8ec784480cc7d8b127a79f9418e8fa7d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d81d86440f16d9f6bc6a97625615da7b51167669", "url": "https://api.github.com/repos/rust-lang/rust/commits/d81d86440f16d9f6bc6a97625615da7b51167669", "html_url": "https://github.com/rust-lang/rust/commit/d81d86440f16d9f6bc6a97625615da7b51167669"}], "stats": {"total": 162, "additions": 159, "deletions": 3}, "files": [{"sha": "d2ee0c3baeb6db720fea251038d0bf4cacc7357f", "filename": "src/rustllvm/RustGCMetadataPrinter.cpp", "status": "modified", "additions": 159, "deletions": 3, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/4a894dae8ec784480cc7d8b127a79f9418e8fa7d/src%2Frustllvm%2FRustGCMetadataPrinter.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4a894dae8ec784480cc7d8b127a79f9418e8fa7d/src%2Frustllvm%2FRustGCMetadataPrinter.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustGCMetadataPrinter.cpp?ref=4a894dae8ec784480cc7d8b127a79f9418e8fa7d", "patch": "@@ -11,10 +11,12 @@\n //\n //===----------------------------------------------------------------------===//\n \n+#include \"llvm/Constants.h\"\n+#include \"llvm/DerivedTypes.h\"\n+#include \"llvm/Module.h\"\n #include \"llvm/CodeGen/GCs.h\"\n #include \"llvm/CodeGen/AsmPrinter.h\"\n #include \"llvm/CodeGen/GCMetadataPrinter.h\"\n-#include \"llvm/Module.h\"\n #include \"llvm/MC/MCAsmInfo.h\"\n #include \"llvm/MC/MCContext.h\"\n #include \"llvm/MC/MCSymbol.h\"\n@@ -27,19 +29,173 @@\n #include \"llvm/Support/ErrorHandling.h\"\n #include \"llvm/Support/FormattedStream.h\"\n #include <cctype>\n+#include <map>\n \n using namespace llvm;\n \n namespace {\n+  enum RustGCMetaType {\n+    RGCMT_DestIndex,  // Type descriptor index -> type descriptor.\n+    RGCMT_SrcIndex,   // Value -> type descriptor index.\n+    RGCMT_Static      // Value with static type descriptor.\n+  };\n \n   class RustGCMetadataPrinter : public GCMetadataPrinter {\n+  private:\n+    std::pair<RustGCMetaType,const Constant *>\n+      GetGCMetadataForRoot(const GCRoot &Root);\n+    void EmitGCMetadata(AsmPrinter &AP, MCStreamer &Out, GCRoot &Root);\n+    bool HandleDestIndex(const GCRoot &Root);\n   public:\n     void beginAssembly(AsmPrinter &AP) {};\n-    void finishAssembly(AsmPrinter &AP) {};\n+    void finishAssembly(AsmPrinter &AP);\n   };\n \n+  struct OrderedSymbol {\n+    unsigned Index;\n+    MCSymbol *Sym;\n+\n+    OrderedSymbol(unsigned I, MCSymbol *S) : Index(I), Sym(S) {}\n+\n+    static OrderedSymbol make(unsigned I, MCSymbol *S) {\n+      OrderedSymbol OS(I, S);\n+      return OS;\n+    }\n+  };\n }\n \n static GCMetadataPrinterRegistry::Add<RustGCMetadataPrinter>\n-Y(\"rust\", \"Rust GC metadata printer\");\n+X(\"rust\", \"Rust GC metadata printer\");\n+\n+\n+typedef std::vector< std::pair< MCSymbol *,std::vector<GCRoot> > > RootMap;\n+\n+std::pair<RustGCMetaType,const Constant *>\n+RustGCMetadataPrinter::GetGCMetadataForRoot(const GCRoot &Root) {\n+  const GlobalVariable *GCMetaVar =\n+    cast<const GlobalVariable>(Root.Metadata->stripPointerCasts());\n+\n+  const Constant *GCMetaInit = GCMetaVar->getInitializer();\n+  if (isa<ConstantAggregateZero>(GCMetaInit)) {\n+    // \"zeroinitializer\": expand to (0, 0).\n+    IntegerType *I32 = IntegerType::get(GCMetaInit->getContext(), 32);\n+    ConstantInt *Zero = ConstantInt::get(I32, 0);\n+    return std::make_pair(RGCMT_DestIndex, Zero);\n+  }\n+\n+  const ConstantStruct *GCMeta =\n+    cast<const ConstantStruct>(GCMetaVar->getInitializer());\n+\n+  RustGCMetaType GCMetaType = (RustGCMetaType)\n+    (cast<const ConstantInt>(GCMeta->getOperand(0))->getZExtValue());\n+  const Constant *Payload = cast<const Constant>(GCMeta->getOperand(1));\n+  return std::make_pair(GCMetaType, Payload);\n+}\n+\n+void RustGCMetadataPrinter::EmitGCMetadata(AsmPrinter &AP, MCStreamer &Out,\n+                                           GCRoot &Root) {\n+  int WordSize = AP.TM.getTargetData()->getPointerSize();\n+\n+  std::pair<RustGCMetaType,const Constant *> Pair =\n+    GetGCMetadataForRoot(Root);\n+  const GlobalValue *Tydesc;\n+\n+  switch (Pair.first) {\n+  case RGCMT_DestIndex: // Dest index.\n+    assert(0 && \"Dest index should not be here!\");\n+  case RGCMT_SrcIndex:\n+    // TODO: Use the mapping to find the tydesc frame offset.\n+    Out.EmitIntValue(1, WordSize, 0);\n+    Out.EmitIntValue(0, WordSize, 0);\n+    return;\n+  case 2: // Static type descriptor.\n+    Out.EmitIntValue(0, WordSize, 0);\n+    Tydesc = cast<const GlobalValue>(Pair.second);\n+    break;\n+  }\n+\n+  MCSymbol *TydescSym = AP.Mang->getSymbol(Tydesc);\n+  Out.EmitSymbolValue(TydescSym, WordSize, 0);\n+}\n+\n+// Records the destination index of a type descriptor in the type descriptor\n+// map, if this GC root is a destination index. Returns true if the GC root is\n+// a destination index and false otherwise.\n+bool RustGCMetadataPrinter::HandleDestIndex(const GCRoot &Root) {\n+  std::pair<RustGCMetaType,const Constant *> Pair =\n+    GetGCMetadataForRoot(Root);\n+  return Pair.first == RGCMT_DestIndex; // TODO\n+}\n+\n+void RustGCMetadataPrinter::finishAssembly(AsmPrinter &AP) {\n+  MCStreamer &Out = AP.OutStreamer;\n+\n+  // Use the data section.\n+  Out.SwitchSection(AP.getObjFileLowering().getDataSection());\n+\n+  // Iterate over each function.\n+  RootMap Map;\n+\n+  iterator FI = begin(), FE = end();\n+  while (FI != FE) {\n+    GCFunctionInfo &GCFI = **FI;\n+\n+    // Iterate over each safe point.\n+    GCFunctionInfo::iterator SPI = GCFI.begin(), SPE = GCFI.end();\n+    while (SPI != SPE) {\n+      std::vector<GCRoot> Roots;\n+\n+      // Iterate over each live root.\n+      GCFunctionInfo::live_iterator LI = GCFI.live_begin(SPI);\n+      GCFunctionInfo::live_iterator LE = GCFI.live_end(SPI);\n+      while (LI != LE) {\n+        if (!HandleDestIndex(*LI))\n+          Roots.push_back(*LI);\n+        ++LI;\n+      }\n+\n+      Map.push_back(std::make_pair(SPI->Label, Roots));\n+      ++SPI;\n+    }\n+    ++FI;\n+  }\n+\n+  // Write out the map.\n+  Out.AddBlankLine();\n+\n+  int WordSize = AP.TM.getTargetData()->getPointerSize();\n+\n+  MCSymbol *SafePointSym = AP.GetExternalSymbolSymbol(\"rust_gc_safe_points\");\n+  Out.EmitSymbolAttribute(SafePointSym, MCSA_Global);\n+  Out.EmitLabel(SafePointSym);\n+  Out.EmitIntValue(Map.size(), WordSize, 0);\n+\n+  std::vector<MCSymbol *> FrameMapLabels;\n+\n+  RootMap::iterator MI = Map.begin(), ME = Map.end();\n+  unsigned i = 0;\n+  while (MI != ME) {\n+    Out.EmitSymbolValue(MI->first, WordSize, 0);\n+    MCSymbol *FrameMapLabel = AP.GetTempSymbol(\"rust_frame_map_label\", i);\n+    FrameMapLabels.push_back(FrameMapLabel);\n+    ++MI, ++i;\n+  }\n+\n+  MI = Map.begin(), i = 0;\n+  while (MI != ME) {\n+    Out.EmitLabel(FrameMapLabels[i]);\n+\n+    std::vector<GCRoot> &Roots = MI->second;\n+    Out.EmitIntValue(Roots.size(), WordSize, 0);\n+\n+    std::vector<GCRoot>::iterator RI = Roots.begin(), RE = Roots.end();\n+    while (RI != RE) {\n+      Out.EmitIntValue(RI->StackOffset, WordSize, 0);\n+      EmitGCMetadata(AP, Out, *RI);\n+      ++RI;\n+    }\n+\n+    ++MI, ++i;\n+  }\n+}\n "}]}