{"sha": "082d8314da6b6b99854f0a70f5ea8e27f2602f79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MmQ4MzE0ZGE2YjZiOTk4NTRmMGE3MGY1ZWE4ZTI3ZjI2MDJmNzk=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-29T23:00:55Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-30T01:39:15Z"}, "message": "Rewrite bitv to use classes and optimize its representation\n\nRewrote bitv as a class that uses a 32-bit int as its representation\nfor bit vectors of 32 bits or less, and a vector (the old representation)\notherwise. I didn't benchmark very much, but a bit of informal benchmarking\nsuggested this is a win.\n\nCloses #2341", "tree": {"sha": "ddf17676e2fadd5918bbed301128ff03d2542c31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddf17676e2fadd5918bbed301128ff03d2542c31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/082d8314da6b6b99854f0a70f5ea8e27f2602f79", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/082d8314da6b6b99854f0a70f5ea8e27f2602f79", "html_url": "https://github.com/rust-lang/rust/commit/082d8314da6b6b99854f0a70f5ea8e27f2602f79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/082d8314da6b6b99854f0a70f5ea8e27f2602f79/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ac86e92fe2512b61881a8d716b4faf5a9feaba6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac86e92fe2512b61881a8d716b4faf5a9feaba6", "html_url": "https://github.com/rust-lang/rust/commit/6ac86e92fe2512b61881a8d716b4faf5a9feaba6"}], "stats": {"total": 1299, "additions": 721, "deletions": 578}, "files": [{"sha": "a9b3910ec195dd7e4d6aad87c8e91007270bfcb7", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 484, "deletions": 330, "changes": 814, "blob_url": "https://github.com/rust-lang/rust/blob/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=082d8314da6b6b99854f0a70f5ea8e27f2602f79", "patch": "@@ -1,3 +1,5 @@\n+import vec::{to_mut, from_elem};\n+\n export bitv;\n export union;\n export intersect;\n@@ -17,120 +19,323 @@ export to_str;\n export eq_vec;\n export methods;\n \n-// FIXME (#2341): With recursive object types, we could implement binary\n-// methods like union, intersection, and difference. At that point, we could\n-// write an optimizing version of this module that produces a different obj\n-// for the case where nbits <= 32.\n+class small_bitv {\n+    let mut bits: u32;\n+    new(bits: u32) { self.bits = bits; }\n+    priv {\n+        #[inline(always)]\n+        fn bits_op(right_bits: u32, f: fn(u32, u32) -> u32) -> bool {\n+            let old_b: u32 = self.bits;\n+            let new_b = f(old_b, right_bits);\n+            self.bits = new_b;\n+            old_b != new_b\n+        }\n+    }\n+    #[inline(always)]\n+    fn union(s: &small_bitv) -> bool {\n+        self.bits_op(s.bits, |u1, u2| { u1 | u2 })\n+    }\n+    #[inline(always)]\n+    fn intersect(s: &small_bitv) -> bool {\n+        self.bits_op(s.bits, |u1, u2| { u1 & u2 })\n+    }\n+    #[inline(always)]\n+    fn become(s: &small_bitv) -> bool {\n+        let old = self.bits;\n+        self.bits = s.bits;\n+        old != self.bits\n+    }\n+    #[inline(always)]\n+    fn difference(s: &small_bitv) -> bool {\n+        let old = self.bits;\n+        self.bits &= !s.bits;\n+        old != self.bits\n+    }\n+    #[inline(always)]\n+    pure fn get(i: uint) -> bool {\n+        (self.bits & (1 << i)) != 0\n+    }\n+    #[inline(always)]\n+    fn set(i: uint, x: bool) {\n+        if x {\n+            self.bits |= 1<<i;\n+        }\n+        else {\n+            self.bits &= !(i as u32);\n+        }\n+    }\n+    #[inline(always)]\n+    fn equals(b: &small_bitv) -> bool { self.bits == b.bits }\n+    #[inline(always)]\n+    fn clear() { self.bits = 0; }\n+    #[inline(always)]\n+    fn set_all() { self.bits = !0; }\n+    #[inline(always)]\n+    fn is_true() -> bool { self.bits == !0 }\n+    #[inline(always)]\n+    fn is_false() -> bool { self.bits == 0 }\n+    #[inline(always)]\n+    fn invert() { self.bits = !self.bits; }\n+}\n \n-/// The bitvector type\n-type bitv = {storage: ~[mut uint], nbits: uint};\n+class big_bitv {\n+// only mut b/c of clone and lack of other constructor\n+    let mut storage: ~[mut uint];\n+    new(-storage: ~[mut uint]) {\n+        self.storage <- storage;\n+    }\n+    priv {\n+        #[inline(always)]\n+        fn process(b: &big_bitv, op: fn(uint, uint) -> uint) -> bool {\n+            let len = b.storage.len();\n+            assert (self.storage.len() == len);\n+            let mut changed = false;\n+            do uint::range(0, len) |i| {\n+                let w0 = self.storage[i];\n+                let w1 = b.storage[i];\n+                let w = op(w0, w1);\n+                if w0 != w unchecked { changed = true; self.storage[i] = w; };\n+                true\n+            };\n+            changed\n+        }\n+    }\n+    #[inline(always)]\n+     fn each_storage(op: fn(&uint) -> bool) {\n+        for uint::range(0, self.storage.len()) |i| {\n+            let mut w = self.storage[i];\n+            let b = !op(w);\n+            self.storage[i] = w;\n+            if !b { break; }\n+        }\n+     }\n+    #[inline(always)]\n+    fn invert() { for self.each_storage() |w| { w = !w } }\n+    #[inline(always)]\n+    fn union(b: &big_bitv)     -> bool { self.process(b, lor) }\n+    #[inline(always)]\n+    fn intersect(b: &big_bitv) -> bool { self.process(b, land) }\n+    #[inline(always)]\n+    fn become(b: &big_bitv)    -> bool { self.process(b, right) }\n+    #[inline(always)]\n+    fn difference(b: &big_bitv) -> bool {\n+        self.invert();\n+        let b = self.intersect(b);\n+        self.invert();\n+        b\n+    }\n+    #[inline(always)]\n+    pure fn get(i: uint) -> bool {\n+        let w = i / uint_bits;\n+        let b = i % uint_bits;\n+        let x = 1 & self.storage[w] >> b;\n+        x == 1\n+    }\n+    #[inline(always)]\n+    fn set(i: uint, x: bool) {\n+        let w = i / uint_bits;\n+        let b = i % uint_bits;\n+        let flag = 1 << b;\n+        self.storage[w] = if x { self.storage[w] | flag }\n+                 else { self.storage[w] & !flag };\n+    }\n+    #[inline(always)]\n+    fn equals(b: &big_bitv) -> bool {\n+        let len = b.storage.len();\n+        for uint::iterate(0, len) |i| {\n+            if self.storage[i] != b.storage[i] { ret false; }\n+        }\n+    }\n+}\n \n-#[cfg(target_arch=\"x86\")]\n-const uint_bits: uint = 32;\n-#[cfg(target_arch=\"x86_64\")]\n-const uint_bits: uint = 64;\n+enum a_bitv { big(~big_bitv), small(~small_bitv) }\n \n-/**\n- * Constructs a bitvector\n- *\n- * # Arguments\n- *\n- * * nbits - The number of bits in the bitvector\n- * * init - If true then the bits are initialized to 1, otherwise 0\n- */\n-fn bitv(nbits: uint, init: bool) -> bitv {\n-    let elt = if init { !0u } else { 0u };\n-    let storage = vec::to_mut(vec::from_elem(nbits / uint_bits + 1u, elt));\n-    ret {storage: storage, nbits: nbits};\n-}\n+enum op {union, intersect, assign, difference}\n \n-fn process(v0: bitv, v1: bitv, op: fn(uint, uint) -> uint) -> bool {\n-    let len = vec::len(v1.storage);\n-    assert (vec::len(v0.storage) == len);\n-    assert (v0.nbits == v1.nbits);\n-    let mut changed = false;\n-    for uint::range(0u, len) |i| {\n-        let w0 = v0.storage[i];\n-        let w1 = v1.storage[i];\n-        let w = op(w0, w1);\n-        if w0 != w { changed = true; v0.storage[i] = w; }\n-    };\n-    ret changed;\n-}\n+// The bitvector type\n+class bitv {\n+    let rep: a_bitv;\n+    let nbits: uint;\n \n+    new(nbits: uint, init: bool) {\n+        self.nbits = nbits;\n+        if nbits <= 32 {\n+          self.rep = small(~small_bitv(if init {!0} else {0}));\n+        }\n+        else {\n+          let s = to_mut(from_elem(nbits / uint_bits + 1,\n+                                        if init {!0} else {0}));\n+          self.rep = big(~big_bitv(s));\n+        };\n+    }\n+\n+    priv {\n+        fn die() -> ! {\n+            fail ~\"Tried to do operation on bit vectors with \\\n+                  different sizes\";\n+        }\n+        #[inline(always)]\n+        fn do_op(op: op, other: &bitv) -> bool {\n+            if self.nbits != other.nbits {\n+                self.die();\n+            }\n+            alt self.rep {\n+              small(s) {\n+                alt other.rep {\n+                  small(s1) {\n+                    alt op {\n+                      union      { s.union(s1) }\n+                      intersect  { s.intersect(s1) }\n+                      assign     { s.become(s1) }\n+                      difference { s.difference(s1) }\n+                    }\n+                  }\n+                 big(s1) {\n+                     self.die();\n+                 }\n+              }\n+            }\n+            big(s) {\n+                alt other.rep {\n+                  small(_) { self.die(); }\n+                  big(s1) {\n+                    alt op {\n+                      union      { s.union(s1) }\n+                      intersect  { s.intersect(s1) }\n+                      assign     { s.become(s1) }\n+                      difference { s.difference(s1) }\n+                    }\n+                  }\n+                }\n+            }\n+          }\n+        }\n+    }\n \n /**\n  * Calculates the union of two bitvectors\n  *\n- * Sets `v0` to the union of `v0` and `v1`. Both bitvectors must be the\n- * same length. Returns 'true' if `v0` was changed.\n- */\n-fn union(v0: bitv, v1: bitv) -> bool {\n-    process(v0, v1, |a, b| a | b)\n-}\n+ * Sets `self` to the union of `self` and `v1`. Both bitvectors must be\n+ * the same length. Returns 'true' if `self` changed.\n+*/\n+    #[inline(always)]\n+    fn union(v1: &bitv) -> bool { self.do_op(union, v1) }\n \n /**\n  * Calculates the intersection of two bitvectors\n  *\n- * Sets `v0` to the intersection of `v0` and `v1`. Both bitvectors must be the\n- * same length. Returns 'true' if `v0` was changed.\n- */\n-fn intersect(v0: bitv, v1: bitv) -> bool {\n-    process(v0, v1, |a, b| a & b)\n-}\n-\n-fn right(_w0: uint, w1: uint) -> uint { ret w1; }\n+ * Sets `self` to the intersection of `self` and `v1`. Both bitvectors must be\n+ * the same length. Returns 'true' if `self` changed.\n+*/\n+    #[inline(always)]\n+    fn intersect(v1: &bitv) -> bool { self.do_op(intersect, v1) }\n \n /**\n- * Assigns the value of `v1` to `v0`\n+ * Assigns the value of `v1` to `self`\n  *\n- * Both bitvectors must be the same length. Returns `true` if `v0` was changed\n+ * Both bitvectors must be the same length. Returns `true` if `self` was\n+ * changed\n  */\n-fn assign(v0: bitv, v1: bitv) -> bool {\n-    let sub = right; ret process(v0, v1, sub);\n-}\n+    #[inline(always)]\n+    fn assign(v: &bitv) -> bool { self.do_op(assign, v) }\n+\n+    /// Makes a copy of a bitvector\n+    #[inline(always)]\n+    fn clone() -> ~bitv {\n+        ~alt self.rep {\n+          small(b) {\n+            bitv{nbits: self.nbits, rep: small(~small_bitv{bits: b.bits})}\n+          }\n+          big(b) {\n+            let st = to_mut(from_elem(self.nbits / uint_bits + 1, 0));\n+            let len = st.len();\n+            for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n+            bitv{nbits: self.nbits, rep: big(~big_bitv{storage: st})}\n+          }\n+        }\n+    }\n \n-/// Makes a copy of a bitvector\n-fn clone(v: bitv) -> bitv {\n-    copy v\n-}\n+    /// Retrieve the value at index `i`\n+    #[inline(always)]\n+    pure fn get(i: uint) -> bool {\n+       assert (i < self.nbits);\n+       alt self.rep {\n+         big(b)   { b.get(i) }\n+         small(s) { s.get(i) }\n+       }\n+    }\n \n-/// Retrieve the value at index `i`\n-#[inline(always)]\n-pure fn get(v: bitv, i: uint) -> bool {\n-    assert (i < v.nbits);\n-    let bits = uint_bits;\n-    let w = i / bits;\n-    let b = i % bits;\n-    let x = 1u & v.storage[w] >> b;\n-    ret x == 1u;\n-}\n+/**\n+ * Set the value of a bit at a given index\n+ *\n+ * `i` must be less than the length of the bitvector.\n+ */\n+    #[inline(always)]\n+    fn set(i: uint, x: bool) {\n+      assert (i < self.nbits);\n+      alt self.rep {\n+        big(b) { b.set(i, x); }\n+        small(s) { s.set(i, x); }\n+      }\n+    }\n \n /**\n  * Compares two bitvectors\n  *\n  * Both bitvectors must be the same length. Returns `true` if both bitvectors\n  * contain identical elements.\n  */\n-fn equal(v0: bitv, v1: bitv) -> bool {\n-    if v0.nbits != v1.nbits { ret false; }\n-    let len = vec::len(v1.storage);\n-    for uint::iterate(0u, len) |i| {\n-        if v0.storage[i] != v1.storage[i] { ret false; }\n+    #[inline(always)]\n+    fn equal(v1: bitv) -> bool {\n+      if self.nbits != v1.nbits { ret false; }\n+      alt self.rep {\n+        small(b) {\n+          alt v1.rep {\n+            small(b1) { b.equals(b1) }\n+            _ { false }\n+          }\n+        }\n+        big(s) {\n+          alt v1.rep {\n+            big(s1) {\n+              s.equals(s1)\n+            }\n+            small(_) { ret false; }\n+          }\n+        }\n+      }\n     }\n-}\n \n-/// Set all bits to 0\n-#[inline(always)]\n-fn clear(v: bitv) { for each_storage(v) |w| { w = 0u } }\n+    /// Set all bits to 0\n+    #[inline(always)]\n+    fn clear() {\n+        alt self.rep {\n+          small(b) { b.clear(); }\n+          big(s) {\n+            for s.each_storage() |w| { w = 0u }\n+          }\n+        }\n+    }\n \n-/// Set all bits to 1\n-#[inline(always)]\n-fn set_all(v: bitv) { for each_storage(v) |w| { w = !0u } }\n+    /// Set all bits to 1\n+    #[inline(always)]\n+    fn set_all() {\n+      alt self.rep {\n+        small(b) { b.set_all(); }\n+        big(s) {\n+          for s.each_storage() |w| { w = !0u } }\n+      }\n+    }\n \n-/// Invert all bits\n-#[inline(always)]\n-fn invert(v: bitv) { for each_storage(v) |w| { w = !w } }\n+    /// Invert all bits\n+    #[inline(always)]\n+    fn invert() {\n+      alt self.rep {\n+        small(b) { b.invert(); }\n+        big(s) {\n+          for s.each_storage() |w| { w = !w } }\n+      }\n+    }\n \n /**\n  * Calculate the difference between two bitvectors\n@@ -140,141 +345,86 @@ fn invert(v: bitv) { for each_storage(v) |w| { w = !w } }\n  *\n  * Returns `true` if `v0` was changed.\n  */\n-fn difference(v0: bitv, v1: bitv) -> bool {\n-    invert(v1);\n-    let b = intersect(v0, v1);\n-    invert(v1);\n-    ret b;\n-}\n-\n-/**\n- * Set the value of a bit at a given index\n- *\n- * `i` must be less than the length of the bitvector.\n- */\n-#[inline(always)]\n-fn set(v: bitv, i: uint, x: bool) {\n-    assert (i < v.nbits);\n-    let bits = uint_bits;\n-    let w = i / bits;\n-    let b = i % bits;\n-    let flag = 1u << b;\n-    v.storage[w] = if x { v.storage[w] | flag } else { v.storage[w] & !flag };\n-}\n+   #[inline(always)]\n+    fn difference(v: ~bitv) -> bool { self.do_op(difference, v) }\n+\n+        /// Returns true if all bits are 1\n+    #[inline(always)]\n+    fn is_true() -> bool {\n+      alt self.rep {\n+        small(b) { b.is_true() }\n+        _ {\n+          for self.each() |i| { if !i { ret false; } }\n+          true\n+        }\n+      }\n+    }\n \n+    #[inline(always)]\n+    fn each(f: fn(bool) -> bool) {\n+        let mut i = 0;\n+        while i < self.nbits {\n+            if !f(self.get(i)) { break; }\n+            i += 1;\n+        }\n+    }\n \n-/// Returns true if all bits are 1\n-fn is_true(v: bitv) -> bool {\n-    for each(v) |i| { if !i { ret false; } }\n-    ret true;\n-}\n+    /// Returns true if all bits are 0\n \n+    fn is_false() -> bool {\n+      alt self.rep {\n+        small(b) { b.is_false() }\n+        big(_) {\n+          for self.each() |i| { if i { ret false; } }\n+          true\n+        }\n+      }\n+    }\n \n-/// Returns true if all bits are 0\n-fn is_false(v: bitv) -> bool {\n-    for each(v) |i| { if i { ret false; } }\n-    ret true;\n-}\n+    fn init_to_vec(i: uint) -> uint {\n+      ret if self.get(i) { 1 } else { 0 };\n+    }\n \n /**\n- * Converts the bitvector to a vector of uint with the same length.\n+ * Converts `self` to a vector of uint with the same length.\n  *\n  * Each uint in the resulting vector has either value 0u or 1u.\n  */\n-fn to_vec(v: bitv) -> ~[uint] {\n-    vec::from_fn::<uint>(v.nbits, |i| if get(v, i) { 1 } else { 0 })\n-}\n-\n-#[inline(always)]\n-fn each(v: bitv, f: fn(bool) -> bool) {\n-    let mut i = 0u;\n-    while i < v.nbits {\n-        if !f(get(v, i)) { break; }\n-        i = i + 1u;\n+    fn to_vec() -> ~[uint] {\n+      let sub = |x| self.init_to_vec(x);\n+      ret vec::from_fn::<uint>(self.nbits, sub);\n     }\n-}\n-\n-#[inline(always)]\n-fn each_storage(v: bitv, op: fn(&uint) -> bool) {\n-    for uint::range(0u, vec::len(v.storage)) |i| {\n-        let mut w = v.storage[i];\n-        let b = !op(w);\n-        v.storage[i] = w;\n-        if !b { break; }\n-    }\n-}\n \n /**\n- * Converts the bitvector to a string.\n+ * Converts `self` to a string.\n  *\n- * The resulting string has the same length as the bitvector, and each\n+ * The resulting string has the same length as `self`, and each\n  * character is either '0' or '1'.\n  */\n-fn to_str(v: bitv) -> ~str {\n-    let mut rs = ~\"\";\n-    for each(v) |i| { if i { rs += ~\"1\"; } else { rs += ~\"0\"; } }\n-    ret rs;\n-}\n+     fn to_str() -> ~str {\n+       let mut rs = ~\"\";\n+       for self.each() |i| { if i { rs += \"1\"; } else { rs += \"0\"; } };\n+       rs\n+     }\n+\n \n /**\n  * Compare a bitvector to a vector of uint\n  *\n  * The uint vector is expected to only contain the values 0u and 1u. Both the\n  * bitvector and vector must have the same length\n  */\n-fn eq_vec(v0: bitv, v1: ~[uint]) -> bool {\n-    assert (v0.nbits == vec::len::<uint>(v1));\n-    let len = v0.nbits;\n-    let mut i = 0u;\n-    while i < len {\n-        let w0 = get(v0, i);\n-        let w1 = v1[i];\n-        if !w0 && w1 != 0u || w0 && w1 == 0u { ret false; }\n-        i = i + 1u;\n-    }\n-    ret true;\n-}\n-\n-trait methods {\n-    fn union(rhs: bitv) -> bool;\n-    fn intersect(rhs: bitv) -> bool;\n-    fn assign(rhs: bitv) -> bool;\n-    pure fn get(i: uint) -> bool;\n-    fn [](i: uint) -> bool;\n-    fn eq(rhs: bitv) -> bool;\n-    fn clear();\n-    fn set_all();\n-    fn invert();\n-    fn difference(rhs: bitv) -> bool;\n-    fn set(i: uint, x: bool);\n-    fn is_true() -> bool;\n-    fn is_false() -> bool;\n-    fn to_vec() -> ~[uint];\n-    fn each(f: fn(bool) -> bool);\n-    fn each_storage(f: fn(&uint) -> bool);\n-    fn eq_vec(v: ~[uint]) -> bool;\n-\n-    fn ones(f: fn(uint) -> bool);\n-}\n-\n-impl of methods for bitv {\n-    fn union(rhs: bitv) -> bool { union(self, rhs) }\n-    fn intersect(rhs: bitv) -> bool { intersect(self, rhs) }\n-    fn assign(rhs: bitv) -> bool { assign(self, rhs) }\n-    pure fn get(i: uint) -> bool { get(self, i) }\n-    fn [](i: uint) -> bool { self.get(i) }\n-    fn eq(rhs: bitv) -> bool { equal(self, rhs) }\n-    fn clear() { clear(self) }\n-    fn set_all() { set_all(self) }\n-    fn invert() { invert(self) }\n-    fn difference(rhs: bitv) -> bool { difference(self, rhs) }\n-    fn set(i: uint, x: bool) { set(self, i, x) }\n-    fn is_true() -> bool { is_true(self) }\n-    fn is_false() -> bool { is_false(self) }\n-    fn to_vec() -> ~[uint] { to_vec(self) }\n-    fn each(f: fn(bool) -> bool) { each(self, f) }\n-    fn each_storage(f: fn(&uint) -> bool) { each_storage(self, f) }\n-    fn eq_vec(v: ~[uint]) -> bool { eq_vec(self, v) }\n+     fn eq_vec(v: ~[uint]) -> bool {\n+       assert self.nbits == v.len();\n+       let mut i = 0;\n+       while i < self.nbits {\n+           let w0 = self.get(i);\n+           let w1 = v[i];\n+           if !w0 && w1 != 0u || w0 && w1 == 0u { ret false; }\n+           i = i + 1;\n+       }\n+       true\n+     }\n \n     fn ones(f: fn(uint) -> bool) {\n         for uint::range(0, self.nbits) |i| {\n@@ -283,27 +433,32 @@ impl of methods for bitv {\n             }\n         }\n     }\n-}\n+\n+} // end of bitv class\n+\n+const uint_bits: uint = 32u + (1u << 32u >> 27u);\n+\n+pure fn lor(w0: uint, w1: uint) -> uint { ret w0 | w1; }\n+\n+pure fn land(w0: uint, w1: uint) -> uint { ret w0 & w1; }\n+\n+pure fn right(_w0: uint, w1: uint) -> uint { ret w1; }\n \n impl extensions of ops::index<uint,bool> for bitv {\n     pure fn index(&&i: uint) -> bool {\n         self.get(i)\n     }\n }\n \n-impl of to_str::to_str for bitv {\n-    fn to_str() -> ~str { to_str(self) }\n-}\n-\n #[cfg(test)]\n mod tests {\n     #[test]\n     fn test_to_str() {\n         let zerolen = bitv(0u, false);\n-        assert to_str(zerolen) == ~\"\";\n+        assert zerolen.to_str() == ~\"\";\n \n         let eightbits = bitv(8u, false);\n-        assert to_str(eightbits) == ~\"00000000\";\n+        assert eightbits.to_str() == ~\"00000000\";\n     }\n \n     #[test]\n@@ -312,16 +467,16 @@ mod tests {\n         let mut exp;\n         act = bitv(0u, false);\n         exp = vec::from_elem::<uint>(0u, 0u);\n-        assert (eq_vec(act, exp));\n+        assert act.eq_vec(exp);\n     }\n \n     #[test]\n     fn test_1_element() {\n         let mut act;\n         act = bitv(1u, false);\n-        assert (eq_vec(act, ~[0u]));\n+        assert act.eq_vec(~[0u]);\n         act = bitv(1u, true);\n-        assert (eq_vec(act, ~[1u]));\n+        assert act.eq_vec(~[1u]);\n     }\n \n     #[test]\n@@ -330,37 +485,37 @@ mod tests {\n         // all 0\n \n         act = bitv(10u, false);\n-        assert (eq_vec(act, ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n+        assert (act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = bitv(10u, true);\n-        assert (eq_vec(act, ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n+        assert (act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n         act = bitv(10u, false);\n-        set(act, 0u, true);\n-        set(act, 1u, true);\n-        set(act, 2u, true);\n-        set(act, 3u, true);\n-        set(act, 4u, true);\n-        assert (eq_vec(act, ~[1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]));\n+        act.set(0u, true);\n+        act.set(1u, true);\n+        act.set(2u, true);\n+        act.set(3u, true);\n+        act.set(4u, true);\n+        assert (act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n         act = bitv(10u, false);\n-        set(act, 5u, true);\n-        set(act, 6u, true);\n-        set(act, 7u, true);\n-        set(act, 8u, true);\n-        set(act, 9u, true);\n-        assert (eq_vec(act, ~[0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]));\n+        act.set(5u, true);\n+        act.set(6u, true);\n+        act.set(7u, true);\n+        act.set(8u, true);\n+        act.set(9u, true);\n+        assert (act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n         act = bitv(10u, false);\n-        set(act, 0u, true);\n-        set(act, 3u, true);\n-        set(act, 6u, true);\n-        set(act, 9u, true);\n-        assert (eq_vec(act, ~[1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u]));\n+        act.set(0u, true);\n+        act.set(3u, true);\n+        act.set(6u, true);\n+        act.set(9u, true);\n+        assert (act.eq_vec(~[1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u]));\n     }\n \n     #[test]\n@@ -369,68 +524,68 @@ mod tests {\n         // all 0\n \n         act = bitv(31u, false);\n-        assert (eq_vec(act,\n+        assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = bitv(31u, true);\n-        assert (eq_vec(act,\n+        assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n         act = bitv(31u, false);\n-        set(act, 0u, true);\n-        set(act, 1u, true);\n-        set(act, 2u, true);\n-        set(act, 3u, true);\n-        set(act, 4u, true);\n-        set(act, 5u, true);\n-        set(act, 6u, true);\n-        set(act, 7u, true);\n-        assert (eq_vec(act,\n+        act.set(0u, true);\n+        act.set(1u, true);\n+        act.set(2u, true);\n+        act.set(3u, true);\n+        act.set(4u, true);\n+        act.set(5u, true);\n+        act.set(6u, true);\n+        act.set(7u, true);\n+        assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n         act = bitv(31u, false);\n-        set(act, 16u, true);\n-        set(act, 17u, true);\n-        set(act, 18u, true);\n-        set(act, 19u, true);\n-        set(act, 20u, true);\n-        set(act, 21u, true);\n-        set(act, 22u, true);\n-        set(act, 23u, true);\n-        assert (eq_vec(act,\n+        act.set(16u, true);\n+        act.set(17u, true);\n+        act.set(18u, true);\n+        act.set(19u, true);\n+        act.set(20u, true);\n+        act.set(21u, true);\n+        act.set(22u, true);\n+        act.set(23u, true);\n+        assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n         act = bitv(31u, false);\n-        set(act, 24u, true);\n-        set(act, 25u, true);\n-        set(act, 26u, true);\n-        set(act, 27u, true);\n-        set(act, 28u, true);\n-        set(act, 29u, true);\n-        set(act, 30u, true);\n-        assert (eq_vec(act,\n+        act.set(24u, true);\n+        act.set(25u, true);\n+        act.set(26u, true);\n+        act.set(27u, true);\n+        act.set(28u, true);\n+        act.set(29u, true);\n+        act.set(30u, true);\n+        assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n         act = bitv(31u, false);\n-        set(act, 3u, true);\n-        set(act, 17u, true);\n-        set(act, 30u, true);\n-        assert (eq_vec(act,\n+        act.set(3u, true);\n+        act.set(17u, true);\n+        act.set(30u, true);\n+        assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u]));\n@@ -442,70 +597,70 @@ mod tests {\n         // all 0\n \n         act = bitv(32u, false);\n-        assert (eq_vec(act,\n+        assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = bitv(32u, true);\n-        assert (eq_vec(act,\n+        assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n         act = bitv(32u, false);\n-        set(act, 0u, true);\n-        set(act, 1u, true);\n-        set(act, 2u, true);\n-        set(act, 3u, true);\n-        set(act, 4u, true);\n-        set(act, 5u, true);\n-        set(act, 6u, true);\n-        set(act, 7u, true);\n-        assert (eq_vec(act,\n+        act.set(0u, true);\n+        act.set(1u, true);\n+        act.set(2u, true);\n+        act.set(3u, true);\n+        act.set(4u, true);\n+        act.set(5u, true);\n+        act.set(6u, true);\n+        act.set(7u, true);\n+        assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n         act = bitv(32u, false);\n-        set(act, 16u, true);\n-        set(act, 17u, true);\n-        set(act, 18u, true);\n-        set(act, 19u, true);\n-        set(act, 20u, true);\n-        set(act, 21u, true);\n-        set(act, 22u, true);\n-        set(act, 23u, true);\n-        assert (eq_vec(act,\n+        act.set(16u, true);\n+        act.set(17u, true);\n+        act.set(18u, true);\n+        act.set(19u, true);\n+        act.set(20u, true);\n+        act.set(21u, true);\n+        act.set(22u, true);\n+        act.set(23u, true);\n+        assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n         act = bitv(32u, false);\n-        set(act, 24u, true);\n-        set(act, 25u, true);\n-        set(act, 26u, true);\n-        set(act, 27u, true);\n-        set(act, 28u, true);\n-        set(act, 29u, true);\n-        set(act, 30u, true);\n-        set(act, 31u, true);\n-        assert (eq_vec(act,\n+        act.set(24u, true);\n+        act.set(25u, true);\n+        act.set(26u, true);\n+        act.set(27u, true);\n+        act.set(28u, true);\n+        act.set(29u, true);\n+        act.set(30u, true);\n+        act.set(31u, true);\n+        assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n         act = bitv(32u, false);\n-        set(act, 3u, true);\n-        set(act, 17u, true);\n-        set(act, 30u, true);\n-        set(act, 31u, true);\n-        assert (eq_vec(act,\n+        act.set(3u, true);\n+        act.set(17u, true);\n+        act.set(30u, true);\n+        act.set(31u, true);\n+        assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 1u]));\n@@ -517,71 +672,71 @@ mod tests {\n         // all 0\n \n         act = bitv(33u, false);\n-        assert (eq_vec(act,\n+        assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = bitv(33u, true);\n-        assert (eq_vec(act,\n+        assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n         act = bitv(33u, false);\n-        set(act, 0u, true);\n-        set(act, 1u, true);\n-        set(act, 2u, true);\n-        set(act, 3u, true);\n-        set(act, 4u, true);\n-        set(act, 5u, true);\n-        set(act, 6u, true);\n-        set(act, 7u, true);\n-        assert (eq_vec(act,\n+        act.set(0u, true);\n+        act.set(1u, true);\n+        act.set(2u, true);\n+        act.set(3u, true);\n+        act.set(4u, true);\n+        act.set(5u, true);\n+        act.set(6u, true);\n+        act.set(7u, true);\n+        assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n         act = bitv(33u, false);\n-        set(act, 16u, true);\n-        set(act, 17u, true);\n-        set(act, 18u, true);\n-        set(act, 19u, true);\n-        set(act, 20u, true);\n-        set(act, 21u, true);\n-        set(act, 22u, true);\n-        set(act, 23u, true);\n-        assert (eq_vec(act,\n+        act.set(16u, true);\n+        act.set(17u, true);\n+        act.set(18u, true);\n+        act.set(19u, true);\n+        act.set(20u, true);\n+        act.set(21u, true);\n+        act.set(22u, true);\n+        act.set(23u, true);\n+        assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n         act = bitv(33u, false);\n-        set(act, 24u, true);\n-        set(act, 25u, true);\n-        set(act, 26u, true);\n-        set(act, 27u, true);\n-        set(act, 28u, true);\n-        set(act, 29u, true);\n-        set(act, 30u, true);\n-        set(act, 31u, true);\n-        assert (eq_vec(act,\n+        act.set(24u, true);\n+        act.set(25u, true);\n+        act.set(26u, true);\n+        act.set(27u, true);\n+        act.set(28u, true);\n+        act.set(29u, true);\n+        act.set(30u, true);\n+        act.set(31u, true);\n+        assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 0u]));\n         // mixed\n \n         act = bitv(33u, false);\n-        set(act, 3u, true);\n-        set(act, 17u, true);\n-        set(act, 30u, true);\n-        set(act, 31u, true);\n-        set(act, 32u, true);\n-        assert (eq_vec(act,\n+        act.set(3u, true);\n+        act.set(17u, true);\n+        act.set(30u, true);\n+        act.set(31u, true);\n+        act.set(32u, true);\n+        assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 1u, 1u]));\n@@ -591,16 +746,15 @@ mod tests {\n     fn test_equal_differing_sizes() {\n         let v0 = bitv(10u, false);\n         let v1 = bitv(11u, false);\n-        assert !equal(v0, v1);\n+        assert !v0.equal(v1);\n     }\n \n     #[test]\n     fn test_equal_greatly_differing_sizes() {\n         let v0 = bitv(10u, false);\n         let v1 = bitv(110u, false);\n-        assert !equal(v0, v1);\n+        assert !v0.equal(v1);\n     }\n-\n }\n \n //"}, {"sha": "c3ae0fb80fd4dee13f2e4e54ca68ab0d39bdfc37", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=082d8314da6b6b99854f0a70f5ea8e27f2602f79", "patch": "@@ -29,7 +29,7 @@ updating the states using rule (2) until there are no changes.\n \n import dvec::extensions;\n \n-import std::bitv::{bitv, methods};\n+import std::bitv::{bitv};\n \n import proto::methods;\n import ast_builder::empty_span;\n@@ -38,7 +38,7 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n     #debug(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n     let colive = do (copy proto.states).map_to_vec |state| {\n-        let bv = bitv(num_states, false);\n+        let bv = ~bitv(num_states, false);\n         for state.reachable |s| {\n             bv.set(s.id, true);\n         }"}, {"sha": "7729c3ffc1d370c978ba3bb8357ff4b398b72ec1", "filename": "src/rustc/middle/tstate/ann.rs", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs?ref=082d8314da6b6b99854f0a70f5ea8e27f2602f79", "patch": "@@ -53,8 +53,8 @@ fn empty_poststate(num_vars: uint) -> poststate {\n \n fn false_postcond(num_vars: uint) -> postcond {\n     let rslt = create_tritv(num_vars);\n-    tritv_set_all(rslt);\n-    ret rslt;\n+    rslt.set_all();\n+    rslt\n }\n \n fn empty_pre_post(num_vars: uint) -> pre_and_post {\n@@ -76,15 +76,11 @@ fn get_pre(&&p: pre_and_post) -> precond { ret p.precondition; }\n \n fn get_post(&&p: pre_and_post) -> postcond { ret p.postcondition; }\n \n-fn difference(p1: precond, p2: precond) -> bool {\n-    ret tritv_difference(p1, p2);\n-}\n+fn difference(p1: precond, p2: precond) -> bool { p1.difference(p2) }\n \n-fn union(p1: precond, p2: precond) -> bool { ret tritv_union(p1, p2); }\n+fn union(p1: precond, p2: precond) -> bool { p1.union(p2) }\n \n-fn intersect(p1: precond, p2: precond) -> bool {\n-    ret tritv_intersect(p1, p2);\n-}\n+fn intersect(p1: precond, p2: precond) -> bool { p1.intersect(p2) }\n \n fn pps_len(p: pre_and_post) -> uint {\n     // gratuitous check\n@@ -95,13 +91,13 @@ fn pps_len(p: pre_and_post) -> uint {\n \n fn require(i: uint, p: pre_and_post) {\n     // sets the ith bit in p's pre\n-    tritv_set(i, p.precondition, ttrue);\n+    p.precondition.set(i, ttrue);\n }\n \n fn require_and_preserve(i: uint, p: pre_and_post) {\n     // sets the ith bit in p's pre and post\n-    tritv_set(i, p.precondition, ttrue);\n-    tritv_set(i, p.postcondition, ttrue);\n+    p.precondition.set(i, ttrue);\n+    p.postcondition.set(i, ttrue);\n }\n \n fn set_in_postcond(i: uint, p: pre_and_post) -> bool {\n@@ -110,8 +106,8 @@ fn set_in_postcond(i: uint, p: pre_and_post) -> bool {\n }\n \n fn set_in_postcond_(i: uint, p: postcond) -> bool {\n-    let was_set = tritv_get(p, i);\n-    tritv_set(i, p, ttrue);\n+    let was_set = p.get(i);\n+    p.set(i, ttrue);\n     ret was_set != ttrue;\n }\n \n@@ -121,8 +117,8 @@ fn set_in_poststate(i: uint, s: pre_and_post_state) -> bool {\n }\n \n fn set_in_poststate_(i: uint, p: poststate) -> bool {\n-    let was_set = tritv_get(p, i);\n-    tritv_set(i, p, ttrue);\n+    let was_set = p.get(i);\n+    p.set(i, ttrue);\n     ret was_set != ttrue;\n \n }\n@@ -133,8 +129,8 @@ fn clear_in_poststate(i: uint, s: pre_and_post_state) -> bool {\n }\n \n fn clear_in_poststate_(i: uint, s: poststate) -> bool {\n-    let was_set = tritv_get(s, i);\n-    tritv_set(i, s, tfalse);\n+    let was_set = s.get(i);\n+    s.set(i, tfalse);\n     ret was_set != tfalse;\n }\n \n@@ -144,61 +140,61 @@ fn clear_in_prestate(i: uint, s: pre_and_post_state) -> bool {\n }\n \n fn clear_in_prestate_(i: uint, s: prestate) -> bool {\n-    let was_set = tritv_get(s, i);\n-    tritv_set(i, s, tfalse);\n+    let was_set = s.get(i);\n+    s.set(i, tfalse);\n     ret was_set != tfalse;\n }\n \n fn clear_in_postcond(i: uint, s: pre_and_post) -> bool {\n     // sets the ith bit in p's post\n-    let was_set = tritv_get(s.postcondition, i);\n-    tritv_set(i, s.postcondition, tfalse);\n+    let was_set = s.postcondition.get(i);\n+    s.postcondition.set(i, tfalse);\n     ret was_set != tfalse;\n }\n \n // Sets all the bits in a's precondition to equal the\n // corresponding bit in p's precondition.\n fn set_precondition(a: ts_ann, p: precond) {\n-    tritv_copy(a.conditions.precondition, p);\n+    a.conditions.precondition.become(p);\n }\n \n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n fn set_postcondition(a: ts_ann, p: postcond) {\n-    tritv_copy(a.conditions.postcondition, p);\n+    a.conditions.postcondition.become(p);\n }\n \n \n // Sets all the bits in a's prestate to equal the\n // corresponding bit in p's prestate.\n fn set_prestate(a: ts_ann, p: prestate) -> bool {\n-    ret tritv_copy(a.states.prestate, p);\n+    a.states.prestate.become(p)\n }\n \n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n fn set_poststate(a: ts_ann, p: poststate) -> bool {\n-    ret tritv_copy(a.states.poststate, p);\n+    a.states.poststate.become(p)\n }\n \n \n // Set all the bits in p that are set in new\n fn extend_prestate(p: prestate, newv: poststate) -> bool {\n-    ret tritv_union(p, newv);\n+    p.union(newv)\n }\n \n \n // Set all the bits in p that are set in new\n fn extend_poststate(p: poststate, newv: poststate) -> bool {\n-    ret tritv_union(p, newv);\n+    p.union(newv)\n }\n \n // Sets the given bit in p to \"don't care\"\n fn relax_prestate(i: uint, p: prestate) -> bool {\n-    let was_set = tritv_get(p, i);\n-    tritv_set(i, p, dont_care);\n+    let was_set = p.get(i);\n+    p.set(i, dont_care);\n     ret was_set != dont_care;\n }\n \n@@ -211,10 +207,10 @@ fn relax_poststate(i: uint, p: poststate) -> bool {\n fn relax_precond(i: uint, p: precond) { relax_prestate(i, p); }\n \n // Sets all the bits in p to \"don't care\"\n-fn clear(p: precond) { tritv_clear(p); }\n+fn clear(p: precond) { p.clear(); }\n \n // Sets all the bits in p to true\n-fn set(p: precond) { tritv_set_all(p); }\n+fn set(p: precond) { p.set_all(); }\n \n fn ann_precond(a: ts_ann) -> precond { ret a.conditions.precondition; }\n \n@@ -227,16 +223,16 @@ fn pp_clone(p: pre_and_post) -> pre_and_post {\n          postcondition: clone(p.postcondition)};\n }\n \n-fn clone(p: prestate) -> prestate { ret tritv_clone(p); }\n+fn clone(p: prestate) -> prestate { p.clone() }\n \n \n // returns true if a implies b\n // that is, returns true except if for some bits c and d,\n // c = 1 and d = either 0 or \"don't know\"\n fn implies(a: t, b: t) -> bool {\n-    let tmp = tritv_clone(b);\n-    tritv_difference(tmp, a);\n-    ret tritv_doesntcare(tmp);\n+    let tmp = b.clone();\n+    tmp.difference(a);\n+    tmp.doesntcare()\n }\n \n fn trit_str(t: trit) -> ~str {"}, {"sha": "1e6bcd52edee614c481a346df6cd4605e959c9ac", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=082d8314da6b6b99854f0a70f5ea8e27f2602f79", "patch": "@@ -15,7 +15,7 @@ import tstate::ann::{pre_and_post, pre_and_post_state, empty_ann, prestate,\n                      clear_in_poststate_};\n import driver::session::session;\n import dvec::{dvec, extensions};\n-import tritv::{dont_care, tfalse, tritv_get, ttrue};\n+import tritv::{trit, tfalse, ttrue, dont_care, t};\n \n import syntax::print::pprust::{constr_args_to_str, lit_to_str};\n \n@@ -59,7 +59,7 @@ fn tritv_to_str(fcx: fn_ctxt, v: tritv::t) -> ~str {\n     let mut s = ~\"\";\n     let mut comma = false;\n     for constraints(fcx).each |p| {\n-        alt tritv_get(v, p.bit_num) {\n+        alt v.get(p.bit_num) {\n           dont_care { }\n           tt {\n             s +=\n@@ -80,8 +80,8 @@ fn first_difference_string(fcx: fn_ctxt, expected: tritv::t, actual: tritv::t)\n    -> ~str {\n     let mut s = ~\"\";\n     for constraints(fcx).each |c| {\n-        if tritv_get(expected, c.bit_num) == ttrue &&\n-               tritv_get(actual, c.bit_num) != ttrue {\n+      if expected.get(c.bit_num) == ttrue &&\n+         actual.get(c.bit_num) != ttrue {\n             s = constraint_to_str(fcx.ccx.tcx, c.c);\n             break;\n         }\n@@ -108,35 +108,35 @@ fn log_cond(v: ~[uint]) { log(debug, tos(v)); }\n fn log_cond_err(v: ~[uint]) { log(error, tos(v)); }\n \n fn log_pp(pp: pre_and_post) {\n-    let p1 = tritv::to_vec(pp.precondition);\n-    let p2 = tritv::to_vec(pp.postcondition);\n+    let p1 = pp.precondition.to_vec();\n+    let p2 = pp.postcondition.to_vec();\n     #debug(\"pre:\");\n     log_cond(p1);\n     #debug(\"post:\");\n     log_cond(p2);\n }\n \n fn log_pp_err(pp: pre_and_post) {\n-    let p1 = tritv::to_vec(pp.precondition);\n-    let p2 = tritv::to_vec(pp.postcondition);\n+    let p1 = pp.precondition.to_vec();\n+    let p2 = pp.postcondition.to_vec();\n     #error(\"pre:\");\n     log_cond_err(p1);\n     #error(\"post:\");\n     log_cond_err(p2);\n }\n \n fn log_states(pp: pre_and_post_state) {\n-    let p1 = tritv::to_vec(pp.prestate);\n-    let p2 = tritv::to_vec(pp.poststate);\n+    let p1 = pp.prestate.to_vec();\n+    let p2 = pp.poststate.to_vec();\n     #debug(\"prestate:\");\n     log_cond(p1);\n     #debug(\"poststate:\");\n     log_cond(p2);\n }\n \n fn log_states_err(pp: pre_and_post_state) {\n-    let p1 = tritv::to_vec(pp.prestate);\n-    let p2 = tritv::to_vec(pp.poststate);\n+    let p1 = pp.prestate.to_vec();\n+    let p2 = pp.poststate.to_vec();\n     #error(\"prestate:\");\n     log_cond_err(p1);\n     #error(\"poststate:\");"}, {"sha": "36b7d9c7308e2e902fe7fd5d30594550a6c21fdf", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=082d8314da6b6b99854f0a70f5ea8e27f2602f79", "patch": "@@ -184,7 +184,7 @@ fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n     alt lhs.node {\n       expr_path(p) {\n         let post = expr_postcond(fcx.ccx, parent);\n-        let tmp = tritv_clone(post);\n+        let tmp = post.clone();\n \n         alt ty {\n           oper_move {\n@@ -497,7 +497,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                     /* Clear out anything that the previous initializer\n                     guaranteed */\n                     let e_pp = expr_pp(fcx.ccx, an_init.expr);\n-                    tritv_copy(prev_pp.precondition,\n+                    prev_pp.precondition.become(\n                                seq_preconds(fcx, ~[prev_pp, e_pp]));\n \n                     /* Include the LHSs too, since those aren't in the"}, {"sha": "e427841103f5f7cff49644cbb6e214fe709db9cf", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=082d8314da6b6b99854f0a70f5ea8e27f2602f79", "patch": "@@ -1,6 +1,6 @@\n import ann::*;\n import aux::*;\n-import tritv::{tritv_clone, tritv_set, ttrue};\n+import tritv::*;\n \n import syntax::print::pprust::block_to_str;\n import bitvectors::*;\n@@ -57,14 +57,14 @@ fn handle_move_or_copy(fcx: fn_ctxt, post: poststate, rhs_path: @path,\n fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: ~[binding]) ->\n    {changed: bool, post: poststate} {\n     let mut changed = false;\n-    let mut post = tritv_clone(pres);\n+    let mut post = pres.clone();\n     for bindings.each |b| {\n         alt b.rhs {\n           some(an_init) {\n             // an expression, with or without a destination\n             changed |=\n                 find_pre_post_state_expr(fcx, post, an_init.expr) || changed;\n-            post = tritv_clone(expr_poststate(fcx.ccx, an_init.expr));\n+            post = expr_poststate(fcx.ccx, an_init.expr).clone();\n             for b.lhs.each |d| {\n                 alt an_init.expr.node {\n                   expr_path(p) {\n@@ -93,7 +93,7 @@ fn find_pre_post_state_sub(fcx: fn_ctxt, pres: prestate, e: @expr,\n \n     changed = set_prestate_ann(fcx.ccx, parent, pres) || changed;\n \n-    let post = tritv_clone(expr_poststate(fcx.ccx, e));\n+    let post = expr_poststate(fcx.ccx, e).clone();\n     alt c {\n       none { }\n       some(c1) { set_in_poststate_(bit_num(fcx, c1), post); }\n@@ -113,15 +113,15 @@ fn find_pre_post_state_two(fcx: fn_ctxt, pres: prestate, lhs: @expr,\n             changed;\n     forbid_upvar(fcx, rhs.id, rhs.span, ty);\n \n-    let post = tritv_clone(expr_poststate(fcx.ccx, rhs));\n+    let post = expr_poststate(fcx.ccx, rhs).clone();\n \n     alt lhs.node {\n       expr_path(p) {\n         // for termination, need to make sure intermediate changes don't set\n         // changed flag\n         // tmp remembers \"old\" constraints we'd otherwise forget,\n         // for substitution purposes\n-        let tmp = tritv_clone(post);\n+        let tmp = post.clone();\n \n         alt ty {\n           oper_move {\n@@ -210,8 +210,8 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n         alt chk {\n           if_check {\n             let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n-            let conseq_prestate = tritv_clone(expr_poststate(fcx.ccx, antec));\n-            tritv_set(bit_num(fcx, c.node), conseq_prestate, ttrue);\n+            let conseq_prestate = expr_poststate(fcx.ccx, antec).clone();\n+            conseq_prestate.set(bit_num(fcx, c.node), ttrue);\n             changed |=\n                 find_pre_post_state_block(fcx, conseq_prestate, conseq) |\n                     set_poststate_ann(fcx.ccx, id,\n@@ -235,8 +235,8 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n         alt chk {\n           if_check {\n             let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n-            conseq_prestate = tritv_clone(conseq_prestate);\n-            tritv_set(bit_num(fcx, c.node), conseq_prestate, ttrue);\n+            conseq_prestate = conseq_prestate.clone();\n+            conseq_prestate.set(bit_num(fcx, c.node),  ttrue);\n           }\n           _ { }\n         }\n@@ -270,7 +270,7 @@ fn find_pre_post_state_cap_clause(fcx: fn_ctxt, e_id: node_id,\n {\n     let ccx = fcx.ccx;\n     let pres_changed = set_prestate_ann(ccx, e_id, pres);\n-    let post = tritv_clone(pres);\n+    let post = pres.clone();\n     for (*cap_clause).each |cap_item| {\n         if cap_item.is_move {\n             forget_in_poststate(fcx, post, cap_item.id);\n@@ -432,7 +432,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n                 worst case, the body could invalidate all preds and\n                 deinitialize everything before breaking */\n             let post = empty_poststate(num_constrs);\n-            tritv::tritv_kill(post);\n+            post.kill();\n             ret changed | set_poststate_ann(fcx.ccx, e.id, post);\n         } else {\n             ret changed | set_poststate_ann(fcx.ccx, e.id,\n@@ -507,8 +507,8 @@ fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n \n     #debug[\"[ %s ]\", *fcx.name];\n     #debug[\"*At beginning: stmt = %s\", stmt_to_str(*s)];\n-    #debug[\"*prestate = %s\", tritv::to_str(stmt_ann.states.prestate)];\n-    #debug[\"*poststate = %s\", tritv::to_str(stmt_ann.states.prestate)];\n+    #debug[\"*prestate = %s\", stmt_ann.states.prestate.to_str()];\n+    #debug[\"*poststate = %s\", stmt_ann.states.prestate.to_str()];\n \n     alt s.node {\n       stmt_decl(adecl, id) {\n@@ -525,8 +525,8 @@ fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n                 set_poststate(stmt_ann, c_and_p.post) | c_and_p.changed;\n \n             #debug[\"Summary: stmt = %s\", stmt_to_str(*s)];\n-            #debug[\"prestate = %s\", tritv::to_str(stmt_ann.states.prestate)];\n-            #debug[\"poststate = %s\",tritv::to_str(stmt_ann.states.poststate)];\n+            #debug[\"prestate = %s\", stmt_ann.states.prestate.to_str()];\n+            #debug[\"poststate = %s\", stmt_ann.states.poststate.to_str()];\n             #debug[\"changed = %s\", bool::to_str(changed)];\n \n             ret changed;\n@@ -545,8 +545,8 @@ fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n \n \n         #debug[\"Finally: %s\", stmt_to_str(*s)];\n-        #debug[\"prestate = %s\", tritv::to_str(stmt_ann.states.prestate)];\n-        #debug[\"poststate = %s\", tritv::to_str(stmt_ann.states.poststate)];\n+        #debug[\"prestate = %s\", stmt_ann.states.prestate.to_str()];\n+        #debug[\"poststate = %s\", stmt_ann.states.poststate.to_str()];\n         #debug[\"changed = %s\", bool::to_str(changed)];\n \n         ret changed;"}, {"sha": "1e78b82fba8c764cbcafa8cb8a9de6e357061bf9", "filename": "src/rustc/middle/tstate/tritv.rs", "status": "modified", "additions": 153, "deletions": 173, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs?ref=082d8314da6b6b99854f0a70f5ea8e27f2602f79", "patch": "@@ -1,24 +1,8 @@\n-import std::bitv;\n+import std::bitv::*;\n \n export t;\n export create_tritv;\n-export tritv_clone;\n-export tritv_set;\n-export to_vec;\n-export trit;\n-export dont_care;\n-export ttrue;\n-export tfalse;\n-export tritv_get;\n-export tritv_set_all;\n-export tritv_difference;\n-export tritv_union;\n-export tritv_intersect;\n-export tritv_copy;\n-export tritv_clear;\n-export tritv_kill;\n-export tritv_doesntcare;\n-export to_str;\n+export trit, tfalse, ttrue, dont_care;\n \n /* for a fixed index:\n    10 = \"this constraint may or may not be true after execution\"\n@@ -31,17 +15,160 @@ export to_str;\n  per discussion at).\n */\n \n-type t = {uncertain: bitv::bitv, val: bitv::bitv, nbits: uint};\n enum trit { ttrue, tfalse, dont_care, }\n \n-fn create_tritv(len: uint) -> t {\n-    ret {uncertain: bitv::bitv(len, true),\n-         val: bitv::bitv(len, false),\n-         nbits: len};\n+class t {\n+    // Shouldn't be mut; instead we should have a different\n+    // constructor that takes two bitvs\n+    let mut uncertain: bitv;\n+    let mut val: bitv;\n+    let nbits: uint;\n+    // next two should be private (#2297)\n+    fn set_uncertain(-b: bitv) {\n+        self.uncertain <- b;\n+    }\n+    fn set_val(-b: bitv) {\n+        self.val <- b;\n+    }\n+    fn clone() -> t {\n+        let rs = t(self.nbits);\n+        let r = self.uncertain.clone();\n+        rs.set_uncertain(r);\n+        let r1 = self.val.clone();\n+        rs.set_val(r1);\n+        rs\n+    }\n+    fn difference(p: t) -> bool {\n+        assert (self.nbits == p.nbits);\n+        let mut changed = false;\n+        for uint::range(0, p.nbits) |i| {\n+           let old = p.get(i);\n+           let newv = minus(old, p.get(i));\n+           changed = change(changed, old, newv);\n+           self.set(i, newv);\n+        };\n+        changed\n+    }\n+    pure fn get(i: uint) -> trit {\n+        let b1 = self.uncertain.get(i);\n+        let b2 = self.val.get(i);\n+        assert (!(b1 && b2));\n+        if b1 { dont_care } else if b2 { ttrue } else { tfalse }\n+    }\n+    pure fn set(i: uint, t: trit) -> bool {\n+        let old = self.get(i);\n+        alt t {\n+          dont_care {\n+            self.uncertain.set(i, true);\n+            self.val.set(i, false);\n+          }\n+          ttrue {\n+            self.uncertain.set(i, false);\n+            self.val.set(i, true);\n+          }\n+          tfalse {\n+            self.uncertain.set(i, false);\n+            self.val.set(i, false);\n+          }\n+        }\n+        change(false, old, t)\n+    }\n+\n+    fn set_all() {\n+      for uint::range(0u, self.nbits) |i| {\n+         self.set(i, ttrue);\n+      }\n+    }\n+\n+    fn clear() {\n+      for uint::range(0, self.nbits) |i| {\n+         self.set(i, dont_care);\n+      }\n+    }\n+\n+    fn kill() {\n+       for uint::range(0, self.nbits) |i| {\n+           self.set(i, dont_care);\n+       }\n+    }\n+\n+    fn doesntcare() -> bool {\n+        for uint::range(0, self.nbits) |i| {\n+           if self.get(i) != dont_care { ret false; }\n+        }\n+        true\n+    }\n+\n+    fn to_vec() -> ~[uint] {\n+      let mut rslt: ~[uint] = ~[];\n+      for uint::range(0, self.nbits) |i| {\n+        vec::push(rslt,\n+                  alt self.get(i) {\n+                      dont_care { 2 }\n+                      ttrue     { 1 }\n+                      tfalse    { 0 }\n+                  });\n+      };\n+      rslt\n+    }\n+\n+    fn to_str() -> str {\n+       let mut rs: str = \"\";\n+       for uint::range(0, self.nbits) |i| {\n+        rs +=\n+            alt self.get(i) {\n+              dont_care { \"?\" }\n+              ttrue { \"1\" }\n+              tfalse { \"0\" }\n+            };\n+       };\n+       rs\n+    }\n+\n+    fn intersect(p: t) -> bool {\n+      assert (self.nbits == p.nbits);\n+      let mut changed = false;\n+      for uint::range(0, self.nbits) |i| {\n+        let old = self.get(i);\n+        let newv = trit_and(old, p.get(i));\n+        changed = change(changed, old, newv);\n+        self.set(i, newv);\n+       }\n+      ret changed;\n+    }\n+\n+    fn become(source: t) -> bool {\n+      assert (self.nbits == source.nbits);\n+      let changed = !self.uncertain.equal(source.uncertain) ||\n+          !self.val.equal(source.val);\n+      self.uncertain.assign(source.uncertain);\n+      self.val.assign(source.val);\n+      changed\n+    }\n+\n+    fn union(p: t) -> bool {\n+        assert (self.nbits == p.nbits);\n+        let mut changed = false;\n+        for uint::range(0, self.nbits) |i| {\n+           let old = self.get(i);\n+           let newv = trit_or(old, p.get(i));\n+           changed = change(changed, old, newv);\n+           self.set(i, newv);\n+        }\n+        ret changed;\n+    }\n+\n+    new(len: uint) {\n+        self.uncertain = mk_bitv(len, true);\n+        self.val = mk_bitv(len, false);\n+        self.nbits = len;\n+    }\n }\n \n+fn create_tritv(len: uint) -> t { t(len) }\n \n-fn trit_minus(a: trit, b: trit) -> trit {\n+\n+fn minus(a: trit, b: trit) -> trit {\n \n     /*   2 - anything = 2\n          1 - 1 = 2\n@@ -56,10 +183,6 @@ fn trit_minus(a: trit, b: trit) -> trit {\n         alt b {\n           ttrue { dont_care }\n           tfalse { ttrue }\n-\n-\n-\n-\n           /* internally contradictory, but\n              I guess it'll get flagged? */\n           dont_care {\n@@ -70,18 +193,14 @@ fn trit_minus(a: trit, b: trit) -> trit {\n       tfalse {\n         alt b {\n           ttrue { tfalse }\n-\n-\n-\n-\n           /* see above comment */\n           _ {\n             tfalse\n           }\n         }\n       }\n+     }\n     }\n-}\n \n fn trit_or(a: trit, b: trit) -> trit {\n     alt a {\n@@ -137,148 +256,9 @@ fn trit_and(a: trit, b: trit) -> trit {\n     // a and b were both dont_care\n }\n \n-fn change(changed: bool, old: trit, newv: trit) -> bool {\n+pure fn change(changed: bool, old: trit, newv: trit) -> bool {\n     changed || newv != old\n }\n-\n-fn tritv_difference(p1: t, p2: t) -> bool {\n-    let mut i: uint = 0u;\n-    assert (p1.nbits == p2.nbits);\n-    let sz: uint = p1.nbits;\n-    let mut changed = false;\n-    while i < sz {\n-        let old = tritv_get(p1, i);\n-        let newv = trit_minus(old, tritv_get(p2, i));\n-        changed = change(changed, old, newv);\n-        tritv_set(i, p1, newv);\n-        i += 1u;\n-    }\n-    ret changed;\n-}\n-\n-fn tritv_union(p1: t, p2: t) -> bool {\n-    let mut i: uint = 0u;\n-    assert (p1.nbits == p2.nbits);\n-    let sz: uint = p1.nbits;\n-    let mut changed = false;\n-    while i < sz {\n-        let old = tritv_get(p1, i);\n-        let newv = trit_or(old, tritv_get(p2, i));\n-        changed = change(changed, old, newv);\n-        tritv_set(i, p1, newv);\n-        i += 1u;\n-    }\n-    ret changed;\n-}\n-\n-fn tritv_intersect(p1: t, p2: t) -> bool {\n-    let mut i: uint = 0u;\n-    assert (p1.nbits == p2.nbits);\n-    let sz: uint = p1.nbits;\n-    let mut changed = false;\n-    while i < sz {\n-        let old = tritv_get(p1, i);\n-        let newv = trit_and(old, tritv_get(p2, i));\n-        changed = change(changed, old, newv);\n-        tritv_set(i, p1, newv);\n-        i += 1u;\n-    }\n-    ret changed;\n-}\n-\n-fn tritv_get(v: t, i: uint) -> trit {\n-    let b1 = bitv::get(v.uncertain, i);\n-    let b2 = bitv::get(v.val, i);\n-    assert (!(b1 && b2));\n-    if b1 { dont_care } else if b2 { ttrue } else { tfalse }\n-}\n-\n-fn tritv_set(i: uint, v: t, t: trit) -> bool {\n-    let old = tritv_get(v, i);\n-    alt t {\n-      dont_care {\n-        bitv::set(v.uncertain, i, true);\n-        bitv::set(v.val, i, false);\n-      }\n-      ttrue { bitv::set(v.uncertain, i, false); bitv::set(v.val, i, true); }\n-      tfalse {\n-        bitv::set(v.uncertain, i, false);\n-        bitv::set(v.val, i, false);\n-      }\n-    }\n-    ret change(false, old, t);\n-}\n-\n-fn tritv_copy(target: t, source: t) -> bool {\n-    assert (target.nbits == source.nbits);\n-    let changed =\n-        !bitv::equal(target.uncertain, source.uncertain) ||\n-            !bitv::equal(target.val, source.val);\n-    bitv::assign(target.uncertain, source.uncertain);\n-    bitv::assign(target.val, source.val);\n-    ret changed;\n-}\n-\n-fn tritv_set_all(v: t) {\n-    let mut i: uint = 0u;\n-    while i < v.nbits { tritv_set(i, v, ttrue); i += 1u; }\n-}\n-\n-fn tritv_clear(v: t) {\n-    let mut i: uint = 0u;\n-    while i < v.nbits { tritv_set(i, v, dont_care); i += 1u; }\n-}\n-\n-fn tritv_kill(v: t) {\n-    let mut i: uint = 0u;\n-    while i < v.nbits { tritv_set(i, v, tfalse); i += 1u; }\n-}\n-\n-fn tritv_clone(v: t) -> t {\n-    ret {uncertain: bitv::clone(v.uncertain),\n-         val: bitv::clone(v.val),\n-         nbits: v.nbits};\n-}\n-\n-fn tritv_doesntcare(v: t) -> bool {\n-    let mut i: uint = 0u;\n-    while i < v.nbits {\n-        if tritv_get(v, i) != dont_care { ret false; }\n-        i += 1u;\n-    }\n-    ret true;\n-}\n-\n-fn to_vec(v: t) -> ~[uint] {\n-    let mut i: uint = 0u;\n-    let mut rslt: ~[uint] = ~[];\n-    while i < v.nbits {\n-        vec::push(rslt,\n-                  alt tritv_get(v, i) {\n-                      dont_care { 2u }\n-                      ttrue { 1u }\n-                      tfalse { 0u }\n-                  });\n-        i += 1u;\n-    }\n-    ret rslt;\n-}\n-\n-fn to_str(v: t) -> ~str {\n-    let mut i: uint = 0u;\n-    let mut rs: ~str = ~\"\";\n-    while i < v.nbits {\n-        rs +=\n-            alt tritv_get(v, i) {\n-              dont_care { ~\"?\" }\n-              ttrue { ~\"1\" }\n-              tfalse { ~\"0\" }\n-            };\n-        i += 1u;\n-    }\n-    ret rs;\n-}\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "f1bf1ec8d0a7e38cc0c7a7bd582caaaf7acbb30b", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=082d8314da6b6b99854f0a70f5ea8e27f2602f79", "patch": "@@ -52,15 +52,15 @@ fn solve_grid(g: grid_t) {\n             // colors not yet used\n             let avail = bitv::bitv(10u, false);\n             for u8::range(start_color, 10u8) |color| {\n-                bitv::set(avail, color as uint, true);\n+                avail.set(color as uint, true);\n             }\n \n             // drop colors already in use in neighbourhood\n             drop_colors(g, avail, row, col);\n \n             // find first remaining color that is available\n             for uint::range(1u, 10u) |i| {\n-                if bitv::get(avail, i) {\n+                if avail.get(i) {\n                     g[row][col] = i as u8;\n                     ret true;\n                 }\n@@ -74,7 +74,7 @@ fn solve_grid(g: grid_t) {\n     fn drop_colors(g: grid, avail: bitv::bitv, row: u8, col: u8) {\n         fn drop_color(g: grid, colors: bitv::bitv, row: u8, col: u8) {\n             let color = g[row][col];\n-            if color != 0u8 { bitv::set(colors, color as uint, false); }\n+            if color != 0u8 { colors.set(color as uint, false); }\n         }\n \n         let it = |a,b| drop_color(g, avail, a, b);"}, {"sha": "2252672f1b558050a2f5ded19c60c0bcffe03554", "filename": "src/test/compile-fail/for-loop-decl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs?ref=082d8314da6b6b99854f0a70f5ea8e27f2602f79", "patch": "@@ -6,12 +6,12 @@ import std::bitv;\n type fn_info = {vars: hashmap<uint, var_info>};\n type var_info = {a: uint, b: uint};\n \n-fn bitv_to_str(enclosing: fn_info, v: bitv::bitv) -> str {\n+fn bitv_to_str(enclosing: fn_info, v: ~bitv::bitv) -> str {\n     let s = \"\";\n \n     // error is that the value type in the hash map is var_info, not a box\n     for enclosing.vars.each_value |val| {\n-        if bitv::get(v, val) { s += \"foo\"; }\n+        if v.get(val) { s += \"foo\"; }\n     }\n     ret s;\n }"}, {"sha": "2e4b567e6196760b66c092801fc7992fcc3f9323", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082d8314da6b6b99854f0a70f5ea8e27f2602f79/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=082d8314da6b6b99854f0a70f5ea8e27f2602f79", "patch": "@@ -0,0 +1,13 @@\n+use std;\n+import std::bitv::*;\n+\n+fn bitv_test() -> bool {\n+    let v1 = ~bitv(31, false);\n+    let v2 = ~bitv(31, true);\n+    v1.union(v2);\n+    true\n+}\n+\n+fn main() {\n+    do iter::repeat(1000000) || {bitv_test()};\n+}\n\\ No newline at end of file"}]}