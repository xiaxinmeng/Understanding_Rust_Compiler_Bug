{"sha": "d88d06448e1ad928d22cf0a511f1edae91b646d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4OGQwNjQ0OGUxYWQ5MjhkMjJjZjBhNTExZjFlZGFlOTFiNjQ2ZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-16T09:17:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-16T09:17:53Z"}, "message": "Auto merge of #37773 - ollie27:rustdoc_inline_glob, r=brson\n\nrustdoc: Fix some local inlining issues\n\n* Only inline public items when inlining glob imports.\n* Never inline while in a private module or a child of a private module.\n* Never inline impls. This allowed the removal of a workaround in the\nrendering code.", "tree": {"sha": "428a29c8df5d9e883db64c0249b0ea736c1560ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/428a29c8df5d9e883db64c0249b0ea736c1560ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d88d06448e1ad928d22cf0a511f1edae91b646d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d88d06448e1ad928d22cf0a511f1edae91b646d5", "html_url": "https://github.com/rust-lang/rust/commit/d88d06448e1ad928d22cf0a511f1edae91b646d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d88d06448e1ad928d22cf0a511f1edae91b646d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c19cb9c12d19ae2fd19abe8c685d0c32961dda78", "url": "https://api.github.com/repos/rust-lang/rust/commits/c19cb9c12d19ae2fd19abe8c685d0c32961dda78", "html_url": "https://github.com/rust-lang/rust/commit/c19cb9c12d19ae2fd19abe8c685d0c32961dda78"}, {"sha": "6fe7786db6d44449127600cf69838cb246db810b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fe7786db6d44449127600cf69838cb246db810b", "html_url": "https://github.com/rust-lang/rust/commit/6fe7786db6d44449127600cf69838cb246db810b"}], "stats": {"total": 313, "additions": 244, "deletions": 69}, "files": [{"sha": "2761ab76607055f08fb918cc9e1da4b5a602cb10", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 17, "deletions": 35, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d88d06448e1ad928d22cf0a511f1edae91b646d5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d88d06448e1ad928d22cf0a511f1edae91b646d5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d88d06448e1ad928d22cf0a511f1edae91b646d5", "patch": "@@ -257,8 +257,6 @@ pub struct Cache {\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     search_index: Vec<IndexItem>,\n-    seen_modules: FxHashSet<DefId>,\n-    seen_mod: bool,\n     stripped_mod: bool,\n     deref_trait_did: Option<DefId>,\n     deref_mut_trait_did: Option<DefId>,\n@@ -520,8 +518,6 @@ pub fn run(mut krate: clean::Crate,\n         parent_is_trait_impl: false,\n         extern_locations: FxHashMap(),\n         primitive_locations: FxHashMap(),\n-        seen_modules: FxHashSet(),\n-        seen_mod: false,\n         stripped_mod: false,\n         access_levels: krate.access_levels.clone(),\n         orphan_impl_items: Vec::new(),\n@@ -977,37 +973,26 @@ impl DocFolder for Cache {\n             _ => self.stripped_mod,\n         };\n \n-        // Inlining can cause us to visit the same item multiple times.\n-        // (i.e. relevant for gathering impls and implementors)\n-        let orig_seen_mod = if item.is_mod() {\n-            let seen_this = self.seen_mod || !self.seen_modules.insert(item.def_id);\n-            mem::replace(&mut self.seen_mod, seen_this)\n-        } else {\n-            self.seen_mod\n-        };\n-\n         // Register any generics to their corresponding string. This is used\n         // when pretty-printing types\n         if let Some(generics) = item.inner.generics() {\n             self.generics(generics);\n         }\n \n-        if !self.seen_mod {\n-            // Propagate a trait methods' documentation to all implementors of the\n-            // trait\n-            if let clean::TraitItem(ref t) = item.inner {\n-                self.traits.insert(item.def_id, t.clone());\n-            }\n+        // Propagate a trait methods' documentation to all implementors of the\n+        // trait\n+        if let clean::TraitItem(ref t) = item.inner {\n+            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n+        }\n \n-            // Collect all the implementors of traits.\n-            if let clean::ImplItem(ref i) = item.inner {\n-                if let Some(did) = i.trait_.def_id() {\n-                    self.implementors.entry(did).or_insert(vec![]).push(Implementor {\n-                        def_id: item.def_id,\n-                        stability: item.stability.clone(),\n-                        impl_: i.clone(),\n-                    });\n-                }\n+        // Collect all the implementors of traits.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if let Some(did) = i.trait_.def_id() {\n+                self.implementors.entry(did).or_insert(vec![]).push(Implementor {\n+                    def_id: item.def_id,\n+                    stability: item.stability.clone(),\n+                    impl_: i.clone(),\n+                });\n             }\n         }\n \n@@ -1186,12 +1171,10 @@ impl DocFolder for Cache {\n                 } else {\n                     unreachable!()\n                 };\n-                if !self.seen_mod {\n-                    if let Some(did) = did {\n-                        self.impls.entry(did).or_insert(vec![]).push(Impl {\n-                            impl_item: item,\n-                        });\n-                    }\n+                if let Some(did) = did {\n+                    self.impls.entry(did).or_insert(vec![]).push(Impl {\n+                        impl_item: item,\n+                    });\n                 }\n                 None\n             } else {\n@@ -1201,7 +1184,6 @@ impl DocFolder for Cache {\n \n         if pushed { self.stack.pop().unwrap(); }\n         if parent_pushed { self.parent_stack.pop().unwrap(); }\n-        self.seen_mod = orig_seen_mod;\n         self.stripped_mod = orig_stripped_mod;\n         self.parent_is_trait_impl = orig_parent_is_trait_impl;\n         ret"}, {"sha": "d9155e10e17b6306f74258972bafa533ea4f5846", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 54, "deletions": 34, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d88d06448e1ad928d22cf0a511f1edae91b646d5/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d88d06448e1ad928d22cf0a511f1edae91b646d5/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=d88d06448e1ad928d22cf0a511f1edae91b646d5", "patch": "@@ -44,7 +44,9 @@ pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx>,\n     view_item_stack: FxHashSet<ast::NodeId>,\n-    inlining_from_glob: bool,\n+    inlining: bool,\n+    /// Is the current module and all of its parents public?\n+    inside_public_path: bool,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n@@ -57,7 +59,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             attrs: hir::HirVec::new(),\n             cx: cx,\n             view_item_stack: stack,\n-            inlining_from_glob: false,\n+            inlining: false,\n+            inside_public_path: true,\n         }\n     }\n \n@@ -189,10 +192,14 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.stab = self.stability(id);\n         om.depr = self.deprecation(id);\n         om.id = id;\n+        // Keep track of if there were any private modules in the path.\n+        let orig_inside_public_path = self.inside_public_path;\n+        self.inside_public_path &= vis == hir::Public;\n         for i in &m.item_ids {\n             let item = self.cx.map.expect_item(i.id);\n             self.visit_item(item, None, &mut om);\n         }\n+        self.inside_public_path = orig_inside_public_path;\n         if let Some(exports) = self.cx.export_map.get(&id) {\n             for export in exports {\n                 if let Def::Macro(def_id) = export.def {\n@@ -336,8 +343,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         let ret = match tcx.map.get(def_node_id) {\n             hir_map::NodeItem(it) => {\n+                let prev = mem::replace(&mut self.inlining, true);\n                 if glob {\n-                    let prev = mem::replace(&mut self.inlining_from_glob, true);\n                     match it.node {\n                         hir::ItemMod(ref m) => {\n                             for i in &m.item_ids {\n@@ -348,10 +355,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                         hir::ItemEnum(..) => {}\n                         _ => { panic!(\"glob not mapped to a module or enum\"); }\n                     }\n-                    self.inlining_from_glob = prev;\n                 } else {\n                     self.visit_item(it, renamed, om);\n                 }\n+                self.inlining = prev;\n                 true\n             }\n             _ => false,\n@@ -365,6 +372,19 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         debug!(\"Visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.name);\n         match item.node {\n+            hir::ItemForeignMod(ref fm) => {\n+                // If inlining we only want to include public functions.\n+                om.foreigns.push(if self.inlining {\n+                    hir::ForeignMod {\n+                        abi: fm.abi,\n+                        items: fm.items.iter().filter(|i| i.vis == hir::Public).cloned().collect(),\n+                    }\n+                } else {\n+                    fm.clone()\n+                });\n+            }\n+            // If we're inlining, skip private items.\n+            _ if self.inlining && item.vis != hir::Public => {}\n             hir::ItemExternCrate(ref p) => {\n                 let cstore = &self.cx.sess().cstore;\n                 om.extern_crates.push(ExternCrate {\n@@ -379,7 +399,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             }\n             hir::ItemUse(ref vpath) => {\n                 let node = vpath.node.clone();\n-                let node = if item.vis == hir::Public {\n+                // If there was a private module in the current path then don't bother inlining\n+                // anything as it will probably be stripped anyway.\n+                let node = if item.vis == hir::Public && self.inside_public_path {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n                             Some(list) if item.check_name(\"doc\") => {\n@@ -479,43 +501,41 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.traits.push(t);\n             },\n+\n             hir::ItemImpl(unsafety, polarity, ref gen, ref tr, ref ty, ref items) => {\n-                let i = Impl {\n-                    unsafety: unsafety,\n-                    polarity: polarity,\n-                    generics: gen.clone(),\n-                    trait_: tr.clone(),\n-                    for_: ty.clone(),\n-                    items: items.clone(),\n-                    attrs: item.attrs.clone(),\n-                    id: item.id,\n-                    whence: item.span,\n-                    vis: item.vis.clone(),\n-                    stab: self.stability(item.id),\n-                    depr: self.deprecation(item.id),\n-                };\n-                // Don't duplicate impls when inlining glob imports, we'll pick\n-                // them up regardless of where they're located.\n-                if !self.inlining_from_glob {\n+                // Don't duplicate impls when inlining, we'll pick them up\n+                // regardless of where they're located.\n+                if !self.inlining {\n+                    let i = Impl {\n+                        unsafety: unsafety,\n+                        polarity: polarity,\n+                        generics: gen.clone(),\n+                        trait_: tr.clone(),\n+                        for_: ty.clone(),\n+                        items: items.clone(),\n+                        attrs: item.attrs.clone(),\n+                        id: item.id,\n+                        whence: item.span,\n+                        vis: item.vis.clone(),\n+                        stab: self.stability(item.id),\n+                        depr: self.deprecation(item.id),\n+                    };\n                     om.impls.push(i);\n                 }\n             },\n             hir::ItemDefaultImpl(unsafety, ref trait_ref) => {\n-                let i = DefaultImpl {\n-                    unsafety: unsafety,\n-                    trait_: trait_ref.clone(),\n-                    id: item.id,\n-                    attrs: item.attrs.clone(),\n-                    whence: item.span,\n-                };\n-                // see comment above about ItemImpl\n-                if !self.inlining_from_glob {\n+                // See comment above about ItemImpl.\n+                if !self.inlining {\n+                    let i = DefaultImpl {\n+                        unsafety: unsafety,\n+                        trait_: trait_ref.clone(),\n+                        id: item.id,\n+                        attrs: item.attrs.clone(),\n+                        whence: item.span,\n+                    };\n                     om.def_traits.push(i);\n                 }\n             }\n-            hir::ItemForeignMod(ref fm) => {\n-                om.foreigns.push(fm.clone());\n-            }\n         }\n     }\n "}, {"sha": "fd2fdd7b8d32936e43e3b326cc74ee6733102eba", "filename": "src/test/rustdoc/inline_local/glob-extern-no-defaults.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d88d06448e1ad928d22cf0a511f1edae91b646d5/src%2Ftest%2Frustdoc%2Finline_local%2Fglob-extern-no-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d88d06448e1ad928d22cf0a511f1edae91b646d5/src%2Ftest%2Frustdoc%2Finline_local%2Fglob-extern-no-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_local%2Fglob-extern-no-defaults.rs?ref=d88d06448e1ad928d22cf0a511f1edae91b646d5", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --no-defaults\n+\n+#![crate_name = \"foo\"]\n+\n+mod mod1 {\n+    extern {\n+        pub fn public_fn();\n+        fn private_fn();\n+    }\n+}\n+\n+pub use mod1::*;\n+\n+// @has foo/index.html\n+// @has - \"mod1\"\n+// @has - \"public_fn\"\n+// @!has - \"private_fn\"\n+// @has foo/fn.public_fn.html\n+// @!has foo/fn.private_fn.html\n+\n+// @has foo/mod1/index.html\n+// @has - \"public_fn\"\n+// @has - \"private_fn\"\n+// @has foo/mod1/fn.public_fn.html\n+// @has foo/mod1/fn.private_fn.html"}, {"sha": "cf899d7728c9dacb9c8fc40bc289ec9c8b434df0", "filename": "src/test/rustdoc/inline_local/glob-extern.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d88d06448e1ad928d22cf0a511f1edae91b646d5/src%2Ftest%2Frustdoc%2Finline_local%2Fglob-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d88d06448e1ad928d22cf0a511f1edae91b646d5/src%2Ftest%2Frustdoc%2Finline_local%2Fglob-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_local%2Fglob-extern.rs?ref=d88d06448e1ad928d22cf0a511f1edae91b646d5", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+mod mod1 {\n+    extern {\n+        pub fn public_fn();\n+        fn private_fn();\n+    }\n+}\n+\n+pub use mod1::*;\n+\n+// @has foo/index.html\n+// @!has - \"mod1\"\n+// @has - \"public_fn\"\n+// @!has - \"private_fn\"\n+// @has foo/fn.public_fn.html\n+// @!has foo/fn.private_fn.html\n+\n+// @!has foo/mod1/index.html\n+// @has foo/mod1/fn.public_fn.html\n+// @!has foo/mod1/fn.private_fn.html"}, {"sha": "420b60f2aca9fa85c8e567e5f518ec4e86d20e8a", "filename": "src/test/rustdoc/inline_local/glob-private-no-defaults.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d88d06448e1ad928d22cf0a511f1edae91b646d5/src%2Ftest%2Frustdoc%2Finline_local%2Fglob-private-no-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d88d06448e1ad928d22cf0a511f1edae91b646d5/src%2Ftest%2Frustdoc%2Finline_local%2Fglob-private-no-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_local%2Fglob-private-no-defaults.rs?ref=d88d06448e1ad928d22cf0a511f1edae91b646d5", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --no-defaults\n+\n+#![crate_name = \"foo\"]\n+\n+mod mod1 {\n+    mod mod2 {\n+        pub struct Mod2Public;\n+        struct Mod2Private;\n+    }\n+    pub use self::mod2::*;\n+\n+    pub struct Mod1Public;\n+    struct Mod1Private;\n+}\n+pub use mod1::*;\n+\n+// @has foo/index.html\n+// @has - \"mod1\"\n+// @has - \"Mod1Public\"\n+// @!has - \"Mod1Private\"\n+// @!has - \"mod2\"\n+// @has - \"Mod2Public\"\n+// @!has - \"Mod2Private\"\n+// @has foo/struct.Mod1Public.html\n+// @!has foo/struct.Mod1Private.html\n+// @has foo/struct.Mod2Public.html\n+// @!has foo/struct.Mod2Private.html\n+\n+// @has foo/mod1/index.html\n+// @has - \"mod2\"\n+// @has - \"Mod1Public\"\n+// @has - \"Mod1Private\"\n+// @!has - \"Mod2Public\"\n+// @!has - \"Mod2Private\"\n+// @has foo/mod1/struct.Mod1Public.html\n+// @has foo/mod1/struct.Mod1Private.html\n+// @!has foo/mod1/struct.Mod2Public.html\n+// @!has foo/mod1/struct.Mod2Private.html\n+\n+// @has foo/mod1/mod2/index.html\n+// @has - \"Mod2Public\"\n+// @has - \"Mod2Private\"\n+// @has foo/mod1/mod2/struct.Mod2Public.html\n+// @has foo/mod1/mod2/struct.Mod2Private.html\n+\n+// @!has foo/mod2/index.html\n+// @!has foo/mod2/struct.Mod2Public.html\n+// @!has foo/mod2/struct.Mod2Private.html"}, {"sha": "b5e256dfdce9495f19f41cad797bc0fcfc8a5d30", "filename": "src/test/rustdoc/inline_local/glob-private.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d88d06448e1ad928d22cf0a511f1edae91b646d5/src%2Ftest%2Frustdoc%2Finline_local%2Fglob-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d88d06448e1ad928d22cf0a511f1edae91b646d5/src%2Ftest%2Frustdoc%2Finline_local%2Fglob-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_local%2Fglob-private.rs?ref=d88d06448e1ad928d22cf0a511f1edae91b646d5", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+mod mod1 {\n+    mod mod2 {\n+        pub struct Mod2Public;\n+        struct Mod2Private;\n+    }\n+    pub use self::mod2::*;\n+\n+    pub struct Mod1Public;\n+    struct Mod1Private;\n+}\n+pub use mod1::*;\n+\n+// @has foo/index.html\n+// @!has - \"mod1\"\n+// @has - \"Mod1Public\"\n+// @!has - \"Mod1Private\"\n+// @!has - \"mod2\"\n+// @has - \"Mod2Public\"\n+// @!has - \"Mod2Private\"\n+// @has foo/struct.Mod1Public.html\n+// @!has foo/struct.Mod1Private.html\n+// @has foo/struct.Mod2Public.html\n+// @!has foo/struct.Mod2Private.html\n+\n+// @!has foo/mod1/index.html\n+// @has foo/mod1/struct.Mod1Public.html\n+// @!has foo/mod1/struct.Mod1Private.html\n+// @!has foo/mod1/struct.Mod2Public.html\n+// @!has foo/mod1/struct.Mod2Private.html\n+\n+// @!has foo/mod1/mod2/index.html\n+// @has foo/mod1/mod2/struct.Mod2Public.html\n+// @!has foo/mod1/mod2/struct.Mod2Private.html\n+\n+// @!has foo/mod2/index.html\n+// @!has foo/mod2/struct.Mod2Public.html\n+// @!has foo/mod2/struct.Mod2Private.html"}]}