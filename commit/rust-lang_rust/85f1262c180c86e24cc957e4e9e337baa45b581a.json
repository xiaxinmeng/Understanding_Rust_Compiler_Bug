{"sha": "85f1262c180c86e24cc957e4e9e337baa45b581a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZjEyNjJjMTgwYzg2ZTI0Y2M5NTdlNGU5ZTMzN2JhYTQ1YjU4MWE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2014-11-09T22:59:56Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2014-11-09T23:12:59Z"}, "message": "Use FnvHashMap instead of HashMap in rustc", "tree": {"sha": "5daf88c8beebfdb67d387d1b5909034a237aebf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5daf88c8beebfdb67d387d1b5909034a237aebf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85f1262c180c86e24cc957e4e9e337baa45b581a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85f1262c180c86e24cc957e4e9e337baa45b581a", "html_url": "https://github.com/rust-lang/rust/commit/85f1262c180c86e24cc957e4e9e337baa45b581a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85f1262c180c86e24cc957e4e9e337baa45b581a/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efc9a441b9f48912166b0ce375efe677edc0e93a", "url": "https://api.github.com/repos/rust-lang/rust/commits/efc9a441b9f48912166b0ce375efe677edc0e93a", "html_url": "https://github.com/rust-lang/rust/commit/efc9a441b9f48912166b0ce375efe677edc0e93a"}], "stats": {"total": 539, "additions": 250, "deletions": 289}, "files": [{"sha": "3026e047626a8ae87cdd8a615ede82853a3970aa", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -32,11 +32,10 @@ use middle::typeck::infer;\n use middle::{typeck, ty, def, pat_util, stability};\n use middle::const_eval::{eval_const_expr_partial, const_int, const_uint};\n use util::ppaux::{ty_to_string};\n-use util::nodemap::NodeSet;\n+use util::nodemap::{FnvHashMap, NodeSet};\n use lint::{Context, LintPass, LintArray};\n \n use std::cmp;\n-use std::collections::HashMap;\n use std::collections::hash_map::{Occupied, Vacant};\n use std::slice;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n@@ -1284,7 +1283,7 @@ impl UnusedMut {\n         // collect all mutable pattern and group their NodeIDs by their Identifier to\n         // avoid false warnings in match arms with multiple patterns\n \n-        let mut mutables = HashMap::new();\n+        let mut mutables = FnvHashMap::new();\n         for p in pats.iter() {\n             pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n                 let ident = path1.node;"}, {"sha": "7f8b779dac1a428cad92b779a4b5f0f93425f7fd", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -34,8 +34,8 @@ use driver::early_error;\n use lint::{Level, LevelSource, Lint, LintId, LintArray, LintPass, LintPassObject};\n use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n use lint::builtin;\n+use util::nodemap::FnvHashMap;\n \n-use std::collections::HashMap;\n use std::rc::Rc;\n use std::cell::RefCell;\n use std::tuple::Tuple2;\n@@ -63,14 +63,14 @@ pub struct LintStore {\n     passes: Option<Vec<LintPassObject>>,\n \n     /// Lints indexed by name.\n-    by_name: HashMap<String, TargetLint>,\n+    by_name: FnvHashMap<String, TargetLint>,\n \n     /// Current levels of each lint, and where they were set.\n-    levels: HashMap<LintId, LevelSource>,\n+    levels: FnvHashMap<LintId, LevelSource>,\n \n     /// Map of registered lint groups to what lints they expand to. The bool\n     /// is true if the lint group was added by a plugin.\n-    lint_groups: HashMap<&'static str, (Vec<LintId>, bool)>,\n+    lint_groups: FnvHashMap<&'static str, (Vec<LintId>, bool)>,\n }\n \n /// The targed of the `by_name` map, which accounts for renaming/deprecation.\n@@ -102,9 +102,9 @@ impl LintStore {\n         LintStore {\n             lints: vec!(),\n             passes: Some(vec!()),\n-            by_name: HashMap::new(),\n-            levels: HashMap::new(),\n-            lint_groups: HashMap::new(),\n+            by_name: FnvHashMap::new(),\n+            levels: FnvHashMap::new(),\n+            lint_groups: FnvHashMap::new(),\n         }\n     }\n \n@@ -279,7 +279,8 @@ impl LintStore {\n                 Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.ref0().clone()))\n-                                                 .collect::<HashMap<&'static str, Vec<LintId>>>()\n+                                                 .collect::<FnvHashMap<&'static str,\n+                                                                       Vec<LintId>>>()\n                                                  .find_equiv(lint_name.as_slice()) {\n                         Some(v) => {\n                             v.iter()\n@@ -317,7 +318,7 @@ pub struct Context<'a, 'tcx: 'a> {\n \n     /// Level of lints for certain NodeIds, stored here because the body of\n     /// the lint needs to run in trans.\n-    node_levels: RefCell<HashMap<(ast::NodeId, LintId), LevelSource>>,\n+    node_levels: RefCell<FnvHashMap<(ast::NodeId, LintId), LevelSource>>,\n }\n \n /// Convenience macro for calling a `LintPass` method on every pass in the context.\n@@ -425,7 +426,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n             exported_items: exported_items,\n             lints: lint_store,\n             level_stack: vec![],\n-            node_levels: RefCell::new(HashMap::new()),\n+            node_levels: RefCell::new(FnvHashMap::new()),\n         }\n     }\n "}, {"sha": "dbf0e4054085c68be26cca75433fd370ce360f34", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -21,9 +21,9 @@ use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n use plugin::load::PluginMetadata;\n+use util::nodemap::FnvHashMap;\n \n use std::rc::Rc;\n-use std::collections::HashMap;\n use std::collections::hash_map::{Occupied, Vacant};\n use syntax::ast;\n use syntax::abi;\n@@ -85,7 +85,7 @@ fn dump_crates(cstore: &CStore) {\n }\n \n fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n-    let mut map = HashMap::new();\n+    let mut map = FnvHashMap::new();\n     cstore.iter_crate_data(|cnum, data| {\n         match map.entry(data.name()) {\n             Vacant(entry) => { entry.set(vec![cnum]); },"}, {"sha": "f2c84bdabfc4a9b71106e5a792b79905325c5549", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -16,11 +16,11 @@\n use back::svh::Svh;\n use metadata::decoder;\n use metadata::loader;\n+use util::nodemap::{FnvHashMap, NodeMap};\n \n use std::cell::RefCell;\n use std::c_vec::CVec;\n use std::rc::Rc;\n-use std::collections::HashMap;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::IdentInterner;\n@@ -29,7 +29,7 @@ use syntax::parse::token::IdentInterner;\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type cnum_map = HashMap<ast::CrateNum, ast::CrateNum>;\n+pub type cnum_map = FnvHashMap<ast::CrateNum, ast::CrateNum>;\n \n pub enum MetadataBlob {\n     MetadataVec(CVec<u8>),\n@@ -67,22 +67,20 @@ pub struct CrateSource {\n }\n \n pub struct CStore {\n-    metas: RefCell<HashMap<ast::CrateNum, Rc<crate_metadata>>>,\n-    extern_mod_crate_map: RefCell<extern_mod_crate_map>,\n+    metas: RefCell<FnvHashMap<ast::CrateNum, Rc<crate_metadata>>>,\n+    /// Map from NodeId's of local extern crate statements to crate numbers\n+    extern_mod_crate_map: RefCell<NodeMap<ast::CrateNum>>,\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n     used_libraries: RefCell<Vec<(String, NativeLibaryKind)>>,\n     used_link_args: RefCell<Vec<String>>,\n     pub intr: Rc<IdentInterner>,\n }\n \n-// Map from NodeId's of local extern crate statements to crate numbers\n-type extern_mod_crate_map = HashMap<ast::NodeId, ast::CrateNum>;\n-\n impl CStore {\n     pub fn new(intr: Rc<IdentInterner>) -> CStore {\n         CStore {\n-            metas: RefCell::new(HashMap::new()),\n-            extern_mod_crate_map: RefCell::new(HashMap::new()),\n+            metas: RefCell::new(FnvHashMap::new()),\n+            extern_mod_crate_map: RefCell::new(FnvHashMap::new()),\n             used_crate_sources: RefCell::new(Vec::new()),\n             used_libraries: RefCell::new(Vec::new()),\n             used_link_args: RefCell::new(Vec::new()),"}, {"sha": "251b7c0c141772a74491f2f61bda414f2213e092", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -23,13 +23,12 @@ use middle::ty::{lookup_item_type};\n use middle::ty;\n use middle::stability;\n use middle;\n-use util::nodemap::{NodeMap, NodeSet};\n+use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use serialize::Encodable;\n use std::cell::RefCell;\n use std::hash::Hash;\n use std::hash;\n-use std::collections::HashMap;\n use syntax::abi;\n use syntax::ast::*;\n use syntax::ast;\n@@ -2062,7 +2061,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate:\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: RefCell::new(encode_inlined_item),\n-        type_abbrevs: RefCell::new(HashMap::new()),\n+        type_abbrevs: RefCell::new(FnvHashMap::new()),\n         reachable: reachable,\n      };\n \n@@ -2167,7 +2166,7 @@ pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> String {\n         diag: tcx.sess.diagnostic(),\n         ds: def_to_string,\n         tcx: tcx,\n-        abbrevs: &RefCell::new(HashMap::new())\n+        abbrevs: &RefCell::new(FnvHashMap::new())\n     }, t);\n     String::from_utf8(wr.unwrap()).unwrap()\n }"}, {"sha": "56e44b69a5f1d1413db6fbce3e51450af5e88e7a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -14,12 +14,12 @@\n #![allow(non_camel_case_types)]\n \n use std::cell::RefCell;\n-use std::collections::HashMap;\n \n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::ParamTy;\n use middle::ty;\n+use util::nodemap::FnvHashMap;\n \n use syntax::abi::Abi;\n use syntax::ast;\n@@ -47,7 +47,7 @@ pub struct ty_abbrev {\n     s: String\n }\n \n-pub type abbrev_map = RefCell<HashMap<ty::t, ty_abbrev>>;\n+pub type abbrev_map = RefCell<FnvHashMap<ty::t, ty_abbrev>>;\n \n pub fn enc_ty(w: &mut SeekableMemWriter, cx: &ctxt, t: ty::t) {\n     match cx.abbrevs.borrow_mut().get(&t) {"}, {"sha": "0ca53054f1c154ad0e14482cefa1fbcdf9929af9", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -1161,7 +1161,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &ty in tcx.node_types.borrow().get(&(id as uint)).iter() {\n+    for &ty in tcx.node_types.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_node_type, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1825,7 +1825,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let ty = val_dsr.read_ty(dcx);\n                         debug!(\"inserting ty for node {}: {}\",\n                                id, ty_to_string(dcx.tcx, ty));\n-                        dcx.tcx.node_types.borrow_mut().insert(id as uint, ty);\n+                        dcx.tcx.node_types.borrow_mut().insert(id, ty);\n                     }\n                     c::tag_table_item_subst => {\n                         let item_substs = ty::ItemSubsts {"}, {"sha": "becc0dbf6246987208b47afa39b3058f1a754670", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -18,7 +18,6 @@ comments in the section \"Moves and initialization\" and in `doc.rs`.\n use std::cell::RefCell;\n use std::rc::Rc;\n use std::uint;\n-use std::collections::{HashMap, HashSet};\n use middle::borrowck::*;\n use middle::cfg;\n use middle::dataflow::DataFlowContext;\n@@ -30,14 +29,15 @@ use middle::ty;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n+use util::nodemap::{FnvHashMap, NodeSet};\n use util::ppaux::Repr;\n \n pub struct MoveData {\n     /// Move paths. See section \"Move paths\" in `doc.rs`.\n     pub paths: RefCell<Vec<MovePath>>,\n \n     /// Cache of loan path to move path index, for easy lookup.\n-    pub path_map: RefCell<HashMap<Rc<LoanPath>, MovePathIndex>>,\n+    pub path_map: RefCell<FnvHashMap<Rc<LoanPath>, MovePathIndex>>,\n \n     /// Each move or uninitialized variable gets an entry here.\n     pub moves: RefCell<Vec<Move>>,\n@@ -53,7 +53,7 @@ pub struct MoveData {\n     pub path_assignments: RefCell<Vec<Assignment>>,\n \n     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.\n-    pub assignee_ids: RefCell<HashSet<ast::NodeId>>,\n+    pub assignee_ids: RefCell<NodeSet>,\n }\n \n pub struct FlowedMoveData<'a, 'tcx: 'a> {\n@@ -183,11 +183,11 @@ impl MoveData {\n     pub fn new() -> MoveData {\n         MoveData {\n             paths: RefCell::new(Vec::new()),\n-            path_map: RefCell::new(HashMap::new()),\n+            path_map: RefCell::new(FnvHashMap::new()),\n             moves: RefCell::new(Vec::new()),\n             path_assignments: RefCell::new(Vec::new()),\n             var_assignments: RefCell::new(Vec::new()),\n-            assignee_ids: RefCell::new(HashSet::new()),\n+            assignee_ids: RefCell::new(NodeSet::new()),\n         }\n     }\n "}, {"sha": "75e61690685bd64fff3a8f35451c706882fd07f1", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -61,14 +61,14 @@\n //! Additionally, the algorithm is geared towards finding *any* solution rather\n //! than finding a number of solutions (there are normally quite a few).\n \n-use std::collections::HashMap;\n use syntax::ast;\n \n use driver::session;\n use driver::config;\n use metadata::cstore;\n use metadata::csearch;\n use middle::ty;\n+use util::nodemap::FnvHashMap;\n \n /// A list of dependencies for a certain crate type.\n ///\n@@ -81,7 +81,7 @@ pub type DependencyList = Vec<Option<cstore::LinkagePreference>>;\n /// A mapping of all required dependencies for a particular flavor of output.\n ///\n /// This is local to the tcx, and is generally relevant to one session.\n-pub type Dependencies = HashMap<config::CrateType, DependencyList>;\n+pub type Dependencies = FnvHashMap<config::CrateType, DependencyList>;\n \n pub fn calculate(tcx: &ty::ctxt) {\n     let mut fmts = tcx.dependency_formats.borrow_mut();\n@@ -137,7 +137,7 @@ fn calculate_type(sess: &session::Session,\n         config::CrateTypeExecutable | config::CrateTypeDylib => {},\n     }\n \n-    let mut formats = HashMap::new();\n+    let mut formats = FnvHashMap::new();\n \n     // Sweep all crates for found dylibs. Add all dylibs, as well as their\n     // dependencies, ensuring there are no conflicts. The only valid case for a\n@@ -208,7 +208,7 @@ fn calculate_type(sess: &session::Session,\n fn add_library(sess: &session::Session,\n                cnum: ast::CrateNum,\n                link: cstore::LinkagePreference,\n-               m: &mut HashMap<ast::CrateNum, cstore::LinkagePreference>) {\n+               m: &mut FnvHashMap<ast::CrateNum, cstore::LinkagePreference>) {\n     match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library"}, {"sha": "c575d2fc4bf13a6bd5bb3763d97102a5522369ba", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -24,6 +24,8 @@ use driver::session::Session;\n use metadata::csearch::each_lang_item;\n use middle::ty;\n use middle::weak_lang_items;\n+use util::nodemap::FnvHashMap;\n+\n use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n@@ -32,7 +34,6 @@ use syntax::parse::token::InternedString;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-use std::collections::HashMap;\n use std::iter::Enumerate;\n use std::slice;\n \n@@ -123,7 +124,7 @@ struct LanguageItemCollector<'a> {\n \n     session: &'a Session,\n \n-    item_refs: HashMap<&'static str, uint>,\n+    item_refs: FnvHashMap<&'static str, uint>,\n }\n \n impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n@@ -148,7 +149,7 @@ impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n \n impl<'a> LanguageItemCollector<'a> {\n     pub fn new(session: &'a Session) -> LanguageItemCollector<'a> {\n-        let mut item_refs = HashMap::new();\n+        let mut item_refs = FnvHashMap::new();\n \n         $( item_refs.insert($name, $variant as uint); )*\n "}, {"sha": "bf524c85ed5263664ebb58f277ae4a6b4221e95e", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -11,18 +11,18 @@\n use middle::def::*;\n use middle::resolve;\n use middle::ty;\n+use util::nodemap::FnvHashMap;\n \n-use std::collections::HashMap;\n use syntax::ast::*;\n use syntax::ast_util::{walk_pat};\n use syntax::codemap::{Span, DUMMY_SP};\n \n-pub type PatIdMap = HashMap<Ident, NodeId>;\n+pub type PatIdMap = FnvHashMap<Ident, NodeId>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n pub fn pat_id_map(dm: &resolve::DefMap, pat: &Pat) -> PatIdMap {\n-    let mut map = HashMap::new();\n+    let mut map = FnvHashMap::new();\n     pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n         map.insert(path1.node, p_id);\n     });"}, {"sha": "2cc8f20b562f3191aeca1e9e16ebc732d9e41169", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -24,11 +24,10 @@ Most of the documentation on regions can be found in\n use driver::session::Session;\n use middle::ty::{FreeRegion};\n use middle::ty;\n-use util::nodemap::NodeMap;\n+use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n use util::common::can_reach;\n \n use std::cell::RefCell;\n-use std::collections::{HashMap, HashSet};\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n@@ -79,9 +78,9 @@ The region maps encode information about region relationships.\n pub struct RegionMaps {\n     scope_map: RefCell<NodeMap<ast::NodeId>>,\n     var_map: RefCell<NodeMap<ast::NodeId>>,\n-    free_region_map: RefCell<HashMap<FreeRegion, Vec<FreeRegion>>>,\n+    free_region_map: RefCell<FnvHashMap<FreeRegion, Vec<FreeRegion>>>,\n     rvalue_scopes: RefCell<NodeMap<ast::NodeId>>,\n-    terminating_scopes: RefCell<HashSet<ast::NodeId>>,\n+    terminating_scopes: RefCell<NodeSet>,\n }\n \n pub struct Context {\n@@ -876,9 +875,9 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n     let maps = RegionMaps {\n         scope_map: RefCell::new(NodeMap::new()),\n         var_map: RefCell::new(NodeMap::new()),\n-        free_region_map: RefCell::new(HashMap::new()),\n+        free_region_map: RefCell::new(FnvHashMap::new()),\n         rvalue_scopes: RefCell::new(NodeMap::new()),\n-        terminating_scopes: RefCell::new(HashSet::new()),\n+        terminating_scopes: RefCell::new(NodeSet::new()),\n     };\n     {\n         let mut visitor = RegionResolutionVisitor {\n@@ -901,4 +900,3 @@ pub fn resolve_inlined_item(sess: &Session,\n     };\n     visit::walk_inlined_item(&mut visitor, item);\n }\n-"}, {"sha": "59fbcde85e883087fe7643ef211bfcdb9b942923", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -261,7 +261,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             let span_utils = self.span;\n             for &(id, ref p, _, _) in self.collected_paths.iter() {\n                 let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                    (*self.analysis.ty_cx.node_types.borrow())[id as uint]);\n+                    (*self.analysis.ty_cx.node_types.borrow())[id]);\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n@@ -427,7 +427,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 let name = get_ident(ident);\n                 let qualname = format!(\"{}::{}\", qualname, name);\n                 let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                    (*self.analysis.ty_cx.node_types.borrow())[field.node.id as uint]);\n+                    (*self.analysis.ty_cx.node_types.borrow())[field.node.id]);\n                 match self.span.sub_span_before_token(field.span, token::Colon) {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n@@ -1447,7 +1447,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         for &(id, ref p, ref immut, _) in self.collected_paths.iter() {\n             let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n             let types = self.analysis.ty_cx.node_types.borrow();\n-            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, (*types)[id as uint]);\n+            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, (*types)[id]);\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);"}, {"sha": "7b0ebe631e0e16331d82feb369fa09853c188d27", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -214,10 +214,10 @@ use middle::trans::type_of;\n use middle::trans::debuginfo;\n use middle::ty;\n use util::common::indenter;\n+use util::nodemap::FnvHashMap;\n use util::ppaux::{Repr, vec_map_to_string};\n \n use std;\n-use std::collections::HashMap;\n use std::iter::AdditiveIterator;\n use std::rc::Rc;\n use syntax::ast;\n@@ -336,7 +336,7 @@ pub struct BindingInfo {\n     pub ty: ty::t,\n }\n \n-type BindingsMap = HashMap<Ident, BindingInfo>;\n+type BindingsMap = FnvHashMap<Ident, BindingInfo>;\n \n struct ArmData<'p, 'blk, 'tcx: 'blk> {\n     bodycx: Block<'blk, 'tcx>,\n@@ -1291,7 +1291,7 @@ fn create_bindings_map(bcx: Block, pat: &ast::Pat,\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n     let reassigned = is_discr_reassigned(bcx, discr, body);\n-    let mut bindings_map = HashMap::new();\n+    let mut bindings_map = FnvHashMap::new();\n     pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n         let ident = path1.node;\n         let variable_ty = node_id_type(bcx, p_id);"}, {"sha": "3fd0a29015392373a218eac166971632a4f1288e", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -18,7 +18,7 @@ use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::machine::llalign_of_pref;\n use middle::trans::type_::Type;\n-use std::collections::HashMap;\n+use util::nodemap::FnvHashMap;\n use libc::{c_uint, c_char};\n use std::string::String;\n use syntax::codemap::Span;\n@@ -58,7 +58,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Build version of path with cycles removed.\n \n                 // Pass 1: scan table mapping str -> rightmost pos.\n-                let mut mm = HashMap::new();\n+                let mut mm = FnvHashMap::new();\n                 let len = v.len();\n                 let mut i = 0u;\n                 while i < len {"}, {"sha": "c0380f87036b6359a22492ea91e2cd01a29fad0d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -36,10 +36,9 @@ use middle::ty_fold::TypeFoldable;\n use middle::typeck;\n use middle::typeck::infer;\n use util::ppaux::Repr;\n-use util::nodemap::{DefIdMap, NodeMap};\n+use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use arena::TypedArena;\n-use std::collections::HashMap;\n use libc::{c_uint, c_char};\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n@@ -185,7 +184,7 @@ pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n-pub type ExternMap = HashMap<String, ValueRef>;\n+pub type ExternMap = FnvHashMap<String, ValueRef>;\n \n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods."}, {"sha": "b659da75222d40b8025711453b5852b0475def19", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 59, "deletions": 60, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -27,13 +27,12 @@ use middle::trans::type_::{Type, TypeNames};\n use middle::ty;\n use util::ppaux::Repr;\n use util::sha2::Sha256;\n-use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n+use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n use std::cell::{Cell, RefCell};\n use std::c_str::ToCStr;\n use std::ptr;\n use std::rc::Rc;\n-use std::collections::{HashMap, HashSet};\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n@@ -47,7 +46,7 @@ pub struct Stats {\n     pub n_inlines: Cell<uint>,\n     pub n_closures: Cell<uint>,\n     pub n_llvm_insns: Cell<uint>,\n-    pub llvm_insns: RefCell<HashMap<String, uint>>,\n+    pub llvm_insns: RefCell<FnvHashMap<String, uint>>,\n     // (ident, time-in-ms, llvm-instructions)\n     pub fn_stats: RefCell<Vec<(String, uint, uint)> >,\n }\n@@ -70,8 +69,8 @@ pub struct SharedCrateContext<'tcx> {\n     tcx: ty::ctxt<'tcx>,\n     stats: Stats,\n \n-    available_monomorphizations: RefCell<HashSet<String>>,\n-    available_drop_glues: RefCell<HashMap<ty::t, String>>,\n+    available_monomorphizations: RefCell<FnvHashSet<String>>,\n+    available_drop_glues: RefCell<FnvHashMap<ty::t, String>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -85,8 +84,8 @@ pub struct LocalCrateContext {\n     tn: TypeNames,\n     externs: RefCell<ExternMap>,\n     item_vals: RefCell<NodeMap<ValueRef>>,\n-    drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n-    tydescs: RefCell<HashMap<ty::t, Rc<tydesc_info>>>,\n+    drop_glues: RefCell<FnvHashMap<ty::t, ValueRef>>,\n+    tydescs: RefCell<FnvHashMap<ty::t, Rc<tydesc_info>>>,\n     /// Set when running emit_tydescs to enforce that no more tydescs are\n     /// created.\n     finished_tydescs: Cell<bool>,\n@@ -96,12 +95,12 @@ pub struct LocalCrateContext {\n     /// came from)\n     external_srcs: RefCell<NodeMap<ast::DefId>>,\n     /// Cache instances of monomorphized functions\n-    monomorphized: RefCell<HashMap<MonoId, ValueRef>>,\n+    monomorphized: RefCell<FnvHashMap<MonoId, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    vtables: RefCell<HashMap<(ty::t,Rc<ty::TraitRef>), ValueRef>>,\n+    vtables: RefCell<FnvHashMap<(ty::t,Rc<ty::TraitRef>), ValueRef>>,\n     /// Cache of constant strings,\n-    const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n+    const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n     /// Key is an int, cast from a ValueRef holding a *T,\n@@ -111,7 +110,7 @@ pub struct LocalCrateContext {\n     /// when we ptrcast, and we have to ptrcast during translation\n     /// of a [T] const because we form a slice, a [*T,int] pair, not\n     /// a pointer to an LLVM array type.\n-    const_globals: RefCell<HashMap<int, ValueRef>>,\n+    const_globals: RefCell<FnvHashMap<int, ValueRef>>,\n \n     /// Cache of emitted const values\n     const_values: RefCell<NodeMap<ValueRef>>,\n@@ -122,36 +121,36 @@ pub struct LocalCrateContext {\n     /// Cache of external const values\n     extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n-    impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n+    impl_method_cache: RefCell<FnvHashMap<(ast::DefId, ast::Name), ast::DefId>>,\n \n     /// Cache of closure wrappers for bare fn's.\n-    closure_bare_wrapper_cache: RefCell<HashMap<ValueRef, ValueRef>>,\n+    closure_bare_wrapper_cache: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n \n-    lltypes: RefCell<HashMap<ty::t, Type>>,\n-    llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n-    adt_reprs: RefCell<HashMap<ty::t, Rc<adt::Repr>>>,\n-    type_hashcodes: RefCell<HashMap<ty::t, String>>,\n-    all_llvm_symbols: RefCell<HashSet<String>>,\n+    lltypes: RefCell<FnvHashMap<ty::t, Type>>,\n+    llsizingtypes: RefCell<FnvHashMap<ty::t, Type>>,\n+    adt_reprs: RefCell<FnvHashMap<ty::t, Rc<adt::Repr>>>,\n+    type_hashcodes: RefCell<FnvHashMap<ty::t, String>>,\n+    all_llvm_symbols: RefCell<FnvHashSet<String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n     builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    unboxed_closure_vals: RefCell<HashMap<MonoId, ValueRef>>,\n+    unboxed_closure_vals: RefCell<FnvHashMap<MonoId, ValueRef>>,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext>,\n \n     eh_personality: RefCell<Option<ValueRef>>,\n \n-    intrinsics: RefCell<HashMap<&'static str, ValueRef>>,\n+    intrinsics: RefCell<FnvHashMap<&'static str, ValueRef>>,\n \n     /// Number of LLVM instructions translated into this `LocalCrateContext`.\n     /// This is used to perform some basic load-balancing to keep all LLVM\n     /// contexts around the same size.\n     n_llvm_insns: Cell<uint>,\n \n-    trait_cache: RefCell<HashMap<Rc<ty::TraitRef>,\n-                                 traits::Vtable<()>>>,\n+    trait_cache: RefCell<FnvHashMap<Rc<ty::TraitRef>,\n+                                    traits::Vtable<()>>>,\n }\n \n pub struct CrateContext<'a, 'tcx: 'a> {\n@@ -269,11 +268,11 @@ impl<'tcx> SharedCrateContext<'tcx> {\n                 n_inlines: Cell::new(0u),\n                 n_closures: Cell::new(0u),\n                 n_llvm_insns: Cell::new(0u),\n-                llvm_insns: RefCell::new(HashMap::new()),\n+                llvm_insns: RefCell::new(FnvHashMap::new()),\n                 fn_stats: RefCell::new(Vec::new()),\n             },\n-            available_monomorphizations: RefCell::new(HashSet::new()),\n-            available_drop_glues: RefCell::new(HashMap::new()),\n+            available_monomorphizations: RefCell::new(FnvHashSet::new()),\n+            available_drop_glues: RefCell::new(FnvHashMap::new()),\n         };\n \n         for i in range(0, local_count) {\n@@ -393,37 +392,37 @@ impl LocalCrateContext {\n                 llcx: llcx,\n                 td: td,\n                 tn: TypeNames::new(),\n-                externs: RefCell::new(HashMap::new()),\n+                externs: RefCell::new(FnvHashMap::new()),\n                 item_vals: RefCell::new(NodeMap::new()),\n-                drop_glues: RefCell::new(HashMap::new()),\n-                tydescs: RefCell::new(HashMap::new()),\n+                drop_glues: RefCell::new(FnvHashMap::new()),\n+                tydescs: RefCell::new(FnvHashMap::new()),\n                 finished_tydescs: Cell::new(false),\n                 external: RefCell::new(DefIdMap::new()),\n                 external_srcs: RefCell::new(NodeMap::new()),\n-                monomorphized: RefCell::new(HashMap::new()),\n+                monomorphized: RefCell::new(FnvHashMap::new()),\n                 monomorphizing: RefCell::new(DefIdMap::new()),\n-                vtables: RefCell::new(HashMap::new()),\n-                const_cstr_cache: RefCell::new(HashMap::new()),\n-                const_globals: RefCell::new(HashMap::new()),\n+                vtables: RefCell::new(FnvHashMap::new()),\n+                const_cstr_cache: RefCell::new(FnvHashMap::new()),\n+                const_globals: RefCell::new(FnvHashMap::new()),\n                 const_values: RefCell::new(NodeMap::new()),\n                 static_values: RefCell::new(NodeMap::new()),\n                 extern_const_values: RefCell::new(DefIdMap::new()),\n-                impl_method_cache: RefCell::new(HashMap::new()),\n-                closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n-                lltypes: RefCell::new(HashMap::new()),\n-                llsizingtypes: RefCell::new(HashMap::new()),\n-                adt_reprs: RefCell::new(HashMap::new()),\n-                type_hashcodes: RefCell::new(HashMap::new()),\n-                all_llvm_symbols: RefCell::new(HashSet::new()),\n+                impl_method_cache: RefCell::new(FnvHashMap::new()),\n+                closure_bare_wrapper_cache: RefCell::new(FnvHashMap::new()),\n+                lltypes: RefCell::new(FnvHashMap::new()),\n+                llsizingtypes: RefCell::new(FnvHashMap::new()),\n+                adt_reprs: RefCell::new(FnvHashMap::new()),\n+                type_hashcodes: RefCell::new(FnvHashMap::new()),\n+                all_llvm_symbols: RefCell::new(FnvHashSet::new()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                unboxed_closure_vals: RefCell::new(HashMap::new()),\n+                unboxed_closure_vals: RefCell::new(FnvHashMap::new()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: RefCell::new(None),\n-                intrinsics: RefCell::new(HashMap::new()),\n+                intrinsics: RefCell::new(FnvHashMap::new()),\n                 n_llvm_insns: Cell::new(0u),\n-                trait_cache: RefCell::new(HashMap::new()),\n+                trait_cache: RefCell::new(FnvHashMap::new()),\n             };\n \n             local_ccx.int_type = Type::int(&local_ccx.dummy_ccx(shared));\n@@ -575,11 +574,11 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.link_meta\n     }\n \n-    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, ValueRef>> {\n+    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, ValueRef>> {\n         &self.local.drop_glues\n     }\n \n-    pub fn tydescs<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Rc<tydesc_info>>> {\n+    pub fn tydescs<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, Rc<tydesc_info>>> {\n         &self.local.tydescs\n     }\n \n@@ -595,23 +594,23 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.external_srcs\n     }\n \n-    pub fn monomorphized<'a>(&'a self) -> &'a RefCell<HashMap<MonoId, ValueRef>> {\n+    pub fn monomorphized<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId, ValueRef>> {\n         &self.local.monomorphized\n     }\n \n     pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<uint>> {\n         &self.local.monomorphizing\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<HashMap<(ty::t,Rc<ty::TraitRef>), ValueRef>> {\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(ty::t,Rc<ty::TraitRef>), ValueRef>> {\n         &self.local.vtables\n     }\n \n-    pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<HashMap<InternedString, ValueRef>> {\n+    pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<FnvHashMap<InternedString, ValueRef>> {\n         &self.local.const_cstr_cache\n     }\n \n-    pub fn const_globals<'a>(&'a self) -> &'a RefCell<HashMap<int, ValueRef>> {\n+    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FnvHashMap<int, ValueRef>> {\n         &self.local.const_globals\n     }\n \n@@ -628,47 +627,47 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn impl_method_cache<'a>(&'a self)\n-            -> &'a RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>> {\n+            -> &'a RefCell<FnvHashMap<(ast::DefId, ast::Name), ast::DefId>> {\n         &self.local.impl_method_cache\n     }\n \n-    pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<HashMap<ValueRef, ValueRef>> {\n+    pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n         &self.local.closure_bare_wrapper_cache\n     }\n \n-    pub fn lltypes<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Type>> {\n+    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, Type>> {\n         &self.local.lltypes\n     }\n \n-    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Type>> {\n+    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, Type>> {\n         &self.local.llsizingtypes\n     }\n \n-    pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Rc<adt::Repr>>> {\n+    pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, Rc<adt::Repr>>> {\n         &self.local.adt_reprs\n     }\n \n     pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n         &self.shared.symbol_hasher\n     }\n \n-    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, String>> {\n+    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, String>> {\n         &self.local.type_hashcodes\n     }\n \n-    pub fn all_llvm_symbols<'a>(&'a self) -> &'a RefCell<HashSet<String>> {\n+    pub fn all_llvm_symbols<'a>(&'a self) -> &'a RefCell<FnvHashSet<String>> {\n         &self.local.all_llvm_symbols\n     }\n \n     pub fn stats<'a>(&'a self) -> &'a Stats {\n         &self.shared.stats\n     }\n \n-    pub fn available_monomorphizations<'a>(&'a self) -> &'a RefCell<HashSet<String>> {\n+    pub fn available_monomorphizations<'a>(&'a self) -> &'a RefCell<FnvHashSet<String>> {\n         &self.shared.available_monomorphizations\n     }\n \n-    pub fn available_drop_glues<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, String>> {\n+    pub fn available_drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, String>> {\n         &self.shared.available_drop_glues\n     }\n \n@@ -680,7 +679,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.opaque_vec_type\n     }\n \n-    pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<HashMap<MonoId,ValueRef>> {\n+    pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId,ValueRef>> {\n         &self.local.unboxed_closure_vals\n     }\n \n@@ -692,15 +691,15 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.eh_personality\n     }\n \n-    fn intrinsics<'a>(&'a self) -> &'a RefCell<HashMap<&'static str, ValueRef>> {\n+    fn intrinsics<'a>(&'a self) -> &'a RefCell<FnvHashMap<&'static str, ValueRef>> {\n         &self.local.intrinsics\n     }\n \n     pub fn count_llvm_insn(&self) {\n         self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n     }\n \n-    pub fn trait_cache(&self) -> &RefCell<HashMap<Rc<ty::TraitRef>, traits::Vtable<()>>> {\n+    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<Rc<ty::TraitRef>, traits::Vtable<()>>> {\n         &self.local.trait_cache\n     }\n "}, {"sha": "fb6347af698162dd51b49c42fd55e291086b3134", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -200,13 +200,12 @@ use middle::trans::type_::Type;\n use middle::trans;\n use middle::ty;\n use middle::pat_util;\n+use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n use util::ppaux;\n \n use libc::c_uint;\n use std::c_str::{CString, ToCStr};\n use std::cell::{Cell, RefCell};\n-use std::collections::HashMap;\n-use std::collections::HashSet;\n use std::ptr;\n use std::rc::{Rc, Weak};\n use syntax::util::interner::Interner;\n@@ -258,21 +257,21 @@ struct TypeMap {\n     // The UniqueTypeIds created so far\n     unique_id_interner: Interner<Rc<String>>,\n     // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n-    unique_id_to_metadata: HashMap<UniqueTypeId, DIType>,\n-    // A map from ty::type_id() to debuginfo metadata. This is a N:1 mapping.\n-    type_to_metadata: HashMap<uint, DIType>,\n-    // A map from ty::type_id() to UniqueTypeId. This is a N:1 mapping.\n-    type_to_unique_id: HashMap<uint, UniqueTypeId>\n+    unique_id_to_metadata: FnvHashMap<UniqueTypeId, DIType>,\n+    // A map from types to debuginfo metadata. This is a N:1 mapping.\n+    type_to_metadata: FnvHashMap<ty::t, DIType>,\n+    // A map from types to UniqueTypeId. This is a N:1 mapping.\n+    type_to_unique_id: FnvHashMap<ty::t, UniqueTypeId>\n }\n \n impl TypeMap {\n \n     fn new() -> TypeMap {\n         TypeMap {\n             unique_id_interner: Interner::new(),\n-            type_to_metadata: HashMap::new(),\n-            unique_id_to_metadata: HashMap::new(),\n-            type_to_unique_id: HashMap::new(),\n+            type_to_metadata: FnvHashMap::new(),\n+            unique_id_to_metadata: FnvHashMap::new(),\n+            type_to_unique_id: FnvHashMap::new(),\n         }\n     }\n \n@@ -282,7 +281,7 @@ impl TypeMap {\n                                    cx: &CrateContext,\n                                    type_: ty::t,\n                                    metadata: DIType) {\n-        if self.type_to_metadata.insert(ty::type_id(type_), metadata).is_some() {\n+        if self.type_to_metadata.insert(type_, metadata).is_some() {\n             cx.sess().bug(format!(\"Type metadata for ty::t '{}' is already in the TypeMap!\",\n                                    ppaux::ty_to_string(cx.tcx(), type_)).as_slice());\n         }\n@@ -302,7 +301,7 @@ impl TypeMap {\n     }\n \n     fn find_metadata_for_type(&self, type_: ty::t) -> Option<DIType> {\n-        self.type_to_metadata.find_copy(&ty::type_id(type_))\n+        self.type_to_metadata.find_copy(&type_)\n     }\n \n     fn find_metadata_for_unique_id(&self, unique_type_id: UniqueTypeId) -> Option<DIType> {\n@@ -342,7 +341,7 @@ impl TypeMap {\n         // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n         // gc box               -> {GC_BOX<:pointee-uid:>}\n \n-        match self.type_to_unique_id.find_copy(&ty::type_id(type_)) {\n+        match self.type_to_unique_id.find_copy(&type_) {\n             Some(unique_type_id) => return unique_type_id,\n             None => { /* generate one */}\n         };\n@@ -486,7 +485,7 @@ impl TypeMap {\n         unique_type_id.shrink_to_fit();\n \n         let key = self.unique_id_interner.intern(Rc::new(unique_type_id));\n-        self.type_to_unique_id.insert(ty::type_id(type_), UniqueTypeId(key));\n+        self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n         return UniqueTypeId(key);\n \n@@ -645,15 +644,15 @@ pub struct CrateDebugContext {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n     current_debug_location: Cell<DebugLocation>,\n-    created_files: RefCell<HashMap<String, DIFile>>,\n-    created_enum_disr_types: RefCell<HashMap<ast::DefId, DIType>>,\n+    created_files: RefCell<FnvHashMap<String, DIFile>>,\n+    created_enum_disr_types: RefCell<DefIdMap<DIType>>,\n \n     type_map: RefCell<TypeMap>,\n-    namespace_map: RefCell<HashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n+    namespace_map: RefCell<FnvHashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n \n     // This collection is used to assert that composite types (structs, enums,\n     // ...) have their members only set once:\n-    composite_types_completed: RefCell<HashSet<DIType>>,\n+    composite_types_completed: RefCell<FnvHashSet<DIType>>,\n }\n \n impl CrateDebugContext {\n@@ -666,11 +665,11 @@ impl CrateDebugContext {\n             llcontext: llcontext,\n             builder: builder,\n             current_debug_location: Cell::new(UnknownLocation),\n-            created_files: RefCell::new(HashMap::new()),\n-            created_enum_disr_types: RefCell::new(HashMap::new()),\n+            created_files: RefCell::new(FnvHashMap::new()),\n+            created_enum_disr_types: RefCell::new(DefIdMap::new()),\n             type_map: RefCell::new(TypeMap::new()),\n-            namespace_map: RefCell::new(HashMap::new()),\n-            composite_types_completed: RefCell::new(HashSet::new()),\n+            namespace_map: RefCell::new(FnvHashMap::new()),\n+            composite_types_completed: RefCell::new(FnvHashSet::new()),\n         };\n     }\n }\n@@ -714,7 +713,7 @@ impl FunctionDebugContext {\n }\n \n struct FunctionDebugContextData {\n-    scope_map: RefCell<HashMap<ast::NodeId, DIScope>>,\n+    scope_map: RefCell<NodeMap<DIScope>>,\n     fn_metadata: DISubprogram,\n     argument_counter: Cell<uint>,\n     source_locations_enabled: Cell<bool>,\n@@ -1346,7 +1345,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n     // Initialize fn debug context (including scope map and namespace map)\n     let fn_debug_context = box FunctionDebugContextData {\n-        scope_map: RefCell::new(HashMap::new()),\n+        scope_map: RefCell::new(NodeMap::new()),\n         fn_metadata: fn_metadata,\n         argument_counter: Cell::new(1),\n         source_locations_enabled: Cell::new(false),\n@@ -3122,7 +3121,7 @@ fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n fn assert_type_for_node_id(cx: &CrateContext,\n                            node_id: ast::NodeId,\n                            error_reporting_span: Span) {\n-    if !cx.tcx().node_types.borrow().contains_key(&(node_id as uint)) {\n+    if !cx.tcx().node_types.borrow().contains_key(&node_id) {\n         cx.sess().span_bug(error_reporting_span,\n                            \"debuginfo: Could not find type for node id!\");\n     }\n@@ -3153,7 +3152,7 @@ fn populate_scope_map(cx: &CrateContext,\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n                       fn_ast_id: ast::NodeId,\n-                      scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n+                      scope_map: &mut NodeMap<DIScope>) {\n     let def_map = &cx.tcx().def_map;\n \n     struct ScopeStackEntry {\n@@ -3188,10 +3187,10 @@ fn populate_scope_map(cx: &CrateContext,\n     fn with_new_scope(cx: &CrateContext,\n                       scope_span: Span,\n                       scope_stack: &mut Vec<ScopeStackEntry> ,\n-                      scope_map: &mut HashMap<ast::NodeId, DIScope>,\n+                      scope_map: &mut NodeMap<DIScope>,\n                       inner_walk: |&CrateContext,\n                                    &mut Vec<ScopeStackEntry> ,\n-                                   &mut HashMap<ast::NodeId, DIScope>|) {\n+                                   &mut NodeMap<DIScope>|) {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n         let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n@@ -3226,7 +3225,7 @@ fn populate_scope_map(cx: &CrateContext,\n     fn walk_block(cx: &CrateContext,\n                   block: &ast::Block,\n                   scope_stack: &mut Vec<ScopeStackEntry> ,\n-                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n+                  scope_map: &mut NodeMap<DIScope>) {\n         scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n \n         // The interesting things here are statements and the concluding expression.\n@@ -3252,7 +3251,7 @@ fn populate_scope_map(cx: &CrateContext,\n     fn walk_decl(cx: &CrateContext,\n                  decl: &ast::Decl,\n                  scope_stack: &mut Vec<ScopeStackEntry> ,\n-                 scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n+                 scope_map: &mut NodeMap<DIScope>) {\n         match *decl {\n             codemap::Spanned { node: ast::DeclLocal(ref local), .. } => {\n                 scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n@@ -3270,7 +3269,7 @@ fn populate_scope_map(cx: &CrateContext,\n     fn walk_pattern(cx: &CrateContext,\n                     pat: &ast::Pat,\n                     scope_stack: &mut Vec<ScopeStackEntry> ,\n-                    scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n+                    scope_map: &mut NodeMap<DIScope>) {\n \n         let def_map = &cx.tcx().def_map;\n \n@@ -3428,7 +3427,7 @@ fn populate_scope_map(cx: &CrateContext,\n     fn walk_expr(cx: &CrateContext,\n                  exp: &ast::Expr,\n                  scope_stack: &mut Vec<ScopeStackEntry> ,\n-                 scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n+                 scope_map: &mut NodeMap<DIScope>) {\n \n         scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n "}, {"sha": "cb6dbcb22e2b76119ea0edc52f5aa125e311a01e", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -15,13 +15,13 @@ use llvm::{TypeRef, Bool, False, True, TypeKind, ValueRef};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use middle::trans::context::CrateContext;\n+use util::nodemap::FnvHashMap;\n \n use syntax::ast;\n \n use std::c_str::ToCStr;\n use std::mem;\n use std::cell::RefCell;\n-use std::collections::HashMap;\n \n use libc::c_uint;\n \n@@ -320,13 +320,13 @@ impl Type {\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n-    named_types: RefCell<HashMap<String, TypeRef>>,\n+    named_types: RefCell<FnvHashMap<String, TypeRef>>,\n }\n \n impl TypeNames {\n     pub fn new() -> TypeNames {\n         TypeNames {\n-            named_types: RefCell::new(HashMap::new())\n+            named_types: RefCell::new(FnvHashMap::new())\n         }\n     }\n "}, {"sha": "0a3c4e76fa0096b45cc506d24ac90bba01dcf063", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 54, "deletions": 73, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -32,17 +32,16 @@ use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n use util::ppaux::{Repr, UserString};\n-use util::common::{indenter, memoized, memoized_with_key};\n-use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet, FnvHashMap};\n-\n+use util::common::{indenter, memoized};\n+use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt::{mod, Show};\n use std::hash::{Hash, sip, Writer};\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n-use std::collections::{HashMap, HashSet};\n use std::collections::hash_map::{Occupied, Vacant};\n use arena::TypedArena;\n use syntax::abi;\n@@ -227,8 +226,6 @@ pub struct creader_cache_key {\n     pub len: uint\n }\n \n-pub type creader_cache = RefCell<HashMap<creader_cache_key, t>>;\n-\n pub struct intern_key {\n     sty: *const sty,\n }\n@@ -438,7 +435,6 @@ pub struct ctxt<'tcx> {\n     /// Specifically use a speedy hash algorithm for this hash map, it's used\n     /// quite often.\n     interner: RefCell<FnvHashMap<intern_key, &'tcx t_box_>>,\n-    pub next_id: Cell<uint>,\n     pub sess: Session,\n     pub def_map: resolve::DefMap,\n \n@@ -449,7 +445,7 @@ pub struct ctxt<'tcx> {\n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n-    pub node_types: node_type_table,\n+    pub node_types: RefCell<NodeMap<t>>,\n \n     /// Stores the type parameters which were substituted to obtain the type\n     /// of this node.  This only applies to nodes that refer to entities\n@@ -478,16 +474,16 @@ pub struct ctxt<'tcx> {\n     pub map: ast_map::Map<'tcx>,\n     pub intrinsic_defs: RefCell<DefIdMap<t>>,\n     pub freevars: RefCell<FreevarMap>,\n-    pub tcache: type_cache,\n-    pub rcache: creader_cache,\n-    pub short_names_cache: RefCell<HashMap<t, String>>,\n-    pub needs_unwind_cleanup_cache: RefCell<HashMap<t, bool>>,\n-    pub tc_cache: RefCell<HashMap<uint, TypeContents>>,\n+    pub tcache: RefCell<DefIdMap<Polytype>>,\n+    pub rcache: RefCell<FnvHashMap<creader_cache_key, t>>,\n+    pub short_names_cache: RefCell<FnvHashMap<t, String>>,\n+    pub needs_unwind_cleanup_cache: RefCell<FnvHashMap<t, bool>>,\n+    pub tc_cache: RefCell<FnvHashMap<t, TypeContents>>,\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry>>,\n     pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo>>>>>,\n     pub ty_param_defs: RefCell<NodeMap<TypeParameterDef>>,\n     pub adjustments: RefCell<NodeMap<AutoAdjustment>>,\n-    pub normalized_cache: RefCell<HashMap<t, t>>,\n+    pub normalized_cache: RefCell<FnvHashMap<t, t>>,\n     pub lang_items: middle::lang_items::LanguageItems,\n     /// A mapping of fake provided method def_ids to the default implementation\n     pub provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n@@ -556,8 +552,8 @@ pub struct ctxt<'tcx> {\n     /// expression defining the unboxed closure.\n     pub unboxed_closures: RefCell<DefIdMap<UnboxedClosure>>,\n \n-    pub node_lint_levels: RefCell<HashMap<(ast::NodeId, lint::LintId),\n-                                          lint::LevelSource>>,\n+    pub node_lint_levels: RefCell<FnvHashMap<(ast::NodeId, lint::LintId),\n+                                              lint::LevelSource>>,\n \n     /// The types that must be asserted to be the same size for `transmute`\n     /// to be valid. We gather up these restrictions in the intrinsicck pass\n@@ -603,7 +599,6 @@ pub type t_box = &'static t_box_;\n #[deriving(Show)]\n pub struct t_box_ {\n     pub sty: sty,\n-    pub id: uint,\n     pub flags: TypeFlags,\n }\n \n@@ -648,7 +643,6 @@ pub fn type_has_ty_infer(t: t) -> bool { tbox_has_flag(get(t), HAS_TY_INFER) }\n pub fn type_needs_infer(t: t) -> bool {\n     tbox_has_flag(get(t), HAS_TY_INFER | HAS_RE_INFER)\n }\n-pub fn type_id(t: t) -> uint { get(t).id }\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct BareFnTy {\n@@ -861,7 +855,7 @@ pub struct UpvarBorrow {\n     pub region: ty::Region,\n }\n \n-pub type UpvarBorrowMap = HashMap<UpvarId, UpvarBorrow>;\n+pub type UpvarBorrowMap = FnvHashMap<UpvarId, UpvarBorrow>;\n \n impl Region {\n     pub fn is_bound(&self) -> bool {\n@@ -904,38 +898,34 @@ mod primitives {\n     use syntax::ast;\n \n     macro_rules! def_prim_ty(\n-        ($name:ident, $sty:expr, $id:expr) => (\n+        ($name:ident, $sty:expr) => (\n             pub static $name: t_box_ = t_box_ {\n                 sty: $sty,\n-                id: $id,\n                 flags: super::NO_TYPE_FLAGS,\n             };\n         )\n     )\n \n-    def_prim_ty!(TY_NIL,    super::ty_nil,                  0)\n-    def_prim_ty!(TY_BOOL,   super::ty_bool,                 1)\n-    def_prim_ty!(TY_CHAR,   super::ty_char,                 2)\n-    def_prim_ty!(TY_INT,    super::ty_int(ast::TyI),        3)\n-    def_prim_ty!(TY_I8,     super::ty_int(ast::TyI8),       4)\n-    def_prim_ty!(TY_I16,    super::ty_int(ast::TyI16),      5)\n-    def_prim_ty!(TY_I32,    super::ty_int(ast::TyI32),      6)\n-    def_prim_ty!(TY_I64,    super::ty_int(ast::TyI64),      7)\n-    def_prim_ty!(TY_UINT,   super::ty_uint(ast::TyU),       8)\n-    def_prim_ty!(TY_U8,     super::ty_uint(ast::TyU8),      9)\n-    def_prim_ty!(TY_U16,    super::ty_uint(ast::TyU16),     10)\n-    def_prim_ty!(TY_U32,    super::ty_uint(ast::TyU32),     11)\n-    def_prim_ty!(TY_U64,    super::ty_uint(ast::TyU64),     12)\n-    def_prim_ty!(TY_F32,    super::ty_float(ast::TyF32),    14)\n-    def_prim_ty!(TY_F64,    super::ty_float(ast::TyF64),    15)\n+    def_prim_ty!(TY_NIL,    super::ty_nil)\n+    def_prim_ty!(TY_BOOL,   super::ty_bool)\n+    def_prim_ty!(TY_CHAR,   super::ty_char)\n+    def_prim_ty!(TY_INT,    super::ty_int(ast::TyI))\n+    def_prim_ty!(TY_I8,     super::ty_int(ast::TyI8))\n+    def_prim_ty!(TY_I16,    super::ty_int(ast::TyI16))\n+    def_prim_ty!(TY_I32,    super::ty_int(ast::TyI32))\n+    def_prim_ty!(TY_I64,    super::ty_int(ast::TyI64))\n+    def_prim_ty!(TY_UINT,   super::ty_uint(ast::TyU))\n+    def_prim_ty!(TY_U8,     super::ty_uint(ast::TyU8))\n+    def_prim_ty!(TY_U16,    super::ty_uint(ast::TyU16))\n+    def_prim_ty!(TY_U32,    super::ty_uint(ast::TyU32))\n+    def_prim_ty!(TY_U64,    super::ty_uint(ast::TyU64))\n+    def_prim_ty!(TY_F32,    super::ty_float(ast::TyF32))\n+    def_prim_ty!(TY_F64,    super::ty_float(ast::TyF64))\n \n     pub static TY_ERR: t_box_ = t_box_ {\n         sty: super::ty_err,\n-        id: 17,\n         flags: super::HAS_TY_ERR,\n     };\n-\n-    pub const LAST_PRIMITIVE_ID: uint = 18;\n }\n \n // NB: If you change this, you'll probably want to change the corresponding\n@@ -1457,10 +1447,6 @@ pub struct ItemSubsts {\n     pub substs: Substs,\n }\n \n-pub type type_cache = RefCell<DefIdMap<Polytype>>;\n-\n-pub type node_type_table = RefCell<HashMap<uint,t>>;\n-\n /// Records information about each unboxed closure.\n #[deriving(Clone)]\n pub struct UnboxedClosure {\n@@ -1511,11 +1497,10 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n         variance_computed: Cell::new(false),\n-        next_id: Cell::new(primitives::LAST_PRIMITIVE_ID),\n         sess: s,\n         def_map: dm,\n         region_maps: region_maps,\n-        node_types: RefCell::new(HashMap::new()),\n+        node_types: RefCell::new(FnvHashMap::new()),\n         item_substs: RefCell::new(NodeMap::new()),\n         trait_refs: RefCell::new(NodeMap::new()),\n         trait_defs: RefCell::new(DefIdMap::new()),\n@@ -1524,10 +1509,10 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         intrinsic_defs: RefCell::new(DefIdMap::new()),\n         freevars: freevars,\n         tcache: RefCell::new(DefIdMap::new()),\n-        rcache: RefCell::new(HashMap::new()),\n-        short_names_cache: RefCell::new(HashMap::new()),\n-        needs_unwind_cleanup_cache: RefCell::new(HashMap::new()),\n-        tc_cache: RefCell::new(HashMap::new()),\n+        rcache: RefCell::new(FnvHashMap::new()),\n+        short_names_cache: RefCell::new(FnvHashMap::new()),\n+        needs_unwind_cleanup_cache: RefCell::new(FnvHashMap::new()),\n+        tc_cache: RefCell::new(FnvHashMap::new()),\n         ast_ty_to_ty_cache: RefCell::new(NodeMap::new()),\n         enum_var_cache: RefCell::new(DefIdMap::new()),\n         impl_or_trait_items: RefCell::new(DefIdMap::new()),\n@@ -1536,7 +1521,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         impl_trait_cache: RefCell::new(DefIdMap::new()),\n         ty_param_defs: RefCell::new(NodeMap::new()),\n         adjustments: RefCell::new(NodeMap::new()),\n-        normalized_cache: RefCell::new(HashMap::new()),\n+        normalized_cache: RefCell::new(FnvHashMap::new()),\n         lang_items: lang_items,\n         provided_method_sources: RefCell::new(DefIdMap::new()),\n         struct_fields: RefCell::new(DefIdMap::new()),\n@@ -1549,13 +1534,13 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         used_mut_nodes: RefCell::new(NodeSet::new()),\n         populated_external_types: RefCell::new(DefIdSet::new()),\n         populated_external_traits: RefCell::new(DefIdSet::new()),\n-        upvar_borrow_map: RefCell::new(HashMap::new()),\n+        upvar_borrow_map: RefCell::new(FnvHashMap::new()),\n         extern_const_statics: RefCell::new(DefIdMap::new()),\n         extern_const_variants: RefCell::new(DefIdMap::new()),\n         method_map: RefCell::new(FnvHashMap::new()),\n-        dependency_formats: RefCell::new(HashMap::new()),\n+        dependency_formats: RefCell::new(FnvHashMap::new()),\n         unboxed_closures: RefCell::new(DefIdMap::new()),\n-        node_lint_levels: RefCell::new(HashMap::new()),\n+        node_lint_levels: RefCell::new(FnvHashMap::new()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n         capture_modes: capture_modes,\n@@ -1681,7 +1666,6 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n \n     let t = cx.type_arena.alloc(t_box_ {\n         sty: st,\n-        id: cx.next_id.get(),\n         flags: flags,\n     });\n \n@@ -1693,8 +1677,6 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n \n     cx.interner.borrow_mut().insert(key, t);\n \n-    cx.next_id.set(cx.next_id.get() + 1);\n-\n     unsafe {\n         mem::transmute::<*const sty, t>(sty_ptr)\n     }\n@@ -2176,10 +2158,10 @@ pub fn type_needs_drop(cx: &ctxt, ty: t) -> bool {\n // cleanups.\n pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n     return memoized(&cx.needs_unwind_cleanup_cache, ty, |ty| {\n-        type_needs_unwind_cleanup_(cx, ty, &mut HashSet::new())\n+        type_needs_unwind_cleanup_(cx, ty, &mut FnvHashSet::new())\n     });\n \n-    fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t, tycache: &mut HashSet<t>) -> bool {\n+    fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t, tycache: &mut FnvHashSet<t>) -> bool {\n         // Prevent infinite recursion\n         if !tycache.insert(ty) {\n             return false;\n@@ -2400,13 +2382,13 @@ pub fn type_interior_is_unsafe(cx: &ctxt, t: ty::t) -> bool {\n }\n \n pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n-    return memoized_with_key(&cx.tc_cache, ty, |ty| {\n-        tc_ty(cx, ty, &mut HashMap::new())\n-    }, |&ty| type_id(ty));\n+    return memoized(&cx.tc_cache, ty, |ty| {\n+        tc_ty(cx, ty, &mut FnvHashMap::new())\n+    });\n \n     fn tc_ty(cx: &ctxt,\n              ty: t,\n-             cache: &mut HashMap<uint, TypeContents>) -> TypeContents\n+             cache: &mut FnvHashMap<t, TypeContents>) -> TypeContents\n     {\n         // Subtle: Note that we are *not* using cx.tc_cache here but rather a\n         // private cache for this walk.  This is needed in the case of cyclic\n@@ -2429,16 +2411,15 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         // which is incorrect.  This value was computed based on the crutch\n         // value for the type contents of list.  The correct value is\n         // TC::OwnsOwned.  This manifested as issue #4821.\n-        let ty_id = type_id(ty);\n-        match cache.get(&ty_id) {\n+        match cache.get(&ty) {\n             Some(tc) => { return *tc; }\n             None => {}\n         }\n-        match cx.tc_cache.borrow().get(&ty_id) {    // Must check both caches!\n+        match cx.tc_cache.borrow().get(&ty) {    // Must check both caches!\n             Some(tc) => { return *tc; }\n             None => {}\n         }\n-        cache.insert(ty_id, TC::None);\n+        cache.insert(ty, TC::None);\n \n         let result = match get(ty).sty {\n             // uint and int are ffi-unsafe\n@@ -2608,13 +2589,13 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n             }\n         };\n \n-        cache.insert(ty_id, result);\n-        return result;\n+        cache.insert(ty, result);\n+        result\n     }\n \n     fn tc_mt(cx: &ctxt,\n              mt: mt,\n-             cache: &mut HashMap<uint, TypeContents>) -> TypeContents\n+             cache: &mut FnvHashMap<t, TypeContents>) -> TypeContents\n     {\n         let mc = TC::ReachesMutable.when(mt.mutbl == MutMutable);\n         mc | tc_ty(cx, mt.ty, cache)\n@@ -2922,7 +2903,7 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n                 pairs.all(|(&a, &b)| same_type(a, b))\n             }\n             _ => {\n-                type_id(a) == type_id(b)\n+                a == b\n             }\n         }\n     }\n@@ -3213,7 +3194,7 @@ pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {\n }\n \n pub fn try_node_id_to_type(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n-    cx.node_types.borrow().find_copy(&(id as uint))\n+    cx.node_types.borrow().find_copy(&id)\n }\n \n pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n@@ -3226,7 +3207,7 @@ pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n }\n \n pub fn node_id_to_type_opt(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n-    match cx.node_types.borrow().get(&(id as uint)) {\n+    match cx.node_types.borrow().get(&id) {\n        Some(&t) => Some(t),\n        None => None\n     }\n@@ -3702,7 +3683,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         }\n \n         ast::ExprCast(..) => {\n-            match tcx.node_types.borrow().get(&(expr.id as uint)) {\n+            match tcx.node_types.borrow().get(&expr.id) {\n                 Some(&t) => {\n                     if type_is_trait(t) {\n                         RvalueDpsExpr"}, {"sha": "ec289a2d80699377318497f79b670cb7c32a598a", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -61,9 +61,9 @@ use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope, Bind\n use middle::typeck::rscope;\n use middle::typeck::TypeAndSubsts;\n use middle::typeck;\n+use util::nodemap::DefIdMap;\n use util::ppaux::{Repr, UserString};\n \n-use std::collections::HashMap;\n use std::rc::Rc;\n use std::iter::AdditiveIterator;\n use syntax::{abi, ast, ast_util};\n@@ -1545,7 +1545,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     let mut builtin_bounds = ty::empty_builtin_bounds();\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n-    let mut trait_def_ids = HashMap::new();\n+    let mut trait_def_ids = DefIdMap::new();\n     for &ast_bound in ast_bounds.iter() {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b) => {\n@@ -1599,4 +1599,3 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n         region_bounds: region_bounds,\n     }\n }\n-"}, {"sha": "c15b6e6ddae2e86df9067156348936e33e6bb1bd", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -16,9 +16,9 @@ use middle::typeck::check::{check_expr, check_expr_has_type, demand, FnCtxt};\n use middle::typeck::check::{instantiate_path, structurally_resolved_type, valid_range_bounds};\n use middle::typeck::infer::{mod, resolve};\n use middle::typeck::require_same_types;\n+use util::nodemap::FnvHashMap;\n \n use std::cmp;\n-use std::collections::HashMap;\n use std::collections::hash_map::{Occupied, Vacant};\n use syntax::ast;\n use syntax::ast_util;\n@@ -430,10 +430,10 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n     let field_type_map = struct_fields\n         .iter()\n         .map(|field| (field.name, field.mt.ty))\n-        .collect::<HashMap<_, _>>();\n+        .collect::<FnvHashMap<_, _>>();\n \n     // Keep track of which fields have already appeared in the pattern.\n-    let mut used_fields = HashMap::new();\n+    let mut used_fields = FnvHashMap::new();\n \n     // Typecheck each field.\n     for &Spanned { node: ref field, span } in fields.iter() {"}, {"sha": "cac702d6ac0c32c1b7b4e7f0413dc7801a39383d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -117,7 +117,6 @@ use util::ppaux::{UserString, Repr};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n-use std::collections::HashMap;\n use std::collections::hash_map::{Occupied, Vacant};\n use std::mem::replace;\n use std::rc::Rc;\n@@ -334,7 +333,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             adjustments: RefCell::new(NodeMap::new()),\n             method_map: RefCell::new(FnvHashMap::new()),\n             object_cast_map: RefCell::new(NodeMap::new()),\n-            upvar_borrow_map: RefCell::new(HashMap::new()),\n+            upvar_borrow_map: RefCell::new(FnvHashMap::new()),\n             unboxed_closures: RefCell::new(DefIdMap::new()),\n             fn_sig_map: RefCell::new(NodeMap::new()),\n             region_obligations: RefCell::new(NodeMap::new()),\n@@ -3747,7 +3746,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                       check_completeness: bool)  {\n         let tcx = fcx.ccx.tcx;\n \n-        let mut class_field_map = HashMap::new();\n+        let mut class_field_map = FnvHashMap::new();\n         let mut fields_found = 0;\n         for field in field_types.iter() {\n             class_field_map.insert(field.name, (field.id, false));"}, {"sha": "c827602cad0566ab668da71f507d07e6fe8a4cb9", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -132,7 +132,7 @@ use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n use middle::typeck::MethodCall;\n use middle::pat_util;\n-use util::nodemap::{DefIdMap, NodeMap};\n+use util::nodemap::{DefIdMap, NodeMap, FnvHashMap};\n use util::ppaux::{ty_to_string, Repr};\n \n use syntax::ast;\n@@ -141,7 +141,6 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::cell::{RefCell};\n-use std::collections::HashMap;\n use std::collections::hash_map::{Vacant, Occupied};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -224,7 +223,7 @@ struct MaybeLink {\n }\n \n // A map associating an upvar ID to a vector of the above\n-type MaybeLinkMap = RefCell<HashMap<ty::UpvarId, Vec<MaybeLink>>>;\n+type MaybeLinkMap = RefCell<FnvHashMap<ty::UpvarId, Vec<MaybeLink>>>;\n \n pub struct Rcx<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -270,7 +269,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n               region_param_pairs: Vec::new(),\n-              maybe_links: RefCell::new(HashMap::new()) }\n+              maybe_links: RefCell::new(FnvHashMap::new()) }\n     }\n \n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {"}, {"sha": "0856c86946bda7fe7b20d30c10727bb19ef23c14", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -17,8 +17,8 @@ use middle::ty_fold::{TypeFolder, TypeFoldable};\n \n use syntax::ast;\n \n-use std::collections::HashMap;\n use std::collections::hash_map::{Occupied, Vacant};\n+use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n@@ -28,13 +28,13 @@ pub fn replace_late_bound_regions<T>(\n     binder_id: ast::NodeId,\n     value: &T,\n     map_fn: |ty::BoundRegion| -> ty::Region)\n-    -> (HashMap<ty::BoundRegion,ty::Region>, T)\n+    -> (FnvHashMap<ty::BoundRegion,ty::Region>, T)\n     where T : TypeFoldable + Repr\n {\n     debug!(\"replace_late_bound_regions(binder_id={}, value={})\",\n            binder_id, value.repr(tcx));\n \n-    let mut map = HashMap::new();\n+    let mut map = FnvHashMap::new();\n     let new_value = {\n         let mut folder = ty_fold::RegionFolder::regions(tcx, |r| {\n             match r {"}, {"sha": "6685bb9be77792aee616f8b2a162adc4c04b71b8", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -48,10 +48,10 @@ use middle::typeck::infer;\n use middle::typeck::rscope::*;\n use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n use middle::typeck;\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux;\n use util::ppaux::{Repr,UserString};\n \n-use std::collections::{HashMap, HashSet};\n use std::rc::Rc;\n \n use syntax::abi;\n@@ -530,7 +530,7 @@ fn convert_methods<'a,I>(ccx: &CrateCtxt,\n            rcvr_ty_generics.repr(ccx.tcx));\n \n     let tcx = ccx.tcx;\n-    let mut seen_methods = HashSet::new();\n+    let mut seen_methods = FnvHashSet::new();\n     for m in ms {\n         if !seen_methods.insert(m.pe_ident().repr(tcx)) {\n             tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n@@ -1247,7 +1247,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members and check for duplicate fields.\n-    let mut seen_fields: HashMap<ast::Name, Span> = HashMap::new();\n+    let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap::new();\n     let field_tys = struct_def.fields.iter().map(|f| {\n         let result = convert_field(ccx, &pty.generics, f, local_def(id));\n "}, {"sha": "7ed5a5db161a8087ab6bceaf526720cfd7422ae2", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -24,8 +24,8 @@ use middle::typeck::infer::region_inference::RegionMark;\n use syntax::ast::{Many, Once, MutImmutable, MutMutable};\n use syntax::ast::{NormalFn, UnsafeFn, NodeId};\n use syntax::ast::{Onceness, FnStyle};\n-use std::collections::HashMap;\n use util::common::{indenter};\n+use util::nodemap::FnvHashMap;\n use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n@@ -176,7 +176,7 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n                              mark: RegionMark,\n                              new_vars: &[RegionVid],\n                              new_binder_id: NodeId,\n-                             a_map: &HashMap<ty::BoundRegion, ty::Region>,\n+                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n                              a_vars: &[RegionVid],\n                              b_vars: &[RegionVid],\n                              r0: ty::Region) -> ty::Region {\n@@ -243,7 +243,7 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         }\n \n         fn rev_lookup(this: &Glb,\n-                      a_map: &HashMap<ty::BoundRegion, ty::Region>,\n+                      a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n                       new_binder_id: NodeId,\n                       r: ty::Region) -> ty::Region\n         {"}, {"sha": "5dbcaadf0df67283b9f0612c0f3da15ed9ca50d1", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -37,10 +37,9 @@ use middle::typeck::infer::*;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n+use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n \n-use std::collections::HashMap;\n-\n pub trait LatticeDir {\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n@@ -108,7 +107,7 @@ pub fn super_lattice_tys<'tcx, L:LatticeDir+Combine<'tcx>>(this: &L,\n // fn types\n \n pub fn var_ids<'tcx, T: Combine<'tcx>>(this: &T,\n-                                       map: &HashMap<ty::BoundRegion, ty::Region>)\n+                                       map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n                                        -> Vec<RegionVid> {\n     map.iter().map(|(_, r)| match *r {\n             ty::ReInfer(ty::ReVar(r)) => { r }"}, {"sha": "597783405640d72b1f3fd1971c2e5c439ba8d4a6", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -20,11 +20,11 @@ use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::region_inference::RegionMark;\n-use std::collections::HashMap;\n use syntax::ast::{Many, Once, NodeId};\n use syntax::ast::{NormalFn, UnsafeFn};\n use syntax::ast::{Onceness, FnStyle};\n use syntax::ast::{MutMutable, MutImmutable};\n+use util::nodemap::FnvHashMap;\n use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n@@ -151,7 +151,7 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n                              mark: RegionMark,\n                              new_vars: &[RegionVid],\n                              new_scope: NodeId,\n-                             a_map: &HashMap<ty::BoundRegion, ty::Region>,\n+                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n                              r0: ty::Region)\n                              -> ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are."}, {"sha": "2f6f307494a2a90184f09a34b8df87da832fe32e", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -30,12 +30,12 @@ use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use std::cell::{RefCell};\n-use std::collections::HashMap;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n use util::common::indent;\n+use util::nodemap::FnvHashMap;\n use util::ppaux::{bound_region_to_string, ty_to_string};\n use util::ppaux::{trait_ref_to_string, Repr};\n \n@@ -958,7 +958,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                          trace: TypeTrace,\n                                                          fsig: &ty::FnSig)\n                                                     -> (ty::FnSig,\n-                                                        HashMap<ty::BoundRegion,\n+                                                        FnvHashMap<ty::BoundRegion,\n                                                                 ty::Region>) {\n         let (map, fn_sig) =\n             replace_late_bound_regions(self.tcx, fsig.binder_id, fsig, |br| {"}, {"sha": "dcf618d94c29d57745bb56dcc66a9d1d5af60bff", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -21,11 +21,11 @@ use middle::typeck::infer;\n use middle::graph;\n use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::Repr;\n \n use std::cell::{Cell, RefCell};\n use std::uint;\n-use std::collections::{HashMap, HashSet};\n use syntax::ast;\n \n mod doc;\n@@ -149,7 +149,7 @@ impl SameRegions {\n     }\n }\n \n-pub type CombineMap = HashMap<TwoRegions, RegionVid>;\n+pub type CombineMap = FnvHashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n@@ -158,7 +158,7 @@ pub struct RegionVarBindings<'a, 'tcx: 'a> {\n     // Constraints of the form `A <= B` introduced by the region\n     // checker.  Here at least one of `A` and `B` must be a region\n     // variable.\n-    constraints: RefCell<HashMap<Constraint, SubregionOrigin>>,\n+    constraints: RefCell<FnvHashMap<Constraint, SubregionOrigin>>,\n \n     // A \"verify\" is something that we need to verify after inference is\n     // done, but which does not directly affect inference in any way.\n@@ -184,7 +184,7 @@ pub struct RegionVarBindings<'a, 'tcx: 'a> {\n     // record the fact that `'a <= 'b` is implied by the fn signature,\n     // and then ignore the constraint when solving equations. This is\n     // a bit of a hack but seems to work.\n-    givens: RefCell<HashSet<(ty::FreeRegion, ty::RegionVid)>>,\n+    givens: RefCell<FnvHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n \n     lubs: RefCell<CombineMap>,\n     glbs: RefCell<CombineMap>,\n@@ -223,11 +223,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             tcx: tcx,\n             var_origins: RefCell::new(Vec::new()),\n             values: RefCell::new(None),\n-            constraints: RefCell::new(HashMap::new()),\n+            constraints: RefCell::new(FnvHashMap::new()),\n             verifys: RefCell::new(Vec::new()),\n-            givens: RefCell::new(HashSet::new()),\n-            lubs: RefCell::new(HashMap::new()),\n-            glbs: RefCell::new(HashMap::new()),\n+            givens: RefCell::new(FnvHashSet::new()),\n+            lubs: RefCell::new(FnvHashMap::new()),\n+            glbs: RefCell::new(FnvHashMap::new()),\n             skolemization_count: Cell::new(0),\n             bound_count: Cell::new(0),\n             undo_log: RefCell::new(Vec::new())\n@@ -1183,7 +1183,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                       values: &Vec<VarValue>,\n                                       errors: &mut Vec<RegionResolutionError>)\n     {\n-        let mut reg_reg_dups = HashSet::new();\n+        let mut reg_reg_dups = FnvHashSet::new();\n         for verify in self.verifys.borrow().iter() {\n             match *verify {\n                 VerifyRegSubReg(ref origin, sub, sup) => {\n@@ -1453,13 +1453,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                 dup_vec: &mut [uint])\n                                 -> (Vec<RegionAndOrigin> , bool) {\n         struct WalkState {\n-            set: HashSet<RegionVid>,\n+            set: FnvHashSet<RegionVid>,\n             stack: Vec<RegionVid> ,\n             result: Vec<RegionAndOrigin> ,\n             dup_found: bool\n         }\n         let mut state = WalkState {\n-            set: HashSet::new(),\n+            set: FnvHashSet::new(),\n             stack: vec!(orig_node_idx),\n             result: Vec::new(),\n             dup_found: false"}, {"sha": "f348e6155a26a6eec5a18d035dd5fd536f8beb29", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -285,8 +285,9 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n pub fn write_ty_to_tcx(tcx: &ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n     debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_string(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n-    tcx.node_types.borrow_mut().insert(node_id as uint, ty);\n+    tcx.node_types.borrow_mut().insert(node_id, ty);\n }\n+\n pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n                            node_id: ast::NodeId,\n                            item_substs: ty::ItemSubsts) {"}, {"sha": "3a2dc1d5ff034eacaa8f7533dc5d5f8cb9624ace", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -192,7 +192,6 @@ represents the \"variance transform\" as defined in the paper:\n \n */\n \n-use std::collections::HashMap;\n use arena;\n use arena::Arena;\n use middle::resolve_lifetime as rl;\n@@ -206,6 +205,7 @@ use syntax::ast_map;\n use syntax::ast_util;\n use syntax::visit;\n use syntax::visit::Visitor;\n+use util::nodemap::NodeMap;\n use util::ppaux::Repr;\n \n pub fn infer_variance(tcx: &ty::ctxt) {\n@@ -263,7 +263,7 @@ struct TermsContext<'a, 'tcx: 'a> {\n \n     // Maps from the node id of a type/generic parameter to the\n     // corresponding inferred index.\n-    inferred_map: HashMap<ast::NodeId, InferredIndex>,\n+    inferred_map: NodeMap<InferredIndex>,\n \n     // Maps from an InferredIndex to the info for that variable.\n     inferred_infos: Vec<InferredInfo<'a>> ,\n@@ -291,7 +291,7 @@ fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n     let mut terms_cx = TermsContext {\n         tcx: tcx,\n         arena: arena,\n-        inferred_map: HashMap::new(),\n+        inferred_map: NodeMap::new(),\n         inferred_infos: Vec::new(),\n \n         // cache and share the variance struct used for items with"}, {"sha": "9d94f4d235695c8c270b102ab854061ab5b8e3c3", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -189,17 +189,7 @@ pub fn memoized<T: Clone + Hash<S> + Eq, U: Clone, S, H: Hasher<S>>(\n     arg: T,\n     f: |T| -> U\n ) -> U {\n-    memoized_with_key(cache, arg, f, |arg| arg.clone())\n-}\n-\n-#[inline(always)]\n-pub fn memoized_with_key<T, K: Hash<S> + Eq, U: Clone, S, H: Hasher<S>>(\n-    cache: &RefCell<HashMap<K, U, H>>,\n-    arg: T,\n-    f: |T| -> U,\n-    k: |&T| -> K\n-) -> U {\n-    let key = k(&arg);\n+    let key = arg.clone();\n     let result = cache.borrow().get(&key).map(|result| result.clone());\n     match result {\n         Some(result) => result,"}, {"sha": "4dd6306c3c096764903348ddb9f53fa9afdb738b", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f1262c180c86e24cc957e4e9e337baa45b581a/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=85f1262c180c86e24cc957e4e9e337baa45b581a", "patch": "@@ -68,7 +68,7 @@ pub mod DefIdSet {\n ///\n /// This uses FNV hashing, as described here:\n /// http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n-#[deriving(Clone)]\n+#[deriving(Clone, Default)]\n pub struct FnvHasher;\n \n pub struct FnvState(u64);"}]}