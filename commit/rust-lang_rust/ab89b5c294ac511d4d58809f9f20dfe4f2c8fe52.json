{"sha": "ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiODliNWMyOTRhYzUxMWQ0ZDU4ODA5ZjlmMjBkZmU0ZjJjOGZlNTI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-13T16:11:33Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-15T15:25:23Z"}, "message": "libstd: make Serializer a trait-level typaram", "tree": {"sha": "e1374cc163794698bda233cdba3b32416820ab7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1374cc163794698bda233cdba3b32416820ab7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52", "html_url": "https://github.com/rust-lang/rust/commit/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07edf9036715bde27cc7bbc0feb3ee6e461130da", "url": "https://api.github.com/repos/rust-lang/rust/commits/07edf9036715bde27cc7bbc0feb3ee6e461130da", "html_url": "https://github.com/rust-lang/rust/commit/07edf9036715bde27cc7bbc0feb3ee6e461130da"}], "stats": {"total": 781, "additions": 698, "deletions": 83}, "files": [{"sha": "d170255b565d8d2b0814dfcf9c5b814732110b52", "filename": "src/libstd/json.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52", "patch": "@@ -273,6 +273,7 @@ pub impl PrettySerializer: serialization::Serializer {\n     }\n }\n \n+#[cfg(stage0)]\n pub impl Json: serialization::Serializable {\n     fn serialize<S: serialization::Serializer>(&self, s: &S) {\n         match *self {\n@@ -296,6 +297,33 @@ pub impl Json: serialization::Serializable {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<\n+    S: serialization::Serializer\n+> Json: serialization::Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        match *self {\n+            Number(v) => v.serialize(s),\n+            String(ref v) => v.serialize(s),\n+            Boolean(v) => v.serialize(s),\n+            List(v) => v.serialize(s),\n+            Object(ref v) => {\n+                do s.emit_rec || {\n+                    let mut idx = 0;\n+                    for v.each |key, value| {\n+                        do s.emit_field(*key, idx) {\n+                            value.serialize(s);\n+                        }\n+                        idx += 1;\n+                    }\n+                }\n+            },\n+            Null => s.emit_nil(),\n+        }\n+    }\n+}\n+\n /// Serializes a json value into a io::writer\n pub fn to_writer(wr: io::Writer, json: &Json) {\n     json.serialize(&Serializer(wr))"}, {"sha": "9df2a326a8474b52bf69eacdcc47c824a42646c4", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 487, "deletions": 0, "changes": 487, "blob_url": "https://github.com/rust-lang/rust/blob/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52", "patch": "@@ -92,6 +92,8 @@ pub trait Deserializer {\n     fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n }\n \n+#[cfg(stage0)]\n+pub mod traits {\n pub trait Serializable {\n     fn serialize<S: Serializer>(&self, s: &S);\n }\n@@ -561,3 +563,488 @@ pub impl<D: Deserializer> D: DeserializerHelpers {\n         }\n     }\n }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub mod traits {\n+pub trait Serializable<S: Serializer> {\n+    fn serialize(&self, s: &S);\n+}\n+\n+pub trait Deserializable<D: Deserializer> {\n+    static fn deserialize(&self, d: &D) -> self;\n+}\n+\n+pub impl<S: Serializer> uint: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_uint(*self) }\n+}\n+\n+pub impl<D: Deserializer> uint: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> uint {\n+        d.read_uint()\n+    }\n+}\n+\n+pub impl<S: Serializer> u8: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_u8(*self) }\n+}\n+\n+pub impl<D: Deserializer> u8: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> u8 {\n+        d.read_u8()\n+    }\n+}\n+\n+pub impl<S: Serializer> u16: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_u16(*self) }\n+}\n+\n+pub impl<D: Deserializer> u16: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> u16 {\n+        d.read_u16()\n+    }\n+}\n+\n+pub impl<S: Serializer> u32: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_u32(*self) }\n+}\n+\n+pub impl<D: Deserializer> u32: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> u32 {\n+        d.read_u32()\n+    }\n+}\n+\n+pub impl<S: Serializer> u64: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_u64(*self) }\n+}\n+\n+pub impl<D: Deserializer> u64: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> u64 {\n+        d.read_u64()\n+    }\n+}\n+\n+pub impl<S: Serializer> int: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_int(*self) }\n+}\n+\n+pub impl<D: Deserializer> int: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> int {\n+        d.read_int()\n+    }\n+}\n+\n+pub impl<S: Serializer> i8: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_i8(*self) }\n+}\n+\n+pub impl<D: Deserializer> i8: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> i8 {\n+        d.read_i8()\n+    }\n+}\n+\n+pub impl<S: Serializer> i16: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_i16(*self) }\n+}\n+\n+pub impl<D: Deserializer> i16: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> i16 {\n+        d.read_i16()\n+    }\n+}\n+\n+pub impl<S: Serializer> i32: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_i32(*self) }\n+}\n+\n+pub impl<D: Deserializer> i32: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> i32 {\n+        d.read_i32()\n+    }\n+}\n+\n+pub impl<S: Serializer> i64: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_i64(*self) }\n+}\n+\n+pub impl<D: Deserializer> i64: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> i64 {\n+        d.read_i64()\n+    }\n+}\n+\n+pub impl<S: Serializer> &str: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_borrowed_str(*self) }\n+}\n+\n+pub impl<S: Serializer> ~str: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_owned_str(*self) }\n+}\n+\n+pub impl<D: Deserializer> ~str: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> ~str {\n+        d.read_owned_str()\n+    }\n+}\n+\n+pub impl<S: Serializer> @str: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_managed_str(*self) }\n+}\n+\n+pub impl<D: Deserializer> @str: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> @str {\n+        d.read_managed_str()\n+    }\n+}\n+\n+pub impl<S: Serializer> float: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_float(*self) }\n+}\n+\n+pub impl<D: Deserializer> float: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> float {\n+        d.read_float()\n+    }\n+}\n+\n+pub impl<S: Serializer> f32: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_f32(*self) }\n+}\n+\n+pub impl<D: Deserializer> f32: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> f32 {\n+        d.read_f32() }\n+}\n+\n+pub impl<S: Serializer> f64: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_f64(*self) }\n+}\n+\n+pub impl<D: Deserializer> f64: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> f64 {\n+        d.read_f64()\n+    }\n+}\n+\n+pub impl<S: Serializer> bool: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_bool(*self) }\n+}\n+\n+pub impl<D: Deserializer> bool: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> bool {\n+        d.read_bool()\n+    }\n+}\n+\n+pub impl<S: Serializer> (): Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_nil() }\n+}\n+\n+pub impl<D: Deserializer> (): Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> () {\n+        d.read_nil()\n+    }\n+}\n+\n+pub impl<S: Serializer, T: Serializable<S>> &T: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        s.emit_borrowed(|| (**self).serialize(s))\n+    }\n+}\n+\n+pub impl<S: Serializer, T: Serializable<S>> ~T: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        s.emit_owned(|| (**self).serialize(s))\n+    }\n+}\n+\n+pub impl<D: Deserializer, T: Deserializable<D>> ~T: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> ~T {\n+        d.read_owned(|| ~deserialize(d))\n+    }\n+}\n+\n+pub impl<S: Serializer, T: Serializable<S>> @T: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        s.emit_managed(|| (**self).serialize(s))\n+    }\n+}\n+\n+pub impl<D: Deserializer, T: Deserializable<D>> @T: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> @T {\n+        d.read_managed(|| @deserialize(d))\n+    }\n+}\n+\n+pub impl<S: Serializer, T: Serializable<S>> &[T]: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        do s.emit_borrowed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<S: Serializer, T: Serializable<S>> ~[T]: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        do s.emit_owned_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<D: Deserializer, T: Deserializable<D>> ~[T]: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> ~[T] {\n+        do d.read_owned_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || deserialize(d))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<S: Serializer, T: Serializable<S>> @[T]: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        do s.emit_managed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<D: Deserializer, T: Deserializable<D>> @[T]: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> @[T] {\n+        do d.read_managed_vec |len| {\n+            do at_vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || deserialize(d))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<S: Serializer, T: Serializable<S>> Option<T>: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        do s.emit_enum(~\"option\") {\n+            match *self {\n+              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n+              },\n+\n+              Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n+                s.emit_enum_variant_arg(0u, || v.serialize(s))\n+              }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<D: Deserializer, T: Deserializable<D>> Option<T>: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> Option<T> {\n+        do d.read_enum(~\"option\") {\n+            do d.read_enum_variant |i| {\n+                match i {\n+                  0 => None,\n+                  1 => Some(d.read_enum_variant_arg(0u, || deserialize(d))),\n+                  _ => fail(#fmt(\"Bad variant for option: %u\", i))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    S: Serializer,\n+    T0: Serializable<S>,\n+    T1: Serializable<S>\n+> (T0, T1): Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1) => {\n+                do s.emit_tup(2) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    D: Deserializer,\n+    T0: Deserializable<D>,\n+    T1: Deserializable<D>\n+> (T0, T1): Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> (T0, T1) {\n+        do d.read_tup(2) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+pub impl<\n+    S: Serializer,\n+    T0: Serializable<S>,\n+    T1: Serializable<S>,\n+    T2: Serializable<S>\n+> (T0, T1, T2): Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2) => {\n+                do s.emit_tup(3) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    D: Deserializer,\n+    T0: Deserializable<D>,\n+    T1: Deserializable<D>,\n+    T2: Deserializable<D>\n+> (T0, T1, T2): Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> (T0, T1, T2) {\n+        do d.read_tup(3) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+pub impl<\n+    S: Serializer,\n+    T0: Serializable<S>,\n+    T1: Serializable<S>,\n+    T2: Serializable<S>,\n+    T3: Serializable<S>\n+> (T0, T1, T2, T3): Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3) => {\n+                do s.emit_tup(4) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                    s.emit_tup_elt(3, || t3.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    D: Deserializer,\n+    T0: Deserializable<D>,\n+    T1: Deserializable<D>,\n+    T2: Deserializable<D>,\n+    T3: Deserializable<D>\n+> (T0, T1, T2, T3): Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> (T0, T1, T2, T3) {\n+        do d.read_tup(4) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d)),\n+                d.read_tup_elt(3, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+pub impl<\n+    S: Serializer,\n+    T0: Serializable<S>,\n+    T1: Serializable<S>,\n+    T2: Serializable<S>,\n+    T3: Serializable<S>,\n+    T4: Serializable<S>\n+> (T0, T1, T2, T3, T4): Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n+                do s.emit_tup(5) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                    s.emit_tup_elt(3, || t3.serialize(s));\n+                    s.emit_tup_elt(4, || t4.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    D: Deserializer,\n+    T0: Deserializable<D>,\n+    T1: Deserializable<D>,\n+    T2: Deserializable<D>,\n+    T3: Deserializable<D>,\n+    T4: Deserializable<D>\n+> (T0, T1, T2, T3, T4): Deserializable<D> {\n+    static fn deserialize(&self, d: &D)\n+      -> (T0, T1, T2, T3, T4) {\n+        do d.read_tup(5) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d)),\n+                d.read_tup_elt(3, || deserialize(d)),\n+                d.read_tup_elt(4, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+// ___________________________________________________________________________\n+// Helper routines\n+//\n+// In some cases, these should eventually be coded as traits.\n+\n+pub trait SerializerHelpers {\n+    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T));\n+}\n+\n+pub impl<S: Serializer> S: SerializerHelpers {\n+    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T)) {\n+        do self.emit_owned_vec(v.len()) {\n+            for v.eachi |i, e| {\n+                do self.emit_vec_elt(i) {\n+                    f(e)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub trait DeserializerHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n+}\n+\n+pub impl<D: Deserializer> D: DeserializerHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n+        do self.read_owned_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                self.read_vec_elt(i, || f())\n+            }\n+        }\n+    }\n+}\n+}\n+\n+pub use traits::*;"}, {"sha": "cf7b758216b91257f855ee0f32ac71f070c436b8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52", "patch": "@@ -7,17 +7,34 @@ use std::serialization::{Serializable,\n use codemap::{span, filename};\n use parse::token;\n \n+#[cfg(stage0)]\n impl span: Serializable {\n     /* Note #1972 -- spans are serialized but not deserialized */\n     fn serialize<S: Serializer>(&self, _s: &S) { }\n }\n \n+#[cfg(stage0)]\n impl span: Deserializable {\n     static fn deserialize<D: Deserializer>(_d: &D) -> span {\n         ast_util::dummy_sp()\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<S: Serializer> span: Serializable<S> {\n+    /* Note #1972 -- spans are serialized but not deserialized */\n+    fn serialize(&self, _s: &S) { }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<D: Deserializer> span: Deserializable<D> {\n+    static fn deserialize(_d: &D) -> span {\n+        ast_util::dummy_sp()\n+    }\n+}\n+\n #[auto_serialize]\n #[auto_deserialize]\n type spanned<T> = {node: T, span: span};\n@@ -34,6 +51,7 @@ macro_rules! interner_key (\n // implemented.\n struct ident { repr: uint }\n \n+#[cfg(stage0)]\n impl ident: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) {\n         let intr = match unsafe {\n@@ -47,6 +65,7 @@ impl ident: Serializable {\n     }\n }\n \n+#[cfg(stage0)]\n impl ident: Deserializable {\n     static fn deserialize<D: Deserializer>(d: &D) -> ident {\n         let intr = match unsafe {\n@@ -60,6 +79,36 @@ impl ident: Deserializable {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<S: Serializer> ident: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        let intr = match unsafe {\n+            task::local_data::local_data_get(interner_key!())\n+        } {\n+            None => fail ~\"serialization: TLS interner not set up\",\n+            Some(intr) => intr\n+        };\n+\n+        s.emit_owned_str(*(*intr).get(*self));\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<D: Deserializer> ident: Deserializable<D> {\n+    static fn deserialize(d: &D) -> ident {\n+        let intr = match unsafe {\n+            task::local_data::local_data_get(interner_key!())\n+        } {\n+            None => fail ~\"deserialization: TLS interner not set up\",\n+            Some(intr) => intr\n+        };\n+\n+        (*intr).intern(@d.read_owned_str())\n+    }\n+}\n+\n impl ident: cmp::Eq {\n     pure fn eq(other: &ident) -> bool { self.repr == other.repr }\n     pure fn ne(other: &ident) -> bool { !self.eq(other) }"}, {"sha": "452becbe559acce5f025c2037fd0590026064f87", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 87, "deletions": 56, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52", "patch": "@@ -13,16 +13,16 @@ For example, a type like:\n \n would generate two implementations like:\n \n-    impl Node: Serializable {\n-        fn serialize<S: Serializer>(s: &S) {\n+    impl<S: Serializer> node_id: Serializable<S> {\n+        fn serialize(s: &S) {\n             do s.emit_struct(\"Node\") {\n                 s.emit_field(\"id\", 0, || s.emit_uint(self))\n             }\n         }\n     }\n \n-    impl node_id: Deserializable {\n-        static fn deserialize<D: Deserializer>(d: &D) -> Node {\n+    impl<D: Deserializer> node_id: Deserializable {\n+        static fn deserialize(d: &D) -> Node {\n             do d.read_struct(\"Node\") {\n                 Node {\n                     id: d.read_field(~\"x\", 0, || deserialize(d))\n@@ -40,7 +40,10 @@ references other non-built-in types.  A type definition like:\n \n would yield functions like:\n \n-    impl<T: Serializable> spanned<T>: Serializable {\n+    impl<\n+        S: Serializer,\n+        T: Serializable<S>\n+    > spanned<T>: Serializable<S> {\n         fn serialize<S: Serializer>(s: &S) {\n             do s.emit_rec {\n                 s.emit_field(\"node\", 0, || self.node.serialize(s));\n@@ -49,8 +52,11 @@ would yield functions like:\n         }\n     }\n \n-    impl<T: Deserializable> spanned<T>: Deserializable {\n-        static fn deserialize<D: Deserializer>(d: &D) -> spanned<T> {\n+    impl<\n+        D: Deserializer,\n+        T: Deserializable<D>\n+    > spanned<T>: Deserializable<D> {\n+        static fn deserialize(d: &D) -> spanned<T> {\n             do d.read_rec {\n                 {\n                     node: d.read_field(~\"node\", 0, || deserialize(d)),\n@@ -215,6 +221,25 @@ fn expand_auto_deserialize(\n }\n \n priv impl ext_ctxt {\n+    fn bind_path(\n+        span: span,\n+        ident: ast::ident,\n+        path: @ast::path,\n+        bounds: @~[ast::ty_param_bound]\n+    ) -> ast::ty_param {\n+        let bound = ast::bound_trait(@{\n+            id: self.next_id(),\n+            node: ast::ty_path(path, self.next_id()),\n+            span: span,\n+        });\n+\n+        {\n+            ident: ident,\n+            id: self.next_id(),\n+            bounds: @vec::append(~[bound], *bounds)\n+        }\n+    }\n+\n     fn expr(span: span, node: ast::expr_) -> @ast::expr {\n         @{id: self.next_id(), callee_id: self.next_id(),\n           node: node, span: span}\n@@ -332,24 +357,28 @@ fn mk_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n+    ty_param: ast::ty_param,\n     path: @ast::path,\n     tps: ~[ast::ty_param],\n     f: fn(@ast::ty) -> @ast::method\n ) -> @ast::item {\n     // All the type parameters need to bound to the trait.\n-    let trait_tps = do tps.map |tp| {\n-        let t_bound = ast::bound_trait(@{\n-            id: cx.next_id(),\n-            node: ast::ty_path(path, cx.next_id()),\n-            span: span,\n-        });\n+    let mut trait_tps = vec::append(\n+        ~[ty_param],\n+         do tps.map |tp| {\n+            let t_bound = ast::bound_trait(@{\n+                id: cx.next_id(),\n+                node: ast::ty_path(path, cx.next_id()),\n+                span: span,\n+            });\n \n-        {\n-            ident: tp.ident,\n-            id: cx.next_id(),\n-            bounds: @vec::append(~[t_bound], *tp.bounds)\n+            {\n+                ident: tp.ident,\n+                id: cx.next_id(),\n+                bounds: @vec::append(~[t_bound], *tp.bounds)\n+            }\n         }\n-    };\n+    );\n \n     let opt_trait = Some(@{\n         path: path,\n@@ -382,20 +411,37 @@ fn mk_ser_impl(\n     tps: ~[ast::ty_param],\n     body: @ast::expr\n ) -> @ast::item {\n+    // Make a path to the std::serialization::Serializable typaram.\n+    let ty_param = cx.bind_path(\n+        span,\n+        cx.ident_of(~\"__S\"),\n+        cx.path(\n+            span,\n+            ~[\n+                cx.ident_of(~\"std\"),\n+                cx.ident_of(~\"serialization\"),\n+                cx.ident_of(~\"Serializer\"),\n+            ]\n+        ),\n+        @~[]\n+    );\n+\n     // Make a path to the std::serialization::Serializable trait.\n-    let path = cx.path(\n+    let path = cx.path_tps(\n         span,\n         ~[\n             cx.ident_of(~\"std\"),\n             cx.ident_of(~\"serialization\"),\n             cx.ident_of(~\"Serializable\"),\n-        ]\n+        ],\n+        ~[cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[])]\n     );\n \n     mk_impl(\n         cx,\n         span,\n         ident,\n+        ty_param,\n         path,\n         tps,\n         |_ty| mk_ser_method(cx, span, cx.expr_blk(body))\n@@ -409,20 +455,37 @@ fn mk_deser_impl(\n     tps: ~[ast::ty_param],\n     body: @ast::expr\n ) -> @ast::item {\n+    // Make a path to the std::serialization::Deserializable typaram.\n+    let ty_param = cx.bind_path(\n+        span,\n+        cx.ident_of(~\"__D\"),\n+        cx.path(\n+            span,\n+            ~[\n+                cx.ident_of(~\"std\"),\n+                cx.ident_of(~\"serialization\"),\n+                cx.ident_of(~\"Deserializer\"),\n+            ]\n+        ),\n+        @~[]\n+    );\n+\n     // Make a path to the std::serialization::Deserializable trait.\n-    let path = cx.path(\n+    let path = cx.path_tps(\n         span,\n         ~[\n             cx.ident_of(~\"std\"),\n             cx.ident_of(~\"serialization\"),\n             cx.ident_of(~\"Deserializable\"),\n-        ]\n+        ],\n+        ~[cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[])]\n     );\n \n     mk_impl(\n         cx,\n         span,\n         ident,\n+        ty_param,\n         path,\n         tps,\n         |ty| mk_deser_method(cx, span, ty, cx.expr_blk(body))\n@@ -434,22 +497,6 @@ fn mk_ser_method(\n     span: span,\n     ser_body: ast::blk\n ) -> @ast::method {\n-    let ser_bound = cx.ty_path(\n-        span,\n-        ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialization\"),\n-            cx.ident_of(~\"Serializer\"),\n-        ],\n-        ~[]\n-    );\n-\n-    let ser_tps = ~[{\n-        ident: cx.ident_of(~\"__S\"),\n-        id: cx.next_id(),\n-        bounds: @~[ast::bound_trait(ser_bound)],\n-    }];\n-\n     let ty_s = @{\n         id: cx.next_id(),\n         node: ast::ty_rptr(\n@@ -487,7 +534,7 @@ fn mk_ser_method(\n     @{\n         ident: cx.ident_of(~\"serialize\"),\n         attrs: ~[],\n-        tps: ser_tps,\n+        tps: ~[],\n         self_ty: { node: ast::sty_region(ast::m_imm), span: span },\n         purity: ast::impure_fn,\n         decl: ser_decl,\n@@ -505,22 +552,6 @@ fn mk_deser_method(\n     ty: @ast::ty,\n     deser_body: ast::blk\n ) -> @ast::method {\n-    let deser_bound = cx.ty_path(\n-        span,\n-        ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialization\"),\n-            cx.ident_of(~\"Deserializer\"),\n-        ],\n-        ~[]\n-    );\n-\n-    let deser_tps = ~[{\n-        ident: cx.ident_of(~\"__D\"),\n-        id: cx.next_id(),\n-        bounds: @~[ast::bound_trait(deser_bound)],\n-    }];\n-\n     let ty_d = @{\n         id: cx.next_id(),\n         node: ast::ty_rptr(\n@@ -552,7 +583,7 @@ fn mk_deser_method(\n     @{\n         ident: cx.ident_of(~\"deserialize\"),\n         attrs: ~[],\n-        tps: deser_tps,\n+        tps: ~[],\n         self_ty: { node: ast::sty_static, span: span },\n         purity: ast::impure_fn,\n         decl: deser_decl,"}, {"sha": "b63d1dcab7ec8367cac60881ca0d79c62f8da464", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=ab89b5c294ac511d4d58809f9f20dfe4f2c8fe52", "patch": "@@ -9,18 +9,22 @@ use io::Writer;\n use std::serialization::{Serializable, Deserializable, deserialize};\n use std::prettyprint;\n \n-fn test_ser_and_deser<A:Eq Serializable Deserializable>(\n-    a1: &A,\n-    +expected: ~str\n+fn test_prettyprint<A: Serializable<prettyprint::Serializer>>(\n+    a: &A,\n+    expected: &~str\n ) {\n-    // check the pretty printer:\n     let s = do io::with_str_writer |w| {\n-        a1.serialize(&prettyprint::Serializer(w))\n+        a.serialize(&prettyprint::Serializer(w))\n     };\n     debug!(\"s == %?\", s);\n-    assert s == expected;\n+    assert s == *expected;\n+}\n \n-    // check the EBML serializer:\n+fn test_ebml<A:\n+    Eq\n+    Serializable<ebml::Serializer>\n+    Deserializable<ebml::Deserializer>\n+>(a1: &A) {\n     let bytes = do io::with_bytes_writer |wr| {\n         let ebml_w = &ebml::Serializer(wr);\n         a1.serialize(ebml_w)\n@@ -140,24 +144,40 @@ enum Quark<T> {\n enum CLike { A, B, C }\n \n fn main() {\n-    test_ser_and_deser(&Plus(@Minus(@Val(3u), @Val(10u)),\n-                             @Plus(@Val(22u), @Val(5u))),\n-                       ~\"Plus(@Minus(@Val(3u), @Val(10u)), \\\n-                        @Plus(@Val(22u), @Val(5u)))\");\n-\n-    test_ser_and_deser(&{lo: 0u, hi: 5u, node: 22u},\n-                       ~\"{lo: 0u, hi: 5u, node: 22u}\");\n-\n-    test_ser_and_deser(&AnEnum({v: ~[1u, 2u, 3u]}),\n-                       ~\"AnEnum({v: ~[1u, 2u, 3u]})\");\n-\n-    test_ser_and_deser(&Point {x: 3u, y: 5u}, ~\"Point {x: 3u, y: 5u}\");\n-\n-    test_ser_and_deser(&@[1u, 2u, 3u], ~\"@[1u, 2u, 3u]\");\n-\n-    test_ser_and_deser(&Top(22u), ~\"Top(22u)\");\n-    test_ser_and_deser(&Bottom(222u), ~\"Bottom(222u)\");\n-\n-    test_ser_and_deser(&A, ~\"A\");\n-    test_ser_and_deser(&B, ~\"B\");\n+    let a = &Plus(@Minus(@Val(3u), @Val(10u)), @Plus(@Val(22u), @Val(5u)));\n+    test_prettyprint(a, &~\"Plus(@Minus(@Val(3u), @Val(10u)), \\\n+                           @Plus(@Val(22u), @Val(5u)))\");\n+    test_ebml(a);\n+\n+    let a = &{lo: 0u, hi: 5u, node: 22u};\n+    test_prettyprint(a, &~\"{lo: 0u, hi: 5u, node: 22u}\");\n+    test_ebml(a);\n+\n+    let a = &AnEnum({v: ~[1u, 2u, 3u]});\n+    test_prettyprint(a, &~\"AnEnum({v: ~[1u, 2u, 3u]})\");\n+    test_ebml(a);\n+\n+    let a = &Point {x: 3u, y: 5u};\n+    test_prettyprint(a, &~\"Point {x: 3u, y: 5u}\");\n+    test_ebml(a);\n+\n+    let a = &@[1u, 2u, 3u];\n+    test_prettyprint(a, &~\"@[1u, 2u, 3u]\");\n+    test_ebml(a);\n+\n+    let a = &Top(22u);\n+    test_prettyprint(a, &~\"Top(22u)\");\n+    test_ebml(a);\n+\n+    let a = &Bottom(222u);\n+    test_prettyprint(a, &~\"Bottom(222u)\");\n+    test_ebml(a);\n+\n+    let a = &A;\n+    test_prettyprint(a, &~\"A\");\n+    test_ebml(a);\n+\n+    let a = &B;\n+    test_prettyprint(a, &~\"B\");\n+    test_ebml(a);\n }"}]}