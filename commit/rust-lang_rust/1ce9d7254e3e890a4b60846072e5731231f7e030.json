{"sha": "1ce9d7254e3e890a4b60846072e5731231f7e030", "node_id": "C_kwDOAAsO6NoAKDFjZTlkNzI1NGUzZTg5MGE0YjYwODQ2MDcyZTU3MzEyMzFmN2UwMzA", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-04-27T00:53:06Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-04-27T00:53:06Z"}, "message": "Migrate trivially translatable `rustc_parse` diagnostics", "tree": {"sha": "791d54cdd067a4b7d48f49c93a682a8d5cce8a52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/791d54cdd067a4b7d48f49c93a682a8d5cce8a52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ce9d7254e3e890a4b60846072e5731231f7e030", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ce9d7254e3e890a4b60846072e5731231f7e030", "html_url": "https://github.com/rust-lang/rust/commit/1ce9d7254e3e890a4b60846072e5731231f7e030", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ce9d7254e3e890a4b60846072e5731231f7e030/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c42cb4ef0544fbfaa500216e53382d6b079c001", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c42cb4ef0544fbfaa500216e53382d6b079c001", "html_url": "https://github.com/rust-lang/rust/commit/1c42cb4ef0544fbfaa500216e53382d6b079c001"}], "stats": {"total": 674, "additions": 443, "deletions": 231}, "files": [{"sha": "3ed342ce48b43194ab30a70997f5c2b5d34536df", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -2976,7 +2976,7 @@ pub enum ItemKind {\n }\n \n impl ItemKind {\n-    pub fn article(&self) -> &str {\n+    pub fn article(&self) -> &'static str {\n         use ItemKind::*;\n         match self {\n             Use(..) | Static(..) | Const(..) | Fn(..) | Mod(..) | GlobalAsm(..) | TyAlias(..)\n@@ -2985,7 +2985,7 @@ impl ItemKind {\n         }\n     }\n \n-    pub fn descr(&self) -> &str {\n+    pub fn descr(&self) -> &'static str {\n         match self {\n             ItemKind::ExternCrate(..) => \"extern crate\",\n             ItemKind::Use(..) => \"`use` import\","}, {"sha": "9c4fac84fc294f0c40e6780b7e7afbbdeefd5a84", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -772,3 +772,75 @@ parse_const_bounds_missing_tilde = const bounds must start with `~`\n     .suggestion = add `~`\n \n parse_underscore_literal_suffix = underscore literal suffix is not allowed\n+\n+parse_expect_label_found_ident = expected a label, found an identifier\n+    .suggestion = labels start with a tick\n+\n+parse_inappropriate_default = {$article} {$descr} cannot be `default`\n+    .label = `default` because of this\n+    .note = only associated `fn`, `const`, and `type` items can be `default`\n+\n+parse_recover_import_as_use = expected item, found {$token_name}\n+    .suggestion = items are imported using the `use` keyword\n+\n+parse_single_colon_import_path = expected `::`, found `:`\n+    .suggestion = use double colon\n+    .note = import paths are delimited using `::`\n+\n+parse_bad_item_kind = {$descr} is not supported in {$ctx}\n+    .help = consider moving the {$descr} out to a nearby module scope\n+\n+parse_single_colon_struct_type = found single colon in a struct field type path\n+    .suggestion = write a path separator here\n+\n+parse_equals_struct_default = default values on `struct` fields aren't supported\n+    .suggestion = remove this unsupported default value\n+\n+parse_macro_rules_missing_bang = expected `!` after `macro_rules`\n+    .suggestion = add a `!`\n+\n+parse_macro_name_remove_bang = macro names aren't followed by a `!`\n+    .suggestion = remove the `!`\n+\n+parse_macro_rules_visibility = can't qualify macro_rules invocation with `{$vis}`\n+    .suggestion = try exporting the macro\n+\n+parse_macro_invocation_visibility = can't qualify macro invocation with `pub`\n+    .suggestion = remove the visibility\n+    .help = try adjusting the macro to put `{$vis}` inside the invocation\n+\n+parse_nested_adt = `{$kw_str}` definition cannot be nested inside `{$keyword}`\n+    .suggestion = consider creating a new `{$kw_str}` definition instead of nesting\n+\n+parse_function_body_equals_expr = function body cannot be `= expression;`\n+    .suggestion = surround the expression with `{\"{\"}` and `{\"}\"}` instead of `=` and `;`\n+\n+parse_box_not_pat = expected pattern, found {$descr}\n+    .note = `box` is a reserved keyword\n+    .suggestion = escape `box` to use it as an identifier\n+\n+parse_unmatched_angle = unmatched angle {$plural ->\n+    [true] brackets\n+    *[false] bracket\n+    }\n+    .suggestion = remove extra angle {$plural ->\n+    [true] brackets\n+    *[false] bracket\n+    }\n+\n+parse_missing_plus_in_bounds = expected `+` between lifetime and {$sym}\n+    .suggestion = add `+`\n+\n+parse_incorrect_braces_trait_bounds = incorrect braces around trait bounds\n+    .suggestion = remove the parentheses\n+\n+parse_kw_bad_case = keyword `{$kw}` is written in the wrong case\n+    .suggestion = write it in the correct case\n+\n+parse_meta_bad_delim = wrong meta list delimiters\n+parse_cfg_attr_bad_delim = wrong `cfg_attr` delimiters\n+parse_meta_bad_delim_suggestion = the delimiters should be `(` and `)`\n+\n+parse_malformed_cfg_attr = malformed `cfg_attr` attribute input\n+    .suggestion = missing condition and attribute\n+    .note = for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>"}, {"sha": "f286707a9c0df5621e5b265c4c209ec1db99d5fd", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -2421,3 +2421,227 @@ pub(crate) struct UnderscoreLiteralSuffix {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expect_label_found_ident)]\n+pub(crate) struct ExpectedLabelFoundIdent {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"'\", applicability = \"machine-applicable\", style = \"short\")]\n+    pub start: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_inappropriate_default)]\n+#[note]\n+pub(crate) struct InappropriateDefault {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub article: &'static str,\n+    pub descr: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_recover_import_as_use)]\n+pub(crate) struct RecoverImportAsUse {\n+    #[primary_span]\n+    #[suggestion(code = \"use\", applicability = \"machine-applicable\", style = \"short\")]\n+    pub span: Span,\n+    pub token_name: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_single_colon_import_path)]\n+#[note]\n+pub(crate) struct SingleColonImportPath {\n+    #[primary_span]\n+    #[suggestion(code = \"::\", applicability = \"machine-applicable\", style = \"short\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_bad_item_kind)]\n+#[help]\n+pub(crate) struct BadItemKind {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: &'static str,\n+    pub ctx: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_single_colon_struct_type)]\n+pub(crate) struct SingleColonStructType {\n+    #[primary_span]\n+    #[suggestion(code = \"::\", applicability = \"maybe-incorrect\", style = \"verbose\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_equals_struct_default)]\n+pub(crate) struct EqualsStructDefault {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_macro_rules_missing_bang)]\n+pub(crate) struct MacroRulesMissingBang {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"!\", applicability = \"machine-applicable\", style = \"verbose\")]\n+    pub hi: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_macro_name_remove_bang)]\n+pub(crate) struct MacroNameRemoveBang {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_macro_rules_visibility)]\n+pub(crate) struct MacroRulesVisibility<'a> {\n+    #[primary_span]\n+    #[suggestion(code = \"#[macro_export]\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+    pub vis: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_macro_invocation_visibility)]\n+#[help]\n+pub(crate) struct MacroInvocationVisibility<'a> {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub vis: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_nested_adt)]\n+pub(crate) struct NestedAdt<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub item: Span,\n+    pub keyword: &'a str,\n+    pub kw_str: Cow<'a, str>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_function_body_equals_expr)]\n+pub(crate) struct FunctionBodyEqualsExpr {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: FunctionBodyEqualsExprSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parse_suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct FunctionBodyEqualsExprSugg {\n+    #[suggestion_part(code = \"{{\")]\n+    pub eq: Span,\n+    #[suggestion_part(code = \" }}\")]\n+    pub semi: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_box_not_pat)]\n+pub(crate) struct BoxNotPat {\n+    #[primary_span]\n+    pub span: Span,\n+    #[note]\n+    pub kw: Span,\n+    #[suggestion(code = \"r#\", applicability = \"maybe-incorrect\", style = \"verbose\")]\n+    pub lo: Span,\n+    pub descr: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unmatched_angle)]\n+pub(crate) struct UnmatchedAngle {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub plural: bool,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_missing_plus_in_bounds)]\n+pub(crate) struct MissingPlusBounds {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" +\", applicability = \"maybe-incorrect\", style = \"verbose\")]\n+    pub hi: Span,\n+    pub sym: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_incorrect_braces_trait_bounds)]\n+pub(crate) struct IncorrectBracesTraitBounds {\n+    #[primary_span]\n+    pub span: Vec<Span>,\n+    #[subdiagnostic]\n+    pub sugg: IncorrectBracesTraitBoundsSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parse_suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct IncorrectBracesTraitBoundsSugg {\n+    #[suggestion_part(code = \" \")]\n+    pub l: Span,\n+    #[suggestion_part(code = \"\")]\n+    pub r: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_kw_bad_case)]\n+pub(crate) struct KwBadCase<'a> {\n+    #[primary_span]\n+    #[suggestion(code = \"{kw}\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub kw: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_meta_bad_delim)]\n+pub(crate) struct MetaBadDelim {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: MetaBadDelimSugg,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_cfg_attr_bad_delim)]\n+pub(crate) struct CfgAttrBadDelim {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: MetaBadDelimSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parse_meta_bad_delim_suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct MetaBadDelimSugg {\n+    #[suggestion_part(code = \"(\")]\n+    pub open: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub close: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_malformed_cfg_attr)]\n+#[note]\n+pub(crate) struct MalformedCfgAttr {\n+    #[primary_span]\n+    #[suggestion(code = \"{sugg}\")]\n+    pub span: Span,\n+    pub sugg: &'static str,\n+}"}, {"sha": "61a1cdeb540e940f63c931e96b9b1022c0500cd4", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -18,7 +18,7 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::{AttrItem, Attribute, MetaItem};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, Diagnostic, FatalError, Level, PResult};\n+use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_fluent_macro::fluent_messages;\n use rustc_session::parse::ParseSess;\n@@ -243,8 +243,7 @@ pub fn parse_cfg_attr(\n         ast::AttrArgs::Delimited(ast::DelimArgs { dspan, delim, ref tokens })\n             if !tokens.is_empty() =>\n         {\n-            let msg = \"wrong `cfg_attr` delimiters\";\n-            crate::validate_attr::check_meta_bad_delim(parse_sess, dspan, delim, msg);\n+            crate::validate_attr::check_cfg_attr_bad_delim(parse_sess, dspan, delim);\n             match parse_in(parse_sess, tokens.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n                 Ok(r) => return Some(r),\n                 Err(mut e) => {\n@@ -265,15 +264,5 @@ const CFG_ATTR_NOTE_REF: &str = \"for more information, visit \\\n     #the-cfg_attr-attribute>\";\n \n fn error_malformed_cfg_attr_missing(span: Span, parse_sess: &ParseSess) {\n-    parse_sess\n-        .span_diagnostic\n-        .struct_span_err(span, \"malformed `cfg_attr` attribute input\")\n-        .span_suggestion(\n-            span,\n-            \"missing condition and attribute\",\n-            CFG_ATTR_GRAMMAR_HELP,\n-            Applicability::HasPlaceholders,\n-        )\n-        .note(CFG_ATTR_NOTE_REF)\n-        .emit();\n+    parse_sess.emit_err(errors::MalformedCfgAttr { span, sugg: CFG_ATTR_GRAMMAR_HELP });\n }"}, {"sha": "27de9bd72685fbc02fa697adc12b67be44135dda", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -3151,14 +3151,10 @@ impl<'a> Parser<'a> {\n         let label = format!(\"'{}\", ident.name);\n         let ident = Ident { name: Symbol::intern(&label), span: ident.span };\n \n-        self.struct_span_err(ident.span, \"expected a label, found an identifier\")\n-            .span_suggestion(\n-                ident.span,\n-                \"labels start with a tick\",\n-                label,\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(errors::ExpectedLabelFoundIdent {\n+            span: ident.span,\n+            start: ident.span.shrink_to_lo(),\n+        });\n \n         Label { ident }\n     }"}, {"sha": "9e003bfc09747727ad8e9ef812f84a751328309c", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 29, "deletions": 90, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -181,11 +181,11 @@ impl<'a> Parser<'a> {\n     /// Error in-case `default` was parsed in an in-appropriate context.\n     fn error_on_unconsumed_default(&self, def: Defaultness, kind: &ItemKind) {\n         if let Defaultness::Default(span) = def {\n-            let msg = format!(\"{} {} cannot be `default`\", kind.article(), kind.descr());\n-            self.struct_span_err(span, &msg)\n-                .span_label(span, \"`default` because of this\")\n-                .note(\"only associated `fn`, `const`, and `type` items can be `default`\")\n-                .emit();\n+            self.sess.emit_err(errors::InappropriateDefault {\n+                span,\n+                article: kind.article(),\n+                descr: kind.descr(),\n+            });\n         }\n     }\n \n@@ -310,14 +310,7 @@ impl<'a> Parser<'a> {\n         self.bump();\n         match self.parse_use_item() {\n             Ok(u) => {\n-                self.struct_span_err(span, format!(\"expected item, found {token_name}\"))\n-                    .span_suggestion_short(\n-                        span,\n-                        \"items are imported using the `use` keyword\",\n-                        \"use\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.sess.emit_err(errors::RecoverImportAsUse { span, token_name });\n                 Ok(Some(u))\n             }\n             Err(e) => {\n@@ -963,15 +956,8 @@ impl<'a> Parser<'a> {\n             } else {\n                 // Recover from using a colon as path separator.\n                 while self.eat_noexpect(&token::Colon) {\n-                    self.struct_span_err(self.prev_token.span, \"expected `::`, found `:`\")\n-                        .span_suggestion_short(\n-                            self.prev_token.span,\n-                            \"use double colon\",\n-                            \"::\",\n-                            Applicability::MachineApplicable,\n-                        )\n-                        .note_once(\"import paths are delimited using `::`\")\n-                        .emit();\n+                    self.sess\n+                        .emit_err(errors::SingleColonImportPath { span: self.prev_token.span });\n \n                     // We parse the rest of the path and append it to the original prefix.\n                     self.parse_path_segments(&mut prefix.segments, PathStyle::Mod, None)?;\n@@ -1134,13 +1120,11 @@ impl<'a> Parser<'a> {\n         ))\n     }\n \n-    fn error_bad_item_kind<T>(&self, span: Span, kind: &ItemKind, ctx: &str) -> Option<T> {\n+    fn error_bad_item_kind<T>(&self, span: Span, kind: &ItemKind, ctx: &'static str) -> Option<T> {\n         // FIXME(#100717): needs variant for each `ItemKind` (instead of using `ItemKind::descr()`)\n         let span = self.sess.source_map().guess_head_span(span);\n         let descr = kind.descr();\n-        self.struct_span_err(span, &format!(\"{descr} is not supported in {ctx}\"))\n-            .help(&format!(\"consider moving the {descr} out to a nearby module scope\"))\n-            .emit();\n+        self.sess.emit_err(errors::BadItemKind { span, descr, ctx });\n         None\n     }\n \n@@ -1713,27 +1697,13 @@ impl<'a> Parser<'a> {\n         self.expect_field_ty_separator()?;\n         let ty = self.parse_ty()?;\n         if self.token.kind == token::Colon && self.look_ahead(1, |tok| tok.kind != token::Colon) {\n-            self.struct_span_err(self.token.span, \"found single colon in a struct field type path\")\n-                .span_suggestion_verbose(\n-                    self.token.span,\n-                    \"write a path separator here\",\n-                    \"::\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.sess.emit_err(errors::SingleColonStructType { span: self.token.span });\n         }\n         if self.token.kind == token::Eq {\n             self.bump();\n             let const_expr = self.parse_expr_anon_const()?;\n             let sp = ty.span.shrink_to_hi().to(const_expr.value.span);\n-            self.struct_span_err(sp, \"default values on `struct` fields aren't supported\")\n-                .span_suggestion(\n-                    sp,\n-                    \"remove this unsupported default value\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(errors::EqualsStructDefault { span: sp });\n         }\n         Ok(FieldDef {\n             span: lo.to(self.prev_token.span),\n@@ -1871,14 +1841,10 @@ impl<'a> Parser<'a> {\n                 return IsMacroRulesItem::Yes { has_bang: true };\n             } else if self.look_ahead(1, |t| (t.is_ident())) {\n                 // macro_rules foo\n-                self.struct_span_err(macro_rules_span, \"expected `!` after `macro_rules`\")\n-                    .span_suggestion(\n-                        macro_rules_span,\n-                        \"add a `!`\",\n-                        \"macro_rules!\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.sess.emit_err(errors::MacroRulesMissingBang {\n+                    span: macro_rules_span,\n+                    hi: macro_rules_span.shrink_to_hi(),\n+                });\n \n                 return IsMacroRulesItem::Yes { has_bang: false };\n             }\n@@ -1903,9 +1869,7 @@ impl<'a> Parser<'a> {\n         if self.eat(&token::Not) {\n             // Handle macro_rules! foo!\n             let span = self.prev_token.span;\n-            self.struct_span_err(span, \"macro names aren't followed by a `!`\")\n-                .span_suggestion(span, \"remove the `!`\", \"\", Applicability::MachineApplicable)\n-                .emit();\n+            self.sess.emit_err(errors::MacroNameRemoveBang { span });\n         }\n \n         let body = self.parse_delim_args()?;\n@@ -1925,25 +1889,9 @@ impl<'a> Parser<'a> {\n         let vstr = pprust::vis_to_string(vis);\n         let vstr = vstr.trim_end();\n         if macro_rules {\n-            let msg = format!(\"can't qualify macro_rules invocation with `{vstr}`\");\n-            self.struct_span_err(vis.span, &msg)\n-                .span_suggestion(\n-                    vis.span,\n-                    \"try exporting the macro\",\n-                    \"#[macro_export]\",\n-                    Applicability::MaybeIncorrect, // speculative\n-                )\n-                .emit();\n+            self.sess.emit_err(errors::MacroRulesVisibility { span: vis.span, vis: vstr });\n         } else {\n-            self.struct_span_err(vis.span, \"can't qualify macro invocation with `pub`\")\n-                .span_suggestion(\n-                    vis.span,\n-                    \"remove the visibility\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .help(&format!(\"try adjusting the macro to put `{vstr}` inside the invocation\"))\n-                .emit();\n+            self.sess.emit_err(errors::MacroInvocationVisibility { span: vis.span, vis: vstr });\n         }\n     }\n \n@@ -1989,18 +1937,12 @@ impl<'a> Parser<'a> {\n             let kw_token = self.token.clone();\n             let kw_str = pprust::token_to_string(&kw_token);\n             let item = self.parse_item(ForceCollect::No)?;\n-\n-            self.struct_span_err(\n-                kw_token.span,\n-                &format!(\"`{kw_str}` definition cannot be nested inside `{keyword}`\"),\n-            )\n-            .span_suggestion(\n-                item.unwrap().span,\n-                &format!(\"consider creating a new `{kw_str}` definition instead of nesting\"),\n-                \"\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+            self.sess.emit_err(errors::NestedAdt {\n+                span: kw_token.span,\n+                item: item.unwrap().span,\n+                kw_str,\n+                keyword: keyword.as_str(),\n+            });\n             // We successfully parsed the item but we must inform the caller about nested problem.\n             return Ok(false);\n         }\n@@ -2139,13 +2081,10 @@ impl<'a> Parser<'a> {\n             let _ = self.parse_expr()?;\n             self.expect_semi()?; // `;`\n             let span = eq_sp.to(self.prev_token.span);\n-            self.struct_span_err(span, \"function body cannot be `= expression;`\")\n-                .multipart_suggestion(\n-                    \"surround the expression with `{` and `}` instead of `=` and `;`\",\n-                    vec![(eq_sp, \"{\".to_string()), (self.prev_token.span, \" }\".to_string())],\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(errors::FunctionBodyEqualsExpr {\n+                span,\n+                sugg: errors::FunctionBodyEqualsExprSugg { eq: eq_sp, semi: self.prev_token.span },\n+            });\n             (AttrVec::new(), Some(self.mk_block_err(span)))\n         } else {\n             let expected = if req_body {"}, {"sha": "1c34e491f210ead9703f6faf266cb4939a822c4c", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -43,7 +43,7 @@ use thin_vec::ThinVec;\n use tracing::debug;\n \n use crate::errors::{\n-    IncorrectVisibilityRestriction, MismatchedClosingDelimiter, NonStringAbiLiteral,\n+    self, IncorrectVisibilityRestriction, MismatchedClosingDelimiter, NonStringAbiLiteral,\n };\n \n bitflags::bitflags! {\n@@ -663,15 +663,10 @@ impl<'a> Parser<'a> {\n         if case == Case::Insensitive\n         && let Some((ident, /* is_raw */ false)) = self.token.ident()\n         && ident.as_str().to_lowercase() == kw.as_str().to_lowercase() {\n-            self\n-                .struct_span_err(ident.span, format!(\"keyword `{kw}` is written in a wrong case\"))\n-                .span_suggestion(\n-                    ident.span,\n-                    \"write it in the correct case\",\n-                    kw,\n-                    Applicability::MachineApplicable\n-                ).emit();\n-\n+            self.sess.emit_err(errors::KwBadCase {\n+                span: ident.span,\n+                kw: kw.as_str()\n+            });\n             self.bump();\n             return true;\n         }"}, {"sha": "f2422fe307c5fd6c38cd886a9da98f392ed1afda", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -1,6 +1,6 @@\n use super::{ForceCollect, Parser, PathStyle, TrailingToken};\n use crate::errors::{\n-    AmbiguousRangePattern, DotDotDotForRemainingFields, DotDotDotRangeToPatternNotAllowed,\n+    self, AmbiguousRangePattern, DotDotDotForRemainingFields, DotDotDotRangeToPatternNotAllowed,\n     DotDotDotRestPattern, EnumPatternInsteadOfIdentifier, ExpectedBindingLeftOfAt,\n     ExpectedCommaAfterPatternField, InclusiveRangeExtraEquals, InclusiveRangeMatchArrow,\n     InclusiveRangeNoEnd, InvalidMutInPattern, PatternOnWrongSideOfAt, RefMutOrderIncorrect,\n@@ -908,18 +908,13 @@ impl<'a> Parser<'a> {\n         let box_span = self.prev_token.span;\n \n         if self.isnt_pattern_start() {\n-            self.struct_span_err(\n-                self.token.span,\n-                format!(\"expected pattern, found {}\", super::token_descr(&self.token)),\n-            )\n-            .span_note(box_span, \"`box` is a reserved keyword\")\n-            .span_suggestion_verbose(\n-                box_span.shrink_to_lo(),\n-                \"escape `box` to use it as an identifier\",\n-                \"r#\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+            let descr = super::token_descr(&self.token);\n+            self.sess.emit_err(errors::BoxNotPat {\n+                span: self.token.span,\n+                kw: box_span,\n+                lo: box_span.shrink_to_lo(),\n+                descr,\n+            });\n \n             // We cannot use `parse_pat_ident()` since it will complain `box`\n             // is not an identifier."}, {"sha": "ae73760bd8cab28c9a7b92ae463d6bd0f6f9a23f", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::{\n     AssocConstraintKind, BlockCheckMode, GenericArg, GenericArgs, Generics, ParenthesizedArgs,\n     Path, PathSegment, QSelf,\n };\n-use rustc_errors::{pluralize, Applicability, PResult};\n+use rustc_errors::{Applicability, PResult};\n use rustc_span::source_map::{BytePos, Span};\n use rustc_span::symbol::{kw, sym, Ident};\n use std::mem;\n@@ -464,23 +464,10 @@ impl<'a> Parser<'a> {\n                     // i.e. no multibyte characters, in this range.\n                     let span =\n                         lo.with_hi(lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count));\n-                    self.struct_span_err(\n+                    self.sess.emit_err(errors::UnmatchedAngle {\n                         span,\n-                        &format!(\n-                            \"unmatched angle bracket{}\",\n-                            pluralize!(snapshot.unmatched_angle_bracket_count)\n-                        ),\n-                    )\n-                    .span_suggestion(\n-                        span,\n-                        &format!(\n-                            \"remove extra angle bracket{}\",\n-                            pluralize!(snapshot.unmatched_angle_bracket_count)\n-                        ),\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                        plural: snapshot.unmatched_angle_bracket_count > 1,\n+                    });\n \n                     // Try again without unmatched angle bracket characters.\n                     self.parse_angle_args(ty_generics)"}, {"sha": "3ceb3a2bef16e57f0ab2cee56314583031556dff", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -588,20 +588,14 @@ impl<'a> Parser<'a> {\n         // Always parse bounds greedily for better error recovery.\n         if self.token.is_lifetime() {\n             self.look_ahead(1, |t| {\n-                if let token::Ident(symname, _) = t.kind {\n+                if let token::Ident(sym, _) = t.kind {\n                     // parse pattern with \"'a Sized\" we're supposed to give suggestion like\n                     // \"'a + Sized\"\n-                    self.struct_span_err(\n-                        self.token.span,\n-                        &format!(\"expected `+` between lifetime and {}\", symname),\n-                    )\n-                    .span_suggestion_verbose(\n-                        self.token.span.shrink_to_hi(),\n-                        \"add `+`\",\n-                        \" +\",\n-                        Applicability::MaybeIncorrect,\n-                    )\n-                    .emit();\n+                    self.sess.emit_err(errors::MissingPlusBounds {\n+                        span: self.token.span,\n+                        hi: self.token.span.shrink_to_hi(),\n+                        sym,\n+                    });\n                 }\n             })\n         }\n@@ -926,14 +920,10 @@ impl<'a> Parser<'a> {\n                 self.parse_remaining_bounds(bounds, true)?;\n                 self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n                 let sp = vec![lo, self.prev_token.span];\n-                let sugg = vec![(lo, String::from(\" \")), (self.prev_token.span, String::new())];\n-                self.struct_span_err(sp, \"incorrect braces around trait bounds\")\n-                    .multipart_suggestion(\n-                        \"remove the parentheses\",\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.sess.emit_err(errors::IncorrectBracesTraitBounds {\n+                    span: sp,\n+                    sugg: errors::IncorrectBracesTraitBoundsSugg { l: lo, r: self.prev_token.span },\n+                });\n             } else {\n                 self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n             }"}, {"sha": "815b7c8567918d0695c8c74aa5c3534c3b587fca", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -1,6 +1,6 @@\n //! Meta-syntax validation logic of attributes for post-expansion.\n \n-use crate::parse_in;\n+use crate::{errors, parse_in};\n \n use rustc_ast::tokenstream::DelimSpan;\n use rustc_ast::MetaItemKind;\n@@ -45,7 +45,7 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n         kind: match &item.args {\n             AttrArgs::Empty => MetaItemKind::Word,\n             AttrArgs::Delimited(DelimArgs { dspan, delim, tokens }) => {\n-                check_meta_bad_delim(sess, *dspan, *delim, \"wrong meta list delimiters\");\n+                check_meta_bad_delim(sess, *dspan, *delim);\n                 let nmis = parse_in(sess, tokens.clone(), \"meta list\", |p| p.parse_meta_seq_top())?;\n                 MetaItemKind::List(nmis)\n             }\n@@ -84,19 +84,24 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n     })\n }\n \n-pub fn check_meta_bad_delim(sess: &ParseSess, span: DelimSpan, delim: MacDelimiter, msg: &str) {\n+pub fn check_meta_bad_delim(sess: &ParseSess, span: DelimSpan, delim: MacDelimiter) {\n     if let ast::MacDelimiter::Parenthesis = delim {\n         return;\n     }\n+    sess.emit_err(errors::MetaBadDelim {\n+        span: span.entire(),\n+        sugg: errors::MetaBadDelimSugg { open: span.open, close: span.close },\n+    });\n+}\n \n-    sess.span_diagnostic\n-        .struct_span_err(span.entire(), msg)\n-        .multipart_suggestion(\n-            \"the delimiters should be `(` and `)`\",\n-            vec![(span.open, \"(\".to_string()), (span.close, \")\".to_string())],\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+pub fn check_cfg_attr_bad_delim(sess: &ParseSess, span: DelimSpan, delim: MacDelimiter) {\n+    if let ast::MacDelimiter::Parenthesis = delim {\n+        return;\n+    }\n+    sess.emit_err(errors::CfgAttrBadDelim {\n+        span: span.entire(),\n+        sugg: errors::MetaBadDelimSugg { open: span.open, close: span.close },\n+    });\n }\n \n /// Checks that the given meta-item is compatible with this `AttributeTemplate`."}, {"sha": "aa78c9a6906438837aa34315966dcc9e0dc6ee89", "filename": "tests/ui/macros/missing-bang-in-decl.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/tests%2Fui%2Fmacros%2Fmissing-bang-in-decl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/tests%2Fui%2Fmacros%2Fmissing-bang-in-decl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fmissing-bang-in-decl.stderr?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -2,13 +2,23 @@ error: expected `!` after `macro_rules`\n   --> $DIR/missing-bang-in-decl.rs:5:1\n    |\n LL | macro_rules foo {\n-   | ^^^^^^^^^^^ help: add a `!`: `macro_rules!`\n+   | ^^^^^^^^^^^\n+   |\n+help: add a `!`\n+   |\n+LL | macro_rules! foo {\n+   |            +\n \n error: expected `!` after `macro_rules`\n   --> $DIR/missing-bang-in-decl.rs:10:1\n    |\n LL | macro_rules bar! {\n-   | ^^^^^^^^^^^ help: add a `!`: `macro_rules!`\n+   | ^^^^^^^^^^^\n+   |\n+help: add a `!`\n+   |\n+LL | macro_rules! bar! {\n+   |            +\n \n error: macro names aren't followed by a `!`\n   --> $DIR/missing-bang-in-decl.rs:10:16"}, {"sha": "4b99537fbf7f4e88816f0fb5b9c4146d8bd0de8e", "filename": "tests/ui/parser/item-kw-case-mismatch.fixed", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.fixed?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -4,31 +4,31 @@\n \n fn main() {}\n \n-use std::ptr::read;  //~ ERROR keyword `use` is written in a wrong case\n-use std::ptr::write; //~ ERROR keyword `use` is written in a wrong case\n+use std::ptr::read;  //~ ERROR keyword `use` is written in the wrong case\n+use std::ptr::write; //~ ERROR keyword `use` is written in the wrong case\n \n async fn _a() {}\n-//~^ ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `fn` is written in the wrong case\n \n fn _b() {}\n-//~^ ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `fn` is written in the wrong case\n \n async fn _c() {}\n-//~^ ERROR keyword `async` is written in a wrong case\n-//~| ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `async` is written in the wrong case\n+//~| ERROR keyword `fn` is written in the wrong case\n \n async fn _d() {}\n-//~^ ERROR keyword `async` is written in a wrong case\n+//~^ ERROR keyword `async` is written in the wrong case\n \n const unsafe fn _e() {}\n-//~^ ERROR keyword `const` is written in a wrong case\n-//~| ERROR keyword `unsafe` is written in a wrong case\n-//~| ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `const` is written in the wrong case\n+//~| ERROR keyword `unsafe` is written in the wrong case\n+//~| ERROR keyword `fn` is written in the wrong case\n \n unsafe extern fn _f() {}\n-//~^ ERROR keyword `unsafe` is written in a wrong case\n-//~| ERROR keyword `extern` is written in a wrong case\n+//~^ ERROR keyword `unsafe` is written in the wrong case\n+//~| ERROR keyword `extern` is written in the wrong case\n \n extern \"C\" fn _g() {}\n-//~^ ERROR keyword `extern` is written in a wrong case\n-//~| ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `extern` is written in the wrong case\n+//~| ERROR keyword `fn` is written in the wrong case"}, {"sha": "b11ec93754fc5808bb091e7d49aeda5a84813198", "filename": "tests/ui/parser/item-kw-case-mismatch.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.rs?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -4,31 +4,31 @@\n \n fn main() {}\n \n-Use std::ptr::read;  //~ ERROR keyword `use` is written in a wrong case\n-USE std::ptr::write; //~ ERROR keyword `use` is written in a wrong case\n+Use std::ptr::read;  //~ ERROR keyword `use` is written in the wrong case\n+USE std::ptr::write; //~ ERROR keyword `use` is written in the wrong case\n \n async Fn _a() {}\n-//~^ ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `fn` is written in the wrong case\n \n Fn _b() {}\n-//~^ ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `fn` is written in the wrong case\n \n aSYNC fN _c() {}\n-//~^ ERROR keyword `async` is written in a wrong case\n-//~| ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `async` is written in the wrong case\n+//~| ERROR keyword `fn` is written in the wrong case\n \n Async fn _d() {}\n-//~^ ERROR keyword `async` is written in a wrong case\n+//~^ ERROR keyword `async` is written in the wrong case\n \n CONST UNSAFE FN _e() {}\n-//~^ ERROR keyword `const` is written in a wrong case\n-//~| ERROR keyword `unsafe` is written in a wrong case\n-//~| ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `const` is written in the wrong case\n+//~| ERROR keyword `unsafe` is written in the wrong case\n+//~| ERROR keyword `fn` is written in the wrong case\n \n unSAFE EXTern fn _f() {}\n-//~^ ERROR keyword `unsafe` is written in a wrong case\n-//~| ERROR keyword `extern` is written in a wrong case\n+//~^ ERROR keyword `unsafe` is written in the wrong case\n+//~| ERROR keyword `extern` is written in the wrong case\n \n EXTERN \"C\" FN _g() {}\n-//~^ ERROR keyword `extern` is written in a wrong case\n-//~| ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `extern` is written in the wrong case\n+//~| ERROR keyword `fn` is written in the wrong case"}, {"sha": "ba59ea853633831dc5a572514ffda2921969a4ae", "filename": "tests/ui/parser/item-kw-case-mismatch.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.stderr?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -1,82 +1,82 @@\n-error: keyword `use` is written in a wrong case\n+error: keyword `use` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:7:1\n    |\n LL | Use std::ptr::read;\n    | ^^^ help: write it in the correct case (notice the capitalization): `use`\n \n-error: keyword `use` is written in a wrong case\n+error: keyword `use` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:8:1\n    |\n LL | USE std::ptr::write;\n    | ^^^ help: write it in the correct case: `use`\n \n-error: keyword `fn` is written in a wrong case\n+error: keyword `fn` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:10:7\n    |\n LL | async Fn _a() {}\n    |       ^^ help: write it in the correct case (notice the capitalization): `fn`\n \n-error: keyword `fn` is written in a wrong case\n+error: keyword `fn` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:13:1\n    |\n LL | Fn _b() {}\n    | ^^ help: write it in the correct case (notice the capitalization): `fn`\n \n-error: keyword `async` is written in a wrong case\n+error: keyword `async` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:16:1\n    |\n LL | aSYNC fN _c() {}\n    | ^^^^^ help: write it in the correct case: `async`\n \n-error: keyword `fn` is written in a wrong case\n+error: keyword `fn` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:16:7\n    |\n LL | aSYNC fN _c() {}\n    |       ^^ help: write it in the correct case: `fn`\n \n-error: keyword `async` is written in a wrong case\n+error: keyword `async` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:20:1\n    |\n LL | Async fn _d() {}\n    | ^^^^^ help: write it in the correct case: `async`\n \n-error: keyword `const` is written in a wrong case\n+error: keyword `const` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:23:1\n    |\n LL | CONST UNSAFE FN _e() {}\n    | ^^^^^ help: write it in the correct case: `const`\n \n-error: keyword `unsafe` is written in a wrong case\n+error: keyword `unsafe` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:23:7\n    |\n LL | CONST UNSAFE FN _e() {}\n    |       ^^^^^^ help: write it in the correct case: `unsafe`\n \n-error: keyword `fn` is written in a wrong case\n+error: keyword `fn` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:23:14\n    |\n LL | CONST UNSAFE FN _e() {}\n    |              ^^ help: write it in the correct case: `fn`\n \n-error: keyword `unsafe` is written in a wrong case\n+error: keyword `unsafe` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:28:1\n    |\n LL | unSAFE EXTern fn _f() {}\n    | ^^^^^^ help: write it in the correct case: `unsafe`\n \n-error: keyword `extern` is written in a wrong case\n+error: keyword `extern` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:28:8\n    |\n LL | unSAFE EXTern fn _f() {}\n    |        ^^^^^^ help: write it in the correct case: `extern`\n \n-error: keyword `extern` is written in a wrong case\n+error: keyword `extern` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:32:1\n    |\n LL | EXTERN \"C\" FN _g() {}\n    | ^^^^^^ help: write it in the correct case: `extern`\n \n-error: keyword `fn` is written in a wrong case\n+error: keyword `fn` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:32:12\n    |\n LL | EXTERN \"C\" FN _g() {}"}, {"sha": "fbd108ca613c72e34a6a33a2970d173c5b72108b", "filename": "tests/ui/parser/recover-unticked-labels.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/tests%2Fui%2Fparser%2Frecover-unticked-labels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/tests%2Fui%2Fparser%2Frecover-unticked-labels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Frecover-unticked-labels.stderr?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -2,13 +2,17 @@ error: expected a label, found an identifier\n   --> $DIR/recover-unticked-labels.rs:5:26\n    |\n LL |     'label: loop { break label 0 };\n-   |                          ^^^^^ help: labels start with a tick: `'label`\n+   |                          -^^^^\n+   |                          |\n+   |                          help: labels start with a tick\n \n error: expected a label, found an identifier\n   --> $DIR/recover-unticked-labels.rs:6:29\n    |\n LL |     'label: loop { continue label };\n-   |                             ^^^^^ help: labels start with a tick: `'label`\n+   |                             -^^^^\n+   |                             |\n+   |                             help: labels start with a tick\n \n error[E0425]: cannot find value `label` in this scope\n   --> $DIR/recover-unticked-labels.rs:4:26"}, {"sha": "bfc5374ef9d2d1e4d39e24ecc26194891d4abfb3", "filename": "tests/ui/parser/use-colon-as-mod-sep.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ce9d7254e3e890a4b60846072e5731231f7e030/tests%2Fui%2Fparser%2Fuse-colon-as-mod-sep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ce9d7254e3e890a4b60846072e5731231f7e030/tests%2Fui%2Fparser%2Fuse-colon-as-mod-sep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fuse-colon-as-mod-sep.stderr?ref=1ce9d7254e3e890a4b60846072e5731231f7e030", "patch": "@@ -11,18 +11,24 @@ error: expected `::`, found `:`\n    |\n LL | use std:fs::File;\n    |        ^ help: use double colon\n+   |\n+   = note: import paths are delimited using `::`\n \n error: expected `::`, found `:`\n   --> $DIR/use-colon-as-mod-sep.rs:7:8\n    |\n LL | use std:collections:HashMap;\n    |        ^ help: use double colon\n+   |\n+   = note: import paths are delimited using `::`\n \n error: expected `::`, found `:`\n   --> $DIR/use-colon-as-mod-sep.rs:7:20\n    |\n LL | use std:collections:HashMap;\n    |                    ^ help: use double colon\n+   |\n+   = note: import paths are delimited using `::`\n \n error: aborting due to 4 previous errors\n "}]}