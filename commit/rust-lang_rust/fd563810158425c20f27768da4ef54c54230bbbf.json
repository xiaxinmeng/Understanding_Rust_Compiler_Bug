{"sha": "fd563810158425c20f27768da4ef54c54230bbbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNTYzODEwMTU4NDI1YzIwZjI3NzY4ZGE0ZWY1NGM1NDIzMGJiYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-20T09:31:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-20T09:31:09Z"}, "message": "Auto merge of #4088 - pJunger:check1, r=oli-obk\n\nAdded lint for TryFrom for checked integer conversion.\n\nworks towards #3947\n\nAdded lint for try_from for checked integer conversion.\nShould recognize simple & straight-forward checked integer conversions.", "tree": {"sha": "857cb9591e147b8b6f3e9dac7653bca7ae911684", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/857cb9591e147b8b6f3e9dac7653bca7ae911684"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd563810158425c20f27768da4ef54c54230bbbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd563810158425c20f27768da4ef54c54230bbbf", "html_url": "https://github.com/rust-lang/rust/commit/fd563810158425c20f27768da4ef54c54230bbbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd563810158425c20f27768da4ef54c54230bbbf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbae9ed8731d7ad8a167e1a779a881812bf14197", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbae9ed8731d7ad8a167e1a779a881812bf14197", "html_url": "https://github.com/rust-lang/rust/commit/cbae9ed8731d7ad8a167e1a779a881812bf14197"}, {"sha": "565feb0bc11116671bb1b71db6fe602ef73b3ef1", "url": "https://api.github.com/repos/rust-lang/rust/commits/565feb0bc11116671bb1b71db6fe602ef73b3ef1", "html_url": "https://github.com/rust-lang/rust/commit/565feb0bc11116671bb1b71db6fe602ef73b3ef1"}], "stats": {"total": 614, "additions": 612, "deletions": 2}, "files": [{"sha": "2287b2f9d433ee99ac5a5017703b16e4432990f5", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd563810158425c20f27768da4ef54c54230bbbf/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd563810158425c20f27768da4ef54c54230bbbf/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=fd563810158425c20f27768da4ef54c54230bbbf", "patch": "@@ -872,6 +872,7 @@ All notable changes to this project will be documented in this file.\n [`char_lit_as_u8`]: https://rust-lang.github.io/rust-clippy/master/index.html#char_lit_as_u8\n [`chars_last_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_last_cmp\n [`chars_next_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_next_cmp\n+[`checked_conversions`]: https://rust-lang.github.io/rust-clippy/master/index.html#checked_conversions\n [`clone_double_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref\n [`clone_on_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy\n [`clone_on_ref_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_ref_ptr"}, {"sha": "a779d0dd1f8aebc462257efa931cc3c981ec7b46", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd563810158425c20f27768da4ef54c54230bbbf/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd563810158425c20f27768da4ef54c54230bbbf/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fd563810158425c20f27768da4ef54c54230bbbf", "patch": "@@ -7,7 +7,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 302 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are 303 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "3c335acb4d3a74952f97e5f46f6d54789145718f", "filename": "clippy_lints/src/checked_conversions.rs", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/fd563810158425c20f27768da4ef54c54230bbbf/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd563810158425c20f27768da4ef54c54230bbbf/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=fd563810158425c20f27768da4ef54c54230bbbf", "patch": "@@ -0,0 +1,341 @@\n+//! lint on manually implemented checked conversions that could be transformed into `try_from`\n+\n+use if_chain::if_chain;\n+use rustc::hir::*;\n+use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n+use rustc::{declare_lint_pass, declare_tool_lint};\n+use rustc_errors::Applicability;\n+use syntax::ast::LitKind;\n+\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for explicit bounds checking when casting.\n+    ///\n+    /// **Why is this bad?** Reduces the readability of statements & is error prone.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let foo: u32 = 5;\n+    /// # let _ =\n+    /// foo <= i32::max_value() as u32\n+    /// # ;\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// # let _ =\n+    /// i32::try_from(foo).is_ok()\n+    /// # ;\n+    /// ```\n+    pub CHECKED_CONVERSIONS,\n+    pedantic,\n+    \"`try_from` could replace manual bounds checking when casting\"\n+}\n+\n+declare_lint_pass!(CheckedConversions => [CHECKED_CONVERSIONS]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CheckedConversions {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, item: &Expr) {\n+        let result = if_chain! {\n+            if !in_external_macro(cx.sess(), item.span);\n+            if let ExprKind::Binary(op, ref left, ref right) = &item.node;\n+\n+            then {\n+                match op.node {\n+                    BinOpKind::Ge | BinOpKind::Le => single_check(item),\n+                    BinOpKind::And => double_check(cx, left, right),\n+                    _ => None,\n+                }\n+            } else {\n+                None\n+            }\n+        };\n+\n+        if_chain! {\n+            if let Some(cv) = result;\n+            if let Some(to_type) = cv.to_type;\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let snippet = snippet_with_applicability(cx, cv.expr_to_cast.span, \"_\", &mut\n+                                applicability);\n+                span_lint_and_sugg(\n+                    cx,\n+                    CHECKED_CONVERSIONS,\n+                    item.span,\n+                    \"Checked cast can be simplified.\",\n+                    \"try\",\n+                    format!(\"{}::try_from({}).is_ok()\",\n+                            to_type,\n+                            snippet),\n+                    applicability\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Searches for a single check from unsigned to _ is done\n+/// todo: check for case signed -> larger unsigned == only x >= 0\n+fn single_check(expr: &Expr) -> Option<Conversion<'_>> {\n+    check_upper_bound(expr).filter(|cv| cv.cvt == ConversionType::FromUnsigned)\n+}\n+\n+/// Searches for a combination of upper & lower bound checks\n+fn double_check<'a>(cx: &LateContext<'_, '_>, left: &'a Expr, right: &'a Expr) -> Option<Conversion<'a>> {\n+    let upper_lower = |l, r| {\n+        let upper = check_upper_bound(l);\n+        let lower = check_lower_bound(r);\n+\n+        transpose(upper, lower).and_then(|(l, r)| l.combine(r, cx))\n+    };\n+\n+    upper_lower(left, right).or_else(|| upper_lower(right, left))\n+}\n+\n+/// Contains the result of a tried conversion check\n+#[derive(Clone, Debug)]\n+struct Conversion<'a> {\n+    cvt: ConversionType,\n+    expr_to_cast: &'a Expr,\n+    to_type: Option<&'a str>,\n+}\n+\n+/// The kind of conversion that is checked\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+enum ConversionType {\n+    SignedToUnsigned,\n+    SignedToSigned,\n+    FromUnsigned,\n+}\n+\n+impl<'a> Conversion<'a> {\n+    /// Combine multiple conversions if the are compatible\n+    pub fn combine(self, other: Self, cx: &LateContext<'_, '_>) -> Option<Conversion<'a>> {\n+        if self.is_compatible(&other, cx) {\n+            // Prefer a Conversion that contains a type-constraint\n+            Some(if self.to_type.is_some() { self } else { other })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Checks if two conversions are compatible\n+    /// same type of conversion, same 'castee' and same 'to type'\n+    pub fn is_compatible(&self, other: &Self, cx: &LateContext<'_, '_>) -> bool {\n+        (self.cvt == other.cvt)\n+            && (SpanlessEq::new(cx).eq_expr(self.expr_to_cast, other.expr_to_cast))\n+            && (self.has_compatible_to_type(other))\n+    }\n+\n+    /// Checks if the to-type is the same (if there is a type constraint)\n+    fn has_compatible_to_type(&self, other: &Self) -> bool {\n+        transpose(self.to_type.as_ref(), other.to_type.as_ref()).map_or(true, |(l, r)| l == r)\n+    }\n+\n+    /// Try to construct a new conversion if the conversion type is valid\n+    fn try_new(expr_to_cast: &'a Expr, from_type: &str, to_type: &'a str) -> Option<Conversion<'a>> {\n+        ConversionType::try_new(from_type, to_type).map(|cvt| Conversion {\n+            cvt,\n+            expr_to_cast,\n+            to_type: Some(to_type),\n+        })\n+    }\n+\n+    /// Construct a new conversion without type constraint\n+    fn new_any(expr_to_cast: &'a Expr) -> Conversion<'a> {\n+        Conversion {\n+            cvt: ConversionType::SignedToUnsigned,\n+            expr_to_cast,\n+            to_type: None,\n+        }\n+    }\n+}\n+\n+impl ConversionType {\n+    /// Creates a conversion type if the type is allowed & conversion is valid\n+    fn try_new(from: &str, to: &str) -> Option<Self> {\n+        if UINTS.contains(&from) {\n+            Some(ConversionType::FromUnsigned)\n+        } else if SINTS.contains(&from) {\n+            if UINTS.contains(&to) {\n+                Some(ConversionType::SignedToUnsigned)\n+            } else if SINTS.contains(&to) {\n+                Some(ConversionType::SignedToSigned)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Check for `expr <= (to_type::max_value() as from_type)`\n+fn check_upper_bound(expr: &Expr) -> Option<Conversion<'_>> {\n+    if_chain! {\n+         if let ExprKind::Binary(ref op, ref left, ref right) = &expr.node;\n+         if let Some((candidate, check)) = normalize_le_ge(op, left, right);\n+         if let Some((from, to)) = get_types_from_cast(check, MAX_VALUE, INTS);\n+\n+         then {\n+             Conversion::try_new(candidate, from, to)\n+         } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Check for `expr >= 0|(to_type::min_value() as from_type)`\n+fn check_lower_bound(expr: &Expr) -> Option<Conversion<'_>> {\n+    fn check_function<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Conversion<'a>> {\n+        (check_lower_bound_zero(candidate, check)).or_else(|| (check_lower_bound_min(candidate, check)))\n+    }\n+\n+    // First of we need a binary containing the expression & the cast\n+    if let ExprKind::Binary(ref op, ref left, ref right) = &expr.node {\n+        normalize_le_ge(op, right, left).and_then(|(l, r)| check_function(l, r))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Check for `expr >= 0`\n+fn check_lower_bound_zero<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Conversion<'a>> {\n+    if_chain! {\n+        if let ExprKind::Lit(ref lit) = &check.node;\n+        if let LitKind::Int(0, _) = &lit.node;\n+\n+        then {\n+            Some(Conversion::new_any(candidate))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Check for `expr >= (to_type::min_value() as from_type)`\n+fn check_lower_bound_min<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Conversion<'a>> {\n+    if let Some((from, to)) = get_types_from_cast(check, MIN_VALUE, SINTS) {\n+        Conversion::try_new(candidate, from, to)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Tries to extract the from- and to-type from a cast expression\n+fn get_types_from_cast<'a>(expr: &'a Expr, func: &'a str, types: &'a [&str]) -> Option<(&'a str, &'a str)> {\n+    // `to_type::maxmin_value() as from_type`\n+    let call_from_cast: Option<(&Expr, &str)> = if_chain! {\n+        // to_type::maxmin_value(), from_type\n+        if let ExprKind::Cast(ref limit, ref from_type) = &expr.node;\n+        if let TyKind::Path(ref from_type_path) = &from_type.node;\n+        if let Some(from_sym) = int_ty_to_sym(from_type_path);\n+\n+        then {\n+            Some((limit, from_sym))\n+        } else {\n+            None\n+        }\n+    };\n+\n+    // `from_type::from(to_type::maxmin_value())`\n+    let limit_from: Option<(&Expr, &str)> = call_from_cast.or_else(|| {\n+        if_chain! {\n+            // `from_type::from, to_type::maxmin_value()`\n+            if let ExprKind::Call(ref from_func, ref args) = &expr.node;\n+            // `to_type::maxmin_value()`\n+            if args.len() == 1;\n+            if let limit = &args[0];\n+            // `from_type::from`\n+            if let ExprKind::Path(ref path) = &from_func.node;\n+            if let Some(from_sym) = get_implementing_type(path, INTS, FROM);\n+\n+            then {\n+                Some((limit, from_sym))\n+            } else {\n+                None\n+            }\n+        }\n+    });\n+\n+    if let Some((limit, from_type)) = limit_from {\n+        if_chain! {\n+            if let ExprKind::Call(ref fun_name, _) = &limit.node;\n+            // `to_type, maxmin_value`\n+            if let ExprKind::Path(ref path) = &fun_name.node;\n+            // `to_type`\n+            if let Some(to_type) = get_implementing_type(path, types, func);\n+\n+            then {\n+                Some((from_type, to_type))\n+            } else {\n+                None\n+            }\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Gets the type which implements the called function\n+fn get_implementing_type<'a>(path: &QPath, candidates: &'a [&str], function: &str) -> Option<&'a str> {\n+    if_chain! {\n+        if let QPath::TypeRelative(ref ty, ref path) = &path;\n+        if path.ident.name.as_str() == function;\n+        if let TyKind::Path(QPath::Resolved(None, ref tp)) = &ty.node;\n+        if let [int] = &*tp.segments;\n+        let name = &int.ident.name.as_str();\n+\n+        then {\n+            candidates.iter().find(|c| name == *c).cloned()\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Gets the type as a string, if it is a supported integer\n+fn int_ty_to_sym(path: &QPath) -> Option<&str> {\n+    if_chain! {\n+        if let QPath::Resolved(_, ref path) = *path;\n+        if let [ty] = &*path.segments;\n+        let name = &ty.ident.name.as_str();\n+\n+        then {\n+            INTS.iter().find(|c| name == *c).cloned()\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// (Option<T>, Option<U>) -> Option<(T, U)>\n+fn transpose<T, U>(lhs: Option<T>, rhs: Option<U>) -> Option<(T, U)> {\n+    match (lhs, rhs) {\n+        (Some(l), Some(r)) => Some((l, r)),\n+        _ => None,\n+    }\n+}\n+\n+/// Will return the expressions as if they were expr1 <= expr2\n+fn normalize_le_ge<'a>(op: &BinOp, left: &'a Expr, right: &'a Expr) -> Option<(&'a Expr, &'a Expr)> {\n+    match op.node {\n+        BinOpKind::Le => Some((left, right)),\n+        BinOpKind::Ge => Some((right, left)),\n+        _ => None,\n+    }\n+}\n+\n+// Constants\n+const FROM: &str = \"from\";\n+const MAX_VALUE: &str = \"max_value\";\n+const MIN_VALUE: &str = \"min_value\";\n+\n+const UINTS: &[&str] = &[\"u8\", \"u16\", \"u32\", \"u64\", \"usize\"];\n+const SINTS: &[&str] = &[\"i8\", \"i16\", \"i32\", \"i64\", \"isize\"];\n+const INTS: &[&str] = &[\"u8\", \"u16\", \"u32\", \"u64\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"isize\"];"}, {"sha": "f289c278a8c9416ab4fa4ba0ac9eb3f877836793", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd563810158425c20f27768da4ef54c54230bbbf/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd563810158425c20f27768da4ef54c54230bbbf/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=fd563810158425c20f27768da4ef54c54230bbbf", "patch": "@@ -10,6 +10,7 @@ use rustc::ty;\n use rustc::ty::subst::InternalSubsts;\n use rustc::ty::util::IntTypeExt;\n use rustc::{declare_lint_pass, declare_tool_lint};\n+use std::convert::TryFrom;\n use syntax::ast::{IntTy, UintTy};\n \n declare_clippy_lint! {\n@@ -65,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                         match ty.sty {\n                             ty::Int(IntTy::Isize) => {\n                                 let val = ((val as i128) << 64) >> 64;\n-                                if val <= i128::from(i32::max_value()) && val >= i128::from(i32::min_value()) {\n+                                if i32::try_from(val).is_ok() {\n                                     continue;\n                                 }\n                             },"}, {"sha": "f7459366263416be680285c36c2f240bdc79f090", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd563810158425c20f27768da4ef54c54230bbbf/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd563810158425c20f27768da4ef54c54230bbbf/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=fd563810158425c20f27768da4ef54c54230bbbf", "patch": "@@ -154,6 +154,7 @@ pub mod block_in_if_condition;\n pub mod booleans;\n pub mod bytecount;\n pub mod cargo_common_metadata;\n+pub mod checked_conversions;\n pub mod cognitive_complexity;\n pub mod collapsible_if;\n pub mod const_static_lifetime;\n@@ -575,6 +576,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box missing_const_for_fn::MissingConstForFn);\n     reg.register_late_lint_pass(box transmuting_null::TransmutingNull);\n     reg.register_late_lint_pass(box path_buf_push_overwrite::PathBufPushOverwrite);\n+    reg.register_late_lint_pass(box checked_conversions::CheckedConversions);\n \n     reg.register_lint_group(\"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -605,6 +607,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n \n     reg.register_lint_group(\"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n         attrs::INLINE_ALWAYS,\n+        checked_conversions::CHECKED_CONVERSIONS,\n         copies::MATCH_SAME_ARMS,\n         copy_iterator::COPY_ITERATOR,\n         default_trait_access::DEFAULT_TRAIT_ACCESS,"}, {"sha": "7febd6f376135884d31ee80143de3d8eec941ef1", "filename": "tests/ui/checked_conversions.fixed", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fd563810158425c20f27768da4ef54c54230bbbf/tests%2Fui%2Fchecked_conversions.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fd563810158425c20f27768da4ef54c54230bbbf/tests%2Fui%2Fchecked_conversions.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_conversions.fixed?ref=fd563810158425c20f27768da4ef54c54230bbbf", "patch": "@@ -0,0 +1,106 @@\n+// run-rustfix\n+\n+#![warn(clippy::checked_conversions)]\n+#![allow(clippy::cast_lossless)]\n+#![allow(dead_code)]\n+use std::convert::TryFrom;\n+\n+// Positive tests\n+\n+// Signed to unsigned\n+\n+fn i64_to_u32(value: i64) -> Option<u32> {\n+    if u32::try_from(value).is_ok() {\n+        Some(value as u32)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn i64_to_u16(value: i64) -> Option<u16> {\n+    if u16::try_from(value).is_ok() {\n+        Some(value as u16)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn isize_to_u8(value: isize) -> Option<u8> {\n+    if u8::try_from(value).is_ok() {\n+        Some(value as u8)\n+    } else {\n+        None\n+    }\n+}\n+\n+// Signed to signed\n+\n+fn i64_to_i32(value: i64) -> Option<i32> {\n+    if i32::try_from(value).is_ok() {\n+        Some(value as i32)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn i64_to_i16(value: i64) -> Option<i16> {\n+    if i16::try_from(value).is_ok() {\n+        Some(value as i16)\n+    } else {\n+        None\n+    }\n+}\n+\n+// Unsigned to X\n+\n+fn u32_to_i32(value: u32) -> Option<i32> {\n+    if i32::try_from(value).is_ok() {\n+        Some(value as i32)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn usize_to_isize(value: usize) -> isize {\n+    if isize::try_from(value).is_ok() && value as i32 == 5 {\n+        5\n+    } else {\n+        1\n+    }\n+}\n+\n+fn u32_to_u16(value: u32) -> isize {\n+    if u16::try_from(value).is_ok() && value as i32 == 5 {\n+        5\n+    } else {\n+        1\n+    }\n+}\n+\n+// Negative tests\n+\n+fn no_i64_to_i32(value: i64) -> Option<i32> {\n+    if value <= (i32::max_value() as i64) && value >= 0 {\n+        Some(value as i32)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn no_isize_to_u8(value: isize) -> Option<u8> {\n+    if value <= (u8::max_value() as isize) && value >= (u8::min_value() as isize) {\n+        Some(value as u8)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn i8_to_u8(value: i8) -> Option<u8> {\n+    if value >= 0 {\n+        Some(value as u8)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a643354e2438f0ad71ffb2cf968c08da8e21dd10", "filename": "tests/ui/checked_conversions.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fd563810158425c20f27768da4ef54c54230bbbf/tests%2Fui%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd563810158425c20f27768da4ef54c54230bbbf/tests%2Fui%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_conversions.rs?ref=fd563810158425c20f27768da4ef54c54230bbbf", "patch": "@@ -0,0 +1,106 @@\n+// run-rustfix\n+\n+#![warn(clippy::checked_conversions)]\n+#![allow(clippy::cast_lossless)]\n+#![allow(dead_code)]\n+use std::convert::TryFrom;\n+\n+// Positive tests\n+\n+// Signed to unsigned\n+\n+fn i64_to_u32(value: i64) -> Option<u32> {\n+    if value <= (u32::max_value() as i64) && value >= 0 {\n+        Some(value as u32)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn i64_to_u16(value: i64) -> Option<u16> {\n+    if value <= i64::from(u16::max_value()) && value >= 0 {\n+        Some(value as u16)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn isize_to_u8(value: isize) -> Option<u8> {\n+    if value <= (u8::max_value() as isize) && value >= 0 {\n+        Some(value as u8)\n+    } else {\n+        None\n+    }\n+}\n+\n+// Signed to signed\n+\n+fn i64_to_i32(value: i64) -> Option<i32> {\n+    if value <= (i32::max_value() as i64) && value >= (i32::min_value() as i64) {\n+        Some(value as i32)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn i64_to_i16(value: i64) -> Option<i16> {\n+    if value <= i64::from(i16::max_value()) && value >= i64::from(i16::min_value()) {\n+        Some(value as i16)\n+    } else {\n+        None\n+    }\n+}\n+\n+// Unsigned to X\n+\n+fn u32_to_i32(value: u32) -> Option<i32> {\n+    if value <= i32::max_value() as u32 {\n+        Some(value as i32)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn usize_to_isize(value: usize) -> isize {\n+    if value <= isize::max_value() as usize && value as i32 == 5 {\n+        5\n+    } else {\n+        1\n+    }\n+}\n+\n+fn u32_to_u16(value: u32) -> isize {\n+    if value <= u16::max_value() as u32 && value as i32 == 5 {\n+        5\n+    } else {\n+        1\n+    }\n+}\n+\n+// Negative tests\n+\n+fn no_i64_to_i32(value: i64) -> Option<i32> {\n+    if value <= (i32::max_value() as i64) && value >= 0 {\n+        Some(value as i32)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn no_isize_to_u8(value: isize) -> Option<u8> {\n+    if value <= (u8::max_value() as isize) && value >= (u8::min_value() as isize) {\n+        Some(value as u8)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn i8_to_u8(value: i8) -> Option<u8> {\n+    if value >= 0 {\n+        Some(value as u8)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f678f009621f8f3dd5a9036ceb376190fd828042", "filename": "tests/ui/checked_conversions.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fd563810158425c20f27768da4ef54c54230bbbf/tests%2Fui%2Fchecked_conversions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd563810158425c20f27768da4ef54c54230bbbf/tests%2Fui%2Fchecked_conversions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_conversions.stderr?ref=fd563810158425c20f27768da4ef54c54230bbbf", "patch": "@@ -0,0 +1,52 @@\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:13:8\n+   |\n+LL |     if value <= (u32::max_value() as i64) && value >= 0 {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u32::try_from(value).is_ok()`\n+   |\n+   = note: `-D clippy::checked-conversions` implied by `-D warnings`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:21:8\n+   |\n+LL |     if value <= i64::from(u16::max_value()) && value >= 0 {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u16::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:29:8\n+   |\n+LL |     if value <= (u8::max_value() as isize) && value >= 0 {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u8::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:39:8\n+   |\n+LL |     if value <= (i32::max_value() as i64) && value >= (i32::min_value() as i64) {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i32::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:47:8\n+   |\n+LL |     if value <= i64::from(i16::max_value()) && value >= i64::from(i16::min_value()) {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i16::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:57:8\n+   |\n+LL |     if value <= i32::max_value() as u32 {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i32::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:65:8\n+   |\n+LL |     if value <= isize::max_value() as usize && value as i32 == 5 {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `isize::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:73:8\n+   |\n+LL |     if value <= u16::max_value() as u32 && value as i32 == 5 {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u16::try_from(value).is_ok()`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/checked_conversions.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fd563810158425c20f27768da4ef54c54230bbbf/tests%2Fui%2Fchecked_conversions.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fd563810158425c20f27768da4ef54c54230bbbf/tests%2Fui%2Fchecked_conversions.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_conversions.stdout?ref=fd563810158425c20f27768da4ef54c54230bbbf"}]}