{"sha": "60c846046ec26c9e5c1216a6e118cc2e69a2956c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYzg0NjA0NmVjMjZjOWU1YzEyMTZhNmUxMThjYzJlNjlhMjk1NmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-05T12:52:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-05T12:52:53Z"}, "message": "Auto merge of #54336 - petrochenkov:preuni, r=alexcrichton\n\nresolve: Some refactorings in preparation for uniform paths 2.0\n\nThe main result is that in-scope resolution performed during macro expansion / import resolution is now consolidated in a single function (`fn early_resolve_ident_in_lexical_scope`), which can now be used for resolving first import segments as well when uniform paths are enabled.\n\nr? @ghost", "tree": {"sha": "8f0d780ff63d577799dd2cc6d7f724713ea6fae7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f0d780ff63d577799dd2cc6d7f724713ea6fae7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60c846046ec26c9e5c1216a6e118cc2e69a2956c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60c846046ec26c9e5c1216a6e118cc2e69a2956c", "html_url": "https://github.com/rust-lang/rust/commit/60c846046ec26c9e5c1216a6e118cc2e69a2956c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60c846046ec26c9e5c1216a6e118cc2e69a2956c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "766e21c7d7f9a0469997c714787d8e244df651b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/766e21c7d7f9a0469997c714787d8e244df651b3", "html_url": "https://github.com/rust-lang/rust/commit/766e21c7d7f9a0469997c714787d8e244df651b3"}, {"sha": "0d8e9cd4df6d2a5e059168fac16d4de9e6eb62fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d8e9cd4df6d2a5e059168fac16d4de9e6eb62fe", "html_url": "https://github.com/rust-lang/rust/commit/0d8e9cd4df6d2a5e059168fac16d4de9e6eb62fe"}], "stats": {"total": 665, "additions": 262, "deletions": 403}, "files": [{"sha": "6a9488226b1bdc61a35479268dcce8fee9cfaf16", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -2388,6 +2388,7 @@ name = \"rustc_resolve\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n+ \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\","}, {"sha": "5d9d4deb0abc9e95793aa303ce1a621980cc0b1c", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -36,6 +36,8 @@ pub enum NonMacroAttrKind {\n     Tool,\n     /// Single-segment custom attribute registered by a derive macro (`#[serde(default)]`).\n     DeriveHelper,\n+    /// Single-segment custom attriubte registered by a legacy plugin (`register_attribute`).\n+    LegacyPluginHelper,\n     /// Single-segment custom attribute not registered in any way (`#[my_attr]`).\n     Custom,\n }\n@@ -259,6 +261,7 @@ impl NonMacroAttrKind {\n             NonMacroAttrKind::Builtin => \"built-in attribute\",\n             NonMacroAttrKind::Tool => \"tool attribute\",\n             NonMacroAttrKind::DeriveHelper => \"derive helper attribute\",\n+            NonMacroAttrKind::LegacyPluginHelper => \"legacy plugin helper attribute\",\n             NonMacroAttrKind::Custom => \"custom attribute\",\n         }\n     }"}, {"sha": "a4386c6cbfd43e54d12c4c75f3480421b9b84d17", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -1012,6 +1012,7 @@ impl_stable_hash_for!(enum hir::def::NonMacroAttrKind {\n     Builtin,\n     Tool,\n     DeriveHelper,\n+    LegacyPluginHelper,\n     Custom,\n });\n "}, {"sha": "3a8e84a3280c6dd3ca30b17a74004a7926db0191", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -10,6 +10,7 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n+bitflags = \"1.0\"\n log = \"0.4\"\n syntax = { path = \"../libsyntax\" }\n rustc = { path = \"../librustc\" }"}, {"sha": "a93cc7ad7518a7715893afef241826515a097859", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -17,6 +17,8 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n \n+#[macro_use]\n+extern crate bitflags;\n #[macro_use]\n extern crate log;\n #[macro_use]\n@@ -1012,7 +1014,8 @@ pub struct ModuleData<'a> {\n     normal_ancestor_id: DefId,\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>, Option<Def>)>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>,\n+                                           Option<&'a NameBinding<'a>>)>>,\n     macro_resolutions: RefCell<Vec<(Box<[Ident]>, Span)>>,\n     builtin_attrs: RefCell<Vec<(Ident, ParentScope<'a>)>>,\n \n@@ -1210,10 +1213,6 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    fn get_macro<'b: 'a>(&self, resolver: &mut Resolver<'a, 'b>) -> Lrc<SyntaxExtension> {\n-        resolver.get_macro(self.def_ignoring_ambiguity())\n-    }\n-\n     // We sometimes need to treat variants as `pub` for backwards compatibility\n     fn pseudo_vis(&self) -> ty::Visibility {\n         if self.is_variant() && self.def().def_id().is_local() {\n@@ -3664,8 +3663,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.resolve_lexical_macro_path_segment(ident, ns, None, parent_scope, record_used,\n-                                                        record_used, path_span).map(|(b, _)| b)\n+                self.early_resolve_ident_in_lexical_scope(ident, ns, None, parent_scope,\n+                                                          record_used, record_used, path_span)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };"}, {"sha": "c31b558dedea03452bebb1a0010ec62f01465332", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 197, "deletions": 278, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -11,7 +11,7 @@\n use {AmbiguityError, CrateLint, Resolver, ResolutionError, is_known_tool, resolve_error};\n use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, ToNameBinding};\n use ModuleOrUniformRoot;\n-use Namespace::{self, TypeNS, MacroNS};\n+use Namespace::{self, *};\n use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX, DefIndex,\n@@ -22,9 +22,9 @@ use rustc::{ty, lint};\n use syntax::ast::{self, Name, Ident};\n use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n+use syntax::ext::base::{self, Determinacy};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n-use syntax::ext::expand::{AstFragment, Invocation, InvocationKind, TogetherWith};\n+use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, Mark};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, feature_err, emit_feature_err, is_builtin_attr_name, GateIssue};\n@@ -43,9 +43,6 @@ use std::cell::Cell;\n use std::mem;\n use rustc_data_structures::sync::Lrc;\n \n-#[derive(Clone, Copy)]\n-crate struct FromPrelude(bool);\n-\n #[derive(Clone)]\n pub struct InvocationData<'a> {\n     def_index: DefIndex,\n@@ -245,27 +242,10 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>, allow_derive: bool)\n                               -> Option<ast::Attribute> {\n-        for i in 0..attrs.len() {\n-            let name = attrs[i].name();\n-\n-            if self.session.plugin_attributes.borrow().iter()\n-                    .any(|&(ref attr_nm, _)| name == &**attr_nm) {\n-                attr::mark_known(&attrs[i]);\n-            }\n-\n-            match self.builtin_macros.get(&name).cloned() {\n-                Some(binding) => match *binding.get_macro(self) {\n-                    MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n-                        return Some(attrs.remove(i))\n-                    }\n-                    _ => {}\n-                },\n-                None => {}\n-            }\n+        if !allow_derive {\n+            return None;\n         }\n \n-        if !allow_derive { return None }\n-\n         // Check for legacy derives\n         for i in 0..attrs.len() {\n             let name = attrs[i].name();\n@@ -333,29 +313,24 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n-        let (path, kind, derives_in_scope, together_with) = match invoc.kind {\n+        let (path, kind, derives_in_scope, after_derive) = match invoc.kind {\n             InvocationKind::Attr { attr: None, .. } =>\n                 return Ok(None),\n-            InvocationKind::Attr { attr: Some(ref attr), ref traits, together_with, .. } =>\n-                (&attr.path, MacroKind::Attr, traits.clone(), together_with),\n+            InvocationKind::Attr { attr: Some(ref attr), ref traits, after_derive, .. } =>\n+                (&attr.path, MacroKind::Attr, traits.clone(), after_derive),\n             InvocationKind::Bang { ref mac, .. } =>\n-                (&mac.node.path, MacroKind::Bang, Vec::new(), TogetherWith::None),\n+                (&mac.node.path, MacroKind::Bang, Vec::new(), false),\n             InvocationKind::Derive { ref path, .. } =>\n-                (path, MacroKind::Derive, Vec::new(), TogetherWith::None),\n+                (path, MacroKind::Derive, Vec::new(), false),\n         };\n \n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n         let (def, ext) = self.resolve_macro_to_def(path, kind, &parent_scope, force)?;\n \n         if let Def::Macro(def_id, _) = def {\n-            match together_with {\n-                TogetherWith::Derive =>\n-                    self.session.span_err(invoc.span(),\n-                        \"macro attributes must be placed before `#[derive]`\"),\n-                TogetherWith::TestBench if !self.session.features_untracked().plugin =>\n-                    self.session.span_err(invoc.span(),\n-                        \"macro attributes cannot be used together with `#[test]` or `#[bench]`\"),\n-                _ => {}\n+            if after_derive {\n+                self.session.span_err(invoc.span(),\n+                                      \"macro attributes must be placed before `#[derive]`\");\n             }\n             self.macro_defs.insert(invoc.expansion_data.mark, def_id);\n             let normal_module_def_id =\n@@ -520,37 +495,34 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     Err(Determinacy::Determined)\n                 },\n             };\n+\n             parent_scope.module.macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n-            return def;\n-        }\n \n-        let result = if let Some(legacy_binding) = self.resolve_legacy_scope(path[0], Some(kind),\n-                                                                             parent_scope, false) {\n-            Ok(legacy_binding.def())\n+            def\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, Some(kind),\n-                                                          parent_scope, false, force, span) {\n-                Ok((binding, _)) => Ok(binding.def_ignoring_ambiguity()),\n+            let binding = self.early_resolve_ident_in_lexical_scope(\n+                path[0], MacroNS, Some(kind), parent_scope, false, force, span\n+            );\n+            match binding {\n+                Ok(..) => {}\n+                Err(Determinacy::Determined) => self.found_unresolved_macro = true,\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n-                Err(Determinacy::Determined) => {\n-                    self.found_unresolved_macro = true;\n-                    Err(Determinacy::Determined)\n-                }\n             }\n-        };\n \n-        parent_scope.module.legacy_macro_resolutions.borrow_mut()\n-            .push((path[0], kind, parent_scope.clone(), result.ok()));\n+            parent_scope.module.legacy_macro_resolutions.borrow_mut()\n+                .push((path[0], kind, parent_scope.clone(), binding.ok()));\n \n-        result\n+            binding.map(|binding| binding.def_ignoring_ambiguity())\n+        }\n     }\n \n-    // Resolve the initial segment of a non-global macro path\n-    // (e.g. `foo` in `foo::bar!(); or `foo!();`).\n+    // Resolve an identifier in lexical scope.\n     // This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n     // expansion and import resolution (perhaps they can be merged in the future).\n-    crate fn resolve_lexical_macro_path_segment(\n+    // The function is used for resolving initial segments of macro paths (e.g. `foo` in\n+    // `foo::bar!(); or `foo!();`) and can be used for \"uniform path\" imports in the future.\n+    crate fn early_resolve_ident_in_lexical_scope(\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n@@ -559,12 +531,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         record_used: bool,\n         force: bool,\n         path_span: Span,\n-    ) -> Result<(&'a NameBinding<'a>, FromPrelude), Determinacy> {\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         // General principles:\n         // 1. Not controlled (user-defined) names should have higher priority than controlled names\n         //    built into the language or standard library. This way we can add new names into the\n         //    language or standard library without breaking user code.\n-        // 2. \"Closed set\" below means new names can appear after the current resolution attempt.\n+        // 2. \"Closed set\" below means new names cannot appear after the current resolution attempt.\n         // Places to search (in order of decreasing priority):\n         // (Type NS)\n         // 1. FIXME: Ribs (type parameters), there's no necessary infrastructure yet\n@@ -575,24 +547,58 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // 4. Tool modules (closed, controlled right now, but not in the future).\n         // 5. Standard library prelude (de-facto closed, controlled).\n         // 6. Language prelude (closed, controlled).\n+        // (Value NS)\n+        // 1. FIXME: Ribs (local variables), there's no necessary infrastructure yet\n+        //    (open set, not controlled).\n+        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 3. Standard library prelude (de-facto closed, controlled).\n         // (Macro NS)\n-        // 0. Derive helpers (open, not controlled). All ambiguities with other names\n+        // 1-3. Derive helpers (open, not controlled). All ambiguities with other names\n         //    are currently reported as errors. They should be higher in priority than preludes\n         //    and probably even names in modules according to the \"general principles\" above. They\n         //    also should be subject to restricted shadowing because are effectively produced by\n         //    derives (you need to resolve the derive first to add helpers into scope), but they\n         //    should be available before the derive is expanded for compatibility.\n         //    It's mess in general, so we are being conservative for now.\n-        // 1. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled).\n-        // 2. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n-        // 2a. User-defined prelude from macro-use\n+        // 1-3. `macro_rules` (open, not controlled), loop through legacy scopes. Have higher\n+        //    priority than prelude macros, but create ambiguities with macros in modules.\n+        // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled). Have higher priority than prelude macros, but create\n+        //    ambiguities with `macro_rules`.\n+        // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n+        // 4a. User-defined prelude from macro-use\n         //    (open, the open part is from macro expansions, not controlled).\n-        // 2b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n-        // 3. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n-        // 4. Language prelude: builtin attributes (closed, controlled).\n+        // 4b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n+        // 5. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n+        // 6. Language prelude: builtin attributes (closed, controlled).\n+        // 4-6. Legacy plugin helpers (open, not controlled). Similar to derive helpers,\n+        //    but introduced by legacy plugins using `register_attribute`. Priority is somewhere\n+        //    in prelude, not sure where exactly (creates ambiguities with any other prelude names).\n+\n+        enum WhereToResolve<'a> {\n+            DeriveHelpers,\n+            MacroRules(LegacyScope<'a>),\n+            Module(Module<'a>),\n+            MacroUsePrelude,\n+            BuiltinMacros,\n+            BuiltinAttrs,\n+            LegacyPluginHelpers,\n+            ExternPrelude,\n+            ToolPrelude,\n+            StdLibPrelude,\n+            BuiltinTypes,\n+        }\n+\n+        bitflags! {\n+            struct Flags: u8 {\n+                const DERIVE_HELPERS = 1 << 0;\n+                const MACRO_RULES    = 1 << 1;\n+                const MODULE         = 1 << 2;\n+                const PRELUDE        = 1 << 3;\n+            }\n+        }\n \n-        assert!(ns == TypeNS  || ns == MacroNS);\n         assert!(force || !record_used); // `record_used` implies `force`\n         ident = ident.modern();\n \n@@ -607,25 +613,38 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // }\n         // So we have to save the innermost solution and continue searching in outer scopes\n         // to detect potential ambiguities.\n-        let mut innermost_result: Option<(&NameBinding, FromPrelude)> = None;\n-\n-        enum WhereToResolve<'a> {\n-            Module(Module<'a>),\n-            MacroUsePrelude,\n-            BuiltinMacros,\n-            BuiltinAttrs,\n-            DeriveHelpers,\n-            ExternPrelude,\n-            ToolPrelude,\n-            StdLibPrelude,\n-            BuiltinTypes,\n-        }\n+        let mut innermost_result: Option<(&NameBinding, Flags, /* conflicts with */ Flags)> = None;\n \n         // Go through all the scopes and try to resolve the name.\n         let mut where_to_resolve = WhereToResolve::DeriveHelpers;\n         let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n         loop {\n             let result = match where_to_resolve {\n+                WhereToResolve::DeriveHelpers => {\n+                    let mut result = Err(Determinacy::Determined);\n+                    for derive in &parent_scope.derives {\n+                        let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n+                        if let Ok((_, ext)) = self.resolve_macro_to_def(derive, MacroKind::Derive,\n+                                                                        &parent_scope, force) {\n+                            if let SyntaxExtension::ProcMacroDerive(_, helper_attrs, _) = &*ext {\n+                                if helper_attrs.contains(&ident.name) {\n+                                    let binding =\n+                                        (Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                        ty::Visibility::Public, derive.span, Mark::root())\n+                                        .to_name_binding(self.arenas);\n+                                    result = Ok((binding, Flags::DERIVE_HELPERS, Flags::all()));\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    result\n+                }\n+                WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n+                    LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n+                        Ok((legacy_binding.binding, Flags::MACRO_RULES, Flags::empty())),\n+                    _ => Err(Determinacy::Determined),\n+                }\n                 WhereToResolve::Module(module) => {\n                     let orig_current_module = mem::replace(&mut self.current_module, module);\n                     let binding = self.resolve_ident_in_module_unadjusted(\n@@ -637,17 +656,17 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         path_span,\n                     );\n                     self.current_module = orig_current_module;\n-                    binding.map(|binding| (binding, FromPrelude(false)))\n+                    binding.map(|binding| (binding, Flags::MODULE, Flags::empty()))\n                 }\n                 WhereToResolve::MacroUsePrelude => {\n                     match self.macro_use_prelude.get(&ident.name).cloned() {\n-                        Some(binding) => Ok((binding, FromPrelude(true))),\n+                        Some(binding) => Ok((binding, Flags::PRELUDE, Flags::empty())),\n                         None => Err(Determinacy::Determined),\n                     }\n                 }\n                 WhereToResolve::BuiltinMacros => {\n                     match self.builtin_macros.get(&ident.name).cloned() {\n-                        Some(binding) => Ok((binding, FromPrelude(true))),\n+                        Some(binding) => Ok((binding, Flags::PRELUDE, Flags::empty())),\n                         None => Err(Determinacy::Determined),\n                     }\n                 }\n@@ -656,30 +675,21 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n                                        ty::Visibility::Public, ident.span, Mark::root())\n                                        .to_name_binding(self.arenas);\n-                        Ok((binding, FromPrelude(true)))\n+                        Ok((binding, Flags::PRELUDE, Flags::empty()))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n                 }\n-                WhereToResolve::DeriveHelpers => {\n-                    let mut result = Err(Determinacy::Determined);\n-                    for derive in &parent_scope.derives {\n-                        let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n-                        if let Ok((_, ext)) = self.resolve_macro_to_def(derive, MacroKind::Derive,\n-                                                                        &parent_scope, force) {\n-                            if let SyntaxExtension::ProcMacroDerive(_, helper_attrs, _) = &*ext {\n-                                if helper_attrs.contains(&ident.name) {\n-                                    let binding =\n-                                        (Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                        ty::Visibility::Public, derive.span, Mark::root())\n-                                        .to_name_binding(self.arenas);\n-                                    result = Ok((binding, FromPrelude(false)));\n-                                    break;\n-                                }\n-                            }\n-                        }\n+                WhereToResolve::LegacyPluginHelpers => {\n+                    if self.session.plugin_attributes.borrow().iter()\n+                                                     .any(|(name, _)| ident.name == &**name) {\n+                        let binding = (Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n+                                       ty::Visibility::Public, ident.span, Mark::root())\n+                                       .to_name_binding(self.arenas);\n+                        Ok((binding, Flags::PRELUDE, Flags::PRELUDE))\n+                    } else {\n+                        Err(Determinacy::Determined)\n                     }\n-                    result\n                 }\n                 WhereToResolve::ExternPrelude => {\n                     if use_prelude && self.session.extern_prelude.contains(&ident.name) {\n@@ -691,7 +701,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                         let binding = (crate_root, ty::Visibility::Public,\n                                        ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok((binding, FromPrelude(true)))\n+                        Ok((binding, Flags::PRELUDE, Flags::empty()))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -700,7 +710,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if use_prelude && is_known_tool(ident.name) {\n                         let binding = (Def::ToolMod, ty::Visibility::Public,\n                                        ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok((binding, FromPrelude(true)))\n+                        Ok((binding, Flags::PRELUDE, Flags::empty()))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -717,80 +727,97 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                 false,\n                                 path_span,\n                             ) {\n-                                result = Ok((binding, FromPrelude(true)));\n+                                result = Ok((binding, Flags::PRELUDE, Flags::empty()));\n                             }\n                         }\n                     }\n                     result\n                 }\n                 WhereToResolve::BuiltinTypes => {\n-                    if let Some(prim_ty) =\n-                            self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n-                        let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n-                                       ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok((binding, FromPrelude(true)))\n-                    } else {\n-                        Err(Determinacy::Determined)\n+                    match self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n+                        Some(prim_ty) => {\n+                            let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n+                                           ident.span, Mark::root()).to_name_binding(self.arenas);\n+                            Ok((binding, Flags::PRELUDE, Flags::empty()))\n+                        }\n+                        None => Err(Determinacy::Determined)\n                     }\n                 }\n             };\n \n             macro_rules! continue_search { () => {\n                 where_to_resolve = match where_to_resolve {\n+                    WhereToResolve::DeriveHelpers =>\n+                        WhereToResolve::MacroRules(parent_scope.legacy),\n+                    WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n+                        LegacyScope::Binding(binding) =>\n+                            WhereToResolve::MacroRules(binding.parent_legacy_scope),\n+                        LegacyScope::Invocation(invocation) =>\n+                            WhereToResolve::MacroRules(invocation.output_legacy_scope.get()),\n+                        LegacyScope::Empty => WhereToResolve::Module(parent_scope.module),\n+                        LegacyScope::Uninitialized => unreachable!(),\n+                    }\n                     WhereToResolve::Module(module) => {\n                         match self.hygienic_lexical_parent(module, &mut ident.span) {\n                             Some(parent_module) => WhereToResolve::Module(parent_module),\n                             None => {\n                                 use_prelude = !module.no_implicit_prelude;\n-                                if ns == MacroNS {\n-                                    WhereToResolve::MacroUsePrelude\n-                                } else {\n-                                    WhereToResolve::ExternPrelude\n+                                match ns {\n+                                    TypeNS => WhereToResolve::ExternPrelude,\n+                                    ValueNS => WhereToResolve::StdLibPrelude,\n+                                    MacroNS => WhereToResolve::MacroUsePrelude,\n                                 }\n                             }\n                         }\n                     }\n                     WhereToResolve::MacroUsePrelude => WhereToResolve::BuiltinMacros,\n                     WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n-                    WhereToResolve::BuiltinAttrs => break, // nowhere else to search\n-                    WhereToResolve::DeriveHelpers => WhereToResolve::Module(parent_scope.module),\n+                    WhereToResolve::BuiltinAttrs => WhereToResolve::LegacyPluginHelpers,\n+                    WhereToResolve::LegacyPluginHelpers => break, // nowhere else to search\n                     WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n                     WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n-                    WhereToResolve::StdLibPrelude => WhereToResolve::BuiltinTypes,\n+                    WhereToResolve::StdLibPrelude => match ns {\n+                        TypeNS => WhereToResolve::BuiltinTypes,\n+                        ValueNS => break, // nowhere else to search\n+                        MacroNS => unreachable!(),\n+                    }\n                     WhereToResolve::BuiltinTypes => break, // nowhere else to search\n                 };\n \n                 continue;\n             }}\n \n             match result {\n-                Ok(result) => {\n-                    if sub_namespace_mismatch(kind, result.0.macro_kind()) {\n+                Ok((binding, flags, ambig_flags)) => {\n+                    if sub_namespace_mismatch(kind, binding.macro_kind()) {\n                         continue_search!();\n                     }\n \n                     if !record_used {\n-                        return Ok(result);\n+                        return Ok(binding);\n                     }\n \n-                    if let Some(innermost_result) = innermost_result {\n+                    if let Some((innermost_binding, innermost_flags, innermost_ambig_flags))\n+                            = innermost_result {\n                         // Found another solution, if the first one was \"weak\", report an error.\n-                        let (def, innermost_def) = (result.0.def(), innermost_result.0.def());\n-                        if def != innermost_def &&\n-                           (innermost_result.0.is_glob_import() ||\n-                            innermost_result.0.may_appear_after(parent_scope.expansion, result.0) ||\n-                            innermost_def == Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper) ||\n-                            def == Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper)) {\n+                        if binding.def() != innermost_binding.def() &&\n+                           (innermost_binding.is_glob_import() ||\n+                            innermost_binding.may_appear_after(parent_scope.expansion, binding) ||\n+                            innermost_flags.intersects(ambig_flags) ||\n+                            flags.intersects(innermost_ambig_flags) ||\n+                            (innermost_flags.contains(Flags::MACRO_RULES) &&\n+                             flags.contains(Flags::MODULE) &&\n+                             !self.disambiguate_legacy_vs_modern(innermost_binding, binding))) {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 ident,\n-                                b1: innermost_result.0,\n-                                b2: result.0,\n+                                b1: innermost_binding,\n+                                b2: binding,\n                             });\n-                            return Ok(innermost_result);\n+                            return Ok(innermost_binding);\n                         }\n                     } else {\n                         // Found the first solution.\n-                        innermost_result = Some(result);\n+                        innermost_result = Some((binding, flags, ambig_flags));\n                     }\n \n                     continue_search!();\n@@ -803,8 +830,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         // The first found solution was the only one, return it.\n-        if let Some(innermost_result) = innermost_result {\n-            return Ok(innermost_result);\n+        if let Some((binding, ..)) = innermost_result {\n+            return Ok(binding);\n         }\n \n         let determinacy = Determinacy::determined(force);\n@@ -816,92 +843,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let binding = (Def::NonMacroAttr(NonMacroAttrKind::Custom),\n                            ty::Visibility::Public, ident.span, Mark::root())\n                            .to_name_binding(self.arenas);\n-            Ok((binding, FromPrelude(true)))\n+            Ok(binding)\n         } else {\n             Err(determinacy)\n         }\n     }\n \n-    fn resolve_legacy_scope(\n-        &mut self,\n-        ident: Ident,\n-        kind: Option<MacroKind>,\n-        parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n-    ) -> Option<&'a NameBinding<'a>> {\n-        if sub_namespace_mismatch(kind, Some(MacroKind::Bang)) {\n-            return None;\n-        }\n-\n-        let ident = ident.modern();\n-\n-        // This is *the* result, resolution from the scope closest to the resolved identifier.\n-        // However, sometimes this result is \"weak\" because it comes from a macro expansion,\n-        // and in this case it cannot shadow names from outer scopes, e.g.\n-        // macro_rules! m { ... } // solution in outer scope\n-        // {\n-        //     define_m!(); // generates another `macro_rules! m` - innermost solution\n-        //                  // weak, cannot shadow the outer `m`, need to report ambiguity error\n-        //     m!();\n-        // }\n-        // So we have to save the innermost solution and continue searching in outer scopes\n-        // to detect potential ambiguities.\n-        let mut innermost_result: Option<&NameBinding> = None;\n-\n-        // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = parent_scope.legacy;\n-        loop {\n-            let result = match where_to_resolve {\n-                LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n-                    Some(legacy_binding.binding),\n-                _ => None,\n-            };\n-\n-            macro_rules! continue_search { () => {\n-                where_to_resolve = match where_to_resolve {\n-                    LegacyScope::Empty => break, // nowhere else to search\n-                    LegacyScope::Binding(binding) => binding.parent_legacy_scope,\n-                    LegacyScope::Invocation(invocation) => invocation.output_legacy_scope.get(),\n-                    LegacyScope::Uninitialized => unreachable!(),\n-                };\n-\n-                continue;\n-            }}\n-\n-            match result {\n-                Some(result) => {\n-                    if !record_used {\n-                        return Some(result);\n-                    }\n-\n-                    if let Some(innermost_result) = innermost_result {\n-                        // Found another solution, if the first one was \"weak\", report an error.\n-                        if result.def() != innermost_result.def() &&\n-                           innermost_result.may_appear_after(parent_scope.expansion, result) {\n-                            self.ambiguity_errors.push(AmbiguityError {\n-                                ident,\n-                                b1: innermost_result,\n-                                b2: result,\n-                            });\n-                            return Some(innermost_result);\n-                        }\n-                    } else {\n-                        // Found the first solution.\n-                        innermost_result = Some(result);\n-                    }\n-\n-                    continue_search!();\n-                }\n-                None => {\n-                    continue_search!();\n-                }\n-            }\n-        }\n-\n-        // The first found solution was the only one (or there was no solution at all), return it.\n-        innermost_result\n-    }\n-\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n@@ -916,80 +863,52 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         let legacy_macro_resolutions =\n             mem::replace(&mut *module.legacy_macro_resolutions.borrow_mut(), Vec::new());\n-        for (ident, kind, parent_scope, def) in legacy_macro_resolutions {\n-            let span = ident.span;\n-            let legacy_resolution = self.resolve_legacy_scope(\n-                ident, Some(kind), &parent_scope, true\n+        for (ident, kind, parent_scope, initial_binding) in legacy_macro_resolutions {\n+            let binding = self.early_resolve_ident_in_lexical_scope(\n+                ident, MacroNS, Some(kind), &parent_scope, true, true, ident.span\n             );\n-            let resolution = self.resolve_lexical_macro_path_segment(\n-                ident, MacroNS, Some(kind), &parent_scope, true, true, span\n-            );\n-\n-            let check_consistency = |this: &Self, new_def: Def| {\n-                if let Some(def) = def {\n-                    if this.ambiguity_errors.is_empty() && new_def != def && new_def != Def::Err {\n-                        // Make sure compilation does not succeed if preferred macro resolution\n-                        // has changed after the macro had been expanded. In theory all such\n-                        // situations should be reported as ambiguity errors, so this is span-bug.\n-                        span_bug!(span, \"inconsistent resolution for a macro\");\n+            match binding {\n+                Ok(binding) => {\n+                    let def = binding.def_ignoring_ambiguity();\n+                    if let Some(initial_binding) = initial_binding {\n+                        self.record_use(ident, MacroNS, initial_binding);\n+                        let initial_def = initial_binding.def_ignoring_ambiguity();\n+                        if self.ambiguity_errors.is_empty() &&\n+                           def != initial_def && def != Def::Err {\n+                            // Make sure compilation does not succeed if preferred macro resolution\n+                            // has changed after the macro had been expanded. In theory all such\n+                            // situations should be reported as ambiguity errors, so this is a bug.\n+                            span_bug!(ident.span, \"inconsistent resolution for a macro\");\n+                        }\n+                    } else {\n+                        // It's possible that the macro was unresolved (indeterminate) and silently\n+                        // expanded into a dummy fragment for recovery during expansion.\n+                        // Now, post-expansion, the resolution may succeed, but we can't change the\n+                        // past and need to report an error.\n+                        let msg = format!(\"cannot determine resolution for the {} `{}`\",\n+                                          kind.descr(), ident);\n+                        let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n+                        self.session.struct_span_err(ident.span, &msg).note(msg_note).emit();\n                     }\n-                } else {\n-                    // It's possible that the macro was unresolved (indeterminate) and silently\n-                    // expanded into a dummy fragment for recovery during expansion.\n-                    // Now, post-expansion, the resolution may succeed, but we can't change the\n-                    // past and need to report an error.\n-                    let msg =\n-                        format!(\"cannot determine resolution for the {} `{}`\", kind.descr(), ident);\n-                    let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n-                    this.session.struct_span_err(span, &msg).note(msg_note).emit();\n                 }\n-            };\n-\n-            match (legacy_resolution, resolution) {\n-                (None, Err(_)) => {\n-                    assert!(def.is_none());\n+                Err(..) => {\n+                    assert!(initial_binding.is_none());\n                     let bang = if kind == MacroKind::Bang { \"!\" } else { \"\" };\n                     let msg =\n                         format!(\"cannot find {} `{}{}` in this scope\", kind.descr(), ident, bang);\n-                    let mut err = self.session.struct_span_err(span, &msg);\n-                    self.suggest_macro_name(&ident.as_str(), kind, &mut err, span);\n+                    let mut err = self.session.struct_span_err(ident.span, &msg);\n+                    self.suggest_macro_name(&ident.as_str(), kind, &mut err, ident.span);\n                     err.emit();\n-                },\n-                (Some(legacy_binding), Ok((binding, FromPrelude(from_prelude))))\n-                        if legacy_binding.def() != binding.def_ignoring_ambiguity() &&\n-                           (!from_prelude &&\n-                            !self.disambiguate_legacy_vs_modern(legacy_binding, binding) ||\n-                            legacy_binding.may_appear_after(parent_scope.expansion, binding)) => {\n-                    self.report_ambiguity_error(ident, legacy_binding, binding);\n-                },\n-                // OK, non-macro-expanded legacy wins over prelude even if defs are different\n-                // Also, non-macro-expanded legacy wins over modern from the same module\n-                // Also, legacy and modern can co-exist if their defs are same\n-                (Some(legacy_binding), Ok(_)) |\n-                // OK, unambiguous resolution\n-                (Some(legacy_binding), Err(_)) => {\n-                    check_consistency(self, legacy_binding.def());\n-                }\n-                // OK, unambiguous resolution\n-                (None, Ok((binding, FromPrelude(from_prelude)))) => {\n-                    check_consistency(self, binding.def_ignoring_ambiguity());\n-                    if from_prelude {\n-                        self.record_use(ident, MacroNS, binding);\n-                    }\n                 }\n-            };\n+            }\n         }\n \n         let builtin_attrs = mem::replace(&mut *module.builtin_attrs.borrow_mut(), Vec::new());\n         for (ident, parent_scope) in builtin_attrs {\n-            let resolve_legacy = |this: &mut Self| this.resolve_legacy_scope(\n-                ident, Some(MacroKind::Attr), &parent_scope, true\n-            );\n-            let resolve_modern = |this: &mut Self| this.resolve_lexical_macro_path_segment(\n+            let binding = self.early_resolve_ident_in_lexical_scope(\n                 ident, MacroNS, Some(MacroKind::Attr), &parent_scope, true, true, ident.span\n-            ).map(|(binding, _)| binding).ok();\n-\n-            if let Some(binding) = resolve_legacy(self).or_else(|| resolve_modern(self)) {\n+            );\n+            if let Ok(binding) = binding {\n                 if binding.def_ignoring_ambiguity() !=\n                         Def::NonMacroAttr(NonMacroAttrKind::Builtin) {\n                     let builtin_binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),"}, {"sha": "6e9877b1ab66d2591c385991b07e7013bc6dd414", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         // expansion. With restricted shadowing names from globs and macro expansions cannot\n         // shadow names from outer scopes, so we can freely fallback from module search to search\n         // in outer scopes. To continue search in outer scopes we have to lie a bit and return\n-        // `Determined` to `resolve_lexical_macro_path_segment` even if the correct answer\n+        // `Determined` to `early_resolve_ident_in_lexical_scope` even if the correct answer\n         // for in-module resolution could be `Undetermined`.\n         if restricted_shadowing {\n             return Err(Determined);"}, {"sha": "9c9419c734722180a6682a6dc806531ec4e260eb", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 30, "deletions": 43, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -220,14 +220,6 @@ pub struct Invocation {\n     pub expansion_data: ExpansionData,\n }\n \n-// Needed for feature-gating attributes used after derives or together with test/bench\n-#[derive(Clone, Copy, PartialEq)]\n-pub enum TogetherWith {\n-    None,\n-    Derive,\n-    TestBench,\n-}\n-\n pub enum InvocationKind {\n     Bang {\n         mac: ast::Mac,\n@@ -238,7 +230,8 @@ pub enum InvocationKind {\n         attr: Option<ast::Attribute>,\n         traits: Vec<Path>,\n         item: Annotatable,\n-        together_with: TogetherWith,\n+        // We temporarily report errors for attribute macros placed after derives\n+        after_derive: bool,\n     },\n     Derive {\n         path: Path,\n@@ -1084,19 +1077,17 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                     traits: Vec<Path>,\n                     item: Annotatable,\n                     kind: AstFragmentKind,\n-                    together_with: TogetherWith)\n+                    after_derive: bool)\n                     -> AstFragment {\n-        self.collect(kind, InvocationKind::Attr { attr, traits, item, together_with })\n+        self.collect(kind, InvocationKind::Attr { attr, traits, item, after_derive })\n     }\n \n-    fn find_attr_invoc(&self, attrs: &mut Vec<ast::Attribute>, together_with: &mut TogetherWith)\n+    fn find_attr_invoc(&self, attrs: &mut Vec<ast::Attribute>, after_derive: &mut bool)\n                        -> Option<ast::Attribute> {\n         let attr = attrs.iter()\n                         .position(|a| {\n                             if a.path == \"derive\" {\n-                                *together_with = TogetherWith::Derive\n-                            } else if a.path == \"rustc_test_marker2\" {\n-                                *together_with = TogetherWith::TestBench\n+                                *after_derive = true;\n                             }\n                             !attr::is_known(a) && !is_builtin_attr(a)\n                         })\n@@ -1109,19 +1100,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                                  \"non-builtin inner attributes are unstable\");\n             }\n         }\n-        if together_with == &TogetherWith::None &&\n-           attrs.iter().any(|a| a.path == \"rustc_test_marker2\") {\n-            *together_with = TogetherWith::TestBench;\n-        }\n         attr\n     }\n \n     /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n     fn classify_item<T>(&mut self, mut item: T)\n-                        -> (Option<ast::Attribute>, Vec<Path>, T, TogetherWith)\n+                        -> (Option<ast::Attribute>, Vec<Path>, T, /* after_derive */ bool)\n         where T: HasAttrs,\n     {\n-        let (mut attr, mut traits, mut together_with) = (None, Vec::new(), TogetherWith::None);\n+        let (mut attr, mut traits, mut after_derive) = (None, Vec::new(), false);\n \n         item = item.map_attrs(|mut attrs| {\n             if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs,\n@@ -1130,20 +1117,20 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 return attrs;\n             }\n \n-            attr = self.find_attr_invoc(&mut attrs, &mut together_with);\n+            attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n             traits = collect_derives(&mut self.cx, &mut attrs);\n             attrs\n         });\n \n-        (attr, traits, item, together_with)\n+        (attr, traits, item, after_derive)\n     }\n \n     /// Alternative of `classify_item()` that ignores `#[derive]` so invocations fallthrough\n     /// to the unused-attributes lint (making it an error on statements and expressions\n     /// is a breaking change)\n     fn classify_nonitem<T: HasAttrs>(&mut self, mut item: T)\n-                                     -> (Option<ast::Attribute>, T, TogetherWith) {\n-        let (mut attr, mut together_with) = (None, TogetherWith::None);\n+                                     -> (Option<ast::Attribute>, T, /* after_derive */ bool) {\n+        let (mut attr, mut after_derive) = (None, false);\n \n         item = item.map_attrs(|mut attrs| {\n             if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs,\n@@ -1152,11 +1139,11 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 return attrs;\n             }\n \n-            attr = self.find_attr_invoc(&mut attrs, &mut together_with);\n+            attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n             attrs\n         });\n \n-        (attr, item, together_with)\n+        (attr, item, after_derive)\n     }\n \n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n@@ -1195,7 +1182,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n         // ignore derives so they remain unused\n-        let (attr, expr, together_with) = self.classify_nonitem(expr);\n+        let (attr, expr, after_derive) = self.classify_nonitem(expr);\n \n         if attr.is_some() {\n             // collect the invoc regardless of whether or not attributes are permitted here\n@@ -1204,7 +1191,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n             // AstFragmentKind::Expr requires the macro to emit an expression\n             return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     AstFragmentKind::Expr, together_with).make_expr();\n+                                     AstFragmentKind::Expr, after_derive).make_expr();\n         }\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n@@ -1220,13 +1207,13 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n         // ignore derives so they remain unused\n-        let (attr, expr, together_with) = self.classify_nonitem(expr);\n+        let (attr, expr, after_derive) = self.classify_nonitem(expr);\n \n         if attr.is_some() {\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n             return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     AstFragmentKind::OptExpr, together_with).make_opt_expr();\n+                                     AstFragmentKind::OptExpr, after_derive).make_opt_expr();\n         }\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n@@ -1258,18 +1245,18 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n-            let (attr, derives, stmt_, together_with) = if stmt.is_item() {\n+            let (attr, derives, stmt_, after_derive) = if stmt.is_item() {\n                 self.classify_item(stmt)\n             } else {\n                 // ignore derives on non-item statements so it falls through\n                 // to the unused-attributes lint\n-                let (attr, stmt, together_with) = self.classify_nonitem(stmt);\n-                (attr, vec![], stmt, together_with)\n+                let (attr, stmt, after_derive) = self.classify_nonitem(stmt);\n+                (attr, vec![], stmt, after_derive)\n             };\n \n             if attr.is_some() || !derives.is_empty() {\n                 return self.collect_attr(attr, derives, Annotatable::Stmt(P(stmt_)),\n-                                         AstFragmentKind::Stmts, together_with).make_stmts();\n+                                         AstFragmentKind::Stmts, after_derive).make_stmts();\n             }\n \n             stmt = stmt_;\n@@ -1311,10 +1298,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let item = configure!(self, item);\n \n-        let (attr, traits, item, together_with) = self.classify_item(item);\n+        let (attr, traits, item, after_derive) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             return self.collect_attr(attr, traits, Annotatable::Item(item),\n-                                     AstFragmentKind::Items, together_with).make_items();\n+                                     AstFragmentKind::Items, after_derive).make_items();\n         }\n \n         match item.node {\n@@ -1386,10 +1373,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n         let item = configure!(self, item);\n \n-        let (attr, traits, item, together_with) = self.classify_item(item);\n+        let (attr, traits, item, after_derive) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             return self.collect_attr(attr, traits, Annotatable::TraitItem(P(item)),\n-                                     AstFragmentKind::TraitItems, together_with).make_trait_items()\n+                                     AstFragmentKind::TraitItems, after_derive).make_trait_items()\n         }\n \n         match item.node {\n@@ -1405,10 +1392,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n         let item = configure!(self, item);\n \n-        let (attr, traits, item, together_with) = self.classify_item(item);\n+        let (attr, traits, item, after_derive) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             return self.collect_attr(attr, traits, Annotatable::ImplItem(P(item)),\n-                                     AstFragmentKind::ImplItems, together_with).make_impl_items();\n+                                     AstFragmentKind::ImplItems, after_derive).make_impl_items();\n         }\n \n         match item.node {\n@@ -1440,11 +1427,11 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_foreign_item(&mut self, foreign_item: ast::ForeignItem)\n         -> SmallVec<[ast::ForeignItem; 1]>\n     {\n-        let (attr, traits, foreign_item, together_with) = self.classify_item(foreign_item);\n+        let (attr, traits, foreign_item, after_derive) = self.classify_item(foreign_item);\n \n         if attr.is_some() || !traits.is_empty() {\n             return self.collect_attr(attr, traits, Annotatable::ForeignItem(P(foreign_item)),\n-                                     AstFragmentKind::ForeignItems, together_with)\n+                                     AstFragmentKind::ForeignItems, after_derive)\n                                      .make_foreign_items();\n         }\n "}, {"sha": "3b4e00a515d3ea305c5731441c5983b072f35502", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -995,10 +995,6 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                      \"the `#[rustc_test_marker]` attribute \\\n                                       is used internally to track tests\",\n                                      cfg_fn!(rustc_attrs))),\n-    (\"rustc_test_marker2\", Normal, Gated(Stability::Unstable,\n-                                         \"rustc_attrs\",\n-                                         \"temporarily used by rustc to report some errors\",\n-                                         cfg_fn!(rustc_attrs))),\n     (\"rustc_transparent_macro\", Whitelisted, Gated(Stability::Unstable,\n                                                    \"rustc_attrs\",\n                                                    \"used internally for testing macro hygiene\","}, {"sha": "be3485cfa7cc23a5e2c8a40e3a22e42ac4822f39", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -49,7 +49,7 @@ pub fn expand_test_or_bench(\n     // If we're not in test configuration, remove the annotated item\n     if !cx.ecfg.should_test { return vec![]; }\n \n-    let mut item =\n+    let item =\n         if let Annotatable::Item(i) = item { i }\n         else {\n             cx.parse_sess.span_diagnostic.span_fatal(item.span(),\n@@ -192,12 +192,6 @@ pub fn expand_test_or_bench(\n \n     debug!(\"Synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n \n-    // Temporarily add another marker to the original item for error reporting\n-    let marker2 = cx.attribute(\n-        attr_sp, cx.meta_word(attr_sp, Symbol::intern(\"rustc_test_marker2\"))\n-    );\n-    item.attrs.push(marker2);\n-\n     vec![\n         // Access to libtest under a gensymed name\n         Annotatable::Item(test_extern),"}, {"sha": "f51a6aae068a121903fe8a357a4fd01923cc34e9", "filename": "src/test/run-pass-fulldeps/macro-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -19,8 +19,8 @@\n #[macro_use] #[no_link]\n extern crate macro_crate_test;\n \n-#[derive(PartialEq, Clone, Debug)]\n #[rustc_into_multi_foo]\n+#[derive(PartialEq, Clone, Debug)]\n fn foo() -> AnotherFakeTypeThatHadBetterGoAway {}\n \n // Check that the `#[into_multi_foo]`-generated `foo2` is configured away"}, {"sha": "7b1eecd1558659f4665d2978d9839febc9074710", "filename": "src/test/ui-fulldeps/attribute-order-restricted.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.rs?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -1,9 +1,5 @@\n // aux-build:attr_proc_macro.rs\n-// compile-flags:--test\n \n-#![feature(test)]\n-\n-extern crate test;\n extern crate attr_proc_macro;\n use attr_proc_macro::*;\n \n@@ -15,18 +11,4 @@ struct Before;\n #[attr_proc_macro] //~ ERROR macro attributes must be placed before `#[derive]`\n struct After;\n \n-#[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-#[test]\n-fn test_before() {}\n-\n-#[test]\n-#[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-fn test_after() {}\n-\n-#[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-#[bench]\n-fn bench_before(b: &mut test::Bencher) {}\n-\n-#[bench]\n-#[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-fn bench_after(b: &mut test::Bencher) {}\n+fn main() {}"}, {"sha": "a4f165cd1b52c65470e116dbed27a4c33152c9b3", "filename": "src/test/ui-fulldeps/attribute-order-restricted.stderr", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.stderr?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -1,32 +1,8 @@\n error: macro attributes must be placed before `#[derive]`\n-  --> $DIR/attribute-order-restricted.rs:15:1\n+  --> $DIR/attribute-order-restricted.rs:11:1\n    |\n LL | #[attr_proc_macro] //~ ERROR macro attributes must be placed before `#[derive]`\n    | ^^^^^^^^^^^^^^^^^^\n \n-error: macro attributes cannot be used together with `#[test]` or `#[bench]`\n-  --> $DIR/attribute-order-restricted.rs:18:1\n-   |\n-LL | #[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-   | ^^^^^^^^^^^^^^^^^^\n-\n-error: macro attributes cannot be used together with `#[test]` or `#[bench]`\n-  --> $DIR/attribute-order-restricted.rs:23:1\n-   |\n-LL | #[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-   | ^^^^^^^^^^^^^^^^^^\n-\n-error: macro attributes cannot be used together with `#[test]` or `#[bench]`\n-  --> $DIR/attribute-order-restricted.rs:26:1\n-   |\n-LL | #[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-   | ^^^^^^^^^^^^^^^^^^\n-\n-error: macro attributes cannot be used together with `#[test]` or `#[bench]`\n-  --> $DIR/attribute-order-restricted.rs:31:1\n-   |\n-LL | #[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-   | ^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to previous error\n "}, {"sha": "7e5ab0c5abe07596fa3cfaac5249cd1f18b62b47", "filename": "src/test/ui/imports/shadow_builtin_macros.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60c846046ec26c9e5c1216a6e118cc2e69a2956c/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr?ref=60c846046ec26c9e5c1216a6e118cc2e69a2956c", "patch": "@@ -1,20 +1,3 @@\n-error[E0659]: `panic` is ambiguous\n-  --> $DIR/shadow_builtin_macros.rs:43:5\n-   |\n-LL |     panic!(); //~ ERROR `panic` is ambiguous\n-   |     ^^^^^ ambiguous name\n-   |\n-note: `panic` could refer to the name defined here\n-  --> $DIR/shadow_builtin_macros.rs:40:9\n-   |\n-LL |         macro_rules! panic { () => {} }\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-LL |     } }\n-LL |     m!();\n-   |     ----- in this macro invocation\n-   = note: `panic` is also a builtin macro\n-   = note: macro-expanded macros do not shadow\n-\n error[E0659]: `panic` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:25:14\n    |\n@@ -43,6 +26,23 @@ LL |     ::two_macros::m!(use foo::panic;);\n    = note: `panic` is also a builtin macro\n    = note: macro-expanded macro imports do not shadow\n \n+error[E0659]: `panic` is ambiguous\n+  --> $DIR/shadow_builtin_macros.rs:43:5\n+   |\n+LL |     panic!(); //~ ERROR `panic` is ambiguous\n+   |     ^^^^^ ambiguous name\n+   |\n+note: `panic` could refer to the name defined here\n+  --> $DIR/shadow_builtin_macros.rs:40:9\n+   |\n+LL |         macro_rules! panic { () => {} }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     } }\n+LL |     m!();\n+   |     ----- in this macro invocation\n+   = note: `panic` is also a builtin macro\n+   = note: macro-expanded macros do not shadow\n+\n error[E0659]: `n` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:59:5\n    |"}]}