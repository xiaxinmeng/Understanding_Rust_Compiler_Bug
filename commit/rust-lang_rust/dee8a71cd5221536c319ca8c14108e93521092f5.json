{"sha": "dee8a71cd5221536c319ca8c14108e93521092f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZThhNzFjZDUyMjE1MzZjMzE5Y2E4YzE0MTA4ZTkzNTIxMDkyZjU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-10-02T13:15:23Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2017-11-26T14:12:43Z"}, "message": "fix #[derive] implementation for repr(packed) structs\n\nFix the derive implementation for repr(packed) structs to move the\nfields out instead of calling functions on references to each subfield.\n\nThat's it, `#[derive(PartialEq)]` on a packed struct now does:\n```Rust\nfn eq(&self, other: &Self) {\n    let field_0 = self.0;\n    let other_field_0 = other.0;\n    &field_0 == &other_field_0\n}\n```\n\nInstead of\n```Rust\nfn eq(&self, other: &Self) {\n    let ref field_0 = self.0;\n    let ref other_field_0 = other.0;\n    &*field_0 == &*other_field_0\n}\n```\n\nTaking (unaligned) references to each subfield is undefined, unsound and\nis an error with MIR effectck, so it had to be prevented. This causes\na borrowck error when a `repr(packed)` struct has a non-Copy field (and\ntherefore is a [breaking-change]), but I don't see a sound way to avoid\nthat error.", "tree": {"sha": "61b09dc7938e27204cd5f6c05bda56cce7e9f356", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61b09dc7938e27204cd5f6c05bda56cce7e9f356"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dee8a71cd5221536c319ca8c14108e93521092f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dee8a71cd5221536c319ca8c14108e93521092f5", "html_url": "https://github.com/rust-lang/rust/commit/dee8a71cd5221536c319ca8c14108e93521092f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dee8a71cd5221536c319ca8c14108e93521092f5/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1a2d443f55ce05fa96f309b94ceabf4813f06045", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a2d443f55ce05fa96f309b94ceabf4813f06045", "html_url": "https://github.com/rust-lang/rust/commit/1a2d443f55ce05fa96f309b94ceabf4813f06045"}], "stats": {"total": 169, "additions": 138, "deletions": 31}, "files": [{"sha": "5abf524313acb8b4a753c73d04b1a7a449129b13", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 64, "deletions": 16, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/dee8a71cd5221536c319ca8c14108e93521092f5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee8a71cd5221536c319ca8c14108e93521092f5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=dee8a71cd5221536c319ca8c14108e93521092f5", "patch": "@@ -393,34 +393,47 @@ fn find_type_parameters(ty: &ast::Ty,\n }\n \n impl<'a> TraitDef<'a> {\n-    pub fn expand(&self,\n+    pub fn expand(self,\n                   cx: &mut ExtCtxt,\n                   mitem: &ast::MetaItem,\n                   item: &'a Annotatable,\n                   push: &mut FnMut(Annotatable)) {\n         self.expand_ext(cx, mitem, item, push, false);\n     }\n \n-    pub fn expand_ext(&self,\n+    pub fn expand_ext(self,\n                       cx: &mut ExtCtxt,\n                       mitem: &ast::MetaItem,\n                       item: &'a Annotatable,\n                       push: &mut FnMut(Annotatable),\n                       from_scratch: bool) {\n         match *item {\n             Annotatable::Item(ref item) => {\n+                let is_packed = item.attrs.iter().any(|attr| {\n+                    attr::find_repr_attrs(&cx.parse_sess.span_diagnostic, attr)\n+                        .contains(&attr::ReprPacked)\n+                });\n+                let use_temporaries = is_packed;\n                 let newitem = match item.node {\n                     ast::ItemKind::Struct(ref struct_def, ref generics) => {\n-                        self.expand_struct_def(cx, &struct_def, item.ident, generics, from_scratch)\n+                        self.expand_struct_def(cx, &struct_def, item.ident, generics, from_scratch,\n+                                               use_temporaries)\n                     }\n                     ast::ItemKind::Enum(ref enum_def, ref generics) => {\n+                        // We ignore `use_temporaries` here, because\n+                        // `repr(packed)` enums cause an error later on.\n+                        //\n+                        // This can only cause further compilation errors\n+                        // downstream in blatantly illegal code, so it\n+                        // is fine.\n                         self.expand_enum_def(cx, enum_def, &item.attrs,\n                                              item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Union(ref struct_def, ref generics) => {\n                         if self.supports_unions {\n                             self.expand_struct_def(cx, &struct_def, item.ident,\n-                                                   generics, from_scratch)\n+                                                   generics, from_scratch,\n+                                                   use_temporaries)\n                         } else {\n                             cx.span_err(mitem.span,\n                                         \"this trait cannot be derived for unions\");\n@@ -675,7 +688,8 @@ impl<'a> TraitDef<'a> {\n                          struct_def: &'a VariantData,\n                          type_ident: Ident,\n                          generics: &Generics,\n-                         from_scratch: bool)\n+                         from_scratch: bool,\n+                         use_temporaries: bool)\n                          -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> = struct_def.fields()\n             .iter()\n@@ -701,7 +715,8 @@ impl<'a> TraitDef<'a> {\n                                                          struct_def,\n                                                          type_ident,\n                                                          &self_args[..],\n-                                                         &nonself_args[..])\n+                                                         &nonself_args[..],\n+                                                         use_temporaries)\n                 };\n \n                 method_def.create_method(cx,\n@@ -958,14 +973,31 @@ impl<'a> MethodDef<'a> {\n     ///         }\n     ///     }\n     /// }\n+    ///\n+    /// // or if A is repr(packed) - note fields are matched by-value\n+    /// // instead of by-reference.\n+    /// impl PartialEq for A {\n+    ///     fn eq(&self, __arg_1: &A) -> bool {\n+    ///         match *self {\n+    ///             A {x: __self_0_0, y: __self_0_1} => {\n+    ///                 match __arg_1 {\n+    ///                     A {x: __self_1_0, y: __self_1_1} => {\n+    ///                         __self_0_0.eq(&__self_1_0) && __self_0_1.eq(&__self_1_1)\n+    ///                     }\n+    ///                 }\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n     /// ```\n     fn expand_struct_method_body<'b>(&self,\n                                      cx: &mut ExtCtxt,\n                                      trait_: &TraitDef<'b>,\n                                      struct_def: &'b VariantData,\n                                      type_ident: Ident,\n                                      self_args: &[P<Expr>],\n-                                     nonself_args: &[P<Expr>])\n+                                     nonself_args: &[P<Expr>],\n+                                     use_temporaries: bool)\n                                      -> P<Expr> {\n \n         let mut raw_fields = Vec::new(); // Vec<[fields of self],\n@@ -977,7 +1009,8 @@ impl<'a> MethodDef<'a> {\n                                                                  struct_path,\n                                                                  struct_def,\n                                                                  &format!(\"__self_{}\", i),\n-                                                                 ast::Mutability::Immutable);\n+                                                                 ast::Mutability::Immutable,\n+                                                                 use_temporaries);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n         }\n@@ -1140,7 +1173,6 @@ impl<'a> MethodDef<'a> {\n                                   self_args: Vec<P<Expr>>,\n                                   nonself_args: &[P<Expr>])\n                                   -> P<Expr> {\n-\n         let sp = trait_.span;\n         let variants = &enum_def.variants;\n \n@@ -1512,12 +1544,18 @@ impl<'a> TraitDef<'a> {\n     fn create_subpatterns(&self,\n                           cx: &mut ExtCtxt,\n                           field_paths: Vec<ast::SpannedIdent>,\n-                          mutbl: ast::Mutability)\n+                          mutbl: ast::Mutability,\n+                          use_temporaries: bool)\n                           -> Vec<P<ast::Pat>> {\n         field_paths.iter()\n             .map(|path| {\n+                let binding_mode = if use_temporaries {\n+                    ast::BindingMode::ByValue(ast::Mutability::Immutable)\n+                } else {\n+                    ast::BindingMode::ByRef(mutbl)\n+                };\n                 cx.pat(path.span,\n-                       PatKind::Ident(ast::BindingMode::ByRef(mutbl), (*path).clone(), None))\n+                       PatKind::Ident(binding_mode, (*path).clone(), None))\n             })\n             .collect()\n     }\n@@ -1528,8 +1566,10 @@ impl<'a> TraitDef<'a> {\n          struct_path: ast::Path,\n          struct_def: &'a VariantData,\n          prefix: &str,\n-         mutbl: ast::Mutability)\n-         -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n+         mutbl: ast::Mutability,\n+         use_temporaries: bool)\n+         -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>)\n+    {\n         let mut paths = Vec::new();\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n@@ -1539,12 +1579,18 @@ impl<'a> TraitDef<'a> {\n                 span: sp,\n                 node: ident,\n             });\n-            let val = cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp, ident)));\n+            let val = cx.expr_path(cx.path_ident(sp, ident));\n+            let val = if use_temporaries {\n+                val\n+            } else {\n+                cx.expr_deref(sp, val)\n+            };\n             let val = cx.expr(sp, ast::ExprKind::Paren(val));\n+\n             ident_exprs.push((sp, struct_field.ident, val, &struct_field.attrs[..]));\n         }\n \n-        let subpats = self.create_subpatterns(cx, paths, mutbl);\n+        let subpats = self.create_subpatterns(cx, paths, mutbl, use_temporaries);\n         let pattern = match *struct_def {\n             VariantData::Struct(..) => {\n                 let field_pats = subpats.into_iter()\n@@ -1588,7 +1634,9 @@ impl<'a> TraitDef<'a> {\n         let variant_ident = variant.node.name;\n         let sp = variant.span.with_ctxt(self.span.ctxt());\n         let variant_path = cx.path(sp, vec![enum_ident, variant_ident]);\n-        self.create_struct_pattern(cx, variant_path, &variant.node.data, prefix, mutbl)\n+        let use_temporaries = false; // enums can't be repr(packed)\n+        self.create_struct_pattern(cx, variant_path, &variant.node.data, prefix, mutbl,\n+                                   use_temporaries)\n     }\n }\n "}, {"sha": "b23e40ce7a932787be02a642d5ac70e0d2989b3c", "filename": "src/libsyntax_pos/span_encoding.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dee8a71cd5221536c319ca8c14108e93521092f5/src%2Flibsyntax_pos%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee8a71cd5221536c319ca8c14108e93521092f5/src%2Flibsyntax_pos%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fspan_encoding.rs?ref=dee8a71cd5221536c319ca8c14108e93521092f5", "patch": "@@ -19,30 +19,16 @@ use hygiene::SyntaxContext;\n \n use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n-use std::hash::{Hash, Hasher};\n \n /// A compressed span.\n /// Contains either fields of `SpanData` inline if they are small, or index into span interner.\n /// The primary goal of `Span` is to be as small as possible and fit into other structures\n /// (that's why it uses `packed` as well). Decoding speed is the second priority.\n /// See `SpanData` for the info on span fields in decoded representation.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n #[repr(packed)]\n pub struct Span(u32);\n \n-impl PartialEq for Span {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool { ({self.0}) == ({other.0}) }\n-}\n-\n-impl Eq for Span {}\n-\n-impl Hash for Span {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        {self.0}.hash(s)\n-    }\n-}\n-\n /// Dummy span, both position and length are zero, syntax context is zero as well.\n /// This span is kept inline and encoded with format 0.\n pub const DUMMY_SP: Span = Span(0);"}, {"sha": "5ab916b91fa3d50a6eab244d7dadbe2528204629", "filename": "src/test/compile-fail/deriving-with-repr-packed-not-copy.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dee8a71cd5221536c319ca8c14108e93521092f5/src%2Ftest%2Fcompile-fail%2Fderiving-with-repr-packed-not-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee8a71cd5221536c319ca8c14108e93521092f5/src%2Ftest%2Fcompile-fail%2Fderiving-with-repr-packed-not-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-with-repr-packed-not-copy.rs?ref=dee8a71cd5221536c319ca8c14108e93521092f5", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that derive on a packed struct with non-Copy fields\n+// correctly. This can't be made to work perfectly because\n+// we can't just use the field from the struct as it might\n+// not be aligned.\n+\n+#[derive(PartialEq)]\n+struct Y(usize);\n+\n+#[derive(PartialEq)]\n+//~^ ERROR cannot move out of borrowed\n+//~| ERROR cannot move out of borrowed\n+//~| ERROR cannot move out of borrowed\n+//~| ERROR cannot move out of borrowed\n+#[repr(packed)]\n+struct X(Y);\n+\n+fn main() {\n+}"}, {"sha": "fcc31b462f8c3458dfaa558fe903d82a1ca6d9b9", "filename": "src/test/run-pass/deriving-with-repr-packed.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/dee8a71cd5221536c319ca8c14108e93521092f5/src%2Ftest%2Frun-pass%2Fderiving-with-repr-packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee8a71cd5221536c319ca8c14108e93521092f5/src%2Ftest%2Frun-pass%2Fderiving-with-repr-packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-with-repr-packed.rs?ref=dee8a71cd5221536c319ca8c14108e93521092f5", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that derive on a packed struct does not call field\n+// methods with a misaligned field.\n+\n+use std::mem;\n+\n+#[derive(Copy, Clone)]\n+struct Aligned(usize);\n+\n+#[inline(never)]\n+fn check_align(ptr: *const Aligned) {\n+    assert_eq!(ptr as usize % mem::align_of::<Aligned>(),\n+               0);\n+}\n+\n+impl PartialEq for Aligned {\n+    fn eq(&self, other: &Self) -> bool {\n+        check_align(self);\n+        check_align(other);\n+        self.0 == other.0\n+    }\n+}\n+\n+#[repr(packed)]\n+#[derive(PartialEq)]\n+struct Packed(Aligned, Aligned);\n+\n+#[derive(PartialEq)]\n+#[repr(C)]\n+struct Dealigned<T>(u8, T);\n+\n+fn main() {\n+    let d1 = Dealigned(0, Packed(Aligned(1), Aligned(2)));\n+    let ck = d1 == d1;\n+    assert!(ck);\n+}"}]}