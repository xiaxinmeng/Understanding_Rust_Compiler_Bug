{"sha": "91f34c0c70746f5c938d25d02a8a66b41240b2f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZjM0YzBjNzA3NDZmNWM5MzhkMjVkMDJhOGE2NmI0MTI0MGIyZjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-29T04:55:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-29T04:55:15Z"}, "message": "Auto merge of #36818 - jonathandturner:rollup, r=jonathandturner\n\nRollup of 12 pull requests\n\n- Successful merges: #35286, #35892, #36460, #36704, #36741, #36760, #36787, #36789, #36794, #36803, #36811, #36813\n- Failed merges:", "tree": {"sha": "5181cf125d06fbb10f8a3d2271003dce4a9f8b62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5181cf125d06fbb10f8a3d2271003dce4a9f8b62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91f34c0c70746f5c938d25d02a8a66b41240b2f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91f34c0c70746f5c938d25d02a8a66b41240b2f0", "html_url": "https://github.com/rust-lang/rust/commit/91f34c0c70746f5c938d25d02a8a66b41240b2f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91f34c0c70746f5c938d25d02a8a66b41240b2f0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eee2d04d877fe909309c39b6bdf711dc586d0a1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/eee2d04d877fe909309c39b6bdf711dc586d0a1e", "html_url": "https://github.com/rust-lang/rust/commit/eee2d04d877fe909309c39b6bdf711dc586d0a1e"}, {"sha": "f12f9504b33b3e98952bc2bbca41fe0b81fac6fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/f12f9504b33b3e98952bc2bbca41fe0b81fac6fe", "html_url": "https://github.com/rust-lang/rust/commit/f12f9504b33b3e98952bc2bbca41fe0b81fac6fe"}], "stats": {"total": 1502, "additions": 694, "deletions": 808}, "files": [{"sha": "59a3c1c828d4edfddc9b1fdd736d281bcf4b11f0", "filename": "configure", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/configure", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -645,7 +645,6 @@ valopt datadir \"${CFG_PREFIX}/share\" \"install data\"\n valopt infodir \"${CFG_PREFIX}/share/info\" \"install additional info\"\n valopt llvm-root \"\" \"set LLVM root\"\n valopt python \"\" \"set path to python\"\n-valopt nodejs \"\" \"set path to nodejs\"\n valopt jemalloc-root \"\" \"set directory where libjemalloc_pic.a is located\"\n valopt build \"${DEFAULT_BUILD}\" \"GNUs ./configure syntax LLVM build triple\"\n valopt android-cross-path \"\" \"Android NDK standalone path (deprecated)\"\n@@ -762,9 +761,6 @@ if [ $(echo $python_version | grep -c '^Python 2\\.7') -ne 1 ]; then\n     err \"Found $python_version, but Python 2.7 is required\"\n fi\n \n-# Checking for node, but not required\n-probe CFG_NODEJS nodejs node\n-\n # If we have no git directory then we are probably a tarball distribution\n # and shouldn't attempt to load submodules\n if [ ! -e ${CFG_SRC_DIR}.git ]"}, {"sha": "cdbbc229bc84e091e22a7c35f2261af9d262848c", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -104,8 +104,7 @@ fn main() {\n         let is_panic_abort = args.windows(2).any(|a| {\n             &*a[0] == \"--crate-name\" && &*a[1] == \"panic_abort\"\n         });\n-        // FIXME(stage0): remove this `stage != \"0\"` condition\n-        if is_panic_abort && stage != \"0\" {\n+        if is_panic_abort {\n             cmd.arg(\"-C\").arg(\"panic=abort\");\n         }\n "}, {"sha": "16dbcae99fa1df2da3b816d8af5590496f37f9ba", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -25,7 +25,7 @@ use std::process::Command;\n use build_helper::output;\n use filetime::FileTime;\n \n-use util::{exe, staticlib, libdir, mtime, is_dylib, copy};\n+use util::{exe, libdir, mtime, is_dylib, copy};\n use {Build, Compiler, Mode};\n \n /// Build the standard library.\n@@ -40,20 +40,6 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     let libdir = build.sysroot_libdir(compiler, target);\n     let _ = fs::remove_dir_all(&libdir);\n     t!(fs::create_dir_all(&libdir));\n-    // FIXME(stage0) remove this `if` after the next snapshot\n-    // The stage0 compiler still passes the `-lcompiler-rt` flag to the linker but now `bootstrap`\n-    // never builds a `libcopmiler-rt.a`! We'll fill the hole by simply copying stage0's\n-    // `libcompiler-rt.a` to where the stage1's one is expected (though we could as well just use\n-    // an empty `.a` archive). Note that the symbols of that stage0 `libcompiler-rt.a` won't make\n-    // it to the final binary because now `libcore.rlib` also contains the symbols that\n-    // `libcompiler-rt.a` provides. Since that rlib appears first in the linker arguments, its\n-    // symbols are used instead of `libcompiler-rt.a`'s.\n-    if compiler.stage == 0 {\n-        let rtlib = &staticlib(\"compiler-rt\", target);\n-        let src = build.rustc.parent().unwrap().parent().unwrap().join(\"lib\").join(\"rustlib\")\n-            .join(target).join(\"lib\").join(rtlib);\n-        copy(&src, &libdir.join(rtlib));\n-    }\n \n     // Some platforms have startup objects that may be required to produce the\n     // libstd dynamic library, for example."}, {"sha": "a8434c3efb3589d256639129fe0d605a2796fab9", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -396,9 +396,6 @@ impl Config {\n                     self.rustc = Some(PathBuf::from(value).join(\"bin/rustc\"));\n                     self.cargo = Some(PathBuf::from(value).join(\"bin/cargo\"));\n                 }\n-                \"CFG_NODEJS\" if value.len() > 0 => {\n-                    self.nodejs = Some(PathBuf::from(value));\n-                }\n                 _ => {}\n             }\n         }"}, {"sha": "962d0666f69f192f8fbb8a37a54fb7ee40ccad92", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -40,17 +40,23 @@ pub fn check(build: &mut Build) {\n             panic!(\"PATH contains invalid character '\\\"'\");\n         }\n     }\n-    let mut need_cmd = |cmd: &OsStr| {\n-        if !checked.insert(cmd.to_owned()) {\n-            return\n-        }\n+    let have_cmd = |cmd: &OsStr| {\n         for path in env::split_paths(&path).map(|p| p.join(cmd)) {\n             if fs::metadata(&path).is_ok() ||\n                fs::metadata(path.with_extension(\"exe\")).is_ok() {\n-                return\n+                return Some(path);\n             }\n         }\n-        panic!(\"\\n\\ncouldn't find required command: {:?}\\n\\n\", cmd);\n+        return None;\n+    };\n+\n+    let mut need_cmd = |cmd: &OsStr| {\n+        if !checked.insert(cmd.to_owned()) {\n+            return\n+        }\n+        if have_cmd(cmd).is_none() {\n+            panic!(\"\\n\\ncouldn't find required command: {:?}\\n\\n\", cmd);\n+        }\n     };\n \n     // If we've got a git directory we're gona need git to update\n@@ -75,8 +81,13 @@ pub fn check(build: &mut Build) {\n \n     need_cmd(\"python\".as_ref());\n \n-    // If a manual nodejs was added to the config,\n-    // of if a nodejs install is detected through config, use it.\n+    // Look for the nodejs command, needed for emscripten testing\n+    if let Some(node) = have_cmd(\"node\".as_ref()) {\n+        build.config.nodejs = Some(node);\n+    } else if let Some(node) = have_cmd(\"nodejs\".as_ref()) {\n+        build.config.nodejs = Some(node);\n+    }\n+\n     if let Some(ref s) = build.config.nodejs {\n         need_cmd(s.as_ref());\n     }"}, {"sha": "1e05b01d30d46531843a8b1a3cd45767f0013772", "filename": "src/doc/book/syntax-index.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fdoc%2Fbook%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fdoc%2Fbook%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsyntax-index.md?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -61,7 +61,6 @@\n * `-` (`- expr`): arithmetic negation.  Overloadable (`Neg`).\n * `-=` (`var -= expr`): arithmetic subtraction & assignment. Overloadable (`SubAssign`).\n * `->` (`fn(\u2026) -> type`, `|\u2026| -> type`): function and closure return type.  See [Functions], [Closures].\n-* `-> !` (`fn(\u2026) -> !`, `|\u2026| -> !`): diverging function or closure. See [Diverging Functions].\n * `.` (`expr.ident`): member access.  See [Structs], [Method Syntax].\n * `..` (`..`, `expr..`, `..expr`, `expr..expr`): right-exclusive range literal.\n * `..` (`..expr`): struct literal update syntax.  See [Structs (Update syntax)].\n@@ -159,6 +158,10 @@\n * `/*!\u2026*/`: inner block doc comment.  See [Comments].\n * `/**\u2026*/`: outer block doc comment.  See [Comments].\n \n+<!-- Special types -->\n+\n+* `!`: always empty Never type.  See [Diverging Functions].\n+\n <!-- Various things involving parens and tuples -->\n \n * `()`: empty tuple (*a.k.a.* unit), both literal and type."}, {"sha": "690d44cc2cb7bc1585624121a5f99724df337957", "filename": "src/doc/grammar.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -764,6 +764,13 @@ bound-list := bound | bound '+' bound-list\n bound := path | lifetime\n ```\n \n+### Never type\n+An empty type\n+\n+```antlr\n+never_type : \"!\" ;\n+```\n+\n ### Object types\n \n **FIXME:** grammar?"}, {"sha": "e3c92fc1aa8301950e1f107d758050e0093ed60d", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -127,7 +127,6 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// }\n /// ```\n \n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n     ptr: Shared<ArcInner<T>>,\n@@ -153,7 +152,6 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n /// nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n /// as `Weak<T>` pointers.\n \n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     ptr: Shared<ArcInner<T>>,"}, {"sha": "31491106d97ee1b22a88d9f1184adc6322c56926", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -88,7 +88,6 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unique)]\n-#![cfg_attr(stage0, feature(unsafe_no_drop_flag))]\n #![feature(unsize)]\n \n #![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol))]"}, {"sha": "e153507956b9f9907452d56170a223260e26ee4a", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -44,7 +44,6 @@ use core::cmp;\n /// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n pub struct RawVec<T> {\n     ptr: Unique<T>,\n     cap: usize,"}, {"sha": "4a4de419f2ede5bf9ce5dc8e4e8b04f46f8348d5", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -252,7 +252,6 @@ struct RcBox<T: ?Sized> {\n /// that you have to call them as e.g. `Rc::get_mut(&value)` instead of\n /// `value.get_mut()`.  This avoids conflicts with methods of the inner\n /// type `T`.\n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n     ptr: Shared<RcBox<T>>,\n@@ -873,7 +872,6 @@ impl<T> From<T> for Rc<T> {\n ///\n /// [rc]: struct.Rc.html\n /// [downgrade]: struct.Rc.html#method.downgrade\n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     ptr: Shared<RcBox<T>>,"}, {"sha": "990de541b6783db047df209c0c013f7c5502bca7", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -52,7 +52,6 @@\n #![feature(step_by)]\n #![feature(unicode)]\n #![feature(unique)]\n-#![cfg_attr(stage0, feature(unsafe_no_drop_flag))]\n #![cfg_attr(test, feature(rand, test))]\n \n #![no_std]"}, {"sha": "3115be00a4d720094fe846219a7d8d91470d924f", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -68,7 +68,9 @@ macro_rules! vec {\n }\n \n /// Use the syntax described in `std::fmt` to create a value of type `String`.\n-/// See `std::fmt` for more information.\n+/// See [`std::fmt`][fmt] for more information.\n+///\n+/// [fmt]: ../std/fmt/index.html\n ///\n /// # Examples\n ///"}, {"sha": "e868a542d55fde2c8c05c8c6bb3d5b5601c1d56f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -268,7 +268,6 @@ use super::range::RangeArgument;\n /// Vec does not currently guarantee the order in which elements are dropped\n /// (the order has changed in the past, and may change again).\n ///\n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     buf: RawVec<T>,"}, {"sha": "4a703b3da68f64c1b34e48f16075ac4ef2a213dd", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![cfg_attr(not(stage0), feature(compiler_builtins))]\n+#![feature(compiler_builtins)]\n #![no_std]\n-#![cfg_attr(not(stage0), compiler_builtins)]\n+#![compiler_builtins]\n #![unstable(feature = \"compiler_builtins_lib\",\n             reason = \"internal implementation detail of rustc right now\",\n             issue = \"0\")]"}, {"sha": "d72b18ae345ce144018d56722403516f99727bdd", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -129,13 +129,6 @@ pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData\n            reason = \"deriving hack, should not be public\",\n            issue = \"0\")]\n pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n-#[cfg(stage0)]\n-#[doc(hidden)]\n-#[inline(always)]\n-#[unstable(feature = \"derive_clone_copy\",\n-           reason = \"deriving hack, should not be public\",\n-           issue = \"0\")]\n-pub fn assert_receiver_is_clone<T: Clone + ?Sized>(_: &T) {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Clone for &'a T {"}, {"sha": "e844a158484af488b2adea942de2127bc12644cc", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -194,14 +194,12 @@ extern \"rust-intrinsic\" {\n     /// own, or if it does not enable any significant optimizations.\n     pub fn assume(b: bool);\n \n-    #[cfg(not(stage0))]\n     /// Hints to the compiler that branch condition is likely to be true.\n     /// Returns the value passed to it.\n     ///\n     /// Any use other than with `if` statements will probably not have an effect.\n     pub fn likely(b: bool) -> bool;\n \n-    #[cfg(not(stage0))]\n     /// Hints to the compiler that branch condition is likely to be false.\n     /// Returns the value passed to it.\n     ///"}, {"sha": "4e83cc328f8269c323f2ac864970c67e730415b8", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -32,7 +32,6 @@ use ty::{self, Ty, TyCtxt};\n use mir::repr::Mir;\n use mir::mir_map::MirMap;\n use session::Session;\n-use session::config::PanicStrategy;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n@@ -46,6 +45,7 @@ use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;\n use hir::intravisit::Visitor;\n+use rustc_back::PanicStrategy;\n \n pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n "}, {"sha": "159b7256c7a27a92f369419f1df37f71dcc04c7d", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -64,9 +64,10 @@\n use hir::def_id::CrateNum;\n \n use session;\n-use session::config::{self, PanicStrategy};\n+use session::config;\n use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n use util::nodemap::FnvHashMap;\n+use rustc_back::PanicStrategy;\n \n /// A list of dependencies for a certain crate type.\n ///\n@@ -357,7 +358,7 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n     // only one, but we perform validation here that all the panic strategy\n     // compilation modes for the whole DAG are valid.\n     if let Some((cnum, found_strategy)) = panic_runtime {\n-        let desired_strategy = sess.opts.cg.panic.clone();\n+        let desired_strategy = sess.panic_strategy();\n \n         // First up, validate that our selected panic runtime is indeed exactly\n         // our same strategy."}, {"sha": "aa75c7a572bc5ba322f9d3d6219cfc438879f0d8", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -10,10 +10,11 @@\n \n //! Validity checking for weak lang items\n \n-use session::config::{self, PanicStrategy};\n+use session::config;\n use session::Session;\n use middle::lang_items;\n \n+use rustc_back::PanicStrategy;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n@@ -92,7 +93,7 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n     // symbols. Other panic runtimes ensure that the relevant symbols are\n     // available to link things together, but they're never exercised.\n     let mut whitelisted = HashSet::new();\n-    if sess.opts.cg.panic != PanicStrategy::Unwind {\n+    if sess.panic_strategy() != PanicStrategy::Unwind {\n         whitelisted.insert(lang_items::EhPersonalityLangItem);\n         whitelisted.insert(lang_items::EhUnwindResumeLangItem);\n     }"}, {"sha": "f8b06bf2e97626c6951323634c8037fe5e1af692", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -19,6 +19,7 @@ pub use self::DebugInfoLevel::*;\n use session::{early_error, early_warn, Session};\n use session::search_paths::SearchPaths;\n \n+use rustc_back::PanicStrategy;\n use rustc_back::target::Target;\n use lint;\n use middle::cstore;\n@@ -492,21 +493,6 @@ impl Passes {\n     }\n }\n \n-#[derive(Clone, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n-pub enum PanicStrategy {\n-    Unwind,\n-    Abort,\n-}\n-\n-impl PanicStrategy {\n-    pub fn desc(&self) -> &str {\n-        match *self {\n-            PanicStrategy::Unwind => \"unwind\",\n-            PanicStrategy::Abort => \"abort\",\n-        }\n-    }\n-}\n-\n /// Declare a macro that will define all CodegenOptions/DebuggingOptions fields and parsers all\n /// at once. The goal of this macro is to define an interface that can be\n /// programmatically used by the option parser in order to initialize the struct\n@@ -620,7 +606,8 @@ macro_rules! options {\n \n     #[allow(dead_code)]\n     mod $mod_set {\n-        use super::{$struct_name, Passes, SomePasses, AllPasses, PanicStrategy};\n+        use super::{$struct_name, Passes, SomePasses, AllPasses};\n+        use rustc_back::PanicStrategy;\n \n         $(\n             pub fn $opt(cg: &mut $struct_name, v: Option<&str>) -> bool {\n@@ -732,10 +719,10 @@ macro_rules! options {\n             }\n         }\n \n-        fn parse_panic_strategy(slot: &mut PanicStrategy, v: Option<&str>) -> bool {\n+        fn parse_panic_strategy(slot: &mut Option<PanicStrategy>, v: Option<&str>) -> bool {\n             match v {\n-                Some(\"unwind\") => *slot = PanicStrategy::Unwind,\n-                Some(\"abort\") => *slot = PanicStrategy::Abort,\n+                Some(\"unwind\") => *slot = Some(PanicStrategy::Unwind),\n+                Some(\"abort\") => *slot = Some(PanicStrategy::Abort),\n                 _ => return false\n             }\n             true\n@@ -809,7 +796,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"explicitly enable the cfg(debug_assertions) directive\"),\n     inline_threshold: Option<usize> = (None, parse_opt_uint, [TRACKED],\n         \"set the inlining threshold for\"),\n-    panic: PanicStrategy = (PanicStrategy::Unwind, parse_panic_strategy,\n+    panic: Option<PanicStrategy> = (None, parse_panic_strategy,\n         [TRACKED], \"panic strategy to compile crate with\"),\n }\n \n@@ -1665,9 +1652,10 @@ mod dep_tracking {\n     use std::collections::BTreeMap;\n     use std::hash::{Hash, SipHasher};\n     use std::path::PathBuf;\n-    use super::{Passes, PanicStrategy, CrateType, OptLevel, DebugInfoLevel,\n+    use super::{Passes, CrateType, OptLevel, DebugInfoLevel,\n                 OutputTypes, Externs, ErrorOutputType};\n     use syntax::feature_gate::UnstableFeatures;\n+    use rustc_back::PanicStrategy;\n \n     pub trait DepTrackingHash {\n         fn hash(&self, &mut SipHasher, ErrorOutputType);\n@@ -1706,6 +1694,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(Option<bool>);\n     impl_dep_tracking_hash_via_hash!(Option<usize>);\n     impl_dep_tracking_hash_via_hash!(Option<String>);\n+    impl_dep_tracking_hash_via_hash!(Option<PanicStrategy>);\n     impl_dep_tracking_hash_via_hash!(Option<lint::Level>);\n     impl_dep_tracking_hash_via_hash!(Option<PathBuf>);\n     impl_dep_tracking_hash_via_hash!(CrateType);\n@@ -1772,7 +1761,8 @@ mod tests {\n     use std::iter::FromIterator;\n     use std::path::PathBuf;\n     use std::rc::Rc;\n-    use super::{OutputType, OutputTypes, Externs, PanicStrategy};\n+    use super::{OutputType, OutputTypes, Externs};\n+    use rustc_back::PanicStrategy;\n     use syntax::{ast, attr};\n     use syntax::parse::token::InternedString;\n     use syntax::codemap::dummy_spanned;\n@@ -2318,7 +2308,7 @@ mod tests {\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n         opts = reference.clone();\n-        opts.cg.panic = PanicStrategy::Abort;\n+        opts.cg.panic = Some(PanicStrategy::Abort);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n     }\n "}, {"sha": "f706bab32c80a0a74d6583a463de7c8b3415537c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -15,7 +15,7 @@ use lint;\n use middle::cstore::CrateStore;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n-use session::config::{DebugInfoLevel, PanicStrategy};\n+use session::config::DebugInfoLevel;\n use ty::tls;\n use util::nodemap::{NodeMap, FnvHashMap};\n use util::common::duration_to_secs_str;\n@@ -33,6 +33,7 @@ use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n use syntax_pos::{Span, MultiSpan};\n \n+use rustc_back::PanicStrategy;\n use rustc_back::target::Target;\n use rustc_data_structures::flock;\n use llvm;\n@@ -42,6 +43,7 @@ use std::cell::{self, Cell, RefCell};\n use std::collections::HashMap;\n use std::env;\n use std::ffi::CString;\n+use std::io::Write;\n use std::rc::Rc;\n use std::fmt;\n use std::time::Duration;\n@@ -306,9 +308,13 @@ impl Session {\n     pub fn lto(&self) -> bool {\n         self.opts.cg.lto\n     }\n+    /// Returns the panic strategy for this compile session. If the user explicitly selected one\n+    /// using '-C panic', use that, otherwise use the panic strategy defined by the target.\n+    pub fn panic_strategy(&self) -> PanicStrategy {\n+        self.opts.cg.panic.unwrap_or(self.target.target.options.panic_strategy)\n+    }\n     pub fn no_landing_pads(&self) -> bool {\n-        self.opts.debugging_opts.no_landing_pads ||\n-            self.opts.cg.panic == PanicStrategy::Abort\n+        self.opts.debugging_opts.no_landing_pads || self.panic_strategy() == PanicStrategy::Abort\n     }\n     pub fn unstable_options(&self) -> bool {\n         self.opts.debugging_opts.unstable_options\n@@ -449,15 +455,17 @@ pub fn build_session(sopts: config::Options,\n                                local_crate_source_file,\n                                registry,\n                                cstore,\n-                               Rc::new(codemap::CodeMap::new()))\n+                               Rc::new(codemap::CodeMap::new()),\n+                               None)\n }\n \n pub fn build_session_with_codemap(sopts: config::Options,\n                                   dep_graph: &DepGraph,\n                                   local_crate_source_file: Option<PathBuf>,\n                                   registry: errors::registry::Registry,\n                                   cstore: Rc<for<'a> CrateStore<'a>>,\n-                                  codemap: Rc<codemap::CodeMap>)\n+                                  codemap: Rc<codemap::CodeMap>,\n+                                  emitter_dest: Option<Box<Write + Send>>)\n                                   -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n     // normal diagnostic warnings, since the warning lint can also be denied and changed\n@@ -470,14 +478,21 @@ pub fn build_session_with_codemap(sopts: config::Options,\n         .unwrap_or(true);\n     let treat_err_as_bug = sopts.debugging_opts.treat_err_as_bug;\n \n-    let emitter: Box<Emitter> = match sopts.error_format {\n-        config::ErrorOutputType::HumanReadable(color_config) => {\n+    let emitter: Box<Emitter> = match (sopts.error_format, emitter_dest) {\n+        (config::ErrorOutputType::HumanReadable(color_config), None) => {\n             Box::new(EmitterWriter::stderr(color_config,\n                                            Some(codemap.clone())))\n         }\n-        config::ErrorOutputType::Json => {\n+        (config::ErrorOutputType::HumanReadable(_), Some(dst)) => {\n+            Box::new(EmitterWriter::new(dst,\n+                                        Some(codemap.clone())))\n+        }\n+        (config::ErrorOutputType::Json, None) => {\n             Box::new(JsonEmitter::stderr(Some(registry), codemap.clone()))\n         }\n+        (config::ErrorOutputType::Json, Some(dst)) => {\n+            Box::new(JsonEmitter::new(dst, Some(registry), codemap.clone()))\n+        }\n     };\n \n     let diagnostic_handler ="}, {"sha": "b1f80455dd98b979d8a6ad46c2cf5166eb6a9f01", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -17,7 +17,7 @@ use hir::TraitMap;\n use hir::def::DefMap;\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as ast_map;\n-use hir::map::{DefKey, DefPath, DefPathData, DisambiguatedDefPathData};\n+use hir::map::{DefKey, DefPathData, DisambiguatedDefPathData};\n use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n@@ -546,8 +546,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn retrace_path(self, path: &DefPath) -> Option<DefId> {\n-        debug!(\"retrace_path(path={:?}, krate={:?})\", path, self.crate_name(path.krate));\n+    pub fn retrace_path(self,\n+                        krate: CrateNum,\n+                        path_data: &[DisambiguatedDefPathData])\n+                        -> Option<DefId> {\n+        debug!(\"retrace_path(path={:?}, krate={:?})\", path_data, self.crate_name(krate));\n \n         let root_key = DefKey {\n             parent: None,\n@@ -557,22 +560,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             },\n         };\n \n-        let root_index = self.def_index_for_def_key(path.krate, root_key)\n+        let root_index = self.def_index_for_def_key(krate, root_key)\n                              .expect(\"no root key?\");\n \n         debug!(\"retrace_path: root_index={:?}\", root_index);\n \n         let mut index = root_index;\n-        for data in &path.data {\n+        for data in path_data {\n             let key = DefKey { parent: Some(index), disambiguated_data: data.clone() };\n             debug!(\"retrace_path: key={:?}\", key);\n-            match self.def_index_for_def_key(path.krate, key) {\n+            match self.def_index_for_def_key(krate, key) {\n                 Some(i) => index = i,\n                 None => return None,\n             }\n         }\n \n-        Some(DefId { krate: path.krate, index: index })\n+        Some(DefId { krate: krate, index: index })\n     }\n \n     pub fn type_parameter_def(self,"}, {"sha": "c0f358ca8017bd884c3bfa53a892ee58a2e67a95", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -45,8 +45,36 @@ extern crate libc;\n extern crate serialize;\n #[macro_use] extern crate log;\n \n+extern crate serialize as rustc_serialize; // used by deriving\n+\n pub mod tempdir;\n pub mod sha2;\n pub mod target;\n pub mod slice;\n pub mod dynamic_lib;\n+\n+use serialize::json::{Json, ToJson};\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum PanicStrategy {\n+    Unwind,\n+    Abort,\n+}\n+\n+impl PanicStrategy {\n+    pub fn desc(&self) -> &str {\n+        match *self {\n+            PanicStrategy::Unwind => \"unwind\",\n+            PanicStrategy::Abort => \"abort\",\n+        }\n+    }\n+}\n+\n+impl ToJson for PanicStrategy {\n+    fn to_json(&self) -> Json {\n+        match *self {\n+            PanicStrategy::Abort => \"abort\".to_json(),\n+            PanicStrategy::Unwind => \"unwind\".to_json(),\n+        }\n+    }\n+}"}, {"sha": "3eddd911749e5251b13818b7fb64c58f5af85e3c", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -50,6 +50,8 @@ use std::default::Default;\n use std::io::prelude::*;\n use syntax::abi::Abi;\n \n+use PanicStrategy;\n+\n mod android_base;\n mod apple_base;\n mod apple_ios_base;\n@@ -347,6 +349,9 @@ pub struct TargetOptions {\n     /// Maximum integer size in bits that this target can perform atomic\n     /// operations on.\n     pub max_atomic_width: u64,\n+\n+    /// Panic strategy: \"unwind\" or \"abort\"\n+    pub panic_strategy: PanicStrategy,\n }\n \n impl Default for TargetOptions {\n@@ -396,6 +401,7 @@ impl Default for TargetOptions {\n             has_elf_tls: false,\n             obj_is_bitcode: false,\n             max_atomic_width: 0,\n+            panic_strategy: PanicStrategy::Unwind,\n         }\n     }\n }\n@@ -474,6 +480,19 @@ impl Target {\n                     .map(|o| o.as_u64()\n                          .map(|s| base.options.$key_name = s));\n             } );\n+            ($key_name:ident, PanicStrategy) => ( {\n+                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n+                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                    match s {\n+                        \"unwind\" => base.options.$key_name = PanicStrategy::Unwind,\n+                        \"abort\" => base.options.$key_name = PanicStrategy::Abort,\n+                        _ => return Some(Err(format!(\"'{}' is not a valid value for \\\n+                                                      panic-strategy. Use 'unwind' or 'abort'.\",\n+                                                     s))),\n+                }\n+                Some(Ok(()))\n+            })).unwrap_or(Ok(()))\n+            } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n                 obj.find(&name[..]).map(|o| o.as_array()\n@@ -534,6 +553,7 @@ impl Target {\n         key!(has_elf_tls, bool);\n         key!(obj_is_bitcode, bool);\n         key!(max_atomic_width, u64);\n+        try!(key!(panic_strategy, PanicStrategy));\n \n         Ok(base)\n     }\n@@ -676,6 +696,7 @@ impl ToJson for Target {\n         target_option_val!(has_elf_tls);\n         target_option_val!(obj_is_bitcode);\n         target_option_val!(max_atomic_width);\n+        target_option_val!(panic_strategy);\n \n         Json::Object(d)\n     }"}, {"sha": "5ac4512fe39004d72386822c36351e960b1d8800", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -74,6 +74,7 @@ use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::config::{Input, PrintRequest, OutputType, ErrorOutputType};\n use rustc::session::config::nightly_options;\n+use rustc::session::early_error;\n use rustc::lint::Lint;\n use rustc::lint;\n use rustc_metadata::loader;\n@@ -93,8 +94,6 @@ use std::str;\n use std::sync::{Arc, Mutex};\n use std::thread;\n \n-use rustc::session::early_error;\n-\n use syntax::{ast, json};\n use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n@@ -131,17 +130,18 @@ pub fn abort_on_err<T>(result: Result<T, usize>, sess: &Session) -> T {\n     }\n }\n \n-pub fn run(args: Vec<String>) -> isize {\n+pub fn run<F>(run_compiler: F) -> isize\n+    where F: FnOnce() -> (CompileResult, Option<Session>) + Send + 'static\n+{\n     monitor(move || {\n-        let (result, session) = run_compiler(&args, &mut RustcDefaultCalls);\n+        let (result, session) = run_compiler();\n         if let Err(err_count) = result {\n             if err_count > 0 {\n                 match session {\n                     Some(sess) => sess.fatal(&abort_msg(err_count)),\n                     None => {\n                         let emitter =\n-                            errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n-                                                                   None);\n+                            errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto, None);\n                         let handler = errors::Handler::with_emitter(true, false, Box::new(emitter));\n                         handler.emit(&MultiSpan::new(),\n                                      &abort_msg(err_count),\n@@ -155,20 +155,15 @@ pub fn run(args: Vec<String>) -> isize {\n     0\n }\n \n-pub fn run_compiler<'a>(args: &[String],\n-                        callbacks: &mut CompilerCalls<'a>)\n-                        -> (CompileResult, Option<Session>) {\n-    run_compiler_with_file_loader(args, callbacks, box RealFileLoader)\n-}\n-\n // Parse args and run the compiler. This is the primary entry point for rustc.\n // See comments on CompilerCalls below for details about the callbacks argument.\n // The FileLoader provides a way to load files from sources other than the file system.\n-pub fn run_compiler_with_file_loader<'a, L>(args: &[String],\n-                                            callbacks: &mut CompilerCalls<'a>,\n-                                            loader: Box<L>)\n-                                            -> (CompileResult, Option<Session>)\n-    where L: FileLoader + 'static {\n+pub fn run_compiler<'a>(args: &[String],\n+                        callbacks: &mut CompilerCalls<'a>,\n+                        file_loader: Option<Box<FileLoader + 'static>>,\n+                        emitter_dest: Option<Box<Write + Send>>)\n+                        -> (CompileResult, Option<Session>)\n+{\n     macro_rules! do_or_return {($expr: expr, $sess: expr) => {\n         match $expr {\n             Compilation::Stop => return (Ok(()), $sess),\n@@ -207,13 +202,16 @@ pub fn run_compiler_with_file_loader<'a, L>(args: &[String],\n \n     let dep_graph = DepGraph::new(sopts.build_dep_graph());\n     let cstore = Rc::new(CStore::new(&dep_graph));\n+\n+    let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader));\n     let sess = session::build_session_with_codemap(sopts,\n                                                    &dep_graph,\n                                                    input_file_path,\n                                                    descriptions,\n                                                    cstore.clone(),\n-                                                   codemap);\n+                                                   codemap,\n+                                                   emitter_dest);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let mut cfg = config::build_configuration(&sess, cfg);\n     target_features::add_configuration(&mut cfg, &sess);\n@@ -1144,6 +1142,9 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n }\n \n pub fn main() {\n-    let result = run(env::args().collect());\n+    let result = run(|| run_compiler(&env::args().collect::<Vec<_>>(),\n+                                     &mut RustcDefaultCalls,\n+                                     None,\n+                                     None));\n     process::exit(result as i32);\n }"}, {"sha": "1d7ff45b3b8a04820b0255199abb580b6865a1ea", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -99,8 +99,10 @@ impl EmitterWriter {\n     pub fn new(dst: Box<Write + Send>,\n                code_map: Option<Rc<CodeMapper>>)\n                -> EmitterWriter {\n-        EmitterWriter { dst: Raw(dst),\n-                        cm: code_map}\n+        EmitterWriter {\n+            dst: Raw(dst),\n+            cm: code_map,\n+        }\n     }\n \n     fn preprocess_annotations(&self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {"}, {"sha": "d238121872be67131f8a2a206e4c20cbd456e68e", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -20,6 +20,7 @@ use rustc::ty::TyCtxt;\n use rustc::util::nodemap::DefIdMap;\n use std::fmt::{self, Debug};\n use std::iter::once;\n+use std::collections::HashMap;\n \n /// Index into the DefIdDirectory\n #[derive(Copy, Clone, Debug, PartialOrd, Ord, Hash, PartialEq, Eq,\n@@ -90,18 +91,29 @@ impl DefIdDirectory {\n     }\n \n     pub fn retrace(&self, tcx: TyCtxt) -> RetracedDefIdDirectory {\n-        let max_current_crate = self.max_current_crate(tcx);\n+\n+        fn make_key(name: &str, disambiguator: &str) -> String {\n+            format!(\"{}/{}\", name, disambiguator)\n+        }\n+\n+        let new_krates: HashMap<_, _> =\n+            once(LOCAL_CRATE)\n+            .chain(tcx.sess.cstore.crates())\n+            .map(|krate| (make_key(&tcx.crate_name(krate),\n+                                   &tcx.crate_disambiguator(krate)), krate))\n+            .collect();\n \n         let ids = self.paths.iter()\n                             .map(|path| {\n-                                if self.krate_still_valid(tcx, max_current_crate, path.krate) {\n-                                    tcx.retrace_path(path)\n+                                let old_krate_id = path.krate.as_usize();\n+                                assert!(old_krate_id < self.krates.len());\n+                                let old_crate_info = &self.krates[old_krate_id];\n+                                let old_crate_key = make_key(&old_crate_info.name,\n+                                                         &old_crate_info.disambiguator);\n+                                if let Some(&new_crate_key) = new_krates.get(&old_crate_key) {\n+                                    tcx.retrace_path(new_crate_key, &path.data)\n                                 } else {\n-                                    debug!(\"crate {} changed from {:?} to {:?}/{:?}\",\n-                                           path.krate,\n-                                           self.krates[path.krate.as_usize()],\n-                                           tcx.crate_name(path.krate),\n-                                           tcx.crate_disambiguator(path.krate));\n+                                    debug!(\"crate {:?} no longer exists\", old_crate_key);\n                                     None\n                                 }\n                             })"}, {"sha": "0c7f6204438a78803b21456fa7f94fb60153069b", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::LoadedMacro;\n use rustc::session::{config, Session};\n-use rustc::session::config::PanicStrategy;\n+use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n@@ -710,7 +710,7 @@ impl<'a> CrateReader<'a> {\n         // The logic for finding the panic runtime here is pretty much the same\n         // as the allocator case with the only addition that the panic strategy\n         // compilation mode also comes into play.\n-        let desired_strategy = self.sess.opts.cg.panic.clone();\n+        let desired_strategy = self.sess.panic_strategy();\n         let mut runtime_found = false;\n         let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n                                                           \"needs_panic_runtime\");"}, {"sha": "16a5b5402fbe30fc431939cf614f5774dcf32bc1", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -26,7 +26,7 @@ use rustc::hir::map::DefKey;\n use rustc::mir::repr::Mir;\n use rustc::mir::mir_map::MirMap;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n-use rustc::session::config::PanicStrategy;\n+use rustc_back::PanicStrategy;\n \n use std::path::PathBuf;\n use syntax::ast;"}, {"sha": "038d0f73d5ce8fd579b6b001e48d8387d00ef14e", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex, DefId};\n use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::ExternCrate;\n-use rustc::session::config::PanicStrategy;\n+use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap, FnvHashSet};\n "}, {"sha": "ca4fb77d95ad62dd8941a2641096df7747185e2d", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -1293,7 +1293,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             triple: tcx.sess.opts.target_triple.clone(),\n             hash: link_meta.crate_hash,\n             disambiguator: tcx.sess.local_crate_disambiguator().to_string(),\n-            panic_strategy: tcx.sess.opts.cg.panic.clone(),\n+            panic_strategy: tcx.sess.panic_strategy(),\n             plugin_registrar_fn: tcx.sess.plugin_registrar_fn.get().map(|id| {\n                 tcx.map.local_def_id(id).index\n             }),"}, {"sha": "58e18bc709e3c41a5dd2cfdb1be6d7227fcbc202", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -18,7 +18,7 @@ use rustc::middle::cstore::{LinkagePreference, NativeLibraryKind};\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc::session::config::PanicStrategy;\n+use rustc_back::PanicStrategy;\n \n use rustc_serialize as serialize;\n use syntax::{ast, attr};"}, {"sha": "1fc9c45de930647b9021aa88e75f6e6749819451", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -683,9 +683,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         match (value_result, type_result) {\n-            // With `#![feature(item_like_imports)]`, all namespaces\n-            // must be re-exported with extra visibility for an error to occur.\n-            (Ok(value_binding), Ok(type_binding)) if self.new_import_semantics => {\n+            // All namespaces must be re-exported with extra visibility for an error to occur.\n+            (Ok(value_binding), Ok(type_binding)) => {\n                 let vis = directive.vis.get();\n                 if !value_binding.pseudo_vis().is_at_least(vis, self) &&\n                    !type_binding.pseudo_vis().is_at_least(vis, self) {"}, {"sha": "b82c5629f9da1dcea0d5510caac0f30ce60aa64f", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef};\n+use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector};\n use base;\n use build::AllocaFcx;\n use common::{type_is_fat_ptr, BlockAndBuilder, C_uint};\n@@ -598,3 +598,73 @@ impl FnType {\n         }\n     }\n }\n+\n+pub fn align_up_to(off: usize, a: usize) -> usize {\n+    return (off + a - 1) / a * a;\n+}\n+\n+fn align(off: usize, ty: Type, pointer: usize) -> usize {\n+    let a = ty_align(ty, pointer);\n+    return align_up_to(off, a);\n+}\n+\n+pub fn ty_align(ty: Type, pointer: usize) -> usize {\n+    match ty.kind() {\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n+        Pointer => pointer,\n+        Float => 4,\n+        Double => 8,\n+        Struct => {\n+            if ty.is_packed() {\n+                1\n+            } else {\n+                let str_tys = ty.field_types();\n+                str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t, pointer)))\n+            }\n+        }\n+        Array => {\n+            let elt = ty.element_type();\n+            ty_align(elt, pointer)\n+        }\n+        Vector => {\n+            let len = ty.vector_length();\n+            let elt = ty.element_type();\n+            ty_align(elt, pointer) * len\n+        }\n+        _ => bug!(\"ty_align: unhandled type\")\n+    }\n+}\n+\n+pub fn ty_size(ty: Type, pointer: usize) -> usize {\n+    match ty.kind() {\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n+        Pointer => pointer,\n+        Float => 4,\n+        Double => 8,\n+        Struct => {\n+            if ty.is_packed() {\n+                let str_tys = ty.field_types();\n+                str_tys.iter().fold(0, |s, t| s + ty_size(*t, pointer))\n+            } else {\n+                let str_tys = ty.field_types();\n+                let size = str_tys.iter().fold(0, |s, t| {\n+                    align(s, *t, pointer) + ty_size(*t, pointer)\n+                });\n+                align(size, ty, pointer)\n+            }\n+        }\n+        Array => {\n+            let len = ty.array_length();\n+            let elt = ty.element_type();\n+            let eltsz = ty_size(elt, pointer);\n+            len * eltsz\n+        }\n+        Vector => {\n+            let len = ty.vector_length();\n+            let elt = ty.element_type();\n+            let eltsz = ty_size(elt, pointer);\n+            len * eltsz\n+        },\n+        _ => bug!(\"ty_size: unhandled type\")\n+    }\n+}"}, {"sha": "59a84439950bad2876ab8a18dd216bdafcc02b82", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 2, "deletions": 68, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -11,78 +11,12 @@\n #![allow(non_upper_case_globals)]\n \n use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use abi::{FnType, ArgType};\n+use abi::{self, FnType, ArgType};\n use context::CrateContext;\n use type_::Type;\n \n-use std::cmp;\n-\n-fn align_up_to(off: usize, a: usize) -> usize {\n-    return (off + a - 1) / a * a;\n-}\n-\n-fn align(off: usize, ty: Type) -> usize {\n-    let a = ty_align(ty);\n-    return align_up_to(off, a);\n-}\n-\n-fn ty_align(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 8,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                1\n-            } else {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t)))\n-            }\n-        }\n-        Array => {\n-            let elt = ty.element_type();\n-            ty_align(elt)\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            ty_align(elt) * len\n-        }\n-        _ => bug!(\"ty_align: unhandled type\")\n-    }\n-}\n-\n fn ty_size(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 8,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-            } else {\n-                let str_tys = ty.field_types();\n-                let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                align(size, ty)\n-            }\n-        }\n-        Array => {\n-            let len = ty.array_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n-            len * eltsz\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n-            len * eltsz\n-        }\n-        _ => bug!(\"ty_size: unhandled type\")\n-    }\n+    abi::ty_size(ty, 8)\n }\n \n fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {"}, {"sha": "93d43f7d96116c5095fddd65f18e11d6ba92047d", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use abi::{FnType, ArgType};\n+use abi::{self, align_up_to, FnType, ArgType};\n use context::CrateContext;\n use type_::Type;\n \n@@ -24,40 +24,13 @@ pub enum Flavor {\n \n type TyAlignFn = fn(ty: Type) -> usize;\n \n-fn align_up_to(off: usize, a: usize) -> usize {\n-    return (off + a - 1) / a * a;\n-}\n-\n fn align(off: usize, ty: Type, align_fn: TyAlignFn) -> usize {\n     let a = align_fn(ty);\n     return align_up_to(off, a);\n }\n \n fn general_ty_align(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 4,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                1\n-            } else {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| cmp::max(a, general_ty_align(*t)))\n-            }\n-        }\n-        Array => {\n-            let elt = ty.element_type();\n-            general_ty_align(elt)\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            general_ty_align(elt) * len\n-        }\n-        _ => bug!(\"ty_align: unhandled type\")\n-    }\n+    abi::ty_align(ty, 4)\n }\n \n // For more information see:"}, {"sha": "25fe53e7ef40f88ab96ba44d3ed6198a9af6fd24", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 4, "deletions": 64, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -13,77 +13,17 @@\n use libc::c_uint;\n use std::cmp;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use abi::{ArgType, FnType};\n+use llvm::{Integer, Pointer, Float, Double, Vector};\n+use abi::{self, align_up_to, ArgType, FnType};\n use context::CrateContext;\n use type_::Type;\n \n-fn align_up_to(off: usize, a: usize) -> usize {\n-    return (off + a - 1) / a * a;\n-}\n-\n-fn align(off: usize, ty: Type) -> usize {\n-    let a = ty_align(ty);\n-    return align_up_to(off, a);\n-}\n-\n fn ty_align(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 4,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-          if ty.is_packed() {\n-            1\n-          } else {\n-            let str_tys = ty.field_types();\n-            str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t)))\n-          }\n-        }\n-        Array => {\n-            let elt = ty.element_type();\n-            ty_align(elt)\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            ty_align(elt) * len\n-        }\n-        _ => bug!(\"ty_align: unhandled type\")\n-    }\n+    abi::ty_align(ty, 4)\n }\n \n fn ty_size(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 4,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-            } else {\n-                let str_tys = ty.field_types();\n-                let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                align(size, ty)\n-            }\n-        }\n-        Array => {\n-            let len = ty.array_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n-            len * eltsz\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n-            len * eltsz\n-        }\n-        _ => bug!(\"ty_size: unhandled type\")\n-    }\n+    abi::ty_size(ty, 4)\n }\n \n fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {"}, {"sha": "e6b500c88dc7ac1be0916491e5afb0be7ecba08f", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 4, "deletions": 64, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -13,77 +13,17 @@\n use libc::c_uint;\n use std::cmp;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use abi::{ArgType, FnType};\n+use llvm::{Integer, Pointer, Float, Double, Vector};\n+use abi::{self, align_up_to, ArgType, FnType};\n use context::CrateContext;\n use type_::Type;\n \n-fn align_up_to(off: usize, a: usize) -> usize {\n-    return (off + a - 1) / a * a;\n-}\n-\n-fn align(off: usize, ty: Type) -> usize {\n-    let a = ty_align(ty);\n-    return align_up_to(off, a);\n-}\n-\n fn ty_align(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 8,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-          if ty.is_packed() {\n-            1\n-          } else {\n-            let str_tys = ty.field_types();\n-            str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t)))\n-          }\n-        }\n-        Array => {\n-            let elt = ty.element_type();\n-            ty_align(elt)\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            ty_align(elt) * len\n-        }\n-        _ => bug!(\"ty_align: unhandled type\")\n-    }\n+    abi::ty_align(ty, 8)\n }\n \n fn ty_size(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 8,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-            } else {\n-                let str_tys = ty.field_types();\n-                let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                align(size, ty)\n-            }\n-        }\n-        Array => {\n-            let len = ty.array_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n-            len * eltsz\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n-            len * eltsz\n-        }\n-        _ => bug!(\"ty_size: unhandled type\")\n-    }\n+    abi::ty_size(ty, 8)\n }\n \n fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {"}, {"sha": "4e1d7a93378270dfb006d8113c1417ecad0dbfc0", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 10, "deletions": 51, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -10,67 +10,26 @@\n \n use libc::c_uint;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n-use abi::{FnType, ArgType};\n+use llvm::{Integer, Pointer, Float, Double, Vector};\n+use abi::{self, align_up_to, FnType, ArgType};\n use context::CrateContext;\n use type_::Type;\n \n use std::cmp;\n \n-fn align_up_to(off: usize, a: usize) -> usize {\n-    return (off + a - 1) / a * a;\n-}\n-\n-fn align(off: usize, ty: Type) -> usize {\n-    let a = ty_align(ty);\n-    return align_up_to(off, a);\n-}\n-\n fn ty_align(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 4,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-          if ty.is_packed() {\n-            1\n-          } else {\n-            let str_tys = ty.field_types();\n-            str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t)))\n-          }\n-        }\n-        Array => {\n-            let elt = ty.element_type();\n-            ty_align(elt)\n-        }\n-        _ => bug!(\"ty_size: unhandled type\")\n+    if ty.kind() == Vector {\n+        bug!(\"ty_size: unhandled type\")\n+    } else {\n+        abi::ty_align(ty, 4)\n     }\n }\n \n fn ty_size(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 4,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-            } else {\n-                let str_tys = ty.field_types();\n-                let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                align(size, ty)\n-            }\n-        }\n-        Array => {\n-            let len = ty.array_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n-            len * eltsz\n-        }\n-        _ => bug!(\"ty_size: unhandled type\")\n+    if ty.kind() == Vector {\n+        bug!(\"ty_size: unhandled type\")\n+    } else {\n+        abi::ty_size(ty, 4)\n     }\n }\n "}, {"sha": "cdc7c1fd1afb379e937c3825853d832260e5fb9e", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 6, "deletions": 57, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -15,67 +15,16 @@\n // Alignment of 128 bit types is not currently handled, this will\n // need to be fixed when PowerPC vector support is added.\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n-use abi::{FnType, ArgType};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Vector, Array};\n+use abi::{self, FnType, ArgType};\n use context::CrateContext;\n use type_::Type;\n \n-use std::cmp;\n-\n-fn align_up_to(off: usize, a: usize) -> usize {\n-    return (off + a - 1) / a * a;\n-}\n-\n-fn align(off: usize, ty: Type) -> usize {\n-    let a = ty_align(ty);\n-    return align_up_to(off, a);\n-}\n-\n-fn ty_align(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 8,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                1\n-            } else {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t)))\n-            }\n-        }\n-        Array => {\n-            let elt = ty.element_type();\n-            ty_align(elt)\n-        }\n-        _ => bug!(\"ty_align: unhandled type\")\n-    }\n-}\n-\n fn ty_size(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 8,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-            } else {\n-                let str_tys = ty.field_types();\n-                let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                align(size, ty)\n-            }\n-        }\n-        Array => {\n-            let len = ty.array_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n-            len * eltsz\n-        }\n-        _ => bug!(\"ty_size: unhandled type\")\n+    if ty.kind() == Vector {\n+        bug!(\"ty_size: unhandled type\")\n+    } else {\n+        abi::ty_size(ty, 8)\n     }\n }\n "}, {"sha": "5a666c6083d16f4649cc9292ea8f878a35aa3e2a", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -12,16 +12,12 @@\n // for a pre-z13 machine or using -mno-vx.\n \n use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use abi::{FnType, ArgType};\n+use abi::{align_up_to, FnType, ArgType};\n use context::CrateContext;\n use type_::Type;\n \n use std::cmp;\n \n-fn align_up_to(off: usize, a: usize) -> usize {\n-    return (off + a - 1) / a * a;\n-}\n-\n fn align(off: usize, ty: Type) -> usize {\n     let a = ty_align(ty);\n     return align_up_to(off, a);"}, {"sha": "33990148c8b7de13d4dbc1e4a39de610d9cd58f3", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 56, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -16,12 +16,10 @@ use self::RegClass::*;\n \n use llvm::{Integer, Pointer, Float, Double};\n use llvm::{Struct, Array, Attribute, Vector};\n-use abi::{ArgType, FnType};\n+use abi::{self, ArgType, FnType};\n use context::CrateContext;\n use type_::Type;\n \n-use std::cmp;\n-\n #[derive(Clone, Copy, PartialEq)]\n enum RegClass {\n     NoClass,\n@@ -90,62 +88,11 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     }\n \n     fn ty_align(ty: Type) -> usize {\n-        match ty.kind() {\n-            Integer => ((ty.int_width() as usize) + 7) / 8,\n-            Pointer => 8,\n-            Float => 4,\n-            Double => 8,\n-            Struct => {\n-              if ty.is_packed() {\n-                1\n-              } else {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t)))\n-              }\n-            }\n-            Array => {\n-                let elt = ty.element_type();\n-                ty_align(elt)\n-            }\n-            Vector => {\n-                let len = ty.vector_length();\n-                let elt = ty.element_type();\n-                ty_align(elt) * len\n-            }\n-            _ => bug!(\"ty_align: unhandled type\")\n-        }\n+        abi::ty_align(ty, 8)\n     }\n \n     fn ty_size(ty: Type) -> usize {\n-        match ty.kind() {\n-            Integer => (ty.int_width() as usize + 7) / 8,\n-            Pointer => 8,\n-            Float => 4,\n-            Double => 8,\n-            Struct => {\n-                let str_tys = ty.field_types();\n-                if ty.is_packed() {\n-                    str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-                } else {\n-                    let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                    align(size, ty)\n-                }\n-            }\n-            Array => {\n-                let len = ty.array_length();\n-                let elt = ty.element_type();\n-                let eltsz = ty_size(elt);\n-                len * eltsz\n-            }\n-            Vector => {\n-                let len = ty.vector_length();\n-                let elt = ty.element_type();\n-                let eltsz = ty_size(elt);\n-                len * eltsz\n-            }\n-\n-            _ => bug!(\"ty_size: unhandled type\")\n-        }\n+        abi::ty_size(ty, 8)\n     }\n \n     fn all_mem(cls: &mut [RegClass]) {"}, {"sha": "ca22faa2ec36ab27f27c1c31cf01f2f3db772815", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 115, "deletions": 99, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -20,7 +20,7 @@ use middle::lang_items::UnsizeTraitLangItem;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::traits::{self, Reveal};\n-use rustc::ty::{ParameterEnvironment};\n+use rustc::ty::ParameterEnvironment;\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n use rustc::ty::{TyRef, TyAdt, TyTrait, TyNever, TyTuple};\n@@ -44,13 +44,13 @@ mod orphan;\n mod overlap;\n mod unsafety;\n \n-struct CoherenceChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct CoherenceChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     crate_context: &'a CrateCtxt<'a, 'gcx>,\n     inference_context: InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n-struct CoherenceCheckVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    cc: &'a CoherenceChecker<'a, 'gcx, 'tcx>\n+struct CoherenceCheckVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    cc: &'a CoherenceChecker<'a, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'gcx, 'tcx> {\n@@ -62,36 +62,25 @@ impl<'a, 'gcx, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, '\n }\n \n impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n-\n     // Returns the def ID of the base type, if there is one.\n     fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n         match ty.sty {\n-            TyAdt(def, _) => {\n-                Some(def.did)\n-            }\n+            TyAdt(def, _) => Some(def.did),\n \n-            TyTrait(ref t) => {\n-                Some(t.principal.def_id())\n-            }\n+            TyTrait(ref t) => Some(t.principal.def_id()),\n \n-            TyBox(_) => {\n-                self.inference_context.tcx.lang_items.owned_box()\n-            }\n+            TyBox(_) => self.inference_context.tcx.lang_items.owned_box(),\n \n-            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyStr | TyArray(..) | TySlice(..) | TyFnDef(..) | TyFnPtr(_) |\n-            TyTuple(..) | TyParam(..) | TyError | TyNever |\n-            TyRawPtr(_) | TyRef(..) | TyProjection(..) => {\n-                None\n-            }\n+            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) | TyStr | TyArray(..) |\n+            TySlice(..) | TyFnDef(..) | TyFnPtr(_) | TyTuple(..) | TyParam(..) | TyError |\n+            TyNever | TyRawPtr(_) | TyRef(..) | TyProjection(..) => None,\n \n             TyInfer(..) | TyClosure(..) | TyAnon(..) => {\n                 // `ty` comes from a user declaration so we should only expect types\n                 // that the user can type\n-                span_bug!(\n-                    span,\n-                    \"coherence encountered unexpected type searching for base type: {}\",\n-                    ty);\n+                span_bug!(span,\n+                          \"coherence encountered unexpected type searching for base type: {}\",\n+                          ty);\n             }\n         }\n     }\n@@ -100,9 +89,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        self.crate_context.tcx.visit_all_items_in_krate(\n-            DepNode::CoherenceCheckImpl,\n-            &mut CoherenceCheckVisitor { cc: self });\n+        self.crate_context.tcx.visit_all_items_in_krate(DepNode::CoherenceCheckImpl,\n+                                                        &mut CoherenceCheckVisitor { cc: self });\n \n         // Populate the table of destructors. It might seem a bit strange to\n         // do this here, but it's actually the most convenient place, since\n@@ -167,7 +155,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n     fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'gcx>, impl_def_id: DefId) {\n         debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n-               impl_trait_ref, impl_def_id);\n+               impl_trait_ref,\n+               impl_def_id);\n         let trait_def = self.crate_context.tcx.lookup_trait_def(impl_trait_ref.def_id);\n         trait_def.record_local_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n@@ -176,24 +165,24 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     fn create_impl_from_item(&self, item: &Item) -> Vec<DefId> {\n         match item.node {\n             ItemImpl(.., ref impl_items) => {\n-                impl_items.iter().map(|impl_item| {\n-                    self.crate_context.tcx.map.local_def_id(impl_item.id)\n-                }).collect()\n+                impl_items.iter()\n+                    .map(|impl_item| self.crate_context.tcx.map.local_def_id(impl_item.id))\n+                    .collect()\n             }\n             _ => {\n                 span_bug!(item.span, \"can't convert a non-impl to an impl\");\n             }\n         }\n     }\n \n-    //\n     // Destructors\n     //\n \n     fn populate_destructors(&self) {\n         let tcx = self.crate_context.tcx;\n         let drop_trait = match tcx.lang_items.drop_trait() {\n-            Some(id) => id, None => { return }\n+            Some(id) => id,\n+            None => return,\n         };\n         tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n         let drop_trait = tcx.lookup_trait_def(drop_trait);\n@@ -219,13 +208,14 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                         match tcx.map.find(impl_node_id) {\n                             Some(hir_map::NodeItem(item)) => {\n                                 let span = match item.node {\n-                                    ItemImpl(.., ref ty, _) => {\n-                                        ty.span\n-                                    },\n-                                    _ => item.span\n+                                    ItemImpl(.., ref ty, _) => ty.span,\n+                                    _ => item.span,\n                                 };\n-                                struct_span_err!(tcx.sess, span, E0120,\n-                                    \"the Drop trait may only be implemented on structures\")\n+                                struct_span_err!(tcx.sess,\n+                                                 span,\n+                                                 E0120,\n+                                                 \"the Drop trait may only be implemented on \\\n+                                                  structures\")\n                                     .span_label(span,\n                                                 &format!(\"implementing Drop requires a struct\"))\n                                     .emit();\n@@ -254,15 +244,14 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         let copy_trait = tcx.lookup_trait_def(copy_trait);\n \n         copy_trait.for_each_impl(tcx, |impl_did| {\n-            debug!(\"check_implementations_of_copy: impl_did={:?}\",\n-                   impl_did);\n+            debug!(\"check_implementations_of_copy: impl_did={:?}\", impl_did);\n \n             let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n                 n\n             } else {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n                         crate\");\n-                return\n+                return;\n             };\n \n             let self_type = tcx.lookup_item_type(impl_did);\n@@ -280,14 +269,12 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             match param_env.can_type_implement_copy(tcx, self_type, span) {\n                 Ok(()) => {}\n                 Err(CopyImplementationError::InfrigingField(name)) => {\n-                       struct_span_err!(tcx.sess, span, E0204,\n-                                 \"the trait `Copy` may not be implemented for \\\n-                                 this type\")\n-                           .span_label(span, &format!(\n-                                 \"field `{}` does not implement `Copy`\", name)\n-                               )\n-                           .emit()\n-\n+                    struct_span_err!(tcx.sess,\n+                                     span,\n+                                     E0204,\n+                                     \"the trait `Copy` may not be implemented for this type\")\n+                        .span_label(span, &format!(\"field `{}` does not implement `Copy`\", name))\n+                        .emit()\n                 }\n                 Err(CopyImplementationError::InfrigingVariant(name)) => {\n                     let item = tcx.map.expect_item(impl_node_id);\n@@ -297,10 +284,12 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                         span\n                     };\n \n-                    struct_span_err!(tcx.sess, span, E0205,\n+                    struct_span_err!(tcx.sess,\n+                                     span,\n+                                     E0205,\n                                      \"the trait `Copy` may not be implemented for this type\")\n-                        .span_label(span, &format!(\"variant `{}` does not implement `Copy`\",\n-                                                   name))\n+                        .span_label(span,\n+                                    &format!(\"variant `{}` does not implement `Copy`\", name))\n                         .emit()\n                 }\n                 Err(CopyImplementationError::NotAnAdt) => {\n@@ -311,15 +300,19 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                         span\n                     };\n \n-                    struct_span_err!(tcx.sess, span, E0206,\n+                    struct_span_err!(tcx.sess,\n+                                     span,\n+                                     E0206,\n                                      \"the trait `Copy` may not be implemented for this type\")\n                         .span_label(span, &format!(\"type is not a structure or enumeration\"))\n                         .emit();\n                 }\n                 Err(CopyImplementationError::HasDestructor) => {\n-                    struct_span_err!(tcx.sess, span, E0184,\n-                              \"the trait `Copy` may not be implemented for this type; \\\n-                               the type has a destructor\")\n+                    struct_span_err!(tcx.sess,\n+                                     span,\n+                                     E0184,\n+                                     \"the trait `Copy` may not be implemented for this type; the \\\n+                                      type has a destructor\")\n                         .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n                         .emit();\n                 }\n@@ -359,7 +352,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n             let target = trait_ref.substs.type_at(1);\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n-                   source, target);\n+                   source,\n+                   target);\n \n             let span = tcx.map.span(impl_node_id);\n             let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n@@ -368,15 +362,19 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             assert!(!source.has_escaping_regions());\n \n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n-                   source, target);\n+                   source,\n+                   target);\n \n             tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n                 let origin = TypeOrigin::Misc(span);\n-                let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>, mt_b: ty::TypeAndMut<'gcx>,\n+                let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>,\n+                                   mt_b: ty::TypeAndMut<'gcx>,\n                                    mk_ptr: &Fn(Ty<'gcx>) -> Ty<'gcx>| {\n                     if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n-                        infcx.report_mismatched_types(origin, mk_ptr(mt_b.ty),\n-                                                      target, ty::error::TypeError::Mutability);\n+                        infcx.report_mismatched_types(origin,\n+                                                      mk_ptr(mt_b.ty),\n+                                                      target,\n+                                                      ty::error::TypeError::Mutability);\n                     }\n                     (mt_a.ty, mt_b.ty, unsize_trait, None)\n                 };\n@@ -394,37 +392,45 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                     }\n \n                     (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b))\n-                            if def_a.is_struct() && def_b.is_struct() => {\n+                        if def_a.is_struct() && def_b.is_struct() => {\n                         if def_a != def_b {\n                             let source_path = tcx.item_path_str(def_a.did);\n                             let target_path = tcx.item_path_str(def_b.did);\n-                            span_err!(tcx.sess, span, E0377,\n+                            span_err!(tcx.sess,\n+                                      span,\n+                                      E0377,\n                                       \"the trait `CoerceUnsized` may only be implemented \\\n                                        for a coercion between structures with the same \\\n                                        definition; expected {}, found {}\",\n-                                      source_path, target_path);\n+                                      source_path,\n+                                      target_path);\n                             return;\n                         }\n \n                         let fields = &def_a.struct_variant().fields;\n-                        let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n-                            let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n-\n-                            if f.unsubst_ty().is_phantom_data() {\n-                                // Ignore PhantomData fields\n-                                None\n-                            } else if infcx.sub_types(false, origin, b, a).is_ok() {\n-                                // Ignore fields that aren't significantly changed\n-                                None\n-                            } else {\n-                                // Collect up all fields that were significantly changed\n-                                // i.e. those that contain T in coerce_unsized T -> U\n-                                Some((i, a, b))\n-                            }\n-                        }).collect::<Vec<_>>();\n+                        let diff_fields = fields.iter()\n+                            .enumerate()\n+                            .filter_map(|(i, f)| {\n+                                let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n+\n+                                if f.unsubst_ty().is_phantom_data() {\n+                                    // Ignore PhantomData fields\n+                                    None\n+                                } else if infcx.sub_types(false, origin, b, a).is_ok() {\n+                                    // Ignore fields that aren't significantly changed\n+                                    None\n+                                } else {\n+                                    // Collect up all fields that were significantly changed\n+                                    // i.e. those that contain T in coerce_unsized T -> U\n+                                    Some((i, a, b))\n+                                }\n+                            })\n+                            .collect::<Vec<_>>();\n \n                         if diff_fields.is_empty() {\n-                            span_err!(tcx.sess, span, E0374,\n+                            span_err!(tcx.sess,\n+                                      span,\n+                                      E0374,\n                                       \"the trait `CoerceUnsized` may only be implemented \\\n                                        for a coercion between structures with one field \\\n                                        being coerced, none found\");\n@@ -437,16 +443,22 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                                 tcx.map.span(impl_node_id)\n                             };\n \n-                            let mut err = struct_span_err!(tcx.sess, span, E0375,\n-                                      \"implementing the trait `CoerceUnsized` \\\n-                                       requires multiple coercions\");\n+                            let mut err = struct_span_err!(tcx.sess,\n+                                                           span,\n+                                                           E0375,\n+                                                           \"implementing the trait \\\n+                                                            `CoerceUnsized` requires multiple \\\n+                                                            coercions\");\n                             err.note(\"`CoerceUnsized` may only be implemented for \\\n                                       a coercion between structures with one field being coerced\");\n                             err.note(&format!(\"currently, {} fields need coercions: {}\",\n-                                             diff_fields.len(),\n-                                             diff_fields.iter().map(|&(i, a, b)| {\n-                                                format!(\"{} ({} to {})\", fields[i].name, a, b)\n-                                             }).collect::<Vec<_>>().join(\", \") ));\n+                                              diff_fields.len(),\n+                                              diff_fields.iter()\n+                                                  .map(|&(i, a, b)| {\n+                                                      format!(\"{} ({} to {})\", fields[i].name, a, b)\n+                                                  })\n+                                                  .collect::<Vec<_>>()\n+                                                  .join(\", \")));\n                             err.span_label(span, &format!(\"requires multiple coercions\"));\n                             err.emit();\n                             return;\n@@ -458,7 +470,9 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                     }\n \n                     _ => {\n-                        span_err!(tcx.sess, span, E0376,\n+                        span_err!(tcx.sess,\n+                                  span,\n+                                  E0376,\n                                   \"the trait `CoerceUnsized` may only be implemented \\\n                                    for a coercion between structures\");\n                         return;\n@@ -469,8 +483,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n                 // Register an obligation for `A: Trait<B>`.\n                 let cause = traits::ObligationCause::misc(span, impl_node_id);\n-                let predicate = tcx.predicate_for_trait_def(cause, trait_def_id, 0,\n-                                                            source, &[target]);\n+                let predicate =\n+                    tcx.predicate_for_trait_def(cause, trait_def_id, 0, source, &[target]);\n                 fulfill_cx.register_predicate_obligation(&infcx, predicate);\n \n                 // Check that all transitive obligations are satisfied.\n@@ -480,8 +494,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n                 // Finally, resolve all regions.\n                 let mut free_regions = FreeRegionMap::new();\n-                free_regions.relate_free_regions_from_predicates(\n-                    &infcx.parameter_environment.caller_bounds);\n+                free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n+                    .caller_bounds);\n                 infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n \n                 if let Some(kind) = kind {\n@@ -495,7 +509,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: DefId) {\n     if tcx.sess.features.borrow().unboxed_closures {\n         // the feature gate allows all of them\n-        return\n+        return;\n     }\n     let did = Some(trait_def_id);\n     let li = &tcx.lang_items;\n@@ -507,24 +521,26 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n     } else if did == li.fn_once_trait() {\n         \"FnOnce\"\n     } else {\n-        return // everything OK\n+        return; // everything OK\n     };\n     let mut err = struct_span_err!(tcx.sess,\n                                    sp,\n                                    E0183,\n                                    \"manual implementations of `{}` are experimental\",\n                                    trait_name);\n-    help!(&mut err, \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n+    help!(&mut err,\n+          \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n     err.emit();\n }\n \n pub fn check_coherence(ccx: &CrateCtxt) {\n     let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n     ccx.tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n         CoherenceChecker {\n-            crate_context: ccx,\n-            inference_context: infcx,\n-        }.check();\n+                crate_context: ccx,\n+                inference_context: infcx,\n+            }\n+            .check();\n     });\n     unsafety::check(ccx.tcx);\n     orphan::check(ccx.tcx);"}, {"sha": "bff794364c098dadc745f646022e5d77df181ebc", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 62, "deletions": 47, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -25,17 +25,20 @@ pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_items_in_krate(DepNode::CoherenceOrphanCheck, &mut orphan);\n }\n \n-struct OrphanChecker<'cx, 'tcx:'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>\n+struct OrphanChecker<'cx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n }\n \n impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n     fn check_def_id(&self, item: &hir::Item, def_id: DefId) {\n         if def_id.krate != LOCAL_CRATE {\n-            struct_span_err!(self.tcx.sess, item.span, E0116,\n-                      \"cannot define inherent `impl` for a type outside of the \\\n-                       crate where the type is defined\")\n-                .span_label(item.span, &format!(\"impl for type defined outside of crate.\"))\n+            struct_span_err!(self.tcx.sess,\n+                             item.span,\n+                             E0116,\n+                             \"cannot define inherent `impl` for a type outside of the crate \\\n+                              where the type is defined\")\n+                .span_label(item.span,\n+                            &format!(\"impl for type defined outside of crate.\"))\n                 .note(\"define and implement a trait or new type instead\")\n                 .emit();\n         }\n@@ -48,11 +51,17 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                             ty: &str,\n                             span: Span) {\n         match lang_def_id {\n-            Some(lang_def_id) if lang_def_id == impl_def_id => { /* OK */ },\n+            Some(lang_def_id) if lang_def_id == impl_def_id => {\n+                // OK\n+            }\n             _ => {\n-                struct_span_err!(self.tcx.sess, span, E0390,\n-                          \"only a single inherent implementation marked with `#[lang = \\\"{}\\\"]` \\\n-                           is allowed for the `{}` primitive\", lang, ty)\n+                struct_span_err!(self.tcx.sess,\n+                                 span,\n+                                 E0390,\n+                                 \"only a single inherent implementation marked with `#[lang = \\\n+                                  \\\"{}\\\"]` is allowed for the `{}` primitive\",\n+                                 lang,\n+                                 ty)\n                     .span_help(span, \"consider using a trait to implement these methods\")\n                     .emit();\n             }\n@@ -209,12 +218,14 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                         return;\n                     }\n                     _ => {\n-                        struct_span_err!(self.tcx.sess, ty.span, E0118,\n+                        struct_span_err!(self.tcx.sess,\n+                                         ty.span,\n+                                         E0118,\n                                          \"no base type found for inherent implementation\")\n-                        .span_label(ty.span, &format!(\"impl requires a base type\"))\n-                        .note(&format!(\"either implement a trait on it or create a newtype \\\n-                                        to wrap it instead\"))\n-                        .emit();\n+                            .span_label(ty.span, &format!(\"impl requires a base type\"))\n+                            .note(&format!(\"either implement a trait on it or create a newtype \\\n+                                            to wrap it instead\"))\n+                            .emit();\n                         return;\n                     }\n                 }\n@@ -226,20 +237,23 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match traits::orphan_check(self.tcx, def_id) {\n-                    Ok(()) => { }\n+                    Ok(()) => {}\n                     Err(traits::OrphanCheckErr::NoLocalInputType) => {\n-                        struct_span_err!(\n-                            self.tcx.sess, item.span, E0117,\n-                             \"only traits defined in the current crate can be \\\n-                             implemented for arbitrary types\")\n-                        .span_label(item.span, &format!(\"impl doesn't use types inside crate\"))\n-                        .note(&format!(\"the impl does not reference any \\\n-                                        types defined in this crate\"))\n-                        .emit();\n+                        struct_span_err!(self.tcx.sess,\n+                                         item.span,\n+                                         E0117,\n+                                         \"only traits defined in the current crate can be \\\n+                                          implemented for arbitrary types\")\n+                            .span_label(item.span, &format!(\"impl doesn't use types inside crate\"))\n+                            .note(&format!(\"the impl does not reference any types defined in \\\n+                                            this crate\"))\n+                            .emit();\n                         return;\n                     }\n                     Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n-                        span_err!(self.tcx.sess, item.span, E0210,\n+                        span_err!(self.tcx.sess,\n+                                  item.span,\n+                                  E0210,\n                                   \"type parameter `{}` must be used as the type parameter for \\\n                                    some local type (e.g. `MyStruct<T>`); only traits defined in \\\n                                    the current crate can be implemented for a type parameter\",\n@@ -285,10 +299,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                        trait_ref,\n                        trait_def_id,\n                        self.tcx.trait_has_default_impl(trait_def_id));\n-                if\n-                    self.tcx.trait_has_default_impl(trait_def_id) &&\n-                    trait_def_id.krate != LOCAL_CRATE\n-                {\n+                if self.tcx.trait_has_default_impl(trait_def_id) &&\n+                   trait_def_id.krate != LOCAL_CRATE {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n                         ty::TyAdt(self_def, _) => Some(self_def.did),\n@@ -305,20 +317,17 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                             if self_def_id.is_local() {\n                                 None\n                             } else {\n-                                Some(format!(\n-                                    \"cross-crate traits with a default impl, like `{}`, \\\n-                                     can only be implemented for a struct/enum type \\\n-                                     defined in the current crate\",\n-                                    self.tcx.item_path_str(trait_def_id)))\n+                                Some(format!(\"cross-crate traits with a default impl, like `{}`, \\\n+                                              can only be implemented for a struct/enum type \\\n+                                              defined in the current crate\",\n+                                             self.tcx.item_path_str(trait_def_id)))\n                             }\n                         }\n                         _ => {\n-                            Some(format!(\n-                                \"cross-crate traits with a default impl, like `{}`, \\\n-                                 can only be implemented for a struct/enum type, \\\n-                                 not `{}`\",\n-                                self.tcx.item_path_str(trait_def_id),\n-                                self_ty))\n+                            Some(format!(\"cross-crate traits with a default impl, like `{}`, can \\\n+                                          only be implemented for a struct/enum type, not `{}`\",\n+                                         self.tcx.item_path_str(trait_def_id),\n+                                         self_ty))\n                         }\n                     };\n \n@@ -330,14 +339,18 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n \n                 // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n                 if Some(trait_def_id) == self.tcx.lang_items.sized_trait() {\n-                    struct_span_err!(self.tcx.sess, item.span, E0322,\n-                              \"explicit impls for the `Sized` trait are not permitted\")\n+                    struct_span_err!(self.tcx.sess,\n+                                     item.span,\n+                                     E0322,\n+                                     \"explicit impls for the `Sized` trait are not permitted\")\n                         .span_label(item.span, &format!(\"impl of 'Sized' not allowed\"))\n                         .emit();\n                     return;\n                 }\n                 if Some(trait_def_id) == self.tcx.lang_items.unsize_trait() {\n-                    span_err!(self.tcx.sess, item.span, E0328,\n+                    span_err!(self.tcx.sess,\n+                              item.span,\n+                              E0328,\n                               \"explicit impls for the `Unsize` trait are not permitted\");\n                     return;\n                 }\n@@ -348,9 +361,11 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                        self.tcx.map.node_to_string(item.id));\n                 let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n                 if trait_ref.def_id.krate != LOCAL_CRATE {\n-                    struct_span_err!(self.tcx.sess, item_trait_ref.path.span, E0318,\n-                              \"cannot create default implementations for traits outside the \\\n-                               crate they're defined in; define a new trait instead\")\n+                    struct_span_err!(self.tcx.sess,\n+                                     item_trait_ref.path.span,\n+                                     E0318,\n+                                     \"cannot create default implementations for traits outside \\\n+                                      the crate they're defined in; define a new trait instead\")\n                         .span_label(item_trait_ref.path.span,\n                                     &format!(\"`{}` trait not defined in this crate\",\n                                              item_trait_ref.path))\n@@ -365,7 +380,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         self.check_item(item);\n     }"}, {"sha": "1bf140c21a5a5b0f99756d38dd4837e73b99d620", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -23,15 +23,17 @@ use util::nodemap::DefIdMap;\n use lint;\n \n pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut overlap = OverlapChecker { tcx: tcx,\n-                                       default_impls: DefIdMap() };\n+    let mut overlap = OverlapChecker {\n+        tcx: tcx,\n+        default_impls: DefIdMap(),\n+    };\n \n     // this secondary walk specifically checks for some other cases,\n     // like defaulted traits, for which additional overlap rules exist\n     tcx.visit_all_items_in_krate(DepNode::CoherenceOverlapCheckSpecial, &mut overlap);\n }\n \n-struct OverlapChecker<'cx, 'tcx:'cx> {\n+struct OverlapChecker<'cx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n \n     // maps from a trait def-id to an impl id\n@@ -41,18 +43,21 @@ struct OverlapChecker<'cx, 'tcx:'cx> {\n impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n         #[derive(Copy, Clone, PartialEq)]\n-        enum Namespace { Type, Value }\n+        enum Namespace {\n+            Type,\n+            Value,\n+        }\n \n         fn name_and_namespace<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId)\n-                                        -> (ast::Name, Namespace)\n-        {\n+                                        -> (ast::Name, Namespace) {\n             let item = tcx.impl_or_trait_item(def_id);\n-            (item.name(), match item {\n-                ty::TypeTraitItem(..) => Namespace::Type,\n-                ty::ConstTraitItem(..) => Namespace::Value,\n-                ty::MethodTraitItem(..) => Namespace::Value,\n-            })\n+            (item.name(),\n+             match item {\n+                 ty::TypeTraitItem(..) => Namespace::Type,\n+                 ty::ConstTraitItem(..) => Namespace::Value,\n+                 ty::MethodTraitItem(..) => Namespace::Value,\n+             })\n         }\n \n         let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n@@ -79,11 +84,11 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         let inherent_impls = self.tcx.inherent_impls.borrow();\n         let impls = match inherent_impls.get(&ty_def_id) {\n             Some(impls) => impls,\n-            None => return\n+            None => return,\n         };\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n-            for &impl2_def_id in &impls[(i+1)..] {\n+            for &impl2_def_id in &impls[(i + 1)..] {\n                 self.tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n                     if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n                         self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n@@ -94,10 +99,12 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemUnion(..) => {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) => {\n                 let type_def_id = self.tcx.map.local_def_id(item.id);\n                 self.check_for_overlapping_inherent_impls(type_def_id);\n             }\n@@ -111,12 +118,14 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n \n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n                 if let Some(prev_id) = prev_default_impl {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        self.tcx.span_of_impl(impl_def_id).unwrap(), E0521,\n-                        \"redundant default implementations of trait `{}`:\",\n-                        trait_ref);\n-                    err.span_note(self.tcx.span_of_impl(self.tcx.map.local_def_id(prev_id))\n+                    let mut err = struct_span_err!(self.tcx.sess,\n+                                                   self.tcx.span_of_impl(impl_def_id).unwrap(),\n+                                                   E0521,\n+                                                   \"redundant default implementations of trait \\\n+                                                    `{}`:\",\n+                                                   trait_ref);\n+                    err.span_note(self.tcx\n+                                      .span_of_impl(self.tcx.map.local_def_id(prev_id))\n                                       .unwrap(),\n                                   \"redundant implementation is here:\");\n                     err.emit();\n@@ -127,8 +136,8 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n \n-                let _task = self.tcx.dep_graph.in_task(\n-                    DepNode::CoherenceOverlapCheck(trait_def_id));\n+                let _task =\n+                    self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n \n                 let def = self.tcx.lookup_trait_def(trait_def_id);\n \n@@ -137,26 +146,27 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n \n                 // insertion failed due to overlap\n                 if let Err(overlap) = insert_result {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess, self.tcx.span_of_impl(impl_def_id).unwrap(), E0119,\n-                        \"conflicting implementations of trait `{}`{}:\",\n-                        overlap.trait_desc,\n-                        overlap.self_desc.clone().map_or(String::new(),\n-                                                         |ty| format!(\" for type `{}`\", ty)));\n+                    let mut err = struct_span_err!(self.tcx.sess,\n+                                                   self.tcx.span_of_impl(impl_def_id).unwrap(),\n+                                                   E0119,\n+                                                   \"conflicting implementations of trait `{}`{}:\",\n+                                                   overlap.trait_desc,\n+                                                   overlap.self_desc.clone().map_or(String::new(),\n+                                                                                    |ty| {\n+                        format!(\" for type `{}`\", ty)\n+                    }));\n \n                     match self.tcx.span_of_impl(overlap.with_impl) {\n                         Ok(span) => {\n-                            err.span_label(span,\n-                                           &format!(\"first implementation here\"));\n+                            err.span_label(span, &format!(\"first implementation here\"));\n                             err.span_label(self.tcx.span_of_impl(impl_def_id).unwrap(),\n                                            &format!(\"conflicting implementation{}\",\n                                                     overlap.self_desc\n                                                         .map_or(String::new(),\n                                                                 |ty| format!(\" for `{}`\", ty))));\n                         }\n                         Err(cname) => {\n-                            err.note(&format!(\"conflicting implementation in crate `{}`\",\n-                                              cname));\n+                            err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n                         }\n                     }\n \n@@ -177,7 +187,9 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                         let mut supertrait_def_ids =\n                             traits::supertrait_def_ids(self.tcx, data.principal.def_id());\n                         if supertrait_def_ids.any(|d| d == trait_def_id) {\n-                            span_err!(self.tcx.sess, item.span, E0371,\n+                            span_err!(self.tcx.sess,\n+                                      item.span,\n+                                      E0371,\n                                       \"the object type `{}` automatically \\\n                                        implements the trait `{}`\",\n                                       trait_ref.self_ty(),"}, {"sha": "ff55ce0e5eb55cea69b75aa270a9a04ea14e7e66", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -20,21 +20,26 @@ pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.map.krate().visit_all_items(&mut orphan);\n }\n \n-struct UnsafetyChecker<'cx, 'tcx:'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>\n+struct UnsafetyChecker<'cx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n }\n \n impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n-    fn check_unsafety_coherence(&mut self, item: &'v hir::Item,\n+    fn check_unsafety_coherence(&mut self,\n+                                item: &'v hir::Item,\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity) {\n         match self.tcx.impl_trait_ref(self.tcx.map.local_def_id(item.id)) {\n             None => {\n                 // Inherent impl.\n                 match unsafety {\n-                    hir::Unsafety::Normal => { /* OK */ }\n+                    hir::Unsafety::Normal => {\n+                        // OK\n+                    }\n                     hir::Unsafety::Unsafe => {\n-                        span_err!(self.tcx.sess, item.span, E0197,\n+                        span_err!(self.tcx.sess,\n+                                  item.span,\n+                                  E0197,\n                                   \"inherent impls cannot be declared as unsafe\");\n                     }\n                 }\n@@ -43,39 +48,41 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n             Some(trait_ref) => {\n                 let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n                 match (trait_def.unsafety, unsafety, polarity) {\n-                    (hir::Unsafety::Unsafe,\n-                     hir::Unsafety::Unsafe, hir::ImplPolarity::Negative) => {\n-                        span_err!(self.tcx.sess, item.span, E0198,\n+                    (hir::Unsafety::Unsafe, hir::Unsafety::Unsafe, hir::ImplPolarity::Negative) => {\n+                        span_err!(self.tcx.sess,\n+                                  item.span,\n+                                  E0198,\n                                   \"negative implementations are not unsafe\");\n                     }\n \n                     (hir::Unsafety::Normal, hir::Unsafety::Unsafe, _) => {\n-                        span_err!(self.tcx.sess, item.span, E0199,\n+                        span_err!(self.tcx.sess,\n+                                  item.span,\n+                                  E0199,\n                                   \"implementing the trait `{}` is not unsafe\",\n                                   trait_ref);\n                     }\n \n-                    (hir::Unsafety::Unsafe,\n-                     hir::Unsafety::Normal, hir::ImplPolarity::Positive) => {\n-                        span_err!(self.tcx.sess, item.span, E0200,\n+                    (hir::Unsafety::Unsafe, hir::Unsafety::Normal, hir::ImplPolarity::Positive) => {\n+                        span_err!(self.tcx.sess,\n+                                  item.span,\n+                                  E0200,\n                                   \"the trait `{}` requires an `unsafe impl` declaration\",\n                                   trait_ref);\n                     }\n \n-                    (hir::Unsafety::Unsafe,\n-                     hir::Unsafety::Normal, hir::ImplPolarity::Negative) |\n-                    (hir::Unsafety::Unsafe,\n-                     hir::Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n+                    (hir::Unsafety::Unsafe, hir::Unsafety::Normal, hir::ImplPolarity::Negative) |\n+                    (hir::Unsafety::Unsafe, hir::Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n                     (hir::Unsafety::Normal, hir::Unsafety::Normal, _) => {\n-                        /* OK */\n+                        // OK\n                     }\n                 }\n             }\n         }\n     }\n }\n \n-impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemDefaultImpl(unsafety, _) => {\n@@ -84,7 +91,7 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n             hir::ItemImpl(unsafety, polarity, ..) => {\n                 self.check_unsafety_coherence(item, unsafety, polarity);\n             }\n-            _ => { }\n+            _ => {}\n         }\n     }\n }"}, {"sha": "afd833d8bdd81dfbebf49c4c1f5a9a8322dba0c4", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -59,7 +59,6 @@ const EMPTY_BUCKET: u64 = 0;\n /// around just the \"table\" part of the hashtable. It enforces some\n /// invariants at the type level and employs some performance trickery,\n /// but in general is just a tricked out `Vec<Option<u64, K, V>>`.\n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n pub struct RawTable<K, V> {\n     capacity: usize,\n     size: usize,"}, {"sha": "6f5ce350e6cb376092275f63cf7bd9c124a8a862", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -314,9 +314,11 @@ impl CString {\n }\n \n // Turns this `CString` into an empty string to prevent\n-// memory unsafe code from working by accident.\n+// memory unsafe code from working by accident. Inline\n+// to prevent LLVM from optimizing it away in debug builds.\n #[stable(feature = \"cstring_drop\", since = \"1.13.0\")]\n impl Drop for CString {\n+    #[inline]\n     fn drop(&mut self) {\n         unsafe { *self.inner.get_unchecked_mut(0) = 0; }\n     }"}, {"sha": "b3e4351e9b20006ce4efe118d2b7d3635d19e2b3", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -278,7 +278,6 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n-#![cfg_attr(stage0, feature(unsafe_no_drop_flag))]\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n #![feature(zero_one)]"}, {"sha": "4f64b3f2e1d676d630cedb34306c1eb0323c4918", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -557,7 +557,9 @@ pub struct ExpansionData {\n     pub depth: usize,\n     pub backtrace: ExpnId,\n     pub module: Rc<ModuleData>,\n-    pub in_block: bool,\n+\n+    // True if non-inline modules without a `#[path]` are forbidden at the root of this expansion.\n+    pub no_noninline_mod: bool,\n }\n \n /// One of these is made during expansion and incrementally updated as we go;\n@@ -590,7 +592,7 @@ impl<'a> ExtCtxt<'a> {\n                 depth: 0,\n                 backtrace: NO_EXPANSION,\n                 module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n-                in_block: false,\n+                no_noninline_mod: false,\n             },\n         }\n     }"}, {"sha": "b1d828d0e3e4938446beda36e0fe2daacf0bf331", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -667,9 +667,9 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        let orig_in_block = mem::replace(&mut self.cx.current_expansion.in_block, true);\n+        let no_noninline_mod = mem::replace(&mut self.cx.current_expansion.no_noninline_mod, true);\n         let result = noop_fold_block(block, self);\n-        self.cx.current_expansion.in_block = orig_in_block;\n+        self.cx.current_expansion.no_noninline_mod = no_noninline_mod;\n         result\n     }\n \n@@ -708,6 +708,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                     return noop_fold_item(item, self);\n                 }\n \n+                let orig_no_noninline_mod = self.cx.current_expansion.no_noninline_mod;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n                 module.mod_path.push(item.ident);\n \n@@ -717,11 +718,14 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 let inline_module = item.span.contains(inner) || inner == syntax_pos::DUMMY_SP;\n \n                 if inline_module {\n-                    module.directory.push(&*{\n-                        ::attr::first_attr_value_str_by_name(&item.attrs, \"path\")\n-                            .unwrap_or(item.ident.name.as_str())\n-                    });\n+                    if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, \"path\") {\n+                        self.cx.current_expansion.no_noninline_mod = false;\n+                        module.directory.push(&*path);\n+                    } else {\n+                        module.directory.push(&*item.ident.name.as_str());\n+                    }\n                 } else {\n+                    self.cx.current_expansion.no_noninline_mod = false;\n                     module.directory =\n                         PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(inner));\n                     module.directory.pop();\n@@ -731,6 +735,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n                 let result = noop_fold_item(item, self);\n                 self.cx.current_expansion.module = orig_module;\n+                self.cx.current_expansion.no_noninline_mod = orig_no_noninline_mod;\n                 return result;\n             }\n             // Ensure that test functions are accessible from the test harness."}, {"sha": "2e0c7ddb540f4c50967f87bf810ce367607e529b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -122,7 +122,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                                            rhs);\n                 let mut p = Parser::new(cx.parse_sess(), cx.cfg(), Box::new(trncbr));\n                 p.directory = cx.current_expansion.module.directory.clone();\n-                p.restrictions = match cx.current_expansion.in_block {\n+                p.restrictions = match cx.current_expansion.no_noninline_mod {\n                     true => Restrictions::NO_NONINLINE_MOD,\n                     false => Restrictions::empty(),\n                 };"}, {"sha": "a1c273baeea42b67e09e6c8814915a8b56388e37", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -38,14 +38,24 @@ pub struct JsonEmitter {\n }\n \n impl JsonEmitter {\n+    pub fn stderr(registry: Option<Registry>,\n+                  code_map: Rc<CodeMap>) -> JsonEmitter {\n+        JsonEmitter {\n+            dst: Box::new(io::stderr()),\n+            registry: registry,\n+            cm: code_map,\n+        }\n+    }\n+\n     pub fn basic() -> JsonEmitter {\n         JsonEmitter::stderr(None, Rc::new(CodeMap::new()))\n     }\n \n-    pub fn stderr(registry: Option<Registry>,\n-                  code_map: Rc<CodeMap>) -> JsonEmitter {\n+    pub fn new(dst: Box<Write + Send>,\n+               registry: Option<Registry>,\n+               code_map: Rc<CodeMap>) -> JsonEmitter {\n         JsonEmitter {\n-            dst: Box::new(io::stderr()),\n+            dst: dst,\n             registry: registry,\n             cm: code_map,\n         }"}, {"sha": "5476166932d32fced7400c13717f82970c9d6b5f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -5274,23 +5274,27 @@ impl<'a> Parser<'a> {\n             }\n         } else {\n             let directory = self.directory.clone();\n-            self.push_directory(id, &outer_attrs);\n+            let restrictions = self.push_directory(id, &outer_attrs);\n             self.expect(&token::OpenDelim(token::Brace))?;\n             let mod_inner_lo = self.span.lo;\n             let attrs = self.parse_inner_attributes()?;\n-            let m = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n+            let m = self.with_res(restrictions, |this| {\n+                this.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)\n+            })?;\n             self.directory = directory;\n             Ok((id, ItemKind::Mod(m), Some(attrs)))\n         }\n     }\n \n-    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n-        let default_path = self.id_to_interned_str(id);\n-        let file_path = match ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n-            Some(d) => d,\n-            None => default_path,\n-        };\n-        self.directory.push(&*file_path)\n+    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) -> Restrictions {\n+        if let Some(path) = ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n+            self.directory.push(&*path);\n+            self.restrictions - Restrictions::NO_NONINLINE_MOD\n+        } else {\n+            let default_path = self.id_to_interned_str(id);\n+            self.directory.push(&*default_path);\n+            self.restrictions\n+        }\n     }\n \n     pub fn submod_path_from_attr(attrs: &[ast::Attribute], dir_path: &Path) -> Option<PathBuf> {"}, {"sha": "6ccf9848c6df901e9844351bb4d06bb110b2cc92", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -19,7 +19,7 @@ use std::iter;\n use std::slice;\n use std::mem;\n use std::vec;\n-use attr;\n+use attr::{self, HasAttrs};\n use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, FileMap, BytePos};\n use std::rc::Rc;\n \n@@ -226,12 +226,20 @@ fn mk_reexport_mod(cx: &mut TestCtxt, parent: ast::NodeId, tests: Vec<ast::Ident\n                    tested_submods: Vec<(ast::Ident, ast::Ident)>) -> (P<ast::Item>, ast::Ident) {\n     let super_ = token::str_to_ident(\"super\");\n \n+    // Generate imports with `#[allow(private_in_public)]` to work around issue #36768.\n+    let allow_private_in_public = cx.ext_cx.attribute(DUMMY_SP, cx.ext_cx.meta_list(\n+        DUMMY_SP,\n+        InternedString::new(\"allow\"),\n+        vec![cx.ext_cx.meta_list_item_word(DUMMY_SP, InternedString::new(\"private_in_public\"))],\n+    ));\n     let items = tests.into_iter().map(|r| {\n         cx.ext_cx.item_use_simple(DUMMY_SP, ast::Visibility::Public,\n                                   cx.ext_cx.path(DUMMY_SP, vec![super_, r]))\n+            .map_attrs(|_| vec![allow_private_in_public.clone()])\n     }).chain(tested_submods.into_iter().map(|(r, sym)| {\n         let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n         cx.ext_cx.item_use_simple_(DUMMY_SP, ast::Visibility::Public, r, path)\n+            .map_attrs(|_| vec![allow_private_in_public.clone()])\n     })).collect();\n \n     let reexport_mod = ast::Mod {"}, {"sha": "05189f2011b0ddeb823ca17fe89a0d0d0542c974", "filename": "src/stage0.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -12,6 +12,6 @@\n # tarball for a stable release you'll likely see `1.x.0-$date` where `1.x.0` was\n # released on `$date`\n \n-rustc: beta-2016-08-17\n-rustc_key: 195e6261\n-cargo: nightly-2016-08-21\n+rustc: beta-2016-09-28\n+rustc_key: 62b3e239\n+cargo: nightly-2016-09-26"}, {"sha": "69b4acd3e302363401a61145dd71c1851504e28e", "filename": "src/test/incremental/change_crate_order/auxiliary/a.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fauxiliary%2Fa.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"rlib\"]\n+\n+pub static A : u32 = 32;\n+"}, {"sha": "1ab97a312c1f1bca36a72d5f2a899f582223d6c5", "filename": "src/test/incremental/change_crate_order/auxiliary/b.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fauxiliary%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fauxiliary%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fauxiliary%2Fb.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"rlib\"]\n+\n+pub static B: u32 = 32;\n+"}, {"sha": "bd8742ff38e01b98572e07ec957025361575522b", "filename": "src/test/incremental/change_crate_order/main.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fmain.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:a.rs\n+// aux-build:b.rs\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+\n+#[cfg(rpass1)]\n+extern crate a;\n+#[cfg(rpass1)]\n+extern crate b;\n+\n+#[cfg(rpass2)]\n+extern crate b;\n+#[cfg(rpass2)]\n+extern crate a;\n+\n+use a::A;\n+use b::B;\n+\n+//? #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn main() {\n+    A + B;\n+}"}, {"sha": "05c1713561a3ed6678be479569a17aa05d80f982", "filename": "src/test/run-make/llvm-phase/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -79,8 +79,8 @@ fn main() {\n         format!(\"_ _ --sysroot {} --crate-type dylib\", path.to_str().unwrap())\n         .split(' ').map(|s| s.to_string()).collect();\n \n-    let (result, _) = rustc_driver::run_compiler_with_file_loader(\n-        &args, &mut JitCalls, box JitLoader);\n+    let (result, _) = rustc_driver::run_compiler(\n+        &args, &mut JitCalls, Some(box JitLoader), None);\n     if let Err(n) = result {\n         panic!(\"Error {}\", n);\n     }"}, {"sha": "35e9f3f5c8d64f2968f5c4320629976f6666a238", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -86,6 +86,6 @@ fn main() {\n     let mut tc = TestCalls { count: 1 };\n     // we should never get use this filename, but lets make sure they are valid args.\n     let args = vec![\"compiler-calls\".to_string(), \"foo.rs\".to_string()];\n-    rustc_driver::run_compiler(&args, &mut tc);\n+    rustc_driver::run_compiler(&args, &mut tc, None, None);\n     assert_eq!(tc.count, 30);\n }"}, {"sha": "960391bb8deac7a788692d89de0325b9f6538b64", "filename": "src/test/run-pass/cstring-drop.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/eee2d04d877fe909309c39b6bdf711dc586d0a1e/src%2Ftest%2Frun-pass%2Fcstring-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee2d04d877fe909309c39b6bdf711dc586d0a1e/src%2Ftest%2Frun-pass%2Fcstring-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcstring-drop.rs?ref=eee2d04d877fe909309c39b6bdf711dc586d0a1e", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-emscripten\n-\n-// Test that `CString::new(\"hello\").unwrap().as_ptr()` pattern\n-// leads to failure.\n-\n-use std::env;\n-use std::ffi::{CString, CStr};\n-use std::os::raw::c_char;\n-use std::process::{Command, Stdio};\n-\n-fn main() {\n-    let args: Vec<String> = env::args().collect();\n-    if args.len() > 1 && args[1] == \"child\" {\n-        // Repeat several times to be more confident that\n-        // it is `Drop` for `CString` that does the cleanup,\n-        // and not just some lucky UB.\n-        let xs = vec![CString::new(\"Hello\").unwrap(); 10];\n-        let ys = xs.iter().map(|s| s.as_ptr()).collect::<Vec<_>>();\n-        drop(xs);\n-        assert!(ys.into_iter().any(is_hello));\n-        return;\n-    }\n-\n-    let output = Command::new(&args[0]).arg(\"child\").output().unwrap();\n-    assert!(!output.status.success());\n-}\n-\n-fn is_hello(s: *const c_char) -> bool {\n-    // `s` is a dangling pointer and reading it is technically\n-    // undefined behavior. But we want to prevent the most diabolical\n-    // kind of UB (apart from nasal demons): reading a value that was\n-    // previously written.\n-    //\n-    // Segfaulting or reading an empty string is Ok,\n-    // reading \"Hello\" is bad.\n-    let s = unsafe { CStr::from_ptr(s) };\n-    let hello = CString::new(\"Hello\").unwrap();\n-    s == hello.as_ref()\n-}"}, {"sha": "bb4d12919a1c2ae1542c554d29101c86f468276e", "filename": "src/test/run-pass/issue-36768.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Frun-pass%2Fissue-36768.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Frun-pass%2Fissue-36768.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-36768.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test\n+#![deny(private_in_public)]\n+\n+#[test] fn foo() {}\n+mod foo {}\n+\n+#[test] fn core() {}\n+extern crate core;"}, {"sha": "28dee15cfa04399e1ebe61bbe7d33b324c03bff5", "filename": "src/test/run-pass/mod_dir_path.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Frun-pass%2Fmod_dir_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src%2Ftest%2Frun-pass%2Fmod_dir_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod_dir_path.rs?ref=91f34c0c70746f5c938d25d02a8a66b41240b2f0", "patch": "@@ -17,4 +17,15 @@ mod mod_dir_simple {\n \n pub fn main() {\n     assert_eq!(mod_dir_simple::syrup::foo(), 10);\n+\n+    #[path = \"auxiliary\"]\n+    mod foo {\n+        mod two_macros;\n+    }\n+\n+    #[path = \"auxiliary\"]\n+    mod bar {\n+        macro_rules! m { () => { mod two_macros; } }\n+        m!();\n+    }\n }"}]}