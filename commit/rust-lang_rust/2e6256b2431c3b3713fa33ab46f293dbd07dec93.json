{"sha": "2e6256b2431c3b3713fa33ab46f293dbd07dec93", "node_id": "C_kwDOAAsO6NoAKDJlNjI1NmIyNDMxYzNiMzcxM2ZhMzNhYjQ2ZjI5M2RiZDA3ZGVjOTM", "commit": {"author": {"name": "Linus F\u00e4rnstrand", "email": "faern@faern.net", "date": "2020-11-02T23:40:27Z"}, "committer": {"name": "Linus F\u00e4rnstrand", "email": "faern@faern.net", "date": "2022-06-23T19:01:58Z"}, "message": "Implement IpV{4,6}Addr structs with native Rust encoding", "tree": {"sha": "43a18cc3a7f58c5b3d23a0f6502a33966e05ac62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43a18cc3a7f58c5b3d23a0f6502a33966e05ac62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e6256b2431c3b3713fa33ab46f293dbd07dec93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e6256b2431c3b3713fa33ab46f293dbd07dec93", "html_url": "https://github.com/rust-lang/rust/commit/2e6256b2431c3b3713fa33ab46f293dbd07dec93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e6256b2431c3b3713fa33ab46f293dbd07dec93/comments", "author": {"login": "faern", "id": 332294, "node_id": "MDQ6VXNlcjMzMjI5NA==", "avatar_url": "https://avatars.githubusercontent.com/u/332294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/faern", "html_url": "https://github.com/faern", "followers_url": "https://api.github.com/users/faern/followers", "following_url": "https://api.github.com/users/faern/following{/other_user}", "gists_url": "https://api.github.com/users/faern/gists{/gist_id}", "starred_url": "https://api.github.com/users/faern/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/faern/subscriptions", "organizations_url": "https://api.github.com/users/faern/orgs", "repos_url": "https://api.github.com/users/faern/repos", "events_url": "https://api.github.com/users/faern/events{/privacy}", "received_events_url": "https://api.github.com/users/faern/received_events", "type": "User", "site_admin": false}, "committer": {"login": "faern", "id": 332294, "node_id": "MDQ6VXNlcjMzMjI5NA==", "avatar_url": "https://avatars.githubusercontent.com/u/332294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/faern", "html_url": "https://github.com/faern", "followers_url": "https://api.github.com/users/faern/followers", "following_url": "https://api.github.com/users/faern/following{/other_user}", "gists_url": "https://api.github.com/users/faern/gists{/gist_id}", "starred_url": "https://api.github.com/users/faern/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/faern/subscriptions", "organizations_url": "https://api.github.com/users/faern/orgs", "repos_url": "https://api.github.com/users/faern/repos", "events_url": "https://api.github.com/users/faern/events{/privacy}", "received_events_url": "https://api.github.com/users/faern/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55e23db137bd659a4299abc29104eb643a5a0b1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/55e23db137bd659a4299abc29104eb643a5a0b1c", "html_url": "https://github.com/rust-lang/rust/commit/55e23db137bd659a4299abc29104eb643a5a0b1c"}], "stats": {"total": 155, "additions": 41, "deletions": 114}, "files": [{"sha": "bfda46a802b38775b224c0de4a729ac76bfd8bde", "filename": "library/std/src/net/addr.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2e6256b2431c3b3713fa33ab46f293dbd07dec93/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6256b2431c3b3713fa33ab46f293dbd07dec93/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs?ref=2e6256b2431c3b3713fa33ab46f293dbd07dec93", "patch": "@@ -12,7 +12,7 @@ use crate::option;\n use crate::slice;\n use crate::sys::net::netc as c;\n use crate::sys_common::net::LookupHost;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::sys_common::{FromInner, IntoInner};\n use crate::vec;\n \n /// An internet socket address, either IPv4 or IPv6.\n@@ -528,17 +528,14 @@ impl SocketAddrV6 {\n \n impl FromInner<c::sockaddr_in> for SocketAddrV4 {\n     fn from_inner(addr: c::sockaddr_in) -> SocketAddrV4 {\n-        SocketAddrV4 {\n-            ip: unsafe { *(&addr.sin_addr as *const c::in_addr as *const Ipv4Addr) },\n-            port: ntohs(addr.sin_port),\n-        }\n+        SocketAddrV4 { ip: Ipv4Addr::from_inner(addr.sin_addr), port: ntohs(addr.sin_port) }\n     }\n }\n \n impl FromInner<c::sockaddr_in6> for SocketAddrV6 {\n     fn from_inner(addr: c::sockaddr_in6) -> SocketAddrV6 {\n         SocketAddrV6 {\n-            ip: unsafe { *(&addr.sin6_addr as *const c::in6_addr as *const Ipv6Addr) },\n+            ip: Ipv6Addr::from_inner(addr.sin6_addr),\n             port: ntohs(addr.sin6_port),\n             flowinfo: addr.sin6_flowinfo,\n             scope_id: addr.sin6_scope_id,\n@@ -562,7 +559,7 @@ impl IntoInner<c::sockaddr_in6> for SocketAddrV6 {\n         c::sockaddr_in6 {\n             sin6_family: c::AF_INET6 as c::sa_family_t,\n             sin6_port: htons(self.port),\n-            sin6_addr: *self.ip.as_inner(),\n+            sin6_addr: self.ip.into_inner(),\n             sin6_flowinfo: self.flowinfo,\n             sin6_scope_id: self.scope_id,\n             ..unsafe { mem::zeroed() }"}, {"sha": "1d49024f13e15956a1c44af788b61f422b1390fd", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 34, "deletions": 104, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/2e6256b2431c3b3713fa33ab46f293dbd07dec93/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6256b2431c3b3713fa33ab46f293dbd07dec93/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=2e6256b2431c3b3713fa33ab46f293dbd07dec93", "patch": "@@ -4,11 +4,10 @@ mod tests;\n \n use crate::cmp::Ordering;\n use crate::fmt::{self, Write as FmtWrite};\n-use crate::hash;\n use crate::io::Write as IoWrite;\n use crate::mem::transmute;\n use crate::sys::net::netc as c;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::sys_common::{FromInner, IntoInner};\n \n /// An IP address, either IPv4 or IPv6.\n ///\n@@ -77,10 +76,10 @@ pub enum IpAddr {\n /// assert!(\"0000000.0.0.0\".parse::<Ipv4Addr>().is_err()); // first octet is a zero in octal\n /// assert!(\"0xcb.0x0.0x71.0x00\".parse::<Ipv4Addr>().is_err()); // all octets are in hex\n /// ```\n-#[derive(Copy)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv4Addr {\n-    inner: c::in_addr,\n+    octets: [u8; 4],\n }\n \n /// An IPv6 address.\n@@ -162,10 +161,10 @@ pub struct Ipv4Addr {\n /// assert_eq!(\"::1\".parse(), Ok(localhost));\n /// assert_eq!(localhost.is_loopback(), true);\n /// ```\n-#[derive(Copy)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv6Addr {\n-    inner: c::in6_addr,\n+    octets: [u8; 16],\n }\n \n /// Scope of an [IPv6 multicast address] as defined in [IETF RFC 7346 section 2].\n@@ -461,9 +460,7 @@ impl Ipv4Addr {\n     #[must_use]\n     #[inline]\n     pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n-        // `s_addr` is stored as BE on all machine and the array is in BE order.\n-        // So the native endian conversion method is used so that it's never swapped.\n-        Ipv4Addr { inner: c::in_addr { s_addr: u32::from_ne_bytes([a, b, c, d]) } }\n+        Ipv4Addr { octets: [a, b, c, d] }\n     }\n \n     /// An IPv4 address with the address pointing to localhost: `127.0.0.1`\n@@ -523,8 +520,7 @@ impl Ipv4Addr {\n     #[must_use]\n     #[inline]\n     pub const fn octets(&self) -> [u8; 4] {\n-        // This returns the order we want because s_addr is stored in big-endian.\n-        self.inner.s_addr.to_ne_bytes()\n+        self.octets\n     }\n \n     /// Returns [`true`] for the special 'unspecified' address (`0.0.0.0`).\n@@ -547,7 +543,7 @@ impl Ipv4Addr {\n     #[must_use]\n     #[inline]\n     pub const fn is_unspecified(&self) -> bool {\n-        self.inner.s_addr == 0\n+        u32::from_be_bytes(self.octets) == 0\n     }\n \n     /// Returns [`true`] if this is a loopback address (`127.0.0.0/8`).\n@@ -910,9 +906,7 @@ impl Ipv4Addr {\n     #[inline]\n     pub const fn to_ipv6_compatible(&self) -> Ipv6Addr {\n         let [a, b, c, d] = self.octets();\n-        Ipv6Addr {\n-            inner: c::in6_addr { s6_addr: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d] },\n-        }\n+        Ipv6Addr { octets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d] }\n     }\n \n     /// Converts this address to an [IPv4-mapped] [`IPv6` address].\n@@ -937,9 +931,7 @@ impl Ipv4Addr {\n     #[inline]\n     pub const fn to_ipv6_mapped(&self) -> Ipv6Addr {\n         let [a, b, c, d] = self.octets();\n-        Ipv6Addr {\n-            inner: c::in6_addr { s6_addr: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d] },\n-        }\n+        Ipv6Addr { octets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d] }\n     }\n }\n \n@@ -1034,22 +1026,6 @@ impl fmt::Debug for Ipv4Addr {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for Ipv4Addr {\n-    #[inline]\n-    fn clone(&self) -> Ipv4Addr {\n-        *self\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialEq for Ipv4Addr {\n-    #[inline]\n-    fn eq(&self, other: &Ipv4Addr) -> bool {\n-        self.inner.s_addr == other.inner.s_addr\n-    }\n-}\n-\n #[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n impl PartialEq<Ipv4Addr> for IpAddr {\n     #[inline]\n@@ -1072,21 +1048,6 @@ impl PartialEq<IpAddr> for Ipv4Addr {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Eq for Ipv4Addr {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for Ipv4Addr {\n-    #[inline]\n-    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        // NOTE:\n-        // * hash in big endian order\n-        // * in netbsd, `in_addr` has `repr(packed)`, we need to\n-        //   copy `s_addr` to avoid unsafe borrowing\n-        { self.inner.s_addr }.hash(s)\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for Ipv4Addr {\n     #[inline]\n@@ -1121,15 +1082,21 @@ impl PartialOrd<IpAddr> for Ipv4Addr {\n impl Ord for Ipv4Addr {\n     #[inline]\n     fn cmp(&self, other: &Ipv4Addr) -> Ordering {\n-        // Compare as native endian\n-        u32::from_be(self.inner.s_addr).cmp(&u32::from_be(other.inner.s_addr))\n+        self.octets.cmp(&other.octets)\n     }\n }\n \n impl IntoInner<c::in_addr> for Ipv4Addr {\n     #[inline]\n     fn into_inner(self) -> c::in_addr {\n-        self.inner\n+        // `s_addr` is stored as BE on all machines and the array is in BE order.\n+        // So the native endian conversion method is used so that it's never swapped.\n+        c::in_addr { s_addr: u32::from_ne_bytes(self.octets) }\n+    }\n+}\n+impl FromInner<c::in_addr> for Ipv4Addr {\n+    fn from_inner(addr: c::in_addr) -> Ipv4Addr {\n+        Ipv4Addr { octets: addr.s_addr.to_ne_bytes() }\n     }\n }\n \n@@ -1147,8 +1114,7 @@ impl From<Ipv4Addr> for u32 {\n     /// ```\n     #[inline]\n     fn from(ip: Ipv4Addr) -> u32 {\n-        let ip = ip.octets();\n-        u32::from_be_bytes(ip)\n+        u32::from_be_bytes(ip.octets)\n     }\n }\n \n@@ -1166,7 +1132,7 @@ impl From<u32> for Ipv4Addr {\n     /// ```\n     #[inline]\n     fn from(ip: u32) -> Ipv4Addr {\n-        Ipv4Addr::from(ip.to_be_bytes())\n+        Ipv4Addr { octets: ip.to_be_bytes() }\n     }\n }\n \n@@ -1184,7 +1150,7 @@ impl From<[u8; 4]> for Ipv4Addr {\n     /// ```\n     #[inline]\n     fn from(octets: [u8; 4]) -> Ipv4Addr {\n-        Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3])\n+        Ipv4Addr { octets }\n     }\n }\n \n@@ -1234,13 +1200,9 @@ impl Ipv6Addr {\n             h.to_be(),\n         ];\n         Ipv6Addr {\n-            inner: c::in6_addr {\n-                // All elements in `addr16` are big endian.\n-                // SAFETY: `[u16; 8]` is always safe to transmute to `[u8; 16]`.\n-                // rustc_allow_const_fn_unstable: the transmute could be written as stable const\n-                // code, but that leads to worse code generation (#75085)\n-                s6_addr: unsafe { transmute::<_, [u8; 16]>(addr16) },\n-            },\n+            // All elements in `addr16` are big endian.\n+            // SAFETY: `[u16; 8]` is always safe to transmute to `[u8; 16]`.\n+            octets: unsafe { transmute::<_, [u8; 16]>(addr16) },\n         }\n     }\n \n@@ -1285,11 +1247,9 @@ impl Ipv6Addr {\n     #[must_use]\n     #[inline]\n     pub const fn segments(&self) -> [u16; 8] {\n-        // All elements in `s6_addr` must be big endian.\n+        // All elements in `self.octets` must be big endian.\n         // SAFETY: `[u8; 16]` is always safe to transmute to `[u16; 8]`.\n-        // rustc_allow_const_fn_unstable: the transmute could be written as stable const code, but\n-        // that leads to worse code generation (#75085)\n-        let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.inner.s6_addr) };\n+        let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.octets) };\n         // We want native endian u16\n         [\n             u16::from_be(a),\n@@ -1748,7 +1708,7 @@ impl Ipv6Addr {\n     #[must_use]\n     #[inline]\n     pub const fn octets(&self) -> [u8; 16] {\n-        self.inner.s6_addr\n+        self.octets\n     }\n }\n \n@@ -1856,22 +1816,6 @@ impl fmt::Debug for Ipv6Addr {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for Ipv6Addr {\n-    #[inline]\n-    fn clone(&self) -> Ipv6Addr {\n-        *self\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialEq for Ipv6Addr {\n-    #[inline]\n-    fn eq(&self, other: &Ipv6Addr) -> bool {\n-        self.inner.s6_addr == other.inner.s6_addr\n-    }\n-}\n-\n #[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n impl PartialEq<IpAddr> for Ipv6Addr {\n     #[inline]\n@@ -1894,17 +1838,6 @@ impl PartialEq<Ipv6Addr> for IpAddr {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Eq for Ipv6Addr {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for Ipv6Addr {\n-    #[inline]\n-    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        self.inner.s6_addr.hash(s)\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for Ipv6Addr {\n     #[inline]\n@@ -1943,16 +1876,15 @@ impl Ord for Ipv6Addr {\n     }\n }\n \n-impl AsInner<c::in6_addr> for Ipv6Addr {\n-    #[inline]\n-    fn as_inner(&self) -> &c::in6_addr {\n-        &self.inner\n+impl IntoInner<c::in6_addr> for Ipv6Addr {\n+    fn into_inner(self) -> c::in6_addr {\n+        c::in6_addr { s6_addr: self.octets }\n     }\n }\n impl FromInner<c::in6_addr> for Ipv6Addr {\n     #[inline]\n     fn from_inner(addr: c::in6_addr) -> Ipv6Addr {\n-        Ipv6Addr { inner: addr }\n+        Ipv6Addr { octets: addr.s6_addr }\n     }\n }\n \n@@ -1973,8 +1905,7 @@ impl From<Ipv6Addr> for u128 {\n     /// ```\n     #[inline]\n     fn from(ip: Ipv6Addr) -> u128 {\n-        let ip = ip.octets();\n-        u128::from_be_bytes(ip)\n+        u128::from_be_bytes(ip.octets)\n     }\n }\n #[stable(feature = \"i128\", since = \"1.26.0\")]\n@@ -2025,8 +1956,7 @@ impl From<[u8; 16]> for Ipv6Addr {\n     /// ```\n     #[inline]\n     fn from(octets: [u8; 16]) -> Ipv6Addr {\n-        let inner = c::in6_addr { s6_addr: octets };\n-        Ipv6Addr::from_inner(inner)\n+        Ipv6Addr { octets }\n     }\n }\n "}, {"sha": "e49337999d2c571f094b697bc2a6b4c46f91aa81", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e6256b2431c3b3713fa33ab46f293dbd07dec93/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6256b2431c3b3713fa33ab46f293dbd07dec93/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=2e6256b2431c3b3713fa33ab46f293dbd07dec93", "patch": "@@ -10,7 +10,7 @@ use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::ptr;\n use crate::sys::net::netc as c;\n use crate::sys::net::{cvt, cvt_gai, cvt_r, init, wrlen_t, Socket};\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::sys_common::{FromInner, IntoInner};\n use crate::time::Duration;\n \n use libc::{c_int, c_void};\n@@ -621,7 +621,7 @@ impl UdpSocket {\n \n     pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n         let mreq = c::ipv6_mreq {\n-            ipv6mr_multiaddr: *multiaddr.as_inner(),\n+            ipv6mr_multiaddr: multiaddr.into_inner(),\n             ipv6mr_interface: to_ipv6mr_interface(interface),\n         };\n         setsockopt(&self.inner, c::IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, mreq)\n@@ -637,7 +637,7 @@ impl UdpSocket {\n \n     pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n         let mreq = c::ipv6_mreq {\n-            ipv6mr_multiaddr: *multiaddr.as_inner(),\n+            ipv6mr_multiaddr: multiaddr.into_inner(),\n             ipv6mr_interface: to_ipv6mr_interface(interface),\n         };\n         setsockopt(&self.inner, c::IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, mreq)"}]}