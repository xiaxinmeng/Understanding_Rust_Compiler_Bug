{"sha": "e7c6ad89cfd937d741b9d256e950ec0de96a7142", "node_id": "C_kwDOAAsO6NoAKGU3YzZhZDg5Y2ZkOTM3ZDc0MWI5ZDI1NmU5NTBlYzBkZTk2YTcxNDI", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-03-15T05:24:28Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-03-15T05:24:28Z"}, "message": "Improved implementation and comments after code review feedback", "tree": {"sha": "64967ced37821935138e1f09ff92a21f231868c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64967ced37821935138e1f09ff92a21f231868c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7c6ad89cfd937d741b9d256e950ec0de96a7142", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c6ad89cfd937d741b9d256e950ec0de96a7142", "html_url": "https://github.com/rust-lang/rust/commit/e7c6ad89cfd937d741b9d256e950ec0de96a7142", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7c6ad89cfd937d741b9d256e950ec0de96a7142/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87696fd5a1a1b7cd75cd9a66896deae0ab56cfb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/87696fd5a1a1b7cd75cd9a66896deae0ab56cfb5", "html_url": "https://github.com/rust-lang/rust/commit/87696fd5a1a1b7cd75cd9a66896deae0ab56cfb5"}], "stats": {"total": 201, "additions": 124, "deletions": 77}, "files": [{"sha": "5d7382305ae14e2bd0a5eb48d54e518351f2e786", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e7c6ad89cfd937d741b9d256e950ec0de96a7142/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c6ad89cfd937d741b9d256e950ec0de96a7142/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=e7c6ad89cfd937d741b9d256e950ec0de96a7142", "patch": "@@ -150,7 +150,7 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                         }\n                     }\n                     sym::read_via_copy => {\n-                        let Ok([arg]) = <[_; 1]>::try_from(std::mem::take(args)) else {\n+                        let [arg] = args.as_slice() else {\n                             span_bug!(terminator.source_info.span, \"Wrong number of arguments\");\n                         };\n                         let derefed_place =\n@@ -159,18 +159,23 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                             } else {\n                                 span_bug!(terminator.source_info.span, \"Only passing a local is supported\");\n                             };\n-                        block.statements.push(Statement {\n-                            source_info: terminator.source_info,\n-                            kind: StatementKind::Assign(Box::new((\n-                                *destination,\n-                                Rvalue::Use(Operand::Copy(derefed_place)),\n-                            ))),\n-                        });\n-                        if let Some(target) = *target {\n-                            terminator.kind = TerminatorKind::Goto { target };\n-                        } else {\n-                            // Reading something uninhabited means this is unreachable.\n-                            terminator.kind = TerminatorKind::Unreachable;\n+                        terminator.kind = match *target {\n+                            None => {\n+                                // No target means this read something uninhabited,\n+                                // so it must be unreachable, and we don't need to\n+                                // preserve the assignment either.\n+                                TerminatorKind::Unreachable\n+                            }\n+                            Some(target) => {\n+                                block.statements.push(Statement {\n+                                    source_info: terminator.source_info,\n+                                    kind: StatementKind::Assign(Box::new((\n+                                        *destination,\n+                                        Rvalue::Use(Operand::Copy(derefed_place)),\n+                                    ))),\n+                                });\n+                                TerminatorKind::Goto { target }\n+                            }\n                         }\n                     }\n                     sym::discriminant_value => {"}, {"sha": "ee8846675ce25135403d8fff3fdbe92e3ec5d12b", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7c6ad89cfd937d741b9d256e950ec0de96a7142/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c6ad89cfd937d741b9d256e950ec0de96a7142/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=e7c6ad89cfd937d741b9d256e950ec0de96a7142", "patch": "@@ -2020,16 +2020,12 @@ extern \"rust-intrinsic\" {\n     #[rustc_safe_intrinsic]\n     pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n-    /// This is a *typed* read, `copy *p` in MIR.\n+    /// This is an implementation detail of [`crate::ptr::read`] and should\n+    /// not be used anywhere else.  See its comments for why this exists.\n     ///\n-    /// The stabilized form of this intrinsic is [`crate::ptr::read`], so\n-    /// that can be implemented without needing to do an *untyped* copy\n-    /// via [`copy_nonoverlapping`], and thus can get proper metadata.\n-    ///\n-    /// This intrinsic can *only* be called with a copy or move of a local.\n-    /// (It allows neither constants nor projections.)\n-    ///\n-    /// To avoid introducing any `noalias` requirements, it just takes a pointer.\n+    /// This intrinsic can *only* be called where the argument is a local without\n+    /// projections (`read_via_copy(p)`, not `read_via_copy(*p)`) so that it\n+    /// trivially obeys runtime-MIR rules about derefs in operands.\n     #[cfg(not(bootstrap))]\n     #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n     pub fn read_via_copy<T>(p: *const T) -> T;"}, {"sha": "5884a8ca308072bbf8dc5e008bba2723439119ac", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7c6ad89cfd937d741b9d256e950ec0de96a7142/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c6ad89cfd937d741b9d256e950ec0de96a7142/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=e7c6ad89cfd937d741b9d256e950ec0de96a7142", "patch": "@@ -1136,10 +1136,12 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn read<T>(src: *const T) -> T {\n     // It would be semantically correct to implement this via `copy_nonoverlapping`\n-    // and `MaybeUninit`, as was done before PR #109035.\n+    // and `MaybeUninit`, as was done before PR #109035. Calling `assume_init`\n+    // provides enough information to know that this is a typed operation.\n \n-    // However, it switched to intrinsic that lowers to `_0 = *src` in MIR in\n-    // order to address a few implementation issues:\n+    // However, as of March 2023 the compiler was not capable of taking advantage\n+    // of that information.  Thus the implementation here switched to an intrinsic,\n+    // which lowers to `_0 = *src` in MIR, to address a few issues:\n     //\n     // - Using `MaybeUninit::assume_init` after a `copy_nonoverlapping` was not\n     //   turning the untyped copy into a typed load. As such, the generated"}, {"sha": "e1e3272662c4bbc0ea3c9a2c45ecd8719e2b510c", "filename": "tests/codegen/ptr-read-metadata.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e7c6ad89cfd937d741b9d256e950ec0de96a7142/tests%2Fcodegen%2Fptr-read-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c6ad89cfd937d741b9d256e950ec0de96a7142/tests%2Fcodegen%2Fptr-read-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fptr-read-metadata.rs?ref=e7c6ad89cfd937d741b9d256e950ec0de96a7142", "patch": "@@ -0,0 +1,96 @@\n+// compile-flags: -O -Z merge-functions=disabled\n+// no-system-llvm\n+// ignore-debug (the extra assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+\n+// Ensure that various forms of reading pointers correctly annotate the `load`s\n+// with `!noundef` and `!range` metadata to enable extra optimization.\n+\n+use std::mem::MaybeUninit;\n+\n+// CHECK-LABEL: define noundef i8 @copy_byte(\n+#[no_mangle]\n+pub unsafe fn copy_byte(p: *const u8) -> u8 {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    *p\n+}\n+\n+// CHECK-LABEL: define noundef i8 @read_byte(\n+#[no_mangle]\n+pub unsafe fn read_byte(p: *const u8) -> u8 {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define i8 @read_byte_maybe_uninit(\n+#[no_mangle]\n+pub unsafe fn read_byte_maybe_uninit(p: *const MaybeUninit<u8>) -> MaybeUninit<u8> {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-NOT: noundef\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define noundef i8 @read_byte_assume_init(\n+#[no_mangle]\n+pub unsafe fn read_byte_assume_init(p: &MaybeUninit<u8>) -> u8 {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    p.assume_init_read()\n+}\n+\n+// CHECK-LABEL: define noundef i32 @copy_char(\n+#[no_mangle]\n+pub unsafe fn copy_char(p: *const char) -> char {\n+    // CHECK-NOT: load\n+    // CHECK: load i32, ptr %p\n+    // CHECK-SAME: !range ![[RANGE:[0-9]+]]\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    *p\n+}\n+\n+// CHECK-LABEL: define noundef i32 @read_char(\n+#[no_mangle]\n+pub unsafe fn read_char(p: *const char) -> char {\n+    // CHECK-NOT: load\n+    // CHECK: load i32, ptr %p\n+    // CHECK-SAME: !range ![[RANGE]]\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define i32 @read_char_maybe_uninit(\n+#[no_mangle]\n+pub unsafe fn read_char_maybe_uninit(p: *const MaybeUninit<char>) -> MaybeUninit<char> {\n+    // CHECK-NOT: load\n+    // CHECK: load i32, ptr %p\n+    // CHECK-NOT: range\n+    // CHECK-NOT: noundef\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define noundef i32 @read_char_assume_init(\n+#[no_mangle]\n+pub unsafe fn read_char_assume_init(p: &MaybeUninit<char>) -> char {\n+    // CHECK-NOT: load\n+    // CHECK: load i32, ptr %p\n+    // CHECK-SAME: !range ![[RANGE]]\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    p.assume_init_read()\n+}\n+\n+// CHECK: ![[RANGE]] = !{i32 0, i32 1114112}"}, {"sha": "03386921c43e35e8b20a96913f5bd0d753913006", "filename": "tests/codegen/read-noundef-metadata.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/87696fd5a1a1b7cd75cd9a66896deae0ab56cfb5/tests%2Fcodegen%2Fread-noundef-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87696fd5a1a1b7cd75cd9a66896deae0ab56cfb5/tests%2Fcodegen%2Fread-noundef-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fread-noundef-metadata.rs?ref=87696fd5a1a1b7cd75cd9a66896deae0ab56cfb5", "patch": "@@ -1,51 +0,0 @@\n-// compile-flags: -O -Z merge-functions=disabled\n-// no-system-llvm\n-// ignore-debug (the extra assertions get in the way)\n-\n-#![crate_type = \"lib\"]\n-\n-// Ensure that various forms of reading pointers correctly annotate the `load`s\n-// with `!noundef` metadata to enable extra optimization.  The functions return\n-// `MaybeUninit` to keep it from being inferred from the function type.\n-\n-use std::mem::MaybeUninit;\n-\n-// CHECK-LABEL: define i8 @copy_byte(\n-#[no_mangle]\n-pub unsafe fn copy_byte(p: *const u8) -> MaybeUninit<u8> {\n-    // CHECK-NOT: load\n-    // CHECK: load i8, ptr %p, align 1\n-    // CHECK-SAME: !noundef !\n-    // CHECK-NOT: load\n-    MaybeUninit::new(*p)\n-}\n-\n-// CHECK-LABEL: define i8 @read_byte(\n-#[no_mangle]\n-pub unsafe fn read_byte(p: *const u8) -> MaybeUninit<u8> {\n-    // CHECK-NOT: load\n-    // CHECK: load i8, ptr %p, align 1\n-    // CHECK-SAME: !noundef !\n-    // CHECK-NOT: load\n-    MaybeUninit::new(p.read())\n-}\n-\n-// CHECK-LABEL: define i8 @read_byte_maybe_uninit(\n-#[no_mangle]\n-pub unsafe fn read_byte_maybe_uninit(p: *const MaybeUninit<u8>) -> MaybeUninit<u8> {\n-    // CHECK-NOT: load\n-    // CHECK: load i8, ptr %p, align 1\n-    // CHECK-NOT: noundef\n-    // CHECK-NOT: load\n-    p.read()\n-}\n-\n-// CHECK-LABEL: define i8 @read_byte_assume_init(\n-#[no_mangle]\n-pub unsafe fn read_byte_assume_init(p: &MaybeUninit<u8>) -> MaybeUninit<u8> {\n-    // CHECK-NOT: load\n-    // CHECK: load i8, ptr %p, align 1\n-    // CHECK-SAME: !noundef !\n-    // CHECK-NOT: load\n-    MaybeUninit::new(p.assume_init_read())\n-}"}, {"sha": "610c67d2fecd67b45a5194059756bb2cb9594777", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7c6ad89cfd937d741b9d256e950ec0de96a7142/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e7c6ad89cfd937d741b9d256e950ec0de96a7142/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff?ref=e7c6ad89cfd937d741b9d256e950ec0de96a7142", "patch": "@@ -15,7 +15,6 @@\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:90:14: 90:45\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Never) -> Never {read_via_copy::<Never>}, val: Value(<ZST>) }\n-+         _0 = (*_2);                      // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n +         unreachable;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n       }\n   }"}]}