{"sha": "118b975c805533bab31f8155ad0af29b3635d3fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOGI5NzVjODA1NTMzYmFiMzFmODE1NWFkMGFmMjliMzYzNWQzZmM=", "commit": {"author": {"name": "Nathan Kleyn", "email": "nathan@nathankleyn.com", "date": "2016-03-08T23:27:24Z"}, "committer": {"name": "Nathan Kleyn", "email": "nathan@nathankleyn.com", "date": "2016-03-08T23:27:24Z"}, "message": "Add missing documentation examples for BinaryHeap.\n\nAs part of the ongoing effort to document all methods with examples,\nthis commit adds the missing examples for the `BinaryHeap` collection\ntype.\n\nThis is part of issue #29348.", "tree": {"sha": "2f1f82bf8339497c7ea0fdcbd36b71452dfddee1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f1f82bf8339497c7ea0fdcbd36b71452dfddee1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/118b975c805533bab31f8155ad0af29b3635d3fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/118b975c805533bab31f8155ad0af29b3635d3fc", "html_url": "https://github.com/rust-lang/rust/commit/118b975c805533bab31f8155ad0af29b3635d3fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/118b975c805533bab31f8155ad0af29b3635d3fc/comments", "author": {"login": "nathankleyn", "id": 220826, "node_id": "MDQ6VXNlcjIyMDgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/220826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nathankleyn", "html_url": "https://github.com/nathankleyn", "followers_url": "https://api.github.com/users/nathankleyn/followers", "following_url": "https://api.github.com/users/nathankleyn/following{/other_user}", "gists_url": "https://api.github.com/users/nathankleyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/nathankleyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nathankleyn/subscriptions", "organizations_url": "https://api.github.com/users/nathankleyn/orgs", "repos_url": "https://api.github.com/users/nathankleyn/repos", "events_url": "https://api.github.com/users/nathankleyn/events{/privacy}", "received_events_url": "https://api.github.com/users/nathankleyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nathankleyn", "id": 220826, "node_id": "MDQ6VXNlcjIyMDgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/220826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nathankleyn", "html_url": "https://github.com/nathankleyn", "followers_url": "https://api.github.com/users/nathankleyn/followers", "following_url": "https://api.github.com/users/nathankleyn/following{/other_user}", "gists_url": "https://api.github.com/users/nathankleyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/nathankleyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nathankleyn/subscriptions", "organizations_url": "https://api.github.com/users/nathankleyn/orgs", "repos_url": "https://api.github.com/users/nathankleyn/repos", "events_url": "https://api.github.com/users/nathankleyn/events{/privacy}", "received_events_url": "https://api.github.com/users/nathankleyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f0479b2a5fc16814b68efe9e87dddf231b8941d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f0479b2a5fc16814b68efe9e87dddf231b8941d", "html_url": "https://github.com/rust-lang/rust/commit/8f0479b2a5fc16814b68efe9e87dddf231b8941d"}], "stats": {"total": 106, "additions": 106, "deletions": 0}, "files": [{"sha": "efd56bdb264f27a6a32fb279e4a72d1a6e29f18a", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/118b975c805533bab31f8155ad0af29b3635d3fc/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/118b975c805533bab31f8155ad0af29b3635d3fc/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=118b975c805533bab31f8155ad0af29b3635d3fc", "patch": "@@ -167,6 +167,49 @@ use vec::{self, Vec};\n /// item's ordering relative to any other item, as determined by the `Ord`\n /// trait, changes while it is in the heap. This is normally only possible\n /// through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::collections::BinaryHeap;\n+///\n+/// // type inference lets us omit an explicit type signature (which\n+/// // would be `BinaryHeap<i32>` in this example).\n+/// let mut heap = BinaryHeap::new();\n+///\n+/// // We can use peek to look at the next item in the heap. In this case,\n+/// // there's no items in there yet so we get None.\n+/// assert_eq!(heap.peek(), None);\n+///\n+/// // Let's add some scores...\n+/// heap.push(1);\n+/// heap.push(5);\n+/// heap.push(2);\n+///\n+/// // Now peek shows the most important item in the heap.\n+/// assert_eq!(heap.peek(), Some(&5));\n+///\n+/// // We can check the length of a heap.\n+/// assert_eq!(heap.len(), 3);\n+///\n+/// // We can iterate over the items in the heap, although they are returned in\n+/// // a random order.\n+/// for x in heap.iter() {\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// // If we instead pop these scores, they should come back in order.\n+/// assert_eq!(heap.pop(), Some(5));\n+/// assert_eq!(heap.pop(), Some(2));\n+/// assert_eq!(heap.pop(), Some(1));\n+/// assert_eq!(heap.pop(), None);\n+///\n+/// // We can clear the heap of any remaining items.\n+/// heap.clear();\n+///\n+/// // The heap should now be empty.\n+/// assert!(heap.is_empty())\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BinaryHeap<T> {\n     data: Vec<T>,\n@@ -331,6 +374,17 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Discards as much additional capacity as possible.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n+    ///\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.shrink_to_fit();\n+    /// assert!(heap.capacity() == 0);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.data.shrink_to_fit();\n@@ -571,12 +625,36 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Returns the length of the binary heap.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::from(vec![1, 3]);\n+    ///\n+    /// assert_eq!(heap.len(), 2);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n         self.data.len()\n     }\n \n     /// Checks if the binary heap is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::new();\n+    ///\n+    /// assert!(heap.is_empty());\n+    ///\n+    /// heap.push(3);\n+    /// heap.push(5);\n+    /// heap.push(1);\n+    ///\n+    /// assert!(!heap.is_empty());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.len() == 0\n@@ -585,13 +663,41 @@ impl<T: Ord> BinaryHeap<T> {\n     /// Clears the binary heap, returning an iterator over the removed elements.\n     ///\n     /// The elements are removed in arbitrary order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::from(vec![1, 3]);\n+    ///\n+    /// assert!(!heap.is_empty());\n+    ///\n+    /// for x in heap.drain() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// assert!(heap.is_empty());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain { iter: self.data.drain(..) }\n     }\n \n     /// Drops all items from the binary heap.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::from(vec![1, 3]);\n+    ///\n+    /// assert!(!heap.is_empty());\n+    ///\n+    /// heap.clear();\n+    ///\n+    /// assert!(heap.is_empty());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.drain();"}]}