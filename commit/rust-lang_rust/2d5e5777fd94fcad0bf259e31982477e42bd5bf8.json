{"sha": "2d5e5777fd94fcad0bf259e31982477e42bd5bf8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNWU1Nzc3ZmQ5NGZjYWQwYmYyNTllMzE5ODI0NzdlNDJiZDViZjg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-05-08T22:31:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-05-12T21:50:36Z"}, "message": "rustc_trans: Abstract linker support behind a trait\n\nThis trait will be used to correctly build a command line for link.exe with MSVC\nand may perhaps one day be used to generate a command line for `lld`, but this\ncommit currently just refactors the bindings used to call `ld`.", "tree": {"sha": "bedd0a77eb551a7400728e5320e15c75b0182311", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bedd0a77eb551a7400728e5320e15c75b0182311"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d5e5777fd94fcad0bf259e31982477e42bd5bf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d5e5777fd94fcad0bf259e31982477e42bd5bf8", "html_url": "https://github.com/rust-lang/rust/commit/2d5e5777fd94fcad0bf259e31982477e42bd5bf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d5e5777fd94fcad0bf259e31982477e42bd5bf8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cc025d83c5e3e54130dff08987982a0926e4cfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cc025d83c5e3e54130dff08987982a0926e4cfa", "html_url": "https://github.com/rust-lang/rust/commit/4cc025d83c5e3e54130dff08987982a0926e4cfa"}], "stats": {"total": 379, "additions": 237, "deletions": 142}, "files": [{"sha": "e748f8b44cbed8ea795f1f99a72cf2112f45d2cc", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 61, "deletions": 142, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/2d5e5777fd94fcad0bf259e31982477e42bd5bf8/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5e5777fd94fcad0bf259e31982477e42bd5bf8/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=2d5e5777fd94fcad0bf259e31982477e42bd5bf8", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use super::archive::{Archive, ArchiveBuilder, ArchiveConfig, METADATA_FILENAME};\n-use super::archive;\n-use super::rpath;\n+use super::linker::{Linker, GnuLinker};\n use super::rpath::RPathConfig;\n+use super::rpath;\n use super::svh::Svh;\n use session::config;\n use session::config::NoDebugInfo;\n@@ -29,7 +29,6 @@ use util::sha2::{Digest, Sha256};\n use util::fs::fix_windows_verbatim_for_gcc;\n use rustc_back::tempdir::TempDir;\n \n-use std::ffi::OsString;\n use std::fs::{self, PathExt};\n use std::io::{self, Read, Write};\n use std::mem;\n@@ -801,10 +800,13 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         cmd.arg(root.join(obj));\n     }\n \n-    link_args(&mut cmd, sess, dylib, tmpdir.path(),\n-              trans, obj_filename, out_filename);\n-    if !sess.target.target.options.no_compiler_rt {\n-        cmd.arg(\"-lcompiler-rt\");\n+    {\n+        let mut linker = GnuLinker { cmd: &mut cmd, sess: &sess };\n+        link_args(&mut linker, sess, dylib, tmpdir.path(),\n+                  trans, obj_filename, out_filename);\n+        if !sess.target.target.options.no_compiler_rt {\n+            linker.link_staticlib(\"compiler-rt\");\n+        }\n     }\n     for obj in &sess.target.target.options.post_link_objects {\n         cmd.arg(root.join(obj));\n@@ -858,7 +860,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     }\n }\n \n-fn link_args(cmd: &mut Command,\n+fn link_args(cmd: &mut Linker,\n              sess: &Session,\n              dylib: bool,\n              tmpdir: &Path,\n@@ -873,10 +875,10 @@ fn link_args(cmd: &mut Command,\n     // target descriptor\n     let t = &sess.target.target;\n \n-    cmd.arg(\"-L\").arg(&fix_windows_verbatim_for_gcc(&lib_path));\n-\n-    cmd.arg(\"-o\").arg(out_filename).arg(obj_filename);\n+    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n \n+    cmd.output_filename(out_filename);\n+    cmd.add_object(obj_filename);\n \n     // Stack growth requires statically linking a __morestack function. Note\n     // that this is listed *before* all other libraries. Due to the usage of the\n@@ -895,89 +897,44 @@ fn link_args(cmd: &mut Command,\n     // will include the __morestack symbol 100% of the time, always resolving\n     // references to it even if the object above didn't use it.\n     if t.options.morestack {\n-        if t.options.is_like_osx {\n-            let morestack = lib_path.join(\"libmorestack.a\");\n-\n-            let mut v = OsString::from(\"-Wl,-force_load,\");\n-            v.push(&morestack);\n-            cmd.arg(&v);\n-        } else {\n-            cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n-        }\n+        cmd.link_whole_staticlib(\"morestack\", &[lib_path]);\n     }\n \n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n     if dylib {\n-        cmd.arg(&obj_filename.with_extension(\"metadata.o\"));\n+        cmd.add_object(&obj_filename.with_extension(\"metadata.o\"));\n     }\n \n-    if t.options.is_like_osx {\n-        // The dead_strip option to the linker specifies that functions and data\n-        // unreachable by the entry point will be removed. This is quite useful\n-        // with Rust's compilation model of compiling libraries at a time into\n-        // one object file. For example, this brings hello world from 1.7MB to\n-        // 458K.\n-        //\n-        // Note that this is done for both executables and dynamic libraries. We\n-        // won't get much benefit from dylibs because LLVM will have already\n-        // stripped away as much as it could. This has not been seen to impact\n-        // link times negatively.\n-        //\n-        // -dead_strip can't be part of the pre_link_args because it's also used\n-        // for partial linking when using multiple codegen units (-r). So we\n-        // insert it here.\n-        cmd.arg(\"-Wl,-dead_strip\");\n-    }\n-\n-    // If we're building a dylib, we don't use --gc-sections because LLVM has\n-    // already done the best it can do, and we also don't want to eliminate the\n-    // metadata. If we're building an executable, however, --gc-sections drops\n-    // the size of hello world from 1.8MB to 597K, a 67% reduction.\n-    if !dylib && !t.options.is_like_osx {\n-        cmd.arg(\"-Wl,--gc-sections\");\n-    }\n+    // Try to strip as much out of the generated object by removing unused\n+    // sections if possible. See more comments in linker.rs\n+    cmd.gc_sections(dylib);\n \n     let used_link_args = sess.cstore.get_used_link_args().borrow();\n \n-    if t.options.position_independent_executables {\n+    if !dylib && t.options.position_independent_executables {\n         let empty_vec = Vec::new();\n         let empty_str = String::new();\n         let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n         let mut args = args.iter().chain(used_link_args.iter());\n-        if !dylib\n-            && (t.options.relocation_model == \"pic\"\n-                || *sess.opts.cg.relocation_model.as_ref()\n-                   .unwrap_or(&empty_str) == \"pic\")\n+        let relocation_model = sess.opts.cg.relocation_model.as_ref()\n+                                   .unwrap_or(&empty_str);\n+        if (t.options.relocation_model == \"pic\" || *relocation_model == \"pic\")\n             && !args.any(|x| *x == \"-static\") {\n-            cmd.arg(\"-pie\");\n+            cmd.position_independent_executable();\n         }\n     }\n \n-    if t.options.linker_is_gnu {\n-        // GNU-style linkers support optimization with -O. GNU ld doesn't need a\n-        // numeric argument, but other linkers do.\n-        if sess.opts.optimize == config::Default ||\n-           sess.opts.optimize == config::Aggressive {\n-            cmd.arg(\"-Wl,-O1\");\n-        }\n-    }\n+    // Pass optimization flags down to the linker.\n+    cmd.optimize();\n \n     // We want to prevent the compiler from accidentally leaking in any system\n     // libraries, so we explicitly ask gcc to not link to any libraries by\n     // default. Note that this does not happen for windows because windows pulls\n     // in some large number of libraries and I couldn't quite figure out which\n     // subset we wanted.\n-    if !t.options.is_like_windows {\n-        cmd.arg(\"-nodefaultlibs\");\n-    }\n-\n-    // Mark all dynamic libraries and executables as compatible with ASLR\n-    // FIXME #17098: ASLR breaks gdb\n-    if t.options.is_like_windows && sess.opts.debuginfo == NoDebugInfo {\n-        // cmd.arg(\"-Wl,--dynamicbase\");\n-    }\n+    cmd.no_default_libraries();\n \n     // Take careful note of the ordering of the arguments we pass to the linker\n     // here. Linkers will assume that things on the left depend on things to the\n@@ -1019,18 +976,7 @@ fn link_args(cmd: &mut Command,\n     // # Telling the linker what we're doing\n \n     if dylib {\n-        // On mac we need to tell the linker to let this library be rpathed\n-        if sess.target.target.options.is_like_osx {\n-            cmd.args(&[\"-dynamiclib\", \"-Wl,-dylib\"]);\n-\n-            if sess.opts.cg.rpath {\n-                let mut v = OsString::from(\"-Wl,-install_name,@rpath/\");\n-                v.push(out_filename.file_name().unwrap());\n-                cmd.arg(&v);\n-            }\n-        } else {\n-            cmd.arg(\"-shared\");\n-        }\n+        cmd.build_dylib(out_filename);\n     }\n \n     // FIXME (#2397): At some point we want to rpath our guesses as to\n@@ -1059,9 +1005,10 @@ fn link_args(cmd: &mut Command,\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n-    let empty = Vec::new();\n-    cmd.args(&sess.opts.cg.link_args.as_ref().unwrap_or(&empty));\n-    cmd.args(&used_link_args[..]);\n+    if let Some(ref args) = sess.opts.cg.link_args {\n+        cmd.args(args);\n+    }\n+    cmd.args(&used_link_args);\n }\n \n // # Native library linking\n@@ -1075,21 +1022,15 @@ fn link_args(cmd: &mut Command,\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n+fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n     sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, k| {\n         match k {\n-            PathKind::Framework => { cmd.arg(\"-F\").arg(path); }\n-            _ => { cmd.arg(\"-L\").arg(&fix_windows_verbatim_for_gcc(path)); }\n+            PathKind::Framework => { cmd.framework_path(path); }\n+            _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(path)); }\n         }\n         FileDoesntMatch\n     });\n \n-    // Some platforms take hints about whether a library is static or dynamic.\n-    // For those that support this, we ensure we pass the option if the library\n-    // was flagged \"static\" (most defaults are dynamic) to ensure that if\n-    // libfoo.a and libfoo.so both exist that the right one is chosen.\n-    let takes_hints = !sess.target.target.options.is_like_osx;\n-\n     let libs = sess.cstore.get_used_libraries();\n     let libs = libs.borrow();\n \n@@ -1100,46 +1041,29 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n         kind != cstore::NativeStatic\n     });\n \n-    // Platforms that take hints generally also support the --whole-archive\n-    // flag. We need to pass this flag when linking static native libraries to\n-    // ensure the entire library is included.\n-    //\n-    // For more details see #15460, but the gist is that the linker will strip\n-    // away any unused objects in the archive if we don't otherwise explicitly\n-    // reference them. This can occur for libraries which are just providing\n-    // bindings, libraries with generic functions, etc.\n-    if takes_hints {\n-        cmd.arg(\"-Wl,--whole-archive\").arg(\"-Wl,-Bstatic\");\n-    }\n+    // Some platforms take hints about whether a library is static or dynamic.\n+    // For those that support this, we ensure we pass the option if the library\n+    // was flagged \"static\" (most defaults are dynamic) to ensure that if\n+    // libfoo.a and libfoo.so both exist that the right one is chosen.\n+    cmd.hint_static();\n+\n     let search_path = archive_search_paths(sess);\n     for l in staticlibs {\n-        if takes_hints {\n-            cmd.arg(&format!(\"-l{}\", l));\n-        } else {\n-            // -force_load is the OSX equivalent of --whole-archive, but it\n-            // involves passing the full path to the library to link.\n-            let lib = archive::find_library(&l[..],\n-                                            &sess.target.target.options.staticlib_prefix,\n-                                            &sess.target.target.options.staticlib_suffix,\n-                                            &search_path[..],\n-                                            &sess.diagnostic().handler);\n-            let mut v = OsString::from(\"-Wl,-force_load,\");\n-            v.push(&lib);\n-            cmd.arg(&v);\n-        }\n-    }\n-    if takes_hints {\n-        cmd.arg(\"-Wl,--no-whole-archive\").arg(\"-Wl,-Bdynamic\");\n+        // Here we explicitly ask that the entire archive is included into the\n+        // result artifact. For more details see #15460, but the gist is that\n+        // the linker will strip away any unused objects in the archive if we\n+        // don't otherwise explicitly reference them. This can occur for\n+        // libraries which are just providing bindings, libraries with generic\n+        // functions, etc.\n+        cmd.link_whole_staticlib(l, &search_path);\n     }\n \n+    cmd.hint_dynamic();\n+\n     for &(ref l, kind) in others {\n         match kind {\n-            cstore::NativeUnknown => {\n-                cmd.arg(&format!(\"-l{}\", l));\n-            }\n-            cstore::NativeFramework => {\n-                cmd.arg(\"-framework\").arg(&l[..]);\n-            }\n+            cstore::NativeUnknown => cmd.link_dylib(l),\n+            cstore::NativeFramework => cmd.link_framework(l),\n             cstore::NativeStatic => unreachable!(),\n         }\n     }\n@@ -1150,7 +1074,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n+fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n                             dylib: bool, tmpdir: &Path,\n                             trans: &CrateTranslation) {\n     // All of the heavy lifting has previously been accomplished by the\n@@ -1201,7 +1125,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n-    fn add_static_crate(cmd: &mut Command, sess: &Session, tmpdir: &Path,\n+    fn add_static_crate(cmd: &mut Linker, sess: &Session, tmpdir: &Path,\n                         cratepath: &Path) {\n         // When performing LTO on an executable output, all of the\n         // bytecode from the upstream libraries has already been\n@@ -1263,27 +1187,27 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                 archive.remove_file(&format!(\"{}.o\", name));\n                 let files = archive.files();\n                 if files.iter().any(|s| s.ends_with(\".o\")) {\n-                    cmd.arg(&dst);\n+                    cmd.link_rlib(&dst);\n                 }\n             });\n         } else {\n-            cmd.arg(&fix_windows_verbatim_for_gcc(cratepath));\n+            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n         }\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(cmd: &mut Command, sess: &Session, cratepath: &Path) {\n+    fn add_dynamic_crate(cmd: &mut Linker, sess: &Session, cratepath: &Path) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n         assert!(!sess.lto());\n \n         // Just need to tell the linker about where the library lives and\n         // what its name is\n         if let Some(dir) = cratepath.parent() {\n-            cmd.arg(\"-L\").arg(&fix_windows_verbatim_for_gcc(dir));\n+            cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n         }\n         let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n-        cmd.arg(&format!(\"-l{}\", unlib(&sess.target, filestem)));\n+        cmd.link_dylib(&unlib(&sess.target, filestem));\n     }\n }\n \n@@ -1305,7 +1229,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n+fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session) {\n     // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,\n     // for example, almost all native libraries depend on libc, so we have to\n@@ -1320,13 +1244,8 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n         let libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         for &(kind, ref lib) in &libs {\n             match kind {\n-                cstore::NativeUnknown => {\n-                    cmd.arg(&format!(\"-l{}\", *lib));\n-                }\n-                cstore::NativeFramework => {\n-                    cmd.arg(\"-framework\");\n-                    cmd.arg(&lib[..]);\n-                }\n+                cstore::NativeUnknown => cmd.link_dylib(lib),\n+                cstore::NativeFramework => cmd.link_framework(lib),\n                 cstore::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");\n                 }"}, {"sha": "da1ec29a41e71fa4f36f8242902875313bbe02c5", "filename": "src/librustc_trans/back/linker.rs", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/2d5e5777fd94fcad0bf259e31982477e42bd5bf8/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5e5777fd94fcad0bf259e31982477e42bd5bf8/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=2d5e5777fd94fcad0bf259e31982477e42bd5bf8", "patch": "@@ -0,0 +1,175 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ffi::OsString;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use rustc_back::archive;\n+use session::Session;\n+use session::config;\n+\n+/// Linker abstraction used by back::link to build up the command to invoke a\n+/// linker.\n+///\n+/// This trait is the total list of requirements needed by `back::link` and\n+/// represents the meaning of each option being passed down. This trait is then\n+/// used to dispatch on whether a GNU-like linker (generally `ld.exe`) or an\n+/// MSVC linker (e.g. `link.exe`) is being used.\n+pub trait Linker {\n+    fn link_dylib(&mut self, lib: &str);\n+    fn link_framework(&mut self, framework: &str);\n+    fn link_staticlib(&mut self, lib: &str);\n+    fn link_rlib(&mut self, lib: &Path);\n+    fn link_whole_staticlib(&mut self, lib: &str, search_path: &[PathBuf]);\n+    fn include_path(&mut self, path: &Path);\n+    fn framework_path(&mut self, path: &Path);\n+    fn output_filename(&mut self, path: &Path);\n+    fn add_object(&mut self, path: &Path);\n+    fn gc_sections(&mut self, is_dylib: bool);\n+    fn position_independent_executable(&mut self);\n+    fn optimize(&mut self);\n+    fn no_default_libraries(&mut self);\n+    fn build_dylib(&mut self, out_filename: &Path);\n+    fn args(&mut self, args: &[String]);\n+    fn hint_static(&mut self);\n+    fn hint_dynamic(&mut self);\n+    fn whole_archives(&mut self);\n+    fn no_whole_archives(&mut self);\n+}\n+\n+pub struct GnuLinker<'a> {\n+    pub cmd: &'a mut Command,\n+    pub sess: &'a Session,\n+}\n+\n+impl<'a> GnuLinker<'a> {\n+    fn takes_hints(&self) -> bool {\n+        !self.sess.target.target.options.is_like_osx\n+    }\n+}\n+\n+impl<'a> Linker for GnuLinker<'a> {\n+    fn link_dylib(&mut self, lib: &str) { self.cmd.arg(\"-l\").arg(lib); }\n+    fn link_staticlib(&mut self, lib: &str) { self.cmd.arg(\"-l\").arg(lib); }\n+    fn link_rlib(&mut self, lib: &Path) { self.cmd.arg(lib); }\n+    fn include_path(&mut self, path: &Path) { self.cmd.arg(\"-L\").arg(path); }\n+    fn framework_path(&mut self, path: &Path) { self.cmd.arg(\"-F\").arg(path); }\n+    fn output_filename(&mut self, path: &Path) { self.cmd.arg(\"-o\").arg(path); }\n+    fn add_object(&mut self, path: &Path) { self.cmd.arg(path); }\n+    fn position_independent_executable(&mut self) { self.cmd.arg(\"-pie\"); }\n+    fn args(&mut self, args: &[String]) { self.cmd.args(args); }\n+\n+    fn link_framework(&mut self, framework: &str) {\n+        self.cmd.arg(\"-framework\").arg(framework);\n+    }\n+\n+    fn link_whole_staticlib(&mut self, lib: &str, search_path: &[PathBuf]) {\n+        let target = &self.sess.target.target;\n+        if !target.options.is_like_osx {\n+            self.cmd.arg(\"-Wl,--whole-archive\")\n+                    .arg(\"-l\").arg(lib)\n+                    .arg(\"-Wl,--no-whole-archive\");\n+        } else {\n+            // -force_load is the OSX equivalent of --whole-archive, but it\n+            // involves passing the full path to the library to link.\n+            let mut v = OsString::from(\"-Wl,-force_load,\");\n+            v.push(&archive::find_library(lib,\n+                                          &target.options.staticlib_prefix,\n+                                          &target.options.staticlib_suffix,\n+                                          search_path,\n+                                          &self.sess.diagnostic().handler));\n+            self.cmd.arg(&v);\n+        }\n+    }\n+\n+    fn gc_sections(&mut self, is_dylib: bool) {\n+        // The dead_strip option to the linker specifies that functions and data\n+        // unreachable by the entry point will be removed. This is quite useful\n+        // with Rust's compilation model of compiling libraries at a time into\n+        // one object file. For example, this brings hello world from 1.7MB to\n+        // 458K.\n+        //\n+        // Note that this is done for both executables and dynamic libraries. We\n+        // won't get much benefit from dylibs because LLVM will have already\n+        // stripped away as much as it could. This has not been seen to impact\n+        // link times negatively.\n+        //\n+        // -dead_strip can't be part of the pre_link_args because it's also used\n+        // for partial linking when using multiple codegen units (-r).  So we\n+        // insert it here.\n+        if self.sess.target.target.options.is_like_osx {\n+            self.cmd.arg(\"-Wl,-dead_strip\");\n+\n+        // If we're building a dylib, we don't use --gc-sections because LLVM\n+        // has already done the best it can do, and we also don't want to\n+        // eliminate the metadata. If we're building an executable, however,\n+        // --gc-sections drops the size of hello world from 1.8MB to 597K, a 67%\n+        // reduction.\n+        } else if !is_dylib {\n+            self.cmd.arg(\"-Wl,--gc-sections\");\n+        }\n+    }\n+\n+    fn optimize(&mut self) {\n+        if !self.sess.target.target.options.linker_is_gnu { return }\n+\n+        // GNU-style linkers support optimization with -O. GNU ld doesn't\n+        // need a numeric argument, but other linkers do.\n+        if self.sess.opts.optimize == config::Default ||\n+           self.sess.opts.optimize == config::Aggressive {\n+            self.cmd.arg(\"-Wl,-O1\");\n+        }\n+    }\n+\n+    fn no_default_libraries(&mut self) {\n+        // Unfortunately right now passing -nodefaultlibs to gcc on windows\n+        // doesn't work so hot (in terms of native dependencies). This if\n+        // statement should hopefully be removed one day though!\n+        if !self.sess.target.target.options.is_like_windows {\n+            self.cmd.arg(\"-nodefaultlibs\");\n+        }\n+    }\n+\n+    fn build_dylib(&mut self, out_filename: &Path) {\n+        // On mac we need to tell the linker to let this library be rpathed\n+        if self.sess.target.target.options.is_like_osx {\n+            self.cmd.args(&[\"-dynamiclib\", \"-Wl,-dylib\"]);\n+\n+            if self.sess.opts.cg.rpath {\n+                let mut v = OsString::from(\"-Wl,-install_name,@rpath/\");\n+                v.push(out_filename.file_name().unwrap());\n+                self.cmd.arg(&v);\n+            }\n+        } else {\n+            self.cmd.arg(\"-shared\");\n+        }\n+    }\n+\n+    fn whole_archives(&mut self) {\n+        if !self.takes_hints() { return }\n+        self.cmd.arg(\"-Wl,--whole-archive\");\n+    }\n+\n+    fn no_whole_archives(&mut self) {\n+        if !self.takes_hints() { return }\n+        self.cmd.arg(\"-Wl,--no-whole-archive\");\n+    }\n+\n+    fn hint_static(&mut self) {\n+        if !self.takes_hints() { return }\n+        self.cmd.arg(\"-Wl,-Bstatic\");\n+    }\n+\n+    fn hint_dynamic(&mut self) {\n+        if !self.takes_hints() { return }\n+        self.cmd.arg(\"-Wl,-Bdynamic\");\n+    }\n+}"}, {"sha": "2a823c69276f67f32c23cf252f74d1c41b351111", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d5e5777fd94fcad0bf259e31982477e42bd5bf8/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5e5777fd94fcad0bf259e31982477e42bd5bf8/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=2d5e5777fd94fcad0bf259e31982477e42bd5bf8", "patch": "@@ -74,6 +74,7 @@ pub mod back {\n     pub use rustc_back::x86;\n     pub use rustc_back::x86_64;\n \n+    pub mod linker;\n     pub mod link;\n     pub mod lto;\n     pub mod write;"}]}