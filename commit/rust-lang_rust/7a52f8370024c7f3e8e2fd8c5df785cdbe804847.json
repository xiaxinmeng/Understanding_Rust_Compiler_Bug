{"sha": "7a52f8370024c7f3e8e2fd8c5df785cdbe804847", "node_id": "C_kwDOAAsO6NoAKDdhNTJmODM3MDAyNGM3ZjNlOGUyZmQ4YzVkZjc4NWNkYmU4MDQ4NDc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-15T12:18:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-15T12:18:46Z"}, "message": "Merge #11294\n\n11294: internal: Move format specifier lexing from syntax to ide_db r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "f420eafd586df982c5dacc45d6e1cdf323a425f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f420eafd586df982c5dacc45d6e1cdf323a425f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a52f8370024c7f3e8e2fd8c5df785cdbe804847", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh4rumCRBK7hj4Ov3rIwAAeGkIABhB+w+hec+chLKmY+wQOBha\n8mP1H6+KlJvb7UKM4IMl8KmlUjJEWr+oJ3ZCwh6opsSFl/9G8W5qVroxN3rExrH/\nfCwFcq7Q/VVYmmSMd9RwzVcM+qSsyPY3UzZZ9iLgTWpnPD94ugMAKOpdNH/bLP3b\nvMt3WiEM5lQAYcbRAxSA3anFunqHrLd+XqfrNcu7pf1qrglQacQTGqmCOVN8vuij\nn4bI1uzv9ricOOuQJF6HULvha/R/qfYa4dS5EAfD70/i06DQiogU/wnEuxB+/V5u\nZzQsIG2+3/0ZCRp03uCMBJJRLdkaml/3Hs4TupLf5pv2VA9GtzXexnWvyxQPq3g=\n=r9A5\n-----END PGP SIGNATURE-----\n", "payload": "tree f420eafd586df982c5dacc45d6e1cdf323a425f1\nparent 4c34909308e9bbf5d35882daaf0f5fb556ee7ac4\nparent 91279db2b4dff5cc77a9f34a2212e93490676c46\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1642249126 +0000\ncommitter GitHub <noreply@github.com> 1642249126 +0000\n\nMerge #11294\n\n11294: internal: Move format specifier lexing from syntax to ide_db r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a52f8370024c7f3e8e2fd8c5df785cdbe804847", "html_url": "https://github.com/rust-lang/rust/commit/7a52f8370024c7f3e8e2fd8c5df785cdbe804847", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a52f8370024c7f3e8e2fd8c5df785cdbe804847/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c34909308e9bbf5d35882daaf0f5fb556ee7ac4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c34909308e9bbf5d35882daaf0f5fb556ee7ac4", "html_url": "https://github.com/rust-lang/rust/commit/4c34909308e9bbf5d35882daaf0f5fb556ee7ac4"}, {"sha": "91279db2b4dff5cc77a9f34a2212e93490676c46", "url": "https://api.github.com/repos/rust-lang/rust/commits/91279db2b4dff5cc77a9f34a2212e93490676c46", "html_url": "https://github.com/rust-lang/rust/commit/91279db2b4dff5cc77a9f34a2212e93490676c46"}], "stats": {"total": 616, "additions": 301, "deletions": 315}, "files": [{"sha": "f09f291e96abaed394a289f705a2fa7d15839193", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7a52f8370024c7f3e8e2fd8c5df785cdbe804847/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a52f8370024c7f3e8e2fd8c5df785cdbe804847/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=7a52f8370024c7f3e8e2fd8c5df785cdbe804847", "patch": "@@ -16,7 +16,7 @@ use hir::{InFile, Name, Semantics};\n use ide_db::RootDatabase;\n use rustc_hash::FxHashMap;\n use syntax::{\n-    ast::{self, HasFormatSpecifier},\n+    ast::{self, IsString},\n     AstNode, AstToken, NodeOrToken,\n     SyntaxKind::*,\n     SyntaxNode, TextRange, WalkEvent, T,\n@@ -336,17 +336,19 @@ fn traverse(\n                 }\n                 highlight_format_string(hl, &string, &expanded_string, range);\n                 // Highlight escape sequences\n-                if let Some(char_ranges) = string.char_ranges() {\n-                    for (piece_range, _) in char_ranges.iter().filter(|(_, char)| char.is_ok()) {\n-                        if string.text()[piece_range.start().into()..].starts_with('\\\\') {\n-                            hl.add(HlRange {\n-                                range: piece_range + range.start(),\n-                                highlight: HlTag::EscapeSequence.into(),\n-                                binding_hash: None,\n-                            });\n-                        }\n+                string.escaped_char_ranges(&mut |piece_range, char| {\n+                    if char.is_err() {\n+                        return;\n                     }\n-                }\n+\n+                    if string.text()[piece_range.start().into()..].starts_with('\\\\') {\n+                        hl.add(HlRange {\n+                            range: piece_range + range.start(),\n+                            highlight: HlTag::EscapeSequence.into(),\n+                            binding_hash: None,\n+                        });\n+                    }\n+                });\n             }\n         }\n "}, {"sha": "c74b9f56db62ee961c69a3af3d461281d95d68cc", "filename": "crates/ide/src/syntax_highlighting/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a52f8370024c7f3e8e2fd8c5df785cdbe804847/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a52f8370024c7f3e8e2fd8c5df785cdbe804847/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs?ref=7a52f8370024c7f3e8e2fd8c5df785cdbe804847", "patch": "@@ -1,9 +1,9 @@\n //! Syntax highlighting for format macro strings.\n-use ide_db::{helpers::format_string::is_format_string, SymbolKind};\n-use syntax::{\n-    ast::{self, FormatSpecifier, HasFormatSpecifier},\n-    TextRange,\n+use ide_db::{\n+    helpers::format_string::{is_format_string, lex_format_specifiers, FormatSpecifier},\n+    SymbolKind,\n };\n+use syntax::{ast, TextRange};\n \n use crate::{syntax_highlighting::highlights::Highlights, HlRange, HlTag};\n \n@@ -17,7 +17,7 @@ pub(super) fn highlight_format_string(\n         return;\n     }\n \n-    string.lex_format_specifier(|piece_range, kind| {\n+    lex_format_specifiers(string, &mut |piece_range, kind| {\n         if let Some(highlight) = highlight_format_specifier(kind) {\n             stack.add(HlRange {\n                 range: piece_range + range.start(),"}, {"sha": "29f61a95e745a6f4cc8327205b94d32279d1e3bf", "filename": "crates/ide_db/src/helpers/format_string.rs", "status": "modified", "additions": 263, "deletions": 2, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/7a52f8370024c7f3e8e2fd8c5df785cdbe804847/crates%2Fide_db%2Fsrc%2Fhelpers%2Fformat_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a52f8370024c7f3e8e2fd8c5df785cdbe804847/crates%2Fide_db%2Fsrc%2Fhelpers%2Fformat_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fformat_string.rs?ref=7a52f8370024c7f3e8e2fd8c5df785cdbe804847", "patch": "@@ -1,5 +1,8 @@\n //! Tools to work with format string literals for the `format_args!` family of macros.\n-use syntax::{ast, AstNode, AstToken};\n+use syntax::{\n+    ast::{self, IsString},\n+    AstNode, AstToken, TextRange,\n+};\n \n pub fn is_format_string(string: &ast::String) -> bool {\n     // Check if `string` is a format string argument of a macro invocation.\n@@ -10,7 +13,7 @@ pub fn is_format_string(string: &ast::String) -> bool {\n     //\n     // This setup lets us correctly highlight the components of `concat!(\"{}\", \"bla\")` format\n     // strings. It still fails for `concat!(\"{\", \"}\")`, but that is rare.\n-\n+    format!(\"{string} {bar}\", bar = string);\n     (|| {\n         let macro_call = string.syntax().ancestors().find_map(ast::MacroCall::cast)?;\n         let name = macro_call.path()?.segment()?.name_ref()?;\n@@ -29,3 +32,261 @@ pub fn is_format_string(string: &ast::String) -> bool {\n     })()\n     .is_some()\n }\n+\n+#[derive(Debug)]\n+pub enum FormatSpecifier {\n+    Open,\n+    Close,\n+    Integer,\n+    Identifier,\n+    Colon,\n+    Fill,\n+    Align,\n+    Sign,\n+    NumberSign,\n+    Zero,\n+    DollarSign,\n+    Dot,\n+    Asterisk,\n+    QuestionMark,\n+}\n+\n+pub fn lex_format_specifiers(\n+    string: &ast::String,\n+    mut callback: &mut dyn FnMut(TextRange, FormatSpecifier),\n+) {\n+    let mut char_ranges = Vec::new();\n+    string.escaped_char_ranges(&mut |range, res| char_ranges.push((range, res)));\n+    let mut chars = char_ranges\n+        .iter()\n+        .filter_map(|(range, res)| Some((*range, *res.as_ref().ok()?)))\n+        .peekable();\n+\n+    while let Some((range, first_char)) = chars.next() {\n+        if let '{' = first_char {\n+            // Format specifier, see syntax at https://doc.rust-lang.org/std/fmt/index.html#syntax\n+            if let Some((_, '{')) = chars.peek() {\n+                // Escaped format specifier, `{{`\n+                chars.next();\n+                continue;\n+            }\n+\n+            callback(range, FormatSpecifier::Open);\n+\n+            // check for integer/identifier\n+            let (_, int_char) = chars.peek().copied().unwrap_or_default();\n+            match int_char {\n+                // integer\n+                '0'..='9' => read_integer(&mut chars, &mut callback),\n+                // identifier\n+                c if c == '_' || c.is_alphabetic() => read_identifier(&mut chars, &mut callback),\n+                _ => {}\n+            }\n+\n+            if let Some((_, ':')) = chars.peek() {\n+                skip_char_and_emit(&mut chars, FormatSpecifier::Colon, &mut callback);\n+\n+                // check for fill/align\n+                let mut cloned = chars.clone().take(2);\n+                let (_, first) = cloned.next().unwrap_or_default();\n+                let (_, second) = cloned.next().unwrap_or_default();\n+                match second {\n+                    '<' | '^' | '>' => {\n+                        // alignment specifier, first char specifies fillment\n+                        skip_char_and_emit(&mut chars, FormatSpecifier::Fill, &mut callback);\n+                        skip_char_and_emit(&mut chars, FormatSpecifier::Align, &mut callback);\n+                    }\n+                    _ => {\n+                        if let '<' | '^' | '>' = first {\n+                            skip_char_and_emit(&mut chars, FormatSpecifier::Align, &mut callback);\n+                        }\n+                    }\n+                }\n+\n+                // check for sign\n+                match chars.peek().copied().unwrap_or_default().1 {\n+                    '+' | '-' => {\n+                        skip_char_and_emit(&mut chars, FormatSpecifier::Sign, &mut callback);\n+                    }\n+                    _ => {}\n+                }\n+\n+                // check for `#`\n+                if let Some((_, '#')) = chars.peek() {\n+                    skip_char_and_emit(&mut chars, FormatSpecifier::NumberSign, &mut callback);\n+                }\n+\n+                // check for `0`\n+                let mut cloned = chars.clone().take(2);\n+                let first = cloned.next().map(|next| next.1);\n+                let second = cloned.next().map(|next| next.1);\n+\n+                if first == Some('0') && second != Some('$') {\n+                    skip_char_and_emit(&mut chars, FormatSpecifier::Zero, &mut callback);\n+                }\n+\n+                // width\n+                match chars.peek().copied().unwrap_or_default().1 {\n+                    '0'..='9' => {\n+                        read_integer(&mut chars, &mut callback);\n+                        if let Some((_, '$')) = chars.peek() {\n+                            skip_char_and_emit(\n+                                &mut chars,\n+                                FormatSpecifier::DollarSign,\n+                                &mut callback,\n+                            );\n+                        }\n+                    }\n+                    c if c == '_' || c.is_alphabetic() => {\n+                        read_identifier(&mut chars, &mut callback);\n+\n+                        if chars.peek().map(|&(_, c)| c) == Some('?') {\n+                            skip_char_and_emit(\n+                                &mut chars,\n+                                FormatSpecifier::QuestionMark,\n+                                &mut callback,\n+                            );\n+                        }\n+\n+                        // can be either width (indicated by dollar sign, or type in which case\n+                        // the next sign has to be `}`)\n+                        let next = chars.peek().map(|&(_, c)| c);\n+\n+                        match next {\n+                            Some('$') => skip_char_and_emit(\n+                                &mut chars,\n+                                FormatSpecifier::DollarSign,\n+                                &mut callback,\n+                            ),\n+                            Some('}') => {\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    FormatSpecifier::Close,\n+                                    &mut callback,\n+                                );\n+                                continue;\n+                            }\n+                            _ => continue,\n+                        };\n+                    }\n+                    _ => {}\n+                }\n+\n+                // precision\n+                if let Some((_, '.')) = chars.peek() {\n+                    skip_char_and_emit(&mut chars, FormatSpecifier::Dot, &mut callback);\n+\n+                    match chars.peek().copied().unwrap_or_default().1 {\n+                        '*' => {\n+                            skip_char_and_emit(\n+                                &mut chars,\n+                                FormatSpecifier::Asterisk,\n+                                &mut callback,\n+                            );\n+                        }\n+                        '0'..='9' => {\n+                            read_integer(&mut chars, &mut callback);\n+                            if let Some((_, '$')) = chars.peek() {\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    FormatSpecifier::DollarSign,\n+                                    &mut callback,\n+                                );\n+                            }\n+                        }\n+                        c if c == '_' || c.is_alphabetic() => {\n+                            read_identifier(&mut chars, &mut callback);\n+                            if chars.peek().map(|&(_, c)| c) != Some('$') {\n+                                continue;\n+                            }\n+                            skip_char_and_emit(\n+                                &mut chars,\n+                                FormatSpecifier::DollarSign,\n+                                &mut callback,\n+                            );\n+                        }\n+                        _ => {\n+                            continue;\n+                        }\n+                    }\n+                }\n+\n+                // type\n+                match chars.peek().copied().unwrap_or_default().1 {\n+                    '?' => {\n+                        skip_char_and_emit(\n+                            &mut chars,\n+                            FormatSpecifier::QuestionMark,\n+                            &mut callback,\n+                        );\n+                    }\n+                    c if c == '_' || c.is_alphabetic() => {\n+                        read_identifier(&mut chars, &mut callback);\n+\n+                        if chars.peek().map(|&(_, c)| c) == Some('?') {\n+                            skip_char_and_emit(\n+                                &mut chars,\n+                                FormatSpecifier::QuestionMark,\n+                                &mut callback,\n+                            );\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            if let Some((_, '}')) = chars.peek() {\n+                skip_char_and_emit(&mut chars, FormatSpecifier::Close, &mut callback);\n+            }\n+            continue;\n+        }\n+    }\n+\n+    fn skip_char_and_emit<I, F>(\n+        chars: &mut std::iter::Peekable<I>,\n+        emit: FormatSpecifier,\n+        callback: &mut F,\n+    ) where\n+        I: Iterator<Item = (TextRange, char)>,\n+        F: FnMut(TextRange, FormatSpecifier),\n+    {\n+        let (range, _) = chars.next().unwrap();\n+        callback(range, emit);\n+    }\n+\n+    fn read_integer<I, F>(chars: &mut std::iter::Peekable<I>, callback: &mut F)\n+    where\n+        I: Iterator<Item = (TextRange, char)>,\n+        F: FnMut(TextRange, FormatSpecifier),\n+    {\n+        let (mut range, c) = chars.next().unwrap();\n+        assert!(c.is_ascii_digit());\n+        while let Some(&(r, next_char)) = chars.peek() {\n+            if next_char.is_ascii_digit() {\n+                chars.next();\n+                range = range.cover(r);\n+            } else {\n+                break;\n+            }\n+        }\n+        callback(range, FormatSpecifier::Integer);\n+    }\n+\n+    fn read_identifier<I, F>(chars: &mut std::iter::Peekable<I>, callback: &mut F)\n+    where\n+        I: Iterator<Item = (TextRange, char)>,\n+        F: FnMut(TextRange, FormatSpecifier),\n+    {\n+        let (mut range, c) = chars.next().unwrap();\n+        assert!(c.is_alphabetic() || c == '_');\n+        while let Some(&(r, next_char)) = chars.peek() {\n+            if next_char == '_' || next_char.is_ascii_digit() || next_char.is_alphabetic() {\n+                chars.next();\n+                range = range.cover(r);\n+            } else {\n+                break;\n+            }\n+        }\n+        callback(range, FormatSpecifier::Identifier);\n+    }\n+}"}, {"sha": "5c1aed3cd4809fd0c39ce7a46dae2df5cebd5524", "filename": "crates/syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a52f8370024c7f3e8e2fd8c5df785cdbe804847/crates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a52f8370024c7f3e8e2fd8c5df785cdbe804847/crates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast.rs?ref=7a52f8370024c7f3e8e2fd8c5df785cdbe804847", "patch": "@@ -25,10 +25,7 @@ pub use self::{\n         SlicePatComponents, StructKind, TypeBoundKind, VisibilityKind,\n     },\n     operators::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp},\n-    token_ext::{\n-        CommentKind, CommentPlacement, CommentShape, FormatSpecifier, HasFormatSpecifier, IsString,\n-        QuoteOffsets, Radix,\n-    },\n+    token_ext::{CommentKind, CommentPlacement, CommentShape, IsString, QuoteOffsets, Radix},\n     traits::{\n         DocCommentIter, HasArgList, HasAttrs, HasDocComments, HasGenericParams, HasLoopBody,\n         HasModuleItem, HasName, HasTypeBounds, HasVisibility,"}, {"sha": "16ac35b399169111ad537dc2038cb03062f5621e", "filename": "crates/syntax/src/ast/token_ext.rs", "status": "modified", "additions": 19, "deletions": 293, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/7a52f8370024c7f3e8e2fd8c5df785cdbe804847/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a52f8370024c7f3e8e2fd8c5df785cdbe804847/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs?ref=7a52f8370024c7f3e8e2fd8c5df785cdbe804847", "patch": "@@ -164,6 +164,25 @@ pub trait IsString: AstToken {\n     fn close_quote_text_range(&self) -> Option<TextRange> {\n         self.quote_offsets().map(|it| it.quotes.1)\n     }\n+    fn escaped_char_ranges(\n+        &self,\n+        cb: &mut dyn FnMut(TextRange, Result<char, rustc_lexer::unescape::EscapeError>),\n+    ) {\n+        let text_range_no_quotes = match self.text_range_between_quotes() {\n+            Some(it) => it,\n+            None => return,\n+        };\n+\n+        let start = self.syntax().text_range().start();\n+        let text = &self.text()[text_range_no_quotes - start];\n+        let offset = text_range_no_quotes.start() - start;\n+\n+        unescape_literal(text, Mode::Str, &mut |range, unescaped_char| {\n+            let text_range =\n+                TextRange::new(range.start.try_into().unwrap(), range.end.try_into().unwrap());\n+            cb(text_range + offset, unescaped_char);\n+        });\n+    }\n }\n \n impl IsString for ast::String {}\n@@ -257,299 +276,6 @@ impl ast::ByteString {\n     }\n }\n \n-#[derive(Debug)]\n-pub enum FormatSpecifier {\n-    Open,\n-    Close,\n-    Integer,\n-    Identifier,\n-    Colon,\n-    Fill,\n-    Align,\n-    Sign,\n-    NumberSign,\n-    Zero,\n-    DollarSign,\n-    Dot,\n-    Asterisk,\n-    QuestionMark,\n-}\n-\n-pub trait HasFormatSpecifier: AstToken {\n-    fn char_ranges(\n-        &self,\n-    ) -> Option<Vec<(TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>>;\n-\n-    fn lex_format_specifier<F>(&self, mut callback: F)\n-    where\n-        F: FnMut(TextRange, FormatSpecifier),\n-    {\n-        let char_ranges = match self.char_ranges() {\n-            Some(char_ranges) => char_ranges,\n-            None => return,\n-        };\n-        let mut chars = char_ranges\n-            .iter()\n-            .filter_map(|(range, res)| Some((*range, *res.as_ref().ok()?)))\n-            .peekable();\n-\n-        while let Some((range, first_char)) = chars.next() {\n-            if let '{' = first_char {\n-                // Format specifier, see syntax at https://doc.rust-lang.org/std/fmt/index.html#syntax\n-                if let Some((_, '{')) = chars.peek() {\n-                    // Escaped format specifier, `{{`\n-                    chars.next();\n-                    continue;\n-                }\n-\n-                callback(range, FormatSpecifier::Open);\n-\n-                // check for integer/identifier\n-                let (_, int_char) = chars.peek().copied().unwrap_or_default();\n-                match int_char {\n-                    // integer\n-                    '0'..='9' => read_integer(&mut chars, &mut callback),\n-                    // identifier\n-                    c if c == '_' || c.is_alphabetic() => {\n-                        read_identifier(&mut chars, &mut callback)\n-                    }\n-                    _ => {}\n-                }\n-\n-                if let Some((_, ':')) = chars.peek() {\n-                    skip_char_and_emit(&mut chars, FormatSpecifier::Colon, &mut callback);\n-\n-                    // check for fill/align\n-                    let mut cloned = chars.clone().take(2);\n-                    let (_, first) = cloned.next().unwrap_or_default();\n-                    let (_, second) = cloned.next().unwrap_or_default();\n-                    match second {\n-                        '<' | '^' | '>' => {\n-                            // alignment specifier, first char specifies fillment\n-                            skip_char_and_emit(&mut chars, FormatSpecifier::Fill, &mut callback);\n-                            skip_char_and_emit(&mut chars, FormatSpecifier::Align, &mut callback);\n-                        }\n-                        _ => {\n-                            if let '<' | '^' | '>' = first {\n-                                skip_char_and_emit(\n-                                    &mut chars,\n-                                    FormatSpecifier::Align,\n-                                    &mut callback,\n-                                );\n-                            }\n-                        }\n-                    }\n-\n-                    // check for sign\n-                    match chars.peek().copied().unwrap_or_default().1 {\n-                        '+' | '-' => {\n-                            skip_char_and_emit(&mut chars, FormatSpecifier::Sign, &mut callback);\n-                        }\n-                        _ => {}\n-                    }\n-\n-                    // check for `#`\n-                    if let Some((_, '#')) = chars.peek() {\n-                        skip_char_and_emit(&mut chars, FormatSpecifier::NumberSign, &mut callback);\n-                    }\n-\n-                    // check for `0`\n-                    let mut cloned = chars.clone().take(2);\n-                    let first = cloned.next().map(|next| next.1);\n-                    let second = cloned.next().map(|next| next.1);\n-\n-                    if first == Some('0') && second != Some('$') {\n-                        skip_char_and_emit(&mut chars, FormatSpecifier::Zero, &mut callback);\n-                    }\n-\n-                    // width\n-                    match chars.peek().copied().unwrap_or_default().1 {\n-                        '0'..='9' => {\n-                            read_integer(&mut chars, &mut callback);\n-                            if let Some((_, '$')) = chars.peek() {\n-                                skip_char_and_emit(\n-                                    &mut chars,\n-                                    FormatSpecifier::DollarSign,\n-                                    &mut callback,\n-                                );\n-                            }\n-                        }\n-                        c if c == '_' || c.is_alphabetic() => {\n-                            read_identifier(&mut chars, &mut callback);\n-\n-                            if chars.peek().map(|&(_, c)| c) == Some('?') {\n-                                skip_char_and_emit(\n-                                    &mut chars,\n-                                    FormatSpecifier::QuestionMark,\n-                                    &mut callback,\n-                                );\n-                            }\n-\n-                            // can be either width (indicated by dollar sign, or type in which case\n-                            // the next sign has to be `}`)\n-                            let next = chars.peek().map(|&(_, c)| c);\n-\n-                            match next {\n-                                Some('$') => skip_char_and_emit(\n-                                    &mut chars,\n-                                    FormatSpecifier::DollarSign,\n-                                    &mut callback,\n-                                ),\n-                                Some('}') => {\n-                                    skip_char_and_emit(\n-                                        &mut chars,\n-                                        FormatSpecifier::Close,\n-                                        &mut callback,\n-                                    );\n-                                    continue;\n-                                }\n-                                _ => continue,\n-                            };\n-                        }\n-                        _ => {}\n-                    }\n-\n-                    // precision\n-                    if let Some((_, '.')) = chars.peek() {\n-                        skip_char_and_emit(&mut chars, FormatSpecifier::Dot, &mut callback);\n-\n-                        match chars.peek().copied().unwrap_or_default().1 {\n-                            '*' => {\n-                                skip_char_and_emit(\n-                                    &mut chars,\n-                                    FormatSpecifier::Asterisk,\n-                                    &mut callback,\n-                                );\n-                            }\n-                            '0'..='9' => {\n-                                read_integer(&mut chars, &mut callback);\n-                                if let Some((_, '$')) = chars.peek() {\n-                                    skip_char_and_emit(\n-                                        &mut chars,\n-                                        FormatSpecifier::DollarSign,\n-                                        &mut callback,\n-                                    );\n-                                }\n-                            }\n-                            c if c == '_' || c.is_alphabetic() => {\n-                                read_identifier(&mut chars, &mut callback);\n-                                if chars.peek().map(|&(_, c)| c) != Some('$') {\n-                                    continue;\n-                                }\n-                                skip_char_and_emit(\n-                                    &mut chars,\n-                                    FormatSpecifier::DollarSign,\n-                                    &mut callback,\n-                                );\n-                            }\n-                            _ => {\n-                                continue;\n-                            }\n-                        }\n-                    }\n-\n-                    // type\n-                    match chars.peek().copied().unwrap_or_default().1 {\n-                        '?' => {\n-                            skip_char_and_emit(\n-                                &mut chars,\n-                                FormatSpecifier::QuestionMark,\n-                                &mut callback,\n-                            );\n-                        }\n-                        c if c == '_' || c.is_alphabetic() => {\n-                            read_identifier(&mut chars, &mut callback);\n-\n-                            if chars.peek().map(|&(_, c)| c) == Some('?') {\n-                                skip_char_and_emit(\n-                                    &mut chars,\n-                                    FormatSpecifier::QuestionMark,\n-                                    &mut callback,\n-                                );\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-\n-                if let Some((_, '}')) = chars.peek() {\n-                    skip_char_and_emit(&mut chars, FormatSpecifier::Close, &mut callback);\n-                }\n-                continue;\n-            }\n-        }\n-\n-        fn skip_char_and_emit<I, F>(\n-            chars: &mut std::iter::Peekable<I>,\n-            emit: FormatSpecifier,\n-            callback: &mut F,\n-        ) where\n-            I: Iterator<Item = (TextRange, char)>,\n-            F: FnMut(TextRange, FormatSpecifier),\n-        {\n-            let (range, _) = chars.next().unwrap();\n-            callback(range, emit);\n-        }\n-\n-        fn read_integer<I, F>(chars: &mut std::iter::Peekable<I>, callback: &mut F)\n-        where\n-            I: Iterator<Item = (TextRange, char)>,\n-            F: FnMut(TextRange, FormatSpecifier),\n-        {\n-            let (mut range, c) = chars.next().unwrap();\n-            assert!(c.is_ascii_digit());\n-            while let Some(&(r, next_char)) = chars.peek() {\n-                if next_char.is_ascii_digit() {\n-                    chars.next();\n-                    range = range.cover(r);\n-                } else {\n-                    break;\n-                }\n-            }\n-            callback(range, FormatSpecifier::Integer);\n-        }\n-\n-        fn read_identifier<I, F>(chars: &mut std::iter::Peekable<I>, callback: &mut F)\n-        where\n-            I: Iterator<Item = (TextRange, char)>,\n-            F: FnMut(TextRange, FormatSpecifier),\n-        {\n-            let (mut range, c) = chars.next().unwrap();\n-            assert!(c.is_alphabetic() || c == '_');\n-            while let Some(&(r, next_char)) = chars.peek() {\n-                if next_char == '_' || next_char.is_ascii_digit() || next_char.is_alphabetic() {\n-                    chars.next();\n-                    range = range.cover(r);\n-                } else {\n-                    break;\n-                }\n-            }\n-            callback(range, FormatSpecifier::Identifier);\n-        }\n-    }\n-}\n-\n-impl HasFormatSpecifier for ast::String {\n-    fn char_ranges(\n-        &self,\n-    ) -> Option<Vec<(TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>> {\n-        let text = self.text();\n-        let text = &text[self.text_range_between_quotes()? - self.syntax().text_range().start()];\n-        let offset = self.text_range_between_quotes()?.start() - self.syntax().text_range().start();\n-\n-        let mut res = Vec::with_capacity(text.len());\n-        unescape_literal(text, Mode::Str, &mut |range, unescaped_char| {\n-            res.push((\n-                TextRange::new(range.start.try_into().unwrap(), range.end.try_into().unwrap())\n-                    + offset,\n-                unescaped_char,\n-            ));\n-        });\n-\n-        Some(res)\n-    }\n-}\n-\n impl ast::IntNumber {\n     pub fn radix(&self) -> Radix {\n         match self.text().get(..2).unwrap_or_default() {"}]}