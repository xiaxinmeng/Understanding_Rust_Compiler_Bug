{"sha": "7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMWQ4NWYxZGVhNWFiMzZmMGViMTdiMjUyZGQ5OTI5YWRjODJjYTQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2016-12-21T14:47:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-21T14:47:12Z"}, "message": "Merge branch 'master' into allow_deprecated", "tree": {"sha": "888613173d781a0dcfacdc285dfc510f084fd2f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/888613173d781a0dcfacdc285dfc510f084fd2f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "html_url": "https://github.com/rust-lang/rust/commit/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "919feaaec5c3c07052f607268f110778ead48964", "url": "https://api.github.com/repos/rust-lang/rust/commits/919feaaec5c3c07052f607268f110778ead48964", "html_url": "https://github.com/rust-lang/rust/commit/919feaaec5c3c07052f607268f110778ead48964"}, {"sha": "ad4df726fdb3bb25f35deaefdbe3fe3123cf97c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad4df726fdb3bb25f35deaefdbe3fe3123cf97c6", "html_url": "https://github.com/rust-lang/rust/commit/ad4df726fdb3bb25f35deaefdbe3fe3123cf97c6"}], "stats": {"total": 4750, "additions": 2698, "deletions": 2052}, "files": [{"sha": "33ecb63593cd4a6db111b9b31738fe2b7c6147b6", "filename": ".gitignore", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -24,3 +24,6 @@ Cargo.lock\n \n # gh pages docs\n util/gh-pages/lints.json\n+\n+# rustfmt backups\n+*.rs.bk"}, {"sha": "3c226c879f26de9343badc9bdb28c9b04b6ea9ca", "filename": ".travis.yml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -17,11 +17,16 @@ install:\n   - nvm install stable\n   - nvm use stable\n   - npm install remark-cli remark-lint\n+  # || true, because we cache rustfmt and don't want to crash on the next travis run\n+  # due to rustfmt already being installed\n+  - (cargo install rustfmt || true)\n \n script:\n  - remark -f README.md > /dev/null\n  - python util/update_lints.py -c\n  - set -e\n+ - PATH=$PATH:~/.cargo/bin cargo fmt -- --write-mode=diff\n+ - cd clippy_lints && PATH=$PATH:~/.cargo/bin cargo fmt -- --write-mode=diff && cd ..\n  - cargo build --features debugging\n  - cargo test --features debugging\n  - mkdir -p ~/rust/cargo/bin"}, {"sha": "51381a6eb0248191dbe47da2adca0301705c4b8a", "filename": "CHANGELOG.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,6 +1,9 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.104 \u2014 2016-12-15\n+* Update to *rustc 1.15.0-nightly (8f02c429a 2016-12-15)*\n+\n ## 0.0.103 \u2014 2016-11-25\n * Update to *rustc 1.15.0-nightly (d5814b03e 2016-11-23)*\n \n@@ -260,6 +263,7 @@ All notable changes to this project will be documented in this file.\n [`crosspointer_transmute`]: https://github.com/Manishearth/rust-clippy/wiki#crosspointer_transmute\n [`cyclomatic_complexity`]: https://github.com/Manishearth/rust-clippy/wiki#cyclomatic_complexity\n [`deprecated_semver`]: https://github.com/Manishearth/rust-clippy/wiki#deprecated_semver\n+[`deref_addrof`]: https://github.com/Manishearth/rust-clippy/wiki#deref_addrof\n [`derive_hash_xor_eq`]: https://github.com/Manishearth/rust-clippy/wiki#derive_hash_xor_eq\n [`diverging_sub_expression`]: https://github.com/Manishearth/rust-clippy/wiki#diverging_sub_expression\n [`doc_markdown`]: https://github.com/Manishearth/rust-clippy/wiki#doc_markdown\n@@ -353,6 +357,7 @@ All notable changes to this project will be documented in this file.\n [`print_stdout`]: https://github.com/Manishearth/rust-clippy/wiki#print_stdout\n [`print_with_newline`]: https://github.com/Manishearth/rust-clippy/wiki#print_with_newline\n [`ptr_arg`]: https://github.com/Manishearth/rust-clippy/wiki#ptr_arg\n+[`pub_enum_variant_names`]: https://github.com/Manishearth/rust-clippy/wiki#pub_enum_variant_names\n [`range_step_by_zero`]: https://github.com/Manishearth/rust-clippy/wiki#range_step_by_zero\n [`range_zip_with_len`]: https://github.com/Manishearth/rust-clippy/wiki#range_zip_with_len\n [`redundant_closure`]: https://github.com/Manishearth/rust-clippy/wiki#redundant_closure"}, {"sha": "0b1d7fd8671b651bed7f361d2f189915cd681bcb", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.103\"\n+version = \"0.0.104\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -25,11 +25,11 @@ test = false\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.103\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.104\", path = \"clippy_lints\" }\n # end automatic update\n \n [dev-dependencies]\n-compiletest_rs = \"0.2.1\"\n+compiletest_rs = \"0.2.5\"\n lazy_static = \"0.1.15\"\n regex = \"0.1.71\"\n rustc-serialize = \"0.3\""}, {"sha": "15751a0d3d0ba8de31ad0dbcbdb4666f3f52a30c", "filename": "README.md", "status": "modified", "additions": 56, "deletions": 47, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -16,52 +16,41 @@ Table of contents:\n \n ## Usage\n \n+Since this is a tool for helping the developer of a library or application\n+write better code, it is recommended not to include clippy as a hard dependency.\n+Options include using it as an optional dependency, as a cargo subcommand, or\n+as an included feature during build. All of these options are detailed below.\n+\n As a general rule clippy will only work with the *latest* Rust nightly for now.\n \n-### As a Compiler Plugin\n+### Optional dependency\n \n-Since stable Rust is backwards compatible, you should be able to\n-compile your stable programs with nightly Rust with clippy plugged in to\n-circumvent this.\n+If you want to make clippy an optional dependency, you can do the following:\n \n-Add in your `Cargo.toml`:\n+In your `Cargo.toml`:\n \n ```toml\n [dependencies]\n-clippy = \"*\"\n-```\n+clippy = {version = \"*\", optional = true}\n \n-You then need to add `#![feature(plugin)]` and `#![plugin(clippy)]` to the top\n-of your crate entry point (`main.rs` or `lib.rs`).\n+[features]\n+default = []\n+```\n \n-Sample `main.rs`:\n+And, in your `main.rs` or `lib.rs`:\n \n ```rust\n-#![feature(plugin)]\n-\n-#![plugin(clippy)]\n-\n+#![cfg_attr(feature=\"clippy\", feature(plugin))]\n \n-fn main(){\n-    let x = Some(1u8);\n-    match x {\n-        Some(y) => println!(\"{:?}\", y),\n-        _ => ()\n-    }\n-}\n+#![cfg_attr(feature=\"clippy\", plugin(clippy))]\n ```\n \n-Produces this warning:\n+Then build by enabling the feature: `cargo build --features \"clippy\"`\n \n-```terminal\n-src/main.rs:8:5: 11:6 warning: you seem to be trying to use match for destructuring a single type. Consider using `if let`, #[warn(single_match)] on by default\n-src/main.rs:8     match x {\n-src/main.rs:9         Some(y) => println!(\"{:?}\", y),\n-src/main.rs:10         _ => ()\n-src/main.rs:11     }\n-src/main.rs:8:5: 11:6 help: Try\n-if let Some(y) = x { println!(\"{:?}\", y) }\n-```\n+Instead of adding the `cfg_attr` attributes you can also run clippy on demand:\n+`cargo rustc --features clippy -- -Z no-trans -Z extra-plugins=clippy`\n+(the `-Z no trans`, while not neccessary, will stop the compilation process after\n+typechecking (and lints) have completed, which can significantly reduce the runtime).\n \n ### As a cargo subcommand (`cargo clippy`)\n \n@@ -96,34 +85,52 @@ cargo rustc -- -L /path/to/clippy_so -Z extra-plugins=clippy\n *[Note](https://github.com/Manishearth/rust-clippy/wiki#a-word-of-warning):*\n Be sure that clippy was compiled with the same version of rustc that cargo invokes here!\n \n-### Optional dependency\n+### As a Compiler Plugin\n \n-If you want to make clippy an optional dependency, you can do the following:\n+*Note:* This is not a recommended installation method.\n \n-In your `Cargo.toml`:\n+Since stable Rust is backwards compatible, you should be able to\n+compile your stable programs with nightly Rust with clippy plugged in to\n+circumvent this.\n+\n+Add in your `Cargo.toml`:\n \n ```toml\n [dependencies]\n-clippy = {version = \"*\", optional = true}\n-\n-[features]\n-default = []\n+clippy = \"*\"\n ```\n \n-And, in your `main.rs` or `lib.rs`:\n+You then need to add `#![feature(plugin)]` and `#![plugin(clippy)]` to the top\n+of your crate entry point (`main.rs` or `lib.rs`).\n+\n+Sample `main.rs`:\n \n ```rust\n-#![cfg_attr(feature=\"clippy\", feature(plugin))]\n+#![feature(plugin)]\n \n-#![cfg_attr(feature=\"clippy\", plugin(clippy))]\n+#![plugin(clippy)]\n+\n+\n+fn main(){\n+    let x = Some(1u8);\n+    match x {\n+        Some(y) => println!(\"{:?}\", y),\n+        _ => ()\n+    }\n+}\n ```\n \n-Then build by enabling the feature: `cargo build --features \"clippy\"`\n+Produces this warning:\n \n-Instead of adding the `cfg_attr` attributes you can also run clippy on demand:\n-`cargo rustc --features clippy -- -Z no-trans -Z extra-plugins=clippy`\n-(the `-Z no trans`, while not neccessary, will stop the compilation process after\n-typechecking (and lints) have completed, which can significantly reduce the runtime).\n+```terminal\n+src/main.rs:8:5: 11:6 warning: you seem to be trying to use match for destructuring a single type. Consider using `if let`, #[warn(single_match)] on by default\n+src/main.rs:8     match x {\n+src/main.rs:9         Some(y) => println!(\"{:?}\", y),\n+src/main.rs:10         _ => ()\n+src/main.rs:11     }\n+src/main.rs:8:5: 11:6 help: Try\n+if let Some(y) = x { println!(\"{:?}\", y) }\n+```\n \n ## Configuration\n \n@@ -172,7 +179,7 @@ transparently:\n \n ## Lints\n \n-There are 178 lints included in this crate:\n+There are 180 lints included in this crate:\n \n name                                                                                                                   | default | triggers on\n -----------------------------------------------------------------------------------------------------------------------|---------|----------------------------------------------------------------------------------------------------------------------------------\n@@ -204,6 +211,7 @@ name\n [crosspointer_transmute](https://github.com/Manishearth/rust-clippy/wiki#crosspointer_transmute)                       | warn    | transmutes that have to or from types that are a pointer to the other\n [cyclomatic_complexity](https://github.com/Manishearth/rust-clippy/wiki#cyclomatic_complexity)                         | warn    | functions that should be split up into multiple functions\n [deprecated_semver](https://github.com/Manishearth/rust-clippy/wiki#deprecated_semver)                                 | warn    | use of `#[deprecated(since = \"x\")]` where x is not semver\n+[deref_addrof](https://github.com/Manishearth/rust-clippy/wiki#deref_addrof)                                           | warn    | use of `*&` or `*&mut` in an expression\n [derive_hash_xor_eq](https://github.com/Manishearth/rust-clippy/wiki#derive_hash_xor_eq)                               | warn    | deriving `Hash` but implementing `PartialEq` explicitly\n [diverging_sub_expression](https://github.com/Manishearth/rust-clippy/wiki#diverging_sub_expression)                   | warn    | whether an expression contains a diverging sub expression\n [doc_markdown](https://github.com/Manishearth/rust-clippy/wiki#doc_markdown)                                           | warn    | presence of `_`, `::` or camel-case outside backticks in documentation\n@@ -297,6 +305,7 @@ name\n [print_stdout](https://github.com/Manishearth/rust-clippy/wiki#print_stdout)                                           | allow   | printing on stdout\n [print_with_newline](https://github.com/Manishearth/rust-clippy/wiki#print_with_newline)                               | warn    | using `print!()` with a format string that ends in a newline\n [ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                                     | warn    | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n+[pub_enum_variant_names](https://github.com/Manishearth/rust-clippy/wiki#pub_enum_variant_names)                       | allow   | enums where all variants share a prefix/postfix\n [range_step_by_zero](https://github.com/Manishearth/rust-clippy/wiki#range_step_by_zero)                               | warn    | using `Range::step_by(0)`, which produces an infinite iterator\n [range_zip_with_len](https://github.com/Manishearth/rust-clippy/wiki#range_zip_with_len)                               | warn    | zipping iterator with a range when `enumerate()` would do\n [redundant_closure](https://github.com/Manishearth/rust-clippy/wiki#redundant_closure)                                 | warn    | redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)"}, {"sha": "faf86875f40d493994c608fc6f2b4d45b85fc900", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.103\"\n+version = \"0.0.104\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "7131e609715b0020f77897482db339c8b91084b6", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -59,8 +59,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprLit(ref lit) = e.node {\n             check_lit(cx, lit, e);\n         }\n@@ -85,7 +85,9 @@ fn check_known_consts(cx: &LateContext, e: &Expr, s: &symbol::Symbol, module: &s\n                           APPROX_CONSTANT,\n                           e.span,\n                           &format!(\"approximate value of `{}::consts::{}` found. \\\n-                                    Consider using it directly\", module, &name));\n+                                    Consider using it directly\",\n+                                   module,\n+                                   &name));\n                 return;\n             }\n         }"}, {"sha": "109f045b619b162c6f6027978d0925775b514820", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -47,8 +47,8 @@ impl LintPass for Arithmetic {\n     }\n }\n \n-impl LateLintPass for Arithmetic {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if self.span.is_some() {\n             return;\n         }\n@@ -67,7 +67,7 @@ impl LateLintPass for Arithmetic {\n                     span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n                     self.span = Some(expr.span);\n                 }\n-            }\n+            },\n             hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n                 let ty = cx.tcx.tables().expr_ty(arg);\n                 if ty.is_integral() {\n@@ -77,12 +77,12 @@ impl LateLintPass for Arithmetic {\n                     span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n                     self.span = Some(expr.span);\n                 }\n-            }\n+            },\n             _ => (),\n         }\n     }\n \n-    fn check_expr_post(&mut self, _: &LateContext, expr: &hir::Expr) {\n+    fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if Some(expr.span) == self.span {\n             self.span = None;\n         }"}, {"sha": "de13c0264e5032e0645f5bace35fe9ad4e0d601d", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -55,8 +55,8 @@ impl LintPass for ArrayIndexing {\n     }\n }\n \n-impl LateLintPass for ArrayIndexing {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         if let hir::ExprIndex(ref array, ref index) = e.node {\n             // Array with known size can be checked statically\n             let ty = cx.tcx.tables().expr_ty(array);\n@@ -107,9 +107,12 @@ impl LateLintPass for ArrayIndexing {\n }\n \n /// Returns an option containing a tuple with the start and end (exclusive) of the range.\n-fn to_const_range(start: Option<Option<ConstVal>>, end: Option<Option<ConstVal>>, limits: RangeLimits,\n-                  array_size: ConstInt)\n-                  -> Option<(ConstInt, ConstInt)> {\n+fn to_const_range(\n+    start: Option<Option<ConstVal>>,\n+    end: Option<Option<ConstVal>>,\n+    limits: RangeLimits,\n+    array_size: ConstInt\n+) -> Option<(ConstInt, ConstInt)> {\n     let start = match start {\n         Some(Some(ConstVal::Integral(x))) => x,\n         Some(_) => return None,\n@@ -123,7 +126,7 @@ fn to_const_range(start: Option<Option<ConstVal>>, end: Option<Option<ConstVal>>\n             } else {\n                 x\n             }\n-        }\n+        },\n         Some(_) => return None,\n         None => array_size,\n     };"}, {"sha": "122a600d7d38f7fd066f61d3bc28e1247f0d2a2b", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,5 +1,6 @@\n use rustc::hir;\n use rustc::lint::*;\n+use syntax::ast;\n use utils::{span_lint_and_then, snippet_opt, SpanlessEq, get_trait_def_id, implements_trait};\n use utils::{higher, sugg};\n \n@@ -66,8 +67,8 @@ impl LintPass for AssignOps {\n     }\n }\n \n-impl LateLintPass for AssignOps {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 span_lint_and_then(cx, ASSIGN_OPS, expr.span, \"assign operation detected\", |db| {\n@@ -94,13 +95,13 @@ impl LateLintPass for AssignOps {\n                                                expr.span,\n                                                \"variable appears on both sides of an assignment operation\",\n                                                |db| {\n-                                                   if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span),\n-                                                                                          snippet_opt(cx, rhs.span)) {\n-                                                       db.span_suggestion(expr.span,\n-                                                                          \"replace it with\",\n-                                                                          format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n-                                                   }\n-                                               });\n+                                if let (Some(snip_a), Some(snip_r)) =\n+                                    (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span)) {\n+                                    db.span_suggestion(expr.span,\n+                                                       \"replace it with\",\n+                                                       format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n+                                }\n+                            });\n                         };\n                         // lhs op= l op r\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n@@ -112,7 +113,7 @@ impl LateLintPass for AssignOps {\n                         }\n                     }\n                 }\n-            }\n+            },\n             hir::ExprAssign(ref assignee, ref e) => {\n                 if let hir::ExprBinary(op, ref l, ref r) = e.node {\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n@@ -125,7 +126,11 @@ impl LateLintPass for AssignOps {\n                             return; // implements_trait does not work with generics\n                         }\n                         macro_rules! ops {\n-                            ($op:expr, $cx:expr, $ty:expr, $rty:expr, $($trait_name:ident:$full_trait_name:ident),+) => {\n+                            ($op:expr,\n+                             $cx:expr,\n+                             $ty:expr,\n+                             $rty:expr,\n+                             $($trait_name:ident:$full_trait_name:ident),+) => {\n                                 match $op {\n                                     $(hir::$full_trait_name => {\n                                         let [krate, module] = ::utils::paths::OPS_MODULE;\n@@ -135,6 +140,16 @@ impl LateLintPass for AssignOps {\n                                         } else {\n                                             return; // useless if the trait doesn't exist\n                                         };\n+                                        // check that we are not inside an `impl AssignOp` of this exact operation\n+                                        let parent_fn = cx.tcx.map.get_parent(e.id);\n+                                        let parent_impl = cx.tcx.map.get_parent(parent_fn);\n+                                        // the crate node is the only one that is not in the map\n+                                        if_let_chain!{[\n+                                            parent_impl != ast::CRATE_NODE_ID,\n+                                            let hir::map::Node::NodeItem(item) = cx.tcx.map.get(parent_impl),\n+                                            let hir::Item_::ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node,\n+                                            trait_ref.path.def.def_id() == trait_id\n+                                        ], { return; }}\n                                         implements_trait($cx, $ty, trait_id, vec![$rty])\n                                     },)*\n                                     _ => false,\n@@ -162,13 +177,13 @@ impl LateLintPass for AssignOps {\n                                                expr.span,\n                                                \"manual implementation of an assign operation\",\n                                                |db| {\n-                                                   if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span),\n-                                                                                          snippet_opt(cx, rhs.span)) {\n-                                                       db.span_suggestion(expr.span,\n-                                                                          \"replace it with\",\n-                                                                          format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n-                                                   }\n-                                               });\n+                                if let (Some(snip_a), Some(snip_r)) =\n+                                    (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span)) {\n+                                    db.span_suggestion(expr.span,\n+                                                       \"replace it with\",\n+                                                       format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n+                                }\n+                            });\n                         }\n                     };\n                     // a = a op b\n@@ -181,37 +196,21 @@ impl LateLintPass for AssignOps {\n                             hir::BiAdd | hir::BiMul | hir::BiAnd | hir::BiOr | hir::BiBitXor | hir::BiBitAnd |\n                             hir::BiBitOr => {\n                                 lint(assignee, l);\n-                            }\n-                            _ => {}\n+                            },\n+                            _ => {},\n                         }\n                     }\n                 }\n-            }\n-            _ => {}\n+            },\n+            _ => {},\n         }\n     }\n }\n \n fn is_commutative(op: hir::BinOp_) -> bool {\n     use rustc::hir::BinOp_::*;\n     match op {\n-        BiAdd |\n-        BiMul |\n-        BiAnd |\n-        BiOr |\n-        BiBitXor |\n-        BiBitAnd |\n-        BiBitOr |\n-        BiEq |\n-        BiNe => true,\n-        BiSub |\n-        BiDiv |\n-        BiRem |\n-        BiShl |\n-        BiShr |\n-        BiLt |\n-        BiLe |\n-        BiGe |\n-        BiGt => false,\n+        BiAdd | BiMul | BiAnd | BiOr | BiBitXor | BiBitAnd | BiBitOr | BiEq | BiNe => true,\n+        BiSub | BiDiv | BiRem | BiShl | BiShr | BiLt | BiLe | BiGe | BiGt => false,\n     }\n }"}, {"sha": "df6ef64a73f80e59416b1cec2f80db6be2b91d61", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -36,9 +36,11 @@ declare_lint! {\n \n /// **What it does:** Checks for `extern crate` and `use` items annotated with lint attributes\n ///\n-/// **Why is this bad?** Lint attributes have no effect on crate imports. Most likely a `!` was forgotten\n+/// **Why is this bad?** Lint attributes have no effect on crate imports. Most likely a `!` was\n+/// forgotten\n ///\n-/// **Known problems:** Technically one might allow `unused_import` on a `use` item, but it's easier to remove the unused item.\n+/// **Known problems:** Technically one might allow `unused_import` on a `use` item,\n+/// but it's easier to remove the unused item.\n ///\n /// **Example:**\n /// ```rust\n@@ -81,8 +83,8 @@ impl LintPass for AttrPass {\n     }\n }\n \n-impl LateLintPass for AttrPass {\n-    fn check_attribute(&mut self, cx: &LateContext, attr: &Attribute) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n+    fn check_attribute(&mut self, cx: &LateContext<'a, 'tcx>, attr: &'tcx Attribute) {\n         if let MetaItemKind::List(ref items) = attr.value.node {\n             if items.is_empty() || attr.name() != \"deprecated\" {\n                 return;\n@@ -99,28 +101,30 @@ impl LateLintPass for AttrPass {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if is_relevant_item(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n         match item.node {\n             ItemExternCrate(_) |\n-            ItemUse(_) => {\n+            ItemUse(_, _) => {\n                 for attr in &item.attrs {\n                     if let MetaItemKind::List(ref lint_list) = attr.value.node {\n                         match &*attr.name().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n                                 // whitelist `unused_imports` and `deprecated`\n                                 for lint in lint_list {\n                                     if is_word(lint, \"unused_imports\") || is_word(lint, \"deprecated\") {\n-                                        if let ItemUse(_) = item.node {\n+                                        if let ItemUse(_, _) = item.node {\n                                             return;\n                                         }\n                                     }\n                                 }\n                                 if let Some(mut sugg) = snippet_opt(cx, attr.span) {\n                                     if sugg.len() > 1 {\n-                                        span_lint_and_then(cx, USELESS_ATTRIBUTE, attr.span,\n+                                        span_lint_and_then(cx,\n+                                                           USELESS_ATTRIBUTE,\n+                                                           attr.span,\n                                                            \"useless lint attribute\",\n                                                            |db| {\n                                             sugg.insert(1, '!');\n@@ -138,38 +142,38 @@ impl LateLintPass for AttrPass {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if is_relevant_impl(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if is_relevant_trait(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n }\n \n fn is_relevant_item(cx: &LateContext, item: &Item) -> bool {\n-    if let ItemFn(_, _, _, _, _, ref expr) = item.node {\n-        is_relevant_expr(cx, expr)\n+    if let ItemFn(_, _, _, _, _, eid) = item.node {\n+        is_relevant_expr(cx, cx.tcx.map.expr(eid))\n     } else {\n         false\n     }\n }\n \n fn is_relevant_impl(cx: &LateContext, item: &ImplItem) -> bool {\n     match item.node {\n-        ImplItemKind::Method(_, ref expr) => is_relevant_expr(cx, expr),\n+        ImplItemKind::Method(_, eid) => is_relevant_expr(cx, cx.tcx.map.expr(eid)),\n         _ => false,\n     }\n }\n \n fn is_relevant_trait(cx: &LateContext, item: &TraitItem) -> bool {\n     match item.node {\n         MethodTraitItem(_, None) => true,\n-        MethodTraitItem(_, Some(ref expr)) => is_relevant_expr(cx, expr),\n+        MethodTraitItem(_, Some(eid)) => is_relevant_expr(cx, cx.tcx.map.expr(eid)),\n         _ => false,\n     }\n }\n@@ -181,7 +185,7 @@ fn is_relevant_block(cx: &LateContext, block: &Block) -> bool {\n             StmtExpr(ref expr, _) |\n             StmtSemi(ref expr, _) => {\n                 return is_relevant_expr(cx, expr);\n-            }\n+            },\n         }\n     }\n     block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, e))\n@@ -191,15 +195,16 @@ fn is_relevant_expr(cx: &LateContext, expr: &Expr) -> bool {\n     match expr.node {\n         ExprBlock(ref block) => is_relevant_block(cx, block),\n         ExprRet(Some(ref e)) => is_relevant_expr(cx, e),\n-        ExprRet(None) | ExprBreak(_, None) => false,\n+        ExprRet(None) |\n+        ExprBreak(_, None) => false,\n         ExprCall(ref path_expr, _) => {\n-            if let ExprPath(..) = path_expr.node {\n-                let fun_id = resolve_node(cx, path_expr.id).expect(\"function should be resolved\").def_id();\n+            if let ExprPath(ref qpath) = path_expr.node {\n+                let fun_id = resolve_node(cx, qpath, path_expr.id).def_id();\n                 !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n             } else {\n                 true\n             }\n-        }\n+        },\n         _ => true,\n     }\n }"}, {"sha": "5b860d8cedc7e876af9a941c0c750675d2852b01", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::*;\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::Def;\n use rustc::lint::*;\n use rustc_const_eval::lookup_const_by_id;\n use syntax::ast::LitKind;\n@@ -79,8 +79,8 @@ impl LintPass for BitMask {\n     }\n }\n \n-impl LateLintPass for BitMask {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n@@ -134,7 +134,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     } else if mask_value == 0 {\n                         span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                     }\n-                }\n+                },\n                 BiBitOr => {\n                     if mask_value | cmp_value != cmp_value {\n                         span_lint(cx,\n@@ -144,10 +144,10 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                                            mask_value,\n                                            cmp_value));\n                     }\n-                }\n+                },\n                 _ => (),\n             }\n-        }\n+        },\n         BiLt | BiGe => {\n             match bit_op {\n                 BiBitAnd => {\n@@ -161,7 +161,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     } else if mask_value == 0 {\n                         span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                     }\n-                }\n+                },\n                 BiBitOr => {\n                     if mask_value >= cmp_value {\n                         span_lint(cx,\n@@ -173,11 +173,11 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     } else {\n                         check_ineffective_lt(cx, *span, mask_value, cmp_value, \"|\");\n                     }\n-                }\n+                },\n                 BiBitXor => check_ineffective_lt(cx, *span, mask_value, cmp_value, \"^\"),\n                 _ => (),\n             }\n-        }\n+        },\n         BiLe | BiGt => {\n             match bit_op {\n                 BiBitAnd => {\n@@ -191,7 +191,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     } else if mask_value == 0 {\n                         span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                     }\n-                }\n+                },\n                 BiBitOr => {\n                     if mask_value > cmp_value {\n                         span_lint(cx,\n@@ -203,11 +203,11 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     } else {\n                         check_ineffective_gt(cx, *span, mask_value, cmp_value, \"|\");\n                     }\n-                }\n+                },\n                 BiBitXor => check_ineffective_gt(cx, *span, mask_value, cmp_value, \"^\"),\n                 _ => (),\n             }\n-        }\n+        },\n         _ => (),\n     }\n }\n@@ -244,20 +244,15 @@ fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n             } else {\n                 None\n             }\n-        }\n-        ExprPath(_, _) => {\n-            {\n-                // Important to let the borrow expire before the const lookup to avoid double\n-                // borrowing.\n-                let def_map = cx.tcx.def_map.borrow();\n-                match def_map.get(&lit.id) {\n-                    Some(&PathResolution { base_def: Def::Const(def_id), .. }) => Some(def_id),\n-                    _ => None,\n-                }\n+        },\n+        ExprPath(ref qpath) => {\n+            let def = cx.tcx.tables().qpath_def(qpath, lit.id);\n+            if let Def::Const(def_id) = def {\n+                lookup_const_by_id(cx.tcx, def_id, None).and_then(|(l, _ty)| fetch_int_literal(cx, l))\n+            } else {\n+                None\n             }\n-            .and_then(|def_id| lookup_const_by_id(cx.tcx, def_id, None))\n-            .and_then(|(l, _ty)| fetch_int_literal(cx, l))\n-        }\n+        },\n         _ => None,\n     }\n }"}, {"sha": "2f9a50fe3dac84d16e833278e9691de53982b0ca", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -37,9 +37,9 @@ impl LintPass for BlackListedName {\n     }\n }\n \n-impl LateLintPass for BlackListedName {\n-    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n-        if let PatKind::Binding(_, ref ident, _) = pat.node {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlackListedName {\n+    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n+        if let PatKind::Binding(_, _, ref ident, _) = pat.node {\n             if self.blacklist.iter().any(|s| s == &*ident.node.as_str()) {\n                 span_lint(cx,\n                           BLACKLISTED_NAME,"}, {"sha": "2f9a6b161585e00b0eb4eab5e2c5eba598c41ac9", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::{LateLintPass, LateContext, LintArray, LintPass};\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use utils::*;\n \n /// **What it does:** Checks for `if` conditions that use blocks to contain an\n@@ -49,28 +49,33 @@ impl LintPass for BlockInIfCondition {\n     }\n }\n \n-struct ExVisitor<'v> {\n-    found_block: Option<&'v Expr>,\n+struct ExVisitor<'a, 'tcx: 'a> {\n+    found_block: Option<&'tcx Expr>,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'v> Visitor<'v> for ExVisitor<'v> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n-        if let ExprClosure(_, _, ref expr, _) = expr.node {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let ExprClosure(_, _, eid, _) = expr.node {\n+            let expr = self.cx.tcx.map.expr(eid);\n             if matches!(expr.node, ExprBlock(_)) {\n                 self.found_block = Some(expr);\n                 return;\n             }\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n const BRACED_EXPR_MESSAGE: &'static str = \"omit braces around single expression condition\";\n const COMPLEX_BLOCK_MESSAGE: &'static str = \"in an 'if' condition, avoid complex blocks or closures with blocks; \\\n                                              instead, move the block or closure higher and bind it with a 'let'\";\n \n-impl LateLintPass for BlockInIfCondition {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprIf(ref check, ref then, _) = expr.node {\n             if let ExprBlock(ref block) = check.node {\n                 if block.rules == DefaultBlock {\n@@ -105,7 +110,10 @@ impl LateLintPass for BlockInIfCondition {\n                     }\n                 }\n             } else {\n-                let mut visitor = ExVisitor { found_block: None };\n+                let mut visitor = ExVisitor {\n+                    found_block: None,\n+                    cx: cx,\n+                };\n                 walk_expr(&mut visitor, check);\n                 if let Some(block) = visitor.found_block {\n                     span_lint(cx, BLOCK_IN_IF_CONDITION_STMT, block.span, COMPLEX_BLOCK_MESSAGE);"}, {"sha": "979b62f8ce7ec73a8195123fec3e6e6b97e6e8fa", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -53,13 +53,15 @@ impl LintPass for NonminimalBool {\n     }\n }\n \n-impl LateLintPass for NonminimalBool {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        NonminimalBoolVisitor(cx).visit_item(item)\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonminimalBool {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n+        NonminimalBoolVisitor { cx: cx }.visit_item(item)\n     }\n }\n \n-struct NonminimalBoolVisitor<'a, 'tcx: 'a>(&'a LateContext<'a, 'tcx>);\n+struct NonminimalBoolVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n \n use quine_mc_cluskey::Bool;\n struct Hir2Qmm<'a, 'tcx: 'a, 'v> {\n@@ -92,14 +94,14 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                         BiAnd => return Ok(Bool::And(self.extract(BiAnd, &[lhs, rhs], Vec::new())?)),\n                         _ => (),\n                     }\n-                }\n+                },\n                 ExprLit(ref lit) => {\n                     match lit.node {\n                         LitKind::Bool(true) => return Ok(Bool::True),\n                         LitKind::Bool(false) => return Ok(Bool::False),\n                         _ => (),\n                     }\n-                }\n+                },\n                 _ => (),\n             }\n         }\n@@ -127,7 +129,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                         BiLe => mk_expr(BiGt),\n                         _ => continue,\n                     }\n-                }\n+                },\n                 _ => continue,\n             };\n             if SpanlessEq::new(self.cx).ignore_fn().eq_expr(&negated, expr) {\n@@ -154,17 +156,17 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n             True => {\n                 s.push_str(\"true\");\n                 s\n-            }\n+            },\n             False => {\n                 s.push_str(\"false\");\n                 s\n-            }\n+            },\n             Not(ref inner) => {\n                 match **inner {\n                     And(_) | Or(_) => {\n                         s.push('!');\n                         recurse(true, cx, inner, terminals, s)\n-                    }\n+                    },\n                     Term(n) => {\n                         if let ExprBinary(binop, ref lhs, ref rhs) = terminals[n as usize].node {\n                             let op = match binop.node {\n@@ -177,7 +179,7 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                                 _ => {\n                                     s.push('!');\n                                     return recurse(true, cx, inner, terminals, s);\n-                                }\n+                                },\n                             };\n                             s.push_str(&snip(lhs));\n                             s.push_str(op);\n@@ -187,13 +189,13 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                             s.push('!');\n                             recurse(false, cx, inner, terminals, s)\n                         }\n-                    }\n+                    },\n                     _ => {\n                         s.push('!');\n                         recurse(false, cx, inner, terminals, s)\n-                    }\n+                    },\n                 }\n-            }\n+            },\n             And(ref v) => {\n                 if brackets {\n                     s.push('(');\n@@ -215,7 +217,7 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                     s.push(')');\n                 }\n                 s\n-            }\n+            },\n             Or(ref v) => {\n                 if brackets {\n                     s.push('(');\n@@ -229,7 +231,7 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                     s.push(')');\n                 }\n                 s\n-            }\n+            },\n             Term(n) => {\n                 if brackets {\n                     if let ExprBinary(..) = terminals[n as usize].node {\n@@ -243,7 +245,7 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                     }\n                 }\n                 s\n-            }\n+            },\n         }\n     }\n     recurse(false, cx, suggestion, terminals, String::new())\n@@ -260,13 +262,13 @@ fn simple_negate(b: Bool) -> Bool {\n                 *el = simple_negate(::std::mem::replace(el, True));\n             }\n             Or(v)\n-        }\n+        },\n         Or(mut v) => {\n             for el in &mut v {\n                 *el = simple_negate(::std::mem::replace(el, True));\n             }\n             And(v)\n-        }\n+        },\n         Not(inner) => *inner,\n     }\n }\n@@ -288,13 +290,13 @@ fn terminal_stats(b: &Bool) -> Stats {\n                     _ => stats.negations += 1,\n                 }\n                 recurse(inner, stats);\n-            }\n+            },\n             And(ref v) | Or(ref v) => {\n                 stats.ops += v.len() - 1;\n                 for inner in v {\n                     recurse(inner, stats);\n                 }\n-            }\n+            },\n             Term(n) => stats.terminals[n as usize] += 1,\n         }\n     }\n@@ -308,7 +310,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n     fn bool_expr(&self, e: &Expr) {\n         let mut h2q = Hir2Qmm {\n             terminals: Vec::new(),\n-            cx: self.0,\n+            cx: self.cx,\n         };\n         if let Ok(expr) = h2q.run(e) {\n \n@@ -323,7 +325,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n             let mut simplified = expr.simplify();\n             for simple in Bool::Not(Box::new(expr.clone())).simplify() {\n                 match simple {\n-                    Bool::Not(_) | Bool::True | Bool::False => {}\n+                    Bool::Not(_) | Bool::True | Bool::False => {},\n                     _ => simplified.push(Bool::Not(Box::new(simple.clone()))),\n                 }\n                 let simple_negated = simple_negate(simple);\n@@ -343,7 +345,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                         continue 'simplified;\n                     }\n                     if stats.terminals[i] != 0 && simplified_stats.terminals[i] == 0 {\n-                        span_lint_and_then(self.0,\n+                        span_lint_and_then(self.cx,\n                                            LOGIC_BUG,\n                                            e.span,\n                                            \"this boolean expression contains a logic bug\",\n@@ -353,7 +355,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                                           outer expression\");\n                             db.span_suggestion(e.span,\n                                                \"it would look like the following\",\n-                                               suggest(self.0, suggestion, &h2q.terminals));\n+                                               suggest(self.cx, suggestion, &h2q.terminals));\n                         });\n                         // don't also lint `NONMINIMAL_BOOL`\n                         return;\n@@ -370,35 +372,38 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                 }\n             }\n             if !improvements.is_empty() {\n-                span_lint_and_then(self.0,\n+                span_lint_and_then(self.cx,\n                                    NONMINIMAL_BOOL,\n                                    e.span,\n                                    \"this boolean expression can be simplified\",\n                                    |db| {\n                     for suggestion in &improvements {\n-                        db.span_suggestion(e.span, \"try\", suggest(self.0, suggestion, &h2q.terminals));\n+                        db.span_suggestion(e.span, \"try\", suggest(self.cx, suggestion, &h2q.terminals));\n                     }\n                 });\n             }\n         }\n     }\n }\n \n-impl<'a, 'v, 'tcx> Visitor<'v> for NonminimalBoolVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, e: &'v Expr) {\n-        if in_macro(self.0, e.span) {\n+impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, e: &'tcx Expr) {\n+        if in_macro(self.cx, e.span) {\n             return;\n         }\n         match e.node {\n             ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n             ExprUnary(UnNot, ref inner) => {\n-                if self.0.tcx.tables.borrow().node_types[&inner.id].is_bool() {\n+                if self.cx.tcx.tables.borrow().node_types[&inner.id].is_bool() {\n                     self.bool_expr(e);\n                 } else {\n                     walk_expr(self, e);\n                 }\n-            }\n+            },\n             _ => walk_expr(self, e),\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "85bd419df7320c167fcadadd7ea0dd085b0a0d60", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -2,7 +2,7 @@\n //!\n //! For example, the lint would catch:\n //!\n-//! ```rust\n+//! ```rust,ignore\n //! if x {\n //!     if y {\n //!         println!(\"Hello world\");\n@@ -28,7 +28,7 @@ use utils::sugg::Sugg;\n /// **Known problems:** None.\n ///\n /// **Example:**\n-/// ```rust\n+/// ```rust,ignore\n /// if x {\n ///     if y {\n ///         \u2026\n@@ -48,7 +48,7 @@ use utils::sugg::Sugg;\n ///\n /// Should be written:\n ///\n-/// ```rust\n+/// ```rust.ignore\n /// if x && y {\n ///     \u2026\n /// }\n@@ -92,10 +92,10 @@ fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n             } else {\n                 check_collapsible_no_if_let(cx, expr, check, then);\n             }\n-        }\n+        },\n         ast::ExprKind::IfLet(_, _, _, Some(ref else_)) => {\n             check_collapsible_maybe_if_let(cx, else_);\n-        }\n+        },\n         _ => (),\n     }\n }\n@@ -120,12 +120,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n     }}\n }\n \n-fn check_collapsible_no_if_let(\n-    cx: &EarlyContext,\n-    expr: &ast::Expr,\n-    check: &ast::Expr,\n-    then: &ast::Block,\n-) {\n+fn check_collapsible_no_if_let(cx: &EarlyContext, expr: &ast::Expr, check: &ast::Expr, then: &ast::Block) {\n     if_let_chain! {[\n         let Some(inner) = expr_block(then),\n         let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node,\n@@ -145,13 +140,14 @@ fn check_collapsible_no_if_let(\n     }}\n }\n \n-/// If the block contains only one expression, returns it.\n+/// If the block contains only one expression, return it.\n fn expr_block(block: &ast::Block) -> Option<&ast::Expr> {\n     let mut it = block.stmts.iter();\n \n     if let (Some(stmt), None) = (it.next(), it.next()) {\n         match stmt.node {\n-            ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => Some(expr),\n+            ast::StmtKind::Expr(ref expr) |\n+            ast::StmtKind::Semi(ref expr) => Some(expr),\n             _ => None,\n         }\n     } else {"}, {"sha": "44288e7d7fcdcf820d14c076aefa7dd3933a8c8b", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,7 +1,7 @@\n #![allow(cast_possible_truncation)]\n \n use rustc::lint::LateContext;\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::Def;\n use rustc_const_eval::lookup_const_by_id;\n use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n use rustc::hir::*;\n@@ -10,7 +10,7 @@ use std::cmp::PartialOrd;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::rc::Rc;\n-use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy, IntTy};\n+use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy, IntTy, NodeId};\n use syntax::ptr::P;\n \n #[derive(Debug, Copy, Clone)]\n@@ -75,18 +75,16 @@ impl PartialEq for Constant {\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n             (&Constant::Int(l), &Constant::Int(r)) => {\n                 l.is_negative() == r.is_negative() && l.to_u64_unchecked() == r.to_u64_unchecked()\n-            }\n+            },\n             (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n                 // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n                 // `Fw32 == Fw64` so don\u2019t compare them\n                 match (ls.parse::<f64>(), rs.parse::<f64>()) {\n                     // mem::transmute is required to catch non-matching 0.0, -0.0, and NaNs\n-                    (Ok(l), Ok(r)) => unsafe {\n-                        mem::transmute::<f64, u64>(l) == mem::transmute::<f64, u64>(r)\n-                    },\n+                    (Ok(l), Ok(r)) => unsafe { mem::transmute::<f64, u64>(l) == mem::transmute::<f64, u64>(r) },\n                     _ => false,\n                 }\n-            }\n+            },\n             (&Constant::Bool(l), &Constant::Bool(r)) => l == r,\n             (&Constant::Vec(ref l), &Constant::Vec(ref r)) => l == r,\n             (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n@@ -104,34 +102,34 @@ impl Hash for Constant {\n             Constant::Str(ref s, ref k) => {\n                 s.hash(state);\n                 k.hash(state);\n-            }\n+            },\n             Constant::Binary(ref b) => {\n                 b.hash(state);\n-            }\n+            },\n             Constant::Char(c) => {\n                 c.hash(state);\n-            }\n+            },\n             Constant::Int(i) => {\n                 i.to_u64_unchecked().hash(state);\n                 i.is_negative().hash(state);\n-            }\n+            },\n             Constant::Float(ref f, _) => {\n                 // don\u2019t use the width here because of PartialEq implementation\n                 if let Ok(f) = f.parse::<f64>() {\n                     unsafe { mem::transmute::<f64, u64>(f) }.hash(state);\n                 }\n-            }\n+            },\n             Constant::Bool(b) => {\n                 b.hash(state);\n-            }\n+            },\n             Constant::Vec(ref v) |\n             Constant::Tuple(ref v) => {\n                 v.hash(state);\n-            }\n+            },\n             Constant::Repeat(ref c, l) => {\n                 c.hash(state);\n                 l.hash(state);\n-            }\n+            },\n         }\n     }\n }\n@@ -145,19 +143,21 @@ impl PartialOrd for Constant {\n                 } else {\n                     None\n                 }\n-            }\n+            },\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n             (&Constant::Int(l), &Constant::Int(r)) => Some(l.cmp(&r)),\n             (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n                 match (ls.parse::<f64>(), rs.parse::<f64>()) {\n-                    (Ok(ref l), Ok(ref r)) => match (l.partial_cmp(r), l.is_sign_positive() == r.is_sign_positive()) {\n-                        // Check for comparison of -0.0 and 0.0\n-                        (Some(Ordering::Equal), false) => None,\n-                        (x, _) => x\n+                    (Ok(ref l), Ok(ref r)) => {\n+                        match (l.partial_cmp(r), l.is_sign_positive() == r.is_sign_positive()) {\n+                            // Check for comparison of -0.0 and 0.0\n+                            (Some(Ordering::Equal), false) => None,\n+                            (x, _) => x,\n+                        }\n                     },\n                     _ => None,\n                 }\n-            }\n+            },\n             (&Constant::Bool(ref l), &Constant::Bool(ref r)) => Some(l.cmp(r)),\n             (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) |\n             (&Constant::Vec(ref l), &Constant::Vec(ref r)) => l.partial_cmp(r),\n@@ -166,7 +166,7 @@ impl PartialOrd for Constant {\n                     Some(Equal) => Some(ls.cmp(rs)),\n                     x => x,\n                 }\n-            }\n+            },\n             _ => None, //TODO: Are there any useful inter-type orderings?\n         }\n     }\n@@ -187,14 +187,14 @@ pub fn lit_to_constant(lit: &LitKind) -> Constant {\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::U64)) => Constant::Int(ConstInt::U64(value as u64)),\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::Us)) => {\n             Constant::Int(ConstInt::Usize(ConstUsize::Us32(value as u32)))\n-        }\n+        },\n         LitKind::Int(value, LitIntType::Signed(IntTy::I8)) => Constant::Int(ConstInt::I8(value as i8)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I16)) => Constant::Int(ConstInt::I16(value as i16)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I32)) => Constant::Int(ConstInt::I32(value as i32)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I64)) => Constant::Int(ConstInt::I64(value as i64)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::Is)) => {\n             Constant::Int(ConstInt::Isize(ConstIsize::Is32(value as i32)))\n-        }\n+        },\n         LitKind::Float(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n         LitKind::FloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::Any),\n         LitKind::Bool(b) => Constant::Bool(b),\n@@ -252,15 +252,15 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     /// simple constant folding: Insert an expression, get a constant or none.\n     fn expr(&mut self, e: &Expr) -> Option<Constant> {\n         match e.node {\n-            ExprPath(_, _) => self.fetch_path(e),\n+            ExprPath(ref qpath) => self.fetch_path(qpath, e.id),\n             ExprBlock(ref block) => self.block(block),\n             ExprIf(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n             ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n             ExprArray(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprRepeat(ref value, ref number) => {\n                 self.binop_apply(value, number, |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n-            }\n+            },\n             ExprUnary(op, ref operand) => {\n                 self.expr(operand).and_then(|o| {\n                     match op {\n@@ -269,7 +269,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                         UnDeref => Some(o),\n                     }\n                 })\n-            }\n+            },\n             ExprBinary(op, ref left, ref right) => self.binop(op, left, right),\n             // TODO: add other expressions\n             _ => None,\n@@ -280,26 +280,30 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     /// non-constant part\n     fn multi(&mut self, vec: &[Expr]) -> Option<Vec<Constant>> {\n         vec.iter()\n-           .map(|elem| self.expr(elem))\n-           .collect::<Option<_>>()\n+            .map(|elem| self.expr(elem))\n+            .collect::<Option<_>>()\n     }\n \n     /// lookup a possibly constant expression from a ExprPath\n-    fn fetch_path(&mut self, e: &Expr) -> Option<Constant> {\n+    fn fetch_path(&mut self, qpath: &QPath, id: NodeId) -> Option<Constant> {\n         if let Some(lcx) = self.lcx {\n-            let mut maybe_id = None;\n-            if let Some(&PathResolution { base_def: Def::Const(id), .. }) = lcx.tcx.def_map.borrow().get(&e.id) {\n-                maybe_id = Some(id);\n-            }\n-            // separate if lets to avoid double borrowing the def_map\n-            if let Some(id) = maybe_id {\n-                if let Some((const_expr, _ty)) = lookup_const_by_id(lcx.tcx, id, None) {\n-                    let ret = self.expr(const_expr);\n-                    if ret.is_some() {\n-                        self.needed_resolution = true;\n+            let def = lcx.tcx.tables().qpath_def(qpath, id);\n+            match def {\n+                Def::Const(def_id) |\n+                Def::AssociatedConst(def_id) => {\n+                    let substs = Some(lcx.tcx\n+                        .tables()\n+                        .node_id_item_substs(id)\n+                        .unwrap_or_else(|| lcx.tcx.intern_substs(&[])));\n+                    if let Some((const_expr, _ty)) = lookup_const_by_id(lcx.tcx, def_id, substs) {\n+                        let ret = self.expr(const_expr);\n+                        if ret.is_some() {\n+                            self.needed_resolution = true;\n+                        }\n+                        return ret;\n                     }\n-                    return ret;\n-                }\n+                },\n+                _ => {},\n             }\n         }\n         None"}, {"sha": "11b85edba3e696711e697ba8c94c3534dc1c3dc7", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -109,8 +109,8 @@ impl LintPass for CopyAndPaste {\n     }\n }\n \n-impl LateLintPass for CopyAndPaste {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if !in_macro(cx, expr.span) {\n             // skip ifs directly in else, it will be checked in the parent if\n             if let Some(&Expr { node: ExprIf(_, _, Some(ref else_expr)), .. }) = get_parent_expr(cx, expr) {\n@@ -204,8 +204,11 @@ fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n \n                     if let PatKind::Wild = j.pats[0].node {\n                         // if the last arm is _, then i could be integrated into _\n-                        // note that i.pats[0] cannot be _, because that would mean that we're hiding all the subsequent arms, and rust won't compile\n-                        db.span_note(i.body.span, &format!(\"`{}` has the same arm body as the `_` wildcard, consider removing it`\", lhs));\n+                        // note that i.pats[0] cannot be _, because that would mean that we're\n+                        // hiding all the subsequent arms, and rust won't compile\n+                        db.span_note(i.body.span,\n+                                     &format!(\"`{}` has the same arm body as the `_` wildcard, consider removing it`\",\n+                                              lhs));\n                     } else {\n                         db.span_note(i.body.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n                     }\n@@ -245,33 +248,37 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n \n /// Return the list of bindings in a pattern.\n fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, ty::Ty<'tcx>> {\n-    fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut HashMap<InternedString, ty::Ty<'tcx>>) {\n+    fn bindings_impl<'a, 'tcx>(\n+        cx: &LateContext<'a, 'tcx>,\n+        pat: &Pat,\n+        map: &mut HashMap<InternedString, ty::Ty<'tcx>>\n+    ) {\n         match pat.node {\n             PatKind::Box(ref pat) |\n             PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n             PatKind::TupleStruct(_, ref pats, _) => {\n                 for pat in pats {\n                     bindings_impl(cx, pat, map);\n                 }\n-            }\n-            PatKind::Binding(_, ref ident, ref as_pat) => {\n+            },\n+            PatKind::Binding(_, _, ref ident, ref as_pat) => {\n                 if let Entry::Vacant(v) = map.entry(ident.node.as_str()) {\n                     v.insert(cx.tcx.tables().pat_ty(pat));\n                 }\n                 if let Some(ref as_pat) = *as_pat {\n                     bindings_impl(cx, as_pat, map);\n                 }\n-            }\n+            },\n             PatKind::Struct(_, ref fields, _) => {\n                 for pat in fields {\n                     bindings_impl(cx, &pat.node.pat, map);\n                 }\n-            }\n+            },\n             PatKind::Tuple(ref fields, _) => {\n                 for pat in fields {\n                     bindings_impl(cx, pat, map);\n                 }\n-            }\n+            },\n             PatKind::Slice(ref lhs, ref mid, ref rhs) => {\n                 for pat in lhs {\n                     bindings_impl(cx, pat, map);\n@@ -282,7 +289,7 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n                 for pat in rhs {\n                     bindings_impl(cx, pat, map);\n                 }\n-            }\n+            },\n             PatKind::Lit(..) |\n             PatKind::Range(..) |\n             PatKind::Wild |\n@@ -320,10 +327,10 @@ fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Option<(&T, &T)>\n                         return Some((o, expr));\n                     }\n                 }\n-            }\n+            },\n             Entry::Vacant(v) => {\n                 v.insert(vec![expr]);\n-            }\n+            },\n         }\n     }\n "}, {"sha": "897a578f19a7ca72b551aa9780a0990a9b4f8ac8", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -4,7 +4,7 @@ use rustc::cfg::CFG;\n use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use syntax::ast::Attribute;\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -42,7 +42,7 @@ impl LintPass for CyclomaticComplexity {\n }\n \n impl CyclomaticComplexity {\n-    fn check<'a, 'tcx>(&mut self, cx: &'a LateContext<'a, 'tcx>, expr: &Expr, span: Span) {\n+    fn check<'a, 'tcx: 'a>(&mut self, cx: &'a LateContext<'a, 'tcx>, expr: &'tcx Expr, span: Span) {\n         if in_macro(cx, span) {\n             return;\n         }\n@@ -60,7 +60,7 @@ impl CyclomaticComplexity {\n             divergence: 0,\n             short_circuits: 0,\n             returns: 0,\n-            tcx: &cx.tcx,\n+            cx: cx,\n         };\n         helper.visit_expr(expr);\n         let CCHelper { match_arms, divergence, short_circuits, returns, .. } = helper;\n@@ -90,76 +90,79 @@ impl CyclomaticComplexity {\n     }\n }\n \n-impl LateLintPass for CyclomaticComplexity {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        if let ItemFn(_, _, _, _, _, ref expr) = item.node {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CyclomaticComplexity {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n+        if let ItemFn(_, _, _, _, _, eid) = item.node {\n             if !attr::contains_name(&item.attrs, \"test\") {\n-                self.check(cx, expr, item.span);\n+                self.check(cx, cx.tcx.map.expr(eid), item.span);\n             }\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n-        if let ImplItemKind::Method(_, ref expr) = item.node {\n-            self.check(cx, expr, item.span);\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n+        if let ImplItemKind::Method(_, eid) = item.node {\n+            self.check(cx, cx.tcx.map.expr(eid), item.span);\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n-        if let MethodTraitItem(_, Some(ref expr)) = item.node {\n-            self.check(cx, expr, item.span);\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n+        if let MethodTraitItem(_, Some(eid)) = item.node {\n+            self.check(cx, cx.tcx.map.expr(eid), item.span);\n         }\n     }\n \n-    fn enter_lint_attrs(&mut self, cx: &LateContext, attrs: &[Attribute]) {\n+    fn enter_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n         self.limit.push_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n     }\n-    fn exit_lint_attrs(&mut self, cx: &LateContext, attrs: &[Attribute]) {\n+    fn exit_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n         self.limit.pop_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n     }\n }\n \n-struct CCHelper<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+struct CCHelper<'a, 'tcx: 'a> {\n     match_arms: u64,\n     divergence: u64,\n     returns: u64,\n     short_circuits: u64, // && and ||\n-    tcx: &'a ty::TyCtxt<'a, 'gcx, 'tcx>,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'a, 'b, 'tcx, 'gcx> Visitor<'a> for CCHelper<'b, 'gcx, 'tcx> {\n-    fn visit_expr(&mut self, e: &'a Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n+    fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n             ExprMatch(_, ref arms, _) => {\n                 walk_expr(self, e);\n                 let arms_n: u64 = arms.iter().map(|arm| arm.pats.len() as u64).sum();\n                 if arms_n > 1 {\n                     self.match_arms += arms_n - 2;\n                 }\n-            }\n+            },\n             ExprCall(ref callee, _) => {\n                 walk_expr(self, e);\n-                let ty = self.tcx.tables().node_id_to_type(callee.id);\n+                let ty = self.cx.tcx.tables().node_id_to_type(callee.id);\n                 match ty.sty {\n                     ty::TyFnDef(_, _, ty) |\n-                    ty::TyFnPtr(ty) if ty.sig.skip_binder().output.sty == ty::TyNever => {\n+                    ty::TyFnPtr(ty) if ty.sig.skip_binder().output().sty == ty::TyNever => {\n                         self.divergence += 1;\n-                    }\n+                    },\n                     _ => (),\n                 }\n-            }\n+            },\n             ExprClosure(..) => (),\n             ExprBinary(op, _, _) => {\n                 walk_expr(self, e);\n                 match op.node {\n                     BiAnd | BiOr => self.short_circuits += 1,\n                     _ => (),\n                 }\n-            }\n+            },\n             ExprRet(_) => self.returns += 1,\n             _ => walk_expr(self, e),\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n }\n \n #[cfg(feature=\"debugging\")]"}, {"sha": "cda82f46434e167b0144876b105df877444437ca", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -5,7 +5,7 @@ use rustc::ty;\n use rustc::hir::*;\n use syntax::codemap::Span;\n use utils::paths;\n-use utils::{is_automatically_derived, match_path, span_lint_and_then};\n+use utils::{is_automatically_derived, span_lint_and_then, match_path_old};\n \n /// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n /// explicitly.\n@@ -70,8 +70,8 @@ impl LintPass for Derive {\n     }\n }\n \n-impl LateLintPass for Derive {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n             let ty = cx.tcx.item_type(cx.tcx.map.local_def_id(item.id));\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n@@ -86,10 +86,15 @@ impl LateLintPass for Derive {\n }\n \n /// Implementation of the `DERIVE_HASH_XOR_EQ` lint.\n-fn check_hash_peq<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>,\n-                                hash_is_automatically_derived: bool) {\n+fn check_hash_peq<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    span: Span,\n+    trait_ref: &TraitRef,\n+    ty: ty::Ty<'tcx>,\n+    hash_is_automatically_derived: bool\n+) {\n     if_let_chain! {[\n-        match_path(&trait_ref.path, &paths::HASH),\n+        match_path_old(&trait_ref.path, &paths::HASH),\n         let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n     ], {\n         let peq_trait_def = cx.tcx.lookup_trait_def(peq_trait_def_id);\n@@ -131,7 +136,7 @@ fn check_hash_peq<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, span: Span, trait_re\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n-    if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {\n+    if match_path_old(&trait_ref.path, &paths::CLONE_TRAIT) {\n         let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, item.id);\n         let subst_ty = ty.subst(cx.tcx, parameter_environment.free_substs);\n \n@@ -149,18 +154,18 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref\n                         match field.ty(cx.tcx, substs).sty {\n                             TypeVariants::TyArray(_, size) if size > 32 => {\n                                 return;\n-                            }\n+                            },\n                             TypeVariants::TyFnPtr(..) => {\n                                 return;\n-                            }\n+                            },\n                             TypeVariants::TyTuple(tys) if tys.len() > 12 => {\n                                 return;\n-                            }\n+                            },\n                             _ => (),\n                         }\n                     }\n                 }\n-            }\n+            },\n             _ => (),\n         }\n \n@@ -169,7 +174,7 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref\n                            item.span,\n                            \"you are implementing `Clone` explicitly on a `Copy` type\",\n                            |db| {\n-                               db.span_note(item.span, \"consider deriving `Clone` or removing `Copy`\");\n-                           });\n+            db.span_note(item.span, \"consider deriving `Clone` or removing `Copy`\");\n+        });\n     }\n }"}, {"sha": "20c82ee466074070a40b146538774a7648ea3c73", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -64,26 +64,21 @@ pub fn strip_doc_comment_decoration((comment, span): (String, Span)) -> Vec<(Str\n     const ONELINERS: &'static [&'static str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n     for prefix in ONELINERS {\n         if comment.starts_with(*prefix) {\n-            return vec![(\n-                comment[prefix.len()..].to_owned(),\n-                Span { lo: span.lo + BytePos(prefix.len() as u32), ..span }\n-            )];\n+            return vec![(comment[prefix.len()..].to_owned(),\n+                         Span { lo: span.lo + BytePos(prefix.len() as u32), ..span })];\n         }\n     }\n \n     if comment.starts_with(\"/*\") {\n-        return comment[3..comment.len() - 2].lines().map(|line| {\n-            let offset = line.as_ptr() as usize - comment.as_ptr() as usize;\n-            debug_assert_eq!(offset as u32 as usize, offset);\n-\n-            (\n-                line.to_owned(),\n-                Span {\n-                    lo: span.lo + BytePos(offset as u32),\n-                    ..span\n-                }\n-            )\n-        }).collect();\n+        return comment[3..comment.len() - 2]\n+            .lines()\n+            .map(|line| {\n+                let offset = line.as_ptr() as usize - comment.as_ptr() as usize;\n+                debug_assert_eq!(offset as u32 as usize, offset);\n+\n+                (line.to_owned(), Span { lo: span.lo + BytePos(offset as u32), ..span })\n+            })\n+            .collect();\n     }\n \n     panic!(\"not a doc-comment: {}\", comment);\n@@ -273,7 +268,9 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(String, Span)]\n                             }\n \n                             lookup_parser = parser.clone();\n-                            if let (Some((false, $c)), Some((false, $c))) = (lookup_parser.next(), lookup_parser.next()) {\n+                            let a = lookup_parser.next();\n+                            let b = lookup_parser.next();\n+                            if let (Some((false, $c)), Some((false, $c))) = (a, b) {\n                                 let mut close_count = 3;\n                                 while let Some((false, $c)) = lookup_parser.next() {\n                                     close_count += 1;\n@@ -299,16 +296,17 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(String, Span)]\n         match parser.next() {\n             Some((new_line, c)) => {\n                 match c {\n-                    '#' if new_line => { // don\u2019t warn on titles\n+                    '#' if new_line => {\n+                        // don\u2019t warn on titles\n                         parser.next_line();\n-                    }\n+                    },\n                     '`' => {\n                         if try!(check_block!(parser, '`', new_line)) {\n                             continue;\n                         }\n \n                         try!(parser.jump_to('`')); // not a code block, just inline code\n-                    }\n+                    },\n                     '~' => {\n                         if try!(check_block!(parser, '~', new_line)) {\n                             continue;\n@@ -317,7 +315,7 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(String, Span)]\n                         // ~ does not introduce inline code, but two of them introduce\n                         // strikethrough. Too bad for the consistency but we don't care about\n                         // strikethrough.\n-                    }\n+                    },\n                     '[' => {\n                         // Check for a reference definition `[foo]:` at the beginning of a line\n                         let mut link = true;\n@@ -335,24 +333,24 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(String, Span)]\n \n                         parser.advance_begin();\n                         parser.link = link;\n-                    }\n+                    },\n                     ']' if parser.link => {\n                         parser.link = false;\n \n                         match parser.peek() {\n                             Some('(') => {\n                                 try!(parser.jump_to(')'));\n-                            }\n+                            },\n                             Some('[') => {\n                                 try!(parser.jump_to(']'));\n-                            }\n+                            },\n                             Some(_) => continue,\n                             None => return Err(()),\n                         }\n-                    }\n+                    },\n                     c if !is_path_char(c) => {\n                         parser.advance_begin();\n-                    }\n+                    },\n                     _ => {\n                         if let Some((_, c)) = parser.find(|&(_, c)| !is_path_char(c)) {\n                             parser.put_back(c);\n@@ -361,10 +359,10 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(String, Span)]\n                         let (word, span) = parser.word();\n                         check_word(cx, valid_idents, word, span);\n                         parser.advance_begin();\n-                    }\n+                    },\n                 }\n \n-            }\n+            },\n             None => break,\n         }\n     }\n@@ -386,8 +384,7 @@ fn check_word(cx: &EarlyContext, valid_idents: &[String], word: &str, span: Span\n             s\n         };\n \n-        s.chars().all(char::is_alphanumeric) &&\n-        s.chars().filter(|&c| c.is_uppercase()).take(2).count() > 1 &&\n+        s.chars().all(char::is_alphanumeric) && s.chars().filter(|&c| c.is_uppercase()).take(2).count() > 1 &&\n         s.chars().filter(|&c| c.is_lowercase()).take(1).count() > 0\n     }\n "}, {"sha": "106e43e1b6f570a29f0427fb127e5ad24589d2f4", "filename": "clippy_lints/src/drop_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_ref.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -35,11 +35,11 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprCall(ref path, ref args) = expr.node {\n-            if let ExprPath(None, _) = path.node {\n-                let def_id = cx.tcx.expect_def(path.id).def_id();\n+            if let ExprPath(ref qpath) = path.node {\n+                let def_id = cx.tcx.tables().qpath_def(qpath, path.id).def_id();\n                 if match_def_path(cx, def_id, &paths::DROP) {\n                     if args.len() != 1 {\n                         return;"}, {"sha": "2fe53d8cacf4c30e2ee462cf442c55d4e100c144", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr, walk_block};\n+use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, NestedVisitorMap};\n use rustc::lint::*;\n use syntax::codemap::Span;\n use utils::SpanlessEq;\n@@ -39,8 +39,8 @@ impl LintPass for HashMapLint {\n     }\n }\n \n-impl LateLintPass for HashMapLint {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprIf(ref check, ref then_block, ref else_block) = expr.node {\n             if let ExprUnary(UnOp::UnNot, ref check) = check.node {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n@@ -78,7 +78,10 @@ impl LateLintPass for HashMapLint {\n     }\n }\n \n-fn check_cond<'a, 'tcx, 'b>(cx: &'a LateContext<'a, 'tcx>, check: &'b Expr) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n+fn check_cond<'a, 'tcx, 'b>(\n+    cx: &'a LateContext<'a, 'tcx>,\n+    check: &'b Expr\n+) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n     if_let_chain! {[\n         let ExprMethodCall(ref name, _, ref params) = check.node,\n         params.len() >= 2,\n@@ -111,8 +114,8 @@ struct InsertVisitor<'a, 'tcx: 'a, 'b> {\n     sole_expr: bool,\n }\n \n-impl<'a, 'tcx, 'v, 'b> Visitor<'v> for InsertVisitor<'a, 'tcx, 'b> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if_let_chain! {[\n             let ExprMethodCall(ref name, _, ref params) = expr.node,\n             params.len() == 3,\n@@ -144,4 +147,7 @@ impl<'a, 'tcx, 'v, 'b> Visitor<'v> for InsertVisitor<'a, 'tcx, 'b> {\n             walk_expr(self, expr);\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "f4181da3c2b704b42ceecc201c00cafc640bf76e", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -36,9 +36,9 @@ impl LintPass for UnportableVariant {\n     }\n }\n \n-impl LateLintPass for UnportableVariant {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n     #[allow(cast_possible_truncation, cast_sign_loss)]\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemEnum(ref def, _) = item.node {\n             for var in &def.variants {\n                 let variant = &var.node;"}, {"sha": "0bd1740c5459d2ee7232779864de22c04225da41", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,9 +1,7 @@\n //! lint on `use`ing all variants of an enum\n \n use rustc::hir::*;\n-use rustc::hir::def::Def;\n-use rustc::hir::map::Node::NodeItem;\n-use rustc::lint::{LateLintPass, LintPass, LateContext, LintArray, LintContext};\n+use rustc::lint::{LateLintPass, LintPass, LateContext, LintArray};\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use utils::span_lint;\n@@ -34,8 +32,8 @@ impl LintPass for EnumGlobUse {\n     }\n }\n \n-impl LateLintPass for EnumGlobUse {\n-    fn check_mod(&mut self, cx: &LateContext, m: &Mod, _: Span, _: NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n+    fn check_mod(&mut self, cx: &LateContext<'a, 'tcx>, m: &'tcx Mod, _: Span, _: NodeId) {\n         // only check top level `use` statements\n         for item in &m.item_ids {\n             self.lint_item(cx, cx.krate.item(item.id));\n@@ -48,24 +46,12 @@ impl EnumGlobUse {\n         if item.vis == Visibility::Public {\n             return; // re-exports are fine\n         }\n-        if let ItemUse(ref item_use) = item.node {\n-            if let ViewPath_::ViewPathGlob(_) = item_use.node {\n-                if let Some(def) = cx.tcx.def_map.borrow().get(&item.id) {\n-                    if let Some(node_id) = cx.tcx.map.as_local_node_id(def.full_def().def_id()) {\n-                        if let Some(NodeItem(it)) = cx.tcx.map.find(node_id) {\n-                            if let ItemEnum(..) = it.node {\n-                                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n-                            }\n-                        }\n-                    } else {\n-                        let child = cx.sess().cstore.item_children(def.full_def().def_id());\n-                        if let Some(child) = child.first() {\n-                            if let Def::Variant(..) = child.def {\n-                                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n-                            }\n-                        }\n-                    }\n-                }\n+        if let ItemUse(ref path, UseKind::Glob) = item.node {\n+            // FIXME: ask jseyfried why the qpath.def for `use std::cmp::Ordering::*;`\n+            // extracted through `ItemUse(ref qpath, UseKind::Glob)` is a `Mod` and not an `Enum`\n+            // if let Def::Enum(_) = path.def {\n+            if path.segments.last().and_then(|seg| seg.name.as_str().chars().next()).map_or(false, char::is_uppercase) {\n+                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n             }\n         }\n     }"}, {"sha": "e7b73809dff267fb15be73e236736d4a1b771385", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 53, "deletions": 12, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -28,6 +28,27 @@ declare_lint! {\n     \"enums where all variants share a prefix/postfix\"\n }\n \n+/// **What it does:** Detects enumeration variants that are prefixed or suffixed\n+/// by the same characters.\n+///\n+/// **Why is this bad?** Enumeration variant names should specify their variant,\n+/// not repeat the enumeration name.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// enum Cake {\n+///     BlackForestCake,\n+///     HummingbirdCake,\n+/// }\n+/// ```\n+declare_lint! {\n+    pub PUB_ENUM_VARIANT_NAMES,\n+    Allow,\n+    \"enums where all variants share a prefix/postfix\"\n+}\n+\n /// **What it does:** Detects type names that are prefixed or suffixed by the\n /// containing module's name.\n ///\n@@ -49,10 +70,13 @@ declare_lint! {\n \n /// **What it does:** Checks for modules that have the same name as their parent module\n ///\n-/// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and again `mod foo { .. }` in `foo.rs`.\n-///                      The expectation is that items inside the inner `mod foo { .. }` are then available\n+/// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and again `mod foo { ..\n+/// }` in `foo.rs`.\n+/// The expectation is that items inside the inner `mod foo { .. }` are then\n+/// available\n ///                      through `foo::x`, but they are only available through `foo::foo::x`.\n-///                      If this is done on purpose, it would be better to choose a more representative module name.\n+/// If this is done on purpose, it would be better to choose a more\n+/// representative module name.\n ///\n /// **Known problems:** None.\n ///\n@@ -78,13 +102,16 @@ pub struct EnumVariantNames {\n \n impl EnumVariantNames {\n     pub fn new(threshold: u64) -> EnumVariantNames {\n-        EnumVariantNames { modules: Vec::new(), threshold: threshold }\n+        EnumVariantNames {\n+            modules: Vec::new(),\n+            threshold: threshold,\n+        }\n     }\n }\n \n impl LintPass for EnumVariantNames {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(ENUM_VARIANT_NAMES, STUTTER, MODULE_INCEPTION)\n+        lint_array!(ENUM_VARIANT_NAMES, PUB_ENUM_VARIANT_NAMES, STUTTER, MODULE_INCEPTION)\n     }\n }\n \n@@ -108,18 +135,25 @@ fn partial_rmatch(post: &str, name: &str) -> usize {\n \n // FIXME: #600\n #[allow(while_let_on_iterator)]\n-fn check_variant(cx: &EarlyContext, threshold: u64, def: &EnumDef, item_name: &str,\n-                 item_name_chars: usize, span: Span) {\n+fn check_variant(\n+    cx: &EarlyContext,\n+    threshold: u64,\n+    def: &EnumDef,\n+    item_name: &str,\n+    item_name_chars: usize,\n+    span: Span,\n+    lint: &'static Lint\n+) {\n     if (def.variants.len() as u64) < threshold {\n         return;\n     }\n     for var in &def.variants {\n         let name = var2str(var);\n         if partial_match(item_name, &name) == item_name_chars {\n-            span_lint(cx, ENUM_VARIANT_NAMES, var.span, \"Variant name starts with the enum's name\");\n+            span_lint(cx, lint, var.span, \"Variant name starts with the enum's name\");\n         }\n         if partial_rmatch(item_name, &name) == item_name_chars {\n-            span_lint(cx, ENUM_VARIANT_NAMES, var.span, \"Variant name ends with the enum's name\");\n+            span_lint(cx, lint, var.span, \"Variant name ends with the enum's name\");\n         }\n     }\n     let first = var2str(&def.variants[0]);\n@@ -154,7 +188,7 @@ fn check_variant(cx: &EarlyContext, threshold: u64, def: &EnumDef, item_name: &s\n         (true, false) => (\"post\", post),\n     };\n     span_help_and_lint(cx,\n-                       ENUM_VARIANT_NAMES,\n+                       lint,\n                        span,\n                        &format!(\"All variants have the same {}fix: `{}`\", what, value),\n                        &format!(\"remove the {}fixes and use full paths to \\\n@@ -200,7 +234,10 @@ impl EarlyLintPass for EnumVariantNames {\n                 if !mod_camel.is_empty() {\n                     if mod_name == &item_name {\n                         if let ItemKind::Mod(..) = item.node {\n-                            span_lint(cx, MODULE_INCEPTION, item.span, \"module has the same name as its containing module\");\n+                            span_lint(cx,\n+                                      MODULE_INCEPTION,\n+                                      item.span,\n+                                      \"module has the same name as its containing module\");\n                         }\n                     }\n                     if item.vis == Visibility::Public {\n@@ -218,7 +255,11 @@ impl EarlyLintPass for EnumVariantNames {\n             }\n         }\n         if let ItemKind::Enum(ref def, _) = item.node {\n-            check_variant(cx, self.threshold, def, &item_name, item_name_chars, item.span);\n+            let lint = match item.vis {\n+                Visibility::Public => PUB_ENUM_VARIANT_NAMES,\n+                _ => ENUM_VARIANT_NAMES,\n+            };\n+            check_variant(cx, self.threshold, def, &item_name, item_name_chars, item.span, lint);\n         }\n         self.modules.push((item_name, item_camel));\n     }"}, {"sha": "bfc16a504570a93ee8a1c52e8429ba145fbda37e", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -32,8 +32,8 @@ impl LintPass for EqOp {\n     }\n }\n \n-impl LateLintPass for EqOp {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n             if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n                 span_lint(cx,\n@@ -48,19 +48,7 @@ impl LateLintPass for EqOp {\n \n fn is_valid_operator(op: &BinOp) -> bool {\n     match op.node {\n-        BiSub |\n-        BiDiv |\n-        BiEq |\n-        BiLt |\n-        BiLe |\n-        BiGt |\n-        BiGe |\n-        BiNe |\n-        BiAnd |\n-        BiOr |\n-        BiBitXor |\n-        BiBitAnd |\n-        BiBitOr => true,\n+        BiSub | BiDiv | BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr | BiBitXor | BiBitAnd | BiBitOr => true,\n         _ => false,\n     }\n }"}, {"sha": "ee415b36382439cd000855a40eba0543984133fa", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -46,7 +46,7 @@ fn is_non_trait_box(ty: ty::Ty) -> bool {\n     }\n }\n \n-struct EscapeDelegate<'a, 'tcx: 'a+'gcx, 'gcx: 'a> {\n+struct EscapeDelegate<'a, 'tcx: 'a + 'gcx, 'gcx: 'a> {\n     tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     set: NodeSet,\n     infcx: &'a InferCtxt<'a, 'gcx, 'gcx>,\n@@ -60,8 +60,16 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_fn(&mut self, cx: &LateContext, _: visit::FnKind, decl: &FnDecl, body: &Expr, _: Span, id: NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: visit::FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        body: &'tcx Expr,\n+        _: Span,\n+        id: NodeId\n+    ) {\n         let param_env = ty::ParameterEnvironment::for_item(cx.tcx, id);\n \n         let infcx = cx.tcx.borrowck_fake_infer_ctxt(param_env);\n@@ -90,7 +98,7 @@ impl LateLintPass for Pass {\n     }\n }\n \n-impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx, 'gcx> {\n+impl<'a, 'tcx: 'a + 'gcx, 'gcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx, 'gcx> {\n     fn consume(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, mode: ConsumeMode) {\n         if let Categorization::Local(lid) = cmt.cat {\n             if self.set.contains(&lid) {\n@@ -143,18 +151,26 @@ impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx, 'g\n         }\n \n     }\n-    fn borrow(&mut self, borrow_id: NodeId, _: Span, cmt: cmt<'tcx>, _: &ty::Region, _: ty::BorrowKind,\n-              loan_cause: LoanCause) {\n+    fn borrow(\n+        &mut self,\n+        borrow_id: NodeId,\n+        _: Span,\n+        cmt: cmt<'tcx>,\n+        _: &ty::Region,\n+        _: ty::BorrowKind,\n+        loan_cause: LoanCause\n+    ) {\n         use rustc::ty::adjustment::Adjust;\n \n         if let Categorization::Local(lid) = cmt.cat {\n             if self.set.contains(&lid) {\n-                if let Some(&Adjust::DerefRef { autoderefs, .. }) = self.tcx\n-                                                                        .tables\n-                                                                        .borrow()\n-                                                                        .adjustments\n-                                                                        .get(&borrow_id)\n-                                                                        .map(|a| &a.kind) {\n+                if let Some(&Adjust::DerefRef { autoderefs, .. }) =\n+                    self.tcx\n+                        .tables\n+                        .borrow()\n+                        .adjustments\n+                        .get(&borrow_id)\n+                        .map(|a| &a.kind) {\n                     if LoanCause::AutoRef == loan_cause {\n                         // x.foo()\n                         if autoderefs == 0 {\n@@ -165,14 +181,15 @@ impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx, 'g\n                     }\n                 } else if LoanCause::AddrOf == loan_cause {\n                     // &x\n-                    if let Some(&Adjust::DerefRef { autoderefs, .. }) = self.tcx\n-                                                                            .tables\n-                                                                            .borrow()\n-                                                                            .adjustments\n-                                                                            .get(&self.tcx\n-                                                                            .map\n-                                                                            .get_parent_node(borrow_id))\n-                                                                            .map(|a| &a.kind) {\n+                    if let Some(&Adjust::DerefRef { autoderefs, .. }) =\n+                        self.tcx\n+                            .tables\n+                            .borrow()\n+                            .adjustments\n+                            .get(&self.tcx\n+                                .map\n+                                .get_parent_node(borrow_id))\n+                            .map(|a| &a.kind) {\n                         if autoderefs <= 1 {\n                             // foo(&x) where no extra autoreffing is happening\n                             self.set.remove(&lid);\n@@ -190,7 +207,7 @@ impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx, 'g\n     fn mutate(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: MutateMode) {}\n }\n \n-impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> EscapeDelegate<'a, 'tcx, 'gcx> {\n+impl<'a, 'tcx: 'a + 'gcx, 'gcx: 'a> EscapeDelegate<'a, 'tcx, 'gcx> {\n     fn is_large_box(&self, ty: ty::Ty<'gcx>) -> bool {\n         // Large types need to be boxed to avoid stack\n         // overflows."}, {"sha": "f25014b6805e3b42b07c6ba01e497a09e2cfdd99", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -33,22 +33,23 @@ impl LintPass for EtaPass {\n     }\n }\n \n-impl LateLintPass for EtaPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n             ExprCall(_, ref args) |\n             ExprMethodCall(_, _, ref args) => {\n                 for arg in args {\n                     check_closure(cx, arg)\n                 }\n-            }\n+            },\n             _ => (),\n         }\n     }\n }\n \n fn check_closure(cx: &LateContext, expr: &Expr) {\n-    if let ExprClosure(_, ref decl, ref ex, _) = expr.node {\n+    if let ExprClosure(_, ref decl, eid, _) = expr.node {\n+        let ex = cx.tcx.map.expr(eid);\n         if let ExprCall(ref caller, ref args) = ex.node {\n             if args.len() != decl.inputs.len() {\n                 // Not the same number of arguments, there\n@@ -64,17 +65,16 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 // Is it an unsafe function? They don't implement the closure traits\n                 ty::TyFnDef(_, _, fn_ty) |\n                 ty::TyFnPtr(fn_ty) => {\n-                    if fn_ty.unsafety == Unsafety::Unsafe ||\n-                       fn_ty.sig.skip_binder().output.sty == ty::TyNever {\n+                    if fn_ty.unsafety == Unsafety::Unsafe || fn_ty.sig.skip_binder().output().sty == ty::TyNever {\n                         return;\n                     }\n-                }\n+                },\n                 _ => (),\n             }\n             for (a1, a2) in decl.inputs.iter().zip(args) {\n-                if let PatKind::Binding(_, ident, _) = a1.pat.node {\n+                if let PatKind::Binding(_, _, ident, _) = a1.pat.node {\n                     // XXXManishearth Should I be checking the binding mode here?\n-                    if let ExprPath(None, ref p) = a2.node {\n+                    if let ExprPath(QPath::Resolved(None, ref p)) = a2.node {\n                         if p.segments.len() != 1 {\n                             // If it's a proper path, it can't be a local variable\n                             return;"}, {"sha": "f83b3271d506ae207d0968469a41ec763ca71fc7", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 82, "deletions": 70, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use rustc::hir::*;\n use rustc::ty;\n use rustc::lint::*;\n@@ -56,45 +56,51 @@ impl LintPass for EvalOrderDependence {\n     }\n }\n \n-impl LateLintPass for EvalOrderDependence {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // Find a write to a local variable.\n         match expr.node {\n-            ExprAssign(ref lhs, _) | ExprAssignOp(_, ref lhs, _) => {\n-                if let ExprPath(None, ref path) = lhs.node {\n-                    if path.segments.len() == 1 {\n-                        let var = cx.tcx.expect_def(lhs.id).def_id();\n-                        let mut visitor = ReadVisitor {\n-                            cx: cx,\n-                            var: var,\n-                            write_expr: expr,\n-                            last_expr: expr,\n-                        };\n-                        check_for_unsequenced_reads(&mut visitor);\n+            ExprAssign(ref lhs, _) |\n+            ExprAssignOp(_, ref lhs, _) => {\n+                if let ExprPath(ref qpath) = lhs.node {\n+                    if let QPath::Resolved(_, ref path) = *qpath {\n+                        if path.segments.len() == 1 {\n+                            let var = cx.tcx.tables().qpath_def(qpath, lhs.id).def_id();\n+                            let mut visitor = ReadVisitor {\n+                                cx: cx,\n+                                var: var,\n+                                write_expr: expr,\n+                                last_expr: expr,\n+                            };\n+                            check_for_unsequenced_reads(&mut visitor);\n+                        }\n                     }\n                 }\n-            }\n-            _ => {}\n+            },\n+            _ => {},\n         }\n     }\n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         match stmt.node {\n-            StmtExpr(ref e, _) | StmtSemi(ref e, _) => DivergenceVisitor(cx).maybe_walk_expr(e),\n+            StmtExpr(ref e, _) |\n+            StmtSemi(ref e, _) => DivergenceVisitor { cx: cx }.maybe_walk_expr(e),\n             StmtDecl(ref d, _) => {\n                 if let DeclLocal(ref local) = d.node {\n                     if let Local { init: Some(ref e), .. } = **local {\n-                        DivergenceVisitor(cx).visit_expr(e);\n+                        DivergenceVisitor { cx: cx }.visit_expr(e);\n                     }\n                 }\n             },\n         }\n     }\n }\n \n-struct DivergenceVisitor<'a, 'tcx: 'a>(&'a LateContext<'a, 'tcx>);\n+struct DivergenceVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n \n impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n-    fn maybe_walk_expr(&mut self, e: &Expr) {\n+    fn maybe_walk_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n             ExprClosure(..) => {},\n             ExprMatch(ref e, ref arms, _) => {\n@@ -106,51 +112,52 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n                     // make sure top level arm expressions aren't linted\n                     self.maybe_walk_expr(&*arm.body);\n                 }\n-            }\n+            },\n             _ => walk_expr(self, e),\n         }\n     }\n     fn report_diverging_sub_expr(&mut self, e: &Expr) {\n-        span_lint(\n-            self.0,\n-            DIVERGING_SUB_EXPRESSION,\n-            e.span,\n-            \"sub-expression diverges\",\n-        );\n+        span_lint(self.cx, DIVERGING_SUB_EXPRESSION, e.span, \"sub-expression diverges\");\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for DivergenceVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, e: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprAgain(_) |\n-            ExprBreak(_, _) |\n-            ExprRet(_) => self.report_diverging_sub_expr(e),\n-            ExprCall(ref func, _) => match self.0.tcx.tables().expr_ty(func).sty {\n-                ty::TyFnDef(_, _, fn_ty) |\n-                ty::TyFnPtr(fn_ty) => if let ty::TyNever = self.0.tcx.erase_late_bound_regions(&fn_ty.sig).output.sty {\n-                    self.report_diverging_sub_expr(e);\n-                },\n-                _ => {},\n+            ExprAgain(_) | ExprBreak(_, _) | ExprRet(_) => self.report_diverging_sub_expr(e),\n+            ExprCall(ref func, _) => {\n+                match self.cx.tcx.tables().expr_ty(func).sty {\n+                    ty::TyFnDef(_, _, fn_ty) |\n+                    ty::TyFnPtr(fn_ty) => {\n+                        if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&fn_ty.sig).output().sty {\n+                            self.report_diverging_sub_expr(e);\n+                        }\n+                    },\n+                    _ => {},\n+                }\n             },\n             ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(e.id);\n-                let borrowed_table = self.0.tcx.tables.borrow();\n+                let borrowed_table = self.cx.tcx.tables.borrow();\n                 let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n                 let result_ty = method_type.ty.fn_ret();\n-                if let ty::TyNever = self.0.tcx.erase_late_bound_regions(&result_ty).sty {\n+                if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&result_ty).sty {\n                     self.report_diverging_sub_expr(e);\n                 }\n             },\n             _ => {\n-                // do not lint expressions referencing objects of type `!`, as that required a diverging expression to begin with\n+                // do not lint expressions referencing objects of type `!`, as that required a diverging expression\n+                // to begin with\n             },\n         }\n         self.maybe_walk_expr(e);\n     }\n-    fn visit_block(&mut self, _: &'v Block) {\n+    fn visit_block(&mut self, _: &'tcx Block) {\n         // don't continue over blocks, LateLintPass already does that\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n /// Walks up the AST from the the given write expression (`vis.write_expr`)\n@@ -188,7 +195,7 @@ fn check_for_unsequenced_reads(vis: &mut ReadVisitor) {\n                 // We reached the top of the function, stop.\n                 break;\n             },\n-            _ => { StopEarly::KeepGoing }\n+            _ => StopEarly::KeepGoing,\n         };\n         match stop_early {\n             StopEarly::Stop => break,\n@@ -207,7 +214,7 @@ enum StopEarly {\n     Stop,\n }\n \n-fn check_expr<'v, 't>(vis: & mut ReadVisitor<'v, 't>, expr: &'v Expr) -> StopEarly {\n+fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> StopEarly {\n     if expr.id == vis.last_expr.id {\n         return StopEarly::KeepGoing;\n     }\n@@ -222,7 +229,7 @@ fn check_expr<'v, 't>(vis: & mut ReadVisitor<'v, 't>, expr: &'v Expr) -> StopEar\n         ExprRepeat(_, _) |\n         ExprStruct(_, _, _) => {\n             walk_expr(vis, expr);\n-        }\n+        },\n         ExprBinary(op, _, _) |\n         ExprAssignOp(op, _, _) => {\n             if op.node == BiAnd || op.node == BiOr {\n@@ -231,7 +238,7 @@ fn check_expr<'v, 't>(vis: & mut ReadVisitor<'v, 't>, expr: &'v Expr) -> StopEar\n             } else {\n                 walk_expr(vis, expr);\n             }\n-        }\n+        },\n         ExprClosure(_, _, _, _) => {\n             // Either\n             //\n@@ -245,18 +252,18 @@ fn check_expr<'v, 't>(vis: & mut ReadVisitor<'v, 't>, expr: &'v Expr) -> StopEar\n             //\n             // This is also the only place we need to stop early (grrr).\n             return StopEarly::Stop;\n-        }\n+        },\n         // All other expressions either have only one child or strictly\n         // sequence the evaluation order of their sub-expressions.\n-        _ => {}\n+        _ => {},\n     }\n \n     vis.last_expr = expr;\n \n     StopEarly::KeepGoing\n }\n \n-fn check_stmt<'v, 't>(vis: &mut ReadVisitor<'v, 't>, stmt: &'v Stmt) -> StopEarly {\n+fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> StopEarly {\n     match stmt.node {\n         StmtExpr(ref expr, _) |\n         StmtSemi(ref expr, _) => check_expr(vis, expr),\n@@ -269,43 +276,45 @@ fn check_stmt<'v, 't>(vis: &mut ReadVisitor<'v, 't>, stmt: &'v Stmt) -> StopEarl\n             };\n             local.and_then(|local| local.init.as_ref())\n                 .map_or(StopEarly::KeepGoing, |expr| check_expr(vis, expr))\n-        }\n+        },\n     }\n }\n \n /// A visitor that looks for reads from a variable.\n-struct ReadVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>,\n+struct ReadVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     /// The id of the variable we're looking for.\n     var: DefId,\n     /// The expressions where the write to the variable occurred (for reporting\n     /// in the lint).\n-    write_expr: &'v Expr,\n+    write_expr: &'tcx Expr,\n     /// The last (highest in the AST) expression we've checked, so we know not\n     /// to recheck it.\n-    last_expr: &'v Expr,\n+    last_expr: &'tcx Expr,\n }\n \n-impl<'v, 't> Visitor<'v> for ReadVisitor<'v, 't> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if expr.id == self.last_expr.id {\n             return;\n         }\n \n         match expr.node {\n-            ExprPath(None, ref path) => {\n-                if path.segments.len() == 1 && self.cx.tcx.expect_def(expr.id).def_id() == self.var {\n-                    if is_in_assignment_position(self.cx, expr) {\n-                        // This is a write, not a read.\n-                    } else {\n-                        span_note_and_lint(\n-                            self.cx,\n-                            EVAL_ORDER_DEPENDENCE,\n-                            expr.span,\n-                            \"unsequenced read of a variable\",\n-                            self.write_expr.span,\n-                            \"whether read occurs before this write depends on evaluation order\"\n-                        );\n+            ExprPath(ref qpath) => {\n+                if let QPath::Resolved(None, ref path) = *qpath {\n+                    if path.segments.len() == 1 && self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id() == self.var {\n+                        if is_in_assignment_position(self.cx, expr) {\n+                            // This is a write, not a read.\n+                        } else {\n+                            span_note_and_lint(\n+                                self.cx,\n+                                EVAL_ORDER_DEPENDENCE,\n+                                expr.span,\n+                                \"unsequenced read of a variable\",\n+                                self.write_expr.span,\n+                                \"whether read occurs before this write depends on evaluation order\"\n+                            );\n+                        }\n                     }\n                 }\n             }\n@@ -332,6 +341,9 @@ impl<'v, 't> Visitor<'v> for ReadVisitor<'v, 't> {\n \n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n /// Returns true if `expr` is the LHS of an assignment, like `expr = ...`."}, {"sha": "1894a12a6d3ebc4dfbb9870fbffbeb486ff22861", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -38,33 +38,32 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let Some(span) = is_expn_of(cx, expr.span, \"format\") {\n             match expr.node {\n                 // `format!(\"{}\", foo)` expansion\n                 ExprCall(ref fun, ref args) => {\n                     if_let_chain!{[\n-                        let ExprPath(..) = fun.node,\n+                        let ExprPath(ref qpath) = fun.node,\n                         args.len() == 2,\n-                        let Some(fun) = resolve_node(cx, fun.id),\n-                        match_def_path(cx, fun.def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n+                        match_def_path(cx, resolve_node(cx, qpath, fun.id).def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n                         // ensure the format string is `\"{..}\"` with only one argument and no text\n                         check_static_str(cx, &args[0]),\n                         // ensure the format argument is `{}` ie. Display with no fancy option\n                         check_arg_is_display(cx, &args[1])\n                     ], {\n                         span_lint(cx, USELESS_FORMAT, span, \"useless use of `format!`\");\n                     }}\n-                }\n+                },\n                 // `format!(\"foo\")` expansion contains `match () { () => [], }`\n                 ExprMatch(ref matchee, _, _) => {\n                     if let ExprTup(ref tup) = matchee.node {\n                         if tup.is_empty() {\n                             span_lint(cx, USELESS_FORMAT, span, \"useless use of `format!`\");\n                         }\n                     }\n-                }\n+                },\n                 _ => (),\n             }\n         }\n@@ -73,8 +72,7 @@ impl LateLintPass for Pass {\n \n /// Returns the slice of format string parts in an `Arguments::new_v1` call.\n /// Public because it's shared with a lint in print.rs.\n-pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Expr)\n-                                         -> Option<Vec<InternedString>> {\n+pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Expr) -> Option<Vec<InternedString>> {\n     if_let_chain! {[\n         let ExprBlock(ref block) = expr.node,\n         block.stmts.len() == 1,\n@@ -129,9 +127,8 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n         exprs.len() == 1,\n         let ExprCall(_, ref args) = exprs[0].node,\n         args.len() == 2,\n-        let ExprPath(None, _) = args[1].node,\n-        let Some(fun) = resolve_node(cx, args[1].id),\n-        match_def_path(cx, fun.def_id(), &paths::DISPLAY_FMT_METHOD),\n+        let ExprPath(ref qpath) = args[1].node,\n+        match_def_path(cx, resolve_node(cx, qpath, args[1].id).def_id(), &paths::DISPLAY_FMT_METHOD),\n     ], {\n         let ty = walk_ptrs_ty(cx.tcx.tables().pat_ty(&pat[0]));\n "}, {"sha": "6fdedaeed43b8a9aa60bb60221a58d8226238ec9", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -62,7 +62,7 @@ impl EarlyLintPass for Formatting {\n                 (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Expr(ref second)) |\n                 (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Semi(ref second)) => {\n                     check_consecutive_ifs(cx, first, second);\n-                }\n+                },\n                 _ => (),\n             }\n         }"}, {"sha": "5ad676e57a088644b4f938256666c00e7e346b99", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -68,8 +68,16 @@ impl LintPass for Functions {\n     }\n }\n \n-impl LateLintPass for Functions {\n-    fn check_fn(&mut self, cx: &LateContext, kind: intravisit::FnKind, decl: &hir::FnDecl, expr: &hir::Expr, span: Span, nodeid: ast::NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: intravisit::FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl,\n+        expr: &'tcx hir::Expr,\n+        span: Span,\n+        nodeid: ast::NodeId\n+    ) {\n         use rustc::hir::map::Node::*;\n \n         let is_impl = if let Some(NodeItem(item)) = cx.tcx.map.find(cx.tcx.map.get_parent_node(nodeid)) {\n@@ -97,21 +105,22 @@ impl LateLintPass for Functions {\n         self.check_raw_ptr(cx, unsafety, decl, expr, nodeid);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n-        if let hir::MethodTraitItem(ref sig, ref expr) = item.node {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n+        if let hir::MethodTraitItem(ref sig, eid) = item.node {\n             // don't lint extern functions decls, it's not their fault\n             if sig.abi == Abi::Rust {\n                 self.check_arg_number(cx, &sig.decl, item.span);\n             }\n \n-            if let Some(ref expr) = *expr {\n+            if let Some(eid) = eid {\n+                let expr = cx.tcx.map.expr(eid);\n                 self.check_raw_ptr(cx, sig.unsafety, &sig.decl, expr, item.id);\n             }\n         }\n     }\n }\n \n-impl Functions {\n+impl<'a, 'tcx> Functions {\n     fn check_arg_number(&self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n         let args = decl.inputs.len() as u64;\n         if args > self.threshold {\n@@ -122,7 +131,14 @@ impl Functions {\n         }\n     }\n \n-    fn check_raw_ptr(&self, cx: &LateContext, unsafety: hir::Unsafety, decl: &hir::FnDecl, expr: &hir::Expr, nodeid: ast::NodeId) {\n+    fn check_raw_ptr(\n+        &self,\n+        cx: &LateContext<'a, 'tcx>,\n+        unsafety: hir::Unsafety,\n+        decl: &'tcx hir::FnDecl,\n+        expr: &'tcx hir::Expr,\n+        nodeid: ast::NodeId\n+    ) {\n         if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(nodeid) {\n             let raw_ptrs = decl.inputs.iter().filter_map(|arg| raw_ptr_arg(cx, arg)).collect::<HashSet<_>>();\n \n@@ -138,9 +154,9 @@ impl Functions {\n     }\n }\n \n-fn raw_ptr_arg(cx: &LateContext, arg: &hir::Arg) -> Option<hir::def_id::DefId> {\n-    if let (&hir::PatKind::Binding(_, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &arg.ty.node) {\n-        cx.tcx.def_map.borrow().get(&arg.pat.id).map(|pr| pr.full_def().def_id())\n+fn raw_ptr_arg(_cx: &LateContext, arg: &hir::Arg) -> Option<hir::def_id::DefId> {\n+    if let (&hir::PatKind::Binding(_, def_id, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &arg.ty.node) {\n+        Some(def_id)\n     } else {\n         None\n     }\n@@ -151,8 +167,8 @@ struct DerefVisitor<'a, 'tcx: 'a> {\n     ptrs: HashSet<hir::def_id::DefId>,\n }\n \n-impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for DerefVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'v hir::Expr) {\n+impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprCall(ref f, ref args) => {\n                 let ty = self.cx.tcx.tables().expr_ty(f);\n@@ -162,7 +178,7 @@ impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for DerefVisitor<'a, 'tcx> {\n                         self.check_arg(arg);\n                     }\n                 }\n-            }\n+            },\n             hir::ExprMethodCall(_, _, ref args) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let base_type = self.cx.tcx.tables.borrow().method_map[&method_call].ty;\n@@ -172,19 +188,23 @@ impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for DerefVisitor<'a, 'tcx> {\n                         self.check_arg(arg);\n                     }\n                 }\n-            }\n+            },\n             hir::ExprUnary(hir::UnDeref, ref ptr) => self.check_arg(ptr),\n             _ => (),\n         }\n \n         hir::intravisit::walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+        intravisit::NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr) {\n-        if let Some(def) = self.cx.tcx.def_map.borrow().get(&ptr.id) {\n-            if self.ptrs.contains(&def.full_def().def_id()) {\n+        if let hir::ExprPath(ref qpath) = ptr.node {\n+            let def = self.cx.tcx.tables().qpath_def(qpath, ptr.id);\n+            if self.ptrs.contains(&def.def_id()) {\n                 span_lint(self.cx,\n                           NOT_UNSAFE_PTR_ARG_DEREF,\n                           ptr.span,"}, {"sha": "a10a9523ac1b581e7c312c293bbbab0cf88aa9f7", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -31,8 +31,8 @@ impl LintPass for IdentityOp {\n     }\n }\n \n-impl LateLintPass for IdentityOp {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if in_macro(cx, e.span) {\n             return;\n         }\n@@ -41,17 +41,17 @@ impl LateLintPass for IdentityOp {\n                 BiAdd | BiBitOr | BiBitXor => {\n                     check(cx, left, 0, e.span, right.span);\n                     check(cx, right, 0, e.span, left.span);\n-                }\n+                },\n                 BiShl | BiShr | BiSub => check(cx, right, 0, e.span, left.span),\n                 BiMul => {\n                     check(cx, left, 1, e.span, right.span);\n                     check(cx, right, 1, e.span, left.span);\n-                }\n+                },\n                 BiDiv => check(cx, right, 1, e.span, left.span),\n                 BiBitAnd => {\n                     check(cx, left, -1, e.span, right.span);\n                     check(cx, right, -1, e.span, left.span);\n-                }\n+                },\n                 _ => (),\n             }\n         }"}, {"sha": "921cd7f8885e23cd1e07cfdb994cde7731519efa", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -42,48 +42,43 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n \n-        if let ExprMatch(ref op, ref arms, MatchSource::IfLetDesugar{..}) = expr.node {\n+        if let ExprMatch(ref op, ref arms, MatchSource::IfLetDesugar { .. }) = expr.node {\n \n             if arms[0].pats.len() == 1 {\n \n                 let good_method = match arms[0].pats[0].node {\n-                    PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 && pats[0].node == PatKind::Wild =>  {\n-\n+                    PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 && pats[0].node == PatKind::Wild => {\n                         if match_path(path, &paths::RESULT_OK) {\n                             \"is_ok()\"\n                         } else if match_path(path, &paths::RESULT_ERR) {\n                             \"is_err()\"\n                         } else if match_path(path, &paths::OPTION_SOME) {\n                             \"is_some()\"\n                         } else {\n-                            return\n+                            return;\n                         }\n-                    }\n+                    },\n \n-                    PatKind::Path(_, ref path) if match_path(path, &paths::OPTION_NONE) => {\n-                        \"is_none()\"\n-                    }\n+                    PatKind::Path(ref path) if match_path(path, &paths::OPTION_NONE) => \"is_none()\",\n \n-                    _ => return\n+                    _ => return,\n                 };\n \n                 span_lint_and_then(cx,\n                                    IF_LET_REDUNDANT_PATTERN_MATCHING,\n                                    arms[0].pats[0].span,\n                                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n                                    |db| {\n-                                        let span = Span {\n-                                            lo: expr.span.lo,\n-                                            hi: op.span.hi,\n-                                            expn_id: expr.span.expn_id,\n-                                        };\n-                                        db.span_suggestion(span,\n-                                                           \"try this\",\n-                                                           format!(\"if {}.{}\", snippet(cx, op.span, \"_\"), good_method));\n-                                    });\n+                    let span = Span {\n+                        lo: expr.span.lo,\n+                        hi: op.span.hi,\n+                        expn_id: expr.span.expn_id,\n+                    };\n+                    db.span_suggestion(span, \"try this\", format!(\"if {}.{}\", snippet(cx, op.span, \"_\"), good_method));\n+                });\n             }\n \n         }"}, {"sha": "72a3d485bd08069eb3187463150255f2e67a1667", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -55,14 +55,14 @@ impl EarlyLintPass for IfNotElse {\n                                            item.span,\n                                            \"Unnecessary boolean `not` operation\",\n                                            \"remove the `!` and swap the blocks of the if/else\");\n-                    }\n+                    },\n                     ExprKind::Binary(ref kind, _, _) if kind.node == BinOpKind::Ne => {\n                         span_help_and_lint(cx,\n                                            IF_NOT_ELSE,\n                                            item.span,\n                                            \"Unnecessary `!=` operation\",\n                                            \"change to `==` and swap the blocks of the if/else\");\n-                    }\n+                    },\n                     _ => (),\n                 }\n             }"}, {"sha": "3b3cd423729b78f6cb916f3444b8bdbed93ddecb", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -47,9 +47,10 @@ impl EarlyLintPass for ItemsAfterStatements {\n         }\n \n         // skip initial items\n-        let stmts = item.stmts.iter()\n-                              .map(|stmt| &stmt.node)\n-                              .skip_while(|s| matches!(**s, StmtKind::Item(..)));\n+        let stmts = item.stmts\n+            .iter()\n+            .map(|stmt| &stmt.node)\n+            .skip_while(|s| matches!(**s, StmtKind::Item(..)));\n \n         // lint on all further items\n         for stmt in stmts {"}, {"sha": "22835b4884033e1e79d2a419f0e693d425ff3b66", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -59,8 +59,8 @@ impl LintPass for LenZero {\n     }\n }\n \n-impl LateLintPass for LenZero {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if in_macro(cx, item.span) {\n             return;\n         }\n@@ -72,7 +72,7 @@ impl LateLintPass for LenZero {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if in_macro(cx, expr.span) {\n             return;\n         }\n@@ -107,8 +107,7 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItem]) {\n                 span_lint(cx,\n                           LEN_WITHOUT_IS_EMPTY,\n                           i.span,\n-                          &format!(\"trait `{}` has a `len` method but no `is_empty` method\",\n-                                   item.name));\n+                          &format!(\"trait `{}` has a `len` method but no `is_empty` method\", item.name));\n             }\n         }\n     }\n@@ -118,7 +117,8 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &ImplItemRef, name: &str) -> bool {\n         &*item.name.as_str() == name &&\n         if let AssociatedItemKind::Method { has_self } = item.kind {\n-            has_self && {\n+            has_self &&\n+            {\n                 let did = cx.tcx.map.local_def_id(item.id.node_id);\n                 let impl_ty = cx.tcx.item_type(did);\n                 impl_ty.fn_args().skip_binder().len() == 1\n@@ -146,9 +146,7 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n             span_lint(cx,\n                       LEN_WITHOUT_IS_EMPTY,\n                       i.span,\n-                      &format!(\"item `{}` has a public `len` method but {} `is_empty` method\",\n-                               ty,\n-                               is_empty));\n+                      &format!(\"item `{}` has a public `len` method but {} `is_empty` method\", ty, is_empty));\n         }\n     }\n }\n@@ -164,7 +162,7 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n         (&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) |\n         (&ExprMethodCall(ref method, _, ref args), &ExprLit(ref lit)) => {\n             check_len_zero(cx, span, &method.node, args, lit, op)\n-        }\n+        },\n         _ => (),\n     }\n }\n@@ -188,7 +186,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n             if &*item.name.as_str() == \"is_empty\" {\n                 let ty = cx.tcx.item_type(item.def_id).fn_sig().skip_binder();\n-                ty.inputs.len() == 1\n+                ty.inputs().len() == 1\n             } else {\n                 false\n             }\n@@ -199,20 +197,18 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n \n     /// Check the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext, id: DefId) -> bool {\n-        cx.tcx.inherent_impls.borrow().get(&id).map_or(false, |impls| impls.iter().any(|imp| {\n-            cx.tcx.associated_items(*imp).any(|item| {\n-                is_is_empty(cx, &item)\n-            })\n-        }))\n+        cx.tcx.inherent_impls.borrow().get(&id).map_or(false, |impls| {\n+            impls.iter().any(|imp| cx.tcx.associated_items(*imp).any(|item| is_is_empty(cx, &item)))\n+        })\n     }\n \n     let ty = &walk_ptrs_ty(cx.tcx.tables().expr_ty(expr));\n     match ty.sty {\n-        ty::TyTrait(_) => {\n+        ty::TyDynamic(..) => {\n             cx.tcx\n-              .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n-              .any(|item| is_is_empty(cx, &item))\n-        }\n+                .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n+                .any(|item| is_is_empty(cx, &item))\n+        },\n         ty::TyProjection(_) => ty.ty_to_def_id().map_or(false, |id| has_is_empty_impl(cx, id)),\n         ty::TyAdt(id, _) => has_is_empty_impl(cx, id.did),\n         ty::TyArray(..) | ty::TyStr => true,"}, {"sha": "88d74b01886335e69e58edbee8009119acaa78b1", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -57,27 +57,26 @@ impl LintPass for LetIfSeq {\n     }\n }\n \n-impl LateLintPass for LetIfSeq {\n-    fn check_block(&mut self, cx: &LateContext, block: &hir::Block) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block) {\n         let mut it = block.stmts.iter().peekable();\n         while let Some(stmt) = it.next() {\n             if_let_chain! {[\n                 let Some(expr) = it.peek(),\n                 let hir::StmtDecl(ref decl, _) = stmt.node,\n                 let hir::DeclLocal(ref decl) = decl.node,\n-                let hir::PatKind::Binding(mode, ref name, None) = decl.pat.node,\n-                let Some(def) = cx.tcx.def_map.borrow().get(&decl.pat.id),\n+                let hir::PatKind::Binding(mode, def_id, ref name, None) = decl.pat.node,\n                 let hir::StmtExpr(ref if_, _) = expr.node,\n                 let hir::ExprIf(ref cond, ref then, ref else_) = if_.node,\n-                !used_in_expr(cx, def.full_def().def_id(), cond),\n-                let Some(value) = check_assign(cx, def.full_def().def_id(), then),\n-                !used_in_expr(cx, def.full_def().def_id(), value),\n+                !used_in_expr(cx, def_id, cond),\n+                let Some(value) = check_assign(cx, def_id, then),\n+                !used_in_expr(cx, def_id, value),\n             ], {\n                 let span = codemap::mk_sp(stmt.span.lo, if_.span.hi);\n \n                 let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n                     if let hir::ExprBlock(ref else_) = else_.node {\n-                        if let Some(default) = check_assign(cx, def.full_def().def_id(), else_) {\n+                        if let Some(default) = check_assign(cx, def_id, else_) {\n                             (else_.stmts.len() > 1, default)\n                         } else if let Some(ref default) = decl.init {\n                             (true, &**default)\n@@ -134,29 +133,34 @@ struct UsedVisitor<'a, 'tcx: 'a> {\n     used: bool,\n }\n \n-impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for UsedVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'v hir::Expr) {\n+impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if_let_chain! {[\n-            let hir::ExprPath(None, _) = expr.node,\n-            let Some(def) = self.cx.tcx.def_map.borrow().get(&expr.id),\n-            self.id == def.full_def().def_id(),\n+            let hir::ExprPath(ref qpath) = expr.node,\n+            self.id == self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id(),\n         ], {\n             self.used = true;\n             return;\n         }}\n         hir::intravisit::walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> hir::intravisit::NestedVisitorMap<'this, 'tcx> {\n+        hir::intravisit::NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n-fn check_assign<'e>(cx: &LateContext, decl: hir::def_id::DefId, block: &'e hir::Block) -> Option<&'e hir::Expr> {\n+fn check_assign<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    decl: hir::def_id::DefId,\n+    block: &'tcx hir::Block\n+) -> Option<&'tcx hir::Expr> {\n     if_let_chain! {[\n         block.expr.is_none(),\n         let Some(expr) = block.stmts.iter().last(),\n         let hir::StmtSemi(ref expr, _) = expr.node,\n         let hir::ExprAssign(ref var, ref value) = expr.node,\n-        let hir::ExprPath(None, _) = var.node,\n-        let Some(def) = cx.tcx.def_map.borrow().get(&var.id),\n-        decl == def.full_def().def_id(),\n+        let hir::ExprPath(ref qpath) = var.node,\n+        decl == cx.tcx.tables().qpath_def(qpath, var.id).def_id(),\n     ], {\n         let mut v = UsedVisitor {\n             cx: cx,\n@@ -178,7 +182,7 @@ fn check_assign<'e>(cx: &LateContext, decl: hir::def_id::DefId, block: &'e hir::\n     None\n }\n \n-fn used_in_expr(cx: &LateContext, id: hir::def_id::DefId, expr: &hir::Expr) -> bool {\n+fn used_in_expr<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, id: hir::def_id::DefId, expr: &'tcx hir::Expr) -> bool {\n     let mut v = UsedVisitor {\n         cx: cx,\n         id: id,"}, {"sha": "06aab286b2fe6effdf60b5724169c8ca0449c33d", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -9,6 +9,7 @@\n #![feature(repeat_str)]\n \n #![allow(indexing_slicing, shadow_reuse, unknown_lints, missing_docs_in_private_items)]\n+#![allow(needless_lifetimes)]\n \n #[macro_use]\n extern crate syntax;\n@@ -115,6 +116,7 @@ pub mod precedence;\n pub mod print;\n pub mod ptr;\n pub mod ranges;\n+pub mod reference;\n pub mod regex;\n pub mod returns;\n pub mod serde;\n@@ -171,10 +173,22 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     };\n \n     let mut store = reg.sess.lint_store.borrow_mut();\n-    store.register_removed(\"unstable_as_slice\", \"`Vec::as_slice` has been stabilized in 1.7\");\n-    store.register_removed(\"unstable_as_mut_slice\", \"`Vec::as_mut_slice` has been stabilized in 1.7\");\n-    store.register_removed(\"str_to_string\", \"using `str::to_string` is common even today and specialization will likely happen soon\");\n-    store.register_removed(\"string_to_string\", \"using `string::to_string` is common even today and specialization will likely happen soon\");\n+    store.register_removed(\n+        \"unstable_as_slice\",\n+        \"`Vec::as_slice` has been stabilized in 1.7\",\n+    );\n+    store.register_removed(\n+        \"unstable_as_mut_slice\",\n+        \"`Vec::as_mut_slice` has been stabilized in 1.7\",\n+    );\n+    store.register_removed(\n+        \"str_to_string\",\n+        \"using `str::to_string` is common even today and specialization will likely happen soon\",\n+    );\n+    store.register_removed(\n+        \"string_to_string\",\n+        \"using `string::to_string` is common even today and specialization will likely happen soon\",\n+    );\n     // end deprecated lints, do not remove this comment, it\u2019s used in `update_lints`\n \n     reg.register_late_lint_pass(box serde::Serde);\n@@ -227,7 +241,9 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box map_clone::Pass);\n     reg.register_late_lint_pass(box temporary_assignment::Pass);\n     reg.register_late_lint_pass(box transmute::Transmute);\n-    reg.register_late_lint_pass(box cyclomatic_complexity::CyclomaticComplexity::new(conf.cyclomatic_complexity_threshold));\n+    reg.register_late_lint_pass(\n+        box cyclomatic_complexity::CyclomaticComplexity::new(conf.cyclomatic_complexity_threshold)\n+    );\n     reg.register_late_lint_pass(box escape::Pass{too_large_for_stack: conf.too_large_for_stack});\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n     reg.register_late_lint_pass(box array_indexing::ArrayIndexing);\n@@ -256,7 +272,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box functions::Functions::new(conf.too_many_arguments_threshold));\n     reg.register_early_lint_pass(box doc::Doc::new(conf.doc_valid_idents));\n     reg.register_late_lint_pass(box neg_multiply::NegMultiply);\n-    reg.register_late_lint_pass(box unsafe_removed_from_name::UnsafeNameRemoval);\n+    reg.register_early_lint_pass(box unsafe_removed_from_name::UnsafeNameRemoval);\n     reg.register_late_lint_pass(box mem_forget::MemForget);\n     reg.register_late_lint_pass(box arithmetic::Arithmetic::default());\n     reg.register_late_lint_pass(box assign_ops::AssignOps);\n@@ -266,6 +282,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box ok_if_let::Pass);\n     reg.register_late_lint_pass(box if_let_redundant_pattern_matching::Pass);\n     reg.register_late_lint_pass(box partialeq_ne_impl::Pass);\n+    reg.register_early_lint_pass(box reference::Pass);\n \n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -277,6 +294,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         booleans::NONMINIMAL_BOOL,\n         enum_glob_use::ENUM_GLOB_USE,\n+        enum_variants::PUB_ENUM_VARIANT_NAMES,\n         enum_variants::STUTTER,\n         if_not_else::IF_NOT_ELSE,\n         items_after_statements::ITEMS_AFTER_STATEMENTS,\n@@ -431,6 +449,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         ptr::PTR_ARG,\n         ranges::RANGE_STEP_BY_ZERO,\n         ranges::RANGE_ZIP_WITH_LEN,\n+        reference::DEREF_ADDROF,\n         regex::INVALID_REGEX,\n         regex::REGEX_MACRO,\n         regex::TRIVIAL_REGEX,"}, {"sha": "ba705a84089c3db6e33f5ee4787c2ef992659a60", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 67, "deletions": 58, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -2,10 +2,10 @@ use reexport::*;\n use rustc::lint::*;\n use rustc::hir::def::Def;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_ty, walk_ty_param_bound, walk_fn_decl, walk_generics};\n+use rustc::hir::intravisit::{Visitor, walk_ty, walk_ty_param_bound, walk_fn_decl, walk_generics, NestedVisitorMap};\n use std::collections::{HashSet, HashMap};\n use syntax::codemap::Span;\n-use utils::{in_external_macro, span_lint};\n+use utils::{in_external_macro, span_lint, last_path_segment};\n \n /// **What it does:** Checks for lifetime annotations which can be removed by\n /// relying on lifetime elision.\n@@ -56,20 +56,20 @@ impl LintPass for LifetimePass {\n     }\n }\n \n-impl LateLintPass for LifetimePass {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LifetimePass {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemFn(ref decl, _, _, _, ref generics, _) = item.node {\n             check_fn_inner(cx, decl, generics, item.span);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(ref sig, _) = item.node {\n             check_fn_inner(cx, &sig.decl, &sig.generics, item.span);\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n             check_fn_inner(cx, &sig.decl, &sig.generics, item.span);\n         }\n@@ -87,25 +87,25 @@ enum RefLt {\n fn bound_lifetimes(bound: &TyParamBound) -> HirVec<&Lifetime> {\n     if let TraitTyParamBound(ref trait_ref, _) = *bound {\n         trait_ref.trait_ref\n-                 .path\n-                 .segments\n-                 .last()\n-                 .expect(\"a path must have at least one segment\")\n-                 .parameters\n-                 .lifetimes()\n+            .path\n+            .segments\n+            .last()\n+            .expect(\"a path must have at least one segment\")\n+            .parameters\n+            .lifetimes()\n     } else {\n         HirVec::new()\n     }\n }\n \n-fn check_fn_inner(cx: &LateContext, decl: &FnDecl, generics: &Generics, span: Span) {\n+fn check_fn_inner<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, generics: &'tcx Generics, span: Span) {\n     if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n \n     let bounds_lts = generics.ty_params\n-                             .iter()\n-                             .flat_map(|typ| typ.bounds.iter().flat_map(bound_lifetimes));\n+        .iter()\n+        .flat_map(|typ| typ.bounds.iter().flat_map(bound_lifetimes));\n \n     if could_use_elision(cx, decl, &generics.lifetimes, bounds_lts) {\n         span_lint(cx,\n@@ -116,9 +116,12 @@ fn check_fn_inner(cx: &LateContext, decl: &FnDecl, generics: &Generics, span: Sp\n     report_extra_lifetimes(cx, decl, generics);\n }\n \n-fn could_use_elision<'a, T: Iterator<Item = &'a Lifetime>>(cx: &LateContext, func: &FnDecl,\n-                                                           named_lts: &[LifetimeDef], bounds_lts: T)\n-                                                           -> bool {\n+fn could_use_elision<'a, 'tcx: 'a, T: Iterator<Item = &'tcx Lifetime>>(\n+    cx: &LateContext<'a, 'tcx>,\n+    func: &'tcx FnDecl,\n+    named_lts: &'tcx [LifetimeDef],\n+    bounds_lts: T\n+) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n@@ -210,8 +213,8 @@ fn unique_lifetimes(lts: &[RefLt]) -> usize {\n }\n \n /// A visitor usable for `rustc_front::visit::walk_ty()`.\n-struct RefVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>,\n+struct RefVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     lts: Vec<RefLt>,\n }\n \n@@ -239,56 +242,57 @@ impl<'v, 't> RefVisitor<'v, 't> {\n         self.lts\n     }\n \n-    fn collect_anonymous_lifetimes(&mut self, path: &Path, ty: &Ty) {\n-        let last_path_segment = path.segments.last().map(|s| &s.parameters);\n-        if let Some(&AngleBracketedParameters(ref params)) = last_path_segment {\n+    fn collect_anonymous_lifetimes(&mut self, qpath: &QPath, ty: &Ty) {\n+        let last_path_segment = &last_path_segment(qpath).parameters;\n+        if let AngleBracketedParameters(ref params) = *last_path_segment {\n             if params.lifetimes.is_empty() {\n-                if let Some(def) = self.cx.tcx.def_map.borrow().get(&ty.id).map(|r| r.full_def()) {\n-                    match def {\n-                        Def::TyAlias(def_id) |\n-                        Def::Struct(def_id) => {\n-                            let generics = self.cx.tcx.item_generics(def_id);\n-                            for _ in generics.regions.as_slice() {\n-                                self.record(&None);\n-                            }\n+                match self.cx.tcx.tables().qpath_def(qpath, ty.id) {\n+                    Def::TyAlias(def_id) |\n+                    Def::Struct(def_id) => {\n+                        let generics = self.cx.tcx.item_generics(def_id);\n+                        for _ in generics.regions.as_slice() {\n+                            self.record(&None);\n                         }\n-                        Def::Trait(def_id) => {\n-                            let trait_def = self.cx.tcx.trait_defs.borrow()[&def_id];\n-                            for _ in &trait_def.generics.regions {\n-                                self.record(&None);\n-                            }\n+                    },\n+                    Def::Trait(def_id) => {\n+                        let trait_def = self.cx.tcx.trait_defs.borrow()[&def_id];\n+                        for _ in &self.cx.tcx.item_generics(trait_def.def_id).regions {\n+                            self.record(&None);\n                         }\n-                        _ => (),\n-                    }\n+                    },\n+                    _ => (),\n                 }\n             }\n         }\n     }\n }\n \n-impl<'v, 't> Visitor<'v> for RefVisitor<'v, 't> {\n+impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n     // for lifetimes as parameters of generics\n-    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n         self.record(&Some(*lifetime));\n     }\n \n-    fn visit_ty(&mut self, ty: &'v Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx Ty) {\n         match ty.node {\n             TyRptr(None, _) => {\n                 self.record(&None);\n-            }\n-            TyPath(_, ref path) => {\n+            },\n+            TyPath(ref path) => {\n                 self.collect_anonymous_lifetimes(path, ty);\n-            }\n+            },\n             _ => (),\n         }\n         walk_ty(self, ty);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n }\n \n /// Are any lifetimes mentioned in the `where` clause? If yes, we don't try to\n /// reason about elision.\n-fn has_where_lifetimes(cx: &LateContext, where_clause: &WhereClause) -> bool {\n+fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &'tcx WhereClause) -> bool {\n     for predicate in &where_clause.predicates {\n         match *predicate {\n             WherePredicate::RegionPredicate(..) => return true,\n@@ -312,47 +316,52 @@ fn has_where_lifetimes(cx: &LateContext, where_clause: &WhereClause) -> bool {\n                         return true;\n                     }\n                 }\n-            }\n+            },\n             WherePredicate::EqPredicate(ref pred) => {\n                 let mut visitor = RefVisitor::new(cx);\n                 walk_ty(&mut visitor, &pred.ty);\n                 if !visitor.lts.is_empty() {\n                     return true;\n                 }\n-            }\n+            },\n         }\n     }\n     false\n }\n \n-struct LifetimeChecker(HashMap<Name, Span>);\n+struct LifetimeChecker {\n+    map: HashMap<Name, Span>,\n+}\n \n-impl<'v> Visitor<'v> for LifetimeChecker {\n+impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n     // for lifetimes as parameters of generics\n-    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n-        self.0.remove(&lifetime.name);\n+    fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n+        self.map.remove(&lifetime.name);\n     }\n \n-    fn visit_lifetime_def(&mut self, _: &'v LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, _: &'tcx LifetimeDef) {\n         // don't actually visit `<'a>` or `<'a: 'b>`\n         // we've already visited the `'a` declarations and\n         // don't want to spuriously remove them\n         // `'b` in `'a: 'b` is useless unless used elsewhere in\n         // a non-lifetime bound\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n }\n \n-fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl, generics: &Generics) {\n+fn report_extra_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, func: &'tcx FnDecl, generics: &'tcx Generics) {\n     let hs = generics.lifetimes\n-                     .iter()\n-                     .map(|lt| (lt.lifetime.name, lt.lifetime.span))\n-                     .collect();\n-    let mut checker = LifetimeChecker(hs);\n+        .iter()\n+        .map(|lt| (lt.lifetime.name, lt.lifetime.span))\n+        .collect();\n+    let mut checker = LifetimeChecker { map: hs };\n \n     walk_generics(&mut checker, generics);\n     walk_fn_decl(&mut checker, func);\n \n-    for &v in checker.0.values() {\n+    for &v in checker.map.values() {\n         span_lint(cx, UNUSED_LIFETIMES, v, \"this lifetime isn't used in the function definition\");\n     }\n }"}, {"sha": "9a3defec72df682535d76925c32c269dcf4bf0c8", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 169, "deletions": 134, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -2,7 +2,7 @@ use reexport::*;\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, walk_decl};\n+use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, walk_decl, NestedVisitorMap};\n use rustc::hir::map::Node::NodeBlock;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n@@ -14,9 +14,9 @@ use std::collections::HashMap;\n use syntax::ast;\n use utils::sugg;\n \n-use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, multispan_sugg,\n-            in_external_macro, is_refutable, span_help_and_lint, is_integer_literal,\n-            get_enclosing_block, span_lint_and_then, higher, walk_ptrs_ty};\n+use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, multispan_sugg, in_external_macro,\n+            is_refutable, span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, higher,\n+            walk_ptrs_ty, last_path_segment};\n use utils::paths;\n \n /// **What it does:** Checks for looping over the range of `0..len` of some\n@@ -307,8 +307,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let Some((pat, arg, body)) = higher::for_loop(expr) {\n             check_for_loop(cx, pat, arg, body, expr);\n         }\n@@ -334,8 +334,7 @@ impl LateLintPass for Pass {\n                     match *source {\n                         MatchSource::Normal |\n                         MatchSource::IfLetDesugar { .. } => {\n-                            if arms.len() == 2 &&\n-                               arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+                            if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n                                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n                                is_break_expr(&arms[1].body) {\n                                 if in_external_macro(cx, expr.span) {\n@@ -352,47 +351,42 @@ impl LateLintPass for Pass {\n                                                    expr.span,\n                                                    \"this loop could be written as a `while let` loop\",\n                                                    |db| {\n-                                                       let sug = format!(\"while let {} = {} {{ .. }}\",\n-                                                                         snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                                                         snippet(cx, matchexpr.span, \"..\"));\n-                                                       db.span_suggestion(expr.span, \"try\", sug);\n-                                                   });\n+                                    let sug = format!(\"while let {} = {} {{ .. }}\",\n+                                                      snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                                      snippet(cx, matchexpr.span, \"..\"));\n+                                    db.span_suggestion(expr.span, \"try\", sug);\n+                                });\n                             }\n-                        }\n+                        },\n                         _ => (),\n                     }\n                 }\n             }\n         }\n         if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n-            if let (&PatKind::TupleStruct(ref path, ref pat_args, _),\n+            if let (&PatKind::TupleStruct(ref qpath, ref pat_args, _),\n                     &ExprMethodCall(method_name, _, ref method_args)) = (pat, &match_expr.node) {\n                 let iter_expr = &method_args[0];\n-                if let Some(lhs_constructor) = path.segments.last() {\n-                    if &*method_name.node.as_str() == \"next\" &&\n-                       match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                       &*lhs_constructor.name.as_str() == \"Some\" &&\n-                       !is_refutable(cx, &pat_args[0]) &&\n-                       !is_iterator_used_after_while_let(cx, iter_expr) {\n-                        let iterator = snippet(cx, method_args[0].span, \"_\");\n-                        let loop_var = snippet(cx, pat_args[0].span, \"_\");\n-                        span_lint_and_then(cx,\n-                                           WHILE_LET_ON_ITERATOR,\n-                                           expr.span,\n-                                           \"this loop could be written as a `for` loop\",\n-                                           |db| {\n-                        db.span_suggestion(expr.span,\n-                                           \"try\",\n-                                           format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n-                        });\n-                    }\n+                let lhs_constructor = last_path_segment(qpath);\n+                if &*method_name.node.as_str() == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n+                   &*lhs_constructor.name.as_str() == \"Some\" && !is_refutable(cx, &pat_args[0]) &&\n+                   !is_iterator_used_after_while_let(cx, iter_expr) {\n+                    let iterator = snippet(cx, method_args[0].span, \"_\");\n+                    let loop_var = snippet(cx, pat_args[0].span, \"_\");\n+                    span_lint_and_then(cx,\n+                                       WHILE_LET_ON_ITERATOR,\n+                                       expr.span,\n+                                       \"this loop could be written as a `for` loop\",\n+                                       |db| {\n+                        db.span_suggestion(expr.span, \"try\", format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n+                    });\n                 }\n             }\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n                 if args.len() == 1 && &*method.node.as_str() == \"collect\" &&\n@@ -408,7 +402,13 @@ impl LateLintPass for Pass {\n     }\n }\n \n-fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n+fn check_for_loop<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr\n+) {\n     check_for_loop_range(cx, pat, arg, body, expr);\n     check_for_loop_reverse_range(cx, arg, expr);\n     check_for_loop_arg(cx, pat, arg, expr);\n@@ -418,13 +418,19 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n \n /// Check for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n-fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n+fn check_for_loop_range<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr\n+) {\n     if let Some(higher::Range { start: Some(start), ref end, limits }) = higher::range(arg) {\n         // the var must be a single name\n-        if let PatKind::Binding(_, ref ident, _) = pat.node {\n+        if let PatKind::Binding(_, def_id, ref ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n                 cx: cx,\n-                var: cx.tcx.expect_def(pat.id).def_id(),\n+                var: def_id,\n                 indexed: HashMap::new(),\n                 nonindex: false,\n             };\n@@ -433,9 +439,9 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n             // linting condition: we only indexed one variable\n             if visitor.indexed.len() == 1 {\n                 let (indexed, indexed_extent) = visitor.indexed\n-                                                       .into_iter()\n-                                                       .next()\n-                                                       .unwrap_or_else(|| unreachable!() /* len == 1 */);\n+                    .into_iter()\n+                    .next()\n+                    .unwrap_or_else(|| unreachable!() /* len == 1 */);\n \n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n@@ -461,10 +467,8 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                             ast::RangeLimits::Closed => {\n                                 let end = sugg::Sugg::hir(cx, end, \"<count>\");\n                                 format!(\".take({})\", end + sugg::ONE)\n-                            }\n-                            ast::RangeLimits::HalfOpen => {\n-                                format!(\".take({})\", snippet(cx, end.span, \"..\"))\n-                            }\n+                            },\n+                            ast::RangeLimits::HalfOpen => format!(\".take({})\", snippet(cx, end.span, \"..\")),\n                         }\n                     }\n                 } else {\n@@ -477,10 +481,10 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                                        expr.span,\n                                        &format!(\"the loop variable `{}` is used to index `{}`\", ident.node, indexed),\n                                        |db| {\n-                        multispan_sugg(db, \"consider using an iterator\".to_string(), &[\n-                            (pat.span, &format!(\"({}, <item>)\", ident.node)),\n-                            (arg.span, &format!(\"{}.iter().enumerate(){}{}\", indexed, take, skip)),\n-                        ]);\n+                        multispan_sugg(db,\n+                                       \"consider using an iterator\".to_string(),\n+                                       &[(pat.span, &format!(\"({}, <item>)\", ident.node)),\n+                                         (arg.span, &format!(\"{}.iter().enumerate(){}{}\", indexed, take, skip))]);\n                     });\n                 } else {\n                     let repl = if starts_at_zero && take.is_empty() {\n@@ -492,12 +496,13 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                     span_lint_and_then(cx,\n                                        NEEDLESS_RANGE_LOOP,\n                                        expr.span,\n-                                       &format!(\"the loop variable `{}` is only used to index `{}`.\", ident.node, indexed),\n+                                       &format!(\"the loop variable `{}` is only used to index `{}`.\",\n+                                                ident.node,\n+                                                indexed),\n                                        |db| {\n-                        multispan_sugg(db, \"consider using an iterator\".to_string(), &[\n-                            (pat.span, \"<item>\"),\n-                            (arg.span, &repl),\n-                        ]);\n+                        multispan_sugg(db,\n+                                       \"consider using an iterator\".to_string(),\n+                                       &[(pat.span, \"<item>\"), (arg.span, &repl)]);\n                     });\n                 }\n             }\n@@ -510,7 +515,7 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n         let ExprMethodCall(method, _, ref len_args) = expr.node,\n         len_args.len() == 1,\n         &*method.node.as_str() == \"len\",\n-        let ExprPath(_, ref path) = len_args[0].node,\n+        let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node,\n         path.segments.len() == 1,\n         &path.segments[0].name == var\n     ], {\n@@ -533,7 +538,7 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n                 let (sup, eq) = match (start_idx, end_idx) {\n                     (ConstVal::Integral(start_idx), ConstVal::Integral(end_idx)) => {\n                         (start_idx > end_idx, start_idx == end_idx)\n-                    }\n+                    },\n                     _ => (false, false),\n                 };\n \n@@ -551,15 +556,14 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n                                        expr.span,\n                                        \"this range is empty so this for loop will never run\",\n                                        |db| {\n-                                           db.span_suggestion(arg.span,\n-                                                              \"consider using the following if \\\n-                                                               you are attempting to iterate \\\n-                                                               over this range in reverse\",\n-                                                              format!(\"({end}{dots}{start}).rev()\",\n-                                                                      end=end_snippet,\n-                                                                      dots=dots,\n-                                                                      start=start_snippet));\n-                                       });\n+                        db.span_suggestion(arg.span,\n+                                           \"consider using the following if you are attempting to iterate over this \\\n+                                            range in reverse\",\n+                                           format!(\"({end}{dots}{start}).rev()\",\n+                                                   end = end_snippet,\n+                                                   dots = dots,\n+                                                   start = start_snippet));\n+                    });\n                 } else if eq && limits != ast::RangeLimits::Closed {\n                     // if they are equal, it's also problematic - this loop\n                     // will never run.\n@@ -597,14 +601,14 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                                        method_name));\n                 }\n             } else if &*method_name.as_str() == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n-                    let object = snippet(cx, args[0].span, \"_\");\n-                    span_lint(cx,\n-                              EXPLICIT_INTO_ITER_LOOP,\n-                              expr.span,\n-                              &format!(\"it is more idiomatic to loop over `{}` instead of `{}.{}()`\",\n-                                       object,\n-                                       object,\n-                                       method_name));\n+                let object = snippet(cx, args[0].span, \"_\");\n+                span_lint(cx,\n+                          EXPLICIT_INTO_ITER_LOOP,\n+                          expr.span,\n+                          &format!(\"it is more idiomatic to loop over `{}` instead of `{}.{}()`\",\n+                                   object,\n+                                   object,\n+                                   method_name));\n \n             } else if &*method_name.as_str() == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n                 span_lint(cx,\n@@ -647,7 +651,12 @@ fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n     }\n }\n \n-fn check_for_loop_explicit_counter(cx: &LateContext, arg: &Expr, body: &Expr, expr: &Expr) {\n+fn check_for_loop_explicit_counter<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr\n+) {\n     // Look for variables that are incremented once per loop iteration.\n     let mut visitor = IncrementVisitor {\n         cx: cx,\n@@ -692,14 +701,20 @@ fn check_for_loop_explicit_counter(cx: &LateContext, arg: &Expr, body: &Expr, ex\n }\n \n /// Check for the `FOR_KV_MAP` lint.\n-fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n+fn check_for_loop_over_map_kv<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr\n+) {\n     let pat_span = pat.span;\n \n     if let PatKind::Tuple(ref pat, _) = pat.node {\n         if pat.len() == 2 {\n             let (new_pat_span, kind) = match (&pat[0].node, &pat[1].node) {\n-                (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\"),\n-                (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\"),\n+                (key, _) if pat_is_wild(cx, key, body) => (pat[1].span, \"value\"),\n+                (_, value) if pat_is_wild(cx, value, body) => (pat[0].span, \"key\"),\n                 _ => return,\n             };\n \n@@ -717,10 +732,10 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n                                    &format!(\"you seem to want to iterate on a map's {}s\", kind),\n                                    |db| {\n                     let map = sugg::Sugg::hir(cx, arg, \"map\");\n-                    multispan_sugg(db, \"use the corresponding method\".into(), &[\n-                        (pat_span, &snippet(cx, new_pat_span, kind)),\n-                        (arg_span, &format!(\"{}.{}s()\", map.maybe_par(), kind)),\n-                    ]);\n+                    multispan_sugg(db,\n+                                   \"use the corresponding method\".into(),\n+                                   &[(pat_span, &snippet(cx, new_pat_span, kind)),\n+                                     (arg_span, &format!(\"{}.{}s()\", map.maybe_par(), kind))]);\n                 });\n             }\n         }\n@@ -729,29 +744,31 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n }\n \n /// Return true if the pattern is a `PatWild` or an ident prefixed with `'_'`.\n-fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n+fn pat_is_wild<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, pat: &'tcx PatKind, body: &'tcx Expr) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n-        PatKind::Binding(_, ident, None) if ident.node.as_str().starts_with('_') => {\n+        PatKind::Binding(_, _, ident, None) if ident.node.as_str().starts_with('_') => {\n             let mut visitor = UsedVisitor {\n                 var: ident.node,\n                 used: false,\n+                cx: cx,\n             };\n             walk_expr(&mut visitor, body);\n             !visitor.used\n-        }\n+        },\n         _ => false,\n     }\n }\n \n-struct UsedVisitor {\n+struct UsedVisitor<'a, 'tcx: 'a> {\n     var: ast::Name, // var to look for\n     used: bool, // has the var been used otherwise?\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'a> Visitor<'a> for UsedVisitor {\n-    fn visit_expr(&mut self, expr: &Expr) {\n-        if let ExprPath(None, ref path) = expr.node {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let ExprPath(QPath::Resolved(None, ref path)) = expr.node {\n             if path.segments.len() == 1 && path.segments[0].name == self.var {\n                 self.used = true;\n                 return;\n@@ -760,31 +777,35 @@ impl<'a> Visitor<'a> for UsedVisitor {\n \n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n-struct VarVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>, // context reference\n+struct VarVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>, // context reference\n     var: DefId, // var name to look for as index\n     indexed: HashMap<Name, Option<CodeExtent>>, // indexed variables, the extent is None for global\n     nonindex: bool, // has the var been used otherwise?\n }\n \n-impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n-        if let ExprPath(None, ref path) = expr.node {\n-            if path.segments.len() == 1 && self.cx.tcx.expect_def(expr.id).def_id() == self.var {\n-                // we are referencing our variable! now check if it's as an index\n-                if_let_chain! {[\n-                    let Some(parexpr) = get_parent_expr(self.cx, expr),\n-                    let ExprIndex(ref seqexpr, _) = parexpr.node,\n-                    let ExprPath(None, ref seqvar) = seqexpr.node,\n-                    seqvar.segments.len() == 1\n-                ], {\n-                    let def_map = self.cx.tcx.def_map.borrow();\n-                    if let Some(def) = def_map.get(&seqexpr.id) {\n-                        match def.base_def {\n+impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let ExprPath(ref qpath) = expr.node {\n+            if let QPath::Resolved(None, ref path) = *qpath {\n+                if path.segments.len() == 1 && self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id() == self.var {\n+                    // we are referencing our variable! now check if it's as an index\n+                    if_let_chain! {[\n+                        let Some(parexpr) = get_parent_expr(self.cx, expr),\n+                        let ExprIndex(ref seqexpr, _) = parexpr.node,\n+                        let ExprPath(ref seqpath) = seqexpr.node,\n+                        let QPath::Resolved(None, ref seqvar) = *seqpath,\n+                        seqvar.segments.len() == 1\n+                    ], {\n+                        let def = self.cx.tcx.tables().qpath_def(seqpath, seqexpr.id);\n+                        match def {\n                             Def::Local(..) | Def::Upvar(..) => {\n-                                let def_id = def.base_def.def_id();\n+                                let def_id = def.def_id();\n                                 let node_id = self.cx.tcx.map.as_local_node_id(def_id).unwrap();\n \n                                 let extent = self.cx.tcx.region_maps.var_scope(node_id);\n@@ -797,18 +818,21 @@ impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n                             }\n                             _ => (),\n                         }\n-                    }\n-                }}\n-                // we are not indexing anything, record that\n-                self.nonindex = true;\n-                return;\n+                    }}\n+                    // we are not indexing anything, record that\n+                    self.nonindex = true;\n+                    return;\n+                }\n             }\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n-fn is_iterator_used_after_while_let(cx: &LateContext, iter_expr: &Expr) -> bool {\n+fn is_iterator_used_after_while_let<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, iter_expr: &'tcx Expr) -> bool {\n     let def_id = match var_def_id(cx, iter_expr) {\n         Some(id) => id,\n         None => return false,\n@@ -826,16 +850,16 @@ fn is_iterator_used_after_while_let(cx: &LateContext, iter_expr: &Expr) -> bool\n     visitor.var_used_after_while_let\n }\n \n-struct VarUsedAfterLoopVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>,\n+struct VarUsedAfterLoopVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     def_id: NodeId,\n     iter_expr_id: NodeId,\n     past_while_let: bool,\n     var_used_after_while_let: bool,\n }\n \n-impl<'v, 't> Visitor<'v> for VarUsedAfterLoopVisitor<'v, 't> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if self.past_while_let {\n             if Some(self.def_id) == var_def_id(self.cx, expr) {\n                 self.var_used_after_while_let = true;\n@@ -845,6 +869,9 @@ impl<'v, 't> Visitor<'v> for VarUsedAfterLoopVisitor<'v, 't> {\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n \n@@ -900,10 +927,11 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n         Some(ref expr) if block.stmts.is_empty() => Some(expr),\n         None if !block.stmts.is_empty() => {\n             match block.stmts[0].node {\n-                StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => Some(expr),\n+                StmtExpr(ref expr, _) |\n+                StmtSemi(ref expr, _) => Some(expr),\n                 StmtDecl(..) => None,\n             }\n-        }\n+        },\n         _ => None,\n     }\n }\n@@ -917,7 +945,7 @@ fn is_break_expr(expr: &Expr) -> bool {\n                 Some(subexpr) => is_break_expr(subexpr),\n                 None => false,\n             }\n-        }\n+        },\n         _ => false,\n     }\n }\n@@ -935,15 +963,15 @@ enum VarState {\n }\n \n /// Scan a for loop for variables that are incremented exactly once.\n-struct IncrementVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>, // context reference\n+struct IncrementVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>, // context reference\n     states: HashMap<NodeId, VarState>, // incremented variables\n     depth: u32, // depth of conditional expressions\n     done: bool,\n }\n \n-impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if self.done {\n             return;\n         }\n@@ -966,7 +994,7 @@ impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n                                 *state = VarState::DontWarn;\n                             }\n                         }\n-                    }\n+                    },\n                     ExprAssign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n                     ExprAddrOf(mutability, _) if mutability == MutMutable => *state = VarState::DontWarn,\n                     _ => (),\n@@ -984,25 +1012,28 @@ impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n /// Check whether a variable is initialized to zero at the start of a loop.\n-struct InitializeVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>, // context reference\n-    end_expr: &'v Expr, // the for loop. Stop scanning here.\n+struct InitializeVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>, // context reference\n+    end_expr: &'tcx Expr, // the for loop. Stop scanning here.\n     var_id: NodeId,\n     state: VarState,\n     name: Option<Name>,\n     depth: u32, // depth of conditional expressions\n     past_loop: bool,\n }\n \n-impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n-    fn visit_decl(&mut self, decl: &'v Decl) {\n+impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n+    fn visit_decl(&mut self, decl: &'tcx Decl) {\n         // Look for declarations of the variable\n         if let DeclLocal(ref local) = decl.node {\n             if local.pat.id == self.var_id {\n-                if let PatKind::Binding(_, ref ident, _) = local.pat.node {\n+                if let PatKind::Binding(_, _, ref ident, _) = local.pat.node {\n                     self.name = Some(ident.node);\n \n                     self.state = if let Some(ref init) = local.init {\n@@ -1020,7 +1051,7 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n         walk_decl(self, decl);\n     }\n \n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if self.state == VarState::DontWarn {\n             return;\n         }\n@@ -1040,14 +1071,14 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n                 match parent.node {\n                     ExprAssignOp(_, ref lhs, _) if lhs.id == expr.id => {\n                         self.state = VarState::DontWarn;\n-                    }\n+                    },\n                     ExprAssign(ref lhs, ref rhs) if lhs.id == expr.id => {\n                         self.state = if is_integer_literal(rhs, 0) && self.depth == 0 {\n                             VarState::Warn\n                         } else {\n                             VarState::DontWarn\n                         }\n-                    }\n+                    },\n                     ExprAddrOf(mutability, _) if mutability == MutMutable => self.state = VarState::DontWarn,\n                     _ => (),\n                 }\n@@ -1068,11 +1099,15 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n-    if let Some(path_res) = cx.tcx.def_map.borrow().get(&expr.id) {\n-        if let Def::Local(def_id) = path_res.base_def {\n+    if let ExprPath(ref qpath) = expr.node {\n+        let path_res = cx.tcx.tables().qpath_def(qpath, expr.id);\n+        if let Def::Local(def_id) = path_res {\n             let node_id = cx.tcx.map.as_local_node_id(def_id).expect(\"That DefId should be valid\");\n             return Some(node_id);\n         }"}, {"sha": "f04a4b32de2b63ffa509e099731aab0b69dbf395", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -24,14 +24,14 @@ declare_lint! {\n #[derive(Copy, Clone)]\n pub struct Pass;\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // call to .map()\n         if let ExprMethodCall(name, _, ref args) = expr.node {\n             if &*name.node.as_str() == \"map\" && args.len() == 2 {\n                 match args[1].node {\n-                    ExprClosure(_, ref decl, ref closure_expr, _) => {\n-                        let closure_expr = remove_blocks(closure_expr);\n+                    ExprClosure(_, ref decl, closure_eid, _) => {\n+                        let closure_expr = remove_blocks(cx.tcx.map.expr(closure_eid));\n                         if_let_chain! {[\n                             // nothing special in the argument, besides reference bindings\n                             // (e.g. .map(|&x| x) )\n@@ -63,8 +63,8 @@ impl LateLintPass for Pass {\n                                 }\n                             }\n                         }}\n-                    }\n-                    ExprPath(_, ref path) => {\n+                    },\n+                    ExprPath(ref path) => {\n                         if match_path(path, &paths::CLONE) {\n                             let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n                             span_help_and_lint(cx,\n@@ -75,7 +75,7 @@ impl LateLintPass for Pass {\n                                                         type_name),\n                                                &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n                         }\n-                    }\n+                    },\n                     _ => (),\n                 }\n             }\n@@ -85,13 +85,13 @@ impl LateLintPass for Pass {\n \n fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n     match expr.node {\n-        ExprPath(None, ref path) => {\n+        ExprPath(QPath::Resolved(None, ref path)) => {\n             let arg_segment = [PathSegment {\n                                    name: id,\n                                    parameters: PathParameters::none(),\n                                }];\n             !path.global && path.segments[..] == arg_segment\n-        }\n+        },\n         _ => false,\n     }\n }\n@@ -108,7 +108,7 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n \n fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n     match pat.node {\n-        PatKind::Binding(_, name, None) => Some(name.node),\n+        PatKind::Binding(_, _, name, None) => Some(name.node),\n         PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n         _ => None,\n     }"}, {"sha": "978e9f5a029fec8b2afe0a0bffa2b1e33fd9c7fa", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -125,12 +125,16 @@ pub struct MatchPass;\n \n impl LintPass for MatchPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(SINGLE_MATCH, MATCH_REF_PATS, MATCH_BOOL, SINGLE_MATCH_ELSE, MATCH_OVERLAPPING_ARM)\n+        lint_array!(SINGLE_MATCH,\n+                    MATCH_REF_PATS,\n+                    MATCH_BOOL,\n+                    SINGLE_MATCH_ELSE,\n+                    MATCH_OVERLAPPING_ARM)\n     }\n }\n \n-impl LateLintPass for MatchPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchPass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if in_external_macro(cx, expr.span) {\n             return;\n         }\n@@ -192,7 +196,14 @@ fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n     }\n }\n \n-fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: ty::Ty, els: Option<&Expr>) {\n+fn check_single_match_opt_like(\n+    cx: &LateContext,\n+    ex: &Expr,\n+    arms: &[Arm],\n+    expr: &Expr,\n+    ty: ty::Ty,\n+    els: Option<&Expr>\n+) {\n     // list of candidate Enums we know will never get any more members\n     let candidates = &[(&paths::COW, \"Borrowed\"),\n                        (&paths::COW, \"Cow::Borrowed\"),\n@@ -209,9 +220,9 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n                 return;\n             }\n             path.to_string()\n-        }\n-        PatKind::Binding(BindByValue(MutImmutable), ident, None) => ident.node.to_string(),\n-        PatKind::Path(None, ref path) => path.to_string(),\n+        },\n+        PatKind::Binding(BindByValue(MutImmutable), _, ident, None) => ident.node.to_string(),\n+        PatKind::Path(ref path) => path.to_string(),\n         _ => return,\n     };\n \n@@ -272,16 +283,14 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n                                          snippet(cx, ex.span, \"b\"),\n                                          expr_block(cx, true_expr, None, \"..\"),\n                                          expr_block(cx, false_expr, None, \"..\")))\n-                        }\n+                        },\n                         (false, true) => {\n                             Some(format!(\"if {} {}\", snippet(cx, ex.span, \"b\"), expr_block(cx, true_expr, None, \"..\")))\n-                        }\n+                        },\n                         (true, false) => {\n                             let test = Sugg::hir(cx, ex, \"..\");\n-                            Some(format!(\"if {} {}\",\n-                                         !test,\n-                                         expr_block(cx, false_expr, None, \"..\")))\n-                        }\n+                            Some(format!(\"if {} {}\", !test, expr_block(cx, false_expr, None, \"..\")))\n+                        },\n                         (true, true) => None,\n                     };\n \n@@ -291,7 +300,7 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n                 }\n             }\n \n-       });\n+        });\n     }\n }\n \n@@ -333,8 +342,7 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n                 let ex = Sugg::hir(cx, ex, \"..\");\n                 let template = match_template(expr.span, source, ex.deref());\n                 db.span_suggestion(expr.span,\n-                                   \"instead of prefixing all patterns with `&`, you can \\\n-                                   dereference the expression\",\n+                                   \"instead of prefixing all patterns with `&`, you can dereference the expression\",\n                                    template);\n             });\n         }\n@@ -346,27 +354,28 @@ fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n     arms.iter()\n         .flat_map(|arm| {\n             if let Arm { ref pats, guard: None, .. } = *arm {\n-                pats.iter()\n-            } else {\n-                [].iter()\n-            }.filter_map(|pat| {\n-                if_let_chain! {[\n+                    pats.iter()\n+                } else {\n+                    [].iter()\n+                }\n+                .filter_map(|pat| {\n+                    if_let_chain! {[\n                     let PatKind::Range(ref lhs, ref rhs) = pat.node,\n                     let Ok(lhs) = eval_const_expr_partial(cx.tcx, lhs, ExprTypeChecked, None),\n                     let Ok(rhs) = eval_const_expr_partial(cx.tcx, rhs, ExprTypeChecked, None)\n                 ], {\n                     return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n                 }}\n \n-                if_let_chain! {[\n+                    if_let_chain! {[\n                     let PatKind::Lit(ref value) = pat.node,\n                     let Ok(value) = eval_const_expr_partial(cx.tcx, value, ExprTypeChecked, None)\n                 ], {\n                     return Some(SpannedRange { span: pat.span, node: (value.clone(), value) });\n                 }}\n \n-                None\n-            })\n+                    None\n+                })\n         })\n         .collect()\n }\n@@ -383,17 +392,17 @@ type TypedRanges = Vec<SpannedRange<ConstInt>>;\n /// `Uint` and `Int` probably don't make sense.\n fn type_ranges(ranges: &[SpannedRange<ConstVal>]) -> TypedRanges {\n     ranges.iter()\n-          .filter_map(|range| {\n-              if let (ConstVal::Integral(start), ConstVal::Integral(end)) = range.node {\n-                  Some(SpannedRange {\n-                      span: range.span,\n-                      node: (start, end),\n-                  })\n-              } else {\n-                  None\n-              }\n-          })\n-          .collect()\n+        .filter_map(|range| {\n+            if let (ConstVal::Integral(start), ConstVal::Integral(end)) = range.node {\n+                Some(SpannedRange {\n+                    span: range.span,\n+                    node: (start, end),\n+                })\n+            } else {\n+                None\n+            }\n+        })\n+        .collect()\n }\n \n fn is_unit_expr(expr: &Expr) -> bool {\n@@ -406,15 +415,15 @@ fn is_unit_expr(expr: &Expr) -> bool {\n \n fn has_only_ref_pats(arms: &[Arm]) -> bool {\n     let mapped = arms.iter()\n-                     .flat_map(|a| &a.pats)\n-                     .map(|p| {\n-                         match p.node {\n-                             PatKind::Ref(..) => Some(true),  // &-patterns\n-                             PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n-                             _ => None,                    // any other pattern is not fine\n-                         }\n-                     })\n-                     .collect::<Option<Vec<bool>>>();\n+        .flat_map(|a| &a.pats)\n+        .map(|p| {\n+            match p.node {\n+                PatKind::Ref(..) => Some(true),  // &-patterns\n+                PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n+                _ => None,                    // any other pattern is not fine\n+            }\n+        })\n+        .collect::<Option<Vec<bool>>>();\n     // look for Some(v) where there's at least one true element\n     mapped.map_or(false, |v| v.iter().any(|el| *el))\n }\n@@ -481,7 +490,7 @@ pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &\n                 if ra.node != rb.node {\n                     return Some((ra, rb));\n                 }\n-            }\n+            },\n             (&Kind::End(a, _), &Kind::Start(b, _)) if a != b => (),\n             _ => return Some((a.range(), b.range())),\n         }"}, {"sha": "55654a7de43b772a1b809f7ef9af0fb7e6f66d04", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -27,11 +27,11 @@ impl LintPass for MemForget {\n     }\n }\n \n-impl LateLintPass for MemForget {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(None, _) = path_expr.node {\n-                let def_id = cx.tcx.expect_def(path_expr.id).def_id();\n+            if let ExprPath(ref qpath) = path_expr.node {\n+                let def_id = cx.tcx.tables().qpath_def(qpath, path_expr.id).def_id();\n                 if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n                     let forgot_ty = cx.tcx.tables().expr_ty(&args[0]);\n "}, {"sha": "591b395fe7099d247b68bd427ea8eeeca372f0fb", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 121, "deletions": 108, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -3,14 +3,16 @@ use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::const_qualif::ConstQualif;\n use rustc::ty;\n+use rustc::hir::def::Def;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n use std::borrow::Cow;\n use std::fmt;\n use syntax::codemap::Span;\n-use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path,\n-            match_trait_method, match_type, method_chain_args, return_ty, same_tys, snippet,\n-            span_lint, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path, match_trait_method,\n+            match_type, method_chain_args, return_ty, same_tys, snippet, span_lint, span_lint_and_then,\n+            span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, last_path_segment, single_segment_path,\n+            match_def_path};\n use utils::paths;\n use utils::sugg;\n \n@@ -547,11 +549,11 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     #[allow(unused_attributes)]\n     // ^ required because `cyclomatic_complexity` attribute shows up as unused\n     #[cyclomatic_complexity = \"30\"]\n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if in_macro(cx, expr.span) {\n             return;\n         }\n@@ -614,20 +616,20 @@ impl LateLintPass for Pass {\n                                 lint_single_char_pattern(cx, expr, &args[pos]);\n                             }\n                         }\n-                    }\n+                    },\n                     _ => (),\n                 }\n-            }\n+            },\n             hir::ExprBinary(op, ref lhs, ref rhs) if op.node == hir::BiEq || op.node == hir::BiNe => {\n                 if !lint_chars_next(cx, expr, lhs, rhs, op.node == hir::BiEq) {\n                     lint_chars_next(cx, expr, rhs, lhs, op.node == hir::BiEq);\n                 }\n-            }\n+            },\n             _ => (),\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, implitem: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, implitem: &'tcx hir::ImplItem) {\n         if in_external_macro(cx, implitem.span) {\n             return;\n         }\n@@ -693,38 +695,42 @@ impl LateLintPass for Pass {\n /// Checks for the `OR_FUN_CALL` lint.\n fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir::Expr]) {\n     /// Check for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n-    fn check_unwrap_or_default(cx: &LateContext, name: &str, fun: &hir::Expr, self_expr: &hir::Expr, arg: &hir::Expr,\n-                               or_has_args: bool, span: Span)\n-                               -> bool {\n+    fn check_unwrap_or_default(\n+        cx: &LateContext,\n+        name: &str,\n+        fun: &hir::Expr,\n+        self_expr: &hir::Expr,\n+        arg: &hir::Expr,\n+        or_has_args: bool,\n+        span: Span\n+    ) -> bool {\n         if or_has_args {\n             return false;\n         }\n \n         if name == \"unwrap_or\" {\n-            if let hir::ExprPath(_, ref path) = fun.node {\n-                let path: &str = &path.segments\n-                                      .last()\n-                                      .expect(\"A path must have at least one segment\")\n-                                      .name\n-                                      .as_str();\n+            if let hir::ExprPath(ref qpath) = fun.node {\n+                let path: &str = &*last_path_segment(qpath).name.as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tcx.tables().expr_ty(arg);\n-                    let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n+                    let default_trait_id = if let Some(default_trait_id) =\n+                        get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n                         default_trait_id\n                     } else {\n                         return false;\n                     };\n \n                     if implements_trait(cx, arg_ty, default_trait_id, Vec::new()) {\n                         span_lint_and_then(cx,\n-                                  OR_FUN_CALL,\n-                                  span,\n-                                  &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n-                                  |db| {\n-                                      db.span_suggestion(span, \"try this\",\n-                                                          format!(\"{}.unwrap_or_default()\", snippet(cx, self_expr.span, \"_\")));\n-                                  });\n+                                           OR_FUN_CALL,\n+                                           span,\n+                                           &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n+                                           |db| {\n+                            db.span_suggestion(span,\n+                                               \"try this\",\n+                                               format!(\"{}.unwrap_or_default()\", snippet(cx, self_expr.span, \"_\")));\n+                        });\n                         return true;\n                     }\n                 }\n@@ -735,8 +741,15 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n     }\n \n     /// Check for `*or(foo())`.\n-    fn check_general_case(cx: &LateContext, name: &str, fun: &hir::Expr, self_expr: &hir::Expr, arg: &hir::Expr, or_has_args: bool,\n-                          span: Span) {\n+    fn check_general_case(\n+        cx: &LateContext,\n+        name: &str,\n+        fun: &hir::Expr,\n+        self_expr: &hir::Expr,\n+        arg: &hir::Expr,\n+        or_has_args: bool,\n+        span: Span\n+    ) {\n         // don't lint for constant values\n         // FIXME: can we `expect` here instead of match?\n         if let Some(qualif) = cx.tcx.const_qualif_map.borrow().get(&arg.id) {\n@@ -745,18 +758,16 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n             }\n         }\n         // (path, fn_has_argument, methods, suffix)\n-        let know_types: &[(&[_], _, &[_], _)] = &[(&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-                                                  (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-                                                  (&paths::OPTION,\n-                                                   false,\n-                                                   &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"],\n-                                                   \"else\"),\n-                                                  (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\")];\n+        let know_types: &[(&[_], _, &[_], _)] =\n+            &[(&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+              (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+              (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n+              (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\")];\n \n         let self_ty = cx.tcx.tables().expr_ty(self_expr);\n \n         let (fn_has_arguments, poss, suffix) = if let Some(&(_, fn_has_arguments, poss, suffix)) =\n-                                                      know_types.iter().find(|&&i| match_type(cx, self_ty, i.0)) {\n+            know_types.iter().find(|&&i| match_type(cx, self_ty, i.0)) {\n             (fn_has_arguments, poss, suffix)\n         } else {\n             return;\n@@ -772,7 +783,11 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n             (false, true) => snippet(cx, fun.span, \"..\"),\n         };\n \n-        span_lint_and_then(cx, OR_FUN_CALL, span, &format!(\"use of `{}` followed by a function call\", name), |db| {\n+        span_lint_and_then(cx,\n+                           OR_FUN_CALL,\n+                           span,\n+                           &format!(\"use of `{}` followed by a function call\", name),\n+                           |db| {\n             db.span_suggestion(span,\n                                \"try this\",\n                                format!(\"{}.{}_{}({})\", snippet(cx, self_expr.span, \"_\"), name, suffix, sugg));\n@@ -802,7 +817,9 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n                                \"using `clone` on a double-reference; \\\n                                 this will copy the reference instead of cloning the inner type\",\n                                |db| if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n-                                   db.span_suggestion(expr.span, \"try dereferencing it\", format!(\"({}).clone()\", snip.deref()));\n+                                   db.span_suggestion(expr.span,\n+                                                      \"try dereferencing it\",\n+                                                      format!(\"({}).clone()\", snip.deref()));\n                                });\n             return; // don't report clone_on_copy\n         }\n@@ -826,12 +843,14 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n fn lint_vec_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n     let arg_ty = cx.tcx.tables().expr_ty(&args[1]);\n     if let Some(slice) = derefs_to_slice(cx, &args[1], arg_ty) {\n-        span_lint_and_then(cx, EXTEND_FROM_SLICE, expr.span, \"use of `extend` to extend a Vec by a slice\", |db| {\n+        span_lint_and_then(cx,\n+                           EXTEND_FROM_SLICE,\n+                           expr.span,\n+                           \"use of `extend` to extend a Vec by a slice\",\n+                           |db| {\n             db.span_suggestion(expr.span,\n                                \"try this\",\n-                               format!(\"{}.extend_from_slice({})\",\n-                                       snippet(cx, args[0].span, \"_\"),\n-                                       slice));\n+                               format!(\"{}.extend_from_slice({})\", snippet(cx, args[0].span, \"_\"), slice));\n         });\n     }\n }\n@@ -849,18 +868,14 @@ fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n             return;\n         };\n \n-        span_lint_and_then(\n-            cx,\n-            STRING_EXTEND_CHARS,\n-            expr.span,\n-            \"calling `.extend(_.chars())`\",\n-            |db| {\n-                db.span_suggestion(expr.span, \"try this\",\n-                        format!(\"{}.push_str({}{})\",\n-                                snippet(cx, args[0].span, \"_\"),\n-                                ref_str,\n-                                snippet(cx, target.span, \"_\")));\n-            });\n+        span_lint_and_then(cx, STRING_EXTEND_CHARS, expr.span, \"calling `.extend(_.chars())`\", |db| {\n+            db.span_suggestion(expr.span,\n+                               \"try this\",\n+                               format!(\"{}.push_str({}{})\",\n+                                       snippet(cx, args[0].span, \"_\"),\n+                                       ref_str,\n+                                       snippet(cx, target.span, \"_\")));\n+        });\n     }\n }\n \n@@ -877,8 +892,9 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n     if_let_chain!{[\n         let hir::ExprCall(ref fun, ref args) = new.node,\n         args.len() == 1,\n-        let hir::ExprPath(None, ref path) = fun.node,\n-        match_path(path, &paths::CSTRING_NEW),\n+        let hir::ExprPath(ref path) = fun.node,\n+        let Def::Method(did) = cx.tcx.tables().qpath_def(path, fun.id),\n+        match_def_path(cx, did, &paths::CSTRING_NEW)\n     ], {\n         span_lint_and_then(cx, TEMPORARY_CSTRING_AS_PTR, expr.span,\n                            \"you are getting the inner pointer of a temporary `CString`\",\n@@ -889,28 +905,24 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n     }}\n }\n \n-fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool){\n-    let mut_str = if is_mut { \"_mut\" } else {\"\"};\n+fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n+    let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tcx.tables().expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n-    }\n-    else if match_type(cx, cx.tcx.tables().expr_ty(&iter_args[0]), &paths::VEC) {\n+    } else if match_type(cx, cx.tcx.tables().expr_ty(&iter_args[0]), &paths::VEC) {\n         \"Vec\"\n-    }\n-    else if match_type(cx, cx.tcx.tables().expr_ty(&iter_args[0]), &paths::VEC_DEQUE) {\n+    } else if match_type(cx, cx.tcx.tables().expr_ty(&iter_args[0]), &paths::VEC_DEQUE) {\n         \"VecDeque\"\n-    }\n-    else {\n+    } else {\n         return; // caller is not a type that we want to lint\n     };\n \n-    span_lint(\n-        cx,\n-        ITER_NTH,\n-        expr.span,\n-        &format!(\"called `.iter{0}().nth()` on a {1}. Calling `.get{0}()` is both faster and more readable\",\n-                 mut_str, caller_type)\n-    );\n+    span_lint(cx,\n+              ITER_NTH,\n+              expr.span,\n+              &format!(\"called `.iter{0}().nth()` on a {1}. Calling `.get{0}()` is both faster and more readable\",\n+                       mut_str,\n+                       caller_type));\n }\n \n fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n@@ -933,32 +945,29 @@ fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], i\n \n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let borrow_str = if is_mut { \"&mut \" } else { \"&\" };\n-    span_lint_and_then(\n-        cx,\n-        GET_UNWRAP,\n-        expr.span,\n-        &format!(\"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n-                 mut_str, caller_type),\n-        |db| {\n-            db.span_suggestion(\n-                expr.span,\n-                \"try this\",\n-                format!(\"{}{}[{}]\", borrow_str, snippet(cx, get_args[0].span, \"_\"),\n-                        snippet(cx, get_args[1].span, \"_\"))\n-            );\n-        }\n-    );\n+    span_lint_and_then(cx,\n+                       GET_UNWRAP,\n+                       expr.span,\n+                       &format!(\"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n+                                mut_str,\n+                                caller_type),\n+                       |db| {\n+        db.span_suggestion(expr.span,\n+                           \"try this\",\n+                           format!(\"{}{}[{}]\",\n+                                   borrow_str,\n+                                   snippet(cx, get_args[0].span, \"_\"),\n+                                   snippet(cx, get_args[1].span, \"_\")));\n+    });\n }\n \n-fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr){\n+fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n     // lint if caller of skip is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-         span_lint(\n-            cx,\n-            ITER_SKIP_NEXT,\n-            expr.span,\n-            \"called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\"\n-        );\n+        span_lint(cx,\n+                  ITER_SKIP_NEXT,\n+                  expr.span,\n+                  \"called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\");\n     }\n }\n \n@@ -976,9 +985,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n \n     if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n         if &*name.node.as_str() == \"iter\" && may_slice(cx, cx.tcx.tables().expr_ty(&args[0])) {\n-            sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| {\n-                sugg.addr()\n-            })\n+            sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| sugg.addr())\n         } else {\n             None\n         }\n@@ -992,7 +999,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n                 } else {\n                     None\n                 }\n-            }\n+            },\n             _ => None,\n         }\n     }\n@@ -1100,8 +1107,8 @@ fn lint_map_unwrap_or_else(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::\n fn lint_filter_next(cx: &LateContext, expr: &hir::Expr, filter_args: &[hir::Expr]) {\n     // lint if caller of `.filter().next()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` \\\n-                   instead.\";\n+        let msg = \"called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n+                   `.find(p)` instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n         if filter_snippet.lines().count() <= 1 {\n             // add note if not multi-line\n@@ -1160,12 +1167,17 @@ fn lint_filter_map_flat_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &[\n }\n \n /// lint searching an Iterator followed by `is_some()`\n-fn lint_search_is_some(cx: &LateContext, expr: &hir::Expr, search_method: &str, search_args: &[hir::Expr],\n-                       is_some_args: &[hir::Expr]) {\n+fn lint_search_is_some(\n+    cx: &LateContext,\n+    expr: &hir::Expr,\n+    search_method: &str,\n+    search_args: &[hir::Expr],\n+    is_some_args: &[hir::Expr]\n+) {\n     // lint if caller of search is an Iterator\n     if match_trait_method(cx, &is_some_args[0], &paths::ITERATOR) {\n-        let msg = format!(\"called `is_some()` after searching an `Iterator` with {}. This is more succinctly expressed \\\n-                           by calling `any()`.\",\n+        let msg = format!(\"called `is_some()` after searching an `Iterator` with {}. This is more succinctly \\\n+                           expressed by calling `any()`.\",\n                           search_method);\n         let search_snippet = snippet(cx, search_args[1].span, \"..\");\n         if search_snippet.lines().count() <= 1 {\n@@ -1188,8 +1200,9 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n         let Some(args) = method_chain_args(chain, &[\"chars\", \"next\"]),\n         let hir::ExprCall(ref fun, ref arg_char) = other.node,\n         arg_char.len() == 1,\n-        let hir::ExprPath(None, ref path) = fun.node,\n-        path.segments.len() == 1 && &*path.segments[0].name.as_str() == \"Some\"\n+        let hir::ExprPath(ref qpath) = fun.node,\n+        let Some(segment) = single_segment_path(qpath),\n+        &*segment.name.as_str() == \"Some\"\n     ], {\n         let self_ty = walk_ptrs_ty(cx.tcx.tables().expr_ty_adjusted(&args[0][0]));\n \n@@ -1227,8 +1240,8 @@ fn lint_single_char_pattern(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr)\n                                arg.span,\n                                \"single-character string constant used as pattern\",\n                                |db| {\n-                                   db.span_suggestion(expr.span, \"try using a char instead:\", hint);\n-                               });\n+                db.span_suggestion(expr.span, \"try using a char instead:\", hint);\n+            });\n         }\n     }\n }\n@@ -1408,7 +1421,7 @@ impl OutType {\n }\n \n fn is_bool(ty: &hir::Ty) -> bool {\n-    if let hir::TyPath(None, ref p) = ty.node {\n+    if let hir::TyPath(ref p) = ty.node {\n         match_path(p, &[\"bool\"])\n     } else {\n         false"}, {"sha": "d4198c97d13f895037aac0835a38134f034d36da", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -33,8 +33,8 @@ impl LintPass for MinMaxPass {\n     }\n }\n \n-impl LateLintPass for MinMaxPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MinMaxPass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let Some((outer_max, outer_c, oe)) = min_max(cx, expr) {\n             if let Some((inner_max, inner_c, _)) = min_max(cx, oe) {\n                 if outer_max == inner_max {\n@@ -46,7 +46,7 @@ impl LateLintPass for MinMaxPass {\n                     (MinMax::Min, Some(Ordering::Greater)) => (),\n                     _ => {\n                         span_lint(cx, MIN_MAX, expr.span, \"this min/max combination leads to constant result\");\n-                    }\n+                    },\n                 }\n             }\n         }\n@@ -61,8 +61,8 @@ enum MinMax {\n \n fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n     if let ExprCall(ref path, ref args) = expr.node {\n-        if let ExprPath(None, _) = path.node {\n-            let def_id = cx.tcx.expect_def(path.id).def_id();\n+        if let ExprPath(ref qpath) = path.node {\n+            let def_id = cx.tcx.tables().qpath_def(qpath, path.id).def_id();\n \n             if match_def_path(cx, def_id, &paths::CMP_MIN) {\n                 fetch_const(args, MinMax::Min)"}, {"sha": "409a7de86f06d4e57ae19521587d47437f1b73d2", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 54, "deletions": 57, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -8,10 +8,8 @@ use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_math::ConstFloat;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n-use utils::{\n-    get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path,\n-    snippet, span_lint, span_lint_and_then, walk_ptrs_ty\n-};\n+use utils::{get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path, snippet,\n+            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for function arguments and let bindings denoted as `ref`.\n@@ -161,19 +159,32 @@ pub struct Pass;\n \n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(TOPLEVEL_REF_ARG, CMP_NAN, FLOAT_CMP, CMP_OWNED, MODULO_ONE, REDUNDANT_PATTERN,\n+        lint_array!(TOPLEVEL_REF_ARG,\n+                    CMP_NAN,\n+                    FLOAT_CMP,\n+                    CMP_OWNED,\n+                    MODULO_ONE,\n+                    REDUNDANT_PATTERN,\n                     USED_UNDERSCORE_BINDING)\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_fn(&mut self, cx: &LateContext, k: FnKind, decl: &FnDecl, _: &Expr, _: Span, _: NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        k: FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        _: &'tcx Expr,\n+        _: Span,\n+        _: NodeId\n+    ) {\n         if let FnKind::Closure(_) = k {\n             // Does not apply to closures\n             return;\n         }\n         for arg in &decl.inputs {\n-            if let PatKind::Binding(BindByRef(_), _, _) = arg.pat.node {\n+            if let PatKind::Binding(BindByRef(_), _, _, _) = arg.pat.node {\n                 span_lint(cx,\n                           TOPLEVEL_REF_ARG,\n                           arg.pat.span,\n@@ -182,11 +193,11 @@ impl LateLintPass for Pass {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext, s: &Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, s: &'tcx Stmt) {\n         if_let_chain! {[\n             let StmtDecl(ref d, _) = s.node,\n             let DeclLocal(ref l) = d.node,\n-            let PatKind::Binding(BindByRef(mt), i, None) = l.pat.node,\n+            let PatKind::Binding(BindByRef(mt), _, i, None) = l.pat.node,\n             let Some(ref init) = l.init\n         ], {\n             let init = Sugg::hir(cx, init, \"..\");\n@@ -216,14 +227,14 @@ impl LateLintPass for Pass {\n         }}\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n             let op = cmp.node;\n             if op.is_comparison() {\n-                if let ExprPath(_, ref path) = left.node {\n+                if let ExprPath(QPath::Resolved(_, ref path)) = left.node {\n                     check_nan(cx, path, expr.span);\n                 }\n-                if let ExprPath(_, ref path) = right.node {\n+                if let ExprPath(QPath::Resolved(_, ref path)) = right.node {\n                     check_nan(cx, path, expr.span);\n                 }\n                 check_to_owned(cx, left, right, true, cmp.span);\n@@ -236,23 +247,19 @@ impl LateLintPass for Pass {\n                 if let Some(name) = get_item_name(cx, expr) {\n                     let name = &*name.as_str();\n                     if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n-                        name.ends_with(\"_eq\") {\n+                       name.ends_with(\"_eq\") {\n                         return;\n                     }\n                 }\n-                span_lint_and_then(cx,\n-                                   FLOAT_CMP,\n-                                   expr.span,\n-                                   \"strict comparison of f32 or f64\",\n-                                   |db| {\n-                                       let lhs = Sugg::hir(cx, left, \"..\");\n-                                       let rhs = Sugg::hir(cx, right, \"..\");\n+                span_lint_and_then(cx, FLOAT_CMP, expr.span, \"strict comparison of f32 or f64\", |db| {\n+                    let lhs = Sugg::hir(cx, left, \"..\");\n+                    let rhs = Sugg::hir(cx, right, \"..\");\n \n-                                       db.span_suggestion(expr.span,\n-                                                          \"consider comparing them within some error\",\n-                                                          format!(\"({}).abs() < error\", lhs - rhs));\n-                                       db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n-                                   });\n+                    db.span_suggestion(expr.span,\n+                                       \"consider comparing them within some error\",\n+                                       format!(\"({}).abs() < error\", lhs - rhs));\n+                    db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n+                });\n             } else if op == BiRem && is_integer_literal(right, 1) {\n                 span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n             }\n@@ -262,51 +269,46 @@ impl LateLintPass for Pass {\n             return;\n         }\n         let binding = match expr.node {\n-            ExprPath(_, ref path) => {\n-                let binding = path.segments\n-                    .last()\n-                    .expect(\"path should always have at least one segment\")\n-                    .name\n-                    .as_str();\n+            ExprPath(ref qpath) => {\n+                let binding = last_path_segment(qpath).name.as_str();\n                 if binding.starts_with('_') &&\n                     !binding.starts_with(\"__\") &&\n                     &*binding != \"_result\" && // FIXME: #944\n                     is_used(cx, expr) &&\n                     // don't lint if the declaration is in a macro\n-                    non_macro_local(cx, &cx.tcx.expect_def(expr.id)) {\n+                    non_macro_local(cx, &cx.tcx.tables().qpath_def(qpath, expr.id)) {\n                     Some(binding)\n                 } else {\n                     None\n                 }\n-            }\n+            },\n             ExprField(_, spanned) => {\n                 let name = spanned.node.as_str();\n                 if name.starts_with('_') && !name.starts_with(\"__\") {\n                     Some(name)\n                 } else {\n                     None\n                 }\n-            }\n+            },\n             _ => None,\n         };\n         if let Some(binding) = binding {\n             span_lint(cx,\n                       USED_UNDERSCORE_BINDING,\n                       expr.span,\n                       &format!(\"used binding `{}` which is prefixed with an underscore. A leading \\\n-                                underscore signals that a binding will not be used.\", binding));\n+                                underscore signals that a binding will not be used.\",\n+                               binding));\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n-        if let PatKind::Binding(_, ref ident, Some(ref right)) = pat.node {\n+    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n+        if let PatKind::Binding(_, _, ref ident, Some(ref right)) = pat.node {\n             if right.node == PatKind::Wild {\n                 span_lint(cx,\n                           REDUNDANT_PATTERN,\n                           pat.span,\n-                          &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n-                                   ident.node,\n-                                   ident.node));\n+                          &format!(\"the `{} @ _` pattern can be written as just `{}`\", ident.node, ident.node));\n             }\n         }\n     }\n@@ -343,9 +345,8 @@ fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n             f64: ::std::f64::NEG_INFINITY,\n         };\n \n-        val.try_cmp(zero) == Ok(Ordering::Equal)\n-            || val.try_cmp(infinity) == Ok(Ordering::Equal)\n-            || val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n+        val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal) ||\n+        val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n     } else {\n         false\n     }\n@@ -364,9 +365,9 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n             } else {\n                 return;\n             }\n-        }\n+        },\n         ExprCall(ref path, ref v) if v.len() == 1 => {\n-            if let ExprPath(None, ref path) = path.node {\n+            if let ExprPath(ref path) = path.node {\n                 if match_path(path, &[\"String\", \"from_str\"]) || match_path(path, &[\"String\", \"from\"]) {\n                     (cx.tcx.tables().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n@@ -375,7 +376,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n             } else {\n                 return;\n             }\n-        }\n+        },\n         _ => return,\n     };\n \n@@ -412,8 +413,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n }\n \n fn is_str_arg(cx: &LateContext, args: &[Expr]) -> bool {\n-    args.len() == 1 &&\n-        matches!(walk_ptrs_ty(cx.tcx.tables().expr_ty(&args[0])).sty, ty::TyStr)\n+    args.len() == 1 && matches!(walk_ptrs_ty(cx.tcx.tables().expr_ty(&args[0])).sty, ty::TyStr)\n }\n \n /// Heuristic to see if an expression is used. Should be compatible with `unused_variables`'s idea\n@@ -434,24 +434,21 @@ fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n /// `#[derive(...)`] or the like).\n fn in_attributes_expansion(cx: &LateContext, expr: &Expr) -> bool {\n     cx.sess().codemap().with_expn_info(expr.span.expn_id, |info_opt| {\n-        info_opt.map_or(false, |info| {\n-            matches!(info.callee.format, ExpnFormat::MacroAttribute(_))\n-        })\n+        info_opt.map_or(false, |info| matches!(info.callee.format, ExpnFormat::MacroAttribute(_)))\n     })\n }\n \n /// Test whether `def` is a variable defined outside a macro.\n fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n     match *def {\n-        def::Def::Local(id) | def::Def::Upvar(id, _, _) => {\n-            let id = cx.tcx.map.as_local_node_id(id).expect(\"That DefId should be valid\");\n-\n-            if let Some(span) = cx.tcx.map.opt_span(id) {\n+        def::Def::Local(id) |\n+        def::Def::Upvar(id, _, _) => {\n+            if let Some(span) = cx.tcx.map.span_if_local(id) {\n                 !in_macro(cx, span)\n             } else {\n                 true\n             }\n-        }\n+        },\n         _ => false,\n     }\n }"}, {"sha": "e6f044ae9b6ad5d474f3534c50fd574ae50a0c2b", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -168,9 +168,14 @@ pub struct MiscEarly;\n \n impl LintPass for MiscEarly {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNEEDED_FIELD_PATTERN, DUPLICATE_UNDERSCORE_ARGUMENT, REDUNDANT_CLOSURE_CALL,\n-                    DOUBLE_NEG, MIXED_CASE_HEX_LITERALS, UNSEPARATED_LITERAL_SUFFIX,\n-                    ZERO_PREFIXED_LITERAL, BUILTIN_TYPE_SHADOW)\n+        lint_array!(UNNEEDED_FIELD_PATTERN,\n+                    DUPLICATE_UNDERSCORE_ARGUMENT,\n+                    REDUNDANT_CLOSURE_CALL,\n+                    DOUBLE_NEG,\n+                    MIXED_CASE_HEX_LITERALS,\n+                    UNSEPARATED_LITERAL_SUFFIX,\n+                    ZERO_PREFIXED_LITERAL,\n+                    BUILTIN_TYPE_SHADOW)\n     }\n }\n \n@@ -272,22 +277,22 @@ impl EarlyLintPass for MiscEarly {\n                                            expr.span,\n                                            \"Try not to call a closure in the expression where it is declared.\",\n                                            |db| {\n-                                               if decl.inputs.is_empty() {\n-                                                   let hint = snippet(cx, block.span, \"..\").into_owned();\n-                                                   db.span_suggestion(expr.span, \"Try doing something like: \", hint);\n-                                               }\n-                                           });\n+                            if decl.inputs.is_empty() {\n+                                let hint = snippet(cx, block.span, \"..\").into_owned();\n+                                db.span_suggestion(expr.span, \"Try doing something like: \", hint);\n+                            }\n+                        });\n                     }\n                 }\n-            }\n+            },\n             ExprKind::Unary(UnOp::Neg, ref inner) => {\n                 if let ExprKind::Unary(UnOp::Neg, _) = inner.node {\n                     span_lint(cx,\n                               DOUBLE_NEG,\n                               expr.span,\n                               \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\");\n                 }\n-            }\n+            },\n             ExprKind::Lit(ref lit) => {\n                 if_let_chain! {[\n                     let LitKind::Int(value, ..) = lit.node,\n@@ -328,8 +333,16 @@ impl EarlyLintPass for MiscEarly {\n                                            lit.span,\n                                            \"this is a decimal constant\",\n                                            |db| {\n-                            db.span_suggestion(lit.span, \"if you mean to use a decimal constant, remove the `0` to remove confusion:\", src[1..].to_string());\n-                            db.span_suggestion(lit.span, \"if you mean to use an octal constant, use `0o`:\", format!(\"0o{}\", &src[1..]));\n+                            db.span_suggestion(\n+                                lit.span,\n+                                \"if you mean to use a decimal constant, remove the `0` to remove confusion:\",\n+                                src[1..].to_string(),\n+                            );\n+                            db.span_suggestion(\n+                                lit.span,\n+                                \"if you mean to use an octal constant, use `0o`:\",\n+                                format!(\"0o{}\", &src[1..]),\n+                            );\n                         });\n                     }\n                 }}\n@@ -351,8 +364,8 @@ impl EarlyLintPass for MiscEarly {\n                         prev = ch;\n                     }\n                 }}\n-            }\n-            _ => ()\n+            },\n+            _ => (),\n         }\n     }\n \n@@ -369,7 +382,12 @@ impl EarlyLintPass for MiscEarly {\n                 let ExprKind::Path(_, ref path) = closure.node\n             ], {\n                 if sp_ident.node == (&path.segments[0]).identifier {\n-                    span_lint(cx, REDUNDANT_CLOSURE_CALL, second.span, \"Closure called just once immediately after it was declared\");\n+                    span_lint(\n+                        cx,\n+                        REDUNDANT_CLOSURE_CALL,\n+                        second.span,\n+                        \"Closure called just once immediately after it was declared\",\n+                    );\n                 }\n             }}\n         }"}, {"sha": "70696ea3908beb1dae77522446eaeeb8d03aa558", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,21 +1,24 @@\n-/* This file incorporates work covered by the following copyright and\n- * permission notice:\n- *   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n- *   file at the top-level directory of this distribution and at\n- *   http://rust-lang.org/COPYRIGHT.\n- *\n- *   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n- *   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n- *   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n- *   option. This file may not be copied, modified, or distributed\n- *   except according to those terms.\n- */\n-\n-/* Note: More specifically this lint is largely inspired (aka copied) from *rustc*'s\n- * [`missing_doc`].\n- *\n- * [`missing_doc`]: https://github.com/rust-lang/rust/blob/d6d05904697d89099b55da3331155392f1db9c00/src/librustc_lint/builtin.rs#L246\n- */\n+// This file incorporates work covered by the following copyright and\n+// permission notice:\n+//   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+//   file at the top-level directory of this distribution and at\n+//   http://rust-lang.org/COPYRIGHT.\n+//\n+//   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+//   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+//   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+//   option. This file may not be copied, modified, or distributed\n+//   except according to those terms.\n+//\n+\n+// Note: More specifically this lint is largely inspired (aka copied) from *rustc*'s\n+// [`missing_doc`].\n+//\n+// [`missing_doc`]:\n+// https://github.\n+// com/rust-lang/rust/blob/d6d05904697d89099b55da3331155392f1db9c00/src/librustc_lint/builtin.\n+// rs#L246\n+//\n \n use rustc::hir;\n use rustc::lint::*;\n@@ -51,20 +54,14 @@ impl ::std::default::Default for MissingDoc {\n \n impl MissingDoc {\n     pub fn new() -> MissingDoc {\n-        MissingDoc {\n-            doc_hidden_stack: vec![false],\n-        }\n+        MissingDoc { doc_hidden_stack: vec![false] }\n     }\n \n     fn doc_hidden(&self) -> bool {\n         *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n-    fn check_missing_docs_attrs(&self,\n-                               cx: &LateContext,\n-                               attrs: &[ast::Attribute],\n-                               sp: Span,\n-                               desc: &'static str) {\n+    fn check_missing_docs_attrs(&self, cx: &LateContext, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n         if cx.sess().opts.test {\n@@ -82,7 +79,8 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name() == \"doc\");\n         if !has_doc {\n-            cx.span_lint(MISSING_DOCS_IN_PRIVATE_ITEMS, sp,\n+            cx.span_lint(MISSING_DOCS_IN_PRIVATE_ITEMS,\n+                         sp,\n                          &format!(\"missing documentation for {}\", desc));\n         }\n     }\n@@ -94,26 +92,28 @@ impl LintPass for MissingDoc {\n     }\n }\n \n-impl LateLintPass for MissingDoc {\n-    fn enter_lint_attrs(&mut self, _: &LateContext, attrs: &[ast::Attribute]) {\n-        let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n-            attr.check_name(\"doc\") && match attr.meta_item_list() {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n+    fn enter_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, attrs: &'tcx [ast::Attribute]) {\n+        let doc_hidden = self.doc_hidden() ||\n+                         attrs.iter().any(|attr| {\n+            attr.check_name(\"doc\") &&\n+            match attr.meta_item_list() {\n                 None => false,\n                 Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n-    fn exit_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) {\n+    fn exit_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx [ast::Attribute]) {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n+    fn check_crate(&mut self, cx: &LateContext<'a, 'tcx>, krate: &'tcx hir::Crate) {\n         self.check_missing_docs_attrs(cx, &krate.attrs, krate.span, \"crate\");\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n         let desc = match it.node {\n             hir::ItemConst(..) => \"a constant\",\n             hir::ItemEnum(..) => \"an enum\",\n@@ -134,7 +134,7 @@ impl LateLintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, &it.attrs, it.span, desc);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, trait_item: &'tcx hir::TraitItem) {\n         let desc = match trait_item.node {\n             hir::ConstTraitItem(..) => \"an associated constant\",\n             hir::MethodTraitItem(..) => \"a trait method\",\n@@ -144,16 +144,16 @@ impl LateLintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, &trait_item.attrs, trait_item.span, desc);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n         let def_id = cx.tcx.map.local_def_id(impl_item.id);\n         match cx.tcx.associated_item(def_id).container {\n             ty::TraitContainer(_) => return,\n             ty::ImplContainer(cid) => {\n                 if cx.tcx.impl_trait_ref(cid).is_some() {\n-                    return\n+                    return;\n                 }\n-            }\n+            },\n         }\n \n         let desc = match impl_item.node {\n@@ -164,13 +164,13 @@ impl LateLintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, sf: &hir::StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, sf: &'tcx hir::StructField) {\n         if !sf.is_positional() {\n             self.check_missing_docs_attrs(cx, &sf.attrs, sf.span, \"a struct field\");\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext, v: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, v: &'tcx hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx, &v.node.attrs, v.span, \"a variant\");\n     }\n }"}, {"sha": "7d4326828cb1ef98a122397f8a51169516ad328a", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -31,12 +31,12 @@ impl LintPass for MutMut {\n     }\n }\n \n-impl LateLintPass for MutMut {\n-    fn check_block(&mut self, cx: &LateContext, block: &hir::Block) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutMut {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block) {\n         intravisit::walk_block(&mut MutVisitor { cx: cx }, block);\n     }\n \n-    fn check_ty(&mut self, cx: &LateContext, ty: &hir::Ty) {\n+    fn check_ty(&mut self, cx: &LateContext<'a, 'tcx>, ty: &'tcx hir::Ty) {\n         use rustc::hir::intravisit::Visitor;\n \n         MutVisitor { cx: cx }.visit_ty(ty);\n@@ -47,8 +47,8 @@ pub struct MutVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for MutVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'v hir::Expr) {\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if in_external_macro(self.cx, expr.span) {\n             return;\n         }\n@@ -64,7 +64,10 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for MutVisitor<'a, 'tcx> {\n             intravisit::walk_expr(self, body);\n         } else if let hir::ExprAddrOf(hir::MutMutable, ref e) = expr.node {\n             if let hir::ExprAddrOf(hir::MutMutable, _) = e.node {\n-                span_lint(self.cx, MUT_MUT, expr.span, \"generally you want to avoid `&mut &mut _` if possible\");\n+                span_lint(self.cx,\n+                          MUT_MUT,\n+                          expr.span,\n+                          \"generally you want to avoid `&mut &mut _` if possible\");\n             } else if let TyRef(_, TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tcx.tables().expr_ty(e).sty {\n                 span_lint(self.cx,\n                           MUT_MUT,\n@@ -74,14 +77,20 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for MutVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyRptr(_, hir::MutTy { ty: ref pty, mutbl: hir::MutMutable }) = ty.node {\n             if let hir::TyRptr(_, hir::MutTy { mutbl: hir::MutMutable, .. }) = pty.node {\n-                span_lint(self.cx, MUT_MUT, ty.span, \"generally you want to avoid `&mut &mut _` if possible\");\n+                span_lint(self.cx,\n+                          MUT_MUT,\n+                          ty.span,\n+                          \"generally you want to avoid `&mut &mut _` if possible\");\n             }\n \n         }\n \n         intravisit::walk_ty(self, ty);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+        intravisit::NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "7e7733bed80cf99a14ef3fc61261d35a1b9faea9", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -32,25 +32,24 @@ impl LintPass for UnnecessaryMutPassed {\n     }\n }\n \n-impl LateLintPass for UnnecessaryMutPassed {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         let borrowed_table = cx.tcx.tables.borrow();\n         match e.node {\n             ExprCall(ref fn_expr, ref arguments) => {\n                 let function_type = borrowed_table.node_types\n-                                                  .get(&fn_expr.id)\n-                                                  .expect(\"A function with an unknown type is called. \\\n-                                                           If this happened, the compiler would have \\\n-                                                           aborted the compilation long ago\");\n-                if let ExprPath(_, ref path) = fn_expr.node {\n+                    .get(&fn_expr.id)\n+                    .expect(\"A function with an unknown type is called. If this happened, the compiler would have \\\n+                             aborted the compilation long ago\");\n+                if let ExprPath(ref path) = fn_expr.node {\n                     check_arguments(cx, arguments, function_type, &path.to_string());\n                 }\n-            }\n+            },\n             ExprMethodCall(ref name, _, ref arguments) => {\n                 let method_call = MethodCall::expr(e.id);\n                 let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n                 check_arguments(cx, arguments, method_type.ty, &name.node.as_str())\n-            }\n+            },\n             _ => (),\n         }\n     }\n@@ -60,7 +59,7 @@ fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: &TyS,\n     match type_definition.sty {\n         TypeVariants::TyFnDef(_, _, fn_type) |\n         TypeVariants::TyFnPtr(fn_type) => {\n-            let parameters = &fn_type.sig.skip_binder().inputs;\n+            let parameters = fn_type.sig.skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {\n                     TypeVariants::TyRef(_, TypeAndMut { mutbl: MutImmutable, .. }) |\n@@ -71,11 +70,11 @@ fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: &TyS,\n                                       argument.span,\n                                       &format!(\"The function/method \\\"{}\\\" doesn't need a mutable reference\", name));\n                         }\n-                    }\n+                    },\n                     _ => (),\n                 }\n             }\n-        }\n+        },\n         _ => (),\n     }\n }"}, {"sha": "8d927110b9d22494495c35ed84660e256a1e2c1b", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -54,8 +54,8 @@ impl LintPass for MutexAtomic {\n \n pub struct MutexAtomic;\n \n-impl LateLintPass for MutexAtomic {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         let ty = cx.tcx.tables().expr_ty(expr);\n         if let ty::TyAdt(_, subst) = ty.sty {\n             if match_type(cx, ty, &paths::MUTEX) {"}, {"sha": "5eae3034aff31e9e1f9368cc8c73b861f0340043", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -56,17 +56,13 @@ impl LintPass for NeedlessBool {\n     }\n }\n \n-impl LateLintPass for NeedlessBool {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use self::Expression::*;\n         if let ExprIf(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n             let reduce = |ret, not| {\n                 let snip = Sugg::hir(cx, pred, \"<predicate>\");\n-                let snip = if not {\n-                    !snip\n-                } else {\n-                    snip\n-                };\n+                let snip = if not { !snip } else { snip };\n \n                 let hint = if ret {\n                     format!(\"return {}\", snip)\n@@ -79,8 +75,8 @@ impl LateLintPass for NeedlessBool {\n                                    e.span,\n                                    \"this if-then-else expression returns a bool literal\",\n                                    |db| {\n-                                       db.span_suggestion(e.span, \"you can reduce it to\", hint);\n-                                   });\n+                    db.span_suggestion(e.span, \"you can reduce it to\", hint);\n+                });\n             };\n             match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                 (RetBool(true), RetBool(true)) |\n@@ -89,14 +85,14 @@ impl LateLintPass for NeedlessBool {\n                               NEEDLESS_BOOL,\n                               e.span,\n                               \"this if-then-else expression will always return true\");\n-                }\n+                },\n                 (RetBool(false), RetBool(false)) |\n                 (Bool(false), Bool(false)) => {\n                     span_lint(cx,\n                               NEEDLESS_BOOL,\n                               e.span,\n                               \"this if-then-else expression will always return false\");\n-                }\n+                },\n                 (RetBool(true), RetBool(false)) => reduce(true, false),\n                 (Bool(true), Bool(false)) => reduce(false, false),\n                 (RetBool(false), RetBool(true)) => reduce(true, true),\n@@ -116,8 +112,8 @@ impl LintPass for BoolComparison {\n     }\n }\n \n-impl LateLintPass for BoolComparison {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use self::Expression::*;\n         if let ExprBinary(Spanned { node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n@@ -128,39 +124,39 @@ impl LateLintPass for BoolComparison {\n                                        e.span,\n                                        \"equality checks against true are unnecessary\",\n                                        |db| {\n-                                           db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n-                                       });\n-                }\n+                        db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n+                    });\n+                },\n                 (Other, Bool(true)) => {\n                     let hint = snippet(cx, left_side.span, \"..\").into_owned();\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n                                        e.span,\n                                        \"equality checks against true are unnecessary\",\n                                        |db| {\n-                                           db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n-                                       });\n-                }\n+                        db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n+                    });\n+                },\n                 (Bool(false), Other) => {\n                     let hint = Sugg::hir(cx, right_side, \"..\");\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n                                        e.span,\n                                        \"equality checks against false can be replaced by a negation\",\n                                        |db| {\n-                                           db.span_suggestion(e.span, \"try simplifying it as shown:\", (!hint).to_string());\n-                                       });\n-                }\n+                        db.span_suggestion(e.span, \"try simplifying it as shown:\", (!hint).to_string());\n+                    });\n+                },\n                 (Other, Bool(false)) => {\n                     let hint = Sugg::hir(cx, left_side, \"..\");\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n                                        e.span,\n                                        \"equality checks against false can be replaced by a negation\",\n                                        |db| {\n-                                           db.span_suggestion(e.span, \"try simplifying it as shown:\", (!hint).to_string());\n-                                       });\n-                }\n+                        db.span_suggestion(e.span, \"try simplifying it as shown:\", (!hint).to_string());\n+                    });\n+                },\n                 _ => (),\n             }\n         }\n@@ -186,7 +182,7 @@ fn fetch_bool_block(block: &Block) -> Expression {\n             } else {\n                 Expression::Other\n             }\n-        }\n+        },\n         _ => Expression::Other,\n     }\n }\n@@ -200,13 +196,13 @@ fn fetch_bool_expr(expr: &Expr) -> Expression {\n             } else {\n                 Expression::Other\n             }\n-        }\n+        },\n         ExprRet(Some(ref expr)) => {\n             match fetch_bool_expr(expr) {\n                 Expression::Bool(value) => Expression::RetBool(value),\n                 _ => Expression::Other,\n             }\n-        }\n+        },\n         _ => Expression::Other,\n     }\n }"}, {"sha": "f05fdaab1764e20ca9b20a19883d51174f01689d", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -34,14 +34,15 @@ impl LintPass for NeedlessBorrow {\n     }\n }\n \n-impl LateLintPass for NeedlessBorrow {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if in_macro(cx, e.span) {\n             return;\n         }\n         if let ExprAddrOf(MutImmutable, ref inner) = e.node {\n             if let ty::TyRef(..) = cx.tcx.tables().expr_ty(inner).sty {\n-                if let Some(&ty::adjustment::Adjust::DerefRef { autoderefs, autoref, .. }) = cx.tcx.tables.borrow().adjustments.get(&e.id).map(|a| &a.kind) {\n+                if let Some(&ty::adjustment::Adjust::DerefRef { autoderefs, autoref, .. }) =\n+                    cx.tcx.tables.borrow().adjustments.get(&e.id).map(|a| &a.kind) {\n                     if autoderefs > 1 && autoref.is_some() {\n                         span_lint(cx,\n                                   NEEDLESS_BORROW,\n@@ -53,18 +54,15 @@ impl LateLintPass for NeedlessBorrow {\n             }\n         }\n     }\n-    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n+    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if in_macro(cx, pat.span) {\n             return;\n         }\n-        if let PatKind::Binding(BindingMode::BindByRef(MutImmutable), _, _) = pat.node {\n+        if let PatKind::Binding(BindingMode::BindByRef(MutImmutable), _, _, _) = pat.node {\n             if let ty::TyRef(_, ref tam) = cx.tcx.tables().pat_ty(pat).sty {\n                 if tam.mutbl == MutImmutable {\n                     if let ty::TyRef(..) = tam.ty.sty {\n-                        span_lint(cx,\n-                                  NEEDLESS_BORROW,\n-                                  pat.span,\n-                                  \"this pattern creates a reference to a reference\")\n+                        span_lint(cx, NEEDLESS_BORROW, pat.span, \"this pattern creates a reference to a reference\")\n                     }\n                 }\n             }"}, {"sha": "de6277aa0ee5c8cefc6daaa9b8b019dff197ca4c", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -30,8 +30,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tcx.tables().expr_ty(expr);\n             if let TyAdt(def, _) = ty.sty {"}, {"sha": "05a6a92c9e9da5a76e359fd72f6cebc66b931854", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -31,8 +31,8 @@ impl LintPass for NegMultiply {\n }\n \n #[allow(match_same_arms)]\n-impl LateLintPass for NegMultiply {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(Spanned { node: BiMul, .. }, ref l, ref r) = e.node {\n             match (&l.node, &r.node) {\n                 (&ExprUnary(..), &ExprUnary(..)) => (),"}, {"sha": "9c7b132dd3d6d0b72e9453cbe66c442ffe479c76", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -89,8 +89,16 @@ impl LintPass for NewWithoutDefault {\n     }\n }\n \n-impl LateLintPass for NewWithoutDefault {\n-    fn check_fn(&mut self, cx: &LateContext, kind: FnKind, decl: &hir::FnDecl, _: &hir::Expr, span: Span, id: ast::NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl,\n+        _: &'tcx hir::Expr,\n+        span: Span,\n+        id: ast::NodeId\n+    ) {\n         if in_external_macro(cx, span) {\n             return;\n         }\n@@ -153,7 +161,7 @@ fn can_derive_default<'t, 'c>(ty: ty::Ty<'t>, cx: &LateContext<'c, 't>, default_\n                 }\n             }\n             true\n-        }\n+        },\n         _ => false,\n     }\n }"}, {"sha": "a87c9d0f7365d7642f2d1ac884345d6092d7bfff", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::Def;\n use rustc::hir::{Expr, Expr_, Stmt, StmtSemi, BlockCheckMode, UnsafeSource};\n use utils::{in_macro, span_lint, snippet_opt, span_lint_and_then};\n use std::ops::Deref;\n@@ -66,25 +66,29 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n                 Some(ref base) => has_no_effect(cx, base),\n                 None => true,\n             }\n-        }\n+        },\n         Expr_::ExprCall(ref callee, ref args) => {\n-            let def = cx.tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def());\n-            match def {\n-                Some(Def::Struct(..)) |\n-                Some(Def::Variant(..)) |\n-                Some(Def::StructCtor(..)) |\n-                Some(Def::VariantCtor(..)) => args.iter().all(|arg| has_no_effect(cx, arg)),\n-                _ => false,\n+            if let Expr_::ExprPath(ref qpath) = callee.node {\n+                let def = cx.tcx.tables().qpath_def(qpath, callee.id);\n+                match def {\n+                    Def::Struct(..) |\n+                    Def::Variant(..) |\n+                    Def::StructCtor(..) |\n+                    Def::VariantCtor(..) => args.iter().all(|arg| has_no_effect(cx, arg)),\n+                    _ => false,\n+                }\n+            } else {\n+                false\n             }\n-        }\n+        },\n         Expr_::ExprBlock(ref block) => {\n             block.stmts.is_empty() &&\n             if let Some(ref expr) = block.expr {\n                 has_no_effect(cx, expr)\n             } else {\n                 false\n             }\n-        }\n+        },\n         _ => false,\n     }\n }\n@@ -98,8 +102,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if has_no_effect(cx, expr) {\n                 span_lint(cx, NO_EFFECT, stmt.span, \"statement with no effect\");\n@@ -144,16 +148,21 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         Expr_::ExprBox(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n         Expr_::ExprStruct(_, ref fields, ref base) => {\n             Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect())\n-        }\n+        },\n         Expr_::ExprCall(ref callee, ref args) => {\n-            match cx.tcx.def_map.borrow().get(&callee.id).map(PathResolution::full_def) {\n-                Some(Def::Struct(..)) |\n-                Some(Def::Variant(..)) |\n-                Some(Def::StructCtor(..)) |\n-                Some(Def::VariantCtor(..)) => Some(args.iter().collect()),\n-                _ => None,\n+            if let Expr_::ExprPath(ref qpath) = callee.node {\n+                let def = cx.tcx.tables().qpath_def(qpath, callee.id);\n+                match def {\n+                    Def::Struct(..) |\n+                    Def::Variant(..) |\n+                    Def::StructCtor(..) |\n+                    Def::VariantCtor(..) => Some(args.iter().collect()),\n+                    _ => None,\n+                }\n+            } else {\n+                None\n             }\n-        }\n+        },\n         Expr_::ExprBlock(ref block) => {\n             if block.stmts.is_empty() {\n                 block.expr.as_ref().and_then(|e| {\n@@ -167,7 +176,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n             } else {\n                 None\n             }\n-        }\n+        },\n         _ => None,\n     }\n }"}, {"sha": "a195673a53bcf4a6411c7aa107db588670b879c3", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -59,9 +59,9 @@ struct ExistingName {\n     whitelist: &'static [&'static str],\n }\n \n-struct SimilarNamesLocalVisitor<'a, 'b: 'a> {\n+struct SimilarNamesLocalVisitor<'a, 'tcx: 'a> {\n     names: Vec<ExistingName>,\n-    cx: &'a EarlyContext<'b>,\n+    cx: &'a EarlyContext<'tcx>,\n     lint: &'a NonExpressiveNames,\n     single_char_names: Vec<char>,\n }\n@@ -76,10 +76,10 @@ const WHITELIST: &'static [&'static [&'static str]] = &[\n     &[\"set\", \"get\"],\n ];\n \n-struct SimilarNamesNameVisitor<'a, 'b: 'a, 'c: 'b>(&'a mut SimilarNamesLocalVisitor<'b, 'c>);\n+struct SimilarNamesNameVisitor<'a: 'b, 'tcx: 'a, 'b>(&'b mut SimilarNamesLocalVisitor<'a, 'tcx>);\n \n-impl<'a, 'b, 'c> Visitor for SimilarNamesNameVisitor<'a, 'b, 'c> {\n-    fn visit_pat(&mut self, pat: &Pat) {\n+impl<'a, 'tcx: 'a, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n+    fn visit_pat(&mut self, pat: &'tcx Pat) {\n         match pat.node {\n             PatKind::Ident(_, id, _) => self.check_name(id.span, id.node.name),\n             PatKind::Struct(_, ref fields, _) => {\n@@ -88,7 +88,7 @@ impl<'a, 'b, 'c> Visitor for SimilarNamesNameVisitor<'a, 'b, 'c> {\n                         self.visit_pat(&field.node.pat);\n                     }\n                 }\n-            }\n+            },\n             _ => walk_pat(self, pat),\n         }\n     }\n@@ -120,7 +120,7 @@ fn whitelisted(interned_name: &str, list: &[&str]) -> bool {\n     false\n }\n \n-impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n+impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n     fn check_short_name(&mut self, c: char, span: Span) {\n         // make sure we ignore shadowing\n         if self.0.single_char_names.contains(&c) {\n@@ -210,8 +210,8 @@ impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n                     diag.span_help(span,\n                                    &format!(\"separate the discriminating character by an \\\n                                                                 underscore like: `{}_{}`\",\n-                                                               &interned_name[..split],\n-                                                               &interned_name[split..]));\n+                                            &interned_name[..split],\n+                                            &interned_name[split..]));\n                 }\n             });\n             return;\n@@ -236,20 +236,22 @@ impl<'a, 'b> SimilarNamesLocalVisitor<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b> Visitor for SimilarNamesLocalVisitor<'a, 'b> {\n-    fn visit_local(&mut self, local: &Local) {\n+impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n+    fn visit_local(&mut self, local: &'tcx Local) {\n         if let Some(ref init) = local.init {\n             self.apply(|this| walk_expr(this, &**init));\n         }\n-        // add the pattern after the expression because the bindings aren't available yet in the init expression\n+        // add the pattern after the expression because the bindings aren't available yet in the init\n+        // expression\n         SimilarNamesNameVisitor(self).visit_pat(&*local.pat);\n     }\n-    fn visit_block(&mut self, blk: &Block) {\n+    fn visit_block(&mut self, blk: &'tcx Block) {\n         self.apply(|this| walk_block(this, blk));\n     }\n-    fn visit_arm(&mut self, arm: &Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx Arm) {\n         self.apply(|this| {\n-            // just go through the first pattern, as either all patterns bind the same bindings or rustc would have errored much earlier\n+            // just go through the first pattern, as either all patterns\n+            // bind the same bindings or rustc would have errored much earlier\n             SimilarNamesNameVisitor(this).visit_pat(&arm.pats[0]);\n             this.apply(|this| walk_expr(this, &arm.body));\n         });"}, {"sha": "65b13688ff626f5ba45fed653f004a1c772e8ebe", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -15,7 +15,7 @@ use utils::{paths, method_chain_args, span_help_and_lint, match_type, snippet};\n ///         vec.push(bench)\n ///     }\n /// }\n-///```\n+/// ```\n /// Could be written:\n ///\n /// ```rust\n@@ -40,13 +40,13 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain! {[ //begin checking variables\n             let ExprMatch(ref op, ref body, ref source) = expr.node, //test if expr is a match\n             let MatchSource::IfLetDesugar { .. } = *source, //test if it is an If Let\n             let ExprMethodCall(_, _, ref result_types) = op.node, //check is expr.ok() has type Result<T,E>.ok()\n-            let PatKind::TupleStruct(ref x, ref y, _)  = body[0].pats[0].node, //get operation\n+            let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pats[0].node, //get operation\n             method_chain_args(op, &[\"ok\"]).is_some() //test to see if using ok() methoduse std::marker::Sized;\n \n         ], {"}, {"sha": "4216345e48e7570e85c4d74dd1e60053c58b8743", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -32,8 +32,8 @@ impl LintPass for NonSensical {\n     }\n }\n \n-impl LateLintPass for NonSensical {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSensical {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n             let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&arguments[0]));\n             if &*name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n@@ -71,36 +71,32 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n             let argument_option = match arguments[1].node {\n                 ExprLit(ref span) => {\n                     if let Spanned { node: LitKind::Bool(lit), .. } = **span {\n-                        if lit {\n-                            Argument::True\n-                        } else {\n-                            Argument::False\n-                        }\n+                        if lit { Argument::True } else { Argument::False }\n                     } else {\n                         return; // The function is called with a literal\n                                 // which is not a boolean literal. This is theoretically\n                                 // possible, but not very likely.\n                     }\n-                }\n+                },\n                 _ => Argument::Unknown,\n             };\n \n             match &*name.node.as_str() {\n                 \"create\" => {\n                     options.push((OpenOption::Create, argument_option));\n-                }\n+                },\n                 \"append\" => {\n                     options.push((OpenOption::Append, argument_option));\n-                }\n+                },\n                 \"truncate\" => {\n                     options.push((OpenOption::Truncate, argument_option));\n-                }\n+                },\n                 \"read\" => {\n                     options.push((OpenOption::Read, argument_option));\n-                }\n+                },\n                 \"write\" => {\n                     options.push((OpenOption::Write, argument_option));\n-                }\n+                },\n                 _ => (),\n             }\n \n@@ -111,11 +107,8 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n \n fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n     let (mut create, mut append, mut truncate, mut read, mut write) = (false, false, false, false, false);\n-    let (mut create_arg, mut append_arg, mut truncate_arg, mut read_arg, mut write_arg) = (false,\n-                                                                                           false,\n-                                                                                           false,\n-                                                                                           false,\n-                                                                                           false);\n+    let (mut create_arg, mut append_arg, mut truncate_arg, mut read_arg, mut write_arg) =\n+        (false, false, false, false, false);\n     // This code is almost duplicated (oh, the irony), but I haven't found a way to unify it.\n \n     for option in options {\n@@ -130,7 +123,7 @@ fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span\n                     create = true\n                 }\n                 create_arg = create_arg || (arg == Argument::True);;\n-            }\n+            },\n             (OpenOption::Append, arg) => {\n                 if append {\n                     span_lint(cx,\n@@ -141,7 +134,7 @@ fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span\n                     append = true\n                 }\n                 append_arg = append_arg || (arg == Argument::True);;\n-            }\n+            },\n             (OpenOption::Truncate, arg) => {\n                 if truncate {\n                     span_lint(cx,\n@@ -152,7 +145,7 @@ fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span\n                     truncate = true\n                 }\n                 truncate_arg = truncate_arg || (arg == Argument::True);\n-            }\n+            },\n             (OpenOption::Read, arg) => {\n                 if read {\n                     span_lint(cx,\n@@ -163,7 +156,7 @@ fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span\n                     read = true\n                 }\n                 read_arg = read_arg || (arg == Argument::True);;\n-            }\n+            },\n             (OpenOption::Write, arg) => {\n                 if write {\n                     span_lint(cx,\n@@ -174,7 +167,7 @@ fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span\n                     write = true\n                 }\n                 write_arg = write_arg || (arg == Argument::True);;\n-            }\n+            },\n         }\n     }\n "}, {"sha": "f2e478865497e4211ad0546b31122549e184108b", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -29,49 +29,53 @@ impl LintPass for OverflowCheckConditional {\n     }\n }\n \n-impl LateLintPass for OverflowCheckConditional {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n     // a + b < a, a > a + b, a < a - b, a - b > a\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain! {[\n             let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n             let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node,\n-            let Expr_::ExprPath(_,ref path1) = ident1.node,\n-            let Expr_::ExprPath(_, ref path2) = ident2.node,\n-            let Expr_::ExprPath(_, ref path3) = second.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = second.node,\n             &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n             cx.tcx.tables().expr_ty(ident1).is_integral(),\n             cx.tcx.tables().expr_ty(ident2).is_integral()\n         ], {\n             if let BinOp_::BiLt = op.node {\n                 if let BinOp_::BiAdd = op2.node {\n-                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n+                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n+                        \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n                 }\n             }\n             if let BinOp_::BiGt = op.node {\n                 if let BinOp_::BiSub = op2.node {\n-                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n+                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n+                        \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n                 }\n             }\n         }}\n \n         if_let_chain! {[\n             let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n             let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node,\n-            let Expr_::ExprPath(_,ref path1) = ident1.node,\n-            let Expr_::ExprPath(_, ref path2) = ident2.node,\n-            let Expr_::ExprPath(_, ref path3) = first.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = first.node,\n             &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n             cx.tcx.tables().expr_ty(ident1).is_integral(),\n             cx.tcx.tables().expr_ty(ident2).is_integral()\n         ], {\n             if let BinOp_::BiGt = op.node {\n                 if let BinOp_::BiAdd = op2.node {\n-                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n+                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n+                        \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n                 }\n             }\n             if let BinOp_::BiLt = op.node {\n                 if let BinOp_::BiSub = op2.node {\n-                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n+                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n+                        \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n                 }\n             }\n         }}"}, {"sha": "3b4fbb3ab1b6da937baaeb9cf2739dd64f3542a2", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -32,16 +32,15 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain! {[\n             let ExprBlock(ref block) = expr.node,\n             let Some(ref ex) = block.expr,\n             let ExprCall(ref fun, ref params) = ex.node,\n             params.len() == 2,\n-            let ExprPath(None, _) = fun.node,\n-            let Some(fun) = resolve_node(cx, fun.id),\n-            match_def_path(cx, fun.def_id(), &paths::BEGIN_PANIC),\n+            let ExprPath(ref qpath) = fun.node,\n+            match_def_path(cx, resolve_node(cx, qpath, fun.id).def_id(), &paths::BEGIN_PANIC),\n             let ExprLit(ref lit) = params[0].node,\n             is_direct_expn_of(cx, params[0].span, \"panic\").is_some(),\n             let LitKind::Str(ref string, _) = lit.node,"}, {"sha": "2677b40f757a9d4d57ce363d9d1b44ae28760321", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -35,12 +35,12 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if_let_chain! {[\n             let ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) = item.node,\n             !is_automatically_derived(&*item.attrs),\n-            cx.tcx.expect_def(trait_ref.ref_id).def_id() == cx.tcx.lang_items.eq_trait().unwrap(),\n+            trait_ref.path.def.def_id() == cx.tcx.lang_items.eq_trait().unwrap(),\n         ], {\n             for impl_item in impl_items {\n                 if &*impl_item.name.as_str() == \"ne\" {"}, {"sha": "146706646ae4abf5b90d39a63d575ae525525165", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -49,7 +49,7 @@ impl EarlyLintPass for Precedence {\n                                        snippet(cx, left.span, \"..\"),\n                                        op.to_string(),\n                                        snippet(cx, right.span, \"..\")));\n-                }\n+                },\n                 (true, false) => {\n                     span_lint(cx,\n                               PRECEDENCE,\n@@ -59,7 +59,7 @@ impl EarlyLintPass for Precedence {\n                                        snippet(cx, left.span, \"..\"),\n                                        op.to_string(),\n                                        snippet(cx, right.span, \"..\")));\n-                }\n+                },\n                 (false, true) => {\n                     span_lint(cx,\n                               PRECEDENCE,\n@@ -69,7 +69,7 @@ impl EarlyLintPass for Precedence {\n                                        snippet(cx, left.span, \"..\"),\n                                        op.to_string(),\n                                        snippet(cx, right.span, \"..\")));\n-                }\n+                },\n                 _ => (),\n             }\n         }\n@@ -88,7 +88,7 @@ impl EarlyLintPass for Precedence {\n                                           &format!(\"unary minus has lower precedence than method call. Consider \\\n                                                     adding parentheses to clarify your intent: -({})\",\n                                                    snippet(cx, rhs.span, \"..\")));\n-                            }\n+                            },\n                             _ => (),\n                         }\n                     }"}, {"sha": "daa55c9675fcb029b6427384ab2bffe37d042b77", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::*;\n use rustc::hir::map::Node::{NodeItem, NodeImplItem};\n use rustc::lint::*;\n use utils::paths;\n-use utils::{is_expn_of, match_path, match_def_path, resolve_node, span_lint};\n+use utils::{is_expn_of, match_def_path, resolve_node, span_lint, match_path_old};\n use format::get_argument_fmtstr_parts;\n \n /// **What it does:** This lint warns when you using `print!()` with a format string that\n@@ -65,13 +65,13 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain! {[\n             let ExprCall(ref fun, ref args) = expr.node,\n-            let ExprPath(..) = fun.node,\n-            let Some(fun) = resolve_node(cx, fun.id),\n+            let ExprPath(ref qpath) = fun.node,\n         ], {\n+            let fun = resolve_node(cx, qpath, fun.id);\n             let fun_id = fun.def_id();\n \n             // Search for `std::io::_print(..)` which is unique in a\n@@ -93,9 +93,8 @@ impl LateLintPass for Pass {\n                         // ensure we're calling Arguments::new_v1\n                         args.len() == 1,\n                         let ExprCall(ref args_fun, ref args_args) = args[0].node,\n-                        let ExprPath(..) = args_fun.node,\n-                        let Some(def) = resolve_node(cx, args_fun.id),\n-                        match_def_path(cx, def.def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n+                        let ExprPath(ref qpath) = args_fun.node,\n+                        match_def_path(cx, resolve_node(cx, qpath, args_fun.id).def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n                         args_args.len() == 2,\n                         let ExprAddrOf(_, ref match_expr) = args_args[1].node,\n                         let ExprMatch(ref args, _, _) = match_expr.node,\n@@ -121,8 +120,8 @@ impl LateLintPass for Pass {\n             // Search for something like\n             // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n             else if args.len() == 2 && match_def_path(cx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n-                if let ExprPath(None, _) = args[1].node {\n-                    let def_id = resolve_node(cx, args[1].id).unwrap().def_id();\n+                if let ExprPath(ref qpath) = args[1].node {\n+                    let def_id = cx.tcx.tables().qpath_def(qpath, args[1].id).def_id();\n                     if match_def_path(cx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n                        is_expn_of(cx, expr.span, \"panic\").is_none() {\n                         span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n@@ -141,7 +140,7 @@ fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n         // `Debug` impl\n         if let Some(NodeItem(item)) = map.find(map.get_parent(item.id)) {\n             if let ItemImpl(_, _, _, Some(ref tr), _, _) = item.node {\n-                return match_path(&tr.path, &[\"Debug\"]);\n+                return match_path_old(&tr.path, &[\"Debug\"]);\n             }\n         }\n     }"}, {"sha": "2f74390cc73e272bdfd44c5e4c48cdae18d169d5", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -54,14 +54,14 @@ impl LintPass for PointerPass {\n     }\n }\n \n-impl LateLintPass for PointerPass {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemFn(ref decl, _, _, _, _, _) = item.node {\n             check_fn(cx, decl, item.id);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(ref sig, _) = item.node {\n             if let Some(NodeItem(it)) = cx.tcx.map.find(cx.tcx.map.get_parent(item.id)) {\n                 if let ItemImpl(_, _, _, Some(_), _, _) = it.node {\n@@ -72,13 +72,13 @@ impl LateLintPass for PointerPass {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n             check_fn(cx, &sig.decl, item.id);\n         }\n     }\n-    \n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprBinary(ref op, ref l, ref r) = expr.node {\n             if (op.node == BiEq || op.node == BiNe) && (is_null_path(l) || is_null_path(r)) {\n                 span_lint(cx,\n@@ -94,7 +94,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n     let fn_def_id = cx.tcx.map.local_def_id(fn_id);\n     let fn_ty = cx.tcx.item_type(fn_def_id).fn_sig().skip_binder();\n \n-    for (arg, ty) in decl.inputs.iter().zip(&fn_ty.inputs) {\n+    for (arg, ty) in decl.inputs.iter().zip(fn_ty.inputs()) {\n         if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {\n             if match_type(cx, ty, &paths::VEC) {\n                 span_lint(cx,\n@@ -116,8 +116,8 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n fn is_null_path(expr: &Expr) -> bool {\n     if let ExprCall(ref pathexp, ref args) = expr.node {\n         if args.is_empty() {\n-            if let ExprPath(_, ref path) = pathexp.node {\n-                return match_path(path, &paths::PTR_NULL) || match_path(path, &paths::PTR_NULL_MUT)\n+            if let ExprPath(ref path) = pathexp.node {\n+                return match_path(path, &paths::PTR_NULL) || match_path(path, &paths::PTR_NULL_MUT);\n             }\n         }\n     }"}, {"sha": "01829ffea45bd865f0b2b08a3ee8be6f871b9ac9", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -46,14 +46,13 @@ impl LintPass for StepByZero {\n     }\n }\n \n-impl LateLintPass for StepByZero {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) = expr.node {\n             let name = &*name.as_str();\n \n             // Range with step_by(0).\n-            if name == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) &&\n-               is_integer_literal(&args[1], 0) {\n+            if name == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) && is_integer_literal(&args[1], 0) {\n                 span_lint(cx,\n                           RANGE_STEP_BY_ZERO,\n                           expr.span,\n@@ -73,15 +72,15 @@ impl LateLintPass for StepByZero {\n                     let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n                     &*len_name.as_str() == \"len\" && len_args.len() == 1,\n                     // .iter() and .len() called on same Path\n-                    let ExprPath(_, Path { segments: ref iter_path, .. }) = iter_args[0].node,\n-                    let ExprPath(_, Path { segments: ref len_path, .. }) = len_args[0].node,\n-                    iter_path == len_path\n+                    let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node,\n+                    let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node,\n+                    iter_path.segments == len_path.segments\n                  ], {\n-                    span_lint(cx,\n-                              RANGE_ZIP_WITH_LEN,\n-                              expr.span,\n-                              &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n-                                       snippet(cx, iter_args[0].span, \"_\")));\n+                     span_lint(cx,\n+                               RANGE_ZIP_WITH_LEN,\n+                               expr.span,\n+                               &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n+                                        snippet(cx, iter_args[0].span, \"_\")));\n                 }}\n             }\n         }\n@@ -94,7 +93,6 @@ fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n     let ty = cx.tcx.tables().expr_ty(expr);\n \n     // Note: `RangeTo`, `RangeToInclusive` and `RangeFull` don't have step_by\n-    match_type(cx, ty, &paths::RANGE)\n-        || match_type(cx, ty, &paths::RANGE_FROM)\n-        || match_type(cx, ty, &paths::RANGE_INCLUSIVE)\n+    match_type(cx, ty, &paths::RANGE) || match_type(cx, ty, &paths::RANGE_FROM) ||\n+    match_type(cx, ty, &paths::RANGE_INCLUSIVE)\n }"}, {"sha": "7c5c5713550a56fde1e6b91449b10268a41bbc15", "filename": "clippy_lints/src/reference.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -0,0 +1,49 @@\n+use syntax::ast::{Expr, ExprKind, UnOp};\n+use rustc::lint::*;\n+use utils::{span_lint_and_then, snippet};\n+\n+/// **What it does:** Checks for usage of `*&` and `*&mut` in expressions.\n+///\n+/// **Why is this bad?** Immediately dereferencing a reference is no-op and\n+/// makes the code less clear.\n+///\n+/// **Known problems:** Multiple dereference/addrof pairs are not handled so\n+/// the suggested fix for `x = **&&y` is `x = *&y`, which is still incorrect.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let a = f(*&mut b);\n+/// let c = *&d;\n+/// ```\n+declare_lint! {\n+    pub DEREF_ADDROF,\n+    Warn,\n+    \"use of `*&` or `*&mut` in an expression\"\n+}\n+\n+pub struct Pass;\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(DEREF_ADDROF)\n+    }\n+}\n+\n+fn without_parens(mut e: &Expr) -> &Expr {\n+    while let ExprKind::Paren(ref child_e) = e.node {\n+        e = child_e;\n+    }\n+    e\n+}\n+\n+impl EarlyLintPass for Pass {\n+    fn check_expr(&mut self, cx: &EarlyContext, e: &Expr) {\n+        if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.node {\n+            if let ExprKind::AddrOf(_, ref addrof_target) = without_parens(deref_target).node {\n+                span_lint_and_then(cx, DEREF_ADDROF, e.span, \"immediately dereferencing a reference\", |db| {\n+                    db.span_suggestion(e.span, \"try this\", format!(\"{}\", snippet(cx, addrof_target.span, \"_\")));\n+                });\n+            }\n+        }\n+    }\n+}"}, {"sha": "31ac194ca7bf20999ed6844390b5fb74caa08117", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -82,12 +82,12 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_crate(&mut self, _: &LateContext, _: &Crate) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_crate(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx Crate) {\n         self.spans.clear();\n     }\n \n-    fn check_block(&mut self, cx: &LateContext, block: &Block) {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n         if_let_chain!{[\n             self.last.is_none(),\n             let Some(ref expr) = block.expr,\n@@ -106,19 +106,19 @@ impl LateLintPass for Pass {\n         }}\n     }\n \n-    fn check_block_post(&mut self, _: &LateContext, block: &Block) {\n+    fn check_block_post(&mut self, _: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n         if self.last.map_or(false, |id| block.id == id) {\n             self.last = None;\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain!{[\n             let ExprCall(ref fun, ref args) = expr.node,\n+            let ExprPath(ref qpath) = fun.node,\n             args.len() == 1,\n-            let Some(def) = cx.tcx.def_map.borrow().get(&fun.id),\n         ], {\n-            let def_id = def.full_def().def_id();\n+            let def_id = cx.tcx.tables().qpath_def(qpath, fun.id).def_id();\n             if match_def_path(cx, def_id, &paths::REGEX_NEW) ||\n                match_def_path(cx, def_id, &paths::REGEX_BUILDER_NEW) {\n                 check_regex(cx, &args[0], true);\n@@ -145,7 +145,7 @@ fn str_span(base: Span, s: &str, c: usize) -> Span {\n                 hi: base.lo + BytePos(h as u32),\n                 ..base\n             }\n-        }\n+        },\n         _ => base,\n     }\n }\n@@ -172,17 +172,18 @@ fn is_trivial_regex(s: &regex_syntax::Expr) -> Option<&'static str> {\n                         (&Expr::Literal { .. }, &Expr::EndText) => Some(\"consider using `str::ends_with`\"),\n                         _ => None,\n                     }\n-                }\n+                },\n                 3 => {\n-                    if let (&Expr::StartText, &Expr::Literal {..}, &Expr::EndText) = (&exprs[0], &exprs[1], &exprs[2]) {\n+                    if let (&Expr::StartText, &Expr::Literal { .. }, &Expr::EndText) =\n+                        (&exprs[0], &exprs[1], &exprs[2]) {\n                         Some(\"consider using `==` on `str`s\")\n                     } else {\n                         None\n                     }\n-                }\n+                },\n                 _ => None,\n             }\n-        }\n+        },\n         _ => None,\n     }\n }\n@@ -213,14 +214,13 @@ fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n                                            \"trivial regex\",\n                                            &format!(\"consider using {}\", repl));\n                     }\n-                }\n+                },\n                 Err(e) => {\n                     span_lint(cx,\n                               INVALID_REGEX,\n                               str_span(expr.span, r, e.position()),\n-                              &format!(\"regex syntax error: {}\",\n-                                       e.description()));\n-                }\n+                              &format!(\"regex syntax error: {}\", e.description()));\n+                },\n             }\n         }\n     } else if let Some(r) = const_str(cx, expr) {\n@@ -233,15 +233,13 @@ fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n                                        \"trivial regex\",\n                                        &format!(\"consider using {}\", repl));\n                 }\n-            }\n+            },\n             Err(e) => {\n                 span_lint(cx,\n                           INVALID_REGEX,\n                           expr.span,\n-                          &format!(\"regex syntax error on position {}: {}\",\n-                                   e.position(),\n-                                   e.description()));\n-            }\n+                          &format!(\"regex syntax error on position {}: {}\", e.position(), e.description()));\n+            },\n         }\n     }\n }"}, {"sha": "b9054f72164ba460b289985b2ea68d8baaf4ca89", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -48,9 +48,10 @@ impl ReturnPass {\n     fn check_block_return(&mut self, cx: &EarlyContext, block: &ast::Block) {\n         if let Some(stmt) = block.stmts.last() {\n             match stmt.node {\n-                ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n+                ast::StmtKind::Expr(ref expr) |\n+                ast::StmtKind::Semi(ref expr) => {\n                     self.check_final_expr(cx, expr, Some(stmt.span));\n-                }\n+                },\n                 _ => (),\n             }\n         }\n@@ -65,24 +66,24 @@ impl ReturnPass {\n                 if !expr.attrs.iter().any(attr_is_cfg) {\n                     self.emit_return_lint(cx, span.expect(\"`else return` is not possible\"), inner.span);\n                 }\n-            }\n+            },\n             // a whole block? check it!\n             ast::ExprKind::Block(ref block) => {\n                 self.check_block_return(cx, block);\n-            }\n+            },\n             // an if/if let expr, check both exprs\n             // note, if without else is going to be a type checking error anyways\n             // (except for unit type functions) so we don't match it\n             ast::ExprKind::If(_, ref ifblock, Some(ref elsexpr)) => {\n                 self.check_block_return(cx, ifblock);\n                 self.check_final_expr(cx, elsexpr, None);\n-            }\n+            },\n             // a match expr, check all arms\n             ast::ExprKind::Match(_, ref arms) => {\n                 for arm in arms {\n                     self.check_final_expr(cx, &arm.body, Some(arm.body.span));\n                 }\n-            }\n+            },\n             _ => (),\n         }\n     }\n@@ -135,7 +136,8 @@ impl LintPass for ReturnPass {\n impl EarlyLintPass for ReturnPass {\n     fn check_fn(&mut self, cx: &EarlyContext, kind: FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) {\n         match kind {\n-            FnKind::ItemFn(.., block) | FnKind::Method(.., block) => self.check_block_return(cx, block),\n+            FnKind::ItemFn(.., block) |\n+            FnKind::Method(.., block) => self.check_block_return(cx, block),\n             FnKind::Closure(body) => self.check_final_expr(cx, body, None),\n         }\n     }\n@@ -152,4 +154,3 @@ fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n         false\n     }\n }\n-"}, {"sha": "02faf7a204fb3f5279ade4a88990713fd960ae45", "filename": "clippy_lints/src/serde.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fserde.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fserde.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -26,10 +26,10 @@ impl LintPass for Serde {\n     }\n }\n \n-impl LateLintPass for Serde {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Serde {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemImpl(_, _, _, Some(ref trait_ref), _, ref items) = item.node {\n-            let did = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n+            let did = trait_ref.path.def.def_id();\n             if let Some(visit_did) = get_trait_def_id(cx, &paths::SERDE_DE_VISITOR) {\n                 if did == visit_did {\n                     let mut seen_str = None;\n@@ -46,8 +46,7 @@ impl LateLintPass for Serde {\n                             span_lint(cx,\n                                       SERDE_API_MISUSE,\n                                       span,\n-                                      \"you should not implement `visit_string` without also implementing `visit_str`\",\n-                            );\n+                                      \"you should not implement `visit_string` without also implementing `visit_str`\");\n                         }\n                     }\n                 }"}, {"sha": "9c5b032f6251e5b4636faaf8f1b3b76738c5a11c", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 86, "deletions": 60, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,9 +1,8 @@\n use reexport::*;\n use rustc::lint::*;\n-use rustc::hir::def::Def;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, FnKind};\n-use std::ops::Deref;\n+use rustc::hir::intravisit::{Visitor, FnKind, NestedVisitorMap};\n+use rustc::ty;\n use syntax::codemap::Span;\n use utils::{higher, in_external_macro, snippet, span_lint_and_then};\n \n@@ -80,26 +79,34 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, expr: &Expr, _: Span, _: NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        expr: &'tcx Expr,\n+        _: Span,\n+        _: NodeId\n+    ) {\n         if in_external_macro(cx, expr.span) {\n             return;\n         }\n         check_fn(cx, decl, expr);\n     }\n }\n \n-fn check_fn(cx: &LateContext, decl: &FnDecl, expr: &Expr) {\n+fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, expr: &'tcx Expr) {\n     let mut bindings = Vec::new();\n     for arg in &decl.inputs {\n-        if let PatKind::Binding(_, ident, _) = arg.pat.node {\n+        if let PatKind::Binding(_, _, ident, _) = arg.pat.node {\n             bindings.push((ident.node, ident.span))\n         }\n     }\n     check_expr(cx, expr, &mut bindings);\n }\n \n-fn check_block(cx: &LateContext, block: &Block, bindings: &mut Vec<(Name, Span)>) {\n+fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, bindings: &mut Vec<(Name, Span)>) {\n     let len = bindings.len();\n     for stmt in &block.stmts {\n         match stmt.node {\n@@ -114,7 +121,7 @@ fn check_block(cx: &LateContext, block: &Block, bindings: &mut Vec<(Name, Span)>\n     bindings.truncate(len);\n }\n \n-fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n+fn check_decl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx, decl.span) {\n         return;\n     }\n@@ -128,27 +135,33 @@ fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n         }\n         if let Some(ref o) = *init {\n             check_expr(cx, o, bindings);\n-            check_pat(cx, pat, &Some(o), span, bindings);\n+            check_pat(cx, pat, Some(o), span, bindings);\n         } else {\n-            check_pat(cx, pat, &None, span, bindings);\n+            check_pat(cx, pat, None, span, bindings);\n         }\n     }\n }\n \n-fn is_binding(cx: &LateContext, pat: &Pat) -> bool {\n-    match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-        Some(Def::Variant(..)) |\n-        Some(Def::Struct(..)) => false,\n+fn is_binding(cx: &LateContext, pat_id: NodeId) -> bool {\n+    let var_ty = cx.tcx.tables().node_id_to_type(pat_id);\n+    match var_ty.sty {\n+        ty::TyAdt(..) => false,\n         _ => true,\n     }\n }\n \n-fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bindings: &mut Vec<(Name, Span)>) {\n+fn check_pat<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    init: Option<&'tcx Expr>,\n+    span: Span,\n+    bindings: &mut Vec<(Name, Span)>\n+) {\n     // TODO: match more stuff / destructuring\n     match pat.node {\n-        PatKind::Binding(_, ref ident, ref inner) => {\n+        PatKind::Binding(_, _, ref ident, ref inner) => {\n             let name = ident.node;\n-            if is_binding(cx, pat) {\n+            if is_binding(cx, pat.id) {\n                 let mut new_binding = true;\n                 for tup in bindings.iter_mut() {\n                     if tup.0 == name {\n@@ -165,16 +178,16 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n             if let Some(ref p) = *inner {\n                 check_pat(cx, p, init, span, bindings);\n             }\n-        }\n+        },\n         PatKind::Struct(_, ref pfields, _) => {\n-            if let Some(init_struct) = *init {\n+            if let Some(init_struct) = init {\n                 if let ExprStruct(_, ref efields, _) = init_struct.node {\n                     for field in pfields {\n                         let name = field.node.name;\n                         let efield = efields.iter()\n-                                            .find(|f| f.name.node == name)\n-                                            .map(|f| &*f.expr);\n-                        check_pat(cx, &field.node.pat, &efield, span, bindings);\n+                            .find(|f| f.name.node == name)\n+                            .map(|f| &*f.expr);\n+                        check_pat(cx, &field.node.pat, efield, span, bindings);\n                     }\n                 } else {\n                     for field in pfields {\n@@ -183,15 +196,15 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n                 }\n             } else {\n                 for field in pfields {\n-                    check_pat(cx, &field.node.pat, &None, span, bindings);\n+                    check_pat(cx, &field.node.pat, None, span, bindings);\n                 }\n             }\n-        }\n+        },\n         PatKind::Tuple(ref inner, _) => {\n-            if let Some(init_tup) = *init {\n+            if let Some(init_tup) = init {\n                 if let ExprTup(ref tup) = init_tup.node {\n                     for (i, p) in inner.iter().enumerate() {\n-                        check_pat(cx, p, &Some(&tup[i]), p.span, bindings);\n+                        check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n                     }\n                 } else {\n                     for p in inner {\n@@ -200,51 +213,57 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n                 }\n             } else {\n                 for p in inner {\n-                    check_pat(cx, p, &None, span, bindings);\n+                    check_pat(cx, p, None, span, bindings);\n                 }\n             }\n-        }\n+        },\n         PatKind::Box(ref inner) => {\n-            if let Some(initp) = *init {\n+            if let Some(initp) = init {\n                 if let ExprBox(ref inner_init) = initp.node {\n-                    check_pat(cx, inner, &Some(&**inner_init), span, bindings);\n+                    check_pat(cx, inner, Some(&**inner_init), span, bindings);\n                 } else {\n                     check_pat(cx, inner, init, span, bindings);\n                 }\n             } else {\n                 check_pat(cx, inner, init, span, bindings);\n             }\n-        }\n+        },\n         PatKind::Ref(ref inner, _) => check_pat(cx, inner, init, span, bindings),\n         // PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n         _ => (),\n     }\n }\n \n-fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, pattern_span: Span, init: &Option<T>, prev_span: Span)\n-    where T: Deref<Target = Expr>\n-{\n-    if let Some(ref expr) = *init {\n+fn lint_shadow<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    name: Name,\n+    span: Span,\n+    pattern_span: Span,\n+    init: Option<&'tcx Expr>,\n+    prev_span: Span\n+) {\n+    if let Some(expr) = init {\n         if is_self_shadow(name, expr) {\n             span_lint_and_then(cx,\n                                SHADOW_SAME,\n                                span,\n                                &format!(\"`{}` is shadowed by itself in `{}`\",\n                                         snippet(cx, pattern_span, \"_\"),\n                                         snippet(cx, expr.span, \"..\")),\n-                               |db| { db.span_note(prev_span, \"previous binding is here\"); },\n-            );\n-        } else if contains_self(name, expr) {\n+                               |db| {\n+                db.span_note(prev_span, \"previous binding is here\");\n+            });\n+        } else if contains_self(cx, name, expr) {\n             span_lint_and_then(cx,\n                                SHADOW_REUSE,\n                                pattern_span,\n                                &format!(\"`{}` is shadowed by `{}` which reuses the original value\",\n                                         snippet(cx, pattern_span, \"_\"),\n                                         snippet(cx, expr.span, \"..\")),\n                                |db| {\n-                                   db.span_note(expr.span, \"initialization happens here\");\n-                                   db.span_note(prev_span, \"previous binding is here\");\n-                               });\n+                db.span_note(expr.span, \"initialization happens here\");\n+                db.span_note(prev_span, \"previous binding is here\");\n+            });\n         } else {\n             span_lint_and_then(cx,\n                                SHADOW_UNRELATED,\n@@ -253,21 +272,23 @@ fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, pattern_span: Span,\n                                         snippet(cx, pattern_span, \"_\"),\n                                         snippet(cx, expr.span, \"..\")),\n                                |db| {\n-                                   db.span_note(expr.span, \"initialization happens here\");\n-                                   db.span_note(prev_span, \"previous binding is here\");\n-                               });\n+                db.span_note(expr.span, \"initialization happens here\");\n+                db.span_note(prev_span, \"previous binding is here\");\n+            });\n         }\n \n     } else {\n         span_lint_and_then(cx,\n                            SHADOW_UNRELATED,\n                            span,\n                            &format!(\"`{}` shadows a previous declaration\", snippet(cx, pattern_span, \"_\")),\n-                           |db| { db.span_note(prev_span, \"previous binding is here\"); });\n+                           |db| {\n+            db.span_note(prev_span, \"previous binding is here\");\n+        });\n     }\n }\n \n-fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n+fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx, expr.span) {\n         return;\n     }\n@@ -285,24 +306,24 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n             for e in v {\n                 check_expr(cx, e, bindings)\n             }\n-        }\n+        },\n         ExprIf(ref cond, ref then, ref otherwise) => {\n             check_expr(cx, cond, bindings);\n             check_block(cx, then, bindings);\n             if let Some(ref o) = *otherwise {\n                 check_expr(cx, o, bindings);\n             }\n-        }\n+        },\n         ExprWhile(ref cond, ref block, _) => {\n             check_expr(cx, cond, bindings);\n             check_block(cx, block, bindings);\n-        }\n+        },\n         ExprMatch(ref init, ref arms, _) => {\n             check_expr(cx, init, bindings);\n             let len = bindings.len();\n             for arm in arms {\n                 for pat in &arm.pats {\n-                    check_pat(cx, pat, &Some(&**init), pat.span, bindings);\n+                    check_pat(cx, pat, Some(&**init), pat.span, bindings);\n                     // This is ugly, but needed to get the right type\n                     if let Some(ref guard) = arm.guard {\n                         check_expr(cx, guard, bindings);\n@@ -311,26 +332,26 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n                     bindings.truncate(len);\n                 }\n             }\n-        }\n+        },\n         _ => (),\n     }\n }\n \n-fn check_ty(cx: &LateContext, ty: &Ty, bindings: &mut Vec<(Name, Span)>) {\n+fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut Vec<(Name, Span)>) {\n     match ty.node {\n         TyObjectSum(ref sty, _) |\n         TySlice(ref sty) => check_ty(cx, sty, bindings),\n         TyArray(ref fty, ref expr) => {\n             check_ty(cx, fty, bindings);\n             check_expr(cx, expr, bindings);\n-        }\n+        },\n         TyPtr(MutTy { ty: ref mty, .. }) |\n         TyRptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n         TyTup(ref tup) => {\n             for t in tup {\n                 check_ty(cx, t, bindings)\n             }\n-        }\n+        },\n         TyTypeof(ref expr) => check_expr(cx, expr, bindings),\n         _ => (),\n     }\n@@ -342,9 +363,9 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n         ExprAddrOf(_, ref inner) => is_self_shadow(name, inner),\n         ExprBlock(ref block) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |e| is_self_shadow(name, e))\n-        }\n+        },\n         ExprUnary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n-        ExprPath(_, ref path) => path_eq_name(name, path),\n+        ExprPath(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n         _ => false,\n     }\n }\n@@ -353,23 +374,28 @@ fn path_eq_name(name: Name, path: &Path) -> bool {\n     !path.global && path.segments.len() == 1 && path.segments[0].name.as_str() == name.as_str()\n }\n \n-struct ContainsSelf {\n+struct ContainsSelf<'a, 'tcx: 'a> {\n     name: Name,\n     result: bool,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'v> Visitor<'v> for ContainsSelf {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for ContainsSelf<'a, 'tcx> {\n     fn visit_name(&mut self, _: Span, name: Name) {\n         if self.name == name {\n             self.result = true;\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n-fn contains_self(name: Name, expr: &Expr) -> bool {\n+fn contains_self<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, name: Name, expr: &'tcx Expr) -> bool {\n     let mut cs = ContainsSelf {\n         name: name,\n         result: false,\n+        cx: cx,\n     };\n     cs.visit_expr(expr);\n     cs.result"}, {"sha": "195b49c72f68427f8f0ebe2cad03e64783f41114", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -79,8 +79,8 @@ impl LintPass for StringAdd {\n     }\n }\n \n-impl LateLintPass for StringAdd {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) = e.node {\n             if is_string(cx, left) {\n                 if let Allow = cx.current_level(STRING_ADD_ASSIGN) {\n@@ -122,7 +122,7 @@ fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n         ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n         ExprBlock(ref block) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n-        }\n+        },\n         _ => false,\n     }\n }\n@@ -136,8 +136,8 @@ impl LintPass for StringLitAsBytes {\n     }\n }\n \n-impl LateLintPass for StringLitAsBytes {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use std::ascii::AsciiExt;\n         use syntax::ast::LitKind;\n         use utils::{snippet, in_macro};\n@@ -152,11 +152,9 @@ impl LateLintPass for StringLitAsBytes {\n                                                e.span,\n                                                \"calling `as_bytes()` on a string literal\",\n                                                |db| {\n-                                                   let sugg = format!(\"b{}\", snippet(cx, args[0].span, r#\"\"foo\"\"#));\n-                                                   db.span_suggestion(e.span,\n-                                                                      \"consider using a byte string literal instead\",\n-                                                                      sugg);\n-                                               });\n+                                let sugg = format!(\"b{}\", snippet(cx, args[0].span, r#\"\"foo\"\"#));\n+                                db.span_suggestion(e.span, \"consider using a byte string literal instead\", sugg);\n+                            });\n \n                         }\n                     }"}, {"sha": "8ed7e355879762b491a3c32c34b916a543cd21d5", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -50,8 +50,8 @@ impl LintPass for Swap {\n     }\n }\n \n-impl LateLintPass for Swap {\n-    fn check_block(&mut self, cx: &LateContext, block: &Block) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Swap {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n         check_manual_swap(cx, block);\n         check_suspicious_swap(cx, block);\n     }\n@@ -65,7 +65,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             let StmtDecl(ref tmp, _) = w[0].node,\n             let DeclLocal(ref tmp) = tmp.node,\n             let Some(ref tmp_init) = tmp.init,\n-            let PatKind::Binding(_, ref tmp_name, None) = tmp.pat.node,\n+            let PatKind::Binding(_, _, ref tmp_name, None) = tmp.pat.node,\n \n             // foo() = bar();\n             let StmtSemi(ref first, _) = w[1].node,\n@@ -74,14 +74,18 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             // bar() = t;\n             let StmtSemi(ref second, _) = w[2].node,\n             let ExprAssign(ref lhs2, ref rhs2) = second.node,\n-            let ExprPath(None, ref rhs2) = rhs2.node,\n+            let ExprPath(QPath::Resolved(None, ref rhs2)) = rhs2.node,\n             rhs2.segments.len() == 1,\n \n             tmp_name.node.as_str() == rhs2.segments[0].name.as_str(),\n             SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1),\n             SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2)\n         ], {\n-            fn check_for_slice<'a>(cx: &LateContext, lhs1: &'a Expr, lhs2: &'a Expr) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n+            fn check_for_slice<'a>(\n+                cx: &LateContext,\n+                lhs1: &'a Expr,\n+                lhs2: &'a Expr,\n+            ) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n                 if let ExprIndex(ref lhs1, ref idx1) = lhs1.node {\n                     if let ExprIndex(ref lhs2, ref idx2) = lhs2.node {\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n@@ -104,7 +108,10 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n                 if let Some(slice) = Sugg::hir_opt(cx, slice) {\n                     (false,\n                      format!(\" elements of `{}`\", slice),\n-                     format!(\"{}.swap({}, {})\", slice.maybe_par(), snippet(cx, idx1.span, \"..\"), snippet(cx, idx2.span, \"..\")))\n+                     format!(\"{}.swap({}, {})\",\n+                             slice.maybe_par(),\n+                             snippet(cx, idx1.span, \"..\"),\n+                             snippet(cx, idx2.span, \"..\")))\n                 } else {\n                     (false, \"\".to_owned(), \"\".to_owned())\n                 }\n@@ -148,7 +155,9 @@ fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n             SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1),\n             SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0)\n         ], {\n-            let (what, lhs, rhs) = if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs0), Sugg::hir_opt(cx, rhs0)) {\n+            let lhs0 = Sugg::hir_opt(cx, lhs0);\n+            let rhs0 = Sugg::hir_opt(cx, rhs0);\n+            let (what, lhs, rhs) = if let (Some(first), Some(second)) = (lhs0, rhs0) {\n                 (format!(\" `{}` and `{}`\", first, second), first.mut_addr().to_string(), second.mut_addr().to_string())\n             } else {\n                 (\"\".to_owned(), \"\".to_owned(), \"\".to_owned())"}, {"sha": "1669b2d65572648f65c708c8c767fca6d0cf668f", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -37,16 +37,16 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprAssign(ref target, _) = expr.node {\n             match target.node {\n                 ExprField(ref base, _) |\n                 ExprTupField(ref base, _) => {\n                     if is_temporary(base) && !is_adjusted(cx, base) {\n                         span_lint(cx, TEMPORARY_ASSIGNMENT, expr.span, \"assignment to temporary\");\n                     }\n-                }\n+                },\n                 _ => (),\n             }\n         }"}, {"sha": "5e01f891eb1739bf79b5d55d672a838504c18747", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 63, "deletions": 62, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc::ty::TypeVariants::{TyRawPtr, TyRef};\n use rustc::ty;\n use rustc::hir::*;\n-use utils::{match_def_path, paths, span_lint, span_lint_and_then, snippet};\n+use utils::{match_def_path, paths, span_lint, span_lint_and_then, snippet, last_path_segment};\n use utils::sugg;\n \n /// **What it does:** Checks for transmutes that can't ever be correct on any\n@@ -84,29 +84,29 @@ impl LintPass for Transmute {\n     }\n }\n \n-impl LateLintPass for Transmute {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(None, ref path) = path_expr.node {\n-                let def_id = cx.tcx.expect_def(path_expr.id).def_id();\n+            if let ExprPath(ref qpath) = path_expr.node {\n+                let def_id = cx.tcx.tables().qpath_def(qpath, path_expr.id).def_id();\n \n                 if match_def_path(cx, def_id, &paths::TRANSMUTE) {\n                     let from_ty = cx.tcx.tables().expr_ty(&args[0]);\n                     let to_ty = cx.tcx.tables().expr_ty(e);\n \n                     match (&from_ty.sty, &to_ty.sty) {\n-                        _ if from_ty == to_ty => span_lint(\n-                            cx,\n-                            USELESS_TRANSMUTE,\n-                            e.span,\n-                            &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n-                        ),\n-                        (&TyRef(_, rty), &TyRawPtr(ptr_ty)) => span_lint_and_then(\n-                            cx,\n-                            USELESS_TRANSMUTE,\n-                            e.span,\n-                            \"transmute from a reference to a pointer\",\n-                            |db| {\n+                        _ if from_ty == to_ty => {\n+                            span_lint(cx,\n+                                      USELESS_TRANSMUTE,\n+                                      e.span,\n+                                      &format!(\"transmute from a type (`{}`) to itself\", from_ty))\n+                        },\n+                        (&TyRef(_, rty), &TyRawPtr(ptr_ty)) => {\n+                            span_lint_and_then(cx,\n+                                               USELESS_TRANSMUTE,\n+                                               e.span,\n+                                               \"transmute from a reference to a pointer\",\n+                                               |db| {\n                                 if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n                                     let sugg = if ptr_ty == rty {\n                                         arg.as_ty(to_ty)\n@@ -116,53 +116,54 @@ impl LateLintPass for Transmute {\n \n                                     db.span_suggestion(e.span, \"try\", sugg.to_string());\n                                 }\n-                            },\n-                        ),\n+                            })\n+                        },\n                         (&ty::TyInt(_), &TyRawPtr(_)) |\n-                        (&ty::TyUint(_), &TyRawPtr(_)) => span_lint_and_then(\n-                            cx,\n-                            USELESS_TRANSMUTE,\n-                            e.span,\n-                            \"transmute from an integer to a pointer\",\n-                            |db| {\n+                        (&ty::TyUint(_), &TyRawPtr(_)) => {\n+                            span_lint_and_then(cx,\n+                                               USELESS_TRANSMUTE,\n+                                               e.span,\n+                                               \"transmute from an integer to a pointer\",\n+                                               |db| {\n                                 if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n                                     db.span_suggestion(e.span, \"try\", arg.as_ty(&to_ty.to_string()).to_string());\n                                 }\n-                            },\n-                        ),\n+                            })\n+                        },\n                         (&ty::TyFloat(_), &TyRef(..)) |\n                         (&ty::TyFloat(_), &TyRawPtr(_)) |\n                         (&ty::TyChar, &TyRef(..)) |\n-                        (&ty::TyChar, &TyRawPtr(_)) => span_lint(\n-                            cx,\n-                            WRONG_TRANSMUTE,\n-                            e.span,\n-                            &format!(\"transmute from a `{}` to a pointer\", from_ty),\n-                        ),\n-                        (&TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n-                            cx,\n-                            CROSSPOINTER_TRANSMUTE,\n-                            e.span,\n-                            &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n-                                     from_ty,\n-                                     to_ty),\n-                        ),\n-                        (_, &TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n-                            cx,\n-                            CROSSPOINTER_TRANSMUTE,\n-                            e.span,\n-                            &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n-                                     from_ty,\n-                                     to_ty),\n-                        ),\n-                        (&TyRawPtr(from_pty), &TyRef(_, to_rty)) => span_lint_and_then(\n-                            cx,\n-                            TRANSMUTE_PTR_TO_REF,\n-                            e.span,\n-                            &format!(\"transmute from a pointer type (`{}`) to a reference type (`{}`)\",\n-                                    from_ty,\n-                                    to_ty),\n-                            |db| {\n+                        (&ty::TyChar, &TyRawPtr(_)) => {\n+                            span_lint(cx,\n+                                      WRONG_TRANSMUTE,\n+                                      e.span,\n+                                      &format!(\"transmute from a `{}` to a pointer\", from_ty))\n+                        },\n+                        (&TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => {\n+                            span_lint(cx,\n+                                      CROSSPOINTER_TRANSMUTE,\n+                                      e.span,\n+                                      &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n+                                               from_ty,\n+                                               to_ty))\n+                        },\n+                        (_, &TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => {\n+                            span_lint(cx,\n+                                      CROSSPOINTER_TRANSMUTE,\n+                                      e.span,\n+                                      &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n+                                               from_ty,\n+                                               to_ty))\n+                        },\n+                        (&TyRawPtr(from_pty), &TyRef(_, to_rty)) => {\n+                            span_lint_and_then(cx,\n+                                               TRANSMUTE_PTR_TO_REF,\n+                                               e.span,\n+                                               &format!(\"transmute from a pointer type (`{}`) to a reference type \\\n+                                                         (`{}`)\",\n+                                                        from_ty,\n+                                                        to_ty),\n+                                               |db| {\n                                 let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n                                 let (deref, cast) = if to_rty.mutbl == Mutability::MutMutable {\n                                     (\"&mut *\", \"*mut\")\n@@ -173,12 +174,12 @@ impl LateLintPass for Transmute {\n                                 let arg = if from_pty.ty == to_rty.ty {\n                                     arg\n                                 } else {\n-                                    arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, path, to_rty.ty)))\n+                                    arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_rty.ty)))\n                                 };\n \n                                 db.span_suggestion(e.span, \"try\", sugg::make_unop(deref, arg).to_string());\n-                            },\n-                        ),\n+                            })\n+                        },\n                         _ => return,\n                     };\n                 }\n@@ -190,9 +191,9 @@ impl LateLintPass for Transmute {\n /// Get the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is not available , use\n /// the type's `ToString` implementation. In weird cases it could lead to types with invalid `'_`\n /// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext, path: &Path, to_rty: ty::Ty) -> String {\n+fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: ty::Ty) -> String {\n+    let seg = last_path_segment(path);\n     if_let_chain!{[\n-        let Some(seg) = path.segments.last(),\n         let PathParameters::AngleBracketedParameters(ref ang) = seg.parameters,\n         let Some(to_ty) = ang.types.get(1),\n         let TyRptr(_, ref to_ty) = to_ty.node,"}, {"sha": "5885d7863b7104c7226afb84f2c9c82d2c6e0b76", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 179, "deletions": 100, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,13 +1,13 @@\n use reexport::*;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{FnKind, Visitor, walk_ty};\n+use rustc::hir::intravisit::{FnKind, Visitor, walk_ty, NestedVisitorMap};\n use rustc::lint::*;\n use rustc::ty;\n use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::codemap::Span;\n-use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet,\n-            span_help_and_lint, span_lint};\n+use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet, span_help_and_lint, span_lint,\n+            opt_def_id, last_path_segment};\n use utils::paths;\n \n /// Handles all the linting of funky types\n@@ -69,38 +69,107 @@ impl LintPass for TypePass {\n     }\n }\n \n-impl LateLintPass for TypePass {\n-    fn check_ty(&mut self, cx: &LateContext, ast_ty: &Ty) {\n-        if in_macro(cx, ast_ty.span) {\n-            return;\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n+    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Expr, _: Span, id: NodeId) {\n+        // skip trait implementations, see #605\n+        if let Some(map::NodeItem(item)) = cx.tcx.map.find(cx.tcx.map.get_parent(id)) {\n+            if let ItemImpl(_, _, _, Some(..), _, _) = item.node {\n+                return;\n+            }\n+        }\n+\n+        check_fn_decl(cx, decl);\n+    }\n+\n+    fn check_struct_field(&mut self, cx: &LateContext, field: &StructField) {\n+        check_ty(cx, &field.ty);\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+        match item.node {\n+            ConstTraitItem(ref ty, _) |\n+            TypeTraitItem(_, Some(ref ty)) => check_ty(cx, ty),\n+            MethodTraitItem(ref sig, _) => check_fn_decl(cx, &sig.decl),\n+            _ => (),\n         }\n-        if let Some(did) = cx.tcx.def_map.borrow().get(&ast_ty.id) {\n-            if let def::Def::Struct(..) = did.full_def() {\n-                if Some(did.full_def().def_id()) == cx.tcx.lang_items.owned_box() {\n+    }\n+}\n+\n+fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n+    for input in &decl.inputs {\n+        check_ty(cx, &input.ty);\n+    }\n+\n+    if let FunctionRetTy::Return(ref ty) = decl.output {\n+        check_ty(cx, ty);\n+    }\n+}\n+\n+fn check_ty(cx: &LateContext, ast_ty: &Ty) {\n+    if in_macro(cx, ast_ty.span) {\n+        return;\n+    }\n+    match ast_ty.node {\n+        TyPath(ref qpath) => {\n+            let def = cx.tcx.tables().qpath_def(qpath, ast_ty.id);\n+            if let Some(def_id) = opt_def_id(def) {\n+                if Some(def_id) == cx.tcx.lang_items.owned_box() {\n+                    let last = last_path_segment(qpath);\n                     if_let_chain! {[\n-                        let TyPath(_, ref path) = ast_ty.node,\n-                        let Some(ref last) = path.segments.last(),\n                         let PathParameters::AngleBracketedParameters(ref ag) = last.parameters,\n                         let Some(ref vec) = ag.types.get(0),\n-                        let Some(did) = cx.tcx.def_map.borrow().get(&vec.id),\n-                        let def::Def::Struct(..) = did.full_def(),\n-                        match_def_path(cx, did.full_def().def_id(), &paths::VEC),\n+                        let TyPath(ref qpath) = vec.node,\n+                        let def::Def::Struct(..) = cx.tcx.tables().qpath_def(qpath, vec.id),\n+                        let Some(did) = opt_def_id(cx.tcx.tables().qpath_def(qpath, vec.id)),\n+                        match_def_path(cx, did, &paths::VEC),\n                     ], {\n                         span_help_and_lint(cx,\n                                            BOX_VEC,\n                                            ast_ty.span,\n                                            \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n                                            \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n+                        return; // don't recurse into the type\n                     }}\n-                } else if match_def_path(cx, did.full_def().def_id(), &paths::LINKED_LIST) {\n+                } else if match_def_path(cx, def_id, &paths::LINKED_LIST) {\n                     span_help_and_lint(cx,\n                                        LINKEDLIST,\n                                        ast_ty.span,\n                                        \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n                                        \"a VecDeque might work\");\n+                    return; // don't recurse into the type\n                 }\n             }\n-        }\n+            match *qpath {\n+                QPath::Resolved(Some(ref ty), ref p) => {\n+                    check_ty(cx, ty);\n+                    for ty in p.segments.iter().flat_map(|seg| seg.parameters.types()) {\n+                        check_ty(cx, ty);\n+                    }\n+                },\n+                QPath::Resolved(None, ref p) => {\n+                    for ty in p.segments.iter().flat_map(|seg| seg.parameters.types()) {\n+                        check_ty(cx, ty);\n+                    }\n+                },\n+                QPath::TypeRelative(ref ty, ref seg) => {\n+                    check_ty(cx, ty);\n+                    for ty in seg.parameters.types() {\n+                        check_ty(cx, ty);\n+                    }\n+                },\n+            }\n+        },\n+        // recurse\n+        TySlice(ref ty) |\n+        TyArray(ref ty, _) |\n+        TyPtr(MutTy { ref ty, .. }) |\n+        TyRptr(_, MutTy { ref ty, .. }) => check_ty(cx, ty),\n+        TyTup(ref tys) => {\n+            for ty in tys {\n+                check_ty(cx, ty);\n+            }\n+        },\n+        _ => {},\n     }\n }\n \n@@ -140,7 +209,7 @@ fn check_let_unit(cx: &LateContext, decl: &Decl) {\n                           decl.span,\n                           &format!(\"this let-binding has unit value. Consider omitting `let {} =`\",\n                                    snippet(cx, local.pat.span, \"..\")));\n-            }\n+            },\n             _ => (),\n         }\n     }\n@@ -152,8 +221,8 @@ impl LintPass for LetPass {\n     }\n }\n \n-impl LateLintPass for LetPass {\n-    fn check_decl(&mut self, cx: &LateContext, decl: &Decl) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetPass {\n+    fn check_decl(&mut self, cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl) {\n         check_let_unit(cx, decl)\n     }\n }\n@@ -189,8 +258,8 @@ impl LintPass for UnitCmp {\n     }\n }\n \n-impl LateLintPass for UnitCmp {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if in_macro(cx, expr.span) {\n             return;\n         }\n@@ -210,8 +279,8 @@ impl LateLintPass for UnitCmp {\n                                   &format!(\"{}-comparison of unit values detected. This will always be {}\",\n                                            op.as_str(),\n                                            result));\n-                    }\n-                    _ => ()\n+                    },\n+                    _ => (),\n                 }\n             }\n         }\n@@ -335,11 +404,7 @@ fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n }\n \n fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS, cast_to_f64: bool) {\n-    let mantissa_nbits = if cast_to_f64 {\n-        52\n-    } else {\n-        23\n-    };\n+    let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n     let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n     let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n     let from_nbits_str = if arch_dependent {\n@@ -355,11 +420,7 @@ fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS,\n               &format!(\"casting {0} to {1} causes a loss of precision {2}({0} is {3} bits wide, but {1}'s mantissa \\\n                         is only {4} bits wide)\",\n                        cast_from,\n-                       if cast_to_f64 {\n-                           \"f64\"\n-                       } else {\n-                           \"f32\"\n-                       },\n+                       if cast_to_f64 { \"f64\" } else { \"f32\" },\n                        if arch_dependent {\n                            arch_dependent_str\n                        } else {\n@@ -387,27 +448,27 @@ fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: &ty::\n              ArchSuffix::None,\n              to_nbits == from_nbits && cast_unsigned_to_signed,\n              ArchSuffix::None)\n-        }\n+        },\n         (true, false) => {\n             (to_nbits <= 32,\n              if to_nbits == 32 {\n-                ArchSuffix::_64\n-            } else {\n-                ArchSuffix::None\n-            },\n+                 ArchSuffix::_64\n+             } else {\n+                 ArchSuffix::None\n+             },\n              to_nbits <= 32 && cast_unsigned_to_signed,\n              ArchSuffix::_32)\n-        }\n+        },\n         (false, true) => {\n             (from_nbits == 64,\n              ArchSuffix::_32,\n              cast_unsigned_to_signed,\n              if from_nbits == 64 {\n-                ArchSuffix::_64\n-            } else {\n-                ArchSuffix::_32\n-            })\n-        }\n+                 ArchSuffix::_64\n+             } else {\n+                 ArchSuffix::_32\n+             })\n+        },\n     };\n     if span_truncation {\n         span_lint(cx,\n@@ -446,8 +507,8 @@ impl LintPass for CastPass {\n     }\n }\n \n-impl LateLintPass for CastPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprCast(ref ex, _) = expr.node {\n             let (cast_from, cast_to) = (cx.tcx.tables().expr_ty(ex), cx.tcx.tables().expr_ty(expr));\n             if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx, expr.span) {\n@@ -462,7 +523,7 @@ impl LateLintPass for CastPass {\n                         if is_isize_or_usize(cast_from) || from_nbits >= to_nbits {\n                             span_precision_loss_lint(cx, expr, cast_from, to_nbits == 64);\n                         }\n-                    }\n+                    },\n                     (false, true) => {\n                         span_lint(cx,\n                                   CAST_POSSIBLE_TRUNCATION,\n@@ -474,7 +535,7 @@ impl LateLintPass for CastPass {\n                                       expr.span,\n                                       &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n                         }\n-                    }\n+                    },\n                     (true, true) => {\n                         if cast_from.is_signed() && !cast_to.is_signed() {\n                             span_lint(cx,\n@@ -483,16 +544,16 @@ impl LateLintPass for CastPass {\n                                       &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n                         }\n                         check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n-                    }\n+                    },\n                     (false, false) => {\n-                        if let (&ty::TyFloat(FloatTy::F64), &ty::TyFloat(FloatTy::F32)) = (&cast_from.sty,\n-                                                                                           &cast_to.sty) {\n+                        if let (&ty::TyFloat(FloatTy::F64), &ty::TyFloat(FloatTy::F32)) =\n+                            (&cast_from.sty, &cast_to.sty) {\n                             span_lint(cx,\n                                       CAST_POSSIBLE_TRUNCATION,\n                                       expr.span,\n                                       \"casting f64 to f32 may truncate the value\");\n                         }\n-                    }\n+                    },\n                 }\n             }\n         }\n@@ -534,17 +595,25 @@ impl LintPass for TypeComplexityPass {\n     }\n }\n \n-impl LateLintPass for TypeComplexityPass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Expr, _: Span, _: NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        _: &'tcx Expr,\n+        _: Span,\n+        _: NodeId\n+    ) {\n         self.check_fndecl(cx, decl);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, field: &StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx StructField) {\n         // enum variants are also struct fields now\n         self.check_type(cx, &field.ty);\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         match item.node {\n             ItemStatic(ref ty, _, _) |\n             ItemConst(ref ty, _) => self.check_type(cx, ty),\n@@ -553,7 +622,7 @@ impl LateLintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         match item.node {\n             ConstTraitItem(ref ty, _) |\n             TypeTraitItem(_, Some(ref ty)) => self.check_type(cx, ty),\n@@ -563,7 +632,7 @@ impl LateLintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         match item.node {\n             ImplItemKind::Const(ref ty, _) |\n             ImplItemKind::Type(ref ty) => self.check_type(cx, ty),\n@@ -572,15 +641,15 @@ impl LateLintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext, local: &Local) {\n+    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local) {\n         if let Some(ref ty) = local.ty {\n             self.check_type(cx, ty);\n         }\n     }\n }\n \n-impl TypeComplexityPass {\n-    fn check_fndecl(&self, cx: &LateContext, decl: &FnDecl) {\n+impl<'a, 'tcx> TypeComplexityPass {\n+    fn check_fndecl(&self, cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl) {\n         for arg in &decl.inputs {\n             self.check_type(cx, &arg.ty);\n         }\n@@ -589,14 +658,15 @@ impl TypeComplexityPass {\n         }\n     }\n \n-    fn check_type(&self, cx: &LateContext, ty: &Ty) {\n+    fn check_type(&self, cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty) {\n         if in_macro(cx, ty.span) {\n             return;\n         }\n         let score = {\n             let mut visitor = TypeComplexityVisitor {\n                 score: 0,\n                 nest: 1,\n+                cx: cx,\n             };\n             visitor.visit_ty(ty);\n             visitor.score\n@@ -612,24 +682,22 @@ impl TypeComplexityPass {\n }\n \n /// Walks a type and assigns a complexity score to it.\n-struct TypeComplexityVisitor {\n+struct TypeComplexityVisitor<'a, 'tcx: 'a> {\n     /// total complexity score of the type\n     score: u64,\n     /// current nesting level\n     nest: u64,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'v> Visitor<'v> for TypeComplexityVisitor {\n-    fn visit_ty(&mut self, ty: &'v Ty) {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for TypeComplexityVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &'tcx Ty) {\n         let (add_score, sub_nest) = match ty.node {\n             // _, &x and *x have only small overhead; don't mess with nesting level\n             TyInfer | TyPtr(..) | TyRptr(..) => (1, 0),\n \n             // the \"normal\" components of a type: named types, arrays/tuples\n-            TyPath(..) |\n-            TySlice(..) |\n-            TyTup(..) |\n-            TyArray(..) => (10 * self.nest, 1),\n+            TyPath(..) | TySlice(..) | TyTup(..) | TyArray(..) => (10 * self.nest, 1),\n \n             // \"Sum\" of trait bounds\n             TyObjectSum(..) => (20 * self.nest, 0),\n@@ -645,6 +713,9 @@ impl<'v> Visitor<'v> for TypeComplexityVisitor {\n         walk_ty(self, ty);\n         self.nest -= sub_nest;\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n /// **What it does:** Checks for expressions where a character literal is cast\n@@ -676,8 +747,8 @@ impl LintPass for CharLitAsU8 {\n     }\n }\n \n-impl LateLintPass for CharLitAsU8 {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         use syntax::ast::{LitKind, UintTy};\n \n         if let ExprCast(ref e, _) = expr.node {\n@@ -687,9 +758,7 @@ impl LateLintPass for CharLitAsU8 {\n                         let msg = \"casting character literal to u8. `char`s \\\n                                    are 4 bytes wide in rust, so casting to u8 \\\n                                    truncates them\";\n-                        let help = format!(\"Consider using a byte literal \\\n-                                            instead:\\nb{}\",\n-                                           snippet(cx, e.span, \"'x'\"));\n+                        let help = format!(\"Consider using a byte literal instead:\\nb{}\", snippet(cx, e.span, \"'x'\"));\n                         span_help_and_lint(cx, CHAR_LIT_AS_U8, expr.span, msg, &help);\n                     }\n                 }\n@@ -746,12 +815,15 @@ enum AbsurdComparisonResult {\n \n \n \n-fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n-                                -> Option<(ExtremeExpr<'a>, AbsurdComparisonResult)> {\n+fn detect_absurd_comparison<'a>(\n+    cx: &LateContext,\n+    op: BinOp_,\n+    lhs: &'a Expr,\n+    rhs: &'a Expr\n+) -> Option<(ExtremeExpr<'a>, AbsurdComparisonResult)> {\n     use types::ExtremeType::*;\n     use types::AbsurdComparisonResult::*;\n     use utils::comparisons::*;\n-    type Extr<'a> = ExtremeExpr<'a>;\n \n     let normalized = normalize_comparison(op, lhs, rhs);\n     let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n@@ -766,20 +838,20 @@ fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs\n     Some(match rel {\n         Rel::Lt => {\n             match (lx, rx) {\n-                (Some(l @ Extr { which: Maximum, .. }), _) => (l, AlwaysFalse), // max < x\n-                (_, Some(r @ Extr { which: Minimum, .. })) => (r, AlwaysFalse), // x < min\n+                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, AlwaysFalse), // max < x\n+                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, AlwaysFalse), // x < min\n                 _ => return None,\n             }\n-        }\n+        },\n         Rel::Le => {\n             match (lx, rx) {\n-                (Some(l @ Extr { which: Minimum, .. }), _) => (l, AlwaysTrue), // min <= x\n-                (Some(l @ Extr { which: Maximum, .. }), _) => (l, InequalityImpossible), //max <= x\n-                (_, Some(r @ Extr { which: Minimum, .. })) => (r, InequalityImpossible), // x <= min\n-                (_, Some(r @ Extr { which: Maximum, .. })) => (r, AlwaysTrue), // x <= max\n+                (Some(l @ ExtremeExpr { which: Minimum, .. }), _) => (l, AlwaysTrue), // min <= x\n+                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, InequalityImpossible), //max <= x\n+                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, InequalityImpossible), // x <= min\n+                (_, Some(r @ ExtremeExpr { which: Maximum, .. })) => (r, AlwaysTrue), // x <= max\n                 _ => return None,\n             }\n-        }\n+        },\n         Rel::Ne | Rel::Eq => return None,\n     })\n }\n@@ -840,8 +912,8 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n     })\n }\n \n-impl LateLintPass for AbsurdExtremeComparisons {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         use types::ExtremeType::*;\n         use types::AbsurdComparisonResult::*;\n \n@@ -859,7 +931,7 @@ impl LateLintPass for AbsurdExtremeComparisons {\n                                      instead\",\n                                     snippet(cx, lhs.span, \"lhs\"),\n                                     snippet(cx, rhs.span, \"rhs\"))\n-                        }\n+                        },\n                     };\n \n                     let help = format!(\"because {} is the {} value for this type, {}\",\n@@ -962,7 +1034,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n                     IntTy::I64 => (FullInt::S(i64::min_value() as i64), FullInt::S(i64::max_value() as i64)),\n                     IntTy::Is => (FullInt::S(isize::min_value() as i64), FullInt::S(isize::max_value() as i64)),\n                 })\n-            }\n+            },\n             TyUint(uint_ty) => {\n                 Some(match uint_ty {\n                     UintTy::U8 => (FullInt::U(u8::min_value() as u64), FullInt::U(u8::max_value() as u64)),\n@@ -971,7 +1043,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n                     UintTy::U64 => (FullInt::U(u64::min_value() as u64), FullInt::U(u64::max_value() as u64)),\n                     UintTy::Us => (FullInt::U(usize::min_value() as u64), FullInt::U(usize::max_value() as u64)),\n                 })\n-            }\n+            },\n             _ => None,\n         }\n     } else {\n@@ -996,7 +1068,7 @@ fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n             } else {\n                 None\n             }\n-        }\n+        },\n         Err(_) => None,\n     }\n }\n@@ -1014,8 +1086,15 @@ fn err_upcast_comparison(cx: &LateContext, span: &Span, expr: &Expr, always: boo\n     }\n }\n \n-fn upcast_comparison_bounds_err(cx: &LateContext, span: &Span, rel: comparisons::Rel,\n-                                lhs_bounds: Option<(FullInt, FullInt)>, lhs: &Expr, rhs: &Expr, invert: bool) {\n+fn upcast_comparison_bounds_err(\n+    cx: &LateContext,\n+    span: &Span,\n+    rel: comparisons::Rel,\n+    lhs_bounds: Option<(FullInt, FullInt)>,\n+    lhs: &Expr,\n+    rhs: &Expr,\n+    invert: bool\n+) {\n     use utils::comparisons::*;\n \n     if let Some((lb, ub)) = lhs_bounds {\n@@ -1031,14 +1110,14 @@ fn upcast_comparison_bounds_err(cx: &LateContext, span: &Span, rel: comparisons:\n                     } else {\n                         ub < norm_rhs_val\n                     }\n-                }\n+                },\n                 Rel::Le => {\n                     if invert {\n                         norm_rhs_val <= lb\n                     } else {\n                         ub <= norm_rhs_val\n                     }\n-                }\n+                },\n                 Rel::Eq | Rel::Ne => unreachable!(),\n             } {\n                 err_upcast_comparison(cx, span, lhs, true)\n@@ -1049,14 +1128,14 @@ fn upcast_comparison_bounds_err(cx: &LateContext, span: &Span, rel: comparisons:\n                     } else {\n                         lb >= norm_rhs_val\n                     }\n-                }\n+                },\n                 Rel::Le => {\n                     if invert {\n                         norm_rhs_val > ub\n                     } else {\n                         lb > norm_rhs_val\n                     }\n-                }\n+                },\n                 Rel::Eq | Rel::Ne => unreachable!(),\n             } {\n                 err_upcast_comparison(cx, span, lhs, false)\n@@ -1065,8 +1144,8 @@ fn upcast_comparison_bounds_err(cx: &LateContext, span: &Span, rel: comparisons:\n     }\n }\n \n-impl LateLintPass for InvalidUpcastComparisons {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n \n             let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);"}, {"sha": "1d5ab7db3461c2749f857305df20031303125150", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -68,8 +68,8 @@ impl LintPass for Unicode {\n     }\n }\n \n-impl LateLintPass for Unicode {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Unicode {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprLit(ref lit) = expr.node {\n             if let LitKind::Str(_, _) = lit.node {\n                 check_str(cx, lit.span)"}, {"sha": "07afc55ae7f171f091bcd9d2be7178fcf0f33e74", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,6 +1,5 @@\n-use rustc::hir::*;\n use rustc::lint::*;\n-use syntax::ast::Name;\n+use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::symbol::InternedString;\n use utils::span_lint;\n@@ -34,46 +33,41 @@ impl LintPass for UnsafeNameRemoval {\n     }\n }\n \n-impl LateLintPass for UnsafeNameRemoval {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        if let ItemUse(ref item_use) = item.node {\n+impl EarlyLintPass for UnsafeNameRemoval {\n+    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+        if let ItemKind::Use(ref item_use) = item.node {\n             match item_use.node {\n                 ViewPath_::ViewPathSimple(ref name, ref path) => {\n-                    unsafe_to_safe_check(\n-                        path.segments\n-                            .last()\n-                            .expect(\"use paths cannot be empty\")\n-                            .name,\n-                        *name,\n-                        cx, &item.span\n-                        );\n-                }\n+                    unsafe_to_safe_check(path.segments\n+                                             .last()\n+                                             .expect(\"use paths cannot be empty\")\n+                                             .identifier,\n+                                         *name,\n+                                         cx,\n+                                         &item.span);\n+                },\n                 ViewPath_::ViewPathList(_, ref path_list_items) => {\n                     for path_list_item in path_list_items.iter() {\n                         let plid = path_list_item.node;\n                         if let Some(rename) = plid.rename {\n                             unsafe_to_safe_check(plid.name, rename, cx, &item.span);\n                         };\n                     }\n-                }\n-                ViewPath_::ViewPathGlob(_) => {}\n+                },\n+                ViewPath_::ViewPathGlob(_) => {},\n             }\n         }\n     }\n }\n \n-fn unsafe_to_safe_check(old_name: Name, new_name: Name, cx: &LateContext, span: &Span) {\n-    let old_str = old_name.as_str();\n-    let new_str = new_name.as_str();\n+fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext, span: &Span) {\n+    let old_str = old_name.name.as_str();\n+    let new_str = new_name.name.as_str();\n     if contains_unsafe(&old_str) && !contains_unsafe(&new_str) {\n         span_lint(cx,\n                   UNSAFE_REMOVED_FROM_NAME,\n                   *span,\n-                  &format!(\n-                \"removed \\\"unsafe\\\" from the name of `{}` in use as `{}`\",\n-                old_str,\n-                new_str\n-            ));\n+                  &format!(\"removed \\\"unsafe\\\" from the name of `{}` in use as `{}`\", old_str, new_str));\n     }\n }\n "}, {"sha": "9017fd6933e81b04f6e66bad4b7aa04217947ceb", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir;\n-use rustc::hir::intravisit::{FnKind, Visitor, walk_expr, walk_fn};\n+use rustc::hir::intravisit::{FnKind, Visitor, walk_expr, walk_fn, NestedVisitorMap};\n use std::collections::HashMap;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -29,15 +29,9 @@ declare_lint! {\n \n pub struct UnusedLabel;\n \n-#[derive(Default)]\n-struct UnusedLabelVisitor {\n+struct UnusedLabelVisitor<'a, 'tcx: 'a> {\n     labels: HashMap<InternedString, Span>,\n-}\n-\n-impl UnusedLabelVisitor {\n-    pub fn new() -> UnusedLabelVisitor {\n-        ::std::default::Default::default()\n-    }\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n impl LintPass for UnusedLabel {\n@@ -46,35 +40,49 @@ impl LintPass for UnusedLabel {\n     }\n }\n \n-impl LateLintPass for UnusedLabel {\n-    fn check_fn(&mut self, cx: &LateContext, kind: FnKind, decl: &hir::FnDecl, body: &hir::Expr, span: Span, fn_id: ast::NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl,\n+        body: &'tcx hir::Expr,\n+        span: Span,\n+        fn_id: ast::NodeId\n+    ) {\n         if in_macro(cx, span) {\n             return;\n         }\n \n-        let mut v = UnusedLabelVisitor::new();\n-        walk_fn(&mut v, kind, decl, body, span, fn_id);\n+        let mut v = UnusedLabelVisitor {\n+            cx: cx,\n+            labels: HashMap::new(),\n+        };\n+        walk_fn(&mut v, kind, decl, body.expr_id(), span, fn_id);\n \n         for (label, span) in v.labels {\n             span_lint(cx, UNUSED_LABEL, span, &format!(\"unused label `{}`\", label));\n         }\n     }\n }\n \n-impl<'v> Visitor<'v> for UnusedLabelVisitor {\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprBreak(Some(label), _) |\n             hir::ExprAgain(Some(label)) => {\n-                self.labels.remove(&label.node.as_str());\n-            }\n+                self.labels.remove(&label.name.as_str());\n+            },\n             hir::ExprLoop(_, Some(label), _) |\n             hir::ExprWhile(_, _, Some(label)) => {\n                 self.labels.insert(label.node.as_str(), expr.span);\n-            }\n+            },\n             _ => (),\n         }\n \n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "f973c2afd27a21ad812eb1192f64e80aa046ac22", "filename": "clippy_lints/src/utils/comparisons.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -18,8 +18,7 @@ pub enum Rel {\n }\n \n /// Put the expression in the form  `lhs < rhs`, `lhs <= rhs`, `lhs == rhs` or `lhs != rhs`.\n-pub fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n-                                -> Option<(Rel, &'a Expr, &'a Expr)> {\n+pub fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(Rel, &'a Expr, &'a Expr)> {\n     match op {\n         BinOp_::BiLt => Some((Rel::Lt, lhs, rhs)),\n         BinOp_::BiLe => Some((Rel::Le, lhs, rhs)),"}, {"sha": "d80fa17e29f736cd0e63b47724eefb4c7885a9d8", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -8,21 +8,20 @@ use syntax::{ast, codemap};\n use toml;\n \n /// Get the configuration file from arguments.\n-pub fn file_from_args(args: &[codemap::Spanned<ast::NestedMetaItemKind>]) -> Result<Option<path::PathBuf>, (&'static str, codemap::Span)> {\n+pub fn file_from_args(args: &[codemap::Spanned<ast::NestedMetaItemKind>])\n+    -> Result<Option<path::PathBuf>, (&'static str, codemap::Span)> {\n     for arg in args.iter().filter_map(|a| a.meta_item()) {\n         if arg.name() == \"conf_file\" {\n             return match arg.node {\n                 ast::MetaItemKind::Word |\n-                ast::MetaItemKind::List(_) => {\n-                    Err((\"`conf_file` must be a named value\", arg.span))\n-                }\n+                ast::MetaItemKind::List(_) => Err((\"`conf_file` must be a named value\", arg.span)),\n                 ast::MetaItemKind::NameValue(ref value) => {\n                     if let ast::LitKind::Str(ref file, _) = value.node {\n                         Ok(Some(file.to_string().into()))\n                     } else {\n                         Err((\"`conf_file` value must be a string\", value.span))\n                     }\n-                }\n+                },\n             };\n         }\n     }\n@@ -38,14 +37,12 @@ pub enum Error {\n     /// The file is not valid TOML.\n     Toml(Vec<toml::ParserError>),\n     /// Type error.\n-    Type(\n-        /// The name of the key.\n-        &'static str,\n-        /// The expected type.\n-        &'static str,\n-        /// The type we got instead.\n-        &'static str\n-    ),\n+    Type(/// The name of the key.\n+         &'static str,\n+         /// The expected type.\n+         &'static str,\n+         /// The type we got instead.\n+         &'static str),\n     /// There is an unknown key is the file.\n     UnknownKey(String),\n }\n@@ -66,10 +63,10 @@ impl fmt::Display for Error {\n                 }\n \n                 Ok(())\n-            }\n+            },\n             Error::Type(key, expected, got) => {\n                 write!(f, \"`{}` is expected to be a `{}` but is a `{}`\", key, expected, got)\n-            }\n+            },\n             Error::UnknownKey(ref key) => write!(f, \"unknown key `{}`\", key),\n         }\n     }\n@@ -134,20 +131,23 @@ macro_rules! define_Conf {\n \n     // how to read the value?\n     (CONV i64, $value: expr) => { $value.as_integer() };\n-    (CONV u64, $value: expr) => { $value.as_integer().iter().filter_map(|&i| if i >= 0 { Some(i as u64) } else { None }).next() };\n+    (CONV u64, $value: expr) => {\n+        $value.as_integer()\n+        .iter()\n+        .filter_map(|&i| if i >= 0 { Some(i as u64) } else { None })\n+        .next()\n+    };\n     (CONV String, $value: expr) => { $value.as_str().map(Into::into) };\n     (CONV Vec<String>, $value: expr) => {{\n         let slice = $value.as_slice();\n \n         if let Some(slice) = slice {\n             if slice.iter().any(|v| v.as_str().is_none()) {\n                 None\n+            } else {\n+                Some(slice.iter().map(|v| v.as_str().expect(\"already checked\").to_owned()).collect())\n             }\n-            else {\n-                Some(slice.iter().map(|v| v.as_str().unwrap_or_else(|| unreachable!()).to_owned()).collect())\n-            }\n-        }\n-        else {\n+        } else {\n             None\n         }\n     }};\n@@ -163,7 +163,19 @@ define_Conf! {\n     /// Lint: CYCLOMATIC_COMPLEXITY. The maximum cyclomatic complexity a function can have\n     (\"cyclomatic-complexity-threshold\", cyclomatic_complexity_threshold, 25 => u64),\n     /// Lint: DOC_MARKDOWN. The list of words this lint should not consider as identifiers needing ticks\n-    (\"doc-valid-idents\", doc_valid_idents, [\"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"DirectX\", \"GPLv2\", \"GPLv3\", \"GitHub\", \"IPv4\", \"IPv6\", \"JavaScript\", \"NaN\", \"OAuth\", \"OpenGL\", \"TrueType\", \"iOS\", \"macOS\"] => Vec<String>),\n+    (\"doc-valid-idents\", doc_valid_idents, [\n+        \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\",\n+        \"DirectX\",\n+        \"GPLv2\", \"GPLv3\",\n+        \"GitHub\",\n+        \"IPv4\", \"IPv6\",\n+        \"JavaScript\",\n+        \"NaN\",\n+        \"OAuth\",\n+        \"OpenGL\",\n+        \"TrueType\",\n+        \"iOS\", \"macOS\",\n+    ] => Vec<String>),\n     /// Lint: TOO_MANY_ARGUMENTS. The maximum number of argument a function or method can have\n     (\"too-many-arguments-threshold\", too_many_arguments_threshold, 7 => u64),\n     /// Lint: TYPE_COMPLEXITY. The maximum complexity a type can have\n@@ -196,7 +208,7 @@ pub fn lookup_conf_file() -> io::Result<Option<path::PathBuf>> {\n                     if e.kind() != io::ErrorKind::NotFound {\n                         return Err(e);\n                     }\n-                }\n+                },\n                 _ => (),\n             }\n         }\n@@ -231,11 +243,11 @@ pub fn read(path: Option<&path::Path>) -> (Conf, Vec<Error>) {\n             }\n \n             buf\n-        }\n+        },\n         Err(err) => {\n             errors.push(err.into());\n             return (conf, errors);\n-        }\n+        },\n     };\n \n     let mut parser = toml::Parser::new(&file);"}, {"sha": "87008307c5f66baf8737a75ea5ec68b0994e6b98", "filename": "clippy_lints/src/utils/constants.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fconstants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fconstants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconstants.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -7,15 +7,5 @@\n /// See also [the reference][reference-types] for a list of such types.\n ///\n /// [reference-types]: https://doc.rust-lang.org/reference.html#types\n-pub const BUILTIN_TYPES: &'static [&'static str] = &[\n-    \"i8\", \"u8\",\n-    \"i16\", \"u16\",\n-    \"i32\", \"u32\",\n-    \"i64\", \"u64\",\n-    \"isize\", \"usize\",\n-    \"f32\",\n-    \"f64\",\n-    \"bool\",\n-    \"str\",\n-    \"char\",\n-];\n+pub const BUILTIN_TYPES: &'static [&'static str] = &[\"i8\", \"u8\", \"i16\", \"u16\", \"i32\", \"u32\", \"i64\", \"u64\", \"isize\",\n+                                                     \"usize\", \"f32\", \"f64\", \"bool\", \"str\", \"char\"];"}, {"sha": "c83dae26fdaa7dbf01288381baf5a6610d23ca65", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -44,34 +44,21 @@ pub struct Range<'a> {\n \n /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n pub fn range(expr: &hir::Expr) -> Option<Range> {\n-    /// Skip unstable blocks. To be removed when ranges get stable.\n-    fn unwrap_unstable(expr: &hir::Expr) -> &hir::Expr {\n-        if let hir::ExprBlock(ref block) = expr.node {\n-            if block.rules == hir::BlockCheckMode::PushUnstableBlock || block.rules == hir::BlockCheckMode::PopUnstableBlock {\n-                if let Some(ref expr) = block.expr {\n-                    return expr;\n-                }\n-            }\n-        }\n-\n-        expr\n-    }\n-\n     /// Find the field named `name` in the field. Always return `Some` for convenience.\n     fn get_field<'a>(name: &str, fields: &'a [hir::Field]) -> Option<&'a hir::Expr> {\n         let expr = &fields.iter()\n-                          .find(|field| field.name.node == name)\n-                          .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n-                          .expr;\n+            .find(|field| field.name.node == name)\n+            .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n+            .expr;\n \n-        Some(unwrap_unstable(expr))\n+        Some(expr)\n     }\n \n     // The range syntax is expanded to literal paths starting with `core` or `std` depending on\n     // `#[no_std]`. Testing both instead of resolving the paths.\n \n-    match unwrap_unstable(expr).node {\n-        hir::ExprPath(None, ref path) => {\n+    match expr.node {\n+        hir::ExprPath(ref path) => {\n             if match_path(path, &paths::RANGE_FULL_STD) || match_path(path, &paths::RANGE_FULL) {\n                 Some(Range {\n                     start: None,\n@@ -81,7 +68,7 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n             } else {\n                 None\n             }\n-        }\n+        },\n         hir::ExprStruct(ref path, ref fields, None) => {\n             if match_path(path, &paths::RANGE_FROM_STD) || match_path(path, &paths::RANGE_FROM) {\n                 Some(Range {\n@@ -90,7 +77,7 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n                     limits: ast::RangeLimits::HalfOpen,\n                 })\n             } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY_STD) ||\n-               match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n+                      match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n                 Some(Range {\n                     start: get_field(\"start\", fields),\n                     end: get_field(\"end\", fields),\n@@ -117,7 +104,7 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n             } else {\n                 None\n             }\n-        }\n+        },\n         _ => None,\n     }\n }\n@@ -168,15 +155,15 @@ pub enum VecArgs<'a> {\n pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n     if_let_chain!{[\n         let hir::ExprCall(ref fun, ref args) = expr.node,\n-        let hir::ExprPath(_, ref path) = fun.node,\n-        let Some(fun_def) = resolve_node(cx, fun.id),\n+        let hir::ExprPath(ref path) = fun.node,\n         is_expn_of(cx, fun.span, \"vec\").is_some(),\n     ], {\n+        let fun_def = resolve_node(cx, path, fun.id);\n         return if match_def_path(cx, fun_def.def_id(), &paths::VEC_FROM_ELEM) && args.len() == 2 {\n             // `vec![elem; size]` case\n             Some(VecArgs::Repeat(&args[0], &args[1]))\n         }\n-        else if match_path(path, &[\"into_vec\"]) && args.len() == 1 {\n+        else if match_def_path(cx, fun_def.def_id(), &paths::SLICE_INTO_VEC) && args.len() == 1 {\n             // `vec![a, b, c]` case\n             if_let_chain!{[\n                 let hir::ExprBox(ref boxed) = args[0].node,"}, {"sha": "80399825b6d1b309ef2c48d8d3c1311d1919d7e6", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 103, "deletions": 106, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -38,12 +38,11 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         match (&left.node, &right.node) {\n             (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n                 if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n-                    both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r)) &&\n-                    both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n+                    both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r)) && both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n                 } else {\n                     false\n                 }\n-            }\n+            },\n             (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) |\n             (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => self.eq_expr(l, r),\n             _ => false,\n@@ -69,69 +68,64 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n         match (&left.node, &right.node) {\n             (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n-            (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.node.as_str() == r.node.as_str()),\n+            (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.name.as_str() == r.name.as_str()),\n             (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n             (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n-            }\n+            },\n             (&ExprBlock(ref l), &ExprBlock(ref r)) => self.eq_block(l, r),\n             (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n                 l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr) ||\n                 swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n                     l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                 })\n-            }\n-            (&ExprBreak(li, ref le), &ExprBreak(ri, ref re)) =>\n-                both(&li, &ri, |l, r| l.node.as_str() == r.node.as_str())\n-                && both(le, re, |l, r| self.eq_expr(l, r)),\n+            },\n+            (&ExprBreak(li, ref le), &ExprBreak(ri, ref re)) => {\n+                both(&li, &ri, |l, r| l.name.as_str() == r.name.as_str()) && both(le, re, |l, r| self.eq_expr(l, r))\n+            },\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n             (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n                 !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n-            }\n+            },\n             (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) |\n-            (&ExprType(ref lx, ref lt), &ExprType(ref rx, ref rt)) => {\n-                self.eq_expr(lx, rx) && self.eq_ty(lt, rt)\n-            }\n+            (&ExprType(ref lx, ref lt), &ExprType(ref rx, ref rt)) => self.eq_expr(lx, rx) && self.eq_ty(lt, rt),\n             (&ExprField(ref l_f_exp, ref l_f_ident), &ExprField(ref r_f_exp, ref r_f_ident)) => {\n                 l_f_ident.node == r_f_ident.node && self.eq_expr(l_f_exp, r_f_exp)\n-            }\n+            },\n             (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n             (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_block(lt, rt) && both(le, re, |l, r| self.eq_expr(l, r))\n-            }\n+            },\n             (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n             (&ExprLoop(ref lb, ref ll, ref lls), &ExprLoop(ref rb, ref rl, ref rls)) => {\n-                self.eq_block(lb, rb) && both(ll, rl, |l, r| l.node.as_str() == r.node.as_str()) && lls == rls\n-            }\n+                lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.node.as_str() == r.node.as_str())\n+            },\n             (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n                 ls == rs && self.eq_expr(le, re) &&\n                 over(la, ra, |l, r| {\n                     self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n                     over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n                 })\n-            }\n+            },\n             (&ExprMethodCall(ref l_name, ref l_tys, ref l_args),\n              &ExprMethodCall(ref r_name, ref r_tys, ref r_args)) => {\n-                !self.ignore_fn && l_name.node == r_name.node &&\n-                over(l_tys, r_tys, |l, r| self.eq_ty(l, r)) &&\n+                !self.ignore_fn && l_name.node == r_name.node && over(l_tys, r_tys, |l, r| self.eq_ty(l, r)) &&\n                 self.eq_exprs(l_args, r_args)\n-            }\n+            },\n             (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n-            (&ExprPath(ref l_qself, ref l_subpath), &ExprPath(ref r_qself, ref r_subpath)) => {\n-                both(l_qself, r_qself, |l, r| self.eq_qself(l, r)) && self.eq_path(l_subpath, r_subpath)\n-            }\n+            (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n             (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n-                self.eq_path(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n+                self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n                 over(lf, rf, |l, r| self.eq_field(l, r))\n-            }\n+            },\n             (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n             (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => li.node == ri.node && self.eq_expr(le, re),\n             (&ExprUnary(l_op, ref le), &ExprUnary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n             (&ExprArray(ref l), &ExprArray(ref r)) => self.eq_exprs(l, r),\n             (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n                 self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.node.as_str() == r.node.as_str())\n-            }\n+            },\n             _ => false,\n         }\n     }\n@@ -153,34 +147,43 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         match (&left.node, &right.node) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n-                self.eq_path(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n-            }\n-            (&PatKind::Binding(ref lb, ref li, ref lp), &PatKind::Binding(ref rb, ref ri, ref rp)) => {\n+                self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n+            },\n+            (&PatKind::Binding(ref lb, _, ref li, ref lp), &PatKind::Binding(ref rb, _, ref ri, ref rp)) => {\n                 lb == rb && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n-            }\n-            (&PatKind::Path(ref ql, ref l), &PatKind::Path(ref qr, ref r)) => {\n-                both(ql, qr, |ql, qr| self.eq_qself(ql, qr)) && self.eq_path(l, r)\n-            }\n+            },\n+            (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n             (&PatKind::Tuple(ref l, ls), &PatKind::Tuple(ref r, rs)) => {\n                 ls == rs && over(l, r, |l, r| self.eq_pat(l, r))\n-            }\n+            },\n             (&PatKind::Range(ref ls, ref le), &PatKind::Range(ref rs, ref re)) => {\n                 self.eq_expr(ls, rs) && self.eq_expr(le, re)\n-            }\n+            },\n             (&PatKind::Ref(ref le, ref lm), &PatKind::Ref(ref re, ref rm)) => lm == rm && self.eq_pat(le, re),\n             (&PatKind::Slice(ref ls, ref li, ref le), &PatKind::Slice(ref rs, ref ri, ref re)) => {\n                 over(ls, rs, |l, r| self.eq_pat(l, r)) && over(le, re, |l, r| self.eq_pat(l, r)) &&\n                 both(li, ri, |l, r| self.eq_pat(l, r))\n-            }\n+            },\n             (&PatKind::Wild, &PatKind::Wild) => true,\n             _ => false,\n         }\n     }\n \n+    fn eq_qpath(&self, left: &QPath, right: &QPath) -> bool {\n+        match (left, right) {\n+            (&QPath::Resolved(ref lty, ref lpath), &QPath::Resolved(ref rty, ref rpath)) => {\n+                both(lty, rty, |l, r| self.eq_ty(l, r)) && self.eq_path(lpath, rpath)\n+            },\n+            (&QPath::TypeRelative(ref lty, ref lseg), &QPath::TypeRelative(ref rty, ref rseg)) => {\n+                self.eq_ty(lty, rty) && self.eq_path_segment(lseg, rseg)\n+            },\n+            _ => false,\n+        }\n+    }\n+\n     fn eq_path(&self, left: &Path, right: &Path) -> bool {\n-        left.global == right.global &&\n-        over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n+        left.global == right.global && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n     }\n \n     fn eq_path_parameters(&self, left: &PathParameters, right: &PathParameters) -> bool {\n@@ -189,42 +192,31 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r)) &&\n                 over(&left.types, &right.types, |l, r| self.eq_ty(l, r)) &&\n                 over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n-            }\n+            },\n             (&ParenthesizedParameters(ref left), &ParenthesizedParameters(ref right)) => {\n                 over(&left.inputs, &right.inputs, |l, r| self.eq_ty(l, r)) &&\n                 both(&left.output, &right.output, |l, r| self.eq_ty(l, r))\n-            }\n+            },\n             (&AngleBracketedParameters(_), &ParenthesizedParameters(_)) |\n-            (&ParenthesizedParameters(_), &AngleBracketedParameters(_)) => {\n-                false\n-            }\n+            (&ParenthesizedParameters(_), &AngleBracketedParameters(_)) => false,\n         }\n     }\n \n     fn eq_path_segment(&self, left: &PathSegment, right: &PathSegment) -> bool {\n         // The == of idents doesn't work with different contexts,\n         // we have to be explicit about hygiene\n-        left.name.as_str() == right.name.as_str() &&\n-        self.eq_path_parameters(&left.parameters, &right.parameters)\n-    }\n-\n-    fn eq_qself(&self, left: &QSelf, right: &QSelf) -> bool {\n-        left.ty.node == right.ty.node && left.position == right.position\n+        left.name.as_str() == right.name.as_str() && self.eq_path_parameters(&left.parameters, &right.parameters)\n     }\n \n     fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n-            (&TyArray(ref lt, ref ll), &TyArray(ref rt, ref rl)) => {\n-                self.eq_ty(lt, rt) && self.eq_expr(ll, rl)\n-            }\n+            (&TyArray(ref lt, ref ll), &TyArray(ref rt, ref rl)) => self.eq_ty(lt, rt) && self.eq_expr(ll, rl),\n             (&TyPtr(ref l_mut), &TyPtr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n             (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n-            }\n-            (&TyPath(ref lq, ref l_path), &TyPath(ref rq, ref r_path)) => {\n-                both(lq, rq, |l, r| self.eq_qself(l, r)) && self.eq_path(l_path, r_path)\n-            }\n+            },\n+            (&TyPath(ref l), &TyPath(ref r)) => self.eq_qpath(l, r),\n             (&TyTup(ref l), &TyTup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n             (&TyInfer, &TyInfer) => true,\n             _ => false,\n@@ -238,13 +230,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n fn swap_binop<'a>(binop: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(BinOp_, &'a Expr, &'a Expr)> {\n     match binop {\n-        BiAdd |\n-        BiMul |\n-        BiBitXor |\n-        BiBitAnd |\n-        BiEq |\n-        BiNe |\n-        BiBitOr => Some((binop, rhs, lhs)),\n+        BiAdd | BiMul | BiBitXor | BiBitAnd | BiEq | BiNe | BiBitOr => Some((binop, rhs, lhs)),\n         BiLt => Some((BiGt, rhs, lhs)),\n         BiLe => Some((BiGe, rhs, lhs)),\n         BiGe => Some((BiLe, rhs, lhs)),\n@@ -313,88 +299,88 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 c.hash(&mut self.s);\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n-            }\n+            },\n             ExprAgain(i) => {\n                 let c: fn(_) -> _ = ExprAgain;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i {\n-                    self.hash_name(&i.node);\n+                    self.hash_name(&i.name);\n                 }\n-            }\n+            },\n             ExprAssign(ref l, ref r) => {\n                 let c: fn(_, _) -> _ = ExprAssign;\n                 c.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n-            }\n+            },\n             ExprAssignOp(ref o, ref l, ref r) => {\n                 let c: fn(_, _, _) -> _ = ExprAssignOp;\n                 c.hash(&mut self.s);\n                 o.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n-            }\n+            },\n             ExprBlock(ref b) => {\n                 let c: fn(_) -> _ = ExprBlock;\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n-            }\n+            },\n             ExprBinary(op, ref l, ref r) => {\n                 let c: fn(_, _, _) -> _ = ExprBinary;\n                 c.hash(&mut self.s);\n                 op.node.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n-            }\n+            },\n             ExprBreak(i, ref j) => {\n                 let c: fn(_, _) -> _ = ExprBreak;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i {\n-                    self.hash_name(&i.node);\n+                    self.hash_name(&i.name);\n                 }\n                 if let Some(ref j) = *j {\n                     self.hash_expr(&*j);\n                 }\n-            }\n+            },\n             ExprBox(ref e) => {\n                 let c: fn(_) -> _ = ExprBox;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n-            }\n+            },\n             ExprCall(ref fun, ref args) => {\n                 let c: fn(_, _) -> _ = ExprCall;\n                 c.hash(&mut self.s);\n                 self.hash_expr(fun);\n                 self.hash_exprs(args);\n-            }\n+            },\n             ExprCast(ref e, ref _ty) => {\n                 let c: fn(_, _) -> _ = ExprCast;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 // TODO: _ty\n-            }\n-            ExprClosure(cap, _, ref e, _) => {\n+            },\n+            ExprClosure(cap, _, eid, _) => {\n                 let c: fn(_, _, _, _) -> _ = ExprClosure;\n                 c.hash(&mut self.s);\n                 cap.hash(&mut self.s);\n-                self.hash_expr(e);\n-            }\n+                self.hash_expr(self.cx.tcx.map.expr(eid));\n+            },\n             ExprField(ref e, ref f) => {\n                 let c: fn(_, _) -> _ = ExprField;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 self.hash_name(&f.node);\n-            }\n+            },\n             ExprIndex(ref a, ref i) => {\n                 let c: fn(_, _) -> _ = ExprIndex;\n                 c.hash(&mut self.s);\n                 self.hash_expr(a);\n                 self.hash_expr(i);\n-            }\n+            },\n             ExprInlineAsm(..) => {\n                 let c: fn(_, _, _) -> _ = ExprInlineAsm;\n                 c.hash(&mut self.s);\n-            }\n+            },\n             ExprIf(ref cond, ref t, ref e) => {\n                 let c: fn(_, _, _) -> _ = ExprIf;\n                 c.hash(&mut self.s);\n@@ -403,21 +389,20 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }\n-            }\n+            },\n             ExprLit(ref l) => {\n                 let c: fn(_) -> _ = ExprLit;\n                 c.hash(&mut self.s);\n                 l.hash(&mut self.s);\n-            }\n-            ExprLoop(ref b, ref i, ref j) => {\n+            },\n+            ExprLoop(ref b, ref i, _) => {\n                 let c: fn(_, _, _) -> _ = ExprLoop;\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n                     self.hash_name(&i.node);\n                 }\n-                j.hash(&mut self.s);\n-            }\n+            },\n             ExprMatch(ref e, ref arms, ref s) => {\n                 let c: fn(_, _, _) -> _ = ExprMatch;\n                 c.hash(&mut self.s);\n@@ -432,36 +417,36 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 }\n \n                 s.hash(&mut self.s);\n-            }\n+            },\n             ExprMethodCall(ref name, ref _tys, ref args) => {\n                 let c: fn(_, _, _) -> _ = ExprMethodCall;\n                 c.hash(&mut self.s);\n                 self.hash_name(&name.node);\n                 self.hash_exprs(args);\n-            }\n+            },\n             ExprRepeat(ref e, ref l) => {\n                 let c: fn(_, _) -> _ = ExprRepeat;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 self.hash_expr(l);\n-            }\n+            },\n             ExprRet(ref e) => {\n                 let c: fn(_) -> _ = ExprRet;\n                 c.hash(&mut self.s);\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }\n-            }\n-            ExprPath(ref _qself, ref subpath) => {\n-                let c: fn(_, _) -> _ = ExprPath;\n+            },\n+            ExprPath(ref qpath) => {\n+                let c: fn(_) -> _ = ExprPath;\n                 c.hash(&mut self.s);\n-                self.hash_path(subpath);\n-            }\n+                self.hash_qpath(qpath);\n+            },\n             ExprStruct(ref path, ref fields, ref expr) => {\n                 let c: fn(_, _, _) -> _ = ExprStruct;\n                 c.hash(&mut self.s);\n \n-                self.hash_path(path);\n+                self.hash_qpath(path);\n \n                 for f in fields {\n                     self.hash_name(&f.name.node);\n@@ -471,38 +456,38 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 if let Some(ref e) = *expr {\n                     self.hash_expr(e);\n                 }\n-            }\n+            },\n             ExprTup(ref tup) => {\n                 let c: fn(_) -> _ = ExprTup;\n                 c.hash(&mut self.s);\n                 self.hash_exprs(tup);\n-            }\n+            },\n             ExprTupField(ref le, li) => {\n                 let c: fn(_, _) -> _ = ExprTupField;\n                 c.hash(&mut self.s);\n \n                 self.hash_expr(le);\n                 li.node.hash(&mut self.s);\n-            }\n+            },\n             ExprType(ref e, ref _ty) => {\n                 let c: fn(_, _) -> _ = ExprType;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 // TODO: _ty\n-            }\n+            },\n             ExprUnary(lop, ref le) => {\n                 let c: fn(_, _) -> _ = ExprUnary;\n                 c.hash(&mut self.s);\n \n                 lop.hash(&mut self.s);\n                 self.hash_expr(le);\n-            }\n+            },\n             ExprArray(ref v) => {\n                 let c: fn(_) -> _ = ExprArray;\n                 c.hash(&mut self.s);\n \n                 self.hash_exprs(v);\n-            }\n+            },\n             ExprWhile(ref cond, ref b, l) => {\n                 let c: fn(_, _, _) -> _ = ExprWhile;\n                 c.hash(&mut self.s);\n@@ -512,7 +497,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 if let Some(l) = l {\n                     self.hash_name(&l.node);\n                 }\n-            }\n+            },\n         }\n     }\n \n@@ -526,6 +511,18 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n         n.as_str().hash(&mut self.s);\n     }\n \n+    pub fn hash_qpath(&mut self, p: &QPath) {\n+        match *p {\n+            QPath::Resolved(_, ref path) => {\n+                self.hash_path(path);\n+            },\n+            QPath::TypeRelative(_, ref path) => {\n+                self.hash_name(&path.name);\n+            },\n+        }\n+        // self.cx.tcx.tables().qpath_def(p, id).hash(&mut self.s);\n+    }\n+\n     pub fn hash_path(&mut self, p: &Path) {\n         p.global.hash(&mut self.s);\n         for p in &p.segments {\n@@ -544,17 +541,17 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                         self.hash_expr(init);\n                     }\n                 }\n-            }\n+            },\n             StmtExpr(ref expr, _) => {\n                 let c: fn(_, _) -> _ = StmtExpr;\n                 c.hash(&mut self.s);\n                 self.hash_expr(expr);\n-            }\n+            },\n             StmtSemi(ref expr, _) => {\n                 let c: fn(_, _) -> _ = StmtSemi;\n                 c.hash(&mut self.s);\n                 self.hash_expr(expr);\n-            }\n+            },\n         }\n     }\n }"}, {"sha": "79cf15b6c5f5ebfd6328ab966b6aebe48549252d", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 52, "deletions": 49, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -36,15 +36,15 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n         if !has_attr(&item.attrs) {\n             return;\n         }\n         print_item(cx, item);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem) {\n         if !has_attr(&item.attrs) {\n             return;\n         }\n@@ -67,34 +67,34 @@ impl LateLintPass for Pass {\n             hir::ImplItemKind::Type(_) => println!(\"associated type\"),\n         }\n     }\n-/*\n-    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n-        if !has_attr(&item.attrs) {\n-            return;\n-        }\n-    }\n+    // fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n+    // if !has_attr(&item.attrs) {\n+    // return;\n+    // }\n+    // }\n+    //\n+    // fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, var: &'tcx hir::Variant, _:\n+    // &hir::Generics) {\n+    // if !has_attr(&var.node.attrs) {\n+    // return;\n+    // }\n+    // }\n+    //\n+    // fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField) {\n+    // if !has_attr(&field.attrs) {\n+    // return;\n+    // }\n+    // }\n+    //\n \n-    fn check_variant(&mut self, cx: &LateContext, var: &hir::Variant, _: &hir::Generics) {\n-        if !has_attr(&var.node.attrs) {\n-            return;\n-        }\n-    }\n-\n-    fn check_struct_field(&mut self, cx: &LateContext, field: &hir::StructField) {\n-        if !has_attr(&field.attrs) {\n-            return;\n-        }\n-    }\n-*/\n-\n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if !has_attr(&expr.attrs) {\n             return;\n         }\n         print_expr(cx, expr, 0);\n     }\n \n-    fn check_arm(&mut self, cx: &LateContext, arm: &hir::Arm) {\n+    fn check_arm(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm) {\n         if !has_attr(&arm.attrs) {\n             return;\n         }\n@@ -109,23 +109,22 @@ impl LateLintPass for Pass {\n         print_expr(cx, &arm.body, 1);\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n         if !has_attr(stmt.node.attrs()) {\n             return;\n         }\n         match stmt.node {\n             hir::StmtDecl(ref decl, _) => print_decl(cx, decl),\n-            hir::StmtExpr(ref e, _) | hir::StmtSemi(ref e, _) => print_expr(cx, e, 0),\n-        }\n-    }\n-/*\n-\n-    fn check_foreign_item(&mut self, cx: &LateContext, item: &hir::ForeignItem) {\n-        if !has_attr(&item.attrs) {\n-            return;\n+            hir::StmtExpr(ref e, _) |\n+            hir::StmtSemi(ref e, _) => print_expr(cx, e, 0),\n         }\n     }\n-*/\n+    // fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ForeignItem) {\n+    // if !has_attr(&item.attrs) {\n+    // return;\n+    // }\n+    // }\n+    //\n }\n \n fn has_attr(attrs: &[Attribute]) -> bool {\n@@ -275,11 +274,14 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n             println!(\"{}index expr:\", ind);\n             print_expr(cx, idx, indent + 1);\n         },\n-        hir::ExprPath(ref sel, ref path) => {\n-            println!(\"{}Path, {}\", ind, ty);\n-            println!(\"{}self: {:?}\", ind, sel);\n+        hir::ExprPath(hir::QPath::Resolved(ref ty, ref path)) => {\n+            println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n+        hir::ExprPath(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+            println!(\"{}Relative Path, {:?}\", ind, ty);\n+            println!(\"{}seg: {:?}\", ind, seg);\n+        },\n         hir::ExprAddrOf(ref muta, ref e) => {\n             println!(\"{}AddrOf, {}\", ind, ty);\n             println!(\"mutability: {:?}\", muta);\n@@ -353,8 +355,8 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n             } else {\n                 println!(\"weird extern crate without a crate id\");\n             }\n-        }\n-        hir::ItemUse(ref path) => println!(\"{:?}\", path.node),\n+        },\n+        hir::ItemUse(ref path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n         hir::ItemStatic(..) => println!(\"static item of type {:#?}\", cx.tcx.item_type(did)),\n         hir::ItemConst(..) => println!(\"const item of type {:#?}\", cx.tcx.item_type(did)),\n         hir::ItemFn(..) => {\n@@ -383,13 +385,11 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n                 println!(\"trait has no default impl\");\n             }\n         },\n-        hir::ItemDefaultImpl(_, ref trait_ref) => {\n-            let trait_did = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n-            println!(\"default impl for `{}`\", cx.tcx.item_path_str(trait_did));\n+        hir::ItemDefaultImpl(_, ref _trait_ref) => {\n+            println!(\"default impl\");\n         },\n-        hir::ItemImpl(_, _, _, Some(ref trait_ref), _, _) => {\n-            let trait_did = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n-            println!(\"impl of trait `{}`\", cx.tcx.item_path_str(trait_did));\n+        hir::ItemImpl(_, _, _, Some(ref _trait_ref), _, _) => {\n+            println!(\"trait impl\");\n         },\n         hir::ItemImpl(_, _, _, None, _, _) => {\n             println!(\"impl\");\n@@ -402,7 +402,7 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n     println!(\"{}+\", ind);\n     match pat.node {\n         hir::PatKind::Wild => println!(\"{}Wild\", ind),\n-        hir::PatKind::Binding(ref mode, ref name, ref inner) => {\n+        hir::PatKind::Binding(ref mode, _, ref name, ref inner) => {\n             println!(\"{}Binding\", ind);\n             println!(\"{}mode: {:?}\", ind, mode);\n             println!(\"{}name: {}\", ind, name.node);\n@@ -434,11 +434,14 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n                 print_pat(cx, field, indent + 1);\n             }\n         },\n-        hir::PatKind::Path(ref sel, ref path) => {\n-            println!(\"{}Path\", ind);\n-            println!(\"{}self: {:?}\", ind, sel);\n+        hir::PatKind::Path(hir::QPath::Resolved(ref ty, ref path)) => {\n+            println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n+        hir::PatKind::Path(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+            println!(\"{}Relative Path, {:?}\", ind, ty);\n+            println!(\"{}seg: {:?}\", ind, seg);\n+        },\n         hir::PatKind::Tuple(ref pats, opt_dots_position) => {\n             println!(\"{}Tuple\", ind);\n             if let Some(dot_position) = opt_dots_position {"}, {"sha": "cf9e90d62bd4fa2e2760a90d6293f0025350d7a0", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use utils::{paths, match_path, span_lint};\n use syntax::symbol::InternedString;\n use syntax::ast::{Name, NodeId, ItemKind, Crate as AstCrate};\n@@ -75,8 +75,8 @@ impl EarlyLintPass for Clippy {\n                                     span_lint(cx,\n                                               CLIPPY_LINTS_INTERNAL,\n                                               item.span,\n-                                              \"this constant should be before the previous constant due to lexical ordering\",\n-                                    );\n+                                              \"this constant should be before the previous constant due to lexical \\\n+                                               ordering\");\n                                 }\n                             }\n                             last_name = Some(name);\n@@ -104,19 +104,22 @@ impl LintPass for LintWithoutLintPass {\n }\n \n \n-impl LateLintPass for LintWithoutLintPass {\n-    fn check_item(&mut self, _: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemStatic(ref ty, MutImmutable, ref expr) = item.node {\n             if is_lint_ref_type(ty) {\n                 self.declared_lints.insert(item.name, item.span);\n             } else if is_lint_array_type(ty) && item.vis == Visibility::Inherited && item.name == \"ARRAY\" {\n-                let mut collector = LintCollector { output: &mut self.registered_lints };\n+                let mut collector = LintCollector {\n+                    output: &mut self.registered_lints,\n+                    cx: cx,\n+                };\n                 collector.visit_expr(expr);\n             }\n         }\n     }\n \n-    fn check_crate_post(&mut self, cx: &LateContext, _: &Crate) {\n+    fn check_crate_post(&mut self, cx: &LateContext<'a, 'tcx>, _: &'tcx Crate) {\n         for (lint_name, &lint_span) in &self.declared_lints {\n             // When using the `declare_lint!` macro, the original `lint_span`'s\n             // file points to \"<rustc macros>\".\n@@ -140,7 +143,7 @@ impl LateLintPass for LintWithoutLintPass {\n \n fn is_lint_ref_type(ty: &Ty) -> bool {\n     if let TyRptr(Some(_), MutTy { ty: ref inner, mutbl: MutImmutable }) = ty.node {\n-        if let TyPath(None, ref path) = inner.node {\n+        if let TyPath(ref path) = inner.node {\n             return match_path(path, &paths::LINT);\n         }\n     }\n@@ -149,25 +152,29 @@ fn is_lint_ref_type(ty: &Ty) -> bool {\n \n \n fn is_lint_array_type(ty: &Ty) -> bool {\n-    if let TyPath(None, ref path) = ty.node {\n+    if let TyPath(ref path) = ty.node {\n         match_path(path, &paths::LINT_ARRAY)\n     } else {\n         false\n     }\n }\n \n-struct LintCollector<'a> {\n+struct LintCollector<'a, 'tcx: 'a> {\n     output: &'a mut HashSet<Name>,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'v, 'a: 'v> Visitor<'v> for LintCollector<'a> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         walk_expr(self, expr);\n     }\n \n-    fn visit_path(&mut self, path: &'v Path, _: NodeId) {\n+    fn visit_path(&mut self, path: &'tcx Path, _: NodeId) {\n         if path.segments.len() == 1 {\n             self.output.insert(path.segments[0].name);\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "77b33d7b58939b14652146a094042781f30a2d52", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 216, "deletions": 113, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,6 +1,7 @@\n use reexport::*;\n use rustc::hir::*;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc::hir::def::Def;\n use rustc::hir::map::Node;\n use rustc::lint::{LintContext, LateContext, Level, Lint};\n use rustc::session::Session;\n@@ -34,23 +35,27 @@ pub type MethodArgs = HirVec<P<Expr>>;\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n-///     if_let_chain! {[\n-///         let Some(y) = x,\n-///         y.len() == 2,\n-///         let Some(z) = y,\n-///     ], {\n-///         block\n-///     }}\n+/// ```rust,ignore\n+/// if_let_chain! {[\n+///     let Some(y) = x,\n+///     y.len() == 2,\n+///     let Some(z) = y,\n+/// ], {\n+///     block\n+/// }}\n+/// ```\n ///\n /// becomes\n ///\n-///     if let Some(y) = x {\n-///         if y.len() == 2 {\n-///             if let Some(z) = y {\n-///                 block\n-///             }\n+/// ```rust,ignore\n+/// if let Some(y) = x {\n+///     if y.len() == 2 {\n+///         if let Some(z) = y {\n+///             block\n ///         }\n ///     }\n+/// }\n+/// ```\n #[macro_export]\n macro_rules! if_let_chain {\n     ([let $pat:pat = $expr:expr, $($tt:tt)+], $block:block) => {\n@@ -93,16 +98,27 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n     rhs.expn_id != lhs.expn_id\n }\n /// Returns true if this `expn_info` was expanded by any macro.\n-pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n-    cx.sess().codemap().with_expn_info(span.expn_id, |info| info.is_some())\n+pub fn in_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n+    cx.sess().codemap().with_expn_info(span.expn_id, |info| {\n+        match info {\n+            Some(info) => {\n+                match info.callee.format {\n+                    // don't treat range expressions desugared to structs as \"in_macro\"\n+                    ExpnFormat::CompilerDesugaring(name) => name != \"...\",\n+                    _ => true,\n+                }\n+            },\n+            None => false,\n+        }\n+    })\n }\n \n /// Returns true if the macro that expanded the crate was outside of the current crate or was a\n /// compiler plugin.\n-pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n+pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n     /// Invokes `in_macro` with the expansion info of the given span slightly heavy, try to use\n     /// this after other checks have already happened.\n-    fn in_macro_ext<T: LintContext>(cx: &T, opt_info: Option<&ExpnInfo>) -> bool {\n+    fn in_macro_ext<'a, T: LintContext<'a>>(cx: &T, opt_info: Option<&ExpnInfo>) -> bool {\n         // no ExpnInfo = no macro\n         opt_info.map_or(false, |info| {\n             if let ExpnFormat::MacroAttribute(..) = info.callee.format {\n@@ -123,7 +139,7 @@ pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n /// Check if a `DefId`'s path matches the given absolute type path usage.\n ///\n /// # Examples\n-/// ```\n+/// ```rust,ignore\n /// match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])\n /// ```\n ///\n@@ -150,8 +166,7 @@ pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n \n     cx.tcx.push_item_path(&mut apb, def_id);\n \n-    apb.names.len() == path.len() &&\n-    apb.names.iter().zip(path.iter()).all(|(a, &b)| &**a == b)\n+    apb.names.len() == path.len() && apb.names.iter().zip(path.iter()).all(|(a, &b)| &**a == b)\n }\n \n /// Check if type is struct, enum or union type with given def path.\n@@ -167,11 +182,11 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n \n     let trt_id = cx.tcx\n-                   .tables\n-                   .borrow()\n-                   .method_map\n-                   .get(&method_call)\n-                   .and_then(|callee| cx.tcx.impl_of_method(callee.def_id));\n+        .tables\n+        .borrow()\n+        .method_map\n+        .get(&method_call)\n+        .and_then(|callee| cx.tcx.impl_of_method(callee.def_id));\n     if let Some(trt_id) = trt_id {\n         match_def_path(cx, trt_id, path)\n     } else {\n@@ -184,32 +199,66 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n     let method_call = ty::MethodCall::expr(expr.id);\n \n     let trt_id = cx.tcx\n-                   .tables\n-                   .borrow()\n-                   .method_map\n-                   .get(&method_call)\n-                   .and_then(|callee| cx.tcx.trait_of_item(callee.def_id));\n+        .tables\n+        .borrow()\n+        .method_map\n+        .get(&method_call)\n+        .and_then(|callee| cx.tcx.trait_of_item(callee.def_id));\n     if let Some(trt_id) = trt_id {\n         match_def_path(cx, trt_id, path)\n     } else {\n         false\n     }\n }\n \n+pub fn last_path_segment(path: &QPath) -> &PathSegment {\n+    match *path {\n+        QPath::Resolved(_, ref path) => {\n+            path.segments\n+                .last()\n+                .expect(\"A path must have at least one segment\")\n+        },\n+        QPath::TypeRelative(_, ref seg) => seg,\n+    }\n+}\n+\n+pub fn single_segment_path(path: &QPath) -> Option<&PathSegment> {\n+    match *path {\n+        QPath::Resolved(_, ref path) if path.segments.len() == 1 => Some(&path.segments[0]),\n+        QPath::Resolved(..) => None,\n+        QPath::TypeRelative(_, ref seg) => Some(seg),\n+    }\n+}\n+\n /// Match a `Path` against a slice of segment string literals.\n ///\n /// # Examples\n-/// ```\n+/// ```rust,ignore\n /// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n-pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n+pub fn match_path(path: &QPath, segments: &[&str]) -> bool {\n+    match *path {\n+        QPath::Resolved(_, ref path) => match_path_old(path, segments),\n+        QPath::TypeRelative(ref ty, ref segment) => {\n+            match ty.node {\n+                TyPath(ref inner_path) => {\n+                    segments.len() > 0 && match_path(inner_path, &segments[..(segments.len() - 1)]) &&\n+                    segment.name == segments[segments.len() - 1]\n+                },\n+                _ => false,\n+            }\n+        },\n+    }\n+}\n+\n+pub fn match_path_old(path: &Path, segments: &[&str]) -> bool {\n     path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.name == *b)\n }\n \n /// Match a `Path` against a slice of segment string literals, e.g.\n ///\n /// # Examples\n-/// ```\n+/// ```rust,ignore\n /// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n@@ -224,7 +273,10 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n     let crates = cstore.crates();\n     let krate = crates.iter().find(|&&krate| cstore.crate_name(krate) == path[0]);\n     if let Some(krate) = krate {\n-        let krate = DefId { krate: *krate, index: CRATE_DEF_INDEX };\n+        let krate = DefId {\n+            krate: *krate,\n+            index: CRATE_DEF_INDEX,\n+        };\n         let mut items = cstore.item_children(krate);\n         let mut path_it = path.iter().skip(1).peekable();\n \n@@ -265,26 +317,25 @@ pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n \n /// Check whether a type implements a trait.\n /// See also `get_trait_def_id`.\n-pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, trait_id: DefId,\n-                                  ty_params: Vec<ty::Ty<'tcx>>)\n-                                  -> bool {\n+pub fn implements_trait<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    ty: ty::Ty<'tcx>,\n+    trait_id: DefId,\n+    ty_params: Vec<ty::Ty<'tcx>>\n+) -> bool {\n     cx.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n \n     let ty = cx.tcx.erase_regions(&ty);\n     cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n-        let obligation = cx.tcx.predicate_for_trait_def(traits::ObligationCause::dummy(),\n-                                                        trait_id,\n-                                                        0,\n-                                                        ty,\n-                                                        &ty_params);\n+        let obligation = cx.tcx.predicate_for_trait_def(traits::ObligationCause::dummy(), trait_id, 0, ty, &ty_params);\n \n         traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n     })\n }\n \n /// Resolve the definition of a node from its `NodeId`.\n-pub fn resolve_node(cx: &LateContext, id: NodeId) -> Option<def::Def> {\n-    cx.tcx.def_map.borrow().get(&id).map(|d| d.full_def())\n+pub fn resolve_node(cx: &LateContext, qpath: &QPath, id: NodeId) -> def::Def {\n+    cx.tcx.tables().qpath_def(qpath, id)\n }\n \n /// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n@@ -327,15 +378,15 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n /// Convert a span to a code snippet if available, otherwise use default.\n ///\n /// # Example\n-/// ```\n+/// ```rust,ignore\n /// snippet(cx, expr.span, \"..\")\n /// ```\n-pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+pub fn snippet<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or_else(|_| Cow::Borrowed(default))\n }\n \n /// Convert a span to a code snippet. Returns `None` if not available.\n-pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n+pub fn snippet_opt<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     cx.sess().codemap().span_to_snippet(span).ok()\n }\n \n@@ -344,17 +395,22 @@ pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n /// things which need to be printed as such.\n ///\n /// # Example\n-/// ```\n+/// ```rust,ignore\n /// snippet(cx, expr.span, \"..\")\n /// ```\n-pub fn snippet_block<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+pub fn snippet_block<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     let snip = snippet(cx, span, default);\n     trim_multiline(snip, true)\n }\n \n /// Like `snippet_block`, but add braces if the expr is not an `ExprBlock`.\n /// Also takes an `Option<String>` which can be put inside the braces.\n-pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr, option: Option<String>, default: &'a str) -> Cow<'a, str> {\n+pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n+    cx: &T,\n+    expr: &Expr,\n+    option: Option<String>,\n+    default: &'a str\n+) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n     let string = option.unwrap_or_default();\n     if let ExprBlock(_) = expr.node {\n@@ -375,32 +431,32 @@ pub fn trim_multiline(s: Cow<str>, ignore_first: bool) -> Cow<str> {\n \n fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n     let x = s.lines()\n-             .skip(ignore_first as usize)\n-             .filter_map(|l| {\n-                 if l.is_empty() {\n-                     None\n-                 } else {\n-                     // ignore empty lines\n-                     Some(l.char_indices()\n-                           .find(|&(_, x)| x != ch)\n-                           .unwrap_or((l.len(), ch))\n-                           .0)\n-                 }\n-             })\n-             .min()\n-             .unwrap_or(0);\n+        .skip(ignore_first as usize)\n+        .filter_map(|l| {\n+            if l.is_empty() {\n+                None\n+            } else {\n+                // ignore empty lines\n+                Some(l.char_indices()\n+                    .find(|&(_, x)| x != ch)\n+                    .unwrap_or((l.len(), ch))\n+                    .0)\n+            }\n+        })\n+        .min()\n+        .unwrap_or(0);\n     if x > 0 {\n         Cow::Owned(s.lines()\n-                    .enumerate()\n-                    .map(|(i, l)| {\n-                        if (ignore_first && i == 0) || l.is_empty() {\n-                            l\n-                        } else {\n-                            l.split_at(x).1\n-                        }\n-                    })\n-                    .collect::<Vec<_>>()\n-                    .join(\"\\n\"))\n+            .enumerate()\n+            .map(|(i, l)| {\n+                if (ignore_first && i == 0) || l.is_empty() {\n+                    l\n+                } else {\n+                    l.split_at(x).1\n+                }\n+            })\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\"))\n     } else {\n         s\n     }\n@@ -423,19 +479,19 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n     })\n }\n \n-pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c Block> {\n+pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeId) -> Option<&'tcx Block> {\n     let map = &cx.tcx.map;\n     let enclosing_node = map.get_enclosing_scope(node)\n-                            .and_then(|enclosing_id| map.find(enclosing_id));\n+        .and_then(|enclosing_id| map.find(enclosing_id));\n     if let Some(node) = enclosing_node {\n         match node {\n             Node::NodeBlock(block) => Some(block),\n-            Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, ref expr), .. }) => {\n-                match expr.node {\n+            Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, eid), .. }) => {\n+                match cx.tcx.map.expr(eid).node {\n                     ExprBlock(ref block) => Some(block),\n                     _ => None,\n                 }\n-            }\n+            },\n             _ => None,\n         }\n     } else {\n@@ -455,29 +511,40 @@ impl<'a> DiagnosticWrapper<'a> {\n     fn wiki_link(&mut self, lint: &'static Lint) {\n         if env::var(\"CLIPPY_DISABLE_WIKI_LINKS\").is_err() {\n             self.0.help(&format!(\"for further information visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-                               lint.name_lower()));\n+                                 lint.name_lower()));\n         }\n     }\n }\n \n-pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n+pub fn span_lint<'a, T: LintContext<'a>>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n     if cx.current_level(lint) != Level::Allow {\n         db.wiki_link(lint);\n     }\n }\n \n-// FIXME: needless lifetime doesn't trigger here\n-pub fn span_help_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span, msg: &str, help: &str) {\n+pub fn span_help_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n+    cx: &'a T,\n+    lint: &'static Lint,\n+    span: Span,\n+    msg: &str,\n+    help: &str\n+) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n     if cx.current_level(lint) != Level::Allow {\n         db.0.help(help);\n         db.wiki_link(lint);\n     }\n }\n \n-pub fn span_note_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span, msg: &str, note_span: Span,\n-                                              note: &str) {\n+pub fn span_note_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n+    cx: &'a T,\n+    lint: &'static Lint,\n+    span: Span,\n+    msg: &str,\n+    note_span: Span,\n+    note: &str\n+) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n     if cx.current_level(lint) != Level::Allow {\n         if note_span == span {\n@@ -489,8 +556,13 @@ pub fn span_note_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, sp\n     }\n }\n \n-pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n-    where F: FnOnce(&mut DiagnosticBuilder<'a>)\n+pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(\n+    cx: &'a T,\n+    lint: &'static Lint,\n+    sp: Span,\n+    msg: &str,\n+    f: F\n+) where F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>)\n {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n     if cx.current_level(lint) != Level::Allow {\n@@ -606,9 +678,9 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span> {\n     loop {\n         let span_name_span = cx.tcx\n-                               .sess\n-                               .codemap()\n-                               .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n+            .sess\n+            .codemap()\n+            .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n \n         match span_name_span {\n             Some((mac_name, new_span)) if mac_name == name => return Some(new_span),\n@@ -627,9 +699,9 @@ pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span>\n /// `is_direct_expn_of`.\n pub fn is_direct_expn_of(cx: &LateContext, span: Span, name: &str) -> Option<Span> {\n     let span_name_span = cx.tcx\n-                           .sess\n-                           .codemap()\n-                           .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n+        .sess\n+        .codemap()\n+        .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n \n     match span_name_span {\n         Some((mac_name, new_span)) if mac_name == name => Some(new_span),\n@@ -663,11 +735,7 @@ pub fn camel_case_until(s: &str) -> usize {\n             return i;\n         }\n     }\n-    if up {\n-        last_i\n-    } else {\n-        s.len()\n-    }\n+    if up { last_i } else { s.len() }\n }\n \n /// Return index of the last camel-case component of `s`.\n@@ -705,13 +773,18 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::T\n     let fn_def_id = cx.tcx.map.local_def_id(fn_item);\n     let fn_sig = cx.tcx.item_type(fn_def_id).fn_sig();\n     let fn_sig = cx.tcx.liberate_late_bound_regions(parameter_env.free_id_outlive, fn_sig);\n-    fn_sig.output\n+    fn_sig.output()\n }\n \n /// Check if two types are the same.\n // FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` == `for <'b> Foo<'b>` but\n // not for type parameters.\n-pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: ty::Ty<'tcx>, b: ty::Ty<'tcx>, parameter_item: NodeId) -> bool {\n+pub fn same_tys<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    a: ty::Ty<'tcx>,\n+    b: ty::Ty<'tcx>,\n+    parameter_item: NodeId\n+) -> bool {\n     let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, parameter_item);\n     cx.tcx.infer_ctxt(None, Some(parameter_env), Reveal::All).enter(|infcx| {\n         let new_a = a.subst(infcx.tcx, infcx.parameter_environment.free_substs);\n@@ -736,37 +809,41 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, env: Node\n \n /// Return whether a pattern is refutable.\n pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n-    fn is_enum_variant(cx: &LateContext, did: NodeId) -> bool {\n-        matches!(cx.tcx.def_map.borrow().get(&did).map(|d| d.full_def()), Some(def::Def::Variant(..)) | Some(def::Def::VariantCtor(..)))\n+    fn is_enum_variant(cx: &LateContext, qpath: &QPath, did: NodeId) -> bool {\n+        matches!(cx.tcx.tables().qpath_def(qpath, did),\n+                 def::Def::Variant(..) | def::Def::VariantCtor(..))\n     }\n \n-    fn are_refutable<'a, I: Iterator<Item=&'a Pat>>(cx: &LateContext, mut i: I) -> bool {\n+    fn are_refutable<'a, I: Iterator<Item = &'a Pat>>(cx: &LateContext, mut i: I) -> bool {\n         i.any(|pat| is_refutable(cx, pat))\n     }\n \n     match pat.node {\n-        PatKind::Binding(..) | PatKind::Wild => false,\n-        PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n-        PatKind::Lit(..) | PatKind::Range(..) => true,\n-        PatKind::Path(..) => is_enum_variant(cx, pat.id),\n+        PatKind::Binding(..) |\n+        PatKind::Wild => false,\n+        PatKind::Box(ref pat) |\n+        PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n+        PatKind::Lit(..) |\n+        PatKind::Range(..) => true,\n+        PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.id),\n         PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n-        PatKind::Struct(_, ref fields, _) => {\n-            if is_enum_variant(cx, pat.id) {\n+        PatKind::Struct(ref qpath, ref fields, _) => {\n+            if is_enum_variant(cx, qpath, pat.id) {\n                 true\n             } else {\n                 are_refutable(cx, fields.iter().map(|field| &*field.node.pat))\n             }\n-        }\n-        PatKind::TupleStruct(_, ref pats, _) => {\n-            if is_enum_variant(cx, pat.id) {\n+        },\n+        PatKind::TupleStruct(ref qpath, ref pats, _) => {\n+            if is_enum_variant(cx, qpath, pat.id) {\n                 true\n             } else {\n                 are_refutable(cx, pats.iter().map(|pat| &**pat))\n             }\n-        }\n+        },\n         PatKind::Slice(ref head, ref middle, ref tail) => {\n             are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat))\n-        }\n+        },\n     }\n }\n \n@@ -793,3 +870,29 @@ pub fn remove_blocks(expr: &Expr) -> &Expr {\n         expr\n     }\n }\n+\n+pub fn opt_def_id(def: Def) -> Option<DefId> {\n+    match def {\n+        Def::Fn(id) |\n+        Def::Mod(id) |\n+        Def::Static(id, _) |\n+        Def::Variant(id) |\n+        Def::VariantCtor(id, ..) |\n+        Def::Enum(id) |\n+        Def::TyAlias(id) |\n+        Def::AssociatedTy(id) |\n+        Def::TyParam(id) |\n+        Def::Struct(id) |\n+        Def::StructCtor(id, ..) |\n+        Def::Union(id) |\n+        Def::Trait(id) |\n+        Def::Method(id) |\n+        Def::Const(id) |\n+        Def::AssociatedConst(id) |\n+        Def::Local(id) |\n+        Def::Upvar(id, ..) |\n+        Def::Macro(id) => Some(id),\n+\n+        Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n+    }\n+}"}, {"sha": "402985613aeb8c0fbecb5a5b9c02d572c800ff13", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -12,7 +12,7 @@ pub const CLONE_TRAIT: [&'static str; 3] = [\"core\", \"clone\", \"Clone\"];\n pub const CMP_MAX: [&'static str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&'static str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n-pub const CSTRING_NEW: [&'static str; 4] = [\"std\", \"ffi\", \"CString\", \"new\"];\n+pub const CSTRING_NEW: [&'static str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"new\"];\n pub const DEBUG_FMT_METHOD: [&'static str; 4] = [\"core\", \"fmt\", \"Debug\", \"fmt\"];\n pub const DEFAULT_TRAIT: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n pub const DISPLAY_FMT_METHOD: [&'static str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n@@ -64,6 +64,7 @@ pub const RESULT: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n pub const RESULT_ERR: [&'static str; 4] = [\"core\", \"result\", \"Result\", \"Err\"];\n pub const RESULT_OK: [&'static str; 4] = [\"core\", \"result\", \"Result\", \"Ok\"];\n pub const SERDE_DE_VISITOR: [&'static str; 3] = [\"serde\", \"de\", \"Visitor\"];\n+pub const SLICE_INTO_VEC: [&'static str; 4] = [\"collections\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const VEC: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];"}, {"sha": "e4938f1c1edc3f0b910f1003d4540d72d881cf2a", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 43, "deletions": 59, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -29,9 +29,9 @@ pub const ONE: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"1\"));\n impl<'a> Display for Sugg<'a> {\n     fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n         match *self {\n-            Sugg::NonParen(ref s) | Sugg::MaybeParen(ref s) | Sugg::BinOp(_, ref s) => {\n-                s.fmt(f)\n-            }\n+            Sugg::NonParen(ref s) |\n+            Sugg::MaybeParen(ref s) |\n+            Sugg::BinOp(_, ref s) => s.fmt(f),\n         }\n     }\n }\n@@ -168,10 +168,12 @@ impl<'a> Sugg<'a> {\n         match self {\n             Sugg::NonParen(..) => self,\n             // (x) and (x).y() both don't need additional parens\n-            Sugg::MaybeParen(sugg) => if sugg.starts_with('(') && sugg.ends_with(')') {\n-                Sugg::MaybeParen(sugg)\n-            } else {\n-                Sugg::NonParen(format!(\"({})\", sugg).into())\n+            Sugg::MaybeParen(sugg) => {\n+                if sugg.starts_with('(') && sugg.ends_with(')') {\n+                    Sugg::MaybeParen(sugg)\n+                } else {\n+                    Sugg::NonParen(format!(\"({})\", sugg).into())\n+                }\n             },\n             Sugg::BinOp(_, sugg) => Sugg::NonParen(format!(\"({})\", sugg).into()),\n         }\n@@ -247,18 +249,17 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n \n     /// Whether the operator is a arithmetic operator (`+`, `-`, `*`, `/`, `%`).\n     fn is_arith(op: &AssocOp) -> bool {\n-        matches!(*op, AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus)\n+        matches!(*op,\n+                 AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus)\n     }\n \n     /// Whether the operator `op` needs parenthesis with the operator `other` in the direction\n     /// `dir`.\n     fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n         other.precedence() < op.precedence() ||\n-            (other.precedence() == op.precedence() &&\n-                ((op != other && associativity(op) != dir) ||\n-                 (op == other && associativity(op) != Associativity::Both))) ||\n-             is_shift(op) && is_arith(other) ||\n-             is_shift(other) && is_arith(op)\n+        (other.precedence() == op.precedence() &&\n+         ((op != other && associativity(op) != dir) || (op == other && associativity(op) != Associativity::Both))) ||\n+        is_shift(op) && is_arith(other) || is_shift(other) && is_arith(op)\n     }\n \n     let lhs_paren = if let Sugg::BinOp(ref lop, _) = *lhs {\n@@ -276,24 +277,12 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n     let lhs = ParenHelper::new(lhs_paren, lhs);\n     let rhs = ParenHelper::new(rhs_paren, rhs);\n     let sugg = match op {\n-        AssocOp::Add |\n-        AssocOp::BitAnd |\n-        AssocOp::BitOr |\n-        AssocOp::BitXor |\n-        AssocOp::Divide |\n-        AssocOp::Equal |\n-        AssocOp::Greater |\n-        AssocOp::GreaterEqual |\n-        AssocOp::LAnd |\n-        AssocOp::LOr |\n-        AssocOp::Less |\n-        AssocOp::LessEqual |\n-        AssocOp::Modulus |\n-        AssocOp::Multiply |\n-        AssocOp::NotEqual |\n-        AssocOp::ShiftLeft |\n-        AssocOp::ShiftRight |\n-        AssocOp::Subtract => format!(\"{} {} {}\", lhs, op.to_ast_binop().expect(\"Those are AST ops\").to_string(), rhs),\n+        AssocOp::Add | AssocOp::BitAnd | AssocOp::BitOr | AssocOp::BitXor | AssocOp::Divide | AssocOp::Equal |\n+        AssocOp::Greater | AssocOp::GreaterEqual | AssocOp::LAnd | AssocOp::LOr | AssocOp::Less |\n+        AssocOp::LessEqual | AssocOp::Modulus | AssocOp::Multiply | AssocOp::NotEqual | AssocOp::ShiftLeft |\n+        AssocOp::ShiftRight | AssocOp::Subtract => {\n+            format!(\"{} {} {}\", lhs, op.to_ast_binop().expect(\"Those are AST ops\").to_string(), rhs)\n+        },\n         AssocOp::Inplace => format!(\"in ({}) {}\", lhs, rhs),\n         AssocOp::Assign => format!(\"{} = {}\", lhs, rhs),\n         AssocOp::AssignOp(op) => format!(\"{} {}= {}\", lhs, binop_to_string(op), rhs),\n@@ -335,11 +324,10 @@ fn associativity(op: &AssocOp) -> Associativity {\n \n     match *op {\n         Inplace | Assign | AssignOp(_) => Associativity::Right,\n-        Add | BitAnd | BitOr | BitXor | LAnd | LOr | Multiply |\n-        As | Colon => Associativity::Both,\n-    Divide | Equal | Greater | GreaterEqual | Less | LessEqual | Modulus | NotEqual | ShiftLeft |\n-        ShiftRight | Subtract => Associativity::Left,\n-        DotDot | DotDotDot => Associativity::None\n+        Add | BitAnd | BitOr | BitXor | LAnd | LOr | Multiply | As | Colon => Associativity::Both,\n+        Divide | Equal | Greater | GreaterEqual | Less | LessEqual | Modulus | NotEqual | ShiftLeft | ShiftRight |\n+        Subtract => Associativity::Left,\n+        DotDot | DotDotDot => Associativity::None,\n     }\n }\n \n@@ -384,7 +372,7 @@ fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n }\n \n /// Return the indentation before `span` if there are nothing but `[ \\t]` before it on its line.\n-fn indentation<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n+fn indentation<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     let lo = cx.sess().codemap().lookup_char_pos(span.lo);\n     if let Some(line) = lo.file.get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */) {\n         if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n@@ -403,25 +391,25 @@ fn indentation<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n }\n \n /// Convenience extension trait for `DiagnosticBuilder`.\n-pub trait DiagnosticBuilderExt<T: LintContext> {\n+pub trait DiagnosticBuilderExt<'a, T: LintContext<'a>> {\n     /// Suggests to add an attribute to an item.\n     ///\n     /// Correctly handles indentation of the attribute and item.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```rust,ignore\n     /// db.suggest_item_with_attr(cx, item, \"#[derive(Default)]\");\n     /// ```\n-    fn suggest_item_with_attr<D: Display+?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D);\n+    fn suggest_item_with_attr<D: Display + ?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D);\n \n     /// Suggest to add an item before another.\n     ///\n     /// The item should not be indented (expect for inner indentation).\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```rust,ignore\n     /// db.suggest_prepend_item(cx, item,\n     /// \"fn foo() {\n     ///     bar();\n@@ -430,34 +418,30 @@ pub trait DiagnosticBuilderExt<T: LintContext> {\n     fn suggest_prepend_item(&mut self, cx: &T, item: Span, msg: &str, new_item: &str);\n }\n \n-impl<'a, 'b, T: LintContext> DiagnosticBuilderExt<T> for rustc_errors::DiagnosticBuilder<'b> {\n-    fn suggest_item_with_attr<D: Display+?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D) {\n+impl<'a, 'b, 'c, T: LintContext<'c>> DiagnosticBuilderExt<'c, T> for rustc_errors::DiagnosticBuilder<'b> {\n+    fn suggest_item_with_attr<D: Display + ?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D) {\n         if let Some(indent) = indentation(cx, item) {\n-            let span = Span {\n-                hi: item.lo,\n-                ..item\n-            };\n+            let span = Span { hi: item.lo, ..item };\n \n             self.span_suggestion(span, msg, format!(\"{}\\n{}\", attr, indent));\n         }\n     }\n \n     fn suggest_prepend_item(&mut self, cx: &T, item: Span, msg: &str, new_item: &str) {\n         if let Some(indent) = indentation(cx, item) {\n-            let span = Span {\n-                hi: item.lo,\n-                ..item\n-            };\n+            let span = Span { hi: item.lo, ..item };\n \n             let mut first = true;\n-            let new_item = new_item.lines().map(|l| {\n-                if first {\n-                    first = false;\n-                    format!(\"{}\\n\", l)\n-                } else {\n-                    format!(\"{}{}\\n\", indent, l)\n-                }\n-            }).collect::<String>();\n+            let new_item = new_item.lines()\n+                .map(|l| {\n+                    if first {\n+                        first = false;\n+                        format!(\"{}\\n\", l)\n+                    } else {\n+                        format!(\"{}{}\\n\", indent, l)\n+                    }\n+                })\n+                .collect::<String>();\n \n             self.span_suggestion(span, msg, format!(\"{}\\n{}\", new_item, indent));\n         }"}, {"sha": "dd3d4d261d053a26bc25a166e66b0a878afc70c9", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -32,8 +32,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_let_chain!{[\n             let ty::TypeVariants::TyRef(_, ref ty) = cx.tcx.tables().expr_ty_adjusted(expr).sty,\n@@ -65,7 +65,7 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n             } else {\n                 return;\n             }\n-        }\n+        },\n         higher::VecArgs::Vec(args) => {\n             if let Some(last) = args.iter().last() {\n                 let span = Span {\n@@ -78,7 +78,7 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n             } else {\n                 \"&[]\".into()\n             }\n-        }\n+        },\n     };\n \n     span_lint_and_then(cx, USELESS_VEC, span, \"useless use of `vec!`\", |db| {"}, {"sha": "daf0721af05aed7fd62358e08ba760b0d778a307", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -27,8 +27,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // check for instances of 0.0/0.0\n         if_let_chain! {[\n             let ExprBinary(ref op, ref left, ref right) = expr.node,"}, {"sha": "18d146d49173afa0aa52acb60cb7d51a1e245569", "filename": "rustfmt.toml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,5 +1,8 @@\n max_width = 120\n ideal_width = 100\n-fn_args_density = \"Compressed\"\n fn_call_width = 80\n-fn_args_paren_newline = false\n\\ No newline at end of file\n+match_block_trailing_comma = true\n+fn_args_layout = \"Block\"\n+closure_block_indent_threshold = 0\n+fn_return_indent = \"WithWhereClause\"\n+wrap_comments = true"}, {"sha": "9672f16eddc2829c4cf79bee425d2e131ed03563", "filename": "src/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -2,7 +2,6 @@\n #![feature(plugin_registrar)]\n #![feature(rustc_private)]\n #![allow(unknown_lints)]\n-#![feature(borrow_state)]\n #![allow(missing_docs_in_private_items)]\n \n extern crate rustc_plugin;\n@@ -12,11 +11,14 @@ extern crate clippy_lints;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    if reg.sess.lint_store.borrow_state() == std::cell::BorrowState::Unused && reg.sess.lint_store.borrow().get_lint_groups().iter().any(|&(s, _, _)| s == \"clippy\") {\n-        reg.sess.struct_warn(\"running cargo clippy on a crate that also imports the clippy plugin\").emit();\n-    } else {\n-        clippy_lints::register_plugins(reg);\n+    if let Ok(lint_store) = reg.sess.lint_store.try_borrow() {\n+        if lint_store.get_lint_groups().iter().any(|&(s, _, _)| s == \"clippy\") {\n+            reg.sess.struct_warn(\"running cargo clippy on a crate that also imports the clippy plugin\").emit();\n+            return;\n+        }\n     }\n+\n+    clippy_lints::register_plugins(reg);\n }\n \n // only exists to let the dogfood integration test works."}, {"sha": "0b91c79d21bc3fcb14c04ff6928cf3ffc81ea7d1", "filename": "src/main.rs", "status": "modified", "additions": 42, "deletions": 29, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -38,32 +38,35 @@ impl ClippyCompilerCalls {\n }\n \n impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n-    fn early_callback(&mut self,\n-                      matches: &getopts::Matches,\n-                      sopts: &config::Options,\n-                      cfg: &ast::CrateConfig,\n-                      descriptions: &rustc_errors::registry::Registry,\n-                      output: ErrorOutputType)\n-                      -> Compilation {\n+    fn early_callback(\n+        &mut self,\n+        matches: &getopts::Matches,\n+        sopts: &config::Options,\n+        cfg: &ast::CrateConfig,\n+        descriptions: &rustc_errors::registry::Registry,\n+        output: ErrorOutputType\n+    ) -> Compilation {\n         self.default.early_callback(matches, sopts, cfg, descriptions, output)\n     }\n-    fn no_input(&mut self,\n-                matches: &getopts::Matches,\n-                sopts: &config::Options,\n-                cfg: &ast::CrateConfig,\n-                odir: &Option<PathBuf>,\n-                ofile: &Option<PathBuf>,\n-                descriptions: &rustc_errors::registry::Registry)\n-                -> Option<(Input, Option<PathBuf>)> {\n+    fn no_input(\n+        &mut self,\n+        matches: &getopts::Matches,\n+        sopts: &config::Options,\n+        cfg: &ast::CrateConfig,\n+        odir: &Option<PathBuf>,\n+        ofile: &Option<PathBuf>,\n+        descriptions: &rustc_errors::registry::Registry\n+    ) -> Option<(Input, Option<PathBuf>)> {\n         self.default.no_input(matches, sopts, cfg, odir, ofile, descriptions)\n     }\n-    fn late_callback(&mut self,\n-                     matches: &getopts::Matches,\n-                     sess: &Session,\n-                     input: &Input,\n-                     odir: &Option<PathBuf>,\n-                     ofile: &Option<PathBuf>)\n-                     -> Compilation {\n+    fn late_callback(\n+        &mut self,\n+        matches: &getopts::Matches,\n+        sess: &Session,\n+        input: &Input,\n+        odir: &Option<PathBuf>,\n+        ofile: &Option<PathBuf>\n+    ) -> Compilation {\n         self.default.late_callback(matches, sess, input, odir, ofile)\n     }\n     fn build_controller(&mut self, sess: &Session, matches: &getopts::Matches) -> driver::CompileController<'a> {\n@@ -73,7 +76,12 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n             let old = std::mem::replace(&mut control.after_parse.callback, box |_| {});\n             control.after_parse.callback = Box::new(move |state| {\n                 {\n-                    let mut registry = rustc_plugin::registry::Registry::new(state.session, state.krate.as_ref().expect(\"at this compilation stage the krate must be parsed\").span);\n+                    let mut registry = rustc_plugin::registry::Registry::new(state.session,\n+                                                                             state.krate\n+                                                                                 .as_ref()\n+                                                                                 .expect(\"at this compilation stage \\\n+                                                                                          the krate must be parsed\")\n+                                                                                 .span);\n                     registry.args_hidden = Some(Vec::new());\n                     clippy_lints::register_plugins(&mut registry);\n \n@@ -153,7 +161,7 @@ pub fn main() {\n     if env::var(\"CLIPPY_DOGFOOD\").map(|_| true).unwrap_or(false) {\n         panic!(\"yummy\");\n     }\n-    \n+\n     // Check for version and help flags even when invoked as 'cargo-clippy'\n     if std::env::args().any(|a| a == \"--help\" || a == \"-h\") {\n         show_help();\n@@ -184,14 +192,16 @@ pub fn main() {\n \n         let current_dir = std::env::current_dir();\n \n-        let package_index = metadata.packages.iter()\n+        let package_index = metadata.packages\n+            .iter()\n             .position(|package| {\n                 let package_manifest_path = Path::new(&package.manifest_path);\n                 if let Some(ref manifest_path) = manifest_path {\n                     package_manifest_path == manifest_path\n                 } else {\n                     let current_dir = current_dir.as_ref().expect(\"could not read current directory\");\n-                    let package_manifest_directory = package_manifest_path.parent().expect(\"could not find parent directory of package manifest\");\n+                    let package_manifest_directory = package_manifest_path.parent()\n+                        .expect(\"could not find parent directory of package manifest\");\n                     package_manifest_directory == current_dir\n                 }\n             })\n@@ -205,7 +215,8 @@ pub fn main() {\n                         std::process::exit(code);\n                     }\n                 } else if [\"bin\", \"example\", \"test\", \"bench\"].contains(&&**first) {\n-                    if let Err(code) = process(vec![format!(\"--{}\", first), target.name].into_iter().chain(args), &dep_path) {\n+                    if let Err(code) = process(vec![format!(\"--{}\", first), target.name].into_iter().chain(args),\n+                                               &dep_path) {\n                         std::process::exit(code);\n                     }\n                 }\n@@ -285,8 +296,10 @@ fn process<P, I>(old_args: I, dep_path: P) -> Result<(), i32>\n     let exit_status = std::process::Command::new(\"cargo\")\n         .args(&args)\n         .env(\"RUSTC\", path)\n-        .spawn().expect(\"could not run cargo\")\n-        .wait().expect(\"failed to wait for cargo?\");\n+        .spawn()\n+        .expect(\"could not run cargo\")\n+        .wait()\n+        .expect(\"failed to wait for cargo?\");\n \n     if exit_status.success() {\n         Ok(())"}, {"sha": "81cb658df8dea25f24c09e7baf43cbc6e9a6ac91", "filename": "tests/compile-fail/absurd-extreme-comparisons.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fabsurd-extreme-comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fabsurd-extreme-comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fabsurd-extreme-comparisons.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -9,7 +9,7 @@ fn main() {\n     let u: u32 = 42;\n \n     u <= 0;\n-    //~^ ERROR this comparison involving the minimum or maximum element for this type contains a case that is always true or always false\n+    //~^ ERROR this comparison involving the minimum or maximum element for this type contains a\n     //~| HELP using u == 0 instead\n     u <= Z;\n     //~^ ERROR this comparison involving\n@@ -41,10 +41,10 @@ fn main() {\n         //~| HELP because 1-1 is the minimum value for this type, this comparison is always false\n     u >= !0;\n         //~^ ERROR this comparison involving\n-        //~| HELP because !0 is the maximum value for this type, the case where the two sides are not equal never occurs, consider using u == !0 instead\n+        //~| HELP consider using u == !0 instead\n     u <= 12 - 2*6;\n         //~^ ERROR this comparison involving\n-        //~| HELP because 12 - 2*6 is the minimum value for this type, the case where the two sides are not equal never occurs, consider using u == 12 - 2*6 instead\n+        //~| HELP consider using u == 12 - 2*6 instead\n \n     let i: i8 = 0;\n     i < -127 - 1;"}, {"sha": "e8549c01bc93268c7d4ff431a017150f3b14249b", "filename": "tests/compile-fail/assign_ops2.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fassign_ops2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fassign_ops2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fassign_ops2.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -34,3 +34,24 @@ fn main() {\n     a %= 42 % a;\n     a <<= 6 << a;\n }\n+\n+// check that we don't lint on op assign impls, because that's just the way to impl them\n+\n+use std::ops::{Mul, MulAssign};\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub struct Wrap(i64);\n+\n+impl Mul<i64> for Wrap {\n+    type Output = Self;\n+\n+    fn mul(self, rhs: i64) -> Self {\n+        Wrap(self.0 * rhs)\n+    }\n+}\n+\n+impl MulAssign<i64> for Wrap {\n+    fn mul_assign(&mut self, rhs: i64) {\n+        *self = *self * rhs\n+    }\n+}"}, {"sha": "090c39abc9268aa1a3af0e728d8a9baf98e8d3b9", "filename": "tests/compile-fail/block_in_if_condition.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fblock_in_if_condition.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -21,13 +21,13 @@ macro_rules! blocky_too {\n fn macro_if() {\n     if blocky!() {\n     }\n-    \n+\n     if blocky_too!() {\n     }\n }\n \n fn condition_has_block() -> i32 {\n-    if { //~ERROR in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n+    if { //~ERROR in an 'if' condition, avoid complex blocks or closures with blocks;\n         let x = 3;\n         x == 3\n     } {\n@@ -55,12 +55,12 @@ fn pred_test() {\n     // this is a sneaky case, where the block isn't directly in the condition, but is actually\n     // inside a closure that the condition is using.  same principle applies.  add some extra\n     // expressions to make sure linter isn't confused by them.\n-    if v == 3 && sky == \"blue\" && predicate(|x| { let target = 3; x == target }, v) { //~ERROR in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n-\n+    if v == 3 && sky == \"blue\" && predicate(|x| { let target = 3; x == target }, v) {\n+        //~^ERROR in an 'if' condition, avoid complex blocks or closures with blocks;\n     }\n \n-    if predicate(|x| { let target = 3; x == target }, v) { //~ERROR in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n-\n+    if predicate(|x| { let target = 3; x == target }, v) {\n+        //~^ERROR in an 'if' condition, avoid complex blocks or closures with blocks;\n     }\n \n }"}, {"sha": "9b1e1ec801ec92670b399b557d9ceeca46d08bc5", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -9,6 +9,7 @@\n #![allow(blacklisted_name)]\n #![allow(collapsible_if)]\n #![allow(zero_divided_by_zero, eq_op)]\n+#![allow(path_statements)]\n \n fn bar<T>(_: T) {}\n fn foo() -> bool { unimplemented!() }\n@@ -236,6 +237,13 @@ fn if_same_then_else() -> Result<&'static str, ()> {\n         if let Some(42) = None {}\n     }\n \n+    if true {\n+        if let Some(42) = None::<u8> {}\n+    }\n+    else {\n+        if let Some(42) = None::<u32> {}\n+    }\n+\n     if true {\n         if let Some(a) = Some(42) {}\n     }"}, {"sha": "63c678eb69c285dabf478fef2ed0b05e223c8e26", "filename": "tests/compile-fail/dlist.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdlist.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,12 +1,37 @@\n #![feature(plugin, collections)]\n+#![feature(associated_type_defaults)]\n+#![feature(associated_consts)]\n \n #![plugin(clippy)]\n #![deny(clippy)]\n+#![allow(dead_code)]\n \n extern crate collections;\n use collections::linked_list::LinkedList;\n \n-pub fn test(_: LinkedList<u8>) {  //~ ERROR I see you're using a LinkedList!\n+trait Foo {\n+    type Baz = LinkedList<u8>; //~ ERROR I see you're using a LinkedList!\n+    fn foo(LinkedList<u8>); //~ ERROR I see you're using a LinkedList!\n+    const BAR : Option<LinkedList<u8>>; //~ ERROR I see you're using a LinkedList!\n+}\n+\n+// ok, we don\u2019t want to warn for implementations, see #605\n+impl Foo for LinkedList<u8> {\n+    fn foo(_: LinkedList<u8>) {}\n+    const BAR : Option<LinkedList<u8>> = None;\n+}\n+\n+struct Bar;\n+impl Bar {\n+    fn foo(_: LinkedList<u8>) {} //~ ERROR I see you're using a LinkedList!\n+}\n+\n+pub fn test(my_favourite_linked_list: LinkedList<u8>) { //~ ERROR I see you're using a LinkedList!\n+    println!(\"{:?}\", my_favourite_linked_list)\n+}\n+\n+pub fn test_ret() -> Option<LinkedList<u8>> { //~ ERROR I see you're using a LinkedList!\n+    unimplemented!();\n }\n \n fn main(){"}, {"sha": "585535f9d999b83f157656cbe5f98e578d69a8f2", "filename": "tests/compile-fail/enum_variants.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fenum_variants.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -1,6 +1,6 @@\n #![feature(plugin, non_ascii_idents)]\n #![plugin(clippy)]\n-#![deny(clippy)]\n+#![deny(clippy, pub_enum_variant_names)]\n \n enum FakeCallType {\n     CALL, CREATE\n@@ -87,4 +87,19 @@ enum NonCaps { //~ ERROR: All variants have the same prefix: `Prefix`\n     PrefixCake,\n }\n \n+pub enum PubSeall { //~ ERROR: All variants have the same prefix:\n+    WithOutCake,\n+    WithOutTea,\n+    WithOut,\n+}\n+\n+#[allow(pub_enum_variant_names)]\n+mod allowed {\n+    pub enum PubAllowed {\n+        SomeThis,\n+        SomeThat,\n+        SomeOtherWhat,\n+    }\n+}\n+\n fn main() {}"}, {"sha": "faaae46af71821a94cc15536af1dd13b3966be2a", "filename": "tests/compile-fail/formatting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fformatting.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -5,6 +5,7 @@\n #![allow(unused_variables)]\n #![allow(unused_assignments)]\n #![allow(if_same_then_else)]\n+#![allow(deref_addrof)]\n \n fn foo() -> bool { true }\n "}, {"sha": "30a66a715f2000ed5d1650b77dc66a449ff1887d", "filename": "tests/compile-fail/no_effect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fno_effect.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -4,6 +4,7 @@\n #![deny(no_effect, unnecessary_operation)]\n #![allow(dead_code)]\n #![allow(path_statements)]\n+#![allow(deref_addrof)]\n #![feature(untagged_unions)]\n \n struct Unit;"}, {"sha": "b77afbc127025ea4969dafa202597b030dd674f1", "filename": "tests/compile-fail/reference.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fcompile-fail%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freference.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -0,0 +1,88 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+fn get_number() -> usize {\n+    10\n+}\n+\n+fn get_reference(n : &usize) -> &usize {\n+    n\n+}\n+\n+#[allow(many_single_char_names)]\n+#[allow(unused_variables)]\n+#[deny(deref_addrof)]\n+fn main() {\n+    let a = 10;\n+    let aref = &a;\n+\n+    let b = *&a;\n+    //~^ERROR immediately dereferencing a reference\n+    //~|HELP try this\n+    //~|SUGGESTION let b = a;\n+\n+    let b = *&get_number();\n+    //~^ERROR immediately dereferencing a reference\n+    //~|HELP try this\n+    //~|SUGGESTION let b = get_number();\n+\n+    let b = *get_reference(&a);\n+\n+    let bytes : Vec<usize> = vec![1, 2, 3, 4];\n+    let b = *&bytes[1..2][0];\n+    //~^ERROR immediately dereferencing a reference\n+    //~|HELP try this\n+    //~|SUGGESTION let b = bytes[1..2][0];\n+\n+    //This produces a suggestion of 'let b = (a);' which\n+    //will trigger the 'unused_parens' lint\n+    let b = *&(a);\n+    //~^ERROR immediately dereferencing a reference\n+    //~|HELP try this\n+    //~|SUGGESTION let b = (a)\n+\n+    let b = *(&a);\n+    //~^ERROR immediately dereferencing a reference\n+    //~|HELP try this\n+    //~|SUGGESTION let b = a;\n+\n+    let b = *((&a));\n+    //~^ERROR immediately dereferencing a reference\n+    //~|HELP try this\n+    //~|SUGGESTION let b = a\n+\n+    let b = *&&a;\n+    //~^ERROR immediately dereferencing a reference\n+    //~|HELP try this\n+    //~|SUGGESTION let b = &a;\n+\n+    let b = **&aref;\n+    //~^ERROR immediately dereferencing a reference\n+    //~|HELP try this\n+    //~|SUGGESTION let b = *aref;\n+\n+    //This produces a suggestion of 'let b = *&a;' which\n+    //will trigger the 'deref_addrof' lint again\n+    let b = **&&a;\n+    //~^ERROR immediately dereferencing a reference\n+    //~|HELP try this\n+    //~|SUGGESTION let b = *&a;\n+\n+    {\n+        let mut x = 10;\n+        let y = *&mut x;\n+        //~^ERROR immediately dereferencing a reference\n+        //~|HELP try this\n+        //~|SUGGESTION let y = x;\n+    }\n+\n+    {\n+        //This produces a suggestion of 'let y = *&mut x' which\n+        //will trigger the 'deref_addrof' lint again\n+        let mut x = 10;\n+        let y = **&mut &mut x;\n+        //~^ERROR immediately dereferencing a reference\n+        //~|HELP try this\n+        //~|SUGGESTION let y = *&mut x;\n+    }\n+}"}, {"sha": "eeab3a2bec593276656472c31471efea0c913018", "filename": "tests/ice_exacte_size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fice_exacte_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fice_exacte_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fice_exacte_size.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -14,4 +14,4 @@ impl Iterator for Foo {\n     }\n }\n \n-impl ExactSizeIterator for Foo { }\n+impl ExactSizeIterator for Foo {}"}, {"sha": "87cbb72f585768335d53977920a5e3014931d19d", "filename": "tests/issue-825.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fissue-825.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Fissue-825.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fissue-825.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -5,19 +5,10 @@\n \n // this should compile in a reasonable amount of time\n fn rust_type_id(name: String) {\n-    if \"bool\" == &name[..] ||\n-        \"uint\" == &name[..] ||\n-        \"u8\" == &name[..] ||\n-        \"u16\" == &name[..] ||\n-        \"u32\" == &name[..] ||\n-        \"f32\" == &name[..] ||\n-        \"f64\" == &name[..] ||\n-        \"i8\" == &name[..] ||\n-        \"i16\" == &name[..] ||\n-        \"i32\" == &name[..] ||\n-        \"i64\" == &name[..] ||\n-        \"Self\" == &name[..] ||\n-        \"str\" == &name[..] {\n+    if \"bool\" == &name[..] || \"uint\" == &name[..] || \"u8\" == &name[..] || \"u16\" == &name[..] ||\n+       \"u32\" == &name[..] || \"f32\" == &name[..] || \"f64\" == &name[..] || \"i8\" == &name[..] ||\n+       \"i16\" == &name[..] || \"i32\" == &name[..] || \"i64\" == &name[..] ||\n+       \"Self\" == &name[..] || \"str\" == &name[..] {\n         unreachable!();\n     }\n }"}, {"sha": "d6de36bfca73be1706fb69de64ea0c1a00bae231", "filename": "tests/trim_multiline.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Ftrim_multiline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/tests%2Ftrim_multiline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftrim_multiline.rs?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -13,6 +13,7 @@ fn test_single_line() {\n }\n \n #[test]\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n fn test_block() {\n     assert_eq!(\"\\\n if x {\n@@ -37,6 +38,7 @@ if x {\n }\n \n #[test]\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n fn test_empty_line() {\n     assert_eq!(\"\\\n if x {"}, {"sha": "ddb5d3ab32fde89986ce758e56419b04de3bde19", "filename": "util/update_lints.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/util%2Fupdate_lints.py", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4/util%2Fupdate_lints.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fupdate_lints.py?ref=7a1d85f1dea5ab36f0eb17b252dd9929adc82ca4", "patch": "@@ -98,7 +98,10 @@ def gen_deprecated(lints):\n     \"\"\"Declare deprecated lints\"\"\"\n \n     for lint in lints:\n-        yield '    store.register_removed(\"%s\", \"%s\");\\n' % (lint[1], lint[2])\n+        yield '    store.register_removed(\\n'\n+        yield '        \"%s\",\\n' % lint[1]\n+        yield '        \"%s\",\\n' % lint[2]\n+        yield '    );\\n'\n \n \n def replace_region(fn, region_start, region_end, callback,"}]}