{"sha": "0a2e7f2149c4630afc1d981a8e8de8e25b71b43f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMmU3ZjIxNDljNDYzMGFmYzFkOTgxYThlOGRlOGUyNWI3MWI0M2Y=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-01T01:28:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-01T01:28:43Z"}, "message": "Add restricted-parse mode, and parse bind expressions.", "tree": {"sha": "bbdc7bb2fc0a9a287b99c4da3464cde0583bb0c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbdc7bb2fc0a9a287b99c4da3464cde0583bb0c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a2e7f2149c4630afc1d981a8e8de8e25b71b43f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a2e7f2149c4630afc1d981a8e8de8e25b71b43f", "html_url": "https://github.com/rust-lang/rust/commit/0a2e7f2149c4630afc1d981a8e8de8e25b71b43f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a2e7f2149c4630afc1d981a8e8de8e25b71b43f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f6f0dcfbf0f908f9dd352061db37ae8ec0a6855", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f6f0dcfbf0f908f9dd352061db37ae8ec0a6855", "html_url": "https://github.com/rust-lang/rust/commit/2f6f0dcfbf0f908f9dd352061db37ae8ec0a6855"}], "stats": {"total": 78, "additions": 68, "deletions": 10}, "files": [{"sha": "15930b98c9a1eba82beddbaf84736fc0d52ce341", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 68, "deletions": 10, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e7f2149c4630afc1d981a8e8de8e25b71b43f/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e7f2149c4630afc1d981a8e8de8e25b71b43f/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=0a2e7f2149c4630afc1d981a8e8de8e25b71b43f", "patch": "@@ -15,6 +15,8 @@ state type parser =\n           fn peek() -> token.token;\n           impure fn bump();\n           impure fn err(str s);\n+          impure fn restrict(bool r);\n+          fn is_restricted() -> bool;\n           fn get_session() -> session.session;\n           fn get_span() -> common.span;\n           fn next_def_id() -> ast.def_id;\n@@ -27,6 +29,7 @@ impure fn new_parser(session.session sess,\n                            mutable common.pos lo,\n                            mutable common.pos hi,\n                            mutable ast.def_num def,\n+                           mutable bool restricted,\n                            ast.crate_num crate,\n                            lexer.reader rdr)\n         {\n@@ -47,6 +50,14 @@ impure fn new_parser(session.session sess,\n                 sess.span_err(span, m);\n             }\n \n+            impure fn restrict(bool r) {\n+                restricted = r;\n+            }\n+\n+            fn is_restricted() -> bool {\n+                ret restricted;\n+            }\n+\n             fn get_session() -> session.session {\n                 ret sess;\n             }\n@@ -65,7 +76,7 @@ impure fn new_parser(session.session sess,\n     auto rdr = lexer.new_reader(srdr, path);\n     auto npos = rdr.get_curr_pos();\n     ret stdio_parser(sess, lexer.next_token(rdr),\n-                     npos, npos, 0, crate, rdr);\n+                     npos, npos, 0, false, crate, rdr);\n }\n \n impure fn unexpected(parser p, token.token t) {\n@@ -481,6 +492,32 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n             ex = ast.expr_rec(fs.node, ast.ann_none);\n         }\n \n+        case (token.BIND) {\n+            p.bump();\n+            auto e = parse_restricted_expr(p);\n+            impure fn parse_expr_opt(parser p) -> option.t[@ast.expr] {\n+                log \"parse expr opt: \" + token.to_str(p.peek());\n+                alt (p.peek()) {\n+                    case (token.UNDERSCORE) {\n+                        p.bump();\n+                        ret none[@ast.expr];\n+                    }\n+                    case (_) {\n+                        ret some[@ast.expr](parse_expr(p));\n+                    }\n+                }\n+            }\n+\n+            auto pf = parse_expr_opt;\n+            auto es = parse_seq[option.t[@ast.expr]](token.LPAREN,\n+                                                     token.RPAREN,\n+                                                     some(token.COMMA),\n+                                                     pf, p);\n+            hi = es.span;\n+            auto e_ = ast.expr_bind(e, es.node, ast.ann_none);\n+            e = @spanned(lo, hi, e_);\n+        }\n+\n         case (_) {\n             alt (parse_lit(p)) {\n                 case (some[ast.lit](?lit)) {\n@@ -505,15 +542,19 @@ impure fn parse_path_expr(parser p) -> @ast.expr {\n         alt (p.peek()) {\n \n             case (token.LPAREN) {\n-                // Call expr.\n-                auto pf = parse_expr;\n-                auto es = parse_seq[@ast.expr](token.LPAREN,\n-                                               token.RPAREN,\n-                                               some(token.COMMA),\n-                                               pf, p);\n-                hi = es.span;\n-                auto e_ = ast.expr_call(e, es.node, ast.ann_none);\n-                e = @spanned(lo, hi, e_);\n+                if (p.is_restricted()) {\n+                    ret e;\n+                } else {\n+                    // Call expr.\n+                    auto pf = parse_expr;\n+                    auto es = parse_seq[@ast.expr](token.LPAREN,\n+                                                   token.RPAREN,\n+                                                   some(token.COMMA),\n+                                                   pf, p);\n+                    hi = es.span;\n+                    auto e_ = ast.expr_call(e, es.node, ast.ann_none);\n+                    e = @spanned(lo, hi, e_);\n+                }\n             }\n \n             case (token.DOT) {\n@@ -865,7 +906,24 @@ impure fn parse_alt_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, expr);\n }\n \n+\n+impure fn parse_restricted_expr(parser p) -> @ast.expr {\n+    ret parse_expr_res(p, true);\n+}\n+\n impure fn parse_expr(parser p) -> @ast.expr {\n+    ret parse_expr_res(p, false);\n+}\n+\n+impure fn parse_expr_res(parser p, bool restrict) -> @ast.expr {\n+    auto old = p.is_restricted();\n+    p.restrict(restrict);\n+    auto e = parse_expr_inner(p);\n+    p.restrict(old);\n+    ret e;\n+}\n+\n+impure fn parse_expr_inner(parser p) -> @ast.expr {\n     alt (p.peek()) {\n         case (token.LBRACE) {\n             auto blk = parse_block(p);"}]}