{"sha": "2a28b69948e13ec09a8a7701fa4d9001e880ad5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMjhiNjk5NDhlMTNlYzA5YThhNzcwMWZhNGQ5MDAxZTg4MGFkNWY=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-02-28T09:12:41Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-03-04T18:39:52Z"}, "message": "Refactor rustdocs attribute handling", "tree": {"sha": "f7ce9f1852b85fa7ebf28570b413d6b9776fa648", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7ce9f1852b85fa7ebf28570b413d6b9776fa648"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a28b69948e13ec09a8a7701fa4d9001e880ad5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a28b69948e13ec09a8a7701fa4d9001e880ad5f", "html_url": "https://github.com/rust-lang/rust/commit/2a28b69948e13ec09a8a7701fa4d9001e880ad5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a28b69948e13ec09a8a7701fa4d9001e880ad5f/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f6e09a956d65dbd81bb5ea12791208aed322704", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f6e09a956d65dbd81bb5ea12791208aed322704", "html_url": "https://github.com/rust-lang/rust/commit/8f6e09a956d65dbd81bb5ea12791208aed322704"}], "stats": {"total": 221, "additions": 85, "deletions": 136}, "files": [{"sha": "32f3706675ad24b3b5f42b6f62443b241f440205", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a28b69948e13ec09a8a7701fa4d9001e880ad5f/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a28b69948e13ec09a8a7701fa4d9001e880ad5f/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=2a28b69948e13ec09a8a7701fa4d9001e880ad5f", "patch": "@@ -26,7 +26,7 @@ use rustc::middle::const_eval;\n \n use core::DocContext;\n use doctree;\n-use clean;\n+use clean::{self, Attributes};\n \n use super::{Clean, ToSource};\n \n@@ -253,7 +253,7 @@ pub fn build_impls(cx: &DocContext, tcx: &TyCtxt,\n                 cstore::DlImpl(did) => build_impl(cx, tcx, did, impls),\n                 cstore::DlDef(Def::Mod(did)) => {\n                     // Don't recurse if this is a #[doc(hidden)] module\n-                    if load_attrs(cx, tcx, did).iter().any(|a| is_doc_hidden(a)) {\n+                    if load_attrs(cx, tcx, did).list_def(\"doc\").has_word(\"hidden\") {\n                         return;\n                     }\n \n@@ -282,7 +282,7 @@ pub fn build_impl(cx: &DocContext,\n     if let Some(ref t) = associated_trait {\n         // If this is an impl for a #[doc(hidden)] trait, be sure to not inline\n         let trait_attrs = load_attrs(cx, tcx, t.def_id);\n-        if trait_attrs.iter().any(|a| is_doc_hidden(a)) {\n+        if trait_attrs.list_def(\"doc\").has_word(\"hidden\") {\n             return\n         }\n     }\n@@ -422,20 +422,6 @@ pub fn build_impl(cx: &DocContext,\n     });\n }\n \n-fn is_doc_hidden(a: &clean::Attribute) -> bool {\n-    match *a {\n-        clean::List(ref name, ref inner) if *name == \"doc\" => {\n-            inner.iter().any(|a| {\n-                match *a {\n-                    clean::Word(ref s) => *s == \"hidden\",\n-                    _ => false,\n-                }\n-            })\n-        }\n-        _ => false\n-    }\n-}\n-\n fn build_module(cx: &DocContext, tcx: &TyCtxt,\n                 did: DefId) -> clean::Module {\n     let mut items = Vec::new();"}, {"sha": "20bcf759cf7c4724e476e32d6bdce9c77b207cc9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 54, "deletions": 57, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2a28b69948e13ec09a8a7701fa4d9001e880ad5f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a28b69948e13ec09a8a7701fa4d9001e880ad5f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2a28b69948e13ec09a8a7701fa4d9001e880ad5f", "patch": "@@ -258,7 +258,7 @@ pub struct Item {\n     pub source: Span,\n     /// Not everything has a name. E.g., impls\n     pub name: Option<String>,\n-    pub attrs: Vec<Attribute> ,\n+    pub attrs: Vec<Attribute>,\n     pub inner: ItemEnum,\n     pub visibility: Option<Visibility>,\n     pub def_id: DefId,\n@@ -267,49 +267,10 @@ pub struct Item {\n }\n \n impl Item {\n-    /// Finds the `doc` attribute as a List and returns the list of attributes\n-    /// nested inside.\n-    pub fn doc_list<'a>(&'a self) -> Option<&'a [Attribute]> {\n-        for attr in &self.attrs {\n-            match *attr {\n-                List(ref x, ref list) if \"doc\" == *x => {\n-                    return Some(list);\n-                }\n-                _ => {}\n-            }\n-        }\n-        return None;\n-    }\n-\n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n     pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n-        for attr in &self.attrs {\n-            match *attr {\n-                NameValue(ref x, ref v) if \"doc\" == *x => {\n-                    return Some(v);\n-                }\n-                _ => {}\n-            }\n-        }\n-        return None;\n-    }\n-\n-    pub fn is_hidden_from_doc(&self) -> bool {\n-        match self.doc_list() {\n-            Some(l) => {\n-                for innerattr in l {\n-                    match *innerattr {\n-                        Word(ref s) if \"hidden\" == *s => {\n-                            return true\n-                        }\n-                        _ => (),\n-                    }\n-                }\n-            },\n-            None => ()\n-        }\n-        return false;\n+        self.attrs.value(\"doc\")\n     }\n \n     pub fn is_mod(&self) -> bool {\n@@ -438,10 +399,54 @@ impl Clean<Item> for doctree::Module {\n     }\n }\n \n+pub trait Attributes {\n+    fn has_word(&self, &str) -> bool;\n+    fn value<'a>(&'a self, &str) -> Option<&'a str>;\n+    fn list_def<'a>(&'a self, &str) -> &'a [Attribute];\n+}\n+\n+impl Attributes for [Attribute] {\n+    /// Returns whether the attribute list contains a specific `Word`\n+    fn has_word(&self, word: &str) -> bool {\n+        for attr in self {\n+            if let Word(ref w) = *attr {\n+                if word == *w {\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Finds an attribute as NameValue and returns the corresponding value found.\n+    fn value<'a>(&'a self, name: &str) -> Option<&'a str> {\n+        for attr in self {\n+            if let NameValue(ref x, ref v) = *attr {\n+                if name == *x {\n+                    return Some(v);\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Finds an attribute as List and returns the list of attributes nested inside.\n+    fn list_def<'a>(&'a self, name: &str) -> &'a [Attribute] {\n+        for attr in self {\n+            if let List(ref x, ref list) = *attr {\n+                if name == *x {\n+                    return &list[..];\n+                }\n+            }\n+        }\n+        &[]\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum Attribute {\n     Word(String),\n-    List(String, Vec<Attribute> ),\n+    List(String, Vec<Attribute>),\n     NameValue(String, String)\n }\n \n@@ -1513,24 +1518,16 @@ impl PrimitiveType {\n     }\n \n     fn find(attrs: &[Attribute]) -> Option<PrimitiveType> {\n-        for attr in attrs {\n-            let list = match *attr {\n-                List(ref k, ref l) if *k == \"doc\" => l,\n-                _ => continue,\n-            };\n-            for sub_attr in list {\n-                let value = match *sub_attr {\n-                    NameValue(ref k, ref v)\n-                        if *k == \"primitive\" => v,\n-                    _ => continue,\n-                };\n-                match PrimitiveType::from_str(value) {\n-                    Some(p) => return Some(p),\n-                    None => {}\n+        for attr in attrs.list_def(\"doc\") {\n+            if let NameValue(ref k, ref v) = *attr {\n+                if \"primitive\" == *k {\n+                    if let ret@Some(..) = PrimitiveType::from_str(v) {\n+                        return ret;\n+                    }\n                 }\n             }\n         }\n-        return None\n+        None\n     }\n \n     pub fn to_string(&self) -> &'static str {"}, {"sha": "f1d836900798319e46b3cb75ec1fc1e60347585a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 9, "deletions": 38, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2a28b69948e13ec09a8a7701fa4d9001e880ad5f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a28b69948e13ec09a8a7701fa4d9001e880ad5f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2a28b69948e13ec09a8a7701fa4d9001e880ad5f", "patch": "@@ -62,7 +62,7 @@ use rustc::middle::stability;\n use rustc::session::config::get_unstable_features_setting;\n use rustc_front::hir;\n \n-use clean::{self, SelfTy};\n+use clean::{self, SelfTy, Attributes};\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n@@ -432,8 +432,7 @@ pub fn run(mut krate: clean::Crate,\n \n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n-    let default: &[_] = &[];\n-    if let Some(attrs) = krate.module.as_ref().map(|m| m.doc_list().unwrap_or(default)) {\n+    if let Some(attrs) = krate.module.as_ref().map(|m| m.attrs.list_def(\"doc\")) {\n         for attr in attrs {\n             match *attr {\n                 clean::NameValue(ref x, ref s)\n@@ -833,28 +832,13 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n \n     // Failing that, see if there's an attribute specifying where to find this\n     // external crate\n-    for attr in &e.attrs {\n-        match *attr {\n-            clean::List(ref x, ref list) if \"doc\" == *x => {\n-                for attr in list {\n-                    match *attr {\n-                        clean::NameValue(ref x, ref s)\n-                                if \"html_root_url\" == *x => {\n-                            if s.ends_with(\"/\") {\n-                                return Remote(s.to_string());\n-                            }\n-                            return Remote(format!(\"{}/\", s));\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-            _ => {}\n+    e.attrs.list_def(\"doc\").value(\"html_root_url\").map(|url| {\n+        let mut url = url.to_owned();\n+        if !url.ends_with(\"/\") {\n+            url.push('/')\n         }\n-    }\n-\n-    // Well, at least we tried.\n-    return Unknown;\n+        Remote(url)\n+    }).unwrap_or(Unknown) // Well, at least we tried.\n }\n \n impl<'a> DocFolder for SourceCollector<'a> {\n@@ -1153,19 +1137,6 @@ impl DocFolder for Cache {\n         // implementations elsewhere\n         let ret = self.fold_item_recur(item).and_then(|item| {\n             if let clean::Item { attrs, inner: clean::ImplItem(i), .. } = item {\n-                // extract relevant documentation for this impl\n-                let dox = match attrs.into_iter().find(|a| {\n-                    match *a {\n-                        clean::NameValue(ref x, _)\n-                                if \"doc\" == *x => {\n-                            true\n-                        }\n-                        _ => false\n-                    }\n-                }) {\n-                    Some(clean::NameValue(_, dox)) => Some(dox),\n-                    Some(..) | None => None,\n-                };\n                 // Figure out the id of this impl. This may map to a\n                 // primitive rather than always to a struct/enum.\n                 let did = match i.for_ {\n@@ -1189,7 +1160,7 @@ impl DocFolder for Cache {\n                 if let Some(did) = did {\n                     self.impls.entry(did).or_insert(vec![]).push(Impl {\n                         impl_: i,\n-                        dox: dox,\n+                        dox: attrs.value(\"doc\").map(|s|s.to_owned()),\n                         stability: item.stability.clone(),\n                     });\n                 }"}, {"sha": "3c7aadb3533c414c764e3a1e9fde5c23f00cd990", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2a28b69948e13ec09a8a7701fa4d9001e880ad5f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a28b69948e13ec09a8a7701fa4d9001e880ad5f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=2a28b69948e13ec09a8a7701fa4d9001e880ad5f", "patch": "@@ -94,6 +94,8 @@ pub mod visit_ast;\n pub mod test;\n mod flock;\n \n+use clean::Attributes;\n+\n type Pass = (&'static str,                                      // name\n              fn(clean::Crate) -> plugins::PluginResult,         // fn\n              &'static str);                                     // description\n@@ -379,32 +381,25 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     // Process all of the crate attributes, extracting plugin metadata along\n     // with the passes which we are supposed to run.\n-    match krate.module.as_ref().unwrap().doc_list() {\n-        Some(nested) => {\n-            for inner in nested {\n-                match *inner {\n-                    clean::Word(ref x)\n-                            if \"no_default_passes\" == *x => {\n-                        default_passes = false;\n-                    }\n-                    clean::NameValue(ref x, ref value)\n-                            if \"passes\" == *x => {\n-                        for pass in value.split_whitespace() {\n-                            passes.push(pass.to_string());\n-                        }\n-                    }\n-                    clean::NameValue(ref x, ref value)\n-                            if \"plugins\" == *x => {\n-                        for p in value.split_whitespace() {\n-                            plugins.push(p.to_string());\n-                        }\n-                    }\n-                    _ => {}\n+    for attr in krate.module.as_ref().unwrap().attrs.list_def(\"doc\") {\n+        match *attr {\n+            clean::Word(ref w) if \"no_default_passes\" == *w => {\n+                default_passes = false;\n+            },\n+            clean::NameValue(ref name, ref value) => {\n+                let sink = match &name[..] {\n+                    \"passes\" => &mut passes,\n+                    \"plugins\" => &mut plugins,\n+                    _ => continue,\n+                };\n+                for p in value.split_whitespace() {\n+                    sink.push(p.to_string());\n                 }\n             }\n+            _ => (),\n         }\n-        None => {}\n     }\n+\n     if default_passes {\n         for name in DEFAULT_PASSES.iter().rev() {\n             passes.insert(0, name.to_string());"}, {"sha": "6293aa3c2725c5074f2c8c66ffdbdf0230da6abc", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a28b69948e13ec09a8a7701fa4d9001e880ad5f/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a28b69948e13ec09a8a7701fa4d9001e880ad5f/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=2a28b69948e13ec09a8a7701fa4d9001e880ad5f", "patch": "@@ -16,7 +16,7 @@ use std::string::String;\n use std::usize;\n use rustc_front::hir;\n \n-use clean;\n+use clean::{self, Attributes};\n use clean::Item;\n use plugins;\n use fold;\n@@ -33,7 +33,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n         }\n         impl<'a> fold::DocFolder for Stripper<'a> {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n-                if i.is_hidden_from_doc() {\n+                if i.attrs.list_def(\"doc\").has_word(\"hidden\") {\n                     debug!(\"found one in strip_hidden; removing\");\n                     self.stripped.insert(i.def_id);\n "}]}