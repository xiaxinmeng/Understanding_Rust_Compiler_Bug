{"sha": "f3ff084d0166b72d9ad9cf11ad1ec21d5d4b2158", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzZmYwODRkMDE2NmI3MmQ5YWQ5Y2YxMWFkMWVjMjFkNWQ0YjIxNTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-03T18:06:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-25T12:04:07Z"}, "message": "Remove the regionck impl of Typer and just use fcx. This requires\nmodifying fcx to remove type variables where possible, but that's it.", "tree": {"sha": "1b8263c51ebd25c9c8ab5b7a35f064247fa09e6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b8263c51ebd25c9c8ab5b7a35f064247fa09e6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3ff084d0166b72d9ad9cf11ad1ec21d5d4b2158", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3ff084d0166b72d9ad9cf11ad1ec21d5d4b2158", "html_url": "https://github.com/rust-lang/rust/commit/f3ff084d0166b72d9ad9cf11ad1ec21d5d4b2158", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3ff084d0166b72d9ad9cf11ad1ec21d5d4b2158/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "230d0eb0031a9bd9df601ee95b62badd5771d9d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/230d0eb0031a9bd9df601ee95b62badd5771d9d0", "html_url": "https://github.com/rust-lang/rust/commit/230d0eb0031a9bd9df601ee95b62badd5771d9d0"}], "stats": {"total": 74, "additions": 19, "deletions": 55}, "files": [{"sha": "835e486019818e13dc62020910f078992e8a4c1f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3ff084d0166b72d9ad9cf11ad1ec21d5d4b2158/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ff084d0166b72d9ad9cf11ad1ec21d5d4b2158/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f3ff084d0166b72d9ad9cf11ad1ec21d5d4b2158", "patch": "@@ -287,11 +287,16 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         self.ccx.tcx\n     }\n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        Ok(self.node_ty(id))\n+        let ty = self.node_ty(id);\n+        Ok(self.infcx().resolve_type_vars_if_possible(ty))\n+    }\n     }\n     fn node_method_ty(&self, method_call: ty::MethodCall)\n                       -> Option<Ty<'tcx>> {\n-        self.inh.method_map.borrow().get(&method_call).map(|m| m.ty)\n+        self.inh.method_map.borrow()\n+                           .get(&method_call)\n+                           .map(|method| method.ty)\n+                           .map(|ty| self.infcx().resolve_type_vars_if_possible(ty))\n     }\n     fn adjustments(&self) -> &RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.inh.adjustments"}, {"sha": "f2aeea665b6647560a7d525da89276d9efcd253f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 12, "deletions": 53, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f3ff084d0166b72d9ad9cf11ad1ec21d5d4b2158/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ff084d0166b72d9ad9cf11ad1ec21d5d4b2158/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f3ff084d0166b72d9ad9cf11ad1ec21d5d4b2158", "patch": "@@ -126,7 +126,7 @@ use middle::ty::{ReScope};\n use middle::ty::{mod, Ty, MethodCall};\n use middle::infer;\n use middle::pat_util;\n-use util::nodemap::{DefIdMap, NodeMap, FnvHashMap};\n+use util::nodemap::{FnvHashMap};\n use util::ppaux::{ty_to_string, Repr};\n \n use syntax::{ast, ast_util};\n@@ -446,47 +446,6 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     }\n }\n \n-impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-        self.fcx.ccx.tcx\n-    }\n-\n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n-        let t = self.resolve_node_type(id);\n-        if ty::type_is_error(t) {Err(())} else {Ok(t)}\n-    }\n-\n-    fn node_method_ty(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n-        self.resolve_method_type(method_call)\n-    }\n-\n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        &self.fcx.inh.adjustments\n-    }\n-\n-    fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.fcx.inh.method_map.borrow().contains_key(&MethodCall::expr(id))\n-    }\n-\n-    fn temporary_scope(&self, id: ast::NodeId) -> Option<CodeExtent> {\n-        self.tcx().region_maps.temporary_scope(id)\n-    }\n-\n-    fn upvar_borrow(&self, id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.fcx.inh.upvar_borrow_map.borrow()[id].clone()\n-    }\n-\n-    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause {\n-        self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n-    }\n-\n-    fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n-        &self.fcx.inh.unboxed_closures\n-    }\n-}\n-\n impl<'a, 'tcx, 'v> Visitor<'v> for Rcx<'a, 'tcx> {\n     // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n@@ -767,7 +726,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             constrain_bindings_in_pat(&**pat, rcx);\n \n             {\n-                let mc = mc::MemCategorizationContext::new(rcx);\n+                let mc = mc::MemCategorizationContext::new(rcx.fcx);\n                 let pat_ty = rcx.resolve_node_type(pat.id);\n                 let pat_cmt = mc.cat_rvalue(pat.id,\n                                             pat.span,\n@@ -1080,7 +1039,7 @@ fn constrain_callee(rcx: &mut Rcx,\n                 ty::RegionTraitStore(r, _) => {\n                     // While we're here, link the closure's region with a unique\n                     // immutable borrow (gathered later in borrowck)\n-                    let mc = mc::MemCategorizationContext::new(rcx);\n+                    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n                     let expr_cmt = ignore_err!(mc.cat_expr(callee_expr));\n                     link_region(rcx, callee_expr.span, call_region,\n                                 ty::UniqueImmBorrow, expr_cmt);\n@@ -1189,7 +1148,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                     method.ty.repr(rcx.tcx()))[])\n                 };\n                 {\n-                    let mc = mc::MemCategorizationContext::new(rcx);\n+                    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     link_region(rcx, deref_expr.span, r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n@@ -1285,7 +1244,7 @@ fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n     debug!(\"link_addr_of(base=?)\");\n \n     let cmt = {\n-        let mc = mc::MemCategorizationContext::new(rcx);\n+        let mc = mc::MemCategorizationContext::new(rcx.fcx);\n         ignore_err!(mc.cat_expr(base))\n     };\n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n@@ -1300,7 +1259,7 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n         None => { return; }\n         Some(ref expr) => &**expr,\n     };\n-    let mc = mc::MemCategorizationContext::new(rcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n     link_pattern(rcx, mc, discr_cmt, &*local.pat);\n }\n@@ -1310,7 +1269,7 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n /// linked to the lifetime of its guarantor (if any).\n fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     debug!(\"regionck::for_match()\");\n-    let mc = mc::MemCategorizationContext::new(rcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={}\", discr_cmt.repr(rcx.tcx()));\n     for arm in arms.iter() {\n@@ -1325,7 +1284,7 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n /// linked to the lifetime of its guarantor (if any).\n fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n     debug!(\"regionck::link_fn_args(body_scope={})\", body_scope);\n-    let mc = mc::MemCategorizationContext::new(rcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     for arg in args.iter() {\n         let arg_ty = rcx.fcx.node_ty(arg.id);\n         let re_scope = ty::ReScope(body_scope);\n@@ -1340,7 +1299,7 @@ fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n /// Link lifetimes of any ref bindings in `root_pat` to the pointers found in the discriminant, if\n /// needed.\n fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                          mc: mc::MemCategorizationContext<Rcx<'a, 'tcx>>,\n+                          mc: mc::MemCategorizationContext<FnCtxt<'a, 'tcx>>,\n                           discr_cmt: mc::cmt<'tcx>,\n                           root_pat: &ast::Pat) {\n     debug!(\"link_pattern(discr_cmt={}, root_pat={})\",\n@@ -1379,7 +1338,7 @@ fn link_autoref(rcx: &Rcx,\n                 autoref: &ty::AutoRef) {\n \n     debug!(\"link_autoref(autoref={})\", autoref);\n-    let mc = mc::MemCategorizationContext::new(rcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n \n@@ -1401,7 +1360,7 @@ fn link_by_ref(rcx: &Rcx,\n     let tcx = rcx.tcx();\n     debug!(\"link_by_ref(expr={}, callee_scope={})\",\n            expr.repr(tcx), callee_scope);\n-    let mc = mc::MemCategorizationContext::new(rcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let borrow_region = ty::ReScope(callee_scope);\n     link_region(rcx, expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n@@ -1669,7 +1628,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n /// assignment expression.\n fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n                                          lhs: &ast::Expr) {\n-    let mc = mc::MemCategorizationContext::new(rcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let cmt = ignore_err!(mc.cat_expr(lhs));\n     adjust_upvar_borrow_kind_for_mut(rcx, cmt);\n }"}]}