{"sha": "32fa80dda57f3c468bb290657eb04720144506ab", "node_id": "C_kwDOAAsO6NoAKDMyZmE4MGRkYTU3ZjNjNDY4YmIyOTA2NTdlYjA0NzIwMTQ0NTA2YWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-08T19:42:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-08T19:42:33Z"}, "message": "Auto merge of #9447 - flip1995:rustup, r=flip1995\n\nRustup\n\nr? `@ghost`\n\nchangelog: none", "tree": {"sha": "81dfbd9256878d97f3fe609e265d4cbb7cd93e70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81dfbd9256878d97f3fe609e265d4cbb7cd93e70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32fa80dda57f3c468bb290657eb04720144506ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32fa80dda57f3c468bb290657eb04720144506ab", "html_url": "https://github.com/rust-lang/rust/commit/32fa80dda57f3c468bb290657eb04720144506ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32fa80dda57f3c468bb290657eb04720144506ab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f92c9dcccc3b991924554ea2cda1d9afed18b2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f92c9dcccc3b991924554ea2cda1d9afed18b2f", "html_url": "https://github.com/rust-lang/rust/commit/1f92c9dcccc3b991924554ea2cda1d9afed18b2f"}, {"sha": "df536c9086471c1484c29d904aff9091d762e151", "url": "https://api.github.com/repos/rust-lang/rust/commits/df536c9086471c1484c29d904aff9091d762e151", "html_url": "https://github.com/rust-lang/rust/commit/df536c9086471c1484c29d904aff9091d762e151"}], "stats": {"total": 1688, "additions": 897, "deletions": 791}, "files": [{"sha": "2bc275ceff0be50cad4cabffd08cbe40e1751958", "filename": "book/src/development/common_tools_writing_lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -66,7 +66,7 @@ Starting with an `expr`, you can check whether it is calling a specific method\n impl<'tcx> LateLintPass<'tcx> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         // Check our expr is calling a method\n-        if let hir::ExprKind::MethodCall(path, _, [_self_arg, ..]) = &expr.kind\n+        if let hir::ExprKind::MethodCall(path, _, _self_arg, ..) = &expr.kind\n             // Check the name of this method is `some_method`\n             && path.ident.name == sym!(some_method)\n             // Optionally, check the type of the self argument."}, {"sha": "82574a8e64b0ae028eb64769914837fd8c148553", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -1,3 +1,4 @@\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(once_cell)]\n #![feature(rustc_private)]"}, {"sha": "7cd198ace86c0e3ff3f3edf4c9b44dc862b68429", "filename": "clippy_lints/src/assertions_on_result_states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fassertions_on_result_states.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fassertions_on_result_states.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_result_states.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnResultStates {\n             && matches!(cx.tcx.get_diagnostic_name(macro_call.def_id), Some(sym::assert_macro))\n             && let Some((condition, panic_expn)) = find_assert_args(cx, e, macro_call.expn)\n             && matches!(panic_expn, PanicExpn::Empty)\n-            && let ExprKind::MethodCall(method_segment, [recv], _) = condition.kind\n+            && let ExprKind::MethodCall(method_segment, recv, [], _) = condition.kind\n             && let result_type_with_refs = cx.typeck_results().expr_ty(recv)\n             && let result_type = result_type_with_refs.peel_refs()\n             && is_type_diagnostic_item(cx, result_type, sym::Result)"}, {"sha": "9464694a3b55ad16e0531810740e49fefd80f255", "filename": "clippy_lints/src/async_yields_async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fasync_yields_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fasync_yields_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fasync_yields_async.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for AsyncYieldsAsync {\n                     hir_id: body.value.hir_id,\n                 };\n                 let typeck_results = cx.tcx.typeck_body(body_id);\n-                let expr_ty = typeck_results.expr_ty(&body.value);\n+                let expr_ty = typeck_results.expr_ty(body.value);\n \n                 if implements_trait(cx, expr_ty, future_trait_def_id, &[]) {\n                     let return_expr_span = match &body.value.kind {"}, {"sha": "732dc2b433091b047abdffa296f7521ebbd7e3e9", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -475,15 +475,15 @@ fn check_lint_reason(cx: &LateContext<'_>, name: Symbol, items: &[NestedMetaItem\n \n fn is_relevant_item(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     if let ItemKind::Fn(_, _, eid) = item.kind {\n-        is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value)\n+        is_relevant_expr(cx, cx.tcx.typeck_body(eid), cx.tcx.hir().body(eid).value)\n     } else {\n         true\n     }\n }\n \n fn is_relevant_impl(cx: &LateContext<'_>, item: &ImplItem<'_>) -> bool {\n     match item.kind {\n-        ImplItemKind::Fn(_, eid) => is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value),\n+        ImplItemKind::Fn(_, eid) => is_relevant_expr(cx, cx.tcx.typeck_body(eid), cx.tcx.hir().body(eid).value),\n         _ => false,\n     }\n }\n@@ -492,7 +492,7 @@ fn is_relevant_trait(cx: &LateContext<'_>, item: &TraitItem<'_>) -> bool {\n     match item.kind {\n         TraitItemKind::Fn(_, TraitFn::Required(_)) => true,\n         TraitItemKind::Fn(_, TraitFn::Provided(eid)) => {\n-            is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value)\n+            is_relevant_expr(cx, cx.tcx.typeck_body(eid), cx.tcx.hir().body(eid).value)\n         },\n         _ => false,\n     }"}, {"sha": "4df4d6ddf416764241517468c5199649ea5eb26e", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n             // do not lint if the closure is called using an iterator (see #1141)\n             if_chain! {\n                 if let Some(parent) = get_parent_expr(self.cx, expr);\n-                if let ExprKind::MethodCall(_, [self_arg, ..], _) = &parent.kind;\n+                if let ExprKind::MethodCall(_, self_arg, ..) = &parent.kind;\n                 let caller = self.cx.typeck_results().expr_ty(self_arg);\n                 if let Some(iter_id) = self.cx.tcx.get_diagnostic_item(sym::Iterator);\n                 if implements_trait(self.cx, caller, iter_id, &[]);"}, {"sha": "656d639f0efd9838c272c92d6aa0e5d2e3fa7179", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -270,8 +270,8 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n                 ))\n             })\n         },\n-        ExprKind::MethodCall(path, args, _) if args.len() == 1 => {\n-            let type_of_receiver = cx.typeck_results().expr_ty(&args[0]);\n+        ExprKind::MethodCall(path, receiver, [], _) => {\n+            let type_of_receiver = cx.typeck_results().expr_ty(receiver);\n             if !is_type_diagnostic_item(cx, type_of_receiver, sym::Option)\n                 && !is_type_diagnostic_item(cx, type_of_receiver, sym::Result)\n             {\n@@ -285,7 +285,7 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n                     let path: &str = path.ident.name.as_str();\n                     a == path\n                 })\n-                .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", snippet_opt(cx, args[0].span)?, neg_method)))\n+                .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", snippet_opt(cx, receiver.span)?, neg_method)))\n         },\n         _ => None,\n     }"}, {"sha": "3f1edabe6c5040621bb2903b0df2e2ea07843270", "filename": "clippy_lints/src/casts/cast_abs_to_unsigned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fcasts%2Fcast_abs_to_unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fcasts%2Fcast_abs_to_unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_abs_to_unsigned.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -20,7 +20,7 @@ pub(super) fn check(\n     if meets_msrv(msrv, msrvs::UNSIGNED_ABS)\n         && let ty::Int(from) = cast_from.kind()\n         && let ty::Uint(to) = cast_to.kind()\n-        && let ExprKind::MethodCall(method_path, args, _) = cast_expr.kind\n+        && let ExprKind::MethodCall(method_path, receiver, ..) = cast_expr.kind\n         && method_path.ident.name.as_str() == \"abs\"\n     {\n         let span = if from.bit_width() == to.bit_width() {\n@@ -37,7 +37,7 @@ pub(super) fn check(\n             span,\n             &format!(\"casting the result of `{cast_from}::abs()` to {cast_to}\"),\n             \"replace with\",\n-            format!(\"{}.unsigned_abs()\", Sugg::hir(cx, &args[0], \"..\").maybe_par()),\n+            format!(\"{}.unsigned_abs()\", Sugg::hir(cx, receiver, \"..\").maybe_par()),\n             Applicability::MachineApplicable,\n         );\n     }"}, {"sha": "406547a4454e6a1abeb91b894a599f36c9109191", "filename": "clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -44,7 +44,7 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n                 .saturating_sub(constant_int(cx, right).map_or(0, |s| u64::try_from(s).expect(\"shift too high\"))),\n             _ => nbits,\n         },\n-        ExprKind::MethodCall(method, [left, right], _) => {\n+        ExprKind::MethodCall(method, left, [right], _) => {\n             if signed {\n                 return nbits;\n             }\n@@ -55,7 +55,7 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n             };\n             apply_reductions(cx, nbits, left, signed).min(max_bits.unwrap_or(u64::max_value()))\n         },\n-        ExprKind::MethodCall(method, [_, lo, hi], _) => {\n+        ExprKind::MethodCall(method, _, [lo, hi], _) => {\n             if method.ident.as_str() == \"clamp\" {\n                 //FIXME: make this a diagnostic item\n                 if let (Some(lo_bits), Some(hi_bits)) = (get_constant_bits(cx, lo), get_constant_bits(cx, hi)) {\n@@ -64,7 +64,7 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n             }\n             nbits\n         },\n-        ExprKind::MethodCall(method, [_value], _) => {\n+        ExprKind::MethodCall(method, _value, [], _) => {\n             if method.ident.name.as_str() == \"signum\" {\n                 0 // do not lint if cast comes from a `signum` function\n             } else {"}, {"sha": "da7b12f67266a31898f5fcec7484eb11f6e8f865", "filename": "clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -18,7 +18,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             cx.typeck_results().expr_ty(expr),\n         );\n         lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n-    } else if let ExprKind::MethodCall(method_path, [self_arg, ..], _) = &expr.kind {\n+    } else if let ExprKind::MethodCall(method_path, self_arg, ..) = &expr.kind {\n         if method_path.ident.name == sym!(cast)\n             && let Some(generic_args) = method_path.args\n             && let [GenericArg::Type(cast_to)] = generic_args.args\n@@ -64,7 +64,7 @@ fn is_used_as_unaligned(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n         return false;\n     };\n     match parent.kind {\n-        ExprKind::MethodCall(name, [self_arg, ..], _) if self_arg.hir_id == e.hir_id => {\n+        ExprKind::MethodCall(name, self_arg, ..) if self_arg.hir_id == e.hir_id => {\n             if matches!(name.ident.as_str(), \"read_unaligned\" | \"write_unaligned\")\n                 && let Some(def_id) = cx.typeck_results().type_dependent_def_id(parent.hir_id)\n                 && let Some(def_id) = cx.tcx.impl_of_method(def_id)"}, {"sha": "5b59350be042c9ee173a398e36c403a81c86e01a", "filename": "clippy_lints/src/casts/cast_sign_loss.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -41,14 +41,14 @@ fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast\n             }\n \n             // Don't lint for the result of methods that always return non-negative values.\n-            if let ExprKind::MethodCall(path, _, _) = cast_op.kind {\n+            if let ExprKind::MethodCall(path, ..) = cast_op.kind {\n                 let mut method_name = path.ident.name.as_str();\n                 let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n \n                 if_chain! {\n                     if method_name == \"unwrap\";\n                     if let Some(arglist) = method_chain_args(cast_op, &[\"unwrap\"]);\n-                    if let ExprKind::MethodCall(inner_path, _, _) = &arglist[0][0].kind;\n+                    if let ExprKind::MethodCall(inner_path, ..) = &arglist[0].0.kind;\n                     then {\n                         method_name = inner_path.ident.name.as_str();\n                     }"}, {"sha": "be02f328e989a67051091196a4d37a2bc8dc673b", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -131,10 +131,10 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 }\n             },\n \n-            ExprKind::MethodCall(_, args, _) => {\n+            ExprKind::MethodCall(_, receiver, args, _) => {\n                 if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n-                    for (expr, bound) in iter::zip(*args, fn_sig.inputs()) {\n+                    for (expr, bound) in iter::zip(std::iter::once(*receiver).chain(args.iter()), fn_sig.inputs()) {\n                         self.ty_bounds.push(TyBound::Ty(*bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();"}, {"sha": "88e28018e5d00529f0f1a63da92e29075aec75cc", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 47, "deletions": 49, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -503,7 +503,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n-        if let PatKind::Binding(BindingAnnotation::Ref, id, name, _) = pat.kind {\n+        if let PatKind::Binding(BindingAnnotation::REF, id, name, _) = pat.kind {\n             if let Some(opt_prev_pat) = self.ref_locals.get_mut(&id) {\n                 // This binding id has been seen before. Add this pattern to the list of changes.\n                 if let Some(prev_pat) = opt_prev_pat {\n@@ -581,7 +581,7 @@ fn try_parse_ref_op<'tcx>(\n     expr: &'tcx Expr<'_>,\n ) -> Option<(RefOp, &'tcx Expr<'tcx>)> {\n     let (def_id, arg) = match expr.kind {\n-        ExprKind::MethodCall(_, [arg], _) => (typeck.type_dependent_def_id(expr.hir_id)?, arg),\n+        ExprKind::MethodCall(_, arg, [], _) => (typeck.type_dependent_def_id(expr.hir_id)?, arg),\n         ExprKind::Call(\n             Expr {\n                 kind: ExprKind::Path(path),\n@@ -796,56 +796,54 @@ fn walk_parents<'tcx>(\n                             },\n                         })\n                     }),\n-                ExprKind::MethodCall(_, args, _) => {\n+                ExprKind::MethodCall(_, receiver, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n-                    args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n-                        if i == 0 {\n-                            // Check for calls to trait methods where the trait is implemented on a reference.\n-                            // Two cases need to be handled:\n-                            // * `self` methods on `&T` will never have auto-borrow\n-                            // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n-                            //   priority.\n-                            if e.hir_id != child_id {\n-                                Position::ReborrowStable(precedence)\n-                            } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n-                                && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n-                                && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n-                                && let subs = match cx\n-                                    .typeck_results()\n-                                    .node_substs_opt(parent.hir_id)\n-                                    .and_then(|subs| subs.get(1..))\n-                                {\n-                                    Some(subs) => cx.tcx.mk_substs(subs.iter().copied()),\n-                                    None => cx.tcx.mk_substs(std::iter::empty::<ty::subst::GenericArg<'_>>()),\n-                                } && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n-                                    // Trait methods taking `&self`\n-                                    sub_ty\n-                                } else {\n-                                    // Trait methods taking `self`\n-                                    arg_ty\n-                                } && impl_ty.is_ref()\n-                                && cx.tcx.infer_ctxt().enter(|infcx|\n-                                    infcx\n-                                        .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n-                                        .must_apply_modulo_regions()\n-                                )\n+                    if receiver.hir_id == child_id {\n+                        // Check for calls to trait methods where the trait is implemented on a reference.\n+                        // Two cases need to be handled:\n+                        // * `self` methods on `&T` will never have auto-borrow\n+                        // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n+                        //   priority.\n+                        if e.hir_id != child_id {\n+                            return Some(Position::ReborrowStable(precedence))\n+                        } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n+                            && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n+                            && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n+                            && let subs = match cx\n+                                .typeck_results()\n+                                .node_substs_opt(parent.hir_id)\n+                                .and_then(|subs| subs.get(1..))\n                             {\n-                                Position::MethodReceiverRefImpl\n+                                Some(subs) => cx.tcx.mk_substs(subs.iter().copied()),\n+                                None => cx.tcx.mk_substs(std::iter::empty::<ty::subst::GenericArg<'_>>()),\n+                            } && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n+                                // Trait methods taking `&self`\n+                                sub_ty\n                             } else {\n-                                Position::MethodReceiver\n-                            }\n+                                // Trait methods taking `self`\n+                                arg_ty\n+                            } && impl_ty.is_ref()\n+                            && cx.tcx.infer_ctxt().enter(|infcx|\n+                                infcx\n+                                    .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n+                                    .must_apply_modulo_regions()\n+                            )\n+                        {\n+                            return Some(Position::MethodReceiverRefImpl)\n+                        }\n+                        return Some(Position::MethodReceiver);\n+                    }\n+                    args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n+                        let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n+                        if let ty::Param(param_ty) = ty.kind() {\n+                            needless_borrow_impl_arg_position(cx, parent, i + 1, *param_ty, e, precedence, msrv)\n                         } else {\n-                            let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n-                            if let ty::Param(param_ty) = ty.kind() {\n-                                needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n-                            } else {\n-                                ty_auto_deref_stability(\n-                                    cx,\n-                                    cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n-                                    precedence,\n-                                )\n-                                .position_for_arg()\n-                            }\n+                            ty_auto_deref_stability(\n+                                cx,\n+                                cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i + 1)),\n+                                precedence,\n+                            )\n+                            .position_for_arg()\n                         }\n                     })\n                 },\n@@ -1174,7 +1172,7 @@ fn replace_types<'tcx>(\n         if replaced.insert(param_ty.index) {\n             for projection_predicate in projection_predicates {\n                 if projection_predicate.projection_ty.self_ty() == param_ty.to_ty(cx.tcx)\n-                    && let ty::Term::Ty(term_ty) = projection_predicate.term\n+                    && let Some(term_ty) = projection_predicate.term.ty()\n                     && let ty::Param(term_param_ty) = term_ty.kind()\n                 {\n                     let item_def_id = projection_predicate.projection_ty.item_def_id;"}, {"sha": "eb158d850fa724b81a8ad83f209bd51697fa8e59", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -236,7 +236,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                         typeck_results: cx.tcx.typeck(item.def_id),\n                         panic_span: None,\n                     };\n-                    fpu.visit_expr(&body.value);\n+                    fpu.visit_expr(body.value);\n                     lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n                 }\n             },\n@@ -286,7 +286,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                 typeck_results: cx.tcx.typeck(item.def_id),\n                 panic_span: None,\n             };\n-            fpu.visit_expr(&body.value);\n+            fpu.visit_expr(body.value);\n             lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n         }\n     }\n@@ -348,7 +348,7 @@ fn lint_for_missing_headers<'tcx>(\n                 if let Some(future) = cx.tcx.lang_items().future_trait();\n                 let typeck = cx.tcx.typeck_body(body_id);\n                 let body = cx.tcx.hir().body(body_id);\n-                let ret_ty = typeck.expr_ty(&body.value);\n+                let ret_ty = typeck.expr_ty(body.value);\n                 if implements_trait(cx, ret_ty, future, &[]);\n                 if let ty::Opaque(_, subs) = ret_ty.kind();\n                 if let Some(gen) = subs.types().next();\n@@ -828,7 +828,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n \n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n             if is_type_diagnostic_item(self.cx, receiver_ty, sym::Option)\n                 || is_type_diagnostic_item(self.cx, receiver_ty, sym::Result)\n             {"}, {"sha": "e70df3f53c75de24d99388251cc906c4b444987c", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -245,8 +245,8 @@ fn try_parse_contains<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Optio\n     match expr.kind {\n         ExprKind::MethodCall(\n             _,\n+            map,\n             [\n-                map,\n                 Expr {\n                     kind: ExprKind::AddrOf(_, _, key),\n                     span: key_span,\n@@ -280,7 +280,7 @@ struct InsertExpr<'tcx> {\n     value: &'tcx Expr<'tcx>,\n }\n fn try_parse_insert<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<InsertExpr<'tcx>> {\n-    if let ExprKind::MethodCall(_, [map, key, value], _) = expr.kind {\n+    if let ExprKind::MethodCall(_, map, [key, value], _) = expr.kind {\n         let id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n         if match_def_path(cx, id, &paths::BTREEMAP_INSERT) || match_def_path(cx, id, &paths::HASHMAP_INSERT) {\n             Some(InsertExpr { map, key, value })"}, {"sha": "53bc617a4f5b78929510599109619bcb29753018", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -83,7 +83,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n         };\n         if body.value.span.from_expansion() {\n             if body.params.is_empty() {\n-                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, &body.value) {\n+                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, body.value) {\n                     // replace `|| vec![]` with `Vec::new`\n                     span_lint_and_sugg(\n                         cx,\n@@ -103,10 +103,10 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n         let closure_ty = cx.typeck_results().expr_ty(expr);\n \n         if_chain!(\n-            if !is_adjusted(cx, &body.value);\n+            if !is_adjusted(cx, body.value);\n             if let ExprKind::Call(callee, args) = body.value.kind;\n             if let ExprKind::Path(_) = callee.kind;\n-            if check_inputs(cx, body.params, args);\n+            if check_inputs(cx, body.params, None, args);\n             let callee_ty = cx.typeck_results().expr_ty_adjusted(callee);\n             let call_ty = cx.typeck_results().type_dependent_def_id(body.value.hir_id)\n                 .map_or(callee_ty, |id| cx.tcx.type_of(id));\n@@ -145,9 +145,9 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n         );\n \n         if_chain!(\n-            if !is_adjusted(cx, &body.value);\n-            if let ExprKind::MethodCall(path, args, _) = body.value.kind;\n-            if check_inputs(cx, body.params, args);\n+            if !is_adjusted(cx, body.value);\n+            if let ExprKind::MethodCall(path, receiver, args, _) = body.value.kind;\n+            if check_inputs(cx, body.params, Some(receiver), args);\n             let method_def_id = cx.typeck_results().type_dependent_def_id(body.value.hir_id).unwrap();\n             let substs = cx.typeck_results().node_substs(body.value.hir_id);\n             let call_ty = cx.tcx.bound_type_of(method_def_id).subst(cx.tcx, substs);\n@@ -167,12 +167,17 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n     }\n }\n \n-fn check_inputs(cx: &LateContext<'_>, params: &[Param<'_>], call_args: &[Expr<'_>]) -> bool {\n-    if params.len() != call_args.len() {\n+fn check_inputs(\n+    cx: &LateContext<'_>,\n+    params: &[Param<'_>],\n+    receiver: Option<&Expr<'_>>,\n+    call_args: &[Expr<'_>],\n+) -> bool {\n+    if receiver.map_or(params.len() != call_args.len(), |_| params.len() != call_args.len() + 1) {\n         return false;\n     }\n     let binding_modes = cx.typeck_results().pat_binding_modes();\n-    std::iter::zip(params, call_args).all(|(param, arg)| {\n+    let check_inputs = |param: &Param<'_>, arg| {\n         match param.pat.kind {\n             PatKind::Binding(_, id, ..) if path_to_local_id(arg, id) => {},\n             _ => return false,\n@@ -200,7 +205,8 @@ fn check_inputs(cx: &LateContext<'_>, params: &[Param<'_>], call_args: &[Expr<'_\n             },\n             _ => false,\n         }\n-    })\n+    };\n+    std::iter::zip(params, receiver.into_iter().chain(call_args.iter())).all(|(param, arg)| check_inputs(param, arg))\n }\n \n fn check_sig<'tcx>(cx: &LateContext<'tcx>, closure_ty: Ty<'tcx>, call_ty: Ty<'tcx>) -> bool {"}, {"sha": "b9ed4af02190b07c4eb7c5a409ab890be52e907b", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -45,10 +45,10 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprKind::MethodCall(unwrap_fun, [write_call], _) = expr.kind;\n+            if let ExprKind::MethodCall(unwrap_fun, write_call, [], _) = expr.kind;\n             if unwrap_fun.ident.name == sym::unwrap;\n             // match call to write_fmt\n-            if let ExprKind::MethodCall(write_fun, [write_recv, write_arg], _) = look_in_block(cx, &write_call.kind);\n+            if let ExprKind::MethodCall(write_fun, write_recv, [write_arg], _) = look_in_block(cx, &write_call.kind);\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n             if let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {\n@@ -128,7 +128,7 @@ fn look_in_block<'tcx, 'hir>(cx: &LateContext<'tcx>, kind: &'tcx ExprKind<'hir>)\n         if let Some(Node::Pat(res_pat)) = cx.tcx.hir().find(expr_res);\n \n         // Find id of the local we found in the block\n-        if let PatKind::Binding(BindingAnnotation::Unannotated, local_hir_id, _ident, None) = local.pat.kind;\n+        if let PatKind::Binding(BindingAnnotation::NONE, local_hir_id, _ident, None) = local.pat.kind;\n \n         // If those two are the same hir id\n         if res_pat.hir_id == local_hir_id;"}, {"sha": "1f69f34a229df4952c4d3b6f5932d6b5b4450703", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -84,7 +84,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n \n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-                let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+                let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n                 if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n                     || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n                 {\n@@ -110,7 +110,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n                     typeck_results: cx.tcx.typeck(impl_item.id.def_id),\n                     result: Vec::new(),\n                 };\n-                fpu.visit_expr(&body.value);\n+                fpu.visit_expr(body.value);\n \n                 // if we've found one, lint\n                 if !fpu.result.is_empty() {"}, {"sha": "ba53a9678801ce2fbfa407a5988356a2ef081a4e", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -164,30 +164,30 @@ fn prepare_receiver_sugg<'a>(cx: &LateContext<'_>, mut expr: &'a Expr<'a>) -> Su\n     suggestion.maybe_par()\n }\n \n-fn check_log_base(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some(method) = get_specialized_log_method(cx, &args[1]) {\n+fn check_log_base(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let Some(method) = get_specialized_log_method(cx, &args[0]) {\n         span_lint_and_sugg(\n             cx,\n             SUBOPTIMAL_FLOPS,\n             expr.span,\n             \"logarithm for bases 2, 10 and e can be computed more accurately\",\n             \"consider using\",\n-            format!(\"{}.{}()\", Sugg::hir(cx, &args[0], \"..\").maybe_par(), method),\n+            format!(\"{}.{}()\", Sugg::hir(cx, receiver, \"..\").maybe_par(), method),\n             Applicability::MachineApplicable,\n         );\n     }\n }\n \n // TODO: Lint expressions of the form `(x + y).ln()` where y > 1 and\n // suggest usage of `(x + (y - 1)).ln_1p()` instead\n-fn check_ln1p(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+fn check_ln1p(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>) {\n     if let ExprKind::Binary(\n         Spanned {\n             node: BinOpKind::Add, ..\n         },\n         lhs,\n         rhs,\n-    ) = &args[0].kind\n+    ) = receiver.kind\n     {\n         let recv = match (\n             constant(cx, cx.typeck_results(), lhs),\n@@ -235,9 +235,9 @@ fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n     }\n }\n \n-fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n     // Check receiver\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), receiver) {\n         if let Some(method) = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n             Some(\"exp\")\n         } else if F32(2.0) == value || F64(2.0) == value {\n@@ -251,33 +251,33 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                 expr.span,\n                 \"exponent for bases 2 and e can be computed more accurately\",\n                 \"consider using\",\n-                format!(\"{}.{}()\", prepare_receiver_sugg(cx, &args[1]), method),\n+                format!(\"{}.{}()\", prepare_receiver_sugg(cx, &args[0]), method),\n                 Applicability::MachineApplicable,\n             );\n         }\n     }\n \n     // Check argument\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[1]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n         let (lint, help, suggestion) = if F32(1.0 / 2.0) == value || F64(1.0 / 2.0) == value {\n             (\n                 SUBOPTIMAL_FLOPS,\n                 \"square-root of a number can be computed more efficiently and accurately\",\n-                format!(\"{}.sqrt()\", Sugg::hir(cx, &args[0], \"..\").maybe_par()),\n+                format!(\"{}.sqrt()\", Sugg::hir(cx, receiver, \"..\").maybe_par()),\n             )\n         } else if F32(1.0 / 3.0) == value || F64(1.0 / 3.0) == value {\n             (\n                 IMPRECISE_FLOPS,\n                 \"cube-root of a number can be computed more accurately\",\n-                format!(\"{}.cbrt()\", Sugg::hir(cx, &args[0], \"..\").maybe_par()),\n+                format!(\"{}.cbrt()\", Sugg::hir(cx, receiver, \"..\").maybe_par()),\n             )\n         } else if let Some(exponent) = get_integer_from_float_constant(&value) {\n             (\n                 SUBOPTIMAL_FLOPS,\n                 \"exponentiation with integer powers can be computed more efficiently\",\n                 format!(\n                     \"{}.powi({})\",\n-                    Sugg::hir(cx, &args[0], \"..\").maybe_par(),\n+                    Sugg::hir(cx, receiver, \"..\").maybe_par(),\n                     numeric_literal::format(&exponent.to_string(), None, false)\n                 ),\n             )\n@@ -297,13 +297,14 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     }\n }\n \n-fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[1]) {\n+fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n         if value == Int(2) {\n             if let Some(parent) = get_parent_expr(cx, expr) {\n                 if let Some(grandparent) = get_parent_expr(cx, parent) {\n-                    if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, args, _) = grandparent.kind {\n-                        if method_name.as_str() == \"sqrt\" && detect_hypot(cx, args).is_some() {\n+                    if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, receiver, ..) = grandparent.kind\n+                    {\n+                        if method_name.as_str() == \"sqrt\" && detect_hypot(cx, receiver).is_some() {\n                             return;\n                         }\n                     }\n@@ -327,8 +328,8 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                         \"consider using\",\n                         format!(\n                             \"{}.mul_add({}, {})\",\n-                            Sugg::hir(cx, &args[0], \"..\").maybe_par(),\n-                            Sugg::hir(cx, &args[0], \"..\"),\n+                            Sugg::hir(cx, receiver, \"..\").maybe_par(),\n+                            Sugg::hir(cx, receiver, \"..\"),\n                             Sugg::hir(cx, other_addend, \"..\"),\n                         ),\n                         Applicability::MachineApplicable,\n@@ -339,14 +340,14 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     }\n }\n \n-fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n+fn detect_hypot(cx: &LateContext<'_>, receiver: &Expr<'_>) -> Option<String> {\n     if let ExprKind::Binary(\n         Spanned {\n             node: BinOpKind::Add, ..\n         },\n         add_lhs,\n         add_rhs,\n-    ) = args[0].kind\n+    ) = receiver.kind\n     {\n         // check if expression of the form x * x + y * y\n         if_chain! {\n@@ -363,12 +364,12 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n         if_chain! {\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: lmethod_name, .. },\n-                [largs_0, largs_1, ..],\n+                largs_0, [largs_1, ..],\n                 _\n             ) = &add_lhs.kind;\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: rmethod_name, .. },\n-                [rargs_0, rargs_1, ..],\n+                rargs_0, [rargs_1, ..],\n                 _\n             ) = &add_rhs.kind;\n             if lmethod_name.as_str() == \"powi\" && rmethod_name.as_str() == \"powi\";\n@@ -384,8 +385,8 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n     None\n }\n \n-fn check_hypot(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some(message) = detect_hypot(cx, args) {\n+fn check_hypot(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>) {\n+    if let Some(message) = detect_hypot(cx, receiver) {\n         span_lint_and_sugg(\n             cx,\n             IMPRECISE_FLOPS,\n@@ -406,7 +407,7 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if cx.typeck_results().expr_ty(lhs).is_floating_point();\n         if let Some((value, _)) = constant(cx, cx.typeck_results(), rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n-        if let ExprKind::MethodCall(path, [self_arg, ..], _) = &lhs.kind;\n+        if let ExprKind::MethodCall(path, self_arg, ..) = &lhs.kind;\n         if cx.typeck_results().expr_ty(self_arg).is_floating_point();\n         if path.ident.name.as_str() == \"exp\";\n         then {\n@@ -450,8 +451,8 @@ fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     ) = &expr.kind\n     {\n         if let Some(parent) = get_parent_expr(cx, expr) {\n-            if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, args, _) = parent.kind {\n-                if method_name.as_str() == \"sqrt\" && detect_hypot(cx, args).is_some() {\n+            if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, receiver, ..) = parent.kind {\n+                if method_name.as_str() == \"sqrt\" && detect_hypot(cx, receiver).is_some() {\n                     return;\n                 }\n             }\n@@ -586,14 +587,14 @@ fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n fn are_same_base_logs(cx: &LateContext<'_>, expr_a: &Expr<'_>, expr_b: &Expr<'_>) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, args_a, _) = expr_a.kind;\n-        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, args_b, _) = expr_b.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, _, args_a, _) = expr_a.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, _, args_b, _) = expr_b.kind;\n         then {\n             return method_name_a.as_str() == method_name_b.as_str() &&\n                 args_a.len() == args_b.len() &&\n                 (\n                     [\"ln\", \"log2\", \"log10\"].contains(&method_name_a.as_str()) ||\n-                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && eq_expr_value(cx, &args_a[1], &args_b[1])\n+                    method_name_a.as_str() == \"log\" && args_a.len() == 1 && eq_expr_value(cx, &args_a[0], &args_b[0])\n                 );\n         }\n     }\n@@ -612,8 +613,8 @@ fn check_log_division(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             rhs,\n         ) = &expr.kind;\n         if are_same_base_logs(cx, lhs, rhs);\n-        if let ExprKind::MethodCall(_, [largs_self, ..], _) = &lhs.kind;\n-        if let ExprKind::MethodCall(_, [rargs_self, ..], _) = &rhs.kind;\n+        if let ExprKind::MethodCall(_, largs_self, ..) = &lhs.kind;\n+        if let ExprKind::MethodCall(_, rargs_self, ..) = &rhs.kind;\n         then {\n             span_lint_and_sugg(\n                 cx,\n@@ -711,16 +712,16 @@ impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n             return;\n         }\n \n-        if let ExprKind::MethodCall(path, args, _) = &expr.kind {\n-            let recv_ty = cx.typeck_results().expr_ty(&args[0]);\n+        if let ExprKind::MethodCall(path, receiver, args, _) = &expr.kind {\n+            let recv_ty = cx.typeck_results().expr_ty(receiver);\n \n             if recv_ty.is_floating_point() {\n                 match path.ident.name.as_str() {\n-                    \"ln\" => check_ln1p(cx, expr, args),\n-                    \"log\" => check_log_base(cx, expr, args),\n-                    \"powf\" => check_powf(cx, expr, args),\n-                    \"powi\" => check_powi(cx, expr, args),\n-                    \"sqrt\" => check_hypot(cx, expr, args),\n+                    \"ln\" => check_ln1p(cx, expr, receiver),\n+                    \"log\" => check_log_base(cx, expr, receiver, args),\n+                    \"powf\" => check_powf(cx, expr, receiver, args),\n+                    \"powi\" => check_powi(cx, expr, receiver, args),\n+                    \"sqrt\" => check_hypot(cx, expr, receiver),\n                     _ => {},\n                 }\n             }"}, {"sha": "97024be16fa474c35586618d0af06ebcf587eb0a", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -126,7 +126,7 @@ fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symb\n fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Expr<'_>) {\n     if_chain! {\n         if !value.span.from_expansion();\n-        if let ExprKind::MethodCall(_, [receiver], _) = value.kind;\n+        if let ExprKind::MethodCall(_, receiver, [], _) = value.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(value.hir_id);\n         if is_diag_trait_item(cx, method_def_id, sym::ToString);\n         let receiver_ty = cx.typeck_results().expr_ty(receiver);"}, {"sha": "b628fd9f758143fa537dae4112d95a032696d5fb", "filename": "clippy_lints/src/format_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fformat_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fformat_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_impl.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> LateLintPass<'tcx> for FormatImpl {\n fn check_to_string_in_display(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         // Get the hir_id of the object we are calling the method on\n-        if let ExprKind::MethodCall(path, [ref self_arg, ..], _) = expr.kind;\n+        if let ExprKind::MethodCall(path, self_arg, ..) = expr.kind;\n         // Is the method to_string() ?\n         if path.ident.name == sym::to_string;\n         // Is the method a part of the ToString trait? (i.e. not to_string() implemented"}, {"sha": "9b9f1872bfc1d2cf5b42a86253b05ccb2db63927", "filename": "clippy_lints/src/format_push_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fformat_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fformat_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_push_string.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -54,7 +54,7 @@ fn is_format(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n impl<'tcx> LateLintPass<'tcx> for FormatPushString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let arg = match expr.kind {\n-            ExprKind::MethodCall(_, [_, arg], _) => {\n+            ExprKind::MethodCall(_, _, [arg], _) => {\n                 if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) &&\n                 match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n                     arg"}, {"sha": "00a4937763eb5ad780c10c278f22531ec2ade832", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n             return;\n         }\n         match expr.kind {\n-            Call(_, args) | MethodCall(_, args, _) => {\n+            Call(_, args) => {\n                 let mut tys = DefIdSet::default();\n                 for arg in args {\n                     if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n@@ -230,6 +230,24 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n                     tys.clear();\n                 }\n             },\n+            MethodCall(_, receiver, args, _) => {\n+                let mut tys = DefIdSet::default();\n+                for arg in std::iter::once(receiver).chain(args.iter()) {\n+                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                        && is_mutable_ty(\n+                            self.cx,\n+                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n+                            arg.span,\n+                            &mut tys,\n+                        )\n+                        && is_mutated_static(arg)\n+                    {\n+                        self.mutates_static = true;\n+                        return;\n+                    }\n+                    tys.clear();\n+                }\n+            },\n             Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target) => {\n                 self.mutates_static |= is_mutated_static(target);\n             },\n@@ -254,6 +272,6 @@ fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bo\n         cx,\n         mutates_static: false,\n     };\n-    intravisit::walk_expr(&mut v, &body.value);\n+    intravisit::walk_expr(&mut v, body.value);\n     v.mutates_static\n }"}, {"sha": "3bbfa52e810392c98cadd63e7cea7e32dd30ec3e", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -88,11 +88,12 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprKind::MethodCall(_, args, _) => {\n+            hir::ExprKind::MethodCall(_, receiver, args, _) => {\n                 let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n                 let base_type = self.cx.tcx.type_of(def_id);\n \n                 if type_is_unsafe_function(self.cx, base_type) {\n+                    self.check_arg(receiver);\n                     for arg in args {\n                         self.check_arg(arg);\n                     }"}, {"sha": "9ea8c494cfcdab4a0fd71e5dbe80433fd4e2f8b1", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -129,7 +129,7 @@ impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n \n fn is_mutex_lock_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n-        if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n+        if let ExprKind::MethodCall(path, self_arg, ..) = &expr.kind;\n         if path.ident.as_str() == \"lock\";\n         let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n         if is_type_diagnostic_item(cx, ty, sym::Mutex);"}, {"sha": "feec8ec2e23f8f802c2b249f0931427eea795162", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -232,7 +232,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitReturn {\n             return;\n         }\n \n-        let res_ty = cx.typeck_results().expr_ty(&body.value);\n+        let res_ty = cx.typeck_results().expr_ty(body.value);\n         if res_ty.is_unit() || res_ty.is_never() {\n             return;\n         }\n@@ -243,7 +243,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitReturn {\n                 None => return,\n             }\n         } else {\n-            &body.value\n+            body.value\n         };\n         lint_implicit_returns(cx, expr, expr.span.ctxt(), None);\n     }"}, {"sha": "0dd7f5bf000d20d69192bf6dfb5251380366251d", "filename": "clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -95,12 +95,14 @@ fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxIndexMap<hir\n     let mut removed_pat: FxHashSet<hir::HirId> = FxHashSet::default();\n     let mut slices: FxIndexMap<hir::HirId, SliceLintInformation> = FxIndexMap::default();\n     pat.walk_always(|pat| {\n-        if let hir::PatKind::Binding(binding, value_hir_id, ident, sub_pat) = pat.kind {\n-            // We'll just ignore mut and ref mut for simplicity sake right now\n-            if let hir::BindingAnnotation::Mutable | hir::BindingAnnotation::RefMut = binding {\n-                return;\n-            }\n-\n+        // We'll just ignore mut and ref mut for simplicity sake right now\n+        if let hir::PatKind::Binding(\n+            hir::BindingAnnotation(by_ref, hir::Mutability::Not),\n+            value_hir_id,\n+            ident,\n+            sub_pat,\n+        ) = pat.kind\n+        {\n             // This block catches bindings with sub patterns. It would be hard to build a correct suggestion\n             // for them and it's likely that the user knows what they are doing in such a case.\n             if removed_pat.contains(&value_hir_id) {\n@@ -116,7 +118,7 @@ fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxIndexMap<hir\n             if let ty::Slice(inner_ty) | ty::Array(inner_ty, _) = bound_ty.peel_refs().kind() {\n                 // The values need to use the `ref` keyword if they can't be copied.\n                 // This will need to be adjusted if the lint want to support mutable access in the future\n-                let src_is_ref = bound_ty.is_ref() && binding != hir::BindingAnnotation::Ref;\n+                let src_is_ref = bound_ty.is_ref() && by_ref != hir::ByRef::Yes;\n                 let needs_ref = !(src_is_ref || is_copy(cx, *inner_ty));\n \n                 let slice_info = slices"}, {"sha": "8c2c96fa105af251ec8796c5e76d122d89394694", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -123,45 +123,45 @@ use self::Heuristic::{All, Always, Any, First};\n /// is an upper bound, e.g., some methods can return a possibly\n /// infinite iterator at worst, e.g., `take_while`.\n const HEURISTICS: [(&str, usize, Heuristic, Finiteness); 19] = [\n-    (\"zip\", 2, All, Infinite),\n-    (\"chain\", 2, Any, Infinite),\n-    (\"cycle\", 1, Always, Infinite),\n-    (\"map\", 2, First, Infinite),\n-    (\"by_ref\", 1, First, Infinite),\n-    (\"cloned\", 1, First, Infinite),\n-    (\"rev\", 1, First, Infinite),\n-    (\"inspect\", 1, First, Infinite),\n-    (\"enumerate\", 1, First, Infinite),\n-    (\"peekable\", 2, First, Infinite),\n-    (\"fuse\", 1, First, Infinite),\n-    (\"skip\", 2, First, Infinite),\n-    (\"skip_while\", 1, First, Infinite),\n-    (\"filter\", 2, First, Infinite),\n-    (\"filter_map\", 2, First, Infinite),\n-    (\"flat_map\", 2, First, Infinite),\n-    (\"unzip\", 1, First, Infinite),\n-    (\"take_while\", 2, First, MaybeInfinite),\n-    (\"scan\", 3, First, MaybeInfinite),\n+    (\"zip\", 1, All, Infinite),\n+    (\"chain\", 1, Any, Infinite),\n+    (\"cycle\", 0, Always, Infinite),\n+    (\"map\", 1, First, Infinite),\n+    (\"by_ref\", 0, First, Infinite),\n+    (\"cloned\", 0, First, Infinite),\n+    (\"rev\", 0, First, Infinite),\n+    (\"inspect\", 0, First, Infinite),\n+    (\"enumerate\", 0, First, Infinite),\n+    (\"peekable\", 1, First, Infinite),\n+    (\"fuse\", 0, First, Infinite),\n+    (\"skip\", 1, First, Infinite),\n+    (\"skip_while\", 0, First, Infinite),\n+    (\"filter\", 1, First, Infinite),\n+    (\"filter_map\", 1, First, Infinite),\n+    (\"flat_map\", 1, First, Infinite),\n+    (\"unzip\", 0, First, Infinite),\n+    (\"take_while\", 1, First, MaybeInfinite),\n+    (\"scan\", 2, First, MaybeInfinite),\n ];\n \n fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(method, args, _) => {\n+        ExprKind::MethodCall(method, receiver, args, _) => {\n             for &(name, len, heuristic, cap) in &HEURISTICS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n                     return (match heuristic {\n                         Always => Infinite,\n-                        First => is_infinite(cx, &args[0]),\n-                        Any => is_infinite(cx, &args[0]).or(is_infinite(cx, &args[1])),\n-                        All => is_infinite(cx, &args[0]).and(is_infinite(cx, &args[1])),\n+                        First => is_infinite(cx, receiver),\n+                        Any => is_infinite(cx, receiver).or(is_infinite(cx, &args[0])),\n+                        All => is_infinite(cx, receiver).and(is_infinite(cx, &args[0])),\n                     })\n                     .and(cap);\n                 }\n             }\n-            if method.ident.name == sym!(flat_map) && args.len() == 2 {\n-                if let ExprKind::Closure(&Closure { body, .. }) = args[1].kind {\n+            if method.ident.name == sym!(flat_map) && args.len() == 1 {\n+                if let ExprKind::Closure(&Closure { body, .. }) = args[0].kind {\n                     let body = cx.tcx.hir().body(body);\n-                    return is_infinite(cx, &body.value);\n+                    return is_infinite(cx, body.value);\n                 }\n             }\n             Finite\n@@ -179,29 +179,29 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n /// the names and argument lengths of methods that *may* exhaust their\n /// iterators\n const POSSIBLY_COMPLETING_METHODS: [(&str, usize); 6] = [\n-    (\"find\", 2),\n-    (\"rfind\", 2),\n-    (\"position\", 2),\n-    (\"rposition\", 2),\n-    (\"any\", 2),\n-    (\"all\", 2),\n+    (\"find\", 1),\n+    (\"rfind\", 1),\n+    (\"position\", 1),\n+    (\"rposition\", 1),\n+    (\"any\", 1),\n+    (\"all\", 1),\n ];\n \n /// the names and argument lengths of methods that *always* exhaust\n /// their iterators\n const COMPLETING_METHODS: [(&str, usize); 12] = [\n-    (\"count\", 1),\n-    (\"fold\", 3),\n-    (\"for_each\", 2),\n-    (\"partition\", 2),\n-    (\"max\", 1),\n-    (\"max_by\", 2),\n-    (\"max_by_key\", 2),\n-    (\"min\", 1),\n-    (\"min_by\", 2),\n-    (\"min_by_key\", 2),\n-    (\"sum\", 1),\n-    (\"product\", 1),\n+    (\"count\", 0),\n+    (\"fold\", 2),\n+    (\"for_each\", 1),\n+    (\"partition\", 1),\n+    (\"max\", 0),\n+    (\"max_by\", 1),\n+    (\"max_by_key\", 1),\n+    (\"min\", 0),\n+    (\"min_by\", 1),\n+    (\"min_by_key\", 1),\n+    (\"sum\", 0),\n+    (\"product\", 0),\n ];\n \n /// the paths of types that are known to be infinitely allocating\n@@ -218,34 +218,34 @@ const INFINITE_COLLECTORS: &[Symbol] = &[\n \n fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(method, args, _) => {\n+        ExprKind::MethodCall(method, receiver, args, _) => {\n             for &(name, len) in &COMPLETING_METHODS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n-                    return is_infinite(cx, &args[0]);\n+                    return is_infinite(cx, receiver);\n                 }\n             }\n             for &(name, len) in &POSSIBLY_COMPLETING_METHODS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n-                    return MaybeInfinite.and(is_infinite(cx, &args[0]));\n+                    return MaybeInfinite.and(is_infinite(cx, receiver));\n                 }\n             }\n-            if method.ident.name == sym!(last) && args.len() == 1 {\n+            if method.ident.name == sym!(last) && args.is_empty() {\n                 let not_double_ended = cx\n                     .tcx\n                     .get_diagnostic_item(sym::DoubleEndedIterator)\n                     .map_or(false, |id| {\n-                        !implements_trait(cx, cx.typeck_results().expr_ty(&args[0]), id, &[])\n+                        !implements_trait(cx, cx.typeck_results().expr_ty(receiver), id, &[])\n                     });\n                 if not_double_ended {\n-                    return is_infinite(cx, &args[0]);\n+                    return is_infinite(cx, receiver);\n                 }\n             } else if method.ident.name == sym!(collect) {\n                 let ty = cx.typeck_results().expr_ty(expr);\n                 if INFINITE_COLLECTORS\n                     .iter()\n                     .any(|diag_item| is_type_diagnostic_item(cx, ty, *diag_item))\n                 {\n-                    return is_infinite(cx, &args[0]);\n+                    return is_infinite(cx, receiver);\n                 }\n             }\n         },"}, {"sha": "7ae8ef830faea952e65ef77b77e83dcffcbcc2f1", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -370,24 +370,37 @@ fn check_for_is_empty<'tcx>(\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(method_path, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n+    if let (&ExprKind::MethodCall(method_path, receiver, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind)\n+    {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {\n                 return;\n             }\n         }\n \n-        check_len(cx, span, method_path.ident.name, args, &lit.node, op, compare_to);\n+        check_len(\n+            cx,\n+            span,\n+            method_path.ident.name,\n+            receiver,\n+            args,\n+            &lit.node,\n+            op,\n+            compare_to,\n+        );\n     } else {\n         check_empty_expr(cx, span, method, lit, op);\n     }\n }\n \n+// FIXME(flip1995): Figure out how to reduce the number of arguments\n+#[allow(clippy::too_many_arguments)]\n fn check_len(\n     cx: &LateContext<'_>,\n     span: Span,\n     method_name: Symbol,\n+    receiver: &Expr<'_>,\n     args: &[Expr<'_>],\n     lit: &LitKind,\n     op: &str,\n@@ -399,7 +412,7 @@ fn check_len(\n             return;\n         }\n \n-        if method_name == sym::len && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+        if method_name == sym::len && args.is_empty() && has_is_empty(cx, receiver) {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n@@ -410,7 +423,7 @@ fn check_len(\n                 format!(\n                     \"{}{}.is_empty()\",\n                     op,\n-                    snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability)\n+                    snippet_with_applicability(cx, receiver.span, \"_\", &mut applicability)\n                 ),\n                 applicability,\n             );"}, {"sha": "10fc0f4018efdd31c990809aa7a0fca44925fa40", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::{path_to_local_id, visitors::is_local_used};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::BindingAnnotation;\n+use rustc_hir::{BindingAnnotation, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -98,7 +98,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                     };\n \n                     let mutability = match mode {\n-                        BindingAnnotation::RefMut | BindingAnnotation::Mutable => \"<mut> \",\n+                        BindingAnnotation(_, Mutability::Mut) => \"<mut> \",\n                         _ => \"\",\n                     };\n "}, {"sha": "ec96999896e289752ff4f9058a96323104304eff", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -4,6 +4,7 @@\n #![feature(control_flow_enum)]\n #![feature(drain_filter)]\n #![feature(iter_intersperse)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(lint_reasons)]\n #![feature(never_type)]"}, {"sha": "d9cf92a9d5ba1115f6cac46a8bfa680c44e17886", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -276,7 +276,7 @@ fn could_use_elision<'tcx>(\n         let mut checker = BodyLifetimeChecker {\n             lifetimes_used_in_body: false,\n         };\n-        checker.visit_expr(&body.value);\n+        checker.visit_expr(body.value);\n         if checker.lifetimes_used_in_body {\n             return false;\n         }"}, {"sha": "09b2376d5c04a6d68ad26d1d3abaaa8002f7d4db", "filename": "clippy_lints/src/loops/manual_find.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -106,7 +106,7 @@ fn get_binding(pat: &Pat<'_>) -> Option<HirId> {\n             hir_id = None;\n             return;\n         }\n-        if let BindingAnnotation::Unannotated = annotation {\n+        if let BindingAnnotation::NONE = annotation {\n             hir_id = Some(id);\n         }\n     });"}, {"sha": "3fc569af89ecb4f386ba4a5b973494b4e31b9279", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -119,7 +119,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n \n     let print_limit = |end: &Expr<'_>, end_str: &str, base: &Expr<'_>, sugg: MinifyingSugg<'static>| {\n         if_chain! {\n-            if let ExprKind::MethodCall(method, [recv], _) = end.kind;\n+            if let ExprKind::MethodCall(method, recv, [], _) = end.kind;\n             if method.ident.name == sym::len;\n             if path_to_local(recv) == path_to_local(base);\n             then {\n@@ -341,7 +341,7 @@ fn get_slice_like_element_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Opti\n \n fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, [arg], _) = expr.kind;\n+        if let ExprKind::MethodCall(method, arg, [], _) = expr.kind;\n         if method.ident.name == sym::clone;\n         then { arg } else { expr }\n     }"}, {"sha": "8412875b11b7ecbfae00e57166f5712f5a61307c", "filename": "clippy_lints/src/loops/missing_spin_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -33,7 +33,7 @@ fn unpack_cond<'tcx>(cond: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, body: &'tcx Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Block(Block { stmts: [], expr: None, ..}, _) = body.kind;\n-        if let ExprKind::MethodCall(method, [callee, ..], _) = unpack_cond(cond).kind;\n+        if let ExprKind::MethodCall(method, callee, ..) = unpack_cond(cond).kind;\n         if [sym::load, sym::compare_exchange, sym::compare_exchange_weak].contains(&method.ident.name);\n         if let ty::Adt(def, _substs) = cx.typeck_results().expr_ty(callee).kind();\n         if cx.tcx.is_diagnostic_item(sym::AtomicBool, def.did());"}, {"sha": "74f3bda9f43efb0fe0749d4e069640cc634bba4e", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -742,7 +742,7 @@ fn check_for_loop<'tcx>(\n fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n \n-    if let ExprKind::MethodCall(method, [self_arg], _) = arg.kind {\n+    if let ExprKind::MethodCall(method, self_arg, [], _) = arg.kind {\n         let method_name = method.ident.as_str();\n         // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n         match method_name {"}, {"sha": "fce2d54639cbf22af7ae546a0153ec48793b7978", "filename": "clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -44,7 +44,7 @@ fn check_for_mutability(cx: &LateContext<'_>, bound: &Expr<'_>) -> Option<HirId>\n     if_chain! {\n         if let Some(hir_id) = path_to_local(bound);\n         if let Node::Pat(pat) = cx.tcx.hir().get(hir_id);\n-        if let PatKind::Binding(BindingAnnotation::Mutable, ..) = pat.kind;\n+        if let PatKind::Binding(BindingAnnotation::MUT, ..) = pat.kind;\n         then {\n             return Some(hir_id);\n         }"}, {"sha": "6e6faa79adc9e7df8e2d43df4efc1fe3e086bbcd", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -25,11 +25,11 @@ pub(super) fn check<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n }\n fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, args, _) = expr.kind;\n-        if let ExprKind::MethodCall(chain_method, _, _) = args[0].kind;\n-        if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n+        if let ExprKind::MethodCall(method, receiver, args, _) = expr.kind;\n+        if let ExprKind::MethodCall(chain_method, ..) = receiver.kind;\n+        if chain_method.ident.name == sym!(collect) && is_trait_method(cx, receiver, sym::Iterator);\n         then {\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            let ty = cx.typeck_results().expr_ty(receiver);\n             let mut applicability = Applicability::MaybeIncorrect;\n             let is_empty_sugg = \"next().is_none()\".to_string();\n             let method_name = method.ident.name.as_str();\n@@ -41,7 +41,7 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n                     \"len\" => \"count()\".to_string(),\n                     \"is_empty\" => is_empty_sugg,\n                     \"contains\" => {\n-                        let contains_arg = snippet_with_applicability(cx, args[1].span, \"??\", &mut applicability);\n+                        let contains_arg = snippet_with_applicability(cx, args[0].span, \"??\", &mut applicability);\n                         let (arg, pred) = contains_arg\n                             .strip_prefix('&')\n                             .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n@@ -80,7 +80,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                 if let StmtKind::Local(local) = stmt.kind;\n                 if let PatKind::Binding(_, id, ..) = local.pat.kind;\n                 if let Some(init_expr) = local.init;\n-                if let ExprKind::MethodCall(method_name, &[ref iter_source], ..) = init_expr.kind;\n+                if let ExprKind::MethodCall(method_name, iter_source, [], ..) = init_expr.kind;\n                 if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n                 let ty = cx.typeck_results().expr_ty(init_expr);\n                 if is_type_diagnostic_item(cx, ty, sym::Vec) ||\n@@ -203,7 +203,7 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n-        if let ExprKind::MethodCall(method_name, [recv, args @ ..], _) = &expr.kind {\n+        if let ExprKind::MethodCall(method_name, recv, [args @ ..], _) = &expr.kind {\n             if method_name.ident.name == sym!(collect) && is_trait_method(self.cx, expr, sym::Iterator) {\n                 self.current_mutably_captured_ids = get_captured_ids(self.cx, self.cx.typeck_results().expr_ty(recv));\n                 self.visit_expr(recv);"}, {"sha": "8ab640051b635fb3da6e6122b6e94359f049a64d", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -188,7 +188,7 @@ pub(super) fn check<'tcx>(\n \n fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, [recv], _) = expr.kind;\n+        if let ExprKind::MethodCall(method, recv, [], _) = expr.kind;\n         if method.ident.name == sym::len;\n         if let ExprKind::Path(QPath::Resolved(_, path)) = recv.kind;\n         if path.segments.len() == 1;\n@@ -301,7 +301,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // a range index op\n-            if let ExprKind::MethodCall(meth, [args_0, args_1, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(meth, args_0, [args_1, ..], _) = &expr.kind;\n             if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n                 || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(args_1, args_0, expr);\n@@ -356,9 +356,12 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     self.visit_expr(expr);\n                 }\n             },\n-            ExprKind::MethodCall(_, args, _) => {\n+            ExprKind::MethodCall(_, receiver, args, _) => {\n                 let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n-                for (ty, expr) in iter::zip(self.cx.tcx.fn_sig(def_id).inputs().skip_binder(), args) {\n+                for (ty, expr) in iter::zip(\n+                    self.cx.tcx.fn_sig(def_id).inputs().skip_binder(),\n+                    std::iter::once(receiver).chain(args.iter()),\n+                ) {\n                     self.prefer_mutable = false;\n                     if let ty::Ref(_, _, mutbl) = *ty.kind() {\n                         if mutbl == Mutability::Mut {\n@@ -370,7 +373,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             },\n             ExprKind::Closure(&Closure { body, .. }) => {\n                 let body = self.cx.tcx.hir().body(body);\n-                self.visit_expr(&body.value);\n+                self.visit_expr(body.value);\n             },\n             _ => walk_expr(self, expr),\n         }"}, {"sha": "116e589cad6f3495d87ccccbf1fdf9e238b9c1da", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -120,8 +120,9 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Repeat(e, _)\n         | ExprKind::DropTemps(e) => never_loop_expr(e, main_loop_id),\n         ExprKind::Let(let_expr) => never_loop_expr(let_expr.init, main_loop_id),\n-        ExprKind::Array(es) | ExprKind::MethodCall(_, es, _) | ExprKind::Tup(es) => {\n-            never_loop_expr_all(&mut es.iter(), main_loop_id)\n+        ExprKind::Array(es) | ExprKind::Tup(es) => never_loop_expr_all(&mut es.iter(), main_loop_id),\n+        ExprKind::MethodCall(_, receiver, es, _) => {\n+            never_loop_expr_all(&mut std::iter::once(receiver).chain(es.iter()), main_loop_id)\n         },\n         ExprKind::Struct(_, fields, base) => {\n             let fields = never_loop_expr_all(&mut fields.iter().map(|f| f.expr), main_loop_id);\n@@ -178,9 +179,9 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n                     never_loop_expr(expr, main_loop_id)\n                 },\n-                InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter(), main_loop_id),\n+                InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter().copied(), main_loop_id),\n                 InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                    never_loop_expr_all(&mut once(in_expr).chain(out_expr.iter()), main_loop_id)\n+                    never_loop_expr_all(&mut once(*in_expr).chain(out_expr.iter().copied()), main_loop_id)\n                 },\n                 InlineAsmOperand::Const { .. }\n                 | InlineAsmOperand::SymFn { .. }"}, {"sha": "aeefe6e33fbe9a9405175f3dd1ba6a3af7ea3f53", "filename": "clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -7,7 +7,7 @@ use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Node, Pat, PatKind, Stmt, StmtKind};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Node, Pat, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n use std::iter::Iterator;\n@@ -65,7 +65,7 @@ pub(super) fn check<'tcx>(\n                             if_chain! {\n                                 if let Node::Pat(pat) = node;\n                                 if let PatKind::Binding(bind_ann, ..) = pat.kind;\n-                                if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n+                                if !matches!(bind_ann, BindingAnnotation(_, Mutability::Mut));\n                                 let parent_node = cx.tcx.hir().get_parent_node(hir_id);\n                                 if let Some(Node::Local(parent_let_expr)) = cx.tcx.hir().find(parent_node);\n                                 if let Some(init) = parent_let_expr.init;\n@@ -180,10 +180,9 @@ fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&\n     if_chain! {\n             // Extract method being called\n             if let StmtKind::Semi(semi_stmt) = &stmt.kind;\n-            if let ExprKind::MethodCall(path, args, _) = &semi_stmt.kind;\n+            if let ExprKind::MethodCall(path, self_expr, args, _) = &semi_stmt.kind;\n             // Figure out the parameters for the method call\n-            if let Some(self_expr) = args.get(0);\n-            if let Some(pushed_item) = args.get(1);\n+            if let Some(pushed_item) = args.get(0);\n             // Check that the method being called is push() on a Vec\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym::Vec);\n             if path.ident.name.as_str() == \"push\";"}, {"sha": "f4b47808dfaa362b8b7f9ce3d6625d87d07d8a48", "filename": "clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -35,32 +35,29 @@ pub(super) fn check<'tcx>(\n         ) => (arg, \"&mut \"),\n         ExprKind::MethodCall(\n             method,\n-            [\n-                Expr {\n-                    kind: ExprKind::Array([arg]),\n-                    ..\n-                },\n-            ],\n+            Expr {\n+                kind: ExprKind::Array([arg]),\n+                ..\n+            },\n+            [],\n             _,\n         ) if method.ident.name == rustc_span::sym::iter => (arg, \"&\"),\n         ExprKind::MethodCall(\n             method,\n-            [\n-                Expr {\n-                    kind: ExprKind::Array([arg]),\n-                    ..\n-                },\n-            ],\n+            Expr {\n+                kind: ExprKind::Array([arg]),\n+                ..\n+            },\n+            [],\n             _,\n         ) if method.ident.name.as_str() == \"iter_mut\" => (arg, \"&mut \"),\n         ExprKind::MethodCall(\n             method,\n-            [\n-                Expr {\n-                    kind: ExprKind::Array([arg]),\n-                    ..\n-                },\n-            ],\n+            Expr {\n+                kind: ExprKind::Array([arg]),\n+                ..\n+            },\n+            [],\n             _,\n         ) if method.ident.name == rustc_span::sym::into_iter => (arg, \"\"),\n         // Only check for arrays edition 2021 or later, as this case will trigger a compiler error otherwise."}, {"sha": "735d704a43cee343dcdb0ea76dea3a02566e6815", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -11,7 +11,14 @@ use rustc_lint::LateContext;\n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n     let (init, has_trailing_exprs) = match (loop_block.stmts, loop_block.expr) {\n         ([stmt, stmts @ ..], expr) => {\n-            if let StmtKind::Local(&Local { init: Some(e), .. }) | StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind {\n+            if let StmtKind::Local(&Local {\n+                init: Some(e),\n+                els: None,\n+                ..\n+            })\n+            | StmtKind::Semi(e)\n+            | StmtKind::Expr(e) = stmt.kind\n+            {\n                 (e, !stmts.is_empty() || expr.is_some())\n             } else {\n                 return;"}, {"sha": "deb21894f36a9709cc1cf20815a8c660c9638cd2", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let Res::Def(_, pat_did) = pat_path.res;\n         if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n         // check for call to `Iterator::next`\n-        if let ExprKind::MethodCall(method_name, [iter_expr], _) = let_expr.kind;\n+        if let ExprKind::MethodCall(method_name, iter_expr, [], _) = let_expr.kind;\n         if method_name.ident.name == sym::next;\n         if is_trait_method(cx, let_expr, sym::Iterator);\n         if let Some(iter_expr_struct) = try_parse_iter_expr(cx, iter_expr);\n@@ -356,7 +356,7 @@ fn needs_mutable_borrow(cx: &LateContext<'_>, iter_expr: &IterExpr, loop_expr: &\n             after_loop: false,\n             used_iter: false,\n         };\n-        v.visit_expr(&cx.tcx.hir().body(cx.enclosing_body.unwrap()).value);\n+        v.visit_expr(cx.tcx.hir().body(cx.enclosing_body.unwrap()).value);\n         v.used_iter\n     }\n }"}, {"sha": "6655c92b1da8da05a2f2f983bbe9fd8e28eaf439", "filename": "clippy_lints/src/manual_bits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmanual_bits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmanual_bits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_bits.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -105,7 +105,7 @@ fn get_size_of_ty<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<\n         if let Some(def_id) = cx.qpath_res(count_func_qpath, count_func.hir_id).opt_def_id();\n         if cx.tcx.is_diagnostic_item(sym::mem_size_of, def_id);\n         then {\n-            cx.typeck_results().node_substs(count_func.hir_id).types().next().map(|resolved_ty| (real_ty, resolved_ty))\n+            cx.typeck_results().node_substs(count_func.hir_id).types().next().map(|resolved_ty| (*real_ty, resolved_ty))\n         } else {\n             None\n         }\n@@ -134,7 +134,7 @@ fn create_sugg(cx: &LateContext<'_>, expr: &Expr<'_>, base_sugg: String) -> Stri\n fn is_ty_conversion(expr: &Expr<'_>) -> bool {\n     if let ExprKind::Cast(..) = expr.kind {\n         true\n-    } else if let ExprKind::MethodCall(path, [_], _) = expr.kind\n+    } else if let ExprKind::MethodCall(path, _, [], _) = expr.kind\n         && path.ident.name == rustc_span::sym::try_into\n     {\n         // This is only called for `usize` which implements `TryInto`. Therefore,"}, {"sha": "f28c37d3dca7e0d9d49417fe4c832197d70229cb", "filename": "clippy_lints/src/manual_retain.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_retain.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -66,9 +66,9 @@ impl<'tcx> LateLintPass<'tcx> for ManualRetain {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if let Some(parent_expr) = get_parent_expr(cx, expr)\n             && let Assign(left_expr, collect_expr, _) = &parent_expr.kind\n-            && let hir::ExprKind::MethodCall(seg, _, _) = &collect_expr.kind\n+            && let hir::ExprKind::MethodCall(seg, ..) = &collect_expr.kind\n             && seg.args.is_none()\n-            && let hir::ExprKind::MethodCall(_, [target_expr], _) = &collect_expr.kind\n+            && let hir::ExprKind::MethodCall(_, target_expr, [], _) = &collect_expr.kind\n             && let Some(collect_def_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id)\n             && match_def_path(cx, collect_def_id, &paths::CORE_ITER_COLLECT) {\n             check_into_iter(cx, parent_expr, left_expr, target_expr, self.msrv);\n@@ -87,10 +87,10 @@ fn check_into_iter(\n     target_expr: &hir::Expr<'_>,\n     msrv: Option<RustcVersion>,\n ) {\n-    if let hir::ExprKind::MethodCall(_, [into_iter_expr, _], _) = &target_expr.kind\n+    if let hir::ExprKind::MethodCall(_, into_iter_expr, [_], _) = &target_expr.kind\n         && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n-        && let hir::ExprKind::MethodCall(_, [struct_expr], _) = &into_iter_expr.kind\n+        && let hir::ExprKind::MethodCall(_, struct_expr, [], _) = &into_iter_expr.kind\n         && let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id)\n         && match_def_path(cx, into_iter_def_id, &paths::CORE_ITER_INTO_ITER)\n         && match_acceptable_type(cx, left_expr, msrv)\n@@ -106,14 +106,14 @@ fn check_iter(\n     target_expr: &hir::Expr<'_>,\n     msrv: Option<RustcVersion>,\n ) {\n-    if let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind\n+    if let hir::ExprKind::MethodCall(_, filter_expr, [], _) = &target_expr.kind\n         && let Some(copied_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n         && (match_def_path(cx, copied_def_id, &paths::CORE_ITER_COPIED)\n             || match_def_path(cx, copied_def_id, &paths::CORE_ITER_CLONED))\n-        && let hir::ExprKind::MethodCall(_, [iter_expr, _], _) = &filter_expr.kind\n+        && let hir::ExprKind::MethodCall(_, iter_expr, [_], _) = &filter_expr.kind\n         && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id)\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n-        && let hir::ExprKind::MethodCall(_, [struct_expr], _) = &iter_expr.kind\n+        && let hir::ExprKind::MethodCall(_, struct_expr, [], _) = &iter_expr.kind\n         && let Some(iter_expr_def_id) = cx.typeck_results().type_dependent_def_id(iter_expr.hir_id)\n         && match_acceptable_def_path(cx, iter_expr_def_id)\n         && match_acceptable_type(cx, left_expr, msrv)\n@@ -130,13 +130,13 @@ fn check_to_owned(\n     msrv: Option<RustcVersion>,\n ) {\n     if meets_msrv(msrv,  msrvs::STRING_RETAIN)\n-        && let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind\n+        && let hir::ExprKind::MethodCall(_, filter_expr, [], _) = &target_expr.kind\n         && let Some(to_owned_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n         && match_def_path(cx, to_owned_def_id, &paths::TO_OWNED_METHOD)\n-        && let hir::ExprKind::MethodCall(_, [chars_expr, _], _) = &filter_expr.kind\n+        && let hir::ExprKind::MethodCall(_, chars_expr, [_], _) = &filter_expr.kind\n         && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id)\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n-        && let hir::ExprKind::MethodCall(_, [str_expr], _) = &chars_expr.kind\n+        && let hir::ExprKind::MethodCall(_, str_expr, [], _) = &chars_expr.kind\n         && let Some(chars_expr_def_id) = cx.typeck_results().type_dependent_def_id(chars_expr.hir_id)\n         && match_def_path(cx, chars_expr_def_id, &paths::STR_CHARS)\n         && let ty = cx.typeck_results().expr_ty(str_expr).peel_refs()\n@@ -147,7 +147,7 @@ fn check_to_owned(\n }\n \n fn suggest(cx: &LateContext<'_>, parent_expr: &hir::Expr<'_>, left_expr: &hir::Expr<'_>, filter_expr: &hir::Expr<'_>) {\n-    if let hir::ExprKind::MethodCall(_, [_, closure], _) = filter_expr.kind\n+    if let hir::ExprKind::MethodCall(_, _, [closure], _) = filter_expr.kind\n         && let hir::ExprKind::Closure(&hir::Closure { body, ..}) = closure.kind\n         && let filter_body = cx.tcx.hir().body(body)\n         && let [filter_params] = filter_body.params"}, {"sha": "6acfb2ae3471c3b3a4f3840b609d490af95e0cfe", "filename": "clippy_lints/src/manual_string_new.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmanual_string_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmanual_string_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_string_new.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -55,8 +55,8 @@ impl LateLintPass<'_> for ManualStringNew {\n             ExprKind::Call(func, args) => {\n                 parse_call(cx, expr.span, func, args);\n             },\n-            ExprKind::MethodCall(path_segment, args, _) => {\n-                parse_method_call(cx, expr.span, path_segment, args);\n+            ExprKind::MethodCall(path_segment, receiver, ..) => {\n+                parse_method_call(cx, expr.span, path_segment, receiver);\n             },\n             _ => (),\n         }\n@@ -88,14 +88,9 @@ fn warn_then_suggest(cx: &LateContext<'_>, span: Span) {\n }\n \n /// Tries to parse an expression as a method call, emitting the warning if necessary.\n-fn parse_method_call(cx: &LateContext<'_>, span: Span, path_segment: &PathSegment<'_>, args: &[Expr<'_>]) {\n-    if args.is_empty() {\n-        // When parsing TryFrom::try_from(...).expect(...), we will have more than 1 arg.\n-        return;\n-    }\n-\n+fn parse_method_call(cx: &LateContext<'_>, span: Span, path_segment: &PathSegment<'_>, receiver: &Expr<'_>) {\n     let ident = path_segment.ident.as_str();\n-    let method_arg_kind = &args[0].kind;\n+    let method_arg_kind = &receiver.kind;\n     if [\"to_string\", \"to_owned\", \"into\"].contains(&ident) && is_expr_kind_empty_str(method_arg_kind) {\n         warn_then_suggest(cx, span);\n     } else if let ExprKind::Call(func, args) = method_arg_kind {"}, {"sha": "7941c8c9c7e39bc4c2f941d765f19904569c7bbd", "filename": "clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n \n         if_chain! {\n             if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n-            if let ExprKind::MethodCall(_, [target_arg, pattern], _) = cond.kind;\n+            if let ExprKind::MethodCall(_, target_arg, [pattern], _) = cond.kind;\n             if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(cond.hir_id);\n             if let ExprKind::Path(target_path) = &target_arg.kind;\n             then {\n@@ -132,7 +132,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n // Returns `Some(arg)` if `expr` matches `arg.len()` and `None` otherwise.\n fn len_arg<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n-        if let ExprKind::MethodCall(_, [arg], _) = expr.kind;\n+        if let ExprKind::MethodCall(_, arg, [], _) = expr.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, method_def_id, &paths::STR_LEN);\n         then {"}, {"sha": "33d744815299f040f56a967423b248e65eb6ea5c", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -200,8 +200,13 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n     )\n }\n \n-fn lint_map_unit_fn(cx: &LateContext<'_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr<'_>, map_args: &[hir::Expr<'_>]) {\n-    let var_arg = &map_args[0];\n+fn lint_map_unit_fn(\n+    cx: &LateContext<'_>,\n+    stmt: &hir::Stmt<'_>,\n+    expr: &hir::Expr<'_>,\n+    map_args: (&hir::Expr<'_>, &[hir::Expr<'_>]),\n+) {\n+    let var_arg = &map_args.0;\n \n     let (map_type, variant, lint) = if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym::Option) {\n         (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n@@ -210,7 +215,7 @@ fn lint_map_unit_fn(cx: &LateContext<'_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr\n     } else {\n         return;\n     };\n-    let fn_arg = &map_args[1];\n+    let fn_arg = &map_args.1[0];\n \n     if is_unit_function(cx, fn_arg) {\n         let mut applicability = Applicability::MachineApplicable;"}, {"sha": "8588ab1ed8db781d159aa74363f4eddbf8642562", "filename": "clippy_lints/src/match_result_ok.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatch_result_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatch_result_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_result_ok.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -58,7 +58,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchResultOk {\n             };\n \n         if_chain! {\n-            if let ExprKind::MethodCall(ok_path, [ref result_types_0, ..], _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n+            if let ExprKind::MethodCall(ok_path, result_types_0, ..) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = let_pat.kind; //get operation\n             if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() method use std::marker::Sized;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(result_types_0), sym::Result);"}, {"sha": "b0198e856d5b6ad3b4e107fc792821cb6eb76ef4", "filename": "clippy_lints/src/matches/manual_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -165,7 +165,7 @@ fn check<'tcx>(\n                 }\n \n                 // `ref` and `ref mut` annotations were handled earlier.\n-                let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                let annotation = if matches!(annotation, BindingAnnotation::MUT) {\n                     \"mut \"\n                 } else {\n                     \"\""}, {"sha": "91d17f481e2df1cd7e369e1eb3dee2e9659dea0f", "filename": "clippy_lints/src/matches/match_as_ref.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -2,26 +2,25 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{is_lang_ctor, peel_blocks};\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, LangItem, PatKind, QPath};\n+use rustc_hir::{Arm, BindingAnnotation, ByRef, Expr, ExprKind, LangItem, Mutability, PatKind, QPath};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n \n use super::MATCH_AS_REF;\n \n pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        let arm_ref: Option<BindingAnnotation> = if is_none_arm(cx, &arms[0]) {\n+        let arm_ref_mut = if is_none_arm(cx, &arms[0]) {\n             is_ref_some_arm(cx, &arms[1])\n         } else if is_none_arm(cx, &arms[1]) {\n             is_ref_some_arm(cx, &arms[0])\n         } else {\n             None\n         };\n-        if let Some(rb) = arm_ref {\n-            let suggestion = if rb == BindingAnnotation::Ref {\n-                \"as_ref\"\n-            } else {\n-                \"as_mut\"\n+        if let Some(rb) = arm_ref_mut {\n+            let suggestion = match rb {\n+                Mutability::Not => \"as_ref\",\n+                Mutability::Mut => \"as_mut\",\n             };\n \n             let output_ty = cx.typeck_results().expr_ty(expr);\n@@ -66,19 +65,18 @@ fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n-fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n+fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<Mutability> {\n     if_chain! {\n         if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n         if is_lang_ctor(cx, qpath, LangItem::OptionSome);\n-        if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n-        if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n+        if let PatKind::Binding(BindingAnnotation(ByRef::Yes, mutabl), .., ident, _) = first_pat.kind;\n         if let ExprKind::Call(e, [arg]) = peel_blocks(arm.body).kind;\n         if let ExprKind::Path(ref some_path) = e.kind;\n         if is_lang_ctor(cx, some_path, LangItem::OptionSome);\n         if let ExprKind::Path(QPath::Resolved(_, path2)) = arg.kind;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {\n-            return Some(rb)\n+            return Some(mutabl)\n         }\n     }\n     None"}, {"sha": "1e80b6cf2d838ecf4d6c64d8fcb353ed214b0d0e", "filename": "clippy_lints/src/matches/match_str_case_mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -48,7 +48,7 @@ struct MatchExprVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for MatchExprVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n         match ex.kind {\n-            ExprKind::MethodCall(segment, [receiver], _) if self.case_altered(segment.ident.as_str(), receiver) => {},\n+            ExprKind::MethodCall(segment, receiver, [], _) if self.case_altered(segment.ident.as_str(), receiver) => {},\n             _ => walk_expr(self, ex),\n         }\n     }"}, {"sha": "634eef82e532ae50304b9f1dd76316ee0acc6748", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -8,7 +8,7 @@ use clippy_utils::{\n };\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, FnRetTy, Guard, Node, Pat, PatKind, Path, QPath};\n+use rustc_hir::{Arm, BindingAnnotation, ByRef, Expr, ExprKind, FnRetTy, Guard, Node, Pat, PatKind, Path, QPath};\n use rustc_lint::LateContext;\n use rustc_span::sym;\n use rustc_typeck::hir_ty_to_ty;\n@@ -189,8 +189,7 @@ fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n                 },\n             )),\n         ) => {\n-            return !matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut)\n-                && pat_ident.name == first_seg.ident.name;\n+            return !matches!(annot, BindingAnnotation(ByRef::Yes, _)) && pat_ident.name == first_seg.ident.name;\n         },\n         // Example: `Custom::TypeA => Custom::TypeB`, or `None => None`\n         (PatKind::Path(QPath::Resolved(_, p_path)), ExprKind::Path(QPath::Resolved(_, e_path))) => {"}, {"sha": "f7443471e31dda274d656766223512c64de39ccb", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -120,7 +120,7 @@ fn find_sugg_for_if_let<'tcx>(\n     // check that `while_let_on_iterator` lint does not trigger\n     if_chain! {\n         if keyword == \"while\";\n-        if let ExprKind::MethodCall(method_path, _, _) = let_expr.kind;\n+        if let ExprKind::MethodCall(method_path, ..) = let_expr.kind;\n         if method_path.ident.name == sym::next;\n         if is_trait_method(cx, let_expr, sym::Iterator);\n         then {"}, {"sha": "86a9df034979be06feb7484f112acf00b2f9529a", "filename": "clippy_lints/src/matches/significant_drop_in_scrutinee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -291,7 +291,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SigDropHelper<'a, 'tcx> {\n         self.is_chain_end = false;\n \n         match ex.kind {\n-            ExprKind::MethodCall(_, [ref expr, ..], _) => {\n+            ExprKind::MethodCall(_, expr, ..) => {\n                 self.visit_expr(expr);\n             }\n             ExprKind::Binary(_, left, right) => {\n@@ -331,8 +331,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SigDropHelper<'a, 'tcx> {\n             ExprKind::Index(..) |\n             ExprKind::Ret(..) |\n             ExprKind::Repeat(..) |\n-            ExprKind::Yield(..) |\n-            ExprKind::MethodCall(..) => walk_expr(self, ex),\n+            ExprKind::Yield(..) => walk_expr(self, ex),\n             ExprKind::AddrOf(_, _, _) |\n             ExprKind::Block(_, _) |\n             ExprKind::Break(_, _) |"}, {"sha": "38df69eeb379b43795590b99b4fe1d0f8e2c3d82", "filename": "clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -175,7 +175,7 @@ fn collect_pat_paths<'a>(acc: &mut Vec<Ty<'a>>, cx: &LateContext<'a>, pat: &Pat<\n             let p_ty = cx.typeck_results().pat_ty(p);\n             collect_pat_paths(acc, cx, p, p_ty);\n         }),\n-        PatKind::TupleStruct(..) | PatKind::Binding(BindingAnnotation::Unannotated, .., None) | PatKind::Path(_) => {\n+        PatKind::TupleStruct(..) | PatKind::Binding(BindingAnnotation::NONE, .., None) | PatKind::Path(_) => {\n             acc.push(ty);\n         },\n         _ => {},"}, {"sha": "22f5635a5bccb803ddad652db33ce738039449ac", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -152,7 +152,7 @@ pub(crate) trait BindInsteadOfMap {\n         match arg.kind {\n             hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }) => {\n                 let closure_body = cx.tcx.hir().body(body);\n-                let closure_expr = peel_blocks(&closure_body.value);\n+                let closure_expr = peel_blocks(closure_body.value);\n \n                 if Self::lint_closure_autofixable(cx, expr, recv, closure_expr, fn_decl_span) {\n                     true"}, {"sha": "fef90f6eba49525eb5c0f827aee1e823d97808df", "filename": "clippy_lints/src/methods/bytecount.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -42,11 +42,11 @@ pub(super) fn check<'tcx>(\n         if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n         if !is_local_used(cx, needle, arg_id);\n         then {\n-            let haystack = if let ExprKind::MethodCall(path, args, _) =\n+            let haystack = if let ExprKind::MethodCall(path, receiver, [], _) =\n                     filter_recv.kind {\n                 let p = path.ident.name;\n-                if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n-                    &args[0]\n+                if p == sym::iter || p == sym!(iter_mut) {\n+                    receiver\n                 } else {\n                     filter_recv\n                 }"}, {"sha": "b2bc1ad5c9ed0f33cc1ce5d69af3485e58bc94fd", "filename": "clippy_lints/src/methods/chars_cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check(\n         if Some(id) == cx.tcx.lang_items().option_some_variant();\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n-            let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n+            let self_ty = cx.typeck_results().expr_ty_adjusted(args[0].0).peel_refs();\n \n             if *self_ty.kind() != ty::Str {\n                 return false;\n@@ -37,7 +37,7 @@ pub(super) fn check(\n                 \"like this\",\n                 format!(\"{}{}.{}({})\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, args[0].0.span, \"..\", &mut applicability),\n                         suggest,\n                         snippet_with_applicability(cx, arg_char.span, \"..\", &mut applicability)),\n                 applicability,"}, {"sha": "b85bfec2b12ba33de410c2902678864a1fdc0f50", "filename": "clippy_lints/src/methods/chars_cmp_with_unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check<'tcx>(\n                 \"like this\",\n                 format!(\"{}{}.{}('{}')\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, args[0].0.span, \"..\", &mut applicability),\n                         suggest,\n                         c.escape_default()),\n                 applicability,"}, {"sha": "7ab6b84c2074918f39b8f0d5aa67de94d23a914c", "filename": "clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::source::snippet_with_context;\n use clippy_utils::sugg;\n use clippy_utils::ty::is_copy;\n use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, Expr, ExprKind, MatchSource, Node, PatKind, QPath};\n+use rustc_hir::{BindingAnnotation, ByRef, Expr, ExprKind, MatchSource, Node, PatKind, QPath};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, adjustment::Adjust};\n use rustc_span::symbol::{sym, Symbol};\n@@ -14,10 +14,17 @@ use super::CLONE_ON_COPY;\n \n /// Checks for the `CLONE_ON_COPY` lint.\n #[allow(clippy::too_many_lines)]\n-pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol, args: &[Expr<'_>]) {\n-    let arg = match args {\n-        [arg] if method_name == sym::clone => arg,\n-        _ => return,\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &Expr<'_>,\n+    args: &[Expr<'_>],\n+) {\n+    let arg = if method_name == sym::clone && args.is_empty() {\n+        receiver\n+    } else {\n+        return;\n     };\n     if cx\n         .typeck_results()\n@@ -81,7 +88,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol,\n                 // &*x is a nop, &x.clone() is not\n                 ExprKind::AddrOf(..) => return,\n                 // (*x).func() is useless, x.clone().func() can work in case func borrows self\n-                ExprKind::MethodCall(_, [self_arg, ..], _)\n+                ExprKind::MethodCall(_, self_arg, ..)\n                     if expr.hir_id == self_arg.hir_id && ty != cx.typeck_results().expr_ty_adjusted(expr) =>\n                 {\n                     return;\n@@ -91,19 +98,14 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol,\n                     hir_callee.kind,\n                     ExprKind::Path(QPath::LangItem(rustc_hir::LangItem::TryTraitBranch, _, _))\n                 ),\n-                ExprKind::MethodCall(_, [self_arg, ..], _) if expr.hir_id == self_arg.hir_id => true,\n+                ExprKind::MethodCall(_, self_arg, ..) if expr.hir_id == self_arg.hir_id => true,\n                 ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n                 | ExprKind::Field(..)\n                 | ExprKind::Index(..) => true,\n                 _ => false,\n             },\n             // local binding capturing a reference\n-            Some(Node::Local(l))\n-                if matches!(\n-                    l.pat.kind,\n-                    PatKind::Binding(BindingAnnotation::Ref | BindingAnnotation::RefMut, ..)\n-                ) =>\n-            {\n+            Some(Node::Local(l)) if matches!(l.pat.kind, PatKind::Binding(BindingAnnotation(ByRef::Yes, _), ..)) => {\n                 return;\n             },\n             _ => false,"}, {"sha": "f82ca8912006180b5b853dd57f8af0538c423976", "filename": "clippy_lints/src/methods/clone_on_ref_ptr.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -10,12 +10,17 @@ use rustc_span::symbol::{sym, Symbol};\n \n use super::CLONE_ON_REF_PTR;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n-    if !(args.len() == 1 && method_name == sym::clone) {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &hir::Expr<'_>,\n+    args: &[hir::Expr<'_>],\n+) {\n+    if !(args.is_empty() && method_name == sym::clone) {\n         return;\n     }\n-    let arg = &args[0];\n-    let obj_ty = cx.typeck_results().expr_ty(arg).peel_refs();\n+    let obj_ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n \n     if let ty::Adt(_, subst) = obj_ty.kind() {\n         let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n@@ -28,7 +33,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Sym\n             return;\n         };\n \n-        let snippet = snippet_with_macro_callsite(cx, arg.span, \"..\");\n+        let snippet = snippet_with_macro_callsite(cx, receiver.span, \"..\");\n \n         span_lint_and_sugg(\n             cx,"}, {"sha": "501646863fe156c4fab56cc8452f2e23cf7e65f9", "filename": "clippy_lints/src/methods/collapsible_str_replace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check<'tcx>(\n         // If the parent node's `to` argument is the same as the `to` argument\n         // of the last replace call in the current chain, don't lint as it was already linted\n         if let Some(parent) = get_parent_expr(cx, expr)\n-            && let Some((\"replace\", [_, current_from, current_to], _)) = method_call(parent)\n+            && let Some((\"replace\", _, [current_from, current_to], _)) = method_call(parent)\n             && eq_expr_value(cx, to, current_to)\n             && from_kind == cx.typeck_results().expr_ty(current_from).peel_refs().kind()\n         {\n@@ -48,7 +48,7 @@ fn collect_replace_calls<'tcx>(\n     let mut from_args = VecDeque::new();\n \n     let _: Option<()> = for_each_expr(expr, |e| {\n-        if let Some((\"replace\", [_, from, to], _)) = method_call(e) {\n+        if let Some((\"replace\", _, [from, to], _)) = method_call(e) {\n             if eq_expr_value(cx, to_arg, to) && cx.typeck_results().expr_ty(from).peel_refs().is_char() {\n                 methods.push_front(e);\n                 from_args.push_front(from);\n@@ -78,7 +78,7 @@ fn check_consecutive_replace_calls<'tcx>(\n         .collect();\n     let app = Applicability::MachineApplicable;\n     let earliest_replace_call = replace_methods.methods.front().unwrap();\n-    if let Some((_, [..], span_lo)) = method_call(earliest_replace_call) {\n+    if let Some((_, _, [..], span_lo)) = method_call(earliest_replace_call) {\n         span_lint_and_sugg(\n             cx,\n             COLLAPSIBLE_STR_REPLACE,"}, {"sha": "bd846d71d4668ed29288ea248849193432903462", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -19,6 +19,7 @@ pub(super) fn check<'tcx>(\n     expr: &hir::Expr<'_>,\n     method_span: Span,\n     name: &str,\n+    receiver: &'tcx hir::Expr<'tcx>,\n     args: &'tcx [hir::Expr<'tcx>],\n ) {\n     // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n@@ -28,16 +29,13 @@ pub(super) fn check<'tcx>(\n         loop {\n             arg_root = match &arg_root.kind {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => expr,\n-                hir::ExprKind::MethodCall(method_name, call_args, _) => {\n-                    if call_args.len() == 1\n-                        && (method_name.ident.name == sym::as_str || method_name.ident.name == sym::as_ref)\n-                        && {\n-                            let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n-                            let base_type = arg_type.peel_refs();\n-                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::String)\n-                        }\n-                    {\n-                        &call_args[0]\n+                hir::ExprKind::MethodCall(method_name, receiver, [], ..) => {\n+                    if (method_name.ident.name == sym::as_str || method_name.ident.name == sym::as_ref) && {\n+                        let arg_type = cx.typeck_results().expr_ty(receiver);\n+                        let base_type = arg_type.peel_refs();\n+                        *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::String)\n+                    } {\n+                        receiver\n                     } else {\n                         break;\n                     }\n@@ -114,11 +112,11 @@ pub(super) fn check<'tcx>(\n         }\n     }\n \n-    if args.len() != 2 || name != \"expect\" || !is_call(&args[1].kind) {\n+    if args.len() != 1 || name != \"expect\" || !is_call(&args[0].kind) {\n         return;\n     }\n \n-    let receiver_type = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    let receiver_type = cx.typeck_results().expr_ty_adjusted(receiver);\n     let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym::Option) {\n         \"||\"\n     } else if is_type_diagnostic_item(cx, receiver_type, sym::Result) {\n@@ -127,7 +125,7 @@ pub(super) fn check<'tcx>(\n         return;\n     };\n \n-    let arg_root = get_arg_root(cx, &args[1]);\n+    let arg_root = get_arg_root(cx, &args[0]);\n \n     let span_replace_word = method_span.with_hi(expr.span.hi());\n "}, {"sha": "37b28463527cc5c3bcfe01233a19770ed0f6fe76", "filename": "clippy_lints/src/methods/extend_with_drain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg:\n     if_chain! {\n         if is_type_diagnostic_item(cx, ty, sym::Vec);\n         //check source object\n-        if let ExprKind::MethodCall(src_method, [drain_vec, drain_arg], _) = &arg.kind;\n+        if let ExprKind::MethodCall(src_method, drain_vec, [drain_arg], _) = &arg.kind;\n         if src_method.ident.as_str() == \"drain\";\n         let src_ty = cx.typeck_results().expr_ty(drain_vec);\n         //check if actual src type is mutable for code suggestion"}, {"sha": "9719b2f1c5125ff78f97934aeed8078405aa8878", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -25,14 +25,14 @@ fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n         },\n         hir::ExprKind::Closure(&hir::Closure { body, .. }) => {\n             let body = cx.tcx.hir().body(body);\n-            let closure_expr = peel_blocks(&body.value);\n+            let closure_expr = peel_blocks(body.value);\n             let arg_id = body.params[0].pat.hir_id;\n             match closure_expr.kind {\n-                hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, args, _) => {\n+                hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, receiver, ..) => {\n                     if_chain! {\n                     if ident.name == method_name;\n-                    if let hir::ExprKind::Path(path) = &args[0].kind;\n-                    if let Res::Local(ref local) = cx.qpath_res(path, args[0].hir_id);\n+                    if let hir::ExprKind::Path(path) = &receiver.kind;\n+                    if let Res::Local(ref local) = cx.qpath_res(path, receiver.hir_id);\n                     then {\n                         return arg_id == *local\n                     }\n@@ -106,7 +106,7 @@ pub(super) fn check<'tcx>(\n             };\n             // closure ends with is_some() or is_ok()\n             if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n-            if let ExprKind::MethodCall(path, [filter_arg], _) = filter_body.value.kind;\n+            if let ExprKind::MethodCall(path, filter_arg, [], _) = filter_body.value.kind;\n             if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).peel_refs().ty_adt_def();\n             if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::Option, opt_ty.did()) {\n                 Some(false)\n@@ -123,13 +123,13 @@ pub(super) fn check<'tcx>(\n             if let [map_param] = map_body.params;\n             if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n             // closure ends with expect() or unwrap()\n-            if let ExprKind::MethodCall(seg, [map_arg, ..], _) = map_body.value.kind;\n+            if let ExprKind::MethodCall(seg, map_arg, ..) = map_body.value.kind;\n             if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n \n             // .filter(..).map(|y| f(y).copied().unwrap())\n             //                     ~~~~\n             let map_arg_peeled = match map_arg.kind {\n-                ExprKind::MethodCall(method, [original_arg], _) if acceptable_methods(method) => {\n+                ExprKind::MethodCall(method, original_arg, [], _) if acceptable_methods(method) => {\n                     original_arg\n                 },\n                 _ => map_arg,"}, {"sha": "02aada87202c26cd2afb3d744e0f304850c7d1c1", "filename": "clippy_lints/src/methods/get_last_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -22,7 +22,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg:\n     ) = arg.kind\n \n         // LHS of subtraction is \"x.len()\"\n-        && let ExprKind::MethodCall(lhs_path, [lhs_recv], _) = &lhs.kind\n+        && let ExprKind::MethodCall(lhs_path, lhs_recv, [], _) = &lhs.kind\n         && lhs_path.ident.name == sym::len\n \n         // RHS of subtraction is 1"}, {"sha": "e1c9b5248a8a4f912c434a6f1a8886d9e59b7dcd", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -12,13 +12,19 @@ use rustc_span::symbol::{sym, Symbol};\n use super::INEFFICIENT_TO_STRING;\n \n /// Checks for the `INEFFICIENT_TO_STRING` lint\n-pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n+pub fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &hir::Expr<'_>,\n+    args: &[hir::Expr<'_>],\n+) {\n     if_chain! {\n-        if args.len() == 1 && method_name == sym::to_string;\n+        if args.is_empty() && method_name == sym::to_string;\n         if let Some(to_string_meth_did) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, to_string_meth_did, &paths::TO_STRING_METHOD);\n         if let Some(substs) = cx.typeck_results().node_substs_opt(expr.hir_id);\n-        let arg_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+        let arg_ty = cx.typeck_results().expr_ty_adjusted(receiver);\n         let self_ty = substs.type_at(0);\n         let (deref_self_ty, deref_count) = walk_ptrs_ty_depth(self_ty);\n         if deref_count >= 1;\n@@ -35,7 +41,7 @@ pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n                         self_ty, deref_self_ty\n                     ));\n                     let mut applicability = Applicability::MachineApplicable;\n-                    let arg_snippet = snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability);\n+                    let arg_snippet = snippet_with_applicability(cx, receiver.span, \"..\", &mut applicability);\n                     diag.span_suggestion(\n                         expr.span,\n                         \"try dereferencing the receiver\","}, {"sha": "11e76841e9f054425257442a1e2f7e825d7f21d1", "filename": "clippy_lints/src/methods/into_iter_on_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -16,9 +16,9 @@ pub(super) fn check(\n     expr: &hir::Expr<'_>,\n     method_span: Span,\n     method_name: Symbol,\n-    args: &[hir::Expr<'_>],\n+    receiver: &hir::Expr<'_>,\n ) {\n-    let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    let self_ty = cx.typeck_results().expr_ty_adjusted(receiver);\n     if_chain! {\n         if let ty::Ref(..) = self_ty.kind();\n         if method_name == sym::into_iter;"}, {"sha": "beb772100affcb1e5f1351c413c0a656b0baeae7", "filename": "clippy_lints/src/methods/iter_skip_next.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -24,7 +24,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n                     if let Some(id) = path_to_local(recv);\n                     if let Node::Pat(pat) = cx.tcx.hir().get(id);\n                     if let PatKind::Binding(ann, _, _, _)  = pat.kind;\n-                    if ann != BindingAnnotation::Mutable;\n+                    if ann != BindingAnnotation::MUT;\n                     then {\n                         application = Applicability::Unspecified;\n                         diag.span_help("}, {"sha": "a669cbbbcc602c77c4fc59c6bad177892751111f", "filename": "clippy_lints/src/methods/iter_with_drain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -35,7 +35,7 @@ fn is_full_range(cx: &LateContext<'_>, container: &Expr<'_>, range: Range<'_>) -\n         && range.end.map_or(true, |e| {\n             if range.limits == RangeLimits::HalfOpen\n                 && let ExprKind::Path(QPath::Resolved(None, container_path)) = container.kind\n-                && let ExprKind::MethodCall(name, [self_arg], _) = e.kind\n+                && let ExprKind::MethodCall(name, self_arg, [], _) = e.kind\n                 && name.ident.name == sym::len\n                 && let ExprKind::Path(QPath::Resolved(None, path)) = self_arg.kind\n             {"}, {"sha": "8261ef5e1ce345819266a83a37f3905a5b5f47f8", "filename": "clippy_lints/src/methods/map_clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -30,16 +30,16 @@ pub(super) fn check<'tcx>(\n         if let hir::ExprKind::Closure(&hir::Closure{ body, .. }) = arg.kind;\n         then {\n             let closure_body = cx.tcx.hir().body(body);\n-            let closure_expr = peel_blocks(&closure_body.value);\n+            let closure_expr = peel_blocks(closure_body.value);\n             match closure_body.params[0].pat.kind {\n                 hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n-                    hir::BindingAnnotation::Unannotated, .., name, None\n+                    hir::BindingAnnotation::NONE, .., name, None\n                 ) = inner.kind {\n                     if ident_eq(name, closure_expr) {\n                         lint_explicit_closure(cx, e.span, recv.span, true, msrv);\n                     }\n                 },\n-                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n+                hir::PatKind::Binding(hir::BindingAnnotation::NONE, .., name, None) => {\n                     match closure_expr.kind {\n                         hir::ExprKind::Unary(hir::UnOp::Deref, inner) => {\n                             if ident_eq(name, inner) {\n@@ -48,7 +48,7 @@ pub(super) fn check<'tcx>(\n                                 }\n                             }\n                         },\n-                        hir::ExprKind::MethodCall(method, [obj], _) => if_chain! {\n+                        hir::ExprKind::MethodCall(method, obj, [], _) => if_chain! {\n                             if ident_eq(name, obj) && method.ident.name == sym::clone;\n                             if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n                             if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);"}, {"sha": "41942b20ea163f34e0e60d47b489b19870b145aa", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -3162,11 +3162,13 @@ impl_lint_pass!(Methods => [\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n-fn method_call<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx str, &'tcx [hir::Expr<'tcx>], Span)> {\n-    if let ExprKind::MethodCall(path, args, _) = recv.kind {\n-        if !args.iter().any(|e| e.span.from_expansion()) {\n+fn method_call<'tcx>(\n+    recv: &'tcx hir::Expr<'tcx>,\n+) -> Option<(&'tcx str, &'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>], Span)> {\n+    if let ExprKind::MethodCall(path, receiver, args, _) = recv.kind {\n+        if !args.iter().any(|e| e.span.from_expansion()) && !receiver.span.from_expansion() {\n             let name = path.ident.name.as_str();\n-            return Some((name, args, path.ident.span));\n+            return Some((name, receiver, args, path.ident.span));\n         }\n     }\n     None\n@@ -3184,17 +3186,17 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             hir::ExprKind::Call(func, args) => {\n                 from_iter_instead_of_collect::check(cx, expr, args, func);\n             },\n-            hir::ExprKind::MethodCall(method_call, args, _) => {\n+            hir::ExprKind::MethodCall(method_call, receiver, args, _) => {\n                 let method_span = method_call.ident.span;\n-                or_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), args);\n-                expect_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), args);\n-                clone_on_copy::check(cx, expr, method_call.ident.name, args);\n-                clone_on_ref_ptr::check(cx, expr, method_call.ident.name, args);\n-                inefficient_to_string::check(cx, expr, method_call.ident.name, args);\n-                single_char_add_str::check(cx, expr, args);\n-                into_iter_on_ref::check(cx, expr, method_span, method_call.ident.name, args);\n-                single_char_pattern::check(cx, expr, method_call.ident.name, args);\n-                unnecessary_to_owned::check(cx, expr, method_call.ident.name, args, self.msrv);\n+                or_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), receiver, args);\n+                expect_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), receiver, args);\n+                clone_on_copy::check(cx, expr, method_call.ident.name, receiver, args);\n+                clone_on_ref_ptr::check(cx, expr, method_call.ident.name, receiver, args);\n+                inefficient_to_string::check(cx, expr, method_call.ident.name, receiver, args);\n+                single_char_add_str::check(cx, expr, receiver, args);\n+                into_iter_on_ref::check(cx, expr, method_span, method_call.ident.name, receiver);\n+                single_char_pattern::check(cx, expr, method_call.ident.name, receiver, args);\n+                unnecessary_to_owned::check(cx, expr, method_call.ident.name, receiver, args, self.msrv);\n             },\n             hir::ExprKind::Binary(op, lhs, rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n                 let mut info = BinaryExprInfo {\n@@ -3303,9 +3305,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 // one of the associated types must be Self\n                 for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n                     if let ty::PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n-                        let assoc_ty = match projection_predicate.term {\n-                            ty::Term::Ty(ty) => ty,\n-                            ty::Term::Const(_c) => continue,\n+                        let assoc_ty = match projection_predicate.term.unpack() {\n+                            ty::TermKind::Ty(ty) => ty,\n+                            ty::TermKind::Const(_c) => continue,\n                         };\n                         // walk the associated type and check for Self\n                         if let Some(self_adt) = self_ty.ty_adt_def() {\n@@ -3380,7 +3382,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n impl Methods {\n     #[allow(clippy::too_many_lines)]\n     fn check_methods<'tcx>(&self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((name, [recv, args @ ..], span)) = method_call(expr) {\n+        if let Some((name, recv, args, span)) = method_call(expr) {\n             match (name, args) {\n                 (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n                     zst_offset::check(cx, expr, recv);\n@@ -3400,40 +3402,40 @@ impl Methods {\n                 (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n                 (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span, self.msrv),\n                 (\"collect\", []) => match method_call(recv) {\n-                    Some((name @ (\"cloned\" | \"copied\"), [recv2], _)) => {\n+                    Some((name @ (\"cloned\" | \"copied\"), recv2, [], _)) => {\n                         iter_cloned_collect::check(cx, name, expr, recv2);\n                     },\n-                    Some((\"map\", [m_recv, m_arg], _)) => {\n+                    Some((\"map\", m_recv, [m_arg], _)) => {\n                         map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n                     },\n-                    Some((\"take\", [take_self_arg, take_arg], _)) => {\n+                    Some((\"take\", take_self_arg, [take_arg], _)) => {\n                         if meets_msrv(self.msrv, msrvs::STR_REPEAT) {\n                             manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n                         }\n                     },\n                     _ => {},\n                 },\n                 (\"count\", []) if is_trait_method(cx, expr, sym::Iterator) => match method_call(recv) {\n-                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n-                    Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n+                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n+                    Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), recv2, [], _)) => {\n                         iter_count::check(cx, expr, recv2, name2);\n                     },\n-                    Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n-                    Some((\"filter\", [recv2, arg], _)) => bytecount::check(cx, expr, recv2, arg),\n-                    Some((\"bytes\", [recv2], _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n+                    Some((\"map\", _, [arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n+                    Some((\"filter\", recv2, [arg], _)) => bytecount::check(cx, expr, recv2, arg),\n+                    Some((\"bytes\", recv2, [], _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n                     _ => {},\n                 },\n                 (\"drain\", [arg]) => {\n                     iter_with_drain::check(cx, expr, recv, span, arg);\n                 },\n                 (\"ends_with\", [arg]) => {\n-                    if let ExprKind::MethodCall(_, _, span) = expr.kind {\n+                    if let ExprKind::MethodCall(.., span) = expr.kind {\n                         case_sensitive_file_extension_comparisons::check(cx, expr, span, recv, arg);\n                     }\n                 },\n                 (\"expect\", [_]) => match method_call(recv) {\n-                    Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n-                    Some((\"err\", [recv], err_span)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n+                    Some((\"ok\", recv, [], _)) => ok_expect::check(cx, expr, recv),\n+                    Some((\"err\", recv, [], err_span)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n                     _ => expect_used::check(cx, expr, recv, false, self.allow_expect_in_tests),\n                 },\n                 (\"expect_err\", [_]) => expect_used::check(cx, expr, recv, true, self.allow_expect_in_tests),\n@@ -3453,13 +3455,13 @@ impl Methods {\n                     flat_map_option::check(cx, expr, arg, span);\n                 },\n                 (\"flatten\", []) => match method_call(recv) {\n-                    Some((\"map\", [recv, map_arg], map_span)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n-                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, true),\n+                    Some((\"map\", recv, [map_arg], map_span)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n+                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, true),\n                     _ => {},\n                 },\n                 (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n                 (\"for_each\", [_]) => {\n-                    if let Some((\"inspect\", [_, _], span2)) = method_call(recv) {\n+                    if let Some((\"inspect\", _, [_], span2)) = method_call(recv) {\n                         inspect_for_each::check(cx, expr, span2);\n                     }\n                 },\n@@ -3479,12 +3481,12 @@ impl Methods {\n                     iter_on_single_or_empty_collections::check(cx, expr, name, recv);\n                 },\n                 (\"join\", [join_arg]) => {\n-                    if let Some((\"collect\", _, span)) = method_call(recv) {\n+                    if let Some((\"collect\", _, _, span)) = method_call(recv) {\n                         unnecessary_join::check(cx, expr, recv, join_arg, span);\n                     }\n                 },\n                 (\"last\", []) | (\"skip\", [_]) => {\n-                    if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _span2)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }\n@@ -3499,7 +3501,7 @@ impl Methods {\n                     } else {\n                         map_err_ignore::check(cx, expr, m_arg);\n                     }\n-                    if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n+                    if let Some((name, recv2, args, span2)) = method_call(recv) {\n                         match (name, args) {\n                             (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, self.msrv),\n                             (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, self.msrv),\n@@ -3519,7 +3521,7 @@ impl Methods {\n                     manual_ok_or::check(cx, expr, recv, def, map);\n                 },\n                 (\"next\", []) => {\n-                    if let Some((name2, [recv2, args2 @ ..], _)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _)) = method_call(recv) {\n                         match (name2, args2) {\n                             (\"cloned\", []) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n                             (\"filter\", [arg]) => filter_next::check(cx, expr, recv2, arg),\n@@ -3532,10 +3534,10 @@ impl Methods {\n                     }\n                 },\n                 (\"nth\", [n_arg]) => match method_call(recv) {\n-                    Some((\"bytes\", [recv2], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n-                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n-                    Some((\"iter\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n-                    Some((\"iter_mut\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n+                    Some((\"bytes\", recv2, [], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n+                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n+                    Some((\"iter\", recv2, [], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n+                    Some((\"iter_mut\", recv2, [], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n                     _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n                 },\n                 (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n@@ -3592,7 +3594,7 @@ impl Methods {\n                 },\n                 (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n                 (\"take\", [_arg]) => {\n-                    if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _span2)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }\n@@ -3615,13 +3617,13 @@ impl Methods {\n                 },\n                 (\"unwrap\", []) => {\n                     match method_call(recv) {\n-                        Some((\"get\", [recv, get_arg], _)) => {\n+                        Some((\"get\", recv, [get_arg], _)) => {\n                             get_unwrap::check(cx, expr, recv, get_arg, false);\n                         },\n-                        Some((\"get_mut\", [recv, get_arg], _)) => {\n+                        Some((\"get_mut\", recv, [get_arg], _)) => {\n                             get_unwrap::check(cx, expr, recv, get_arg, true);\n                         },\n-                        Some((\"or\", [recv, or_arg], or_span)) => {\n+                        Some((\"or\", recv, [or_arg], or_span)) => {\n                             or_then_unwrap::check(cx, expr, recv, or_arg, or_span);\n                         },\n                         _ => {},\n@@ -3630,27 +3632,27 @@ impl Methods {\n                 },\n                 (\"unwrap_err\", []) => unwrap_used::check(cx, expr, recv, true, self.allow_unwrap_in_tests),\n                 (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n-                    Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {\n+                    Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), lhs, [rhs], _)) => {\n                         manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n                     },\n-                    Some((\"map\", [m_recv, m_arg], span)) => {\n+                    Some((\"map\", m_recv, [m_arg], span)) => {\n                         option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span);\n                     },\n-                    Some((\"then_some\", [t_recv, t_arg], _)) => {\n+                    Some((\"then_some\", t_recv, [t_arg], _)) => {\n                         obfuscated_if_else::check(cx, expr, t_recv, t_arg, u_arg);\n                     },\n                     _ => {},\n                 },\n                 (\"unwrap_or_else\", [u_arg]) => match method_call(recv) {\n-                    Some((\"map\", [recv, map_arg], _))\n+                    Some((\"map\", recv, [map_arg], _))\n                         if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, self.msrv) => {},\n                     _ => {\n                         unwrap_or_else_default::check(cx, expr, recv, u_arg);\n                         unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\");\n                     },\n                 },\n                 (\"zip\", [arg]) => {\n-                    if let ExprKind::MethodCall(name, [iter_recv], _) = recv.kind\n+                    if let ExprKind::MethodCall(name, iter_recv, [], _) = recv.kind\n                         && name.ident.name == sym::iter\n                     {\n                         range_zip_with_len::check(cx, expr, iter_recv, arg);\n@@ -3663,7 +3665,7 @@ impl Methods {\n }\n \n fn check_is_some_is_none(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, is_some: bool) {\n-    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), [f_recv, arg], span)) = method_call(recv) {\n+    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), f_recv, [arg], span)) = method_call(recv) {\n         search_is_some::check(cx, expr, name, is_some, f_recv, arg, recv, span);\n     }\n }"}, {"sha": "597af853dc681a57d44f973f8a4fbe83a9d14977", "filename": "clippy_lints/src/methods/open_options.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -36,12 +36,12 @@ enum OpenOption {\n }\n \n fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n-    if let ExprKind::MethodCall(path, arguments, _) = argument.kind {\n-        let obj_ty = cx.typeck_results().expr_ty(&arguments[0]).peel_refs();\n+    if let ExprKind::MethodCall(path, receiver, arguments, _) = argument.kind {\n+        let obj_ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n-        if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {\n-            let argument_option = match arguments[1].kind {\n+        if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && !arguments.is_empty() {\n+            let argument_option = match arguments[0].kind {\n                 ExprKind::Lit(ref span) => {\n                     if let Spanned {\n                         node: LitKind::Bool(lit),\n@@ -77,7 +77,7 @@ fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec\n                 _ => (),\n             }\n \n-            get_open_options(cx, &arguments[0], options);\n+            get_open_options(cx, receiver, options);\n         }\n     }\n }"}, {"sha": "c409268de769d6616a1555071d5a7d1f75a07cdb", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -53,16 +53,15 @@ pub(super) fn check<'tcx>(\n             }),\n         hir::ExprKind::Closure(&hir::Closure { body, .. }) => {\n             let closure_body = cx.tcx.hir().body(body);\n-            let closure_expr = peel_blocks(&closure_body.value);\n+            let closure_expr = peel_blocks(closure_body.value);\n \n             match &closure_expr.kind {\n-                hir::ExprKind::MethodCall(_, args, _) => {\n+                hir::ExprKind::MethodCall(_, receiver, [], _) => {\n                     if_chain! {\n-                        if args.len() == 1;\n-                        if path_to_local_id(&args[0], closure_body.params[0].pat.hir_id);\n+                        if path_to_local_id(receiver, closure_body.params[0].pat.hir_id);\n                         let adj = cx\n                             .typeck_results()\n-                            .expr_adjustments(&args[0])\n+                            .expr_adjustments(receiver)\n                             .iter()\n                             .map(|x| &x.kind)\n                             .collect::<Box<[_]>>();"}, {"sha": "6657cdccd010c4398a7d0b3dbfd9d8a0e8ca6e91", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -74,7 +74,7 @@ pub(super) fn check<'tcx>(\n             if let hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }) = map_arg.kind;\n             let arg_snippet = snippet(cx, fn_decl_span, \"..\");\n             let body = cx.tcx.hir().body(body);\n-            if let Some((func, [arg_char])) = reduce_unit_expression(&body.value);\n+            if let Some((func, [arg_char])) = reduce_unit_expression(body.value);\n             if let Some(id) = path_def_id(cx, func).map(|ctor_id| cx.tcx.parent(ctor_id));\n             if Some(id) == cx.tcx.lang_items().option_some_variant();\n             then {"}, {"sha": "b43b9258c471da6ec44eae9a9204d0b4c6327a2d", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -20,6 +20,7 @@ pub(super) fn check<'tcx>(\n     expr: &hir::Expr<'_>,\n     method_span: Span,\n     name: &str,\n+    receiver: &'tcx hir::Expr<'_>,\n     args: &'tcx [hir::Expr<'_>],\n ) {\n     /// Checks for `unwrap_or(T::new())`, `unwrap_or(T::default())`,\n@@ -149,7 +150,7 @@ pub(super) fn check<'tcx>(\n         }\n     }\n \n-    if let [self_arg, arg] = args {\n+    if let [arg] = args {\n         let inner_arg = if let hir::ExprKind::Block(\n             hir::Block {\n                 stmts: [],\n@@ -168,11 +169,11 @@ pub(super) fn check<'tcx>(\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, arg, or_has_args, expr.span, method_span) {\n                     let fun_span = if or_has_args { None } else { Some(fun.span) };\n-                    check_general_case(cx, name, method_span, self_arg, arg, expr.span, fun_span);\n+                    check_general_case(cx, name, method_span, receiver, arg, expr.span, fun_span);\n                 }\n             },\n             hir::ExprKind::Index(..) | hir::ExprKind::MethodCall(..) => {\n-                check_general_case(cx, name, method_span, self_arg, arg, expr.span, None);\n+                check_general_case(cx, name, method_span, receiver, arg, expr.span, None);\n             },\n             _ => (),\n         }"}, {"sha": "867a3b4023770e6e162bc2227960022866d10cc5", "filename": "clippy_lints/src/methods/range_zip_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -16,7 +16,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, recv: &'\n         if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n         if is_integer_const(cx, start, 0);\n         // `.len()` call\n-        if let ExprKind::MethodCall(len_path, [len_recv], _) = end.kind;\n+        if let ExprKind::MethodCall(len_path, len_recv, [], _) = end.kind;\n         if len_path.ident.name == sym::len;\n         // `.iter()` and `.len()` called on same `Path`\n         if let ExprKind::Path(QPath::Resolved(_, iter_path)) = recv.kind;"}, {"sha": "81450fd8c6c3c565faa9350ef60f2b868e181e03", "filename": "clippy_lints/src/methods/single_char_add_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_add_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_add_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_add_str.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -3,12 +3,12 @@ use clippy_utils::{match_def_path, paths};\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, receiver: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n         if match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n-            single_char_push_string::check(cx, expr, args);\n+            single_char_push_string::check(cx, expr, receiver, args);\n         } else if match_def_path(cx, fn_def_id, &paths::INSERT_STR) {\n-            single_char_insert_string::check(cx, expr, args);\n+            single_char_insert_string::check(cx, expr, receiver, args);\n         }\n     }\n }"}, {"sha": "18b6b5be175d14f34ecb22093fc49d354482ce53", "filename": "clippy_lints/src/methods/single_char_insert_string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -8,12 +8,12 @@ use rustc_lint::LateContext;\n use super::SINGLE_CHAR_ADD_STR;\n \n /// lint for length-1 `str`s as argument for `insert_str`\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, receiver: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let mut applicability = Applicability::MachineApplicable;\n-    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[2], &mut applicability) {\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[1], &mut applicability) {\n         let base_string_snippet =\n-            snippet_with_applicability(cx, args[0].span.source_callsite(), \"_\", &mut applicability);\n-        let pos_arg = snippet_with_applicability(cx, args[1].span, \"..\", &mut applicability);\n+            snippet_with_applicability(cx, receiver.span.source_callsite(), \"_\", &mut applicability);\n+        let pos_arg = snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability);\n         let sugg = format!(\"{}.insert({}, {})\", base_string_snippet, pos_arg, extension_string);\n         span_lint_and_sugg(\n             cx,"}, {"sha": "4221c52d5cd79a57924fa2b8af6ed4caaf3b8c4a", "filename": "clippy_lints/src/methods/single_char_pattern.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -10,37 +10,43 @@ use rustc_span::symbol::Symbol;\n use super::SINGLE_CHAR_PATTERN;\n \n const PATTERN_METHODS: [(&str, usize); 24] = [\n-    (\"contains\", 1),\n-    (\"starts_with\", 1),\n-    (\"ends_with\", 1),\n-    (\"find\", 1),\n-    (\"rfind\", 1),\n-    (\"split\", 1),\n-    (\"split_inclusive\", 1),\n-    (\"rsplit\", 1),\n-    (\"split_terminator\", 1),\n-    (\"rsplit_terminator\", 1),\n-    (\"splitn\", 2),\n-    (\"rsplitn\", 2),\n-    (\"split_once\", 1),\n-    (\"rsplit_once\", 1),\n-    (\"matches\", 1),\n-    (\"rmatches\", 1),\n-    (\"match_indices\", 1),\n-    (\"rmatch_indices\", 1),\n-    (\"strip_prefix\", 1),\n-    (\"strip_suffix\", 1),\n-    (\"trim_start_matches\", 1),\n-    (\"trim_end_matches\", 1),\n-    (\"replace\", 1),\n-    (\"replacen\", 1),\n+    (\"contains\", 0),\n+    (\"starts_with\", 0),\n+    (\"ends_with\", 0),\n+    (\"find\", 0),\n+    (\"rfind\", 0),\n+    (\"split\", 0),\n+    (\"split_inclusive\", 0),\n+    (\"rsplit\", 0),\n+    (\"split_terminator\", 0),\n+    (\"rsplit_terminator\", 0),\n+    (\"splitn\", 1),\n+    (\"rsplitn\", 1),\n+    (\"split_once\", 0),\n+    (\"rsplit_once\", 0),\n+    (\"matches\", 0),\n+    (\"rmatches\", 0),\n+    (\"match_indices\", 0),\n+    (\"rmatch_indices\", 0),\n+    (\"strip_prefix\", 0),\n+    (\"strip_suffix\", 0),\n+    (\"trim_start_matches\", 0),\n+    (\"trim_end_matches\", 0),\n+    (\"replace\", 0),\n+    (\"replacen\", 0),\n ];\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n-pub(super) fn check(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    _expr: &hir::Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &hir::Expr<'_>,\n+    args: &[hir::Expr<'_>],\n+) {\n     for &(method, pos) in &PATTERN_METHODS {\n         if_chain! {\n-            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(&args[0]).kind();\n+            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(receiver).kind();\n             if *ty.kind() == ty::Str;\n             if method_name.as_str() == method && args.len() > pos;\n             let arg = &args[pos];"}, {"sha": "9ea6751956abb2c42b1492e917c64eaa36a8617c", "filename": "clippy_lints/src/methods/single_char_push_string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -8,11 +8,11 @@ use rustc_lint::LateContext;\n use super::SINGLE_CHAR_ADD_STR;\n \n /// lint for length-1 `str`s as argument for `push_str`\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, receiver: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let mut applicability = Applicability::MachineApplicable;\n-    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[1], &mut applicability) {\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[0], &mut applicability) {\n         let base_string_snippet =\n-            snippet_with_applicability(cx, args[0].span.source_callsite(), \"..\", &mut applicability);\n+            snippet_with_applicability(cx, receiver.span.source_callsite(), \"..\", &mut applicability);\n         let sugg = format!(\"{}.push({})\", base_string_snippet, extension_string);\n         span_lint_and_sugg(\n             cx,"}, {"sha": "9ca4d65550d3e1d594726005ecf99fd3c84d9a26", "filename": "clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -130,7 +130,7 @@ fn check_manual_split_once_indirect(\n     let ctxt = expr.span.ctxt();\n     let mut parents = cx.tcx.hir().parent_iter(expr.hir_id);\n     if let (_, Node::Local(local)) = parents.next()?\n-        && let PatKind::Binding(BindingAnnotation::Mutable, iter_binding_id, iter_ident, None) = local.pat.kind\n+        && let PatKind::Binding(BindingAnnotation::MUT, iter_binding_id, iter_ident, None) = local.pat.kind\n         && let (iter_stmt_id, Node::Stmt(_)) = parents.next()?\n         && let (_, Node::Block(enclosing_block)) = parents.next()?\n \n@@ -212,11 +212,10 @@ fn indirect_usage<'tcx>(\n     ctxt: SyntaxContext,\n ) -> Option<IndirectUsage<'tcx>> {\n     if let StmtKind::Local(Local {\n-        pat:\n-            Pat {\n-                kind: PatKind::Binding(BindingAnnotation::Unannotated, _, ident, None),\n-                ..\n-            },\n+        pat: Pat {\n+            kind: PatKind::Binding(BindingAnnotation::NONE, _, ident, None),\n+            ..\n+        },\n         init: Some(init_expr),\n         hir_id: local_hir_id,\n         ..\n@@ -292,7 +291,7 @@ fn parse_iter_usage<'tcx>(\n ) -> Option<IterUsage> {\n     let (kind, span) = match iter.next() {\n         Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n-            let (name, args) = if let ExprKind::MethodCall(name, [_, args @ ..], _) = e.kind {\n+            let (name, args) = if let ExprKind::MethodCall(name, _, [args @ ..], _) = e.kind {\n                 (name, args)\n             } else {\n                 return None;\n@@ -327,7 +326,7 @@ fn parse_iter_usage<'tcx>(\n                         } else {\n                             if_chain! {\n                                 if let Some((_, Node::Expr(next_expr))) = iter.next();\n-                                if let ExprKind::MethodCall(next_name, [_], _) = next_expr.kind;\n+                                if let ExprKind::MethodCall(next_name, _, [], _) = next_expr.kind;\n                                 if next_name.ident.name == sym::next;\n                                 if next_expr.span.ctxt() == ctxt;\n                                 if let Some(next_id) = cx.typeck_results().type_dependent_def_id(next_expr.hir_id);\n@@ -367,7 +366,7 @@ fn parse_iter_usage<'tcx>(\n                 }\n             },\n             _ if e.span.ctxt() != ctxt => (None, span),\n-            ExprKind::MethodCall(name, [_], _)\n+            ExprKind::MethodCall(name, _, [], _)\n                 if name.ident.name == sym::unwrap\n                     && cx\n                         .typeck_results()"}, {"sha": "143dcee350521075ee0acd3acd3459107fa02708", "filename": "clippy_lints/src/methods/string_extend_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -16,7 +16,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         return;\n     }\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n-        let target = &arglists[0][0];\n+        let target = &arglists[0].0;\n         let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n         let ref_str = if *self_ty.kind() == ty::Str {\n             \"\""}, {"sha": "851cdf544550f6caf077890c8c3d9f1293058bbd", "filename": "clippy_lints/src/methods/suspicious_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -15,9 +15,9 @@ pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, count_recv: &hi\n         if let Some(def_id) = cx.tcx.hir().opt_local_def_id(closure.hir_id);\n         if let Some(body_id) = cx.tcx.hir().maybe_body_owned_by(def_id);\n         let closure_body = cx.tcx.hir().body(body_id);\n-        if !cx.typeck_results().expr_ty(&closure_body.value).is_unit();\n+        if !cx.typeck_results().expr_ty(closure_body.value).is_unit();\n         then {\n-            if let Some(map_mutated_vars) = mutated_variables(&closure_body.value, cx) {\n+            if let Some(map_mutated_vars) = mutated_variables(closure_body.value, cx) {\n                 // A variable is used mutably inside of the closure. Suppress the lint.\n                 if !map_mutated_vars.is_empty() {\n                     return;"}, {"sha": "4e8c201f470bab9b86fbb2b130ca8af2969f03ef", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -21,22 +21,21 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n     if let hir::ExprKind::Closure(&hir::Closure { body, .. }) = arg.kind {\n         let body = cx.tcx.hir().body(body);\n         let arg_id = body.params[0].pat.hir_id;\n-        let mutates_arg =\n-            mutated_variables(&body.value, cx).map_or(true, |used_mutably| used_mutably.contains(&arg_id));\n-        let (clone_or_copy_needed, _) = clone_or_copy_needed(cx, body.params[0].pat, &body.value);\n+        let mutates_arg = mutated_variables(body.value, cx).map_or(true, |used_mutably| used_mutably.contains(&arg_id));\n+        let (clone_or_copy_needed, _) = clone_or_copy_needed(cx, body.params[0].pat, body.value);\n \n-        let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, &body.value);\n+        let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, body.value);\n \n         let mut return_visitor = ReturnVisitor::new(cx, arg_id);\n-        return_visitor.visit_expr(&body.value);\n+        return_visitor.visit_expr(body.value);\n         found_mapping |= return_visitor.found_mapping;\n         found_filtering |= return_visitor.found_filtering;\n \n         let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n         let sugg = if !found_filtering {\n             if name == \"filter_map\" { \"map\" } else { \"map(..).next()\" }\n         } else if !found_mapping && !mutates_arg && (!clone_or_copy_needed || is_copy(cx, in_ty)) {\n-            match cx.typeck_results().expr_ty(&body.value).kind() {\n+            match cx.typeck_results().expr_ty(body.value).kind() {\n                 ty::Adt(adt, subst)\n                     if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) && in_ty == subst.type_at(0) =>\n                 {"}, {"sha": "c17ef6809f91281aa7ab9490d0092a1f077d8a0f", "filename": "clippy_lints/src/methods/unnecessary_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -31,7 +31,7 @@ pub(super) fn check(\n             // Extract the body of the closure passed to fold\n             if let hir::ExprKind::Closure(&hir::Closure { body, .. }) = acc.kind;\n             let closure_body = cx.tcx.hir().body(body);\n-            let closure_expr = peel_blocks(&closure_body.value);\n+            let closure_expr = peel_blocks(closure_body.value);\n \n             // Check if the closure body is of the form `acc <op> some_expr(x)`\n             if let hir::ExprKind::Binary(ref bin_op, left_expr, right_expr) = closure_expr.kind;"}, {"sha": "95138c0e25b034a088447c327bda976b0a15b3e4", "filename": "clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -43,7 +43,7 @@ pub fn check_for_loop_iter(\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n             let snippet = if_chain! {\n-                if let ExprKind::MethodCall(maybe_iter_method_name, [collection], _) = receiver.kind;\n+                if let ExprKind::MethodCall(maybe_iter_method_name, collection, [], _) = receiver.kind;\n                 if maybe_iter_method_name.ident.name == sym::iter;\n \n                 if let Some(iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);"}, {"sha": "a187a8d6016f871325c2d58ca803d19add8ca842", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -54,7 +54,7 @@ pub(super) fn check<'tcx>(\n                 // This is a duplicate of what's happening in clippy_lints::methods::method_call,\n                 // which isn't ideal, We want to get the method call span,\n                 // but prefer to avoid changing the signature of the function itself.\n-                if let hir::ExprKind::MethodCall(_, _, span) = expr.kind {\n+                if let hir::ExprKind::MethodCall(.., span) = expr.kind {\n                     span_lint_and_then(cx, UNNECESSARY_LAZY_EVALUATIONS, expr.span, msg, |diag| {\n                         diag.span_suggestion(\n                             span,"}, {"sha": "ed5a75b0f3ce574ee50790436ef6704d6323bbe0", "filename": "clippy_lints/src/methods/unnecessary_sort_by.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -50,9 +50,13 @@ fn mirrored_exprs(a_expr: &Expr<'_>, a_ident: &Ident, b_expr: &Expr<'_>, b_ident\n         // The two exprs are method calls.\n         // Check to see that the function is the same and the arguments are mirrored\n         // This is enough because the receiver of the method is listed in the arguments\n-        (ExprKind::MethodCall(left_segment, left_args, _), ExprKind::MethodCall(right_segment, right_args, _)) => {\n+        (\n+            ExprKind::MethodCall(left_segment, left_receiver, left_args, _),\n+            ExprKind::MethodCall(right_segment, right_receiver, right_args, _),\n+        ) => {\n             left_segment.ident == right_segment.ident\n                 && iter::zip(*left_args, *right_args).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n+                && mirrored_exprs(left_receiver, a_ident, right_receiver, b_ident)\n         },\n         // Two tuples with mirrored contents\n         (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs)) => {\n@@ -125,9 +129,9 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg: &Exp\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},\n             Param { pat: Pat { kind: PatKind::Binding(_, _, right_ident, _), .. }, .. }\n         ] = &closure_body.params;\n-        if let ExprKind::MethodCall(method_path, [left_expr, right_expr], _) = closure_body.value.kind;\n+        if let ExprKind::MethodCall(method_path, left_expr, [right_expr], _) = closure_body.value.kind;\n         if method_path.ident.name == sym::cmp;\n-        if is_trait_method(cx, &closure_body.value, sym::Ord);\n+        if is_trait_method(cx, closure_body.value, sym::Ord);\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n                 left_expr,"}, {"sha": "763bfafecef14916ebbccec2203d4c569eabed9a", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -28,12 +28,13 @@ pub fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'tcx>,\n     method_name: Symbol,\n-    args: &'tcx [Expr<'tcx>],\n+    receiver: &'tcx Expr<'_>,\n+    args: &'tcx [Expr<'_>],\n     msrv: Option<RustcVersion>,\n ) {\n     if_chain! {\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-        if let [receiver] = args;\n+        if args.is_empty();\n         then {\n             if is_cloned_or_copied(cx, method_name, method_def_id) {\n                 unnecessary_iter_cloned::check(cx, expr, method_name, receiver);\n@@ -249,9 +250,9 @@ fn check_other_call_arg<'tcx>(\n ) -> bool {\n     if_chain! {\n         if let Some((maybe_call, maybe_arg)) = skip_addr_of_ancestors(cx, expr);\n-        if let Some((callee_def_id, _, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n+        if let Some((callee_def_id, _, recv, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n         let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n-        if let Some(i) = call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id);\n+        if let Some(i) = recv.into_iter().chain(call_args).position(|arg| arg.hir_id == maybe_arg.hir_id);\n         if let Some(input) = fn_sig.inputs().get(i);\n         let (input, n_refs) = peel_mid_ty_refs(*input);\n         if let (trait_predicates, _) = get_input_traits_and_projections(cx, callee_def_id, input);\n@@ -307,22 +308,22 @@ fn skip_addr_of_ancestors<'tcx>(\n fn get_callee_substs_and_args<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'tcx>,\n-) -> Option<(DefId, SubstsRef<'tcx>, &'tcx [Expr<'tcx>])> {\n+) -> Option<(DefId, SubstsRef<'tcx>, Option<&'tcx Expr<'tcx>>, &'tcx [Expr<'tcx>])> {\n     if_chain! {\n         if let ExprKind::Call(callee, args) = expr.kind;\n         let callee_ty = cx.typeck_results().expr_ty(callee);\n         if let ty::FnDef(callee_def_id, _) = callee_ty.kind();\n         then {\n             let substs = cx.typeck_results().node_substs(callee.hir_id);\n-            return Some((*callee_def_id, substs, args));\n+            return Some((*callee_def_id, substs, None, args));\n         }\n     }\n     if_chain! {\n-        if let ExprKind::MethodCall(_, args, _) = expr.kind;\n+        if let ExprKind::MethodCall(_, recv, args, _) = expr.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         then {\n             let substs = cx.typeck_results().node_substs(expr.hir_id);\n-            return Some((method_def_id, substs, args));\n+            return Some((method_def_id, substs, Some(recv), args));\n         }\n     }\n     None\n@@ -377,9 +378,10 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n                 }\n             }\n             Node::Expr(parent_expr) => {\n-                if let Some((callee_def_id, call_substs, call_args)) = get_callee_substs_and_args(cx, parent_expr) {\n+                if let Some((callee_def_id, call_substs, recv, call_args)) = get_callee_substs_and_args(cx, parent_expr)\n+                {\n                     let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n-                    if let Some(arg_index) = call_args.iter().position(|arg| arg.hir_id == expr.hir_id)\n+                    if let Some(arg_index) = recv.into_iter().chain(call_args).position(|arg| arg.hir_id == expr.hir_id)\n                         && let Some(param_ty) = fn_sig.inputs().get(arg_index)\n                         && let ty::Param(ParamTy { index: param_index , ..}) = param_ty.kind()\n                     {"}, {"sha": "045f739e64ded7db0b2a352287eb394ca45d8956", "filename": "clippy_lints/src/methods/unwrap_or_else_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funwrap_or_else_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Funwrap_or_else_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funwrap_or_else_default.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -52,7 +52,7 @@ fn closure_body_returns_empty_to_string(cx: &LateContext<'_>, e: &hir::Expr<'_>)\n \n         if body.params.is_empty()\n             && let hir::Expr{ kind, .. } = &body.value\n-            && let hir::ExprKind::MethodCall(hir::PathSegment {ident, ..}, [self_arg], _) = kind\n+            && let hir::ExprKind::MethodCall(hir::PathSegment {ident, ..}, self_arg, _, _) = kind\n             && ident == &symbol::Ident::from_str(\"to_string\")\n             && let hir::Expr{ kind, .. } = self_arg\n             && let hir::ExprKind::Lit(lit) = kind"}, {"sha": "ae6b165fdc36650d8517e9d2b1f450a934ecc0b3", "filename": "clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -28,7 +28,7 @@ pub(super) fn derefs_to_slice<'tcx>(\n         }\n     }\n \n-    if let hir::ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind {\n+    if let hir::ExprKind::MethodCall(path, self_arg, ..) = &expr.kind {\n         if path.ident.name == sym::iter && may_slice(cx, cx.typeck_results().expr_ty(self_arg)) {\n             Some(self_arg)\n         } else {\n@@ -139,9 +139,9 @@ impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n                         self.addr_of_exprs.push(parent);\n                         return;\n                     },\n-                    ExprKind::MethodCall(_, args, _) => {\n+                    ExprKind::MethodCall(.., args, _) => {\n                         if_chain! {\n-                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n+                            if args.iter().all(|arg| !self.is_binding(arg));\n                             if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n                             let method_ty = self.cx.tcx.type_of(method_def_id);\n                             let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();"}, {"sha": "4d8579135fc061279efa57bdf4b9e83c8adf1568", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::{match_trait_method, paths};\n-use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -75,45 +74,49 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n                     .qpath_res(qpath, path.hir_id)\n                     .opt_def_id()\n                     .and_then(|def_id| match cx.tcx.get_diagnostic_name(def_id) {\n-                        Some(sym::cmp_min) => fetch_const(cx, args, MinMax::Min),\n-                        Some(sym::cmp_max) => fetch_const(cx, args, MinMax::Max),\n+                        Some(sym::cmp_min) => fetch_const(cx, None, args, MinMax::Min),\n+                        Some(sym::cmp_max) => fetch_const(cx, None, args, MinMax::Max),\n                         _ => None,\n                     })\n             } else {\n                 None\n             }\n         },\n-        ExprKind::MethodCall(path, args, _) => {\n-            if_chain! {\n-                if let [obj, _] = args;\n-                if cx.typeck_results().expr_ty(obj).is_floating_point() || match_trait_method(cx, expr, &paths::ORD);\n-                then {\n-                    if path.ident.name == sym!(max) {\n-                        fetch_const(cx, args, MinMax::Max)\n-                    } else if path.ident.name == sym!(min) {\n-                        fetch_const(cx, args, MinMax::Min)\n-                    } else {\n-                        None\n-                    }\n+        ExprKind::MethodCall(path, receiver, args @ [_], _) => {\n+            if cx.typeck_results().expr_ty(receiver).is_floating_point() || match_trait_method(cx, expr, &paths::ORD) {\n+                if path.ident.name == sym!(max) {\n+                    fetch_const(cx, Some(receiver), args, MinMax::Max)\n+                } else if path.ident.name == sym!(min) {\n+                    fetch_const(cx, Some(receiver), args, MinMax::Min)\n                 } else {\n                     None\n                 }\n+            } else {\n+                None\n             }\n         },\n         _ => None,\n     }\n }\n \n-fn fetch_const<'a>(cx: &LateContext<'_>, args: &'a [Expr<'a>], m: MinMax) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n-    if args.len() != 2 {\n+fn fetch_const<'a>(\n+    cx: &LateContext<'_>,\n+    receiver: Option<&'a Expr<'a>>,\n+    args: &'a [Expr<'a>],\n+    m: MinMax,\n+) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n+    let mut args = receiver.into_iter().chain(args);\n+    let first_arg = args.next()?;\n+    let second_arg = args.next()?;\n+    if args.next().is_some() {\n         return None;\n     }\n-    constant_simple(cx, cx.typeck_results(), &args[0]).map_or_else(\n-        || constant_simple(cx, cx.typeck_results(), &args[1]).map(|c| (m, c, &args[0])),\n+    constant_simple(cx, cx.typeck_results(), first_arg).map_or_else(\n+        || constant_simple(cx, cx.typeck_results(), second_arg).map(|c| (m, c, first_arg)),\n         |c| {\n-            if constant_simple(cx, cx.typeck_results(), &args[1]).is_none() {\n+            if constant_simple(cx, cx.typeck_results(), second_arg).is_none() {\n                 // otherwise ignore\n-                Some((m, c, &args[1]))\n+                Some((m, c, second_arg))\n             } else {\n                 None\n             }"}, {"sha": "ea245edd77040688400d3810e3e10b668fcac282", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -5,8 +5,8 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n-    self as hir, def, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind, Stmt,\n-    StmtKind, TyKind,\n+    self as hir, def, BinOpKind, BindingAnnotation, Body, ByRef, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind,\n+    Stmt, StmtKind, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n@@ -146,7 +146,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             return;\n         }\n         for arg in iter_input_pats(decl, body) {\n-            if let PatKind::Binding(BindingAnnotation::Ref | BindingAnnotation::RefMut, ..) = arg.pat.kind {\n+            if let PatKind::Binding(BindingAnnotation(ByRef::Yes, _), ..) = arg.pat.kind {\n                 span_lint(\n                     cx,\n                     TOPLEVEL_REF_ARG,\n@@ -162,9 +162,8 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n         if_chain! {\n             if !in_external_macro(cx.tcx.sess, stmt.span);\n             if let StmtKind::Local(local) = stmt.kind;\n-            if let PatKind::Binding(an, .., name, None) = local.pat.kind;\n+            if let PatKind::Binding(BindingAnnotation(ByRef::Yes, mutabl), .., name, None) = local.pat.kind;\n             if let Some(init) = local.init;\n-            if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut;\n             then {\n                 // use the macro callsite when the init span (but not the whole local span)\n                 // comes from an expansion like `vec![1, 2, 3]` in `let ref _ = vec![1, 2, 3];`\n@@ -173,7 +172,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                 } else {\n                     Sugg::hir(cx, init, \"..\")\n                 };\n-                let (mutopt, initref) = if an == BindingAnnotation::RefMut {\n+                let (mutopt, initref) = if mutabl == Mutability::Mut {\n                     (\"mut \", sugg_init.mut_addr())\n                 } else {\n                     (\"\", sugg_init.addr())"}, {"sha": "d7bb0616acb0ba4aba14a2af50eb13263eeb70a1", "filename": "clippy_lints/src/misc_early/redundant_pattern.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmisc_early%2Fredundant_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmisc_early%2Fredundant_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fredundant_pattern.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -1,18 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use rustc_ast::ast::{BindingMode, Mutability, Pat, PatKind};\n+use rustc_ast::ast::{Pat, PatKind};\n use rustc_errors::Applicability;\n use rustc_lint::EarlyContext;\n \n use super::REDUNDANT_PATTERN;\n \n pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n-    if let PatKind::Ident(left, ident, Some(ref right)) = pat.kind {\n-        let left_binding = match left {\n-            BindingMode::ByRef(Mutability::Mut) => \"ref mut \",\n-            BindingMode::ByRef(Mutability::Not) => \"ref \",\n-            BindingMode::ByValue(..) => \"\",\n-        };\n-\n+    if let PatKind::Ident(ann, ident, Some(ref right)) = pat.kind {\n         if let PatKind::Wild = right.kind {\n             span_lint_and_sugg(\n                 cx,\n@@ -23,7 +17,7 @@ pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n                     ident.name, ident.name,\n                 ),\n                 \"try\",\n-                format!(\"{}{}\", left_binding, ident.name),\n+                format!(\"{}{}\", ann.prefix_str(), ident.name),\n                 Applicability::MachineApplicable,\n             );\n         }"}, {"sha": "82dc03ef5c5bce3c264c505ef9ff5b5075a115b4", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -43,18 +43,24 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n                 if let ExprKind::Path(ref path) = fn_expr.kind {\n                     check_arguments(\n                         cx,\n-                        arguments,\n+                        arguments.iter().collect(),\n                         cx.typeck_results().expr_ty(fn_expr),\n                         &rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false)),\n                         \"function\",\n                     );\n                 }\n             },\n-            ExprKind::MethodCall(path, arguments, _) => {\n+            ExprKind::MethodCall(path, receiver, arguments, _) => {\n                 let def_id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n                 let substs = cx.typeck_results().node_substs(e.hir_id);\n                 let method_type = cx.tcx.bound_type_of(def_id).subst(cx.tcx, substs);\n-                check_arguments(cx, arguments, method_type, path.ident.as_str(), \"method\");\n+                check_arguments(\n+                    cx,\n+                    std::iter::once(receiver).chain(arguments.iter()).collect(),\n+                    method_type,\n+                    path.ident.as_str(),\n+                    \"method\",\n+                );\n             },\n             _ => (),\n         }\n@@ -63,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n \n fn check_arguments<'tcx>(\n     cx: &LateContext<'tcx>,\n-    arguments: &[Expr<'_>],\n+    arguments: Vec<&Expr<'_>>,\n     type_definition: Ty<'tcx>,\n     name: &str,\n     fn_kind: &str,"}, {"sha": "f2ffac85bf4023cc25368595e239b84c7383f7e9", "filename": "clippy_lints/src/needless_arbitrary_self_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use if_chain::if_chain;\n-use rustc_ast::ast::{BindingMode, Lifetime, Mutability, Param, PatKind, Path, TyKind};\n+use rustc_ast::ast::{BindingAnnotation, ByRef, Lifetime, Mutability, Param, PatKind, Path, TyKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -120,14 +120,14 @@ impl EarlyLintPass for NeedlessArbitrarySelfType {\n \n         match &p.ty.kind {\n             TyKind::Path(None, path) => {\n-                if let PatKind::Ident(BindingMode::ByValue(mutbl), _, _) = p.pat.kind {\n+                if let PatKind::Ident(BindingAnnotation(ByRef::No, mutbl), _, _) = p.pat.kind {\n                     check_param_inner(cx, path, p.span.to(p.ty.span), &Mode::Value, mutbl);\n                 }\n             },\n             TyKind::Rptr(lifetime, mut_ty) => {\n                 if_chain! {\n                 if let TyKind::Path(None, path) = &mut_ty.ty.kind;\n-                if let PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, _) = p.pat.kind;\n+                if let PatKind::Ident(BindingAnnotation::NONE, _, _) = p.pat.kind;\n                     then {\n                         check_param_inner(cx, path, p.span.to(p.ty.span), &Mode::Ref(*lifetime), mut_ty.mutbl);\n                     }"}, {"sha": "b8855e5adbff4c11c6b17a7176c0857372e4dfda", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n             if let PatKind::Ref(sub_pat, Mutability::Not) = pat.kind;\n \n             // Check sub_pat got a `ref` keyword (excluding `ref mut`).\n-            if let PatKind::Binding(BindingAnnotation::Ref, .., spanned_name, _) = sub_pat.kind;\n+            if let PatKind::Binding(BindingAnnotation::REF, .., spanned_name, _) = sub_pat.kind;\n             let parent_id = cx.tcx.hir().get_parent_node(pat.hir_id);\n             if let Some(parent_node) = cx.tcx.hir().find(parent_id);\n             then {"}, {"sha": "3233d87c073193f99a0046745ff49c603f7576a5", "filename": "clippy_lints/src/needless_for_each.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -56,12 +56,12 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessForEach {\n \n         if_chain! {\n             // Check the method name is `for_each`.\n-            if let ExprKind::MethodCall(method_name, [for_each_recv, for_each_arg], _) = expr.kind;\n+            if let ExprKind::MethodCall(method_name, for_each_recv, [for_each_arg], _) = expr.kind;\n             if method_name.ident.name == Symbol::intern(\"for_each\");\n             // Check `for_each` is an associated function of `Iterator`.\n             if is_trait_method(cx, expr, sym::Iterator);\n             // Checks the receiver of `for_each` is also a method call.\n-            if let ExprKind::MethodCall(_, [iter_recv], _) = for_each_recv.kind;\n+            if let ExprKind::MethodCall(_, iter_recv, [], _) = for_each_recv.kind;\n             // Skip the lint if the call chain is too long. e.g. `v.field.iter().for_each()` or\n             // `v.foo().iter().for_each()` must be skipped.\n             if matches!(\n@@ -77,7 +77,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessForEach {\n             if let ExprKind::Block(..) = body.value.kind;\n             then {\n                 let mut ret_collector = RetCollector::default();\n-                ret_collector.visit_expr(&body.value);\n+                ret_collector.visit_expr(body.value);\n \n                 // Skip the lint if `return` is used in `Loop` in order not to suggest using `'label`.\n                 if ret_collector.ret_in_loop {"}, {"sha": "de99f1d7078e97eb40fd1030376f9c179c26bf75", "filename": "clippy_lints/src/needless_late_init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_late_init.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -373,7 +373,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessLateInit {\n             if let Local {\n                 init: None,\n                 pat: &Pat {\n-                    kind: PatKind::Binding(BindingAnnotation::Unannotated, binding_id, _, None),\n+                    kind: PatKind::Binding(BindingAnnotation::NONE, binding_id, _, None),\n                     ..\n                 },\n                 source: LocalSource::Normal,"}, {"sha": "6d17c7a7346f3994fc99e74cd8d6d002dc3f16bf", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -8,7 +8,9 @@ use rustc_ast::ast::Attribute;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{BindingAnnotation, Body, FnDecl, GenericArg, HirId, Impl, ItemKind, Node, PatKind, QPath, TyKind};\n+use rustc_hir::{\n+    BindingAnnotation, Body, FnDecl, GenericArg, HirId, Impl, ItemKind, Mutability, Node, PatKind, QPath, TyKind,\n+};\n use rustc_hir::{HirIdMap, HirIdSet};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -188,13 +190,9 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;\n \n-                if let PatKind::Binding(mode, canonical_id, ..) = arg.pat.kind;\n+                if let PatKind::Binding(BindingAnnotation(_, Mutability::Not), canonical_id, ..) = arg.pat.kind;\n                 if !moved_vars.contains(&canonical_id);\n                 then {\n-                    if mode == BindingAnnotation::Mutable || mode == BindingAnnotation::RefMut {\n-                        continue;\n-                    }\n-\n                     // Dereference suggestion\n                     let sugg = |diag: &mut Diagnostic| {\n                         if let ty::Adt(def, ..) = ty.kind() {"}, {"sha": "25fb4f0f4cff199ed2aa961faad136b0e533e1d0", "filename": "clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -43,7 +43,7 @@ declare_lint_pass!(NonOctalUnixPermissions => [NON_OCTAL_UNIX_PERMISSIONS]);\n impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         match &expr.kind {\n-            ExprKind::MethodCall(path, [func, param], _) => {\n+            ExprKind::MethodCall(path, func, [param], _) => {\n                 let obj_ty = cx.typeck_results().expr_ty(func).peel_refs();\n \n                 if_chain! {"}, {"sha": "6217110a1f3aee8253704a06c8894757fd54ed51", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::ty::{self, ConstKind};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n+use std::iter;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -296,13 +297,13 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n                             }\n                             return;\n                         },\n-                        ExprKind::MethodCall(_, args, _)\n+                        ExprKind::MethodCall(_, receiver, args, _)\n                             if typeck.type_dependent_def_id(parent.hir_id).map_or(false, |id| {\n                                 id == param.fn_id\n                                     && has_matching_substs(param.fn_kind, typeck.node_substs(parent.hir_id))\n                             }) =>\n                         {\n-                            if let Some(idx) = args.iter().position(|arg| arg.hir_id == child_id) {\n+                            if let Some(idx) = iter::once(receiver).chain(args).position(|arg| arg.hir_id == child_id) {\n                                 param.uses.push(Usage::new(span, idx));\n                             }\n                             return;"}, {"sha": "638a514ff9b361f7e33e3bc02d86f25e3214688f", "filename": "clippy_lints/src/operators/cmp_owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -38,7 +38,7 @@ fn symmetric_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'t\n fn check_op(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n     let typeck = cx.typeck_results();\n     let (arg, arg_span) = match expr.kind {\n-        ExprKind::MethodCall(.., [arg], _)\n+        ExprKind::MethodCall(_, arg, [], _)\n             if typeck\n                 .type_dependent_def_id(expr.hir_id)\n                 .and_then(|id| cx.tcx.trait_of_item(id))"}, {"sha": "827a2b26709350dc1ad9ceb3f678cca5ab26a82d", "filename": "clippy_lints/src/operators/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -17,7 +17,7 @@ pub(crate) fn check<'tcx>(\n     right: &'tcx Expr<'_>,\n ) {\n     if op == BinOpKind::Div\n-        && let ExprKind::MethodCall(method_path, [self_arg], _) = left.kind\n+        && let ExprKind::MethodCall(method_path, self_arg, [], _) = left.kind\n         && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_arg).peel_refs(), sym::Duration)\n         && let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right)\n     {"}, {"sha": "97ddcdb24799d12ac2a73d9202a2b724b6249fb4", "filename": "clippy_lints/src/operators/float_cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -113,7 +113,7 @@ fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     }\n \n     if_chain! {\n-        if let ExprKind::MethodCall(method_name, [ref self_arg, ..], _) = expr.kind;\n+        if let ExprKind::MethodCall(method_name, self_arg, ..) = expr.kind;\n         if sym!(signum) == method_name.ident.name;\n         // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n         // the method call)"}, {"sha": "1085e608944154beed10801798f9aa684a3fe643", "filename": "clippy_lints/src/operators/op_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fop_ref.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -185,7 +185,7 @@ fn in_impl<'tcx>(\n         if let ItemKind::Impl(item) = &item.kind;\n         if let Some(of_trait) = &item.of_trait;\n         if let Some(seg) = of_trait.path.segments.last();\n-        if let Some(Res::Def(_, trait_id)) = seg.res;\n+        if let Res::Def(_, trait_id) = seg.res;\n         if trait_id == bin_op;\n         if let Some(generic_args) = seg.args;\n         if let Some(GenericArg::Type(other_ty)) = generic_args.args.last();"}, {"sha": "0315678bf97a96c1ef6fcd58e59df3c7b4b5342d", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -130,15 +130,15 @@ fn try_get_option_occurence<'tcx>(\n             .filter_map(|(id, &c)| none_captures.get(id).map(|&c2| (c, c2)))\n             .all(|(x, y)| x.is_imm_ref() && y.is_imm_ref());\n         then {\n-            let capture_mut = if bind_annotation == BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n+            let capture_mut = if bind_annotation == BindingAnnotation::MUT { \"mut \" } else { \"\" };\n             let some_body = peel_blocks(if_then);\n             let none_body = peel_blocks(if_else);\n             let method_sugg = if eager_or_lazy::switch_to_eager_eval(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n             let (as_ref, as_mut) = match &expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n                 ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n-                _ => (bind_annotation == BindingAnnotation::Ref, bind_annotation == BindingAnnotation::RefMut),\n+                _ => (bind_annotation == BindingAnnotation::REF, bind_annotation == BindingAnnotation::REF_MUT),\n             };\n \n             // Check if captures the closure will need conflict with borrows made in the scrutinee."}, {"sha": "4aa0d9227abadd80aba8b0811f8f893e0a7965ac", "filename": "clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -69,7 +69,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, body: &'tcx hir\n         }\n         true\n     })\n-    .visit_expr(&body.value);\n+    .visit_expr(body.value);\n     if !panics.is_empty() {\n         span_lint_and_then(\n             cx,"}, {"sha": "0960b050c240e37553be6b96824f26b2d09983fd", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -221,7 +221,7 @@ impl<'tcx> PassByRefOrValue {\n                     // if function has a body and parameter is annotated with mut, ignore\n                     if let Some(param) = fn_body.and_then(|body| body.params.get(index)) {\n                         match param.pat.kind {\n-                            PatKind::Binding(BindingAnnotation::Unannotated, _, _, _) => {},\n+                            PatKind::Binding(BindingAnnotation::NONE, _, _, _) => {},\n                             _ => continue,\n                         }\n                     }"}, {"sha": "41d1baba64f851ffa6409bef6e1c6f3f62575ca4", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -507,7 +507,7 @@ fn check_mut_from_ref<'tcx>(cx: &LateContext<'tcx>, sig: &FnSig<'_>, body: Optio\n         if let Some(args) = args\n             && !args.is_empty()\n             && body.map_or(true, |body| {\n-                sig.header.unsafety == Unsafety::Unsafe || contains_unsafe_block(cx, &body.value)\n+                sig.header.unsafety == Unsafety::Unsafe || contains_unsafe_block(cx, body.value)\n             })\n         {\n             span_lint_and_then(\n@@ -571,7 +571,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                 Some((Node::Stmt(_), _)) => (),\n                 Some((Node::Local(l), _)) => {\n                     // Only trace simple bindings. e.g `let x = y;`\n-                    if let PatKind::Binding(BindingAnnotation::Unannotated, id, _, None) = l.pat.kind {\n+                    if let PatKind::Binding(BindingAnnotation::NONE, id, _, None) = l.pat.kind {\n                         self.bindings.insert(id, args_idx);\n                     } else {\n                         set_skip_flag();\n@@ -591,8 +591,11 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                             set_skip_flag();\n                         }\n                     },\n-                    ExprKind::MethodCall(name, expr_args @ [self_arg, ..], _) => {\n-                        let i = expr_args.iter().position(|arg| arg.hir_id == child_id).unwrap_or(0);\n+                    ExprKind::MethodCall(name, self_arg, expr_args, _) => {\n+                        let i = std::iter::once(self_arg)\n+                            .chain(expr_args.iter())\n+                            .position(|arg| arg.hir_id == child_id)\n+                            .unwrap_or(0);\n                         if i == 0 {\n                             // Check if the method can be renamed.\n                             let name = name.ident.as_str();\n@@ -644,7 +647,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n             .filter_map(|(i, arg)| {\n                 let param = &body.params[arg.idx];\n                 match param.pat.kind {\n-                    PatKind::Binding(BindingAnnotation::Unannotated, id, _, None)\n+                    PatKind::Binding(BindingAnnotation::NONE, id, _, None)\n                         if !is_lint_allowed(cx, PTR_ARG, param.hir_id) =>\n                     {\n                         Some((id, i))\n@@ -661,7 +664,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n         results,\n         skip_count,\n     };\n-    v.visit_expr(&body.value);\n+    v.visit_expr(body.value);\n     v.results\n }\n "}, {"sha": "4dc65da3ea1fd9fd8227823a0ce416c6c573a466", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -93,7 +93,7 @@ fn expr_as_ptr_offset_call<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n ) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, Method)> {\n-    if let ExprKind::MethodCall(path_segment, [arg_0, arg_1, ..], _) = &expr.kind {\n+    if let ExprKind::MethodCall(path_segment, arg_0, [arg_1, ..], _) = &expr.kind {\n         if is_expr_ty_raw_ptr(cx, arg_0) {\n             if path_segment.ident.name == sym::offset {\n                 return Some((arg_0, arg_1, Method::Offset));"}, {"sha": "f4f1fd336df7cc81c4a60786da7e95ccb5ed85bb", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -9,7 +9,7 @@ use clippy_utils::{\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n-use rustc_hir::{BindingAnnotation, Expr, ExprKind, Node, PatKind, PathSegment, QPath};\n+use rustc_hir::{BindingAnnotation, ByRef, Expr, ExprKind, Node, PatKind, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::Ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -86,7 +86,7 @@ fn check_is_none_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr: &Ex\n     if_chain! {\n         if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n         if !is_else_clause(cx.tcx, expr);\n-        if let ExprKind::MethodCall(segment, [caller, ..], _) = &cond.kind;\n+        if let ExprKind::MethodCall(segment, caller, ..) = &cond.kind;\n         let caller_ty = cx.typeck_results().expr_ty(caller);\n         let if_block = IfBlockType::IfIs(caller, caller_ty, segment.ident.name, then, r#else);\n         if is_early_return(sym::Option, cx, &if_block) || is_early_return(sym::Result, cx, &if_block);\n@@ -123,7 +123,7 @@ fn check_if_let_some_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr:\n         if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else }) = higher::IfLet::hir(cx, expr);\n         if !is_else_clause(cx.tcx, expr);\n         if let PatKind::TupleStruct(ref path1, [field], None) = let_pat.kind;\n-        if let PatKind::Binding(annot, bind_id, ident, None) = field.kind;\n+        if let PatKind::Binding(BindingAnnotation(by_ref, _), bind_id, ident, None) = field.kind;\n         let caller_ty = cx.typeck_results().expr_ty(let_expr);\n         let if_block = IfBlockType::IfLet(path1, caller_ty, ident.name, let_expr, if_then, if_else);\n         if (is_early_return(sym::Option, cx, &if_block) && path_to_local_id(peel_blocks(if_then), bind_id))\n@@ -132,12 +132,11 @@ fn check_if_let_some_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr:\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n-            let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n             let requires_semi = matches!(get_parent_node(cx.tcx, expr.hir_id), Some(Node::Stmt(_)));\n             let sugg = format!(\n                 \"{}{}?{}\",\n                 receiver_str,\n-                if by_ref { \".as_ref()\" } else { \"\" },\n+                if by_ref == ByRef::Yes { \".as_ref()\" } else { \"\" },\n                 if requires_semi { \";\" } else { \"\" }\n             );\n             span_lint_and_sugg("}, {"sha": "94dec191103c587d02a2bc8501cfc0ac02cc0bb1", "filename": "clippy_lints/src/read_zero_byte_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fread_zero_byte_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fread_zero_byte_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fread_zero_byte_vec.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for ReadZeroByteVec {\n                 // finds use of `_.read(&mut v)`\n                 let mut read_found = false;\n                 let mut visitor = expr_visitor_no_bodies(|expr| {\n-                    if let ExprKind::MethodCall(path, [_self, arg], _) = expr.kind\n+                    if let ExprKind::MethodCall(path, _self, [arg], _) = expr.kind\n                         && let PathSegment { ident: read_or_read_exact, .. } = *path\n                         && matches!(read_or_read_exact.as_str(), \"read\" | \"read_exact\")\n                         && let ExprKind::AddrOf(_, hir::Mutability::Mut, inner) = arg.kind"}, {"sha": "9fd86331ec755d8fbeafb87bce01d4f98f4786af", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n             vis.into_map(cx, maybe_storage_live_result)\n         };\n \n-        for (bb, bbdata) in mir.basic_blocks().iter_enumerated() {\n+        for (bb, bbdata) in mir.basic_blocks.iter_enumerated() {\n             let terminator = bbdata.terminator();\n \n             if terminator.source_info.span.from_expansion() {\n@@ -186,7 +186,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                     unwrap_or_continue!(find_stmt_assigns_to(cx, mir, pred_arg, true, ps[0]));\n                 let loc = mir::Location {\n                     block: bb,\n-                    statement_index: mir.basic_blocks()[bb].statements.len(),\n+                    statement_index: mir.basic_blocks[bb].statements.len(),\n                 };\n \n                 // This can be turned into `res = move local` if `arg` and `cloned` are not borrowed\n@@ -310,7 +310,7 @@ fn find_stmt_assigns_to<'tcx>(\n     by_ref: bool,\n     bb: mir::BasicBlock,\n ) -> Option<(mir::Local, CannotMoveOut)> {\n-    let rvalue = mir.basic_blocks()[bb].statements.iter().rev().find_map(|stmt| {\n+    let rvalue = mir.basic_blocks[bb].statements.iter().rev().find_map(|stmt| {\n         if let mir::StatementKind::Assign(box (mir::Place { local, .. }, v)) = &stmt.kind {\n             return if *local == to_local { Some(v) } else { None };\n         }"}, {"sha": "42514f861be1c25f33bcca47ef88ac7a2cef5b47", "filename": "clippy_lints/src/ref_option_ref.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fref_option_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fref_option_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fref_option_ref.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -43,8 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for RefOptionRef {\n             if mut_ty.mutbl == Mutability::Not;\n             if let TyKind::Path(ref qpath) = &mut_ty.ty.kind;\n             let last = last_path_segment(qpath);\n-            if let Some(res) = last.res;\n-            if let Some(def_id) = res.opt_def_id();\n+            if let Some(def_id) = last.res.opt_def_id();\n \n             if cx.tcx.is_diagnostic_item(sym::Option, def_id);\n             if let Some(params) = last_path_segment(qpath).args ;"}, {"sha": "91553240e3c910fa4a25d4222a9c315a6ca0dad3", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n                 } else {\n                     RetReplacement::Empty\n                 };\n-                check_final_expr(cx, &body.value, Some(body.value.span), replacement);\n+                check_final_expr(cx, body.value, Some(body.value.span), replacement);\n             },\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n                 if let ExprKind::Block(block, _) = body.value.kind {"}, {"sha": "ac4e29e9dfdfa0f5d5c95b93b2b6883284aeb757", "filename": "clippy_lints/src/size_of_in_element_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -108,7 +108,7 @@ fn get_pointee_ty_and_count_expr<'tcx>(\n     };\n     if_chain! {\n         // Find calls to copy_{from,to}{,_nonoverlapping} and write_bytes methods\n-        if let ExprKind::MethodCall(method_path, [ptr_self, .., count], _) = expr.kind;\n+        if let ExprKind::MethodCall(method_path, ptr_self, [.., count], _) = expr.kind;\n         let method_ident = method_path.ident.as_str();\n         if METHODS.iter().any(|m| *m == method_ident);\n "}, {"sha": "c07aa00a12789af66d57b26093c4839347c80d80", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -99,7 +99,7 @@ impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n         // Matches statements which initializes vectors. For example: `let mut vec = Vec::with_capacity(10)`\n         if_chain! {\n             if let StmtKind::Local(local) = stmt.kind;\n-            if let PatKind::Binding(BindingAnnotation::Mutable, local_id, _, None) = local.pat.kind;\n+            if let PatKind::Binding(BindingAnnotation::MUT, local_id, _, None) = local.pat.kind;\n             if let Some(init) = local.init;\n             if let Some(len_arg) = Self::is_vec_with_capacity(cx, init);\n \n@@ -201,7 +201,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_extend_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(path, [self_arg, extend_arg], _) = expr.kind;\n+            if let ExprKind::MethodCall(path, self_arg, [extend_arg], _) = expr.kind;\n             if path_to_local_id(self_arg, self.vec_alloc.local_id);\n             if path.ident.name == sym!(extend);\n             if self.is_repeat_take(extend_arg);\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Checks if the given expression is resizing a vector with 0\n     fn search_slow_resize_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if self.initialization_found\n-            && let ExprKind::MethodCall(path, [self_arg, len_arg, fill_arg], _) = expr.kind\n+            && let ExprKind::MethodCall(path, self_arg, [len_arg, fill_arg], _) = expr.kind\n             && path_to_local_id(self_arg, self.vec_alloc.local_id)\n             && path.ident.name == sym!(resize)\n             // Check that is filled with 0\n@@ -224,7 +224,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n                 // Check that len expression is equals to `with_capacity` expression\n                 if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr) {\n                     self.slow_expression = Some(InitializationType::Resize(expr));\n-                } else if let ExprKind::MethodCall(path, _, _) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n+                } else if let ExprKind::MethodCall(path, ..) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n                     self.slow_expression = Some(InitializationType::Resize(expr));\n                 }\n             }\n@@ -233,15 +233,15 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Returns `true` if give expression is `repeat(0).take(...)`\n     fn is_repeat_take(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n-            if let ExprKind::MethodCall(take_path, [recv, len_arg, ..], _) = expr.kind;\n+            if let ExprKind::MethodCall(take_path, recv, [len_arg, ..], _) = expr.kind;\n             if take_path.ident.name == sym!(take);\n             // Check that take is applied to `repeat(0)`\n             if self.is_repeat_zero(recv);\n             then {\n                 // Check that len expression is equals to `with_capacity` expression\n                 if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr) {\n                     return true;\n-                } else if let ExprKind::MethodCall(path, _, _) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n+                } else if let ExprKind::MethodCall(path, ..) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n                     return true;\n                 }\n             }"}, {"sha": "662d399ca538a6918a07b3a69d14996ca1febc6d", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -262,15 +262,15 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n             let (method_names, expressions, _) = method_calls(left, 1);\n             if method_names.len() == 1;\n             if expressions.len() == 1;\n-            if expressions[0].len() == 1;\n+            if expressions[0].1.is_empty();\n             if method_names[0] == sym!(as_bytes);\n \n             // Check for slicer\n             if let ExprKind::Struct(QPath::LangItem(LangItem::Range, ..), _, _) = right.kind;\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n-                let string_expression = &expressions[0][0];\n+                let string_expression = &expressions[0].0;\n \n                 let snippet_app = snippet_with_applicability(\n                     cx,\n@@ -291,12 +291,12 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, args, _) = &e.kind;\n+            if let ExprKind::MethodCall(path, receiver, ..) = &e.kind;\n             if path.ident.name == sym!(as_bytes);\n-            if let ExprKind::Lit(lit) = &args[0].kind;\n+            if let ExprKind::Lit(lit) = &receiver.kind;\n             if let LitKind::Str(lit_content, _) = &lit.node;\n             then {\n-                let callsite = snippet(cx, args[0].span.source_callsite(), r#\"\"foo\"\"#);\n+                let callsite = snippet(cx, receiver.span.source_callsite(), r#\"\"foo\"\"#);\n                 let mut applicability = Applicability::MachineApplicable;\n                 if callsite.starts_with(\"include_str!\") {\n                     span_lint_and_sugg(\n@@ -305,7 +305,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n                         e.span,\n                         \"calling `as_bytes()` on `include_str!(..)`\",\n                         \"consider using `include_bytes!(..)` instead\",\n-                        snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability).replacen(\n+                        snippet_with_applicability(cx, receiver.span, r#\"\"foo\"\"#, &mut applicability).replacen(\n                             \"include_str\",\n                             \"include_bytes\",\n                             1,\n@@ -314,7 +314,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n                     );\n                 } else if lit_content.as_str().is_ascii()\n                     && lit_content.as_str().len() <= MAX_LENGTH_BYTE_STRING_LIT\n-                    && !args[0].span.from_expansion()\n+                    && !receiver.span.from_expansion()\n                 {\n                     span_lint_and_sugg(\n                         cx,\n@@ -324,7 +324,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n                         \"consider using a byte string literal instead\",\n                         format!(\n                             \"b{}\",\n-                            snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability)\n+                            snippet_with_applicability(cx, receiver.span, r#\"\"foo\"\"#, &mut applicability)\n                         ),\n                         applicability,\n                     );\n@@ -333,9 +333,9 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, [recv], _) = &e.kind;\n+            if let ExprKind::MethodCall(path, recv, [], _) = &e.kind;\n             if path.ident.name == sym!(into_bytes);\n-            if let ExprKind::MethodCall(path, [recv], _) = &recv.kind;\n+            if let ExprKind::MethodCall(path, recv, [], _) = &recv.kind;\n             if matches!(path.ident.name.as_str(), \"to_owned\" | \"to_string\");\n             if let ExprKind::Lit(lit) = &recv.kind;\n             if let LitKind::Str(lit_content, _) = &lit.node;\n@@ -393,7 +393,7 @@ declare_lint_pass!(StrToString => [STR_TO_STRING]);\n impl<'tcx> LateLintPass<'tcx> for StrToString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, self_arg, ..) = &expr.kind;\n             if path.ident.name == sym::to_string;\n             let ty = cx.typeck_results().expr_ty(self_arg);\n             if let ty::Ref(_, ty, ..) = ty.kind();\n@@ -443,7 +443,7 @@ declare_lint_pass!(StringToString => [STRING_TO_STRING]);\n impl<'tcx> LateLintPass<'tcx> for StringToString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, self_arg, ..) = &expr.kind;\n             if path.ident.name == sym::to_string;\n             let ty = cx.typeck_results().expr_ty(self_arg);\n             if is_type_diagnostic_item(cx, ty, sym::String);\n@@ -487,11 +487,11 @@ impl<'tcx> LateLintPass<'tcx> for TrimSplitWhitespace {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         let tyckres = cx.typeck_results();\n         if_chain! {\n-            if let ExprKind::MethodCall(path, [split_recv], split_ws_span) = expr.kind;\n+            if let ExprKind::MethodCall(path, split_recv, [], split_ws_span) = expr.kind;\n             if path.ident.name == sym!(split_whitespace);\n             if let Some(split_ws_def_id) = tyckres.type_dependent_def_id(expr.hir_id);\n             if cx.tcx.is_diagnostic_item(sym::str_split_whitespace, split_ws_def_id);\n-            if let ExprKind::MethodCall(path, [_trim_recv], trim_span) = split_recv.kind;\n+            if let ExprKind::MethodCall(path, _trim_recv, [], trim_span) = split_recv.kind;\n             if let trim_fn_name @ (\"trim\" | \"trim_start\" | \"trim_end\") = path.ident.name.as_str();\n             if let Some(trim_def_id) = tyckres.type_dependent_def_id(split_recv.hir_id);\n             if is_one_of_trim_diagnostic_items(cx, trim_def_id);"}, {"sha": "78403d9fdb7e6f17a81b1f4069105878369d0e9b", "filename": "clippy_lints/src/strlen_on_c_strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> LateLintPass<'tcx> for StrlenOnCStrings {\n             if let ExprKind::Path(path) = &func.kind;\n             if let Some(did) = cx.qpath_res(path, func.hir_id).opt_def_id();\n             if match_libc_symbol(cx, did, \"strlen\");\n-            if let ExprKind::MethodCall(path, [self_arg], _) = recv.kind;\n+            if let ExprKind::MethodCall(path, self_arg, [], _) = recv.kind;\n             if !recv.span.from_expansion();\n             if path.ident.name == sym::as_ptr;\n             then {"}, {"sha": "6add20c1fb712dcad9575e7b2b278bc4125f1412", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -78,7 +78,7 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n             ]\n                 .iter()\n                 .find(|&(ts, _)| ts.iter().any(|&t| Ok(trait_id) == cx.tcx.lang_items().require(t)));\n-            if count_binops(&body.value) == 1;\n+            if count_binops(body.value) == 1;\n             then {\n                 span_lint(\n                     cx,"}, {"sha": "651201f34ed28d46471e08ff6b2a9610679d2ad9", "filename": "clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -39,27 +39,25 @@ declare_lint_pass!(ToDigitIsSome => [TO_DIGIT_IS_SOME]);\n impl<'tcx> LateLintPass<'tcx> for ToDigitIsSome {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n-            if let hir::ExprKind::MethodCall(is_some_path, is_some_args, _) = &expr.kind;\n+            if let hir::ExprKind::MethodCall(is_some_path, to_digit_expr, [], _) = &expr.kind;\n             if is_some_path.ident.name.as_str() == \"is_some\";\n-            if let [to_digit_expr] = &**is_some_args;\n             then {\n                 let match_result = match &to_digit_expr.kind {\n-                    hir::ExprKind::MethodCall(to_digits_path, to_digit_args, _) => {\n+                    hir::ExprKind::MethodCall(to_digits_path, char_arg, [radix_arg], _) => {\n                         if_chain! {\n-                            if let [char_arg, radix_arg] = &**to_digit_args;\n                             if to_digits_path.ident.name.as_str() == \"to_digit\";\n                             let char_arg_ty = cx.typeck_results().expr_ty_adjusted(char_arg);\n                             if *char_arg_ty.kind() == ty::Char;\n                             then {\n-                                Some((true, char_arg, radix_arg))\n+                                Some((true, *char_arg, radix_arg))\n                             } else {\n                                 None\n                             }\n                         }\n                     }\n                     hir::ExprKind::Call(to_digits_call, to_digit_args) => {\n                         if_chain! {\n-                            if let [char_arg, radix_arg] = &**to_digit_args;\n+                            if let [char_arg, radix_arg] = *to_digit_args;\n                             if let hir::ExprKind::Path(to_digits_path) = &to_digits_call.kind;\n                             if let to_digits_call_res = cx.qpath_res(to_digits_path, to_digits_call.hir_id);\n                             if let Some(to_digits_def_id) = to_digits_call_res.opt_def_id();"}, {"sha": "a25be93b8d61696f3f803e48ae294b5f02ef24fc", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n                 if !bound_predicate.span.from_expansion();\n                 if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n                 if let Some(PathSegment {\n-                    res: Some(Res::SelfTy{ trait_: Some(def_id), alias_to: _ }), ..\n+                    res: Res::SelfTy{ trait_: Some(def_id), alias_to: _ }, ..\n                 }) = segments.first();\n                 if let Some(\n                     Node::Item("}, {"sha": "3f99bd3f31567c43592b9e2301557857096f65e7", "filename": "clippy_lints/src/uninit_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funinit_vec.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -177,7 +177,7 @@ fn extract_init_or_reserve_target<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt\n                     });\n                 }\n             },\n-            ExprKind::MethodCall(path, [self_expr, _], _) if is_reserve(cx, path, self_expr) => {\n+            ExprKind::MethodCall(path, self_expr, [_], _) if is_reserve(cx, path, self_expr) => {\n                 return Some(TargetVec {\n                     location: VecLocation::Expr(self_expr),\n                     init_kind: None,\n@@ -211,7 +211,7 @@ fn extract_set_len_self<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Opt\n         }\n     });\n     match expr.kind {\n-        ExprKind::MethodCall(path, [self_expr, _], _) => {\n+        ExprKind::MethodCall(path, self_expr, [_], _) => {\n             let self_type = cx.typeck_results().expr_ty(self_expr).peel_refs();\n             if is_type_diagnostic_item(cx, self_type, sym::Vec) && path.ident.name.as_str() == \"set_len\" {\n                 Some((self_expr, expr.span))"}, {"sha": "c0a4f3fbacd6487521ae0b9ca0777545176e1e51", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -144,11 +144,12 @@ fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Spa\n \n impl<'tcx> LateLintPass<'tcx> for UnitReturnExpectingOrd {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::MethodCall(_, args, _) = expr.kind {\n+        if let ExprKind::MethodCall(_, receiver, args, _) = expr.kind {\n             let arg_indices = get_args_to_check(cx, expr);\n+            let args = std::iter::once(receiver).chain(args.iter()).collect::<Vec<_>>();\n             for (i, trait_name) in arg_indices {\n                 if i < args.len() {\n-                    match check_arg(cx, &args[i]) {\n+                    match check_arg(cx, args[i]) {\n                         Some((span, None)) => {\n                             span_lint(\n                                 cx,"}, {"sha": "35824b03170afb87e139373715ad3b1caca492e5", "filename": "clippy_lints/src/unit_types/let_unit_value.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -128,7 +128,7 @@ fn needs_inferred_result_ty(\n     locals_to_check: &mut Vec<HirId>,\n     seen_locals: &mut HirIdSet,\n ) -> bool {\n-    let (id, args) = match e.kind {\n+    let (id, receiver, args) = match e.kind {\n         ExprKind::Call(\n             Expr {\n                 kind: ExprKind::Path(ref path),\n@@ -137,11 +137,11 @@ fn needs_inferred_result_ty(\n             },\n             args,\n         ) => match cx.qpath_res(path, *hir_id) {\n-            Res::Def(DefKind::AssocFn | DefKind::Fn, id) => (id, args),\n+            Res::Def(DefKind::AssocFn | DefKind::Fn, id) => (id, None, args),\n             _ => return false,\n         },\n-        ExprKind::MethodCall(_, args, _) => match cx.typeck_results().type_dependent_def_id(e.hir_id) {\n-            Some(id) => (id, args),\n+        ExprKind::MethodCall(_, receiver, args, _) => match cx.typeck_results().type_dependent_def_id(e.hir_id) {\n+            Some(id) => (id, Some(receiver), args),\n             None => return false,\n         },\n         ExprKind::Path(QPath::Resolved(None, path)) => {\n@@ -156,6 +156,11 @@ fn needs_inferred_result_ty(\n     };\n     let sig = cx.tcx.fn_sig(id).skip_binder();\n     if let ty::Param(output_ty) = *sig.output().kind() {\n+        let args: Vec<&Expr<'_>> = if let Some(receiver) = receiver {\n+            std::iter::once(receiver).chain(args.iter()).collect()\n+        } else {\n+            args.iter().collect()\n+        };\n         sig.inputs().iter().zip(args).all(|(&ty, arg)| {\n             !ty.is_param(output_ty.index) || each_value_source_needs_inference(cx, arg, locals_to_check, seen_locals)\n         })"}, {"sha": "a6f777abc6e942aaf0259f83314b859ba569efb0", "filename": "clippy_lints/src/unit_types/unit_arg.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -30,26 +30,27 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         }\n     }\n \n-    match expr.kind {\n-        ExprKind::Call(_, args) | ExprKind::MethodCall(_, args, _) => {\n-            let args_to_recover = args\n-                .iter()\n-                .filter(|arg| {\n-                    if cx.typeck_results().expr_ty(arg).is_unit() && !utils::is_unit_literal(arg) {\n-                        !matches!(\n-                            &arg.kind,\n-                            ExprKind::Match(.., MatchSource::TryDesugar) | ExprKind::Path(..)\n-                        )\n-                    } else {\n-                        false\n-                    }\n-                })\n-                .collect::<Vec<_>>();\n-            if !args_to_recover.is_empty() && !is_from_proc_macro(cx, expr) {\n-                lint_unit_args(cx, expr, &args_to_recover);\n+    let args: Vec<_> = match expr.kind {\n+        ExprKind::Call(_, args) => args.iter().collect(),\n+        ExprKind::MethodCall(_, receiver, args, _) => std::iter::once(receiver).chain(args.iter()).collect(),\n+        _ => return,\n+    };\n+\n+    let args_to_recover = args\n+        .into_iter()\n+        .filter(|arg| {\n+            if cx.typeck_results().expr_ty(arg).is_unit() && !utils::is_unit_literal(arg) {\n+                !matches!(\n+                    &arg.kind,\n+                    ExprKind::Match(.., MatchSource::TryDesugar) | ExprKind::Path(..)\n+                )\n+            } else {\n+                false\n             }\n-        },\n-        _ => (),\n+        })\n+        .collect::<Vec<_>>();\n+    if !args_to_recover.is_empty() && !is_from_proc_macro(cx, expr) {\n+        lint_unit_args(cx, expr, args_to_recover.as_slice());\n     }\n }\n "}, {"sha": "2c40827db0e75677800317cf9af9e397028e8b35", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -115,7 +115,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n \n         // Check if all return expression respect the following condition and collect them.\n         let mut suggs = Vec::new();\n-        let can_sugg = find_all_ret_expressions(cx, &body.value, |ret_expr| {\n+        let can_sugg = find_all_ret_expressions(cx, body.value, |ret_expr| {\n             if_chain! {\n                 if !ret_expr.span.from_expansion();\n                 // Check if a function call."}, {"sha": "fb73c386640b49babd971298c21445d4286f9225", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -137,12 +137,12 @@ fn insert_necessary_parens(pat: &mut P<Pat>) {\n     struct Visitor;\n     impl MutVisitor for Visitor {\n         fn visit_pat(&mut self, pat: &mut P<Pat>) {\n-            use ast::{BindingMode::*, Mutability::*};\n+            use ast::BindingAnnotation;\n             noop_visit_pat(pat, self);\n             let target = match &mut pat.kind {\n                 // `i @ a | b`, `box a | b`, and `& mut? a | b`.\n                 Ident(.., Some(p)) | Box(p) | Ref(p, _) if matches!(&p.kind, Or(ps) if ps.len() > 1) => p,\n-                Ref(p, Not) if matches!(p.kind, Ident(ByValue(Mut), ..)) => p, // `&(mut x)`\n+                Ref(p, Mutability::Not) if matches!(p.kind, Ident(BindingAnnotation::MUT, ..)) => p, // `&(mut x)`\n                 _ => return,\n             };\n             target.kind = Paren(P(take_pat(target)));"}, {"sha": "b38d71784fcfc74475b7f07042267479929aabe8", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n                     check_map_error(cx, res, expr);\n                 }\n             },\n-            hir::ExprKind::MethodCall(path, [ref arg_0, ..], _) => match path.ident.as_str() {\n+            hir::ExprKind::MethodCall(path, arg_0, ..) => match path.ident.as_str() {\n                 \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                     check_map_error(cx, arg_0, expr);\n                 },\n@@ -94,9 +94,9 @@ fn try_remove_await<'a>(expr: &'a hir::Expr<'a>) -> Option<&hir::Expr<'a>> {\n \n fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n     let mut call = call;\n-    while let hir::ExprKind::MethodCall(path, args, _) = call.kind {\n+    while let hir::ExprKind::MethodCall(path, receiver, ..) = call.kind {\n         if matches!(path.ident.as_str(), \"or\" | \"or_else\" | \"ok\") {\n-            call = &args[0];\n+            call = receiver;\n         } else {\n             break;\n         }\n@@ -110,7 +110,7 @@ fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<\n }\n \n fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>, is_await: bool) {\n-    if let hir::ExprKind::MethodCall(path, _, _) = call.kind {\n+    if let hir::ExprKind::MethodCall(path, ..) = call.kind {\n         let symbol = path.ident.as_str();\n         let read_trait = if is_await {\n             match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCREADEXT)"}, {"sha": "cfc181e435b9c9da1068a6d642a16d4d9f789b71", "filename": "clippy_lints/src/unused_peekable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_peekable.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -149,7 +149,8 @@ impl<'tcx> Visitor<'_> for PeekableVisitor<'_, 'tcx> {\n                                     ident: method_name_ident,\n                                     ..\n                                 },\n-                                [self_arg, remaining_args @ ..],\n+                                self_arg,\n+                                remaining_args,\n                                 _,\n                             ) => {\n                                 let method_name = method_name_ident.name.as_str();"}, {"sha": "7e451b7b7a419239c5c136541ab74222e54fce8e", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -154,13 +154,13 @@ fn collect_unwrap_info<'tcx>(\n         return collect_unwrap_info(cx, if_expr, expr, branch, !invert, false);\n     } else {\n         if_chain! {\n-            if let ExprKind::MethodCall(method_name, args, _) = &expr.kind;\n-            if let Some(local_id) = path_to_local(&args[0]);\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            if let ExprKind::MethodCall(method_name, receiver, args, _) = &expr.kind;\n+            if let Some(local_id) = path_to_local(receiver);\n+            let ty = cx.typeck_results().expr_ty(receiver);\n             let name = method_name.ident.as_str();\n             if is_relevant_option_call(cx, ty, name) || is_relevant_result_call(cx, ty, name);\n             then {\n-                assert!(args.len() == 1);\n+                assert!(args.is_empty());\n                 let unwrappable = match name {\n                     \"is_some\" | \"is_ok\" => true,\n                     \"is_err\" | \"is_none\" => false,\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let ExprKind::MethodCall(method_name, [self_arg, ..], _) = expr.kind;\n+                if let ExprKind::MethodCall(method_name, self_arg, ..) = expr.kind;\n                 if let Some(id) = path_to_local(self_arg);\n                 if [sym::unwrap, sym::expect, sym!(unwrap_err)].contains(&method_name.ident.name);\n                 let call_to_unwrap = [sym::unwrap, sym::expect].contains(&method_name.ident.name);"}, {"sha": "46020adcaa2caae66e67974e86f0f17f08543c44", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         // check for `expect`\n         if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n             if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n                 || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n             {\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n \n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n             if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n                 || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n             {\n@@ -114,7 +114,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tc\n             typeck_results: cx.tcx.typeck(impl_item.def_id),\n             result: Vec::new(),\n         };\n-        fpu.visit_expr(&body.value);\n+        fpu.visit_expr(body.value);\n \n         // if we've found one, lint\n         if !fpu.result.is_empty() {"}, {"sha": "f1b6463ad0f7c62a375aa8cfad9f7a086729cf19", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                 }\n             },\n \n-            ExprKind::MethodCall(name, .., [recv, ..], _) => {\n+            ExprKind::MethodCall(name, recv, ..) => {\n                 if is_trait_method(cx, e, sym::Into) && name.ident.as_str() == \"into\" {\n                     let a = cx.typeck_results().expr_ty(e);\n                     let b = cx.typeck_results().expr_ty(recv);"}, {"sha": "4003fff27c006a7d5956aa6094406fc4f1f735eb", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -6,7 +6,9 @@ use rustc_ast::ast::{LitFloatType, LitKind};\n use rustc_ast::LitIntType;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_hir::{ArrayLen, Closure, ExprKind, FnRetTy, HirId, Lit, PatKind, QPath, StmtKind, TyKind};\n+use rustc_hir::{\n+    ArrayLen, BindingAnnotation, Closure, ExprKind, FnRetTy, HirId, Lit, PatKind, QPath, StmtKind, TyKind,\n+};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::{Ident, Symbol};\n@@ -140,7 +142,7 @@ fn check_item(cx: &LateContext<'_>, hir_id: HirId) {\n     let hir = cx.tcx.hir();\n     if let Some(body_id) = hir.maybe_body_owned_by(hir_id.expect_owner()) {\n         check_node(cx, hir_id, |v| {\n-            v.expr(&v.bind(\"expr\", &hir.body(body_id).value));\n+            v.expr(&v.bind(\"expr\", hir.body(body_id).value));\n         });\n     }\n }\n@@ -402,10 +404,11 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 self.expr(func);\n                 self.slice(args, |e| self.expr(e));\n             },\n-            ExprKind::MethodCall(method_name, args, _) => {\n-                bind!(self, method_name, args);\n-                kind!(\"MethodCall({method_name}, {args}, _)\");\n+            ExprKind::MethodCall(method_name, receiver, args, _) => {\n+                bind!(self, method_name, receiver, args);\n+                kind!(\"MethodCall({method_name}, {receiver}, {args}, _)\");\n                 self.ident(field!(method_name.ident));\n+                self.expr(receiver);\n                 self.slice(args, |e| self.expr(e));\n             },\n             ExprKind::Tup(elements) => {\n@@ -595,7 +598,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     }\n \n     fn body(&self, body_id: &Binding<hir::BodyId>) {\n-        let expr = &self.cx.tcx.hir().body(body_id.value).value;\n+        let expr = self.cx.tcx.hir().body(body_id.value).value;\n         bind!(self, expr);\n         out!(\"let {expr} = &cx.tcx.hir().body({body_id}).value;\");\n         self.expr(expr);\n@@ -609,10 +612,16 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n \n         match pat.value.kind {\n             PatKind::Wild => kind!(\"Wild\"),\n-            PatKind::Binding(anno, .., name, sub) => {\n+            PatKind::Binding(ann, _, name, sub) => {\n                 bind!(self, name);\n                 opt_bind!(self, sub);\n-                kind!(\"Binding(BindingAnnotation::{anno:?}, _, {name}, {sub})\");\n+                let ann = match ann {\n+                    BindingAnnotation::NONE => \"NONE\",\n+                    BindingAnnotation::REF => \"REF\",\n+                    BindingAnnotation::MUT => \"MUT\",\n+                    BindingAnnotation::REF_MUT => \"REF_MUT\",\n+                };\n+                kind!(\"Binding(BindingAnnotation::{ann}, _, {name}, {sub})\");\n                 self.ident(name);\n                 sub.if_some(|p| self.pat(p));\n             },"}, {"sha": "17d9a041857678adfe81e0d950defc3e6a417431", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -505,7 +505,7 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n                             .hir_id(),\n                     ),\n                 );\n-                collector.visit_expr(&cx.tcx.hir().body(body_id).value);\n+                collector.visit_expr(cx.tcx.hir().body(body_id).value);\n             }\n         }\n     }\n@@ -653,7 +653,7 @@ impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, self_arg, _, _) = &expr.kind;\n             let fn_name = path.ident;\n             if let Some(sugg) = self.map.get(fn_name.as_str());\n             let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n@@ -685,9 +685,8 @@ impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n         let method_names: Vec<&str> = method_names.iter().map(Symbol::as_str).collect();\n         if_chain! {\n             if let [\"expn_data\", \"outer_expn\"] = method_names.as_slice();\n-            let args = arg_lists[1];\n-            if args.len() == 1;\n-            let self_arg = &args[0];\n+            let (self_arg, args)= arg_lists[1];\n+            if args.is_empty();\n             let self_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n             if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n             then {\n@@ -734,30 +733,30 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             if and_then_args.len() == 5;\n             if let ExprKind::Closure(&Closure { body, .. }) = &and_then_args[4].kind;\n             let body = cx.tcx.hir().body(body);\n-            let only_expr = peel_blocks_with_stmt(&body.value);\n-            if let ExprKind::MethodCall(ps, span_call_args, _) = &only_expr.kind;\n-            if let ExprKind::Path(..) = span_call_args[0].kind;\n+            let only_expr = peel_blocks_with_stmt(body.value);\n+            if let ExprKind::MethodCall(ps, recv, span_call_args, _) = &only_expr.kind;\n+            if let ExprKind::Path(..) = recv.kind;\n             then {\n                 let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n                 let mut sle = SpanlessEq::new(cx).deny_side_effects();\n                 match ps.ident.as_str() {\n-                    \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[1]) => {\n+                    \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n                         suggest_suggestion(cx, expr, &and_then_snippets, &span_suggestion_snippets(cx, span_call_args));\n                     },\n-                    \"span_help\" if sle.eq_expr(&and_then_args[2], &span_call_args[1]) => {\n-                        let help_snippet = snippet(cx, span_call_args[2].span, r#\"\"...\"\"#);\n+                    \"span_help\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n                         suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), true);\n                     },\n-                    \"span_note\" if sle.eq_expr(&and_then_args[2], &span_call_args[1]) => {\n-                        let note_snippet = snippet(cx, span_call_args[2].span, r#\"\"...\"\"#);\n+                    \"span_note\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        let note_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n                         suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), true);\n                     },\n                     \"help\" => {\n-                        let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+                        let help_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n                         suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), false);\n                     }\n                     \"note\" => {\n-                        let note_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+                        let note_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n                         suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), false);\n                     }\n                     _  => (),\n@@ -798,9 +797,9 @@ fn span_suggestion_snippets<'a, 'hir>(\n     cx: &LateContext<'_>,\n     span_call_args: &'hir [Expr<'hir>],\n ) -> SpanSuggestionSnippets<'a> {\n-    let help_snippet = snippet(cx, span_call_args[2].span, r#\"\"...\"\"#);\n-    let sugg_snippet = snippet(cx, span_call_args[3].span, \"..\");\n-    let applicability_snippet = snippet(cx, span_call_args[4].span, \"Applicability::MachineApplicable\");\n+    let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+    let sugg_snippet = snippet(cx, span_call_args[2].span, \"..\");\n+    let applicability_snippet = snippet(cx, span_call_args[3].span, \"Applicability::MachineApplicable\");\n \n     SpanSuggestionSnippets {\n         help: help_snippet,\n@@ -954,7 +953,7 @@ fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Ve\n                 if let Some(Node::Item(item)) = cx.tcx.hir().get_if_local(def_id) {\n                     if let ItemKind::Const(.., body_id) | ItemKind::Static(.., body_id) = item.kind {\n                         let body = cx.tcx.hir().body(body_id);\n-                        return path_to_matched_type(cx, &body.value);\n+                        return path_to_matched_type(cx, body.value);\n                     }\n                 }\n             },\n@@ -1046,7 +1045,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n             if el_ty.is_str();\n             let body = cx.tcx.hir().body(body_id);\n             let typeck_results = cx.tcx.typeck_body(body_id);\n-            if let Some(Constant::Vec(path)) = constant_simple(cx, typeck_results, &body.value);\n+            if let Some(Constant::Vec(path)) = constant_simple(cx, typeck_results, body.value);\n             let path: Vec<&str> = path.iter().map(|x| {\n                     if let Constant::Str(s) = x {\n                         s.as_str()\n@@ -1177,7 +1176,7 @@ impl InterningDefinedSymbol {\n         };\n         if_chain! {\n             // is a method call\n-            if let ExprKind::MethodCall(_, [item], _) = call.kind;\n+            if let ExprKind::MethodCall(_, item, [], _) = call.kind;\n             if let Some(did) = cx.typeck_results().type_dependent_def_id(call.hir_id);\n             let ty = cx.typeck_results().expr_ty(item);\n             // ...on either an Ident or a Symbol"}, {"sha": "342f627e38275ce925c224595542abadfef9b2e3", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -1145,8 +1145,8 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for IsMultiSpanScanner<'a, 'hir> {\n                     self.add_single_span_suggestion();\n                 }\n             },\n-            ExprKind::MethodCall(path, arg, _arg_span) => {\n-                let (self_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&arg[0]));\n+            ExprKind::MethodCall(path, recv, _, _arg_span) => {\n+                let (self_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(recv));\n                 if match_type(self.cx, self_ty, &paths::DIAGNOSTIC_BUILDER) {\n                     let called_method = path.ident.name.as_str().to_string();\n                     for (method_name, is_multi_part) in &SUGGESTION_DIAGNOSTIC_BUILDER_METHODS {"}, {"sha": "bd5be0c9d7eda70d5db3c9e973c7471c034d47ee", "filename": "clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -100,7 +100,7 @@ impl VecPushSearcher {\n                         || get_parent_expr(cx, last_place)\n                             .map_or(false, |e| matches!(e.kind, ExprKind::AddrOf(_, Mutability::Mut, _)));\n                 },\n-                ExprKind::MethodCall(_, [recv, ..], _)\n+                ExprKind::MethodCall(_, recv, ..)\n                     if recv.hir_id == e.hir_id\n                         && adjusted_mut == Mutability::Mut\n                         && !adjusted_ty.peel_refs().is_slice() =>\n@@ -157,7 +157,7 @@ impl<'tcx> LateLintPass<'tcx> for VecInitThenPush {\n \n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n         if let Some(init_expr) = local.init\n-            && let PatKind::Binding(BindingAnnotation::Mutable, id, name, None) = local.pat.kind\n+            && let PatKind::Binding(BindingAnnotation::MUT, id, name, None) = local.pat.kind\n             && !in_external_macro(cx.sess(), local.span)\n             && let Some(init) = get_vec_init_kind(cx, init_expr)\n             && !matches!(init, VecInitKind::WithExprCapacity(_))\n@@ -201,7 +201,7 @@ impl<'tcx> LateLintPass<'tcx> for VecInitThenPush {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let Some(searcher) = self.searcher.take() {\n             if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = stmt.kind\n-                && let ExprKind::MethodCall(name, [self_arg, _], _) = expr.kind\n+                && let ExprKind::MethodCall(name, self_arg, [_], _) = expr.kind\n                 && path_to_local_id(self_arg, searcher.local_id)\n                 && name.ident.as_str() == \"push\"\n             {"}, {"sha": "640a09a7a912347396816d4fec4c0b41c5f09c55", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -526,7 +526,7 @@ impl SimpleFormatArgs {\n         str_lit_span: Span,\n         fmt_span: Span,\n     ) {\n-        use rustc_parse_format::{ArgumentImplicitlyIs, ArgumentIs, CountIsParam};\n+        use rustc_parse_format::{ArgumentImplicitlyIs, ArgumentIs, CountIsParam, CountIsStar};\n \n         let snippet = snippet_opt(cx, fmt_span);\n \n@@ -540,7 +540,7 @@ impl SimpleFormatArgs {\n             self.push_to_complex(span, n);\n         };\n \n-        if let (CountIsParam(n), Some(span)) = (arg.format.precision, arg.format.precision_span) {\n+        if let (CountIsParam(n) | CountIsStar(n), Some(span)) = (arg.format.precision, arg.format.precision_span) {\n             // We need to do this hack as precision spans should be converted from .* to .foo$\n             let hack = if snippet.as_ref().and_then(|s| s.find('*')).is_some() {\n                 0"}, {"sha": "7a8d4e8068ed6dc514031623c55a5d2e47333c07", "filename": "clippy_utils/src/check_proc_macro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -118,9 +118,9 @@ fn expr_search_pat(tcx: TyCtxt<'_>, e: &Expr<'_>) -> (Pat, Pat) {\n         ExprKind::Unary(UnOp::Neg, e) => (Pat::Str(\"-\"), expr_search_pat(tcx, e).1),\n         ExprKind::Lit(ref lit) => lit_search_pat(&lit.node),\n         ExprKind::Array(_) | ExprKind::Repeat(..) => (Pat::Str(\"[\"), Pat::Str(\"]\")),\n-        ExprKind::Call(e, []) | ExprKind::MethodCall(_, [e], _) => (expr_search_pat(tcx, e).0, Pat::Str(\"(\")),\n+        ExprKind::Call(e, []) | ExprKind::MethodCall(_, e, [], _) => (expr_search_pat(tcx, e).0, Pat::Str(\"(\")),\n         ExprKind::Call(first, [.., last])\n-        | ExprKind::MethodCall(_, [first, .., last], _)\n+        | ExprKind::MethodCall(_, first, [.., last], _)\n         | ExprKind::Binary(_, first, last)\n         | ExprKind::Tup([first, .., last])\n         | ExprKind::Assign(first, last, _)\n@@ -140,7 +140,7 @@ fn expr_search_pat(tcx: TyCtxt<'_>, e: &Expr<'_>) -> (Pat, Pat) {\n         ExprKind::Match(e, _, MatchSource::AwaitDesugar) | ExprKind::Yield(e, YieldSource::Await { .. }) => {\n             (expr_search_pat(tcx, e).0, Pat::Str(\"await\"))\n         },\n-        ExprKind::Closure(&Closure { body, .. }) => (Pat::Str(\"\"), expr_search_pat(tcx, &tcx.hir().body(body).value).1),\n+        ExprKind::Closure(&Closure { body, .. }) => (Pat::Str(\"\"), expr_search_pat(tcx, tcx.hir().body(body).value).1),\n         ExprKind::Block(\n             Block {\n                 rules: BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n@@ -254,7 +254,7 @@ fn fn_kind_pat(tcx: TyCtxt<'_>, kind: &FnKind<'_>, body: &Body<'_>, hir_id: HirI\n     let (start_pat, end_pat) = match kind {\n         FnKind::ItemFn(.., header) => (fn_header_search_pat(*header), Pat::Str(\"\")),\n         FnKind::Method(.., sig) => (fn_header_search_pat(sig.header), Pat::Str(\"\")),\n-        FnKind::Closure => return (Pat::Str(\"\"), expr_search_pat(tcx, &body.value).1),\n+        FnKind::Closure => return (Pat::Str(\"\"), expr_search_pat(tcx, body.value).1),\n     };\n     let start_pat = match tcx.hir().get(hir_id) {\n         Node::Item(Item { vis_span, .. }) | Node::ImplItem(ImplItem { vis_span, .. }) => {"}, {"sha": "91c9c382c236bcbc87c535976c33944fba629bf8", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -45,12 +45,7 @@ impl ops::BitOrAssign for EagernessSuggestion {\n }\n \n /// Determine the eagerness of the given function call.\n-fn fn_eagerness<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    fn_id: DefId,\n-    name: Symbol,\n-    args: &'tcx [Expr<'_>],\n-) -> EagernessSuggestion {\n+fn fn_eagerness(cx: &LateContext<'_>, fn_id: DefId, name: Symbol, have_one_arg: bool) -> EagernessSuggestion {\n     use EagernessSuggestion::{Eager, Lazy, NoChange};\n     let name = name.as_str();\n \n@@ -59,7 +54,7 @@ fn fn_eagerness<'tcx>(\n         None => return Lazy,\n     };\n \n-    if (name.starts_with(\"as_\") || name == \"len\" || name == \"is_empty\") && args.len() == 1 {\n+    if (name.starts_with(\"as_\") || name == \"len\" || name == \"is_empty\") && have_one_arg {\n         if matches!(\n             cx.tcx.crate_name(fn_id.krate),\n             sym::std | sym::core | sym::alloc | sym::proc_macro\n@@ -127,10 +122,11 @@ fn expr_eagerness<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessS\n                     },\n                     Res::Def(_, id) => match path {\n                         QPath::Resolved(_, p) => {\n-                            self.eagerness |= fn_eagerness(self.cx, id, p.segments.last().unwrap().ident.name, args);\n+                            self.eagerness |=\n+                                fn_eagerness(self.cx, id, p.segments.last().unwrap().ident.name, !args.is_empty());\n                         },\n                         QPath::TypeRelative(_, name) => {\n-                            self.eagerness |= fn_eagerness(self.cx, id, name.ident.name, args);\n+                            self.eagerness |= fn_eagerness(self.cx, id, name.ident.name, !args.is_empty());\n                         },\n                         QPath::LangItem(..) => self.eagerness = Lazy,\n                     },\n@@ -141,12 +137,12 @@ fn expr_eagerness<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessS\n                     self.eagerness |= NoChange;\n                     return;\n                 },\n-                ExprKind::MethodCall(name, args, _) => {\n+                ExprKind::MethodCall(name, ..) => {\n                     self.eagerness |= self\n                         .cx\n                         .typeck_results()\n                         .type_dependent_def_id(e.hir_id)\n-                        .map_or(Lazy, |id| fn_eagerness(self.cx, id, name.ident.name, args));\n+                        .map_or(Lazy, |id| fn_eagerness(self.cx, id, name.ident.name, true));\n                 },\n                 ExprKind::Index(_, e) => {\n                     let ty = self.cx.typeck_results().expr_ty_adjusted(e);"}, {"sha": "7dd1a3b7e19389bdf80b085dba1b94d0ec71f483", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -6,9 +6,9 @@ use rustc_data_structures::fx::FxHasher;\n use rustc_hir::def::Res;\n use rustc_hir::HirIdMap;\n use rustc_hir::{\n-    ArrayLen, BinOpKind, Block, BodyId, Closure, Expr, ExprField, ExprKind, FnRetTy, GenericArg, GenericArgs, Guard,\n-    HirId, InlineAsmOperand, Let, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path, PathSegment, QPath,\n-    Stmt, StmtKind, Ty, TyKind, TypeBinding,\n+    ArrayLen, BinOpKind, BindingAnnotation, Block, BodyId, Closure, Expr, ExprField, ExprKind, FnRetTy, GenericArg,\n+    GenericArgs, Guard, HirId, InlineAsmOperand, Let, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path,\n+    PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n@@ -201,8 +201,8 @@ impl HirEqInterExpr<'_, '_, '_> {\n             self.inner.cx.tcx.typeck_body(right),\n         ));\n         let res = self.eq_expr(\n-            &self.inner.cx.tcx.hir().body(left).value,\n-            &self.inner.cx.tcx.hir().body(right).value,\n+            self.inner.cx.tcx.hir().body(left).value,\n+            self.inner.cx.tcx.hir().body(right).value,\n         );\n         self.inner.maybe_typeck_results = old_maybe_typeck_results;\n         res\n@@ -282,8 +282,14 @@ impl HirEqInterExpr<'_, '_, '_> {\n                             && self.eq_expr(l.body, r.body)\n                     })\n             },\n-            (&ExprKind::MethodCall(l_path, l_args, _), &ExprKind::MethodCall(r_path, r_args, _)) => {\n-                self.inner.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n+            (\n+                &ExprKind::MethodCall(l_path, l_receiver, l_args, _),\n+                &ExprKind::MethodCall(r_path, r_receiver, r_args, _),\n+            ) => {\n+                self.inner.allow_side_effects\n+                    && self.eq_path_segment(l_path, r_path)\n+                    && self.eq_expr(l_receiver, r_receiver)\n+                    && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(le, ll), &ExprKind::Repeat(re, rl)) => {\n                 self.eq_expr(le, re) && self.eq_array_length(ll, rl)\n@@ -643,7 +649,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             }) => {\n                 std::mem::discriminant(&capture_clause).hash(&mut self.s);\n                 // closures inherit TypeckResults\n-                self.hash_expr(&self.cx.tcx.hir().body(body).value);\n+                self.hash_expr(self.cx.tcx.hir().body(body).value);\n             },\n             ExprKind::Field(e, ref f) => {\n                 self.hash_expr(e);\n@@ -743,8 +749,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n                 s.hash(&mut self.s);\n             },\n-            ExprKind::MethodCall(path, args, ref _fn_span) => {\n+            ExprKind::MethodCall(path, receiver, args, ref _fn_span) => {\n                 self.hash_name(path.ident.name);\n+                self.hash_expr(receiver);\n                 self.hash_exprs(args);\n             },\n             ExprKind::ConstBlock(ref l_id) => {\n@@ -815,8 +822,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     pub fn hash_pat(&mut self, pat: &Pat<'_>) {\n         std::mem::discriminant(&pat.kind).hash(&mut self.s);\n         match pat.kind {\n-            PatKind::Binding(ann, _, _, pat) => {\n-                std::mem::discriminant(&ann).hash(&mut self.s);\n+            PatKind::Binding(BindingAnnotation(by_ref, mutability), _, _, pat) => {\n+                std::mem::discriminant(&by_ref).hash(&mut self.s);\n+                std::mem::discriminant(&mutability).hash(&mut self.s);\n                 if let Some(pat) = pat {\n                     self.hash_pat(pat);\n                 }\n@@ -1002,15 +1010,15 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     pub fn hash_body(&mut self, body_id: BodyId) {\n         // swap out TypeckResults when hashing a body\n         let old_maybe_typeck_results = self.maybe_typeck_results.replace(self.cx.tcx.typeck_body(body_id));\n-        self.hash_expr(&self.cx.tcx.hir().body(body_id).value);\n+        self.hash_expr(self.cx.tcx.hir().body(body_id).value);\n         self.maybe_typeck_results = old_maybe_typeck_results;\n     }\n \n     fn hash_generic_args(&mut self, arg_list: &[GenericArg<'_>]) {\n         for arg in arg_list {\n             match *arg {\n                 GenericArg::Lifetime(l) => self.hash_lifetime(l),\n-                GenericArg::Type(ref ty) => self.hash_ty(ty),\n+                GenericArg::Type(ty) => self.hash_ty(ty),\n                 GenericArg::Const(ref ca) => self.hash_body(ca.value.body),\n                 GenericArg::Infer(ref inf) => self.hash_ty(&inf.to_ty()),\n             }"}, {"sha": "a1a716ebeca29eef69e54915d101fc6133c98c61", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -2,6 +2,7 @@\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(let_else)]\n+#![feature(let_chains)]\n #![feature(lint_reasons)]\n #![feature(once_cell)]\n #![feature(rustc_private)]\n@@ -191,7 +192,7 @@ pub fn find_binding_init<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<\n     let hir = cx.tcx.hir();\n     if_chain! {\n         if let Some(Node::Pat(pat)) = hir.find(hir_id);\n-        if matches!(pat.kind, PatKind::Binding(BindingAnnotation::Unannotated, ..));\n+        if matches!(pat.kind, PatKind::Binding(BindingAnnotation::NONE, ..));\n         let parent = hir.get_parent_node(hir_id);\n         if let Some(Node::Local(local)) = hir.find(parent);\n         then {\n@@ -336,7 +337,7 @@ pub fn qpath_generic_tys<'tcx>(qpath: &QPath<'tcx>) -> impl Iterator<Item = &'tc\n         .map_or(&[][..], |a| a.args)\n         .iter()\n         .filter_map(|a| match a {\n-            hir::GenericArg::Type(ty) => Some(ty),\n+            hir::GenericArg::Type(ty) => Some(*ty),\n             _ => None,\n         })\n }\n@@ -1030,26 +1031,26 @@ pub fn can_move_expr_to_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'\n     v.allow_closure.then_some(v.captures)\n }\n \n+/// Arguments of a method: the receiver and all the additional arguments.\n+pub type MethodArguments<'tcx> = Vec<(&'tcx Expr<'tcx>, &'tcx [Expr<'tcx>])>;\n+\n /// Returns the method names and argument list of nested method call expressions that make up\n /// `expr`. method/span lists are sorted with the most recent call first.\n-pub fn method_calls<'tcx>(\n-    expr: &'tcx Expr<'tcx>,\n-    max_depth: usize,\n-) -> (Vec<Symbol>, Vec<&'tcx [Expr<'tcx>]>, Vec<Span>) {\n+pub fn method_calls<'tcx>(expr: &'tcx Expr<'tcx>, max_depth: usize) -> (Vec<Symbol>, MethodArguments<'tcx>, Vec<Span>) {\n     let mut method_names = Vec::with_capacity(max_depth);\n     let mut arg_lists = Vec::with_capacity(max_depth);\n     let mut spans = Vec::with_capacity(max_depth);\n \n     let mut current = expr;\n     for _ in 0..max_depth {\n-        if let ExprKind::MethodCall(path, args, _) = &current.kind {\n-            if args.iter().any(|e| e.span.from_expansion()) {\n+        if let ExprKind::MethodCall(path, receiver, args, _) = &current.kind {\n+            if receiver.span.from_expansion() || args.iter().any(|e| e.span.from_expansion()) {\n                 break;\n             }\n             method_names.push(path.ident.name);\n-            arg_lists.push(&**args);\n+            arg_lists.push((*receiver, &**args));\n             spans.push(path.ident.span);\n-            current = &args[0];\n+            current = receiver;\n         } else {\n             break;\n         }\n@@ -1064,18 +1065,18 @@ pub fn method_calls<'tcx>(\n /// `method_chain_args(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n /// containing the `Expr`s for\n /// `.bar()` and `.baz()`\n-pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec<&'a [Expr<'a>]>> {\n+pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec<(&'a Expr<'a>, &'a [Expr<'a>])>> {\n     let mut current = expr;\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n-        if let ExprKind::MethodCall(path, args, _) = current.kind {\n+        if let ExprKind::MethodCall(path, receiver, args, _) = current.kind {\n             if path.ident.name.as_str() == *method_name {\n-                if args.iter().any(|e| e.span.from_expansion()) {\n+                if receiver.span.from_expansion() || args.iter().any(|e| e.span.from_expansion()) {\n                     return None;\n                 }\n-                matched.push(args); // build up `matched` backwards\n-                current = &args[0]; // go to parent expression\n+                matched.push((receiver, args)); // build up `matched` backwards\n+                current = receiver; // go to parent expression\n             } else {\n                 return None;\n             }\n@@ -1238,8 +1239,10 @@ pub fn get_enclosing_loop_or_multi_call_closure<'tcx>(\n                                     ty_is_fn_once_param(cx.tcx, ty.skip_binder(), predicates).then_some(())\n                                 })\n                             },\n-                            ExprKind::MethodCall(_, args, _) => {\n-                                let i = args.iter().position(|arg| arg.hir_id == id)?;\n+                            ExprKind::MethodCall(_, receiver, args, _) => {\n+                                let i = std::iter::once(receiver)\n+                                    .chain(args.iter())\n+                                    .position(|arg| arg.hir_id == id)?;\n                                 let id = cx.typeck_results().type_dependent_def_id(e.hir_id)?;\n                                 let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n                                 ty_is_fn_once_param(cx.tcx, ty, cx.tcx.param_env(id).caller_bounds()).then_some(())\n@@ -1811,7 +1814,7 @@ pub fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool\n             }\n         };\n \n-        let mut expr = &func.value;\n+        let mut expr = func.value;\n         loop {\n             match expr.kind {\n                 #[rustfmt::skip]"}, {"sha": "bd89ff977f87791dd6deacaf193b34e7781ffd62", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -646,7 +646,7 @@ impl<'tcx> Count<'tcx> {\n                 span,\n                 values,\n             )?),\n-            rpf::Count::CountIsParam(_) => {\n+            rpf::Count::CountIsParam(_) | rpf::Count::CountIsStar(_) => {\n                 Self::Param(FormatParam::new(FormatParamKind::Numbered, position?, inner?, values)?)\n             },\n             rpf::Count::CountImplied => Self::Implied,"}, {"sha": "0226f74906b5152b66a678c960200fcd844564da", "filename": "clippy_utils/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -36,7 +36,7 @@ fn extract_clone_suggestions<'tcx>(\n         if abort {\n             return false;\n         }\n-        if let ExprKind::MethodCall(seg, [recv], _) = expr.kind {\n+        if let ExprKind::MethodCall(seg, recv, [], _) = expr.kind {\n             if path_to_local_id(recv, id) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n                     abort = true;"}, {"sha": "d5f64e5118f563b97cc2c497b1d1fa2dd7429d78", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -6,8 +6,8 @@\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{\n-    Body, CastKind, NullOp, Operand, Place, ProjectionElem, Rvalue, Statement, StatementKind, Terminator,\n-    TerminatorKind,\n+    Body, CastKind, NonDivergingIntrinsic, NullOp, Operand, Place, ProjectionElem, Rvalue, Statement, StatementKind,\n+    Terminator, TerminatorKind,\n };\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n@@ -55,7 +55,7 @@ pub fn is_min_const_fn<'a, 'tcx>(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv:\n         body.local_decls.iter().next().unwrap().source_info.span,\n     )?;\n \n-    for bb in body.basic_blocks() {\n+    for bb in body.basic_blocks.iter() {\n         check_terminator(tcx, body, bb.terminator(), msrv)?;\n         for stmt in &bb.statements {\n             check_statement(tcx, body, def_id, stmt)?;\n@@ -212,11 +212,16 @@ fn check_statement<'tcx>(\n             check_place(tcx, **place, span, body)\n         },\n \n-        StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping { dst, src, count }) => {\n+        StatementKind::Intrinsic(box NonDivergingIntrinsic::Assume(op)) => check_operand(tcx, op, span, body),\n+\n+        StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(\n+            rustc_middle::mir::CopyNonOverlapping { dst, src, count },\n+        )) => {\n             check_operand(tcx, dst, span, body)?;\n             check_operand(tcx, src, span, body)?;\n             check_operand(tcx, count, span, body)\n         },\n+\n         // These are all NOPs\n         StatementKind::StorageLive(_)\n         | StatementKind::StorageDead(_)"}, {"sha": "cca71bbf76e2877196898bec350b5435dbcbeaf5", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -373,12 +373,14 @@ fn binop_to_string(op: AssocOp, lhs: &str, rhs: &str) -> String {\n         | AssocOp::LessEqual\n         | AssocOp::NotEqual\n         | AssocOp::Greater\n-        | AssocOp::GreaterEqual => format!(\n-            \"{} {} {}\",\n-            lhs,\n-            op.to_ast_binop().expect(\"Those are AST ops\").to_string(),\n-            rhs\n-        ),\n+        | AssocOp::GreaterEqual => {\n+            format!(\n+                \"{} {} {}\",\n+                lhs,\n+                op.to_ast_binop().expect(\"Those are AST ops\").to_string(),\n+                rhs\n+            )\n+        },\n         AssocOp::Assign => format!(\"{} = {}\", lhs, rhs),\n         AssocOp::AssignOp(op) => {\n             format!(\"{} {}= {}\", lhs, token_kind_to_string(&token::BinOp(op)), rhs)\n@@ -868,15 +870,15 @@ impl<'tcx> DerefDelegate<'_, 'tcx> {\n     /// indicates whether the function from `parent_expr` takes its args by double reference\n     fn func_takes_arg_by_double_ref(&self, parent_expr: &'tcx hir::Expr<'_>, cmt_hir_id: HirId) -> bool {\n         let ty = match parent_expr.kind {\n-            ExprKind::MethodCall(_, call_args, _) => {\n+            ExprKind::MethodCall(_, receiver, call_args, _) => {\n                 if let Some(sig) = self\n                     .cx\n                     .typeck_results()\n                     .type_dependent_def_id(parent_expr.hir_id)\n                     .map(|did| self.cx.tcx.fn_sig(did).skip_binder())\n                 {\n-                    call_args\n-                        .iter()\n+                    std::iter::once(receiver)\n+                        .chain(call_args.iter())\n                         .position(|arg| arg.hir_id == cmt_hir_id)\n                         .map(|i| sig.inputs()[i])\n                 } else {\n@@ -933,14 +935,14 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                     match &parent_expr.kind {\n                         // given expression is the self argument and will be handled completely by the compiler\n                         // i.e.: `|x| x.is_something()`\n-                        ExprKind::MethodCall(_, [self_expr, ..], _) if self_expr.hir_id == cmt.hir_id => {\n+                        ExprKind::MethodCall(_, self_expr, ..) if self_expr.hir_id == cmt.hir_id => {\n                             let _ = write!(self.suggestion_start, \"{}{}\", start_snip, ident_str_with_proj);\n                             self.next_pos = span.hi();\n                             return;\n                         },\n                         // item is used in a call\n                         // i.e.: `Call`: `|x| please(x)` or `MethodCall`: `|x| [1, 2, 3].contains(x)`\n-                        ExprKind::Call(_, [call_args @ ..]) | ExprKind::MethodCall(_, [_, call_args @ ..], _) => {\n+                        ExprKind::Call(_, [call_args @ ..]) | ExprKind::MethodCall(_, _, [call_args @ ..], _) => {\n                             let expr = self.cx.tcx.hir().expect_expr(cmt.hir_id);\n                             let arg_ty_kind = self.cx.typeck_results().expr_ty(expr).kind();\n "}, {"sha": "232d571902b6c20a8f84684e7ca1ca5e88206f47", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -274,7 +274,7 @@ pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n         }\n         !found\n     })\n-    .visit_expr(&cx.tcx.hir().body(body).value);\n+    .visit_expr(cx.tcx.hir().body(body).value);\n     found\n }\n \n@@ -568,6 +568,7 @@ pub fn for_each_local_use_after_expr<'tcx, B>(\n // Calls the given function for every unconsumed temporary created by the expression. Note the\n // function is only guaranteed to be called for types which need to be dropped, but it may be called\n // for other types.\n+#[allow(clippy::too_many_lines)]\n pub fn for_each_unconsumed_temporary<'tcx, B>(\n     cx: &LateContext<'tcx>,\n     e: &'tcx Expr<'tcx>,\n@@ -620,7 +621,13 @@ pub fn for_each_unconsumed_temporary<'tcx, B>(\n                     helper(typeck, true, arg, f)?;\n                 }\n             },\n-            ExprKind::MethodCall(_, args, _) | ExprKind::Tup(args) | ExprKind::Array(args) => {\n+            ExprKind::MethodCall(_, receiver, args, _) => {\n+                helper(typeck, true, receiver, f)?;\n+                for arg in args {\n+                    helper(typeck, true, arg, f)?;\n+                }\n+            },\n+            ExprKind::Tup(args) | ExprKind::Array(args) => {\n                 for arg in args {\n                     helper(typeck, true, arg, f)?;\n                 }"}, {"sha": "b6976366dafc9c66287a30ac986407e9865998eb", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-08-27\"\n+channel = \"nightly-2022-09-08\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "597318a556b850fc5b356214849b6c23ca734b13", "filename": "tests/ui/author.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fauthor.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fauthor.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor.stdout?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -6,7 +6,7 @@ if_chain! {\n     if match_qpath(qpath, &[\"char\"]);\n     if let ExprKind::Lit(ref lit) = expr.kind;\n     if let LitKind::Int(69, LitIntType::Unsuffixed) = lit.node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind;\n     if name.as_str() == \"x\";\n     then {\n         // report your lint here"}, {"sha": "a529981e2e68372c0cd034cdbc187cc0c2da900a", "filename": "tests/ui/author/blocks.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fauthor%2Fblocks.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fauthor%2Fblocks.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fblocks.stdout?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -5,13 +5,13 @@ if_chain! {\n     if let Some(init) = local.init;\n     if let ExprKind::Lit(ref lit) = init.kind;\n     if let LitKind::Int(42, LitIntType::Signed(IntTy::I32)) = lit.node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind;\n     if name.as_str() == \"x\";\n     if let StmtKind::Local(local1) = block.stmts[1].kind;\n     if let Some(init1) = local1.init;\n     if let ExprKind::Lit(ref lit1) = init1.kind;\n     if let LitKind::Float(_, LitFloatType::Suffixed(FloatTy::F32)) = lit1.node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local1.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local1.pat.kind;\n     if name1.as_str() == \"_t\";\n     if let StmtKind::Semi(e) = block.stmts[2].kind;\n     if let ExprKind::Unary(UnOp::Neg, inner) = e.kind;\n@@ -31,7 +31,7 @@ if_chain! {\n     if let ExprKind::Path(ref qpath) = func.kind;\n     if match_qpath(qpath, &[\"String\", \"new\"]);\n     if args.is_empty();\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind;\n     if name.as_str() == \"expr\";\n     if let Some(trailing_expr) = block.expr;\n     if let ExprKind::Call(func1, args1) = trailing_expr.kind;"}, {"sha": "ceb53fcd496369c11e90ea971cc02091e8c33780", "filename": "tests/ui/author/loop.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fauthor%2Floop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fauthor%2Floop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Floop.stdout?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -1,6 +1,6 @@\n if_chain! {\n     if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr);\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = pat.kind;\n     if name.as_str() == \"y\";\n     if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n     if matches!(qpath, QPath::LangItem(LangItem::Range, _));\n@@ -17,7 +17,7 @@ if_chain! {\n     if let Some(init) = local.init;\n     if let ExprKind::Path(ref qpath1) = init.kind;\n     if match_qpath(qpath1, &[\"y\"]);\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local.pat.kind;\n     if name1.as_str() == \"z\";\n     if block.expr.is_none();\n     then {"}, {"sha": "2cf69a035b4c7364ff6ee3991c78f50101f067bf", "filename": "tests/ui/author/matches.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fauthor%2Fmatches.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fauthor%2Fmatches.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.stdout?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -21,7 +21,7 @@ if_chain! {\n     if let Some(init1) = local1.init;\n     if let ExprKind::Lit(ref lit4) = init1.kind;\n     if let LitKind::Int(3, LitIntType::Unsuffixed) = lit4.node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local1.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local1.pat.kind;\n     if name.as_str() == \"x\";\n     if let Some(trailing_expr) = block.expr;\n     if let ExprKind::Path(ref qpath) = trailing_expr.kind;\n@@ -30,7 +30,7 @@ if_chain! {\n     if arms[2].guard.is_none();\n     if let ExprKind::Lit(ref lit5) = arms[2].body.kind;\n     if let LitKind::Int(1, LitIntType::Unsuffixed) = lit5.node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local.pat.kind;\n+    if let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local.pat.kind;\n     if name1.as_str() == \"a\";\n     then {\n         // report your lint here"}, {"sha": "b5bbc9e213c6e928330105b81cd6b0e7fb17fd45", "filename": "tests/ui/author/struct.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fauthor%2Fstruct.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fauthor%2Fstruct.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fstruct.stdout?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -53,11 +53,11 @@ if_chain! {\n     }\n }\n if_chain! {\n-    if let ExprKind::MethodCall(method_name, args, _) = expr.kind;\n+    if let ExprKind::MethodCall(method_name, receiver, args, _) = expr.kind;\n     if method_name.ident.as_str() == \"test\";\n-    if args.len() == 1;\n-    if let ExprKind::Path(ref qpath) = args[0].kind;\n+    if let ExprKind::Path(ref qpath) = receiver.kind;\n     if match_qpath(qpath, &[\"test_method_call\"]);\n+    if args.is_empty();\n     then {\n         // report your lint here\n     }"}, {"sha": "7ebf6ee993cbd7a02b6db0b178a3de67f828ba8c", "filename": "tests/ui/indexing_slicing_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Findexing_slicing_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Findexing_slicing_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing_index.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -3,7 +3,7 @@\n // We also check the out_of_bounds_indexing lint here, because it lints similar things and\n // we want to avoid false positives.\n #![warn(clippy::out_of_bounds_indexing)]\n-#![allow(const_err, clippy::no_effect, clippy::unnecessary_operation)]\n+#![allow(const_err, unconditional_panic, clippy::no_effect, clippy::unnecessary_operation)]\n \n const ARR: [i32; 2] = [1, 2];\n const REF: &i32 = &ARR[idx()]; // Ok, should not produce stderr."}, {"sha": "fee8e3030b8087cb16a52a6ffa55f67967c9158f", "filename": "tests/ui/needless_late_init.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fneedless_late_init.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fneedless_late_init.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init.fixed?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+#![feature(let_chains)]\n #![allow(\n     unused,\n     clippy::assign_op_pattern,"}, {"sha": "402d9f9ef7f81945f4dd9087c314ca0dfe0f8b32", "filename": "tests/ui/needless_late_init.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+#![feature(let_chains)]\n #![allow(\n     unused,\n     clippy::assign_op_pattern,"}, {"sha": "313cdbbeba183c3222fec8dd7848e48b27bb511b", "filename": "tests/ui/needless_late_init.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fneedless_late_init.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Fneedless_late_init.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init.stderr?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -1,5 +1,5 @@\n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:22:5\n+  --> $DIR/needless_late_init.rs:23:5\n    |\n LL |     let a;\n    |     ^^^^^^ created here\n@@ -13,7 +13,7 @@ LL |     let a = \"zero\";\n    |     ~~~~~\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:25:5\n+  --> $DIR/needless_late_init.rs:26:5\n    |\n LL |     let b;\n    |     ^^^^^^ created here\n@@ -27,7 +27,7 @@ LL |     let b = 1;\n    |     ~~~~~\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:26:5\n+  --> $DIR/needless_late_init.rs:27:5\n    |\n LL |     let c;\n    |     ^^^^^^ created here\n@@ -41,7 +41,7 @@ LL |     let c = 2;\n    |     ~~~~~\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:30:5\n+  --> $DIR/needless_late_init.rs:31:5\n    |\n LL |     let d: usize;\n    |     ^^^^^^^^^^^^^ created here\n@@ -54,7 +54,7 @@ LL |     let d: usize = 1;\n    |     ~~~~~~~~~~~~\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:33:5\n+  --> $DIR/needless_late_init.rs:34:5\n    |\n LL |     let e;\n    |     ^^^^^^ created here\n@@ -67,7 +67,7 @@ LL |     let e = format!(\"{}\", d);\n    |     ~~~~~\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:38:5\n+  --> $DIR/needless_late_init.rs:39:5\n    |\n LL |     let a;\n    |     ^^^^^^\n@@ -88,7 +88,7 @@ LL |     };\n    |      +\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:47:5\n+  --> $DIR/needless_late_init.rs:48:5\n    |\n LL |     let b;\n    |     ^^^^^^\n@@ -109,7 +109,7 @@ LL |     };\n    |      +\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:54:5\n+  --> $DIR/needless_late_init.rs:55:5\n    |\n LL |     let d;\n    |     ^^^^^^\n@@ -130,7 +130,7 @@ LL |     };\n    |      +\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:62:5\n+  --> $DIR/needless_late_init.rs:63:5\n    |\n LL |     let e;\n    |     ^^^^^^\n@@ -151,7 +151,7 @@ LL |     };\n    |      +\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:69:5\n+  --> $DIR/needless_late_init.rs:70:5\n    |\n LL |     let f;\n    |     ^^^^^^\n@@ -167,7 +167,7 @@ LL +         1 => \"three\",\n    |\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:75:5\n+  --> $DIR/needless_late_init.rs:76:5\n    |\n LL |     let g: usize;\n    |     ^^^^^^^^^^^^^\n@@ -187,7 +187,7 @@ LL |     };\n    |      +\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:83:5\n+  --> $DIR/needless_late_init.rs:84:5\n    |\n LL |     let x;\n    |     ^^^^^^ created here\n@@ -201,7 +201,7 @@ LL |     let x = 1;\n    |     ~~~~~\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:87:5\n+  --> $DIR/needless_late_init.rs:88:5\n    |\n LL |     let x;\n    |     ^^^^^^ created here\n@@ -215,7 +215,7 @@ LL |     let x = SignificantDrop;\n    |     ~~~~~\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:91:5\n+  --> $DIR/needless_late_init.rs:92:5\n    |\n LL |     let x;\n    |     ^^^^^^ created here\n@@ -229,7 +229,7 @@ LL |     let x = SignificantDrop;\n    |     ~~~~~\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:110:5\n+  --> $DIR/needless_late_init.rs:111:5\n    |\n LL |     let a;\n    |     ^^^^^^\n@@ -250,7 +250,7 @@ LL |     };\n    |      +\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:127:5\n+  --> $DIR/needless_late_init.rs:128:5\n    |\n LL |     let a;\n    |     ^^^^^^"}, {"sha": "2113173170868409b861f0eaa34fc54ec27a34de", "filename": "tests/ui/uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Funinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fa80dda57f3c468bb290657eb04720144506ab/tests%2Fui%2Funinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.rs?ref=32fa80dda57f3c468bb290657eb04720144506ab", "patch": "@@ -1,5 +1,5 @@\n #![feature(stmt_expr_attributes)]\n-#![allow(clippy::let_unit_value)]\n+#![allow(clippy::let_unit_value, invalid_value)]\n \n use std::mem::{self, MaybeUninit};\n "}]}