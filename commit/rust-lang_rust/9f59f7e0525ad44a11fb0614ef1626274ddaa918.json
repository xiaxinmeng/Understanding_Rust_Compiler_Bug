{"sha": "9f59f7e0525ad44a11fb0614ef1626274ddaa918", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNTlmN2UwNTI1YWQ0NGExMWZiMDYxNGVmMTYyNjI3NGRkYWE5MTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-19T00:58:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-20T19:27:51Z"}, "message": "Add error codes to rustc", "tree": {"sha": "2650d66453430fad95f7f3c42556e1b43ab56132", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2650d66453430fad95f7f3c42556e1b43ab56132"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f59f7e0525ad44a11fb0614ef1626274ddaa918", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f59f7e0525ad44a11fb0614ef1626274ddaa918", "html_url": "https://github.com/rust-lang/rust/commit/9f59f7e0525ad44a11fb0614ef1626274ddaa918", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f59f7e0525ad44a11fb0614ef1626274ddaa918/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf629e7cfa54e4bd641dbbafa2297159a7c52749", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf629e7cfa54e4bd641dbbafa2297159a7c52749", "html_url": "https://github.com/rust-lang/rust/commit/cf629e7cfa54e4bd641dbbafa2297159a7c52749"}], "stats": {"total": 279, "additions": 137, "deletions": 142}, "files": [{"sha": "1dbd6eb4e8d5a06e51eb2b411192e517e6485a2e", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=9f59f7e0525ad44a11fb0614ef1626274ddaa918", "patch": "@@ -53,7 +53,52 @@ register_diagnostics! {\n     E0161,\n     E0162,\n     E0165,\n-    E0170\n+    E0170,\n+    E0261, // use of undeclared lifetime name\n+    E0262, // illegal lifetime parameter name\n+    E0263, // lifetime name declared twice in same scope\n+    E0264, // unknown external lang item\n+    E0265, // recursive constant\n+    E0266, // expected item\n+    E0267, // thing inside of a closure\n+    E0268, // thing outside of a loop\n+    E0269, // not all control paths return a value\n+    E0270, // computation may converge in a function marked as diverging\n+    E0271, // type mismatch resolving\n+    E0272, // rustc_on_unimplemented attribute refers to non-existent type parameter\n+    E0273, // rustc_on_unimplemented must have named format arguments\n+    E0274, // rustc_on_unimplemented must have a value\n+    E0275, // overflow evaluating requirement\n+    E0276, // requirement appears on impl method but not on corresponding trait method\n+    E0277, // trait is not implemented for type\n+    E0278, // requirement is not satisfied\n+    E0279, // requirement is not satisfied\n+    E0280, // requirement is not satisfied\n+    E0281, // type implements trait but other trait is required\n+    E0282, // unable to infer enough type information about\n+    E0283, // cannot resolve type\n+    E0284, // cannot resolve type\n+    E0285, // overflow evaluation builtin bounds\n+    E0296, // malformed recursion limit attribute\n+    E0297, // refutable pattern in for loop binding\n+    E0298, // mismatched types between arms\n+    E0299, // mismatched types between arms\n+    E0300, // unexpanded macro\n+    E0301, // cannot mutable borrow in a pattern guard\n+    E0302, // cannot assign in a pattern guard\n+    E0303, // pattern bindings are not allowed after an `@`\n+    E0304, // expected signed integer constant\n+    E0305, // expected constant\n+    E0306, // expected positive integer for repeat count\n+    E0307, // expected constant integer for repeat count\n+    E0308,\n+    E0309, // thing may not live long enough\n+    E0310, // thing may not live long enough\n+    E0311, // thing may not live long enough\n+    E0312, // lifetime of reference outlives lifetime of borrowed content\n+    E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n+    E0314, // closure outlives stack frame\n+    E0315 // cannot invoke closure outside of its lifetime\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "623f3525d4a90b3111740d20ce7e43b51d50c38a", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=9f59f7e0525ad44a11fb0614ef1626274ddaa918", "patch": "@@ -73,12 +73,12 @@ impl<'a> CheckLoopVisitor<'a> {\n         match self.cx {\n             Loop => {}\n             Closure => {\n-                self.sess.span_err(span,\n-                                   &format!(\"`{}` inside of a closure\", name)[]);\n+                span_err!(self.sess, span, E0267,\n+                                   \"`{}` inside of a closure\", name);\n             }\n             Normal => {\n-                self.sess.span_err(span,\n-                                   &format!(\"`{}` outside of loop\", name)[]);\n+                span_err!(self.sess, span, E0268,\n+                                   \"`{}` outside of loop\", name);\n             }\n         }\n     }"}, {"sha": "f6db0cf755b9c9b4318dda54465c4e03c4dc204d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9f59f7e0525ad44a11fb0614ef1626274ddaa918", "patch": "@@ -226,11 +226,10 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n         ast::ExprForLoop(ref pat, _, _, _) => {\n             let mut static_inliner = StaticInliner::new(cx.tcx);\n             is_refutable(cx, &*static_inliner.fold_pat((*pat).clone()), |uncovered_pat| {\n-                cx.tcx.sess.span_err(\n-                    pat.span,\n-                    &format!(\"refutable pattern in `for` loop binding: \\\n+                span_err!(cx.tcx.sess, pat.span, E0297,\n+                    \"refutable pattern in `for` loop binding: \\\n                             `{}` not covered\",\n-                            pat_to_string(uncovered_pat))[]);\n+                            pat_to_string(uncovered_pat));\n             });\n \n             // Check legality of move bindings.\n@@ -869,7 +868,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 Some(true) => Some(vec![]),\n                 Some(false) => None,\n                 None => {\n-                    cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n+                    span_err!(cx.tcx.sess, pat_span, E0298, \"mismatched types between arms\");\n                     None\n                 }\n             }\n@@ -882,7 +881,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 Some(true) => Some(vec![]),\n                 Some(false) => None,\n                 None => {\n-                    cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n+                    span_err!(cx.tcx.sess, pat_span, E0299, \"mismatched types between arms\");\n                     None\n                 }\n             }\n@@ -921,7 +920,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         ast::PatMac(_) => {\n-            cx.tcx.sess.span_err(pat_span, \"unexpanded macro\");\n+            span_err!(cx.tcx.sess, pat_span, E0300, \"unexpanded macro\");\n             None\n         }\n     };\n@@ -1082,11 +1081,8 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n               _: LoanCause) {\n         match kind {\n             MutBorrow => {\n-                self.cx\n-                    .tcx\n-                    .sess\n-                    .span_err(span,\n-                              \"cannot mutably borrow in a pattern guard\")\n+                span_err!(self.cx.tcx.sess, span, E0301,\n+                          \"cannot mutably borrow in a pattern guard\")\n             }\n             ImmBorrow | UniqueImmBorrow => {}\n         }\n@@ -1095,10 +1091,7 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n     fn mutate(&mut self, _: NodeId, span: Span, _: cmt, mode: MutateMode) {\n         match mode {\n             JustWrite | WriteAndRead => {\n-                self.cx\n-                    .tcx\n-                    .sess\n-                    .span_err(span, \"cannot assign in a pattern guard\")\n+                span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")\n             }\n             Init => {}\n         }\n@@ -1120,7 +1113,7 @@ struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     fn visit_pat(&mut self, pat: &Pat) {\n         if !self.bindings_allowed && pat_is_binding(&self.cx.tcx.def_map, pat) {\n-            self.cx.tcx.sess.span_err(pat.span,\n+            span_err!(self.cx.tcx.sess, pat.span, E0303,\n                                       \"pattern bindings are not allowed \\\n                                        after an `@`\");\n         }"}, {"sha": "4280b7fe3f09649170a73dc7e37f90873a22fa9f", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=9f59f7e0525ad44a11fb0614ef1626274ddaa918", "patch": "@@ -83,7 +83,7 @@ pub fn check_item_recursion<'a>(sess: &'a Session,\n impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_item(&mut self, it: &ast::Item) {\n         if self.idstack.iter().any(|x| x == &(it.id)) {\n-            self.sess.span_err(self.root_it.span, \"recursive constant\");\n+            span_err!(self.sess, self.root_it.span, E0265, \"recursive constant\");\n             return;\n         }\n         self.idstack.push(it.id);\n@@ -103,9 +103,9 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n                             self.visit_item(item),\n                           ast_map::NodeForeignItem(_) => {},\n                           _ => {\n-                            self.sess.span_err(e.span,\n-                              &format!(\"expected item, found {}\",\n-                                      self.ast_map.node_to_string(def_id.node))[]);\n+                            span_err!(self.sess, e.span, E0266,\n+                              \"expected item, found {}\",\n+                                      self.ast_map.node_to_string(def_id.node));\n                             return;\n                           },\n                         }"}, {"sha": "18c36f870b5bce09da24a3222f81d46bc56a487f", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=9f59f7e0525ad44a11fb0614ef1626274ddaa918", "patch": "@@ -371,12 +371,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::EquatePredicate(_) => \"equality predicate not satisfied\",\n         };\n \n-        self.tcx.sess.span_err(\n-            trace.origin.span(),\n-            &format!(\"{}: {} ({})\",\n+        span_err!(self.tcx.sess, trace.origin.span(), E0308,\n+            \"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr))[]);\n+                 ty::type_err_to_str(self.tcx, terr));\n \n         match trace.origin {\n             infer::MatchExpressionArm(_, arm_span) =>\n@@ -443,9 +442,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         match sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n-                self.tcx.sess.span_err(\n-                    origin.span(),\n-                    &format!(\"{} may not live long enough\", labeled_user_string)[]);\n+                span_err!(self.tcx.sess, origin.span(), E0309,\n+                    \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     &format!(\n@@ -456,9 +454,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n-                self.tcx.sess.span_err(\n-                    origin.span(),\n-                    &format!(\"{} may not live long enough\", labeled_user_string)[]);\n+                span_err!(self.tcx.sess, origin.span(), E0310,\n+                    \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     &format!(\n@@ -468,11 +465,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             _ => {\n                 // If not, be less specific.\n-                self.tcx.sess.span_err(\n-                    origin.span(),\n-                    &format!(\n+                span_err!(self.tcx.sess, origin.span(), E0311,\n                         \"{} may not live long enough\",\n-                        labeled_user_string)[]);\n+                        labeled_user_string);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     &format!(\n@@ -499,8 +494,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.report_and_explain_type_error(trace, &terr);\n             }\n             infer::Reborrow(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n+                span_err!(self.tcx.sess, span, E0312,\n                     \"lifetime of reference outlines \\\n                      lifetime of borrowed content...\");\n                 note_and_explain_region(\n@@ -515,14 +509,13 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"lifetime of borrowed pointer outlives \\\n+                span_err!(self.tcx.sess, span, E0313,\n+                    \"lifetime of borrowed pointer outlives \\\n                             lifetime of captured variable `{}`...\",\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string())[]);\n+                                .to_string());\n                 note_and_explain_region(\n                     self.tcx,\n                     \"...the borrowed pointer is valid for \",\n@@ -539,8 +532,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::InfStackClosure(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n+                span_err!(self.tcx.sess, span, E0314,\n                     \"closure outlives stack frame\");\n                 note_and_explain_region(\n                     self.tcx,\n@@ -554,8 +546,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::InvokeClosure(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n+                span_err!(self.tcx.sess, span, E0315,\n                     \"cannot invoke closure outside of its lifetime\");\n                 note_and_explain_region(\n                     self.tcx,"}, {"sha": "f71779e23333f80d6de43509b86b86c0b1a0ba38", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9f59f7e0525ad44a11fb0614ef1626274ddaa918", "patch": "@@ -1557,8 +1557,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                             },\n                         _ => false\n                     };\n-                    self.ir.tcx.sess.span_err(\n-                        sp, \"not all control paths return a value\");\n+                    span_err!(self.ir.tcx.sess, sp, E0269, \"not all control paths return a value\");\n                     if ends_with_stmt {\n                         let last_stmt = body.stmts.first().unwrap();\n                         let original_span = original_sp(self.ir.tcx.sess.codemap(),\n@@ -1575,7 +1574,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n             ty::FnDiverging\n                 if self.live_on_entry(entry_ln, self.s.clean_exit_var).is_some() => {\n-                    self.ir.tcx.sess.span_err(sp,\n+                    span_err!(self.ir.tcx.sess, sp, E0270,\n                         \"computation may converge in a function marked as diverging\");\n                 }\n "}, {"sha": "81cbdf13c518925c60ef57b9b1d260a42fb8b870", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=9f59f7e0525ad44a11fb0614ef1626274ddaa918", "patch": "@@ -33,7 +33,7 @@ pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n             }\n         }\n \n-        sess.span_err(attr.span, \"malformed recursion limit attribute, \\\n+        span_err!(sess, attr.span, E0296, \"malformed recursion limit attribute, \\\n                                   expected #![recursion_limit=\\\"N\\\"]\");\n     }\n }"}, {"sha": "be2b3026755b203ea9a433b89513c99f5d3fc012", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9f59f7e0525ad44a11fb0614ef1626274ddaa918", "patch": "@@ -396,10 +396,9 @@ impl<'a> LifetimeContext<'a> {\n     }\n \n     fn unresolved_lifetime_ref(&self, lifetime_ref: &ast::Lifetime) {\n-        self.sess.span_err(\n-            lifetime_ref.span,\n-            &format!(\"use of undeclared lifetime name `{}`\",\n-                    token::get_name(lifetime_ref.name))[]);\n+        span_err!(self.sess, lifetime_ref.span, E0261,\n+            \"use of undeclared lifetime name `{}`\",\n+                    token::get_name(lifetime_ref.name));\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n@@ -409,11 +408,9 @@ impl<'a> LifetimeContext<'a> {\n             let special_idents = [special_idents::static_lifetime];\n             for lifetime in lifetimes.iter() {\n                 if special_idents.iter().any(|&i| i.name == lifetime.lifetime.name) {\n-                    self.sess.span_err(\n-                        lifetime.lifetime.span,\n-                        &format!(\"illegal lifetime parameter name: `{}`\",\n-                                token::get_name(lifetime.lifetime.name))\n-                        []);\n+                    span_err!(self.sess, lifetime.lifetime.span, E0262,\n+                        \"illegal lifetime parameter name: `{}`\",\n+                                token::get_name(lifetime.lifetime.name));\n                 }\n             }\n \n@@ -422,12 +419,10 @@ impl<'a> LifetimeContext<'a> {\n                 let lifetime_j = &lifetimes[j];\n \n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n-                    self.sess.span_err(\n-                        lifetime_j.lifetime.span,\n-                        &format!(\"lifetime name `{}` declared twice in \\\n+                    span_err!(self.sess, lifetime_j.lifetime.span, E0263,\n+                        \"lifetime name `{}` declared twice in \\\n                                 the same scope\",\n-                                token::get_name(lifetime_j.lifetime.name))\n-                        []);\n+                                token::get_name(lifetime_j.lifetime.name));\n                 }\n             }\n "}, {"sha": "93805750606efa8afe4e511b9e99d489afc0b9ca", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 31, "deletions": 56, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=9f59f7e0525ad44a11fb0614ef1626274ddaa918", "patch": "@@ -55,12 +55,10 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n     if !predicate.references_error() {\n-        infcx.tcx.sess.span_err(\n-            obligation.cause.span,\n-            format!(\n+        span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n                 \"type mismatch resolving `{}`: {}\",\n                 predicate.user_string(infcx.tcx),\n-                ty::type_err_to_str(infcx.tcx, &error.err)).as_slice());\n+                ty::type_err_to_str(infcx.tcx, &error.err));\n         note_obligation_cause(infcx, obligation);\n     }\n }\n@@ -97,28 +95,25 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             Position::ArgumentNamed(s) => match generic_map.get(s) {\n                                 Some(val) => Some(val.as_slice()),\n                                 None => {\n-                                    infcx.tcx.sess\n-                                         .span_err(err_sp,\n-                                                   format!(\"the #[rustc_on_unimplemented] \\\n+                                    span_err!(infcx.tcx.sess, err_sp, E0272,\n+                                                   \"the #[rustc_on_unimplemented] \\\n                                                             attribute on \\\n                                                             trait definition for {} refers to \\\n                                                             non-existent type parameter {}\",\n-                                                           trait_str, s)\n-                                                   .as_slice());\n+                                                           trait_str, s);\n                                     errored = true;\n                                     None\n                                 }\n                             },\n                             _ => {\n-                                infcx.tcx.sess\n-                                     .span_err(err_sp,\n-                                               format!(\"the #[rustc_on_unimplemented] \\\n+                                     span_err!(infcx.tcx.sess, err_sp, E0273,\n+                                               \"the #[rustc_on_unimplemented] \\\n                                                         attribute on \\\n                                                         trait definition for {} must have named \\\n                                                         format arguments, \\\n                                                         eg `#[rustc_on_unimplemented = \\\n                                                         \\\"foo {{T}}\\\"]`\",\n-                                                       trait_str).as_slice());\n+                                                       trait_str);\n                                 errored = true;\n                                 None\n                             }\n@@ -130,11 +125,11 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     report = Some(err);\n                 }\n             } else {\n-                infcx.tcx.sess.span_err(err_sp,\n-                                        format!(\"the #[rustc_on_unimplemented] attribute on \\\n+                span_err!(infcx.tcx.sess, err_sp, E0274,\n+                                        \"the #[rustc_on_unimplemented] attribute on \\\n                                                  trait definition for {} must have a value, \\\n                                                  eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n-                                                 trait_str).as_slice());\n+                                                 trait_str);\n             }\n             break;\n         }\n@@ -151,11 +146,9 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             // We could track the stack here more precisely if we wanted, I imagine.\n             let predicate =\n                 infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-            infcx.tcx.sess.span_err(\n-                obligation.cause.span,\n-                format!(\n+            span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n                     \"overflow evaluating the requirement `{}`\",\n-                    predicate.user_string(infcx.tcx)).as_slice());\n+                    predicate.user_string(infcx.tcx));\n \n             suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n \n@@ -165,12 +158,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         SelectionError::Unimplemented => {\n             match &obligation.cause.code {\n                 &ObligationCauseCode::CompareImplMethodObligation => {\n-                    infcx.tcx.sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n+                    span_err!(infcx.tcx.sess, obligation.cause.span, E0276,\n                             \"the requirement `{}` appears on the impl \\\n                             method but not on the corresponding trait method\",\n-                            obligation.predicate.user_string(infcx.tcx)).as_slice());\n+                            obligation.predicate.user_string(infcx.tcx));;\n                 }\n                 _ => {\n                     match obligation.predicate {\n@@ -180,12 +171,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n                             if !trait_predicate.references_error() {\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n-                                infcx.tcx.sess.span_err(\n-                                    obligation.cause.span,\n-                                    format!(\n+                                span_err!(infcx.tcx.sess, obligation.cause.span, E0277,\n                                         \"the trait `{}` is not implemented for the type `{}`\",\n                                         trait_ref.user_string(infcx.tcx),\n-                                        trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n+                                        trait_ref.self_ty().user_string(infcx.tcx));\n                                 // Check if it has a custom \"#[rustc_on_unimplemented]\"\n                                 // error message, report with that message if it does\n                                 let custom_note = report_on_unimplemented(infcx, &*trait_ref.0,\n@@ -201,34 +190,28 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                             let err = infcx.equality_predicate(obligation.cause.span,\n                                                                &predicate).unwrap_err();\n-                            infcx.tcx.sess.span_err(\n-                                obligation.cause.span,\n-                                format!(\n+                            span_err!(infcx.tcx.sess, obligation.cause.span, E0278,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n                                     predicate.user_string(infcx.tcx),\n-                                    ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                                    ty::type_err_to_str(infcx.tcx, &err));\n                         }\n \n                         ty::Predicate::RegionOutlives(ref predicate) => {\n                             let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                             let err = infcx.region_outlives_predicate(obligation.cause.span,\n                                                                       &predicate).unwrap_err();\n-                            infcx.tcx.sess.span_err(\n-                                obligation.cause.span,\n-                                format!(\n+                            span_err!(infcx.tcx.sess, obligation.cause.span, E0279,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n                                     predicate.user_string(infcx.tcx),\n-                                    ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                                    ty::type_err_to_str(infcx.tcx, &err));\n                         }\n \n                         ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n                                 let predicate =\n                                     infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-                                infcx.tcx.sess.span_err(\n-                                    obligation.cause.span,\n-                                    format!(\n+                                span_err!(infcx.tcx.sess, obligation.cause.span, E0280,\n                                         \"the requirement `{}` is not satisfied\",\n-                                        predicate.user_string(infcx.tcx)).as_slice());\n+                                        predicate.user_string(infcx.tcx));\n                         }\n                     }\n                 }\n@@ -239,15 +222,13 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n             let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n             if !ty::type_is_error(actual_trait_ref.self_ty()) {\n-                infcx.tcx.sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n+                span_err!(infcx.tcx.sess, obligation.cause.span, E0281,\n                         \"type mismatch: the type `{}` implements the trait `{}`, \\\n                         but the trait `{}` is required ({})\",\n                         expected_trait_ref.self_ty().user_string(infcx.tcx),\n                         expected_trait_ref.user_string(infcx.tcx),\n                         actual_trait_ref.user_string(infcx.tcx),\n-                        ty::type_err_to_str(infcx.tcx, e)).as_slice());\n+                        ty::type_err_to_str(infcx.tcx, e));\n                     note_obligation_cause(infcx, obligation);\n             }\n         }\n@@ -293,18 +274,14 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         infcx.tcx.lang_items.sized_trait()\n                         .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n                     {\n-                        infcx.tcx.sess.span_err(\n-                            obligation.cause.span,\n-                            format!(\n+                        span_err!(infcx.tcx.sess, obligation.cause.span, E0282,\n                                 \"unable to infer enough type information about `{}`; \\\n                                  type annotations required\",\n-                                self_ty.user_string(infcx.tcx)).as_slice());\n+                                self_ty.user_string(infcx.tcx));\n                     } else {\n-                        infcx.tcx.sess.span_err(\n-                            obligation.cause.span,\n-                            format!(\n+                        span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n                                 \"type annotations required: cannot resolve `{}`\",\n-                                predicate.user_string(infcx.tcx)).as_slice());\n+                                predicate.user_string(infcx.tcx));;\n                         note_obligation_cause(infcx, obligation);\n                     }\n                 }\n@@ -323,11 +300,9 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n         _ => {\n             if !infcx.tcx.sess.has_errors() {\n-                infcx.tcx.sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n+                span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n                         \"type annotations required: cannot resolve `{}`\",\n-                        predicate.user_string(infcx.tcx)).as_slice());\n+                        predicate.user_string(infcx.tcx));;\n                 note_obligation_cause(infcx, obligation);\n             }\n         }"}, {"sha": "89459f95b879fe730c020fc9ab88ae94309b54ba", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=9f59f7e0525ad44a11fb0614ef1626274ddaa918", "patch": "@@ -379,11 +379,10 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n             false\n         }\n         Err(Overflow) => {\n-            infcx.tcx.sess.span_err(\n-                span,\n-                format!(\"overflow evaluating whether `{}` is `{}`\",\n-                        ty.user_string(infcx.tcx),\n-                        bound.user_string(infcx.tcx)).as_slice());\n+            span_err!(infcx.tcx.sess, span, E0285,\n+                \"overflow evaluating whether `{}` is `{}`\",\n+                      ty.user_string(infcx.tcx),\n+                      bound.user_string(infcx.tcx));\n             suggest_new_overflow_limit(infcx.tcx, span);\n             false\n         }"}, {"sha": "e5bbd01dde67724c2817a6f58bc4868c04b321c6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9f59f7e0525ad44a11fb0614ef1626274ddaa918", "patch": "@@ -5369,15 +5369,13 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                                 discriminant = val as Disr\n                                             }\n                                             Ok(_) => {\n-                                                cx.sess\n-                                                  .span_err(e.span,\n+                                                span_err!(cx.sess, e.span, E0304,\n                                                             \"expected signed integer constant\");\n                                             }\n                                             Err(ref err) => {\n-                                                cx.sess\n-                                                  .span_err(e.span,\n-                                                            &format!(\"expected constant: {}\",\n-                                                                    *err)[]);\n+                                                span_err!(cx.sess, e.span, E0305,\n+                                                            \"expected constant: {}\",\n+                                                                    *err);\n                                             }\n                                         },\n                                     None => {}\n@@ -5851,9 +5849,9 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n                 const_eval::const_binary(_) =>\n                     \"binary array\"\n             };\n-            tcx.sess.span_err(count_expr.span, &format!(\n+            span_err!(tcx.sess, count_expr.span, E0306,\n                 \"expected positive integer for repeat count, found {}\",\n-                found)[]);\n+                found);\n         }\n         Err(_) => {\n             let found = match count_expr.node {\n@@ -5866,9 +5864,9 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n                 _ =>\n                     \"non-constant expression\"\n             };\n-            tcx.sess.span_err(count_expr.span, &format!(\n+            span_err!(tcx.sess, count_expr.span, E0307,\n                 \"expected constant integer for repeat count, found {}\",\n-                found)[]);\n+                found);\n         }\n     }\n     0"}, {"sha": "25cca98c5fb4788af7f1fce215b2444bb43f8579", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59f7e0525ad44a11fb0614ef1626274ddaa918/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=9f59f7e0525ad44a11fb0614ef1626274ddaa918", "patch": "@@ -99,9 +99,9 @@ impl<'a> Context<'a> {\n                 self.items.missing.push(lang_items::$item);\n             }\n         } else)* {\n-            self.sess.span_err(span,\n-                               format!(\"unknown external lang item: `{}`\",\n-                                       name).as_slice());\n+            span_err!(self.sess, span, E0264,\n+                               \"unknown external lang item: `{}`\",\n+                                       name);\n         }\n     }\n }"}]}