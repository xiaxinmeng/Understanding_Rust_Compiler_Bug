{"sha": "8f5b899c8533046f0eed7a6148ce60ce591b4666", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNWI4OTljODUzMzA0NmYwZWVkN2E2MTQ4Y2U2MGNlNTkxYjQ2NjY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-14T01:12:56Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-14T01:13:35Z"}, "message": "Use strings.rs rather than local modules", "tree": {"sha": "e14b646e62c6f4620cbb06c3e79c09365acd71af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e14b646e62c6f4620cbb06c3e79c09365acd71af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f5b899c8533046f0eed7a6148ce60ce591b4666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5b899c8533046f0eed7a6148ce60ce591b4666", "html_url": "https://github.com/rust-lang/rust/commit/8f5b899c8533046f0eed7a6148ce60ce591b4666", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f5b899c8533046f0eed7a6148ce60ce591b4666/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76854677c1b730ecb262b5277a6520fc2ff75974", "url": "https://api.github.com/repos/rust-lang/rust/commits/76854677c1b730ecb262b5277a6520fc2ff75974", "html_url": "https://github.com/rust-lang/rust/commit/76854677c1b730ecb262b5277a6520fc2ff75974"}], "stats": {"total": 1608, "additions": 6, "deletions": 1602}, "files": [{"sha": "770a1c1b9453282279cc20ea191eaaa88e94ba5c", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f5b899c8533046f0eed7a6148ce60ce591b4666/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8f5b899c8533046f0eed7a6148ce60ce591b4666/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=8f5b899c8533046f0eed7a6148ce60ce591b4666", "patch": "@@ -8,9 +8,9 @@ repository = \"https://github.com/nick29581/rustfmt\"\n readme = \"README.md\"\n license = \"Apache-2.0/MIT\"\n \n-#[dependencies.reprint]\n-#reprint = \"0.0.1\"\n-#path = \"/home/ncameron/reprint\"\n+[dependencies.strings]\n+strings = \"0.0.1\"\n+git = \"https://github.com/nrc/strings.rs.git\"\n \n [[bin]]\n name = \"rustfmt\""}, {"sha": "752ae942f1f98b3bfb9d8e2dae9002e7b91f5be1", "filename": "src/changes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f5b899c8533046f0eed7a6148ce60ce591b4666/src%2Fchanges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5b899c8533046f0eed7a6148ce60ce591b4666/src%2Fchanges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchanges.rs?ref=8f5b899c8533046f0eed7a6148ce60ce591b4666", "patch": "@@ -13,7 +13,7 @@\n // print to files \n // tests\n \n-use string_buffer::StringBuffer;\n+use strings::string_buffer::StringBuffer;\n use std::collections::HashMap;\n use syntax::codemap::{CodeMap, Span};\n use std::fmt;"}, {"sha": "a124eb9e2b4830d62d6b6653ddaa66d406cebfc3", "filename": "src/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f5b899c8533046f0eed7a6148ce60ce591b4666/src%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5b899c8533046f0eed7a6148ce60ce591b4666/src%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmod.rs?ref=8f5b899c8533046f0eed7a6148ce60ce591b4666", "patch": "@@ -12,8 +12,6 @@\n #![feature(box_patterns)]\n #![feature(rustc_private)]\n #![feature(collections)]\n-#![feature(core)]\n-#![feature(unicode)]\n #![feature(exit_status)]\n #![feature(str_char)]\n \n@@ -23,7 +21,6 @@\n \n // TODO priorities\n // Fix fns and methods properly - need visibility in visit\n-// Use strings crate\n // Writing output\n // Working on multiple files, inclding empty ones\n // Smoke testing till we can use it\n@@ -36,6 +33,8 @@ extern crate rustc;\n extern crate rustc_driver;\n extern crate syntax;\n \n+extern crate strings;\n+\n use rustc::session::Session;\n use rustc::session::config::{self, Input};\n use rustc_driver::{driver, CompilerCalls, Compilation};\n@@ -51,8 +50,6 @@ use std::path::PathBuf;\n \n use changes::ChangeSet;\n \n-pub mod rope;\n-pub mod string_buffer;\n mod changes;\n \n const IDEAL_WIDTH: usize = 80;"}, {"sha": "61f543175cfdba75e0670239c1eeb51dec8c7793", "filename": "src/rope.rs", "status": "removed", "additions": 0, "deletions": 1281, "changes": 1281, "blob_url": "https://github.com/rust-lang/rust/blob/76854677c1b730ecb262b5277a6520fc2ff75974/src%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76854677c1b730ecb262b5277a6520fc2ff75974/src%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frope.rs?ref=76854677c1b730ecb262b5277a6520fc2ff75974", "patch": "@@ -1,1281 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// TODO\n-// ----\n-// docs - mod docs, item docs\n-// tests\n-// pull out into its own crate\n-// impl Default, Extend\n-// impl DoubleEndedIter and ExactSizeIter for RopeChars\n-// better allocation\n-// balancing?\n-\n-extern crate unicode;\n-use std::fmt;\n-use std::ops::Range;\n-use std::num::{SignedInt, Int};\n-\n-// A Rope, based on an unbalanced binary tree. The rope is somewhat special in\n-// that it tracks positions in the source text. So when locating a position in\n-// the rope, the user can use either a current position in the text or a\n-// position in the source text, which the Rope will adjust to a current position\n-// whilst searching.\n-pub struct Rope {\n-    root: Node,\n-    len: usize,\n-    src_len: usize,\n-    // FIXME: Allocation is very dumb at the moment, we always add another\n-    // buffer for every inserted string and we never resuse or collect old\n-    // memory\n-    storage: Vec<Vec<u8>>\n-}\n-\n-// A view over a portion of a Rope. Analagous to string slices (`str`);\n-pub struct RopeSlice<'rope> {\n-    // All nodes which make up the slice, in order.\n-    nodes: Vec<&'rope Lnode>,\n-    // The offset of the start point in the first node.\n-    start: usize,\n-    // The length of text in the last node.\n-    len: usize,\n-}\n-\n-// An iterator over the chars in a rope.\n-pub struct RopeChars<'rope> {\n-    data: RopeSlice<'rope>,\n-    cur_node: usize,\n-    cur_byte: usize,\n-    abs_byte: usize,\n-}\n-\n-impl Rope {\n-    // Create an empty rope.\n-    pub fn new() -> Rope {\n-        Rope {\n-            root: Node::empty_inner(),\n-            len: 0,\n-            src_len: 0,\n-            storage: vec![],\n-        }\n-    }\n-\n-    // Uses text as initial storage.\n-    pub fn from_string(text: String) -> Rope {\n-        // TODO should split very large texts into segments as we insert\n-\n-        let mut result = Rope::new();\n-        result.insert(0, text);\n-        result.fix_src();\n-        result\n-    }\n-\n-    // When initialising a rope, indicates that the rope is complete wrt the\n-    // source text.\n-    fn fix_src(&mut self) {\n-        self.root.fix_src();\n-        self.src_len = self.len;\n-    }\n-\n-    // Length of the rope.\n-    pub fn len(&self) -> usize {\n-        self.len\n-    }\n-\n-    pub fn insert_copy(&mut self, start: usize, text: &str) {\n-        // FIXME If we did clever things with allocation, we could do better here.\n-        self.insert(start, text.to_string());\n-    }\n-\n-    pub fn insert(&mut self, start: usize, text: String) {\n-        self.insert_inner(start,\n-                          text,\n-                          |this, node| this.root.insert(node, start, start))\n-    }\n-\n-    pub fn src_insert(&mut self, start: usize, text: String) {\n-        self.insert_inner(start,\n-                          text,\n-                          |this, node| this.root.src_insert(node, start, start))\n-    }\n-\n-    fn insert_inner<F>(&mut self,\n-                       start: usize,\n-                       text: String,\n-                       do_insert: F)\n-        where F: Fn(&mut Rope, Box<Node>) -> NodeAction\n-    {\n-        if text.len() == 0 {\n-            return;\n-        }\n-\n-        debug_assert!(start <= self.src_len, \"insertion out of bounds of rope\");\n-\n-        let len = text.len();\n-        let storage = text.into_bytes();\n-        let new_node = box Node::new_leaf(&storage[..][0] as *const u8, len, 0);\n-        self.storage.push(storage);\n-\n-        match do_insert(self, new_node) {\n-            NodeAction::Change(n, adj) => {\n-                assert!(adj as usize == len);\n-                self.root = *n;\n-            }\n-            NodeAction::Adjust(adj) => {\n-                assert!(adj as usize == len);\n-            }\n-            _ => panic!(\"Unexpected action\")\n-        }\n-        self.len += len;\n-    }\n-\n-    pub fn push(&mut self, text: String) {\n-        let len = self.len();\n-        self.insert(len, text);\n-    }\n-\n-    pub fn push_copy(&mut self, text: &str) {\n-        // If we did clever things with allocation, we could do better here\n-        let len = self.len();\n-        self.insert(len, text.to_string());\n-    }\n-\n-    pub fn remove(&mut self, start: usize, end: usize) {\n-        self.remove_inner(start, end, |this| this.root.remove(start, end, start))\n-    }\n-\n-    pub fn src_remove(&mut self, start: usize, end: usize) {\n-        self.remove_inner(start, end, |this| this.root.src_remove(start, end, start))\n-    }\n-\n-    fn remove_inner<F>(&mut self,\n-                       start: usize,\n-                       end: usize,\n-                       do_remove: F)\n-        where F: Fn(&mut Rope) -> NodeAction\n-    {\n-        assert!(end >= start);\n-        if start == end {\n-            return;\n-        }\n-\n-        match do_remove(self) {\n-            NodeAction::None => {}\n-            NodeAction::Remove => {\n-                self.root = Node::empty_inner();\n-                self.len = 0;\n-            }\n-            NodeAction::Adjust(adj) => self.len = (self.len as isize + adj) as usize,\n-            NodeAction::Change(node, adj) => {\n-                self.root = *node;\n-                self.len = (self.len as isize + adj) as usize;\n-            }\n-        }\n-    }\n-\n-    // TODO src_replace\n-    // TODO src_replace_str\n-\n-    // This can go horribly wrong if you overwrite a grapheme of different size.\n-    // It is the callers responsibility to ensure that the grapheme at point start\n-    // has the same size as new_char.\n-    pub fn replace(&mut self, start: usize, new_char: char) {\n-        assert!(start + new_char.len_utf8() <= self.len);\n-        // This is pretty wasteful in that we're allocating for no point, but\n-        // I think that is better than duplicating a bunch of code.\n-        // It should be possible to view a &char as a &[u8] somehow, and then\n-        // we can optimise this (FIXME).\n-        self.replace_str(start, &new_char.to_string()[..]);\n-    }\n-\n-    pub fn replace_str(&mut self, start: usize, new_str: &str) {\n-        assert!(start + new_str.len() <= self.len);\n-        self.root.replace(start, new_str);\n-    }\n-\n-    // Note, this is not necessarily cheap.\n-    pub fn col_for_src_loc(&self, src_loc: usize) -> usize {\n-        assert!(src_loc <= self.src_len);\n-        match self.root.col_for_src_loc(src_loc) {\n-            Search::Done(c) | Search::Continue(c) => c\n-        }\n-    }\n-\n-    pub fn slice(&self, Range { start, end }: Range<usize>) -> RopeSlice {\n-        debug_assert!(end > start && start <= self.len && end <= self.len);\n-        if start == end {\n-            return RopeSlice::empty();\n-        }\n-\n-        let mut result = RopeSlice::empty();\n-        self.root.find_slice(start, end, &mut result);\n-        result\n-    }\n-\n-    pub fn full_slice(&self) -> RopeSlice {\n-        self.slice(0..self.len)\n-    }\n-\n-    pub fn src_slice(&self, Range { start, end }: Range<usize>) -> RopeSlice {\n-        debug_assert!(end > start && start <= self.src_len && end <= self.src_len);\n-        if start == end {\n-            return RopeSlice::empty();\n-        }\n-\n-        let mut result = RopeSlice::empty();\n-        self.root.find_src_slice(start, end, &mut result);\n-        result\n-    }\n-\n-    pub fn chars(&self) -> RopeChars {\n-        RopeChars {\n-            data: self.full_slice(),\n-            cur_node: 0,\n-            cur_byte: 0,\n-            abs_byte: 0,\n-        }\n-    }\n-}\n-\n-impl<'rope> RopeSlice<'rope> {\n-    fn empty<'r>() -> RopeSlice<'r> {\n-        RopeSlice {\n-            nodes: vec![],\n-            start: 0,\n-            len: 0,\n-        }\n-    }\n-}\n-\n-impl<'rope> Iterator for RopeChars<'rope> {\n-    type Item = (char, usize);\n-    fn next(&mut self) -> Option<(char, usize)> {\n-        if self.cur_node >= self.data.nodes.len() {\n-            return None;\n-        }\n-\n-        let byte = self.abs_byte;\n-        let node = self.data.nodes[self.cur_node];\n-        if self.cur_byte >= node.len {\n-            self.cur_byte = 0;\n-            self.cur_node += 1;\n-            return self.next();\n-        }\n-\n-        let result = self.read_char();\n-        return Some((result, byte));\n-    }\n-}\n-\n-impl<'rope> RopeChars<'rope> {\n-    fn read_char(&mut self) -> char {\n-        let first_byte = self.read_byte();\n-        let width = unicode::str::utf8_char_width(first_byte);\n-        if width == 1 {\n-            return first_byte as char\n-        }\n-        if width == 0 {\n-            panic!(\"non-utf8 char in rope\");\n-        }\n-        let mut buf = [first_byte, 0, 0, 0];\n-        {\n-            let mut start = 1;\n-            while start < width {\n-                buf[start] = self.read_byte();\n-                start += 1;\n-            }\n-        }\n-        match ::std::str::from_utf8(&buf[..width]).ok() {\n-            Some(s) => s.char_at(0),\n-            None => panic!(\"bad chars in rope\")\n-        }\n-    }\n-\n-    fn read_byte(&mut self) -> u8 {\n-        let node = self.data.nodes[self.cur_node];\n-        let addr = node.text as usize + self.cur_byte;\n-        self.cur_byte += 1;\n-        self.abs_byte += 1;\n-        let addr = addr as *const u8;\n-        unsafe {\n-            *addr\n-        }        \n-    }\n-}\n-\n-impl ::std::str::FromStr for Rope {\n-    type Err = ();\n-    fn from_str(text: &str) -> Result<Rope, ()> {\n-        // TODO should split large texts into segments as we insert\n-\n-        let mut result = Rope::new();\n-        result.insert_copy(0, text);\n-        result.fix_src();\n-        Ok(result)\n-    }\n-}\n-\n-impl<'a> fmt::Display for RopeSlice<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        if self.nodes.len() == 0 {\n-            return Ok(());\n-        }\n-\n-        let last_idx = self.nodes.len() - 1;\n-        for (i, n) in self.nodes.iter().enumerate() {\n-            let mut ptr = n.text;\n-            let mut len = n.len;\n-            if i == 0 {\n-                ptr = (ptr as usize + self.start) as *const u8;\n-                len -= self.start;\n-            }\n-            if i == last_idx {\n-                len = self.len;\n-            }\n-            unsafe {\n-                try!(write!(fmt,\n-                            \"{}\",\n-                            ::std::str::from_utf8(::std::slice::from_raw_parts(ptr, len)).unwrap()));\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl<'a> fmt::Debug for RopeSlice<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        let last_idx = self.nodes.len() - 1;\n-        for (i, n) in self.nodes.iter().enumerate() {\n-            let mut ptr = n.text;\n-            let mut len = n.len;\n-            if i == 0 {\n-                ptr = (ptr as usize + self.start) as *const u8;\n-                len -= self.start;\n-            } else {\n-                try!(write!(fmt, \"|\"));\n-            }\n-            if i == last_idx {\n-                len = self.len;\n-            }\n-            unsafe {\n-                try!(write!(fmt,\n-                            \"\\\"{}\\\"\",\n-                            ::std::str::from_utf8(::std::slice::from_raw_parts(ptr, len)).unwrap()));\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl fmt::Display for Rope {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        write!(fmt, \"{}\", self.root)\n-    }\n-}\n-\n-impl fmt::Debug for Rope {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        write!(fmt, \"{:?}\", self.root)\n-    }\n-}\n-\n-impl fmt::Display for Node {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        match *self {\n-            Node::InnerNode(Inode { ref left, ref right, .. }) => {\n-                if let Some(ref left) = *left {\n-                    write!(fmt, \"{}\", left)\n-                } else {\n-                    Ok(())\n-                }.and_then(|_| if let Some(ref right) = *right {\n-                    write!(fmt, \"{}\", right)\n-                } else {\n-                    Ok(())\n-                })\n-            }\n-            Node::LeafNode(Lnode{ ref text, len, .. }) => {\n-                unsafe {\n-                    write!(fmt,\n-                           \"{}\",\n-                           ::std::str::from_utf8(::std::slice::from_raw_parts(*text, len)).unwrap())\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for Node {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        match *self {\n-            Node::InnerNode(Inode { ref left, ref right, weight, .. }) => {\n-                try!(write!(fmt, \"(\"));\n-                if let Some(ref left) = *left {\n-                    try!(write!(fmt, \"left: {:?}\", &**left));\n-                } else {\n-                    try!(write!(fmt, \"left: ()\"));\n-                }\n-                try!(write!(fmt, \", \"));\n-                if let Some(ref right) = *right {\n-                    try!(write!(fmt, \"right: {:?}\", &**right));\n-                } else {\n-                    try!(write!(fmt, \"right: ()\"));\n-                }\n-                write!(fmt, \"; {})\", weight)\n-            }\n-            Node::LeafNode(Lnode{ ref text, len, .. }) => {\n-                unsafe {\n-                    write!(fmt,\n-                           \"(\\\"{}\\\"; {})\",\n-                           ::std::str::from_utf8(::std::slice::from_raw_parts(*text, len)).unwrap(),\n-                           len)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Eq, PartialEq)]\n-enum Node {\n-    InnerNode(Inode),\n-    LeafNode(Lnode),\n-}\n-\n-#[derive(Clone, Eq, PartialEq)]\n-struct Inode {\n-    weight: usize,\n-    src_weight: usize,\n-    left: Option<Box<Node>>,\n-    right: Option<Box<Node>>,\n-}\n-\n-#[derive(Clone, Eq, PartialEq)]\n-struct Lnode {\n-    text: *const u8,\n-    len: usize,\n-    // text + src_offset = src text (src_offset should always be <= 0)\n-    src_offset: isize,\n-}\n-\n-impl Node {\n-    fn empty_inner() -> Node {\n-        Node::InnerNode(Inode {\n-            left: None,\n-            right: None,\n-            weight: 0,\n-            src_weight: 0,\n-        })\n-    }\n-\n-    fn new_inner(left: Option<Box<Node>>,\n-                 right: Option<Box<Node>>,\n-                 weight: usize,\n-                 src_weight: usize)\n-    -> Node {\n-        Node::InnerNode(Inode {\n-            left: left,\n-            right: right,\n-            weight: weight,\n-            src_weight: src_weight,\n-        })\n-    }\n-\n-    fn new_leaf(text: *const u8, len: usize, src_offset: isize) -> Node {\n-        Node::LeafNode(Lnode {\n-            text: text,\n-            len: len,\n-            src_offset: src_offset,\n-        })\n-    }\n-\n-    fn len(&self) -> usize {\n-        match *self {\n-            Node::InnerNode(Inode { weight, ref right, .. }) => {\n-                match *right {\n-                    Some(ref r) => weight + r.len(),\n-                    None => weight\n-                }\n-            }\n-            Node::LeafNode(Lnode { len, .. }) => len,\n-        }\n-    }\n-\n-    fn fix_src(&mut self) {\n-        match *self {\n-            Node::InnerNode(ref mut i) => i.fix_src(),\n-            Node::LeafNode(ref mut l) => {\n-                l.src_offset = 0;\n-            },\n-        }\n-    }\n-\n-    // Most of these methods are just doing dynamic dispatch, TODO use a macro\n-\n-    // precond: start < end\n-    fn remove(&mut self, start: usize, end: usize, src_start: usize) -> NodeAction {\n-        match *self {\n-            Node::InnerNode(ref mut i) => i.remove(start, end, src_start),\n-            Node::LeafNode(ref mut l) => l.remove(start, end, src_start),\n-        }\n-    }\n-\n-    fn src_remove(&mut self, start: usize, end: usize, src_start: usize) -> NodeAction {\n-        match *self {\n-            Node::InnerNode(ref mut i) => i.src_remove(start, end, src_start),\n-            Node::LeafNode(ref mut l) => {\n-                debug!(\"src_remove: pre-adjust {}-{}; {}\", start, end, l.src_offset);\n-                let start = minz(start as isize + l.src_offset);\n-                let end = minz(end as isize + l.src_offset);\n-                let src_start = minz(src_start as isize + l.src_offset);\n-                debug!(\"src_remove: post-adjust {}-{}, {}\", start, end, src_start);\n-                if end > start {\n-                    l.remove(start as usize, end as usize, src_start as usize)\n-                } else {\n-                    NodeAction::None\n-                }\n-            }\n-        }\n-    }\n-\n-    fn insert(&mut self, node: Box<Node>, start: usize, src_start: usize) -> NodeAction {\n-        match *self {\n-            Node::InnerNode(ref mut i) => i.insert(node, start, src_start),\n-            Node::LeafNode(ref mut l) => l.insert(node, start, src_start),\n-        }\n-    }\n-\n-    fn src_insert(&mut self, node: Box<Node>, start: usize, src_start: usize) -> NodeAction {\n-        match *self {\n-            Node::InnerNode(ref mut i) => i.src_insert(node, start, src_start),\n-            Node::LeafNode(ref mut l) => {\n-                debug!(\"src_insert: pre-adjust {}, {}; {}\", start, src_start, l.src_offset);\n-                let start = minz(start as isize + l.src_offset);\n-                let src_start = minz(src_start as isize + l.src_offset);\n-                debug!(\"src_insert: post-adjust {}, {}\", start, src_start);\n-                l.insert(node, start as usize, src_start as usize)\n-            }\n-        }\n-    }\n-\n-    fn find_slice<'a>(&'a self, start: usize, end: usize, slice: &mut RopeSlice<'a>) {\n-        match *self {\n-            Node::InnerNode(ref i) => i.find_slice(start, end, slice),\n-            Node::LeafNode(ref l) => l.find_slice(start, end, slice),\n-        }\n-    }\n-\n-    fn find_src_slice<'a>(&'a self, start: usize, end: usize, slice: &mut RopeSlice<'a>) {\n-        match *self {\n-            Node::InnerNode(ref i) => i.find_src_slice(start, end, slice),\n-            Node::LeafNode(ref l) => {\n-                debug!(\"find_src_slice: pre-adjust {}-{}; {}\", start, end, l.src_offset);\n-                let start = minz(start as isize + l.src_offset);\n-                let end = minz(end as isize + l.src_offset);\n-                debug!(\"find_src_slice: post-adjust {}-{}\", start, end);\n-                if end > start {\n-                    l.find_slice(start as usize, end as usize, slice);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn replace(&mut self, start: usize, new_str: &str) {\n-        match *self {\n-            Node::InnerNode(ref mut i) => i.replace(start, new_str),\n-            Node::LeafNode(ref mut l) => l.replace(start, new_str),\n-        }        \n-    }\n-\n-    fn col_for_src_loc(&self, src_loc: usize) -> Search {\n-        match *self {\n-            Node::InnerNode(ref i) => i.col_for_src_loc(src_loc),\n-            Node::LeafNode(ref l) => l.col_for_src_loc(src_loc),\n-        }\n-    }\n-\n-    fn find_last_char(&self, c: char) -> Option<usize> {\n-        match *self {\n-            Node::InnerNode(ref i) => i.find_last_char(c),\n-            Node::LeafNode(ref l) => l.find_last_char(c),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-enum NodeAction {\n-    None,\n-    Remove,\n-    Adjust(isize), // Arg is the length of the old node - the length of the newly adjusted node.\n-    Change(Box<Node>, isize) // Args are the new node and the change in length.\n-}\n-\n-impl Inode {\n-    fn remove(&mut self, start: usize, end: usize, src_start: usize) -> NodeAction {\n-        debug!(\"Inode::remove: {}, {}, {}\", start, end, self.weight);\n-\n-        let left_action = if start <= self.weight {\n-            if let Some(ref mut left) = self.left {\n-                left.remove(start, end, src_start)\n-            } else {\n-                panic!();\n-            }\n-        } else {\n-            NodeAction::None\n-        };\n-\n-        let right_action = if end > self.weight {\n-            if let Some(ref mut right) = self.right {\n-                let start = if start < self.weight {\n-                    0\n-                } else {\n-                    start - self.weight\n-                };\n-                let src_start = if src_start < self.src_weight {\n-                    0\n-                } else {\n-                    src_start - self.src_weight\n-                };\n-                right.remove(start, end - self.weight, src_start)\n-            } else {\n-                panic!();\n-            }\n-        } else {\n-            NodeAction::None\n-        };\n-\n-\n-        if left_action == NodeAction::Remove && right_action == NodeAction::Remove ||\n-           left_action == NodeAction::Remove && self.right.is_none() ||\n-           right_action == NodeAction::Remove && self.left.is_none() {\n-            return NodeAction::Remove;\n-        }\n-\n-        if left_action == NodeAction::Remove {\n-            return NodeAction::Change(self.right.clone().unwrap(),\n-                                      -(self.weight as isize));\n-        }\n-        if right_action == NodeAction::Remove {\n-            return NodeAction::Change(self.left.clone().unwrap(),\n-                                      -(self.right.as_ref().map(|n| n.len()).unwrap() as isize));\n-        }\n-\n-        let mut total_adj = 0;\n-        if let NodeAction::Change(ref n, adj) = left_action {\n-            self.left = Some(n.clone());\n-            self.weight = (self.weight as isize + adj) as usize;\n-            total_adj += adj;\n-        }\n-        if let NodeAction::Change(ref n, adj) = right_action {\n-            self.right = Some(n.clone());\n-            total_adj += adj;\n-        }\n-\n-        if let NodeAction::Adjust(adj) = left_action {\n-            self.weight = (self.weight as isize + adj) as usize;\n-            total_adj += adj;\n-        }\n-        if let NodeAction::Adjust(adj) = right_action {\n-            total_adj += adj;\n-        }\n-\n-        return NodeAction::Adjust(total_adj);\n-    }\n-\n-    fn src_remove(&mut self, start: usize, end: usize, src_start: usize) -> NodeAction {\n-        // TODO refactor with remove\n-\n-        debug!(\"Inode::src_remove: {}, {}, {}/{}\", start, end, self.src_weight, self.weight);\n-\n-        let left_action = if start <= self.src_weight {\n-            if let Some(ref mut left) = self.left {\n-                left.src_remove(start, end, src_start)\n-            } else {\n-                panic!();\n-            }\n-        } else {\n-            NodeAction::None\n-        };\n-\n-        let right_action = if end > self.src_weight {\n-            if let Some(ref mut right) = self.right {\n-                let start = if start < self.src_weight {\n-                    0\n-                } else {\n-                    start - self.src_weight\n-                };\n-                let src_start = if src_start < self.src_weight {\n-                    0\n-                } else {\n-                    src_start - self.src_weight\n-                };\n-                right.src_remove(start, end - self.src_weight, src_start)\n-            } else {\n-                panic!();\n-            }\n-        } else {\n-            NodeAction::None\n-        };\n-\n-\n-        if left_action == NodeAction::Remove && right_action == NodeAction::Remove ||\n-           left_action == NodeAction::Remove && self.right.is_none() ||\n-           right_action == NodeAction::Remove && self.left.is_none() {\n-            return NodeAction::Remove;\n-        }\n-\n-        if left_action == NodeAction::Remove {\n-            return NodeAction::Change(self.right.clone().unwrap(),\n-                                      -(self.weight as isize));\n-        }\n-        if right_action == NodeAction::Remove {\n-            return NodeAction::Change(self.left.clone().unwrap(),\n-                                      -(self.right.as_ref().map(|n| n.len()).unwrap() as isize));\n-        }\n-\n-        let mut total_adj = 0;\n-        if let NodeAction::Change(ref n, adj) = left_action {\n-            self.left = Some(n.clone());\n-            self.weight = (self.weight as isize + adj) as usize;\n-            total_adj += adj;\n-        }\n-        if let NodeAction::Change(ref n, adj) = right_action {\n-            self.right = Some(n.clone());\n-            total_adj += adj;\n-        }\n-\n-        if let NodeAction::Adjust(adj) = left_action {\n-            self.weight = (self.weight as isize + adj) as usize;\n-            total_adj += adj;\n-        }\n-        if let NodeAction::Adjust(adj) = right_action {\n-            total_adj += adj;\n-        }\n-\n-        return NodeAction::Adjust(total_adj);\n-    }\n-\n-    fn insert(&mut self, node: Box<Node>, start: usize, src_start: usize) -> NodeAction {\n-        let mut total_adj = 0;\n-        if start <= self.weight {\n-            let action = if let Some(ref mut left) = self.left {\n-                left.insert(node, start, src_start)\n-            } else {\n-                assert!(self.weight == 0);\n-                let len = node.len() as isize;\n-                NodeAction::Change(node, len)\n-            };\n-\n-            match action {\n-                NodeAction::Change(n, adj) => {\n-                    self.left = Some(n);\n-                    self.weight += adj as usize;\n-                    total_adj += adj;\n-                }\n-                NodeAction::Adjust(adj) => {\n-                    self.weight += adj as usize;\n-                    total_adj += adj;\n-                }\n-                _ => panic!(\"Unexpected action\"),\n-            }\n-        } else {\n-            let action = if let Some(ref mut right) = self.right {\n-                assert!(start >= self.weight);\n-                assert!(src_start >= self.src_weight);\n-                right.insert(node, start - self.weight, src_start - self.src_weight)\n-            } else {\n-                let len = node.len() as isize;\n-                NodeAction::Change(node, len)\n-            };\n-\n-            match action {\n-                NodeAction::Change(n, adj) => {\n-                    self.right = Some(n);\n-                    total_adj += adj;\n-                }\n-                NodeAction::Adjust(adj) => total_adj += adj,\n-                _ => panic!(\"Unexpected action\"),\n-            }\n-        }\n-\n-        NodeAction::Adjust(total_adj)\n-    }\n-\n-    fn src_insert(&mut self, node: Box<Node>, start: usize, src_start: usize) -> NodeAction {\n-        let mut total_adj = 0;\n-        if start <= self.src_weight {\n-            let action = if let Some(ref mut left) = self.left {\n-                left.src_insert(node, start, src_start)\n-            } else {\n-                let len = node.len() as isize;\n-                NodeAction::Change(node, len)\n-            };\n-\n-            match action {\n-                NodeAction::Change(n, adj) => {\n-                    self.left = Some(n);\n-                    self.weight += adj as usize;\n-                    total_adj += adj;\n-                }\n-                NodeAction::Adjust(adj) => {\n-                    self.weight += adj as usize;\n-                    total_adj += adj;\n-                }\n-                _ => panic!(\"Unexpected action\"),\n-            }\n-        } else {\n-            let action = if let Some(ref mut right) = self.right {\n-                assert!(start >= self.src_weight);\n-                assert!(src_start >= self.src_weight);\n-                right.src_insert(node, start - self.src_weight, src_start - self.src_weight)\n-            } else {\n-                let len = node.len() as isize;\n-                NodeAction::Change(node, len)\n-            };\n-\n-            match action {\n-                NodeAction::Change(n, adj) => {\n-                    self.right = Some(n);\n-                    total_adj += adj;\n-                }\n-                NodeAction::Adjust(adj) => total_adj += adj,\n-                _ => panic!(\"Unexpected action\"),\n-            }\n-        }\n-\n-        NodeAction::Adjust(total_adj)\n-    }\n-\n-    fn find_slice<'a>(&'a self, start: usize, end: usize, slice: &mut RopeSlice<'a>) {\n-        debug!(\"Inode::find_slice: {}, {}, {}\", start, end, self.weight);\n-        if start < self.weight {\n-            self.left.as_ref().unwrap().find_slice(start, end, slice);\n-        }\n-        if end > self.weight {\n-            let start = if start < self.weight {\n-                0\n-            } else {\n-                start - self.weight\n-            };\n-            self.right.as_ref().unwrap().find_slice(start, end - self.weight, slice)\n-        }\n-    }\n-\n-    fn find_src_slice<'a>(&'a self, start: usize, end: usize, slice: &mut RopeSlice<'a>) {\n-        debug!(\"Inode::find_src_slice: {}, {}, {}\", start, end, self.src_weight);\n-        if start < self.src_weight && self.left.is_some() {\n-            self.left.as_ref().unwrap().find_src_slice(start, end, slice);\n-        }\n-        if end > self.src_weight && self.right.is_some() {\n-            let start = if start < self.src_weight {\n-                0\n-            } else {\n-                start - self.src_weight\n-            };\n-            self.right.as_ref().unwrap().find_src_slice(start, end - self.src_weight, slice)\n-        }\n-    }\n-\n-    fn replace(&mut self, start: usize, new_str: &str) {\n-        debug!(\"Inode::replace: {}, {}, {}\", start, new_str, self.weight);\n-        let end = start + new_str.len();\n-        if start < self.weight {\n-            if let Some(ref mut left) = self.left {\n-                left.replace(start, &new_str[..::std::cmp::min(self.weight-start, new_str.len())]);\n-            } else {\n-                panic!();\n-            }\n-        }\n-        if end > self.weight {\n-            let (start, offset) = if start < self.weight {\n-                (0, self.weight - start)\n-            } else {\n-                (start - self.weight, 0)\n-            };\n-            if let Some(ref mut right) = self.right {\n-                right.replace(start, &new_str[offset..]);\n-            } else {\n-                panic!();\n-            }\n-        }\n-    }\n-\n-    fn fix_src(&mut self) {\n-        self.src_weight = self.weight;\n-        if let Some(ref mut left) = self.left {\n-            left.fix_src();\n-        }\n-        if let Some(ref mut right) = self.right {\n-            right.fix_src();\n-        }\n-    }\n-\n-    fn col_for_src_loc(&self, src_loc: usize) -> Search {\n-        debug!(\"Inode::col_for_src_loc: {}, {}\", src_loc, self.src_weight);\n-        let result = if src_loc < self.src_weight {\n-            if self.left.is_some() {\n-                Some(self.left.as_ref().unwrap().col_for_src_loc(src_loc))\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        };\n-        if result.is_none() {\n-            if self.right.is_some() {\n-                match self.right.as_ref().unwrap().col_for_src_loc(src_loc - self.src_weight) {\n-                    Search::Continue(c) if self.left.is_some() => {\n-                        // TODO broken - need number of chars, not bytes\n-                        match self.left.as_ref().unwrap().find_last_char('\\n') {\n-                            Some(l) => {\n-                                Search::Done((self.weight - l - 1) + c)\n-                            }\n-                            None => {\n-                                Search::Continue(c + self.weight)\n-                            }\n-                        }\n-                    }\n-                    result => result,\n-                }\n-            } else {\n-                panic!(\"Can't look up source location\");\n-            }\n-        } else {\n-            // TODO don't do it this way\n-            result.unwrap()\n-        }\n-    }\n-\n-    fn find_last_char(&self, c: char) -> Option<usize> {\n-        // TODO use map or something\n-        match self.right {\n-            Some(ref right) => match right.find_last_char(c) {\n-                Some(x) => return Some(x),\n-                None => {},\n-            },\n-            None => {}\n-        }\n-        match self.left {\n-            Some(ref left) => match left.find_last_char(c) {\n-                Some(x) => return Some(x),\n-                None => {},\n-            },\n-            None => {}\n-        }\n-        None\n-    }\n-}\n-\n-impl Lnode {\n-    fn remove(&mut self, start: usize, end: usize, src_start: usize) -> NodeAction {\n-        debug!(\"Lnode::remove: {}, {}, {}\", start, end, self.len);\n-        assert!(start <= self.len);\n-\n-        if start == 0 && end >= self.len {\n-            // The removal span includes us, remove ourselves.\n-            return NodeAction::Remove;\n-        }\n-\n-        let old_len = self.len;\n-        if start == 0 {\n-            // Truncate the left of the node.\n-            self.text = (self.text as usize + end) as *const u8;\n-            self.len = old_len - end;\n-            let delta = self.len as isize - old_len as isize;\n-            self.src_offset += delta;\n-            return NodeAction::Adjust(delta);\n-        }\n-\n-        if end >= self.len {\n-            // Truncate the right of the node.\n-            self.len = start;\n-            return NodeAction::Adjust(self.len as isize - old_len as isize);\n-        }\n-\n-        let delta = -((end - start) as isize);\n-        // Split the node (span to remove is in the middle of the node).\n-        let new_node = Node::new_inner(\n-            Some(box Node::new_leaf(self.text, start, self.src_offset)),\n-            Some(box Node::new_leaf((self.text as usize + end) as *const u8,\n-                                    old_len - end,\n-                                    self.src_offset + delta)),\n-            start,\n-            src_start);\n-        return NodeAction::Change(box new_node, delta);\n-    }\n-\n-    fn insert(&mut self, mut node: Box<Node>, start: usize, src_start: usize) -> NodeAction {\n-        match node {\n-            box Node::LeafNode(ref mut node) => node.src_offset = self.src_offset,\n-            _ => panic!()\n-        }\n-\n-        let len = node.len();\n-        if start == 0 {\n-            // Insert at the start of the node\n-            let new_node = box Node::new_inner(Some(node),\n-                                               Some(box Node::LeafNode(self.clone())),\n-                                               len,\n-                                               0);\n-            return NodeAction::Change(new_node, len as isize)\n-        }\n-\n-        if start == self.len {\n-            // Insert at the end of the node\n-            let new_node = box Node::new_inner(Some(box Node::LeafNode(self.clone())),\n-                                               Some(node),\n-                                               self.len,\n-                                               self.len);\n-            return NodeAction::Change(new_node, len as isize)\n-        }\n-\n-        // Insert into the middle of the node\n-        let left = Some(box Node::new_leaf(self.text, start, self.src_offset));\n-        let new_left = box Node::new_inner(left, Some(node), start, src_start);\n-        let right = Some(box Node::new_leaf((self.text as usize + (start)) as *const u8,\n-                                            self.len - start,\n-                                            self.src_offset));\n-        let new_node = box Node::new_inner(Some(new_left), right, start + len, src_start);\n-\n-        return NodeAction::Change(new_node, len as isize)        \n-    }\n-\n-    fn find_slice<'a>(&'a self, start: usize, end: usize, slice: &mut RopeSlice<'a>) {\n-        debug!(\"Lnode::find_slice: {}, {}, {}, {}\", start, end, self.len, self.src_offset);\n-        debug_assert!(start < self.len, \"Shouldn't have called this fn, we're out of bounds\");\n-\n-        slice.nodes.push(self);\n-        let mut len = ::std::cmp::min(end, self.len);\n-        if start > 0 {\n-            slice.start = start;\n-            len -= start;\n-        }\n-        slice.len = len;\n-    }\n-\n-    fn replace(&mut self, start: usize, new_str: &str) {\n-        debug!(\"Lnode::replace: {}, {}, {}\", start, new_str, self.len);\n-        debug_assert!(start + new_str.len() <= self.len);\n-        let addr = (self.text as usize + start) as *mut u8;\n-        unsafe {\n-            ::std::intrinsics::volatile_copy_nonoverlapping_memory(addr, &new_str.as_bytes()[0], new_str.len());\n-        }\n-    }\n-\n-    fn col_for_src_loc(&self, src_loc: usize) -> Search {\n-        debug!(\"Lnode::col_for_src_loc {}; {}; {}\", src_loc, self.len, self.src_offset);\n-        let loc = if (src_loc as isize) > (self.len as isize - self.src_offset) {\n-            // The source location we are looking up has been removed\n-            self.len as isize\n-        } else {\n-            (src_loc as isize + self.src_offset) \n-        };\n-\n-        // FIXME if '/n' as u8 is part of a multi-byte grapheme, then this will\n-        // cause false positives.\n-        let mut i = loc - 1;\n-        while i >= 0 {\n-            unsafe {\n-                let c = *((self.text as usize + i as usize) as *const u8);\n-                if c as char == '\\n' {\n-                    debug!(\"Lnode::col_for_src_loc, return Done({})\", loc - i - 1);\n-                    return Search::Done((loc - i - 1) as usize)\n-                }\n-            }\n-            i -= 1;\n-        }\n-\n-        let loc = minz(loc) as usize;\n-        debug!(\"Lnode::col_for_src_loc, return Continue({})\", loc);\n-        Search::Continue(loc)\n-    }\n-\n-    fn find_last_char(&self, needle: char) -> Option<usize> {\n-        // FIXME due to multi-byte chars, this will give false positives\n-        // FIXME use std::str::GraphemeIndices to do this!\n-        let mut loc = self.len as isize - 1;\n-        while loc >= 0 {\n-            unsafe {\n-                let c = *((self.text as usize + loc as usize) as *const u8);\n-                if c as char == needle {\n-                    return Some(loc as usize)\n-                }\n-            }\n-            loc -= 1;\n-        }\n-\n-        return None\n-    }\n-}\n-\n-// The state of searching through a rope.\n-enum Search {\n-    // TODO comment\n-    Continue(usize),\n-    // TODO comment\n-    Done(usize)\n-}\n-\n-fn minz<I: SignedInt>(x: I) -> I {\n-    if x.is_negative() {\n-        return I::zero();\n-    }\n-\n-    x\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    // FIXME is this a Rust bug? Why is minz not imported by the glob import?\n-    use super::minz;\n-\n-    #[test]\n-    fn test_new() {\n-        let r = Rope::new();\n-        assert!(r.len() == 0);\n-        assert!(r.to_string() == \"\");\n-\n-        let r = Rope::from_string(\"Hello world!\".to_string());\n-        assert!(r.len() == 12);\n-        assert!(r.to_string() == \"Hello world!\");\n-    }\n-\n-    #[test]\n-    fn test_minz() {\n-        let x: i32 = 0;\n-        assert!(super::minz(x) == 0);\n-        let x: i32 = 42;\n-        assert!(minz(x) == 42);\n-        let x: i32 = -42;\n-        assert!(minz(x) == 0);\n-        let x: isize = 0;\n-        assert!(minz(x) == 0);\n-        let x: isize = 42;\n-        assert!(minz(x) == 42);\n-        let x: isize = -42;\n-        assert!(minz(x) == 0);\n-    }\n-\n-    #[test]\n-    fn test_from_string() {\n-        let r: Rope = \"Hello world!\".parse().unwrap();\n-        assert!(r.to_string() == \"Hello world!\");\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        let mut r: Rope = \"Hello world!\".parse().unwrap();\n-        r.remove(0, 10);\n-        assert!(r.to_string() == \"d!\");\n-        assert!(r.src_slice(0..5).to_string() == \"\");\n-        assert!(r.src_slice(10..12).to_string() == \"d!\");       \n-\n-        let mut r: Rope = \"Hello world!\".parse().unwrap();\n-        r.remove(4, 12);\n-        assert!(r.to_string() == \"Hell\");\n-        // TODO\n-        //assert!(r.src_slice(0..4).to_string() == \"Hell\");\n-        //assert!(r.src_slice(10..12).to_string() == \"\");       \n-\n-        let mut r: Rope = \"Hello world!\".parse().unwrap();\n-        r.remove(4, 10);\n-        assert!(r.to_string() == \"Helld!\");\n-        // TODO\n-        //assert!(r.src_slice(1..5).to_string() == \"ell\");\n-        assert!(r.src_slice(9..12).to_string() == \"d!\");\n-    }\n-\n-    #[test]\n-    fn test_insert_copy() {\n-        let mut r: Rope = \"Hello world!\".parse().unwrap();\n-        r.insert_copy(0, \"foo\");\n-        assert!(r.to_string() == \"fooHello world!\");\n-        assert!(r.slice(2..8).to_string() == \"oHello\");\n-\n-        let mut r: Rope = \"Hello world!\".parse().unwrap();\n-        r.insert_copy(12, \"foo\");\n-        assert!(r.to_string() == \"Hello world!foo\");\n-        assert!(r.slice(2..8).to_string() == \"llo wo\");\n-\n-        let mut r: Rope = \"Hello world!\".parse().unwrap();\n-        r.insert_copy(5, \"foo\");\n-        assert!(r.to_string() == \"Hellofoo world!\");\n-        assert!(r.slice(2..8).to_string() == \"llofoo\");\n-    }\n-\n-    #[test]\n-    fn test_push_copy() {\n-        let mut r: Rope = \"Hello world!\".parse().unwrap();\n-        r.push_copy(\"foo\");\n-        assert!(r.to_string() == \"Hello world!foo\");\n-        assert!(r.slice(2..8).to_string() == \"llo wo\");\n-    }\n-\n-    #[test]\n-    fn test_insert_replace() {\n-        let mut r: Rope = \"hello worl\\u{00bb0}!\".parse().unwrap();\n-        r.insert_copy(5, \"bb\");\n-        assert!(r.to_string() == \"hellobb worl\u0bb0!\");\n-        r.replace(0, 'H');\n-        r.replace(15, '~');\n-        r.replace_str(5, \"fo\\u{00cb0}\");\n-        assert!(r.to_string() == \"Hellofo\u0cb0rl\u0bb0~\");\n-        assert!(r.slice(0..10).to_string() == \"Hellofo\u0cb0\");\n-        assert!(r.slice(5..10).to_string() == \"fo\u0cb0\");\n-        assert!(r.slice(10..15).to_string() == \"rl\u0bb0\");\n-\n-        let expected = \"Hellofo\u0cb0rl\u0bb0~\";\n-        let mut byte_pos = 0;\n-        for ((c, b), e) in r.chars().zip(expected.chars()) {\n-            assert!(c == e);\n-            assert!(b == byte_pos);\n-            byte_pos += e.len_utf8();\n-        }\n-    }\n-\n-    #[test]\n-    fn test_src_insert_remove_col_for_src_loc() {\n-        let mut r: Rope = \"hello\\n world!\".parse().unwrap();\n-        r.src_insert(4, \"foo\".to_string());\n-        r.src_insert(5, \"bar\".to_string());\n-        assert!(r.to_string() == \"hellfooobar\\n world!\");\n-\n-        r.src_remove(2, 4);\n-        r.src_remove(10, 12);\n-        assert!(r.to_string() == \"hefooobar\\n wor!\");\n-\n-        let expected = \"hefooobar\\n wor!\";\n-        let mut byte_pos = 0;\n-        for ((c, b), e) in r.chars().zip(expected.chars()) {\n-            assert!(c == e);\n-            assert!(b == byte_pos);\n-            byte_pos += e.len_utf8();\n-        }\n-\n-        let expected = [0, 1, 2, 2, 5, 9, 0, 1, 2, 3, 4, 4, 4];\n-        for i in 0..13 {\n-            assert!(r.col_for_src_loc(i) == expected[i]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_src_insert() {\n-        let mut r: Rope = \"Hello world!\".parse().unwrap();\n-        r.src_insert(4, \"foo\".to_string());\n-        r.src_insert(0, \"foo\".to_string());\n-        r.src_insert(12, \"foo\".to_string());\n-        assert!(r.to_string() == \"fooHellfooo world!foo\");\n-        r.src_insert(4, \"bar\".to_string());\n-        r.src_insert(5, \"bar\".to_string());\n-        r.src_insert(3, \"bar\".to_string());\n-        r.src_insert(0, \"bar\".to_string());\n-        r.src_insert(12, \"bar\".to_string());\n-        assert!(r.to_string() == \"barfooHelbarlbarfooobar world!barfoo\");\n-    }\n-}"}, {"sha": "df11e79d318215d0ed5361ceec4773c56f1d97fd", "filename": "src/string_buffer.rs", "status": "removed", "additions": 0, "deletions": 312, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/76854677c1b730ecb262b5277a6520fc2ff75974/src%2Fstring_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76854677c1b730ecb262b5277a6520fc2ff75974/src%2Fstring_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring_buffer.rs?ref=76854677c1b730ecb262b5277a6520fc2ff75974", "patch": "@@ -1,312 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// A specialised string-like structure that is optimised for appending text and\n-// sequential reading.\n-\n-// TODO\n-// Debug\n-// docs\n-// char iterator\n-//   chars -> char_indices and flip order of char/index\n-// Eq\n-\n-extern crate unicode;\n-\n-use std::str::FromStr;\n-use std::{cmp, fmt};\n-\n-const MAX_CAPACITY: usize = 0xffff;\n-const INIT_CAPACITY: usize = 0xff; \n-\n-pub struct StringBuffer {\n-    first: Box<StringNode>,\n-    // last: &self StringNode\n-    // Optimisation that saves us from walking the whole list of nodes everytime\n-    // we append a string.\n-    last: *mut StringNode,\n-    // The length of the whole StringBuffer.\n-    len: usize,\n-}\n-\n-pub struct Chars<'a> {\n-    // Node we're currently iterating over.\n-    cur_node: &'a StringNode,\n-    // Byte in cur_node.\n-    cur_byte: usize,\n-    // Byte since start of StringBuffer.\n-    abs_byte: usize,\n-}\n-\n-struct StringNode {\n-    data: String,\n-    next: Option<Box<StringNode>>,\n-}\n-\n-impl StringBuffer {\n-    pub fn new() -> StringBuffer {\n-        StringBuffer::with_capacity(INIT_CAPACITY)\n-    }\n-\n-    pub fn with_capacity(capacity: usize) -> StringBuffer {\n-        let mut result = StringBuffer {\n-            first: box StringNode::with_capacity(capacity),\n-            last: 0 as *mut StringNode,\n-            len: 0,\n-        };\n-        result.last = &mut *result.first;\n-        result\n-    }\n-\n-    pub fn push_str(&mut self, text: &str) {\n-        self.len += text.len();\n-        unsafe {\n-            // Safety invariant: the `last` field will only ever point to\n-            // a node owned by self, and will live until destruction of self.\n-            self.last = (&mut *self.last).push_str(text);\n-        }\n-    }\n-\n-    // Returns the number of characters from start of the last line in the\n-    // StringBuffer.\n-    // Note that it is possible for this operation to take a long time in\n-    // pathological cases (lots of nodes, few line breaks).\n-    pub fn cur_offset(&self) -> usize {\n-        unsafe {\n-            let result = (&*self.last).cur_offset();\n-            // TODO\n-            result.unwrap_or_else(|| {\n-                println!(\" FIXME Unimplemented cur_offset across node boundaries\");\n-                0\n-            })\n-        }\n-    }\n-\n-    pub fn chars<'a>(&'a self) -> Chars<'a> {\n-        Chars::new(&self.first)\n-    }\n-}\n-\n-impl StringNode {\n-    fn with_capacity(capacity: usize) -> StringNode {\n-        StringNode {\n-            data: String::with_capacity(capacity),\n-            next: None,\n-        }\n-    }\n-\n-    // Returns a reference to the new last node. \n-    fn push_str(&mut self, text: &str) -> &mut StringNode {\n-        if let Some(ref mut n) = self.next {\n-            return n.push_str(text);\n-        }\n-\n-        if self.data.capacity() - self.data.len() >= text.len() {\n-            self.data.push_str(text);\n-            self\n-        } else {\n-            self.data.shrink_to_fit();\n-            let next_cap = cmp::min(cmp::max(self.data.capacity(),\n-                                             INIT_CAPACITY) * 2,\n-                                    MAX_CAPACITY);\n-            let next_cap = cmp::max(next_cap, text.len());\n-            self.next = Some(box StringNode::with_capacity(next_cap));\n-            let next = self.next.as_mut().unwrap();\n-            next.push_str(text);\n-            &mut **next\n-        }\n-    }\n-\n-    // None if there is no new line in this node.\n-    fn cur_offset(&self) -> Option<usize> {\n-        self.data.rfind('\\n').map(|i| self.data.len() - i - 1)\n-    }\n-}\n-\n-impl FromStr for StringBuffer {\n-    type Err = ();\n-    fn from_str(text: &str) -> Result<StringBuffer, ()> {\n-        let mut result = StringBuffer::with_capacity(cmp::max(INIT_CAPACITY, text.len()));\n-        result.push_str(text);\n-        Ok(result)\n-    }\n-}\n-\n-impl fmt::Display for StringBuffer {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        fn fmt_node(node: &StringNode, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-            try!(write!(fmt, \"{}\", node.data));\n-            if let Some(ref n) = node.next {\n-                fmt_node(n, fmt)\n-            } else {\n-                Ok(())\n-            }\n-        }\n-\n-        fmt_node(&self.first, fmt)\n-    }\n-}\n-\n-impl<'a> Iterator for Chars<'a> {\n-    type Item = (char, usize);\n-\n-    fn next(&mut self) -> Option<(char, usize)> {\n-        while self.cur_byte >= self.cur_node.data.len() {\n-            if let Some(ref n) = self.cur_node.next {\n-                self.cur_byte = 0;\n-                self.cur_node = n;\n-            } else {\n-                return None;                \n-            }\n-        }\n-\n-        let byte = self.abs_byte;\n-        let result = self.read_char();\n-\n-        return Some((result, byte));\n-    }\n-}\n-\n-impl<'a> Chars<'a> {\n-    fn new<'b>(first_node: &'b StringNode) -> Chars<'b> {\n-        Chars {\n-            cur_node: first_node,\n-            cur_byte: 0,\n-            abs_byte: 0,\n-        }\n-    }\n-\n-    fn read_char(&mut self) -> char {\n-        let first_byte = self.read_byte();\n-        let width = unicode::str::utf8_char_width(first_byte);\n-        if width == 1 {\n-            return first_byte as char\n-        }\n-        if width == 0 {\n-            panic!(\"non-utf8 char in StringBuffer\");\n-        }\n-        let mut buf = [first_byte, 0, 0, 0];\n-        {\n-            let mut start = 1;\n-            while start < width {\n-                buf[start] = self.read_byte();\n-                start += 1;\n-            }\n-        }\n-        match ::std::str::from_utf8(&buf[..width]).ok() {\n-            Some(s) => s.char_at(0),\n-            None => panic!(\"bad chars in StringBuffer\")\n-        }\n-    }\n-\n-    fn read_byte(&mut self) -> u8 {\n-        let result = self.cur_node.data.as_bytes()[self.cur_byte];\n-        self.cur_byte += 1;\n-        self.abs_byte += 1;\n-        result\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    // Bug #23157\n-    use super::{StringNode, INIT_CAPACITY};\n-\n-    #[test]\n-    fn test_new() {\n-        let s = StringBuffer::new();\n-        assert!(s.len == 0);\n-        assert!(s.to_string() == \"\");\n-        assert!(count_nodes(&s) == 1);\n-        assert!(first_capacity(&s) == INIT_CAPACITY);\n-\n-        let s = StringBuffer::with_capacity(64);\n-        assert!(s.len == 0);\n-        assert!(s.to_string() == \"\");\n-        assert!(count_nodes(&s) == 1);\n-        assert!(first_capacity(&s) == 64);\n-    }\n-\n-    #[test]\n-    fn test_from_str() {\n-        let s: StringBuffer = \"Hello\".parse().unwrap();\n-        assert!(s.len == 5);\n-        assert!(s.to_string() == \"Hello\");\n-        assert!(count_nodes(&s) == 1);\n-        assert!(first_capacity(&s) == INIT_CAPACITY);\n-\n-        let expected = \"Hello\";\n-        for ((i, (c, b)), cc) in s.chars().enumerate().zip(expected.chars()) {\n-            assert!(c == cc);\n-            assert!(i == b);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_push_str() {\n-        let mut s: StringBuffer = \"Hello\".parse().unwrap();\n-        assert!(first_capacity(&s) == INIT_CAPACITY);\n-\n-        s.push_str(\" world!\");\n-        assert!(s.to_string() == \"Hello world!\");\n-        assert!(s.len == 12);\n-        s.push_str(\" foo\");\n-        assert!(s.to_string() == \"Hello world! foo\");\n-        assert!(s.len == 16);\n-\n-        assert!(count_nodes(&s) == 1);\n-\n-        let expected = \"Hello world! foo\";\n-        for ((i, (c, b)), cc) in s.chars().enumerate().zip(expected.chars()) {\n-            assert!(c == cc);\n-            assert!(i == b);\n-        }\n-    }\n-\n-    // push_str requiring multiple nodes\n-    #[test]\n-    fn test_push_str_multi() {\n-        let mut s: StringBuffer = StringBuffer::with_capacity(2);\n-        assert!(first_capacity(&s) == 2);\n-\n-        s.push_str(\"Hello\");\n-        assert!(s.to_string() == \"Hello\");\n-        assert!(s.len == 5);\n-        assert!(count_nodes(&s) == 2);\n-        s.push_str(\" world!\");\n-        assert!(s.to_string() == \"Hello world!\");\n-        assert!(s.len == 12);\n-        assert!(count_nodes(&s) == 2);\n-\n-        let expected = \"Hello world!\";\n-        for ((i, (c, b)), cc) in s.chars().enumerate().zip(expected.chars()) {\n-            assert!(c == cc);\n-            assert!(i == b);\n-        }\n-    }\n-\n-    // TODO test unicode\n-\n-    // Helper methods.\n-    fn count_nodes(s: &StringBuffer) -> usize {\n-        count_nodes_from(&s.first)\n-    }\n-    fn count_nodes_from(s: &StringNode) -> usize {\n-        match s.next {\n-            Some(ref n) => 1 + count_nodes_from(n),\n-            None => 1,\n-        }\n-    }\n-    fn first_capacity(s: &StringBuffer) -> usize {\n-        s.first.data.capacity()\n-    }\n-}"}]}