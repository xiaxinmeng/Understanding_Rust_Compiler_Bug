{"sha": "9f26f14dc9b1e152a79e0999556f09f4ca952658", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmMjZmMTRkYzliMWUxNTJhNzllMDk5OTU1NmYwOWY0Y2E5NTI2NTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-08T22:45:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-08T22:45:19Z"}, "message": "Auto merge of #26869 - alexcrichton:fix-msvc-sepcomp, r=nrc\n\nThis commit alters the implementation of multiple codegen units slightly to be\r\ncompatible with the MSVC linker. Currently the implementation will take the N\r\nobject files created by each codegen unit and will run `ld -r` to create a new\r\nobject file which is then passed along. The MSVC linker, however, is not able to\r\ndo this operation.\r\n\r\nThe compiler will now no longer attempt to assemble object files together but\r\nwill instead just pass through all the object files as usual. This implies that\r\nrlibs may not contain more than one object file (if the library is compiled with\r\nmore than one codegen unit) and the output of `-C save-temps` will have changed\r\nslightly as object files with the extension `0.o` will not be renamed to `o`\r\nunless requested otherwise.", "tree": {"sha": "ba62469a07dbd2a31ac9e035d75d9663fde71c4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba62469a07dbd2a31ac9e035d75d9663fde71c4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f26f14dc9b1e152a79e0999556f09f4ca952658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f26f14dc9b1e152a79e0999556f09f4ca952658", "html_url": "https://github.com/rust-lang/rust/commit/9f26f14dc9b1e152a79e0999556f09f4ca952658", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f26f14dc9b1e152a79e0999556f09f4ca952658/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "020d201a661746359430610ee811b0aaa242dea8", "url": "https://api.github.com/repos/rust-lang/rust/commits/020d201a661746359430610ee811b0aaa242dea8", "html_url": "https://github.com/rust-lang/rust/commit/020d201a661746359430610ee811b0aaa242dea8"}, {"sha": "9bc8e6d1472a57441afe3592078838d2bc767996", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bc8e6d1472a57441afe3592078838d2bc767996", "html_url": "https://github.com/rust-lang/rust/commit/9bc8e6d1472a57441afe3592078838d2bc767996"}], "stats": {"total": 541, "additions": 289, "deletions": 252}, "files": [{"sha": "905012bbb64d851e8deda1eeb03fee3641024311", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -148,4 +148,5 @@ pub fn oom() -> ! {\n //                optimize it out).\n #[doc(hidden)]\n #[unstable(feature = \"issue_14344_fixme\")]\n+#[cfg(stage0)]\n pub fn fixme_14344_be_sure_to_link_to_collections() {}"}, {"sha": "3c90a2c54e128fc4bb552cfd2ab3ecf5810afe07", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -138,6 +138,7 @@ pub mod btree_set {\n // FIXME(#14344) this shouldn't be necessary\n #[doc(hidden)]\n #[unstable(feature = \"issue_14344_fixme\")]\n+#[cfg(stage0)]\n pub fn fixme_14344_be_sure_to_link_to_collections() {}\n \n #[cfg(not(test))]"}, {"sha": "102894bec133ed46ecc163f3e08610cea895c70a", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -6431,6 +6431,7 @@ pub mod funcs {\n }\n \n #[doc(hidden)]\n+#[cfg(stage0)]\n pub fn issue_14344_workaround() {} // FIXME #14344 force linkage to happen correctly\n \n #[test] fn work_on_windows() { } // FIXME #10872 needed for a happy windows"}, {"sha": "a9e9f17bdce75e31170e6b392c4097cf21f3a110", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -2136,11 +2136,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n     let mut rbml_w = Encoder::new(wr);\n \n     encode_crate_name(&mut rbml_w, &ecx.link_meta.crate_name);\n-    encode_crate_triple(&mut rbml_w,\n-                        &tcx.sess\n-                           .opts\n-                           .target_triple\n-                           );\n+    encode_crate_triple(&mut rbml_w, &tcx.sess.opts.target_triple);\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n "}, {"sha": "9541076df82be575eb3e80b12858558ca25bc949", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -804,8 +804,8 @@ fn write_out_deps(sess: &Session,\n         match *output_type {\n             config::OutputTypeExe => {\n                 for output in sess.crate_types.borrow().iter() {\n-                    let p = link::filename_for_input(sess, *output,\n-                                                     id, &file);\n+                    let p = link::filename_for_input(sess, *output, id,\n+                                                     outputs);\n                     out_filenames.push(p);\n                 }\n             }"}, {"sha": "7ccada1079ff908f2c4fd812507d5d68ae7a4778", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -452,10 +452,8 @@ impl RustcDefaultCalls {\n                     let metadata = driver::collect_crate_metadata(sess, attrs);\n                     *sess.crate_metadata.borrow_mut() = metadata;\n                     for &style in &crate_types {\n-                        let fname = link::filename_for_input(sess,\n-                                                             style,\n-                                                             &id,\n-                                                             &t_outputs.with_extension(\"\"));\n+                        let fname = link::filename_for_input(sess, style, &id,\n+                                                             &t_outputs);\n                         println!(\"{}\", fname.file_name().unwrap()\n                                             .to_string_lossy());\n                     }"}, {"sha": "21bc61593c9cdbf451fadcb726ba0277e753be5d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 139, "deletions": 127, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -417,11 +417,10 @@ pub fn link_binary(sess: &Session,\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n-        let obj_filename = outputs.temp_path(OutputTypeObject);\n-        if !sess.opts.output_types.contains(&OutputTypeObject) {\n-            remove(sess, &obj_filename);\n+        for obj in object_filenames(sess, outputs) {\n+            remove(sess, &obj);\n         }\n-        remove(sess, &obj_filename.with_extension(\"metadata.o\"));\n+        remove(sess, &outputs.with_extension(\"metadata.o\"));\n     }\n \n     out_filenames\n@@ -465,26 +464,25 @@ fn is_writeable(p: &Path) -> bool {\n \n pub fn filename_for_input(sess: &Session,\n                           crate_type: config::CrateType,\n-                          name: &str,\n-                          out_filename: &Path) -> PathBuf {\n-    let libname = format!(\"{}{}\", name, sess.opts.cg.extra_filename);\n+                          crate_name: &str,\n+                          outputs: &OutputFilenames) -> PathBuf {\n+    let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n     match crate_type {\n         config::CrateTypeRlib => {\n-            out_filename.with_file_name(&format!(\"lib{}.rlib\", libname))\n+            outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n             let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n                                     &sess.target.target.options.dll_suffix);\n-            out_filename.with_file_name(&format!(\"{}{}{}\",\n-                                                  prefix,\n-                                                 libname,\n-                                                 suffix))\n+            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n+                                                suffix))\n         }\n         config::CrateTypeStaticlib => {\n-            out_filename.with_file_name(&format!(\"lib{}.a\", libname))\n+            outputs.out_directory.join(&format!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => {\n             let suffix = &sess.target.target.options.exe_suffix;\n+            let out_filename = outputs.path(OutputTypeExe);\n             if suffix.is_empty() {\n                 out_filename.to_path_buf()\n             } else {\n@@ -499,50 +497,47 @@ fn link_binary_output(sess: &Session,\n                       crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n                       crate_name: &str) -> PathBuf {\n-    let obj_filename = outputs.temp_path(OutputTypeObject);\n+    let objects = object_filenames(sess, outputs);\n     let out_filename = match outputs.single_output_file {\n         Some(ref file) => file.clone(),\n-        None => {\n-            let out_filename = outputs.path(OutputTypeExe);\n-            filename_for_input(sess, crate_type, crate_name, &out_filename)\n-        }\n+        None => filename_for_input(sess, crate_type, crate_name, outputs),\n     };\n \n-    // Make sure the output and obj_filename are both writeable.\n-    // Mac, FreeBSD, and Windows system linkers check this already --\n-    // however, the Linux linker will happily overwrite a read-only file.\n-    // We should be consistent.\n-    let obj_is_writeable = is_writeable(&obj_filename);\n-    let out_is_writeable = is_writeable(&out_filename);\n-    if !out_is_writeable {\n-        sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n-                            permissions.\",\n-                           out_filename.display()));\n-    }\n-    else if !obj_is_writeable {\n-        sess.fatal(&format!(\"object file {} is not writeable -- check its \\\n-                            permissions.\",\n-                           obj_filename.display()));\n+    // Make sure files are writeable.  Mac, FreeBSD, and Windows system linkers\n+    // check this already -- however, the Linux linker will happily overwrite a\n+    // read-only file.  We should be consistent.\n+    for file in objects.iter().chain(Some(&out_filename)) {\n+        if !is_writeable(file) {\n+            sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n+                                permissions\", file.display()));\n+        }\n     }\n \n     match crate_type {\n         config::CrateTypeRlib => {\n-            link_rlib(sess, Some(trans), &obj_filename, &out_filename).build();\n+            link_rlib(sess, Some(trans), &objects, &out_filename).build();\n         }\n         config::CrateTypeStaticlib => {\n-            link_staticlib(sess, &obj_filename, &out_filename);\n+            link_staticlib(sess, &objects, &out_filename);\n         }\n         config::CrateTypeExecutable => {\n-            link_natively(sess, trans, false, &obj_filename, &out_filename);\n+            link_natively(sess, trans, false, &objects, &out_filename, outputs);\n         }\n         config::CrateTypeDylib => {\n-            link_natively(sess, trans, true, &obj_filename, &out_filename);\n+            link_natively(sess, trans, true, &objects, &out_filename, outputs);\n         }\n     }\n \n     out_filename\n }\n \n+fn object_filenames(sess: &Session, outputs: &OutputFilenames) -> Vec<PathBuf> {\n+    (0..sess.opts.cg.codegen_units).map(|i| {\n+        let ext = format!(\"{}.o\", i);\n+        outputs.temp_path(OutputTypeObject).with_extension(&ext)\n+    }).collect()\n+}\n+\n fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n     let mut search = Vec::new();\n     sess.target_filesearch(PathKind::Native).for_each_lib_search_path(|path, _| {\n@@ -552,6 +547,19 @@ fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n     return search;\n }\n \n+fn archive_config<'a>(sess: &'a Session,\n+                      output: &Path) -> ArchiveConfig<'a> {\n+    ArchiveConfig {\n+        handler: &sess.diagnostic().handler,\n+        dst: output.to_path_buf(),\n+        lib_search_paths: archive_search_paths(sess),\n+        slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n+        slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n+        ar_prog: get_ar_prog(sess),\n+        command_path: command_path(sess),\n+    }\n+}\n+\n // Create an 'rlib'\n //\n // An rlib in its current incarnation is essentially a renamed .a file. The\n@@ -560,21 +568,13 @@ fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n // native libraries and inserting all of the contents into this archive.\n fn link_rlib<'a>(sess: &'a Session,\n                  trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n-                 obj_filename: &Path,\n+                 objects: &[PathBuf],\n                  out_filename: &Path) -> ArchiveBuilder<'a> {\n-    info!(\"preparing rlib from {:?} to {:?}\", obj_filename, out_filename);\n-    let handler = &sess.diagnostic().handler;\n-    let config = ArchiveConfig {\n-        handler: handler,\n-        dst: out_filename.to_path_buf(),\n-        lib_search_paths: archive_search_paths(sess),\n-        slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n-        slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n-        ar_prog: get_ar_prog(sess),\n-        command_path: command_path(sess),\n-    };\n-    let mut ab = ArchiveBuilder::create(config);\n-    ab.add_file(obj_filename).unwrap();\n+    info!(\"preparing rlib from {:?} to {:?}\", objects, out_filename);\n+    let mut ab = ArchiveBuilder::create(archive_config(sess, out_filename));\n+    for obj in objects {\n+        ab.add_file(obj).unwrap();\n+    }\n \n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n@@ -600,7 +600,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     // this is as follows:\n     //\n     // * When performing LTO, this archive will be modified to remove\n-    //   obj_filename from above. The reason for this is described below.\n+    //   objects from above. The reason for this is described below.\n     //\n     // * When the system linker looks at an archive, it will attempt to\n     //   determine the architecture of the archive in order to see whether its\n@@ -639,15 +639,14 @@ fn link_rlib<'a>(sess: &'a Session,\n             // For LTO purposes, the bytecode of this library is also inserted\n             // into the archive.  If codegen_units > 1, we insert each of the\n             // bitcode files.\n-            for i in 0..sess.opts.cg.codegen_units {\n+            for obj in objects {\n                 // Note that we make sure that the bytecode filename in the\n                 // archive is never exactly 16 bytes long by adding a 16 byte\n                 // extension to it. This is to work around a bug in LLDB that\n                 // would cause it to crash if the name of a file in an archive\n                 // was exactly 16 bytes.\n-                let bc_filename = obj_filename.with_extension(&format!(\"{}.bc\", i));\n-                let bc_deflated_filename = obj_filename.with_extension(\n-                    &format!(\"{}.bytecode.deflate\", i));\n+                let bc_filename = obj.with_extension(\"bc\");\n+                let bc_deflated_filename = obj.with_extension(\"bytecode.deflate\");\n \n                 let mut bc_data = Vec::new();\n                 match fs::File::open(&bc_filename).and_then(|mut f| {\n@@ -750,8 +749,8 @@ fn write_rlib_bytecode_object_v1(writer: &mut Write,\n // There's no need to include metadata in a static archive, so ensure to not\n // link in the metadata object file (and also don't prepare the archive with a\n // metadata file).\n-fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n-    let ab = link_rlib(sess, None, obj_filename, out_filename);\n+fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path) {\n+    let ab = link_rlib(sess, None, objects, out_filename);\n     let mut ab = match sess.target.target.options.is_like_osx {\n         true => ab.build().extend(),\n         false => ab,\n@@ -806,8 +805,9 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n // This will invoke the system linker/cc to create the resulting file. This\n // links to all upstream files as well.\n fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n-                 obj_filename: &Path, out_filename: &Path) {\n-    info!(\"preparing dylib? ({}) from {:?} to {:?}\", dylib, obj_filename,\n+                 objects: &[PathBuf], out_filename: &Path,\n+                 outputs: &OutputFilenames) {\n+    info!(\"preparing dylib? ({}) from {:?} to {:?}\", dylib, objects,\n           out_filename);\n     let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n \n@@ -828,7 +828,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n             Box::new(GnuLinker { cmd: &mut cmd, sess: &sess }) as Box<Linker>\n         };\n         link_args(&mut *linker, sess, dylib, tmpdir.path(),\n-                  trans, obj_filename, out_filename);\n+                  trans, objects, out_filename, outputs);\n         if !sess.target.target.options.no_compiler_rt {\n             linker.link_staticlib(\"compiler-rt\");\n         }\n@@ -884,8 +884,9 @@ fn link_args(cmd: &mut Linker,\n              dylib: bool,\n              tmpdir: &Path,\n              trans: &CrateTranslation,\n-             obj_filename: &Path,\n-             out_filename: &Path) {\n+             objects: &[PathBuf],\n+             out_filename: &Path,\n+             outputs: &OutputFilenames) {\n \n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n@@ -895,7 +896,9 @@ fn link_args(cmd: &mut Linker,\n     let t = &sess.target.target;\n \n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n-    cmd.add_object(obj_filename);\n+    for obj in objects {\n+        cmd.add_object(obj);\n+    }\n     cmd.output_filename(out_filename);\n \n     // Stack growth requires statically linking a __morestack function. Note\n@@ -922,7 +925,7 @@ fn link_args(cmd: &mut Linker,\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n     if dylib {\n-        cmd.add_object(&obj_filename.with_extension(\"metadata.o\"));\n+        cmd.add_object(&outputs.with_extension(\"metadata.o\"));\n     }\n \n     // Try to strip as much out of the generated object by removing unused\n@@ -1127,7 +1130,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n                 add_dynamic_crate(cmd, sess, &src.dylib.unwrap().0)\n             }\n             cstore::RequireStatic => {\n-                add_static_crate(cmd, sess, tmpdir, &src.rlib.unwrap().0)\n+                add_static_crate(cmd, sess, tmpdir, dylib, &src.rlib.unwrap().0)\n             }\n         }\n \n@@ -1143,71 +1146,80 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n+    // There's a bit of magic which happens here specifically related to LTO and\n+    // dynamic libraries. Specifically:\n+    //\n+    // * For LTO, we remove upstream object files.\n+    // * For dylibs we remove metadata and bytecode from upstream rlibs\n+    //\n+    // When performing LTO, all of the bytecode from the upstream libraries has\n+    // already been included in our object file output. As a result we need to\n+    // remove the object files in the upstream libraries so the linker doesn't\n+    // try to include them twice (or whine about duplicate symbols). We must\n+    // continue to include the rest of the rlib, however, as it may contain\n+    // static native libraries which must be linked in.\n+    //\n+    // When making a dynamic library, linkers by default don't include any\n+    // object files in an archive if they're not necessary to resolve the link.\n+    // We basically want to convert the archive (rlib) to a dylib, though, so we\n+    // *do* want everything included in the output, regardless of whether the\n+    // linker thinks it's needed or not. As a result we must use the\n+    // --whole-archive option (or the platform equivalent). When using this\n+    // option the linker will fail if there are non-objects in the archive (such\n+    // as our own metadata and/or bytecode). All in all, for rlibs to be\n+    // entirely included in dylibs, we need to remove all non-object files.\n+    //\n+    // Note, however, that if we're not doing LTO or we're not producing a dylib\n+    // (aka we're making an executable), we can just pass the rlib blindly to\n+    // the linker (fast) because it's fine if it's not actually included as\n+    // we're at the end of the dependency chain.\n     fn add_static_crate(cmd: &mut Linker, sess: &Session, tmpdir: &Path,\n-                        cratepath: &Path) {\n-        // When performing LTO on an executable output, all of the\n-        // bytecode from the upstream libraries has already been\n-        // included in our object file output. We need to modify all of\n-        // the upstream archives to remove their corresponding object\n-        // file to make sure we don't pull the same code in twice.\n-        //\n-        // We must continue to link to the upstream archives to be sure\n-        // to pull in native static dependencies. As the final caveat,\n-        // on Linux it is apparently illegal to link to a blank archive,\n-        // so if an archive no longer has any object files in it after\n-        // we remove `lib.o`, then don't link against it at all.\n-        //\n-        // If we're not doing LTO, then our job is simply to just link\n-        // against the archive.\n-        if sess.lto() {\n-            let name = cratepath.file_name().unwrap().to_str().unwrap();\n-            let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n-            time(sess.time_passes(),\n-                 &format!(\"altering {}.rlib\", name),\n-                 (), |()| {\n-                let dst = tmpdir.join(cratepath.file_name().unwrap());\n-                match fs::copy(&cratepath, &dst) {\n-                    Ok(..) => {}\n-                    Err(e) => {\n-                        sess.fatal(&format!(\"failed to copy {} to {}: {}\",\n-                                            cratepath.display(),\n-                                            dst.display(), e));\n-                    }\n+                        dylib: bool, cratepath: &Path) {\n+        if !sess.lto() && !dylib {\n+            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n+            return\n+        }\n+\n+        let dst = tmpdir.join(cratepath.file_name().unwrap());\n+        let name = cratepath.file_name().unwrap().to_str().unwrap();\n+        let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n+\n+        time(sess.time_passes(), &format!(\"altering {}.rlib\", name), (), |()| {\n+            let err = (|| {\n+                io::copy(&mut try!(fs::File::open(&cratepath)),\n+                         &mut try!(fs::File::create(&dst)))\n+            })();\n+            if let Err(e) = err {\n+                sess.fatal(&format!(\"failed to copy {} to {}: {}\",\n+                                    cratepath.display(), dst.display(), e));\n+            }\n+\n+            let mut archive = Archive::open(archive_config(sess, &dst));\n+            archive.remove_file(METADATA_FILENAME);\n+\n+            let mut any_objects = false;\n+            for f in archive.files() {\n+                if f.ends_with(\"bytecode.deflate\") {\n+                    archive.remove_file(&f);\n+                    continue\n                 }\n-                // Fix up permissions of the copy, as fs::copy() preserves\n-                // permissions, but the original file may have been installed\n-                // by a package manager and may be read-only.\n-                match fs::metadata(&dst).and_then(|m| {\n-                    let mut perms = m.permissions();\n-                    perms.set_readonly(false);\n-                    fs::set_permissions(&dst, perms)\n-                }) {\n-                    Ok(..) => {}\n-                    Err(e) => {\n-                        sess.fatal(&format!(\"failed to chmod {} when preparing \\\n-                                             for LTO: {}\", dst.display(), e));\n+                let canonical = f.replace(\"-\", \"_\");\n+                let canonical_name = name.replace(\"-\", \"_\");\n+                if sess.lto() && canonical.starts_with(&canonical_name) &&\n+                   canonical.ends_with(\".o\") {\n+                    let num = &f[name.len()..f.len() - 2];\n+                    if num.len() > 0 && num[1..].parse::<u32>().is_ok() {\n+                        archive.remove_file(&f);\n+                        continue\n                     }\n                 }\n-                let handler = &sess.diagnostic().handler;\n-                let config = ArchiveConfig {\n-                    handler: handler,\n-                    dst: dst.clone(),\n-                    lib_search_paths: archive_search_paths(sess),\n-                    slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n-                    slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n-                    ar_prog: get_ar_prog(sess),\n-                    command_path: command_path(sess),\n-                };\n-                let mut archive = Archive::open(config);\n-                archive.remove_file(&format!(\"{}.o\", name));\n-                let files = archive.files();\n-                if files.iter().any(|s| s.ends_with(\".o\")) {\n-                    cmd.link_rlib(&dst);\n-                }\n-            });\n-        } else {\n-            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n-        }\n+                any_objects = true;\n+            }\n+\n+            if any_objects {\n+                cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n+            }\n+        });\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates."}, {"sha": "518a6c248407a995e38a6edc990b791c8fd18ad9", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -30,6 +30,7 @@ pub trait Linker {\n     fn link_framework(&mut self, framework: &str);\n     fn link_staticlib(&mut self, lib: &str);\n     fn link_rlib(&mut self, lib: &Path);\n+    fn link_whole_rlib(&mut self, lib: &Path);\n     fn link_whole_staticlib(&mut self, lib: &str, search_path: &[PathBuf]);\n     fn include_path(&mut self, path: &Path);\n     fn framework_path(&mut self, path: &Path);\n@@ -96,6 +97,17 @@ impl<'a> Linker for GnuLinker<'a> {\n         }\n     }\n \n+    fn link_whole_rlib(&mut self, lib: &Path) {\n+        if self.sess.target.target.options.is_like_osx {\n+            let mut v = OsString::from(\"-Wl,-force_load,\");\n+            v.push(lib);\n+            self.cmd.arg(&v);\n+        } else {\n+            self.cmd.arg(\"-Wl,--whole-archive\").arg(lib)\n+                    .arg(\"-Wl,--no-whole-archive\");\n+        }\n+    }\n+\n     fn gc_sections(&mut self, is_dylib: bool) {\n         // The dead_strip option to the linker specifies that functions and data\n         // unreachable by the entry point will be removed. This is quite useful\n@@ -250,6 +262,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n         // not supported?\n         self.link_staticlib(lib);\n     }\n+    fn link_whole_rlib(&mut self, path: &Path) {\n+        // not supported?\n+        self.link_rlib(path);\n+    }\n     fn optimize(&mut self) {\n         // Needs more investigation of `/OPT` arguments\n     }"}, {"sha": "dfeb866c5b3f00a2fd7b69e8079bad0a50edb58d", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -56,33 +56,14 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         };\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n-        let file = path.file_name().unwrap().to_str().unwrap();\n-        let file = &file[3..file.len() - 5]; // chop off lib/.rlib\n-        debug!(\"reading {}\", file);\n-        for i in 0.. {\n-            let filename = format!(\"{}.{}.bytecode.deflate\", file, i);\n-            let msg = format!(\"check for {}\", filename);\n-            let bc_encoded = time(sess.time_passes(), &msg, (), |_| {\n-                archive.iter().find(|section| {\n-                    section.name() == Some(&filename[..])\n-                })\n-            });\n-            let bc_encoded = match bc_encoded {\n-                Some(data) => data,\n-                None => {\n-                    if i == 0 {\n-                        // No bitcode was found at all.\n-                        sess.fatal(&format!(\"missing compressed bytecode in {}\",\n-                                           path.display()));\n-                    }\n-                    // No more bitcode files to read.\n-                    break\n-                }\n-            };\n-            let bc_encoded = bc_encoded.data();\n+        let bytecodes = archive.iter().filter_map(|child| {\n+            child.name().map(|name| (name, child))\n+        }).filter(|&(name, _)| name.ends_with(\"bytecode.deflate\"));\n+        for (name, data) in bytecodes {\n+            let bc_encoded = data.data();\n \n             let bc_decoded = if is_versioned_bytecode_format(bc_encoded) {\n-                time(sess.time_passes(), &format!(\"decode {}.{}.bc\", file, i), (), |_| {\n+                time(sess.time_passes(), &format!(\"decode {}\", name), (), |_| {\n                     // Read the version\n                     let version = extract_bytecode_format_version(bc_encoded);\n \n@@ -106,7 +87,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     }\n                 })\n             } else {\n-                time(sess.time_passes(), &format!(\"decode {}.{}.bc\", file, i), (), |_| {\n+                time(sess.time_passes(), &format!(\"decode {}\", name), (), |_| {\n                 // the object must be in the old, pre-versioning format, so simply\n                 // inflate everything and let LLVM decide if it can make sense of it\n                     match flate::inflate_bytes(bc_encoded) {\n@@ -120,10 +101,8 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             };\n \n             let ptr = bc_decoded.as_ptr();\n-            debug!(\"linking {}, part {}\", name, i);\n-            time(sess.time_passes(),\n-                 &format!(\"ll link {}.{}\", name, i),\n-                 (),\n+            debug!(\"linking {}\", name);\n+            time(sess.time_passes(), &format!(\"ll link {}\", name), (),\n                  |()| unsafe {\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                         ptr as *const libc::c_char,"}, {"sha": "0a9db8a651e65d0ab1d37ec6e211c6c995d2aafc", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 14, "deletions": 81, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -27,7 +27,6 @@ use std::ffi::{CStr, CString};\n use std::fs;\n use std::mem;\n use std::path::Path;\n-use std::process::Stdio;\n use std::ptr;\n use std::str;\n use std::sync::{Arc, Mutex};\n@@ -619,6 +618,8 @@ pub fn run_passes(sess: &Session,\n     let needs_crate_bitcode =\n             sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n             sess.opts.output_types.contains(&config::OutputTypeExe);\n+    let needs_crate_object =\n+            sess.opts.output_types.contains(&config::OutputTypeExe);\n     if needs_crate_bitcode {\n         modules_config.emit_bc = true;\n     }\n@@ -696,7 +697,8 @@ pub fn run_passes(sess: &Session,\n         if sess.opts.cg.codegen_units == 1 {\n             // 1) Only one codegen unit.  In this case it's no difficulty\n             //    to copy `foo.0.x` to `foo.x`.\n-            copy_gracefully(&crate_output.with_extension(ext), &crate_output.path(output_type));\n+            copy_gracefully(&crate_output.with_extension(ext),\n+                            &crate_output.path(output_type));\n             if !sess.opts.cg.save_temps && !keep_numbered {\n                 // The user just wants `foo.x`, not `foo.0.x`.\n                 remove(sess, &crate_output.with_extension(ext));\n@@ -715,76 +717,11 @@ pub fn run_passes(sess: &Session,\n         }\n     };\n \n-    let link_obj = |output_path: &Path| {\n-        // Running `ld -r` on a single input is kind of pointless.\n-        if sess.opts.cg.codegen_units == 1 {\n-            copy_gracefully(&crate_output.with_extension(\"0.o\"), output_path);\n-            // Leave the .0.o file around, to mimic the behavior of the normal\n-            // code path.\n-            return;\n-        }\n-\n-        // Some builds of MinGW GCC will pass --force-exe-suffix to ld, which\n-        // will automatically add a .exe extension if the extension is not\n-        // already .exe or .dll.  To ensure consistent behavior on Windows, we\n-        // add the .exe suffix explicitly and then rename the output file to\n-        // the desired path.  This will give the correct behavior whether or\n-        // not GCC adds --force-exe-suffix.\n-        let windows_output_path =\n-            if sess.target.target.options.is_like_windows {\n-                Some(output_path.with_extension(\"o.exe\"))\n-            } else {\n-                None\n-            };\n-\n-        let (pname, mut cmd) = get_linker(sess);\n-\n-        cmd.args(&sess.target.target.options.pre_link_args);\n-        cmd.arg(\"-nostdlib\");\n-\n-        for index in 0..trans.modules.len() {\n-            cmd.arg(&crate_output.with_extension(&format!(\"{}.o\", index)));\n-        }\n-\n-        cmd.arg(\"-r\").arg(\"-o\")\n-           .arg(windows_output_path.as_ref().map(|s| &**s).unwrap_or(output_path));\n-\n-        cmd.args(&sess.target.target.options.post_link_args);\n-\n-        if sess.opts.debugging_opts.print_link_args {\n-            println!(\"{:?}\", &cmd);\n-        }\n-\n-        cmd.stdin(Stdio::null());\n-        match cmd.status() {\n-            Ok(status) => {\n-                if !status.success() {\n-                    sess.err(&format!(\"linking of {} with `{:?}` failed\",\n-                                     output_path.display(), cmd));\n-                    sess.abort_if_errors();\n-                }\n-            },\n-            Err(e) => {\n-                sess.err(&format!(\"could not exec the linker `{}`: {}\",\n-                                 pname, e));\n-                sess.abort_if_errors();\n-            },\n-        }\n-\n-        match windows_output_path {\n-            Some(ref windows_path) => {\n-                fs::rename(windows_path, output_path).unwrap();\n-            },\n-            None => {\n-                // The file is already named according to `output_path`.\n-            }\n-        }\n-    };\n-\n     // Flag to indicate whether the user explicitly requested bitcode.\n     // Otherwise, we produced it only as a temporary output, and will need\n     // to get rid of it.\n     let mut user_wants_bitcode = false;\n+    let mut user_wants_objects = false;\n     for output_type in output_types {\n         match *output_type {\n             config::OutputTypeBitcode => {\n@@ -801,17 +738,10 @@ pub fn run_passes(sess: &Session,\n                 copy_if_one_unit(\"0.s\", config::OutputTypeAssembly, false);\n             }\n             config::OutputTypeObject => {\n-                link_obj(&crate_output.path(config::OutputTypeObject));\n-            }\n-            config::OutputTypeExe => {\n-                // If config::OutputTypeObject is already in the list, then\n-                // `crate.o` will be handled by the config::OutputTypeObject case.\n-                // Otherwise, we need to create the temporary object so we\n-                // can run the linker.\n-                if !sess.opts.output_types.contains(&config::OutputTypeObject) {\n-                    link_obj(&crate_output.temp_path(config::OutputTypeObject));\n-                }\n+                user_wants_objects = true;\n+                copy_if_one_unit(\"0.o\", config::OutputTypeObject, true);\n             }\n+            config::OutputTypeExe |\n             config::OutputTypeDepInfo => {}\n         }\n     }\n@@ -848,15 +778,18 @@ pub fn run_passes(sess: &Session,\n         let keep_numbered_bitcode = needs_crate_bitcode ||\n                 (user_wants_bitcode && sess.opts.cg.codegen_units > 1);\n \n+        let keep_numbered_objects = needs_crate_object ||\n+                (user_wants_objects && sess.opts.cg.codegen_units > 1);\n+\n         for i in 0..trans.modules.len() {\n-            if modules_config.emit_obj {\n+            if modules_config.emit_obj && !keep_numbered_objects {\n                 let ext = format!(\"{}.o\", i);\n-                remove(sess, &crate_output.with_extension(&ext[..]));\n+                remove(sess, &crate_output.with_extension(&ext));\n             }\n \n             if modules_config.emit_bc && !keep_numbered_bitcode {\n                 let ext = format!(\"{}.bc\", i);\n-                remove(sess, &crate_output.with_extension(&ext[..]));\n+                remove(sess, &crate_output.with_extension(&ext));\n             }\n         }\n "}, {"sha": "78c03bac33f27bc31b581707770ff7b55d0f829f", "filename": "src/test/auxiliary/issue-14344-1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Fauxiliary%2Fissue-14344-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Fauxiliary%2Fissue-14344-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-14344-1.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rlib\"]\n+\n+pub fn foo() {}"}, {"sha": "9df35e50adba9ce73eeafa60bb761789190fc636", "filename": "src/test/auxiliary/issue-14344-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Fauxiliary%2Fissue-14344-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Fauxiliary%2Fissue-14344-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-14344-2.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate issue_14344_1;\n+\n+pub fn bar() {}"}, {"sha": "b9da39cbbcb4e35a516c4456b5b9a2c0f16b5ef6", "filename": "src/test/auxiliary/issue-25185-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Fauxiliary%2Fissue-25185-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Fauxiliary%2Fissue-25185-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-25185-1.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rlib\"]\n+\n+#[link(name = \"rust_test_helpers\", kind = \"static\")]\n+extern {\n+    pub fn rust_dbg_extern_identity_u32(u: u32) -> u32;\n+}"}, {"sha": "00b5277d6c00e852e3682969f7c68c62e4cc4f60", "filename": "src/test/auxiliary/issue-25185-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Fauxiliary%2Fissue-25185-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Fauxiliary%2Fissue-25185-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-25185-2.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate issue_25185_1;\n+\n+pub use issue_25185_1::rust_dbg_extern_identity_u32;"}, {"sha": "79a9a3c640f03b62cc294be160d9e82f48372ab2", "filename": "src/test/run-make/extern-fn-reachable/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2FMakefile?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -4,6 +4,6 @@\n TARGET_RPATH_DIR:=$(TARGET_RPATH_DIR):$(TMPDIR)\n \n all:\n-\t$(RUSTC) dylib.rs -o $(TMPDIR)/libdylib.so\n-\t$(RUSTC) main.rs\n+\t$(RUSTC) dylib.rs -o $(TMPDIR)/libdylib.so -C prefer-dynamic\n+\t$(RUSTC) main.rs -C prefer-dynamic\n \t$(call RUN,main)"}, {"sha": "d33c18a6f3c2c8159045b935a85a59c0a06354b7", "filename": "src/test/run-make/extra-filename-with-temp-outputs/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Frun-make%2Fextra-filename-with-temp-outputs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Frun-make%2Fextra-filename-with-temp-outputs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextra-filename-with-temp-outputs%2FMakefile?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -2,5 +2,5 @@\n \n all:\n \t$(RUSTC) -C extra-filename=bar foo.rs -C save-temps\n-\trm $(TMPDIR)/foobar.o\n+\trm $(TMPDIR)/foobar.0.o\n \trm $(TMPDIR)/$(call BIN,foobar)"}, {"sha": "06b8f44ed260ccc778a9e43edaeb3d466885badb", "filename": "src/test/run-pass/issue-14344.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Frun-pass%2Fissue-14344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Frun-pass%2Fissue-14344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14344.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-14344-1.rs\n+// aux-build:issue-14344-2.rs\n+\n+extern crate issue_14344_1;\n+extern crate issue_14344_2;\n+\n+fn main() {\n+    issue_14344_1::foo();\n+    issue_14344_2::bar();\n+}"}, {"sha": "d8d2d5078c5e71342490d9a082b68e0bab8a6151", "filename": "src/test/run-pass/issue-25185.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Frun-pass%2Fissue-25185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f26f14dc9b1e152a79e0999556f09f4ca952658/src%2Ftest%2Frun-pass%2Fissue-25185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25185.rs?ref=9f26f14dc9b1e152a79e0999556f09f4ca952658", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-25185-1.rs\n+// aux-build:issue-25185-2.rs\n+\n+extern crate issue_25185_2;\n+\n+fn main() {\n+    let x = unsafe {\n+        issue_25185_2::rust_dbg_extern_identity_u32(1)\n+    };\n+    assert_eq!(x, 1);\n+}"}]}