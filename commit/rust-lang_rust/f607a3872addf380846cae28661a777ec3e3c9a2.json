{"sha": "f607a3872addf380846cae28661a777ec3e3c9a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MDdhMzg3MmFkZGYzODA4NDZjYWUyODY2MWE3NzdlYzNlM2M5YTI=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-11T15:19:48Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-12T20:53:22Z"}, "message": "Rename alloc::Void to alloc::Opaque", "tree": {"sha": "73dc7f401b1b77cd28e3454638b876a14d2d9ac8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73dc7f401b1b77cd28e3454638b876a14d2d9ac8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f607a3872addf380846cae28661a777ec3e3c9a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f607a3872addf380846cae28661a777ec3e3c9a2", "html_url": "https://github.com/rust-lang/rust/commit/f607a3872addf380846cae28661a777ec3e3c9a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f607a3872addf380846cae28661a777ec3e3c9a2/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed297777599081d11c4a337cf19c9b1a1112136b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed297777599081d11c4a337cf19c9b1a1112136b", "html_url": "https://github.com/rust-lang/rust/commit/ed297777599081d11c4a337cf19c9b1a1112136b"}], "stats": {"total": 279, "additions": 139, "deletions": 140}, "files": [{"sha": "3c56329d1bd9038e5341f1962bcd8d043312a712", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -1 +1 @@\n-Subproject commit 498ac2997420f7b25f7cd0a3f8202950d8ad93ec\n+Subproject commit 3c56329d1bd9038e5341f1962bcd8d043312a712"}, {"sha": "031b6347445e2af92cc22ab75ca1cb16cad491f8", "filename": "src/doc/unstable-book/src/language-features/global-allocator.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -29,17 +29,17 @@ looks like:\n ```rust\n #![feature(global_allocator, allocator_api, heap_api)]\n \n-use std::alloc::{GlobalAlloc, System, Layout, Void};\n+use std::alloc::{GlobalAlloc, System, Layout, Opaque};\n use std::ptr::NonNull;\n \n struct MyAllocator;\n \n unsafe impl GlobalAlloc for MyAllocator {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&self, ptr: *mut Void, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n         System.dealloc(ptr, layout)\n     }\n }"}, {"sha": "68a617e0ffed4371e21570a16d975e2c964fc02f", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -76,36 +76,36 @@ pub const Heap: Global = Global;\n \n unsafe impl GlobalAlloc for Global {\n     #[inline]\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n         #[cfg(not(stage0))]\n         let ptr = __rust_alloc(layout.size(), layout.align());\n         #[cfg(stage0)]\n         let ptr = __rust_alloc(layout.size(), layout.align(), &mut 0);\n-        ptr as *mut Void\n+        ptr as *mut Opaque\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&self, ptr: *mut Void, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n         __rust_dealloc(ptr as *mut u8, layout.size(), layout.align())\n     }\n \n     #[inline]\n-    unsafe fn realloc(&self, ptr: *mut Void, layout: Layout, new_size: usize) -> *mut Void {\n+    unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n         #[cfg(not(stage0))]\n         let ptr = __rust_realloc(ptr as *mut u8, layout.size(), layout.align(), new_size);\n         #[cfg(stage0)]\n         let ptr = __rust_realloc(ptr as *mut u8, layout.size(), layout.align(),\n                                  new_size, layout.align(), &mut 0);\n-        ptr as *mut Void\n+        ptr as *mut Opaque\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Void {\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n         #[cfg(not(stage0))]\n         let ptr = __rust_alloc_zeroed(layout.size(), layout.align());\n         #[cfg(stage0)]\n         let ptr = __rust_alloc_zeroed(layout.size(), layout.align(), &mut 0);\n-        ptr as *mut Void\n+        ptr as *mut Opaque\n     }\n \n     #[inline]\n@@ -121,27 +121,27 @@ unsafe impl GlobalAlloc for Global {\n \n unsafe impl Alloc for Global {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Void>, layout: Layout) {\n+    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n         GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Void>,\n+                      ptr: NonNull<Opaque>,\n                       layout: Layout,\n                       new_size: usize)\n-                      -> Result<NonNull<Void>, AllocErr>\n+                      -> Result<NonNull<Opaque>, AllocErr>\n     {\n         NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n     }\n \n@@ -178,7 +178,7 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n     if size != 0 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        Global.dealloc(ptr as *mut Void, layout);\n+        Global.dealloc(ptr as *mut Opaque, layout);\n     }\n }\n "}, {"sha": "225b055d8ee8296129faae4ddacef105172a1186", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -518,7 +518,7 @@ impl<T: ?Sized> Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            Global.dealloc(self.ptr.as_void(), Layout::for_value(self.ptr.as_ref()))\n+            Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()))\n         }\n     }\n \n@@ -637,7 +637,7 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem.as_void(), self.layout.clone());\n+                    Global.dealloc(self.mem.as_opaque(), self.layout.clone());\n                 }\n             }\n         }\n@@ -1156,7 +1156,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n             unsafe {\n-                Global.dealloc(self.ptr.as_void(), Layout::for_value(self.ptr.as_ref()))\n+                Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()))\n             }\n         }\n     }"}, {"sha": "d6346662314e65ae993a498ff4ffba1fb9579f30", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -249,7 +249,7 @@ impl<K, V> Root<K, V> {\n         self.as_mut().as_leaf_mut().parent = ptr::null();\n \n         unsafe {\n-            Global.dealloc(NonNull::from(top).as_void(), Layout::new::<InternalNode<K, V>>());\n+            Global.dealloc(NonNull::from(top).as_opaque(), Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -435,7 +435,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n     > {\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(node.as_void(), Layout::new::<LeafNode<K, V>>());\n+        Global.dealloc(node.as_opaque(), Layout::new::<LeafNode<K, V>>());\n         ret\n     }\n }\n@@ -456,7 +456,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n     > {\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(node.as_void(), Layout::new::<InternalNode<K, V>>());\n+        Global.dealloc(node.as_opaque(), Layout::new::<InternalNode<K, V>>());\n         ret\n     }\n }\n@@ -1239,12 +1239,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 }\n \n                 Global.dealloc(\n-                    right_node.node.as_void(),\n+                    right_node.node.as_opaque(),\n                     Layout::new::<InternalNode<K, V>>(),\n                 );\n             } else {\n                 Global.dealloc(\n-                    right_node.node.as_void(),\n+                    right_node.node.as_opaque(),\n                     Layout::new::<LeafNode<K, V>>(),\n                 );\n             }"}, {"sha": "faac38ca7ce15d5a35fe1e09f06f4b223b009fc7", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(deprecated)]\n \n-pub use alloc::{Layout, AllocErr, CannotReallocInPlace, Void};\n+pub use alloc::{Layout, AllocErr, CannotReallocInPlace, Opaque};\n use core::alloc::Alloc as CoreAlloc;\n use core::ptr::NonNull;\n \n@@ -54,7 +54,7 @@ unsafe impl<T> Alloc for T where T: CoreAlloc {\n     }\n \n     unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Void);\n+        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n         CoreAlloc::dealloc(self, ptr, layout)\n     }\n \n@@ -70,7 +70,7 @@ unsafe impl<T> Alloc for T where T: CoreAlloc {\n                       ptr: *mut u8,\n                       layout: Layout,\n                       new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Void);\n+        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n         CoreAlloc::realloc(self, ptr, layout, new_layout.size()).map(|ptr| ptr.cast().as_ptr())\n     }\n \n@@ -87,7 +87,7 @@ unsafe impl<T> Alloc for T where T: CoreAlloc {\n                              ptr: *mut u8,\n                              layout: Layout,\n                              new_layout: Layout) -> Result<Excess, AllocErr> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Void);\n+        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n         CoreAlloc::realloc_excess(self, ptr, layout, new_layout.size())\n             .map(|e| Excess(e.0 .cast().as_ptr(), e.1))\n     }\n@@ -96,15 +96,15 @@ unsafe impl<T> Alloc for T where T: CoreAlloc {\n                             ptr: *mut u8,\n                             layout: Layout,\n                             new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Void);\n+        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n         CoreAlloc::grow_in_place(self, ptr, layout, new_layout.size())\n     }\n \n     unsafe fn shrink_in_place(&mut self,\n                               ptr: *mut u8,\n                               layout: Layout,\n                               new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Void);\n+        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n         CoreAlloc::shrink_in_place(self, ptr, layout, new_layout.size())\n     }\n }"}, {"sha": "214cc7d7d0cd96e6f8553f58f12a024deb5b62d4", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -90,7 +90,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n-                NonNull::<T>::dangling().as_void()\n+                NonNull::<T>::dangling().as_opaque()\n             } else {\n                 let align = mem::align_of::<T>();\n                 let result = if zeroed {\n@@ -310,7 +310,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = 2 * self.cap;\n                     let new_size = new_cap * elem_size;\n                     alloc_guard(new_size).expect(\"capacity overflow\");\n-                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).as_void(),\n+                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).as_opaque(),\n                                                  cur,\n                                                  new_size);\n                     match ptr_res {\n@@ -369,7 +369,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let new_cap = 2 * self.cap;\n             let new_size = new_cap * elem_size;\n             alloc_guard(new_size).expect(\"capacity overflow\");\n-            match self.a.grow_in_place(NonNull::from(self.ptr).as_void(), old_layout, new_size) {\n+            match self.a.grow_in_place(NonNull::from(self.ptr).as_opaque(), old_layout, new_size) {\n                 Ok(_) => {\n                     // We can't directly divide `size`.\n                     self.cap = new_cap;\n@@ -426,7 +426,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let res = match self.current_layout() {\n                 Some(layout) => {\n                     debug_assert!(new_layout.align() == layout.align());\n-                    self.a.realloc(NonNull::from(self.ptr).as_void(), layout, new_layout.size())\n+                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n@@ -535,7 +535,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let res = match self.current_layout() {\n                 Some(layout) => {\n                     debug_assert!(new_layout.align() == layout.align());\n-                    self.a.realloc(NonNull::from(self.ptr).as_void(), layout, new_layout.size())\n+                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n@@ -601,7 +601,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // FIXME: may crash and burn on over-reserve\n             alloc_guard(new_layout.size()).expect(\"capacity overflow\");\n             match self.a.grow_in_place(\n-                NonNull::from(self.ptr).as_void(), old_layout, new_layout.size(),\n+                NonNull::from(self.ptr).as_opaque(), old_layout, new_layout.size(),\n             ) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n@@ -662,7 +662,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 let new_size = elem_size * amount;\n                 let align = mem::align_of::<T>();\n                 let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-                match self.a.realloc(NonNull::from(self.ptr).as_void(),\n+                match self.a.realloc(NonNull::from(self.ptr).as_opaque(),\n                                      old_layout,\n                                      new_size) {\n                     Ok(p) => self.ptr = p.cast().into(),\n@@ -698,7 +698,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n         let elem_size = mem::size_of::<T>();\n         if elem_size != 0 {\n             if let Some(layout) = self.current_layout() {\n-                self.a.dealloc(NonNull::from(self.ptr).as_void(), layout);\n+                self.a.dealloc(NonNull::from(self.ptr).as_opaque(), layout);\n             }\n         }\n     }\n@@ -734,7 +734,7 @@ fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use alloc::Void;\n+    use alloc::Opaque;\n \n     #[test]\n     fn allocator_param() {\n@@ -754,7 +754,7 @@ mod tests {\n         // before allocation attempts start failing.\n         struct BoundedAlloc { fuel: usize }\n         unsafe impl Alloc for BoundedAlloc {\n-            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n+            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n                 let size = layout.size();\n                 if size > self.fuel {\n                     return Err(AllocErr);\n@@ -764,7 +764,7 @@ mod tests {\n                     err @ Err(_) => err,\n                 }\n             }\n-            unsafe fn dealloc(&mut self, ptr: NonNull<Void>, layout: Layout) {\n+            unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n                 Global.dealloc(ptr, layout)\n             }\n         }"}, {"sha": "de0422d82bb76aaa77fce3a616e60e461b18a555", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -259,7 +259,7 @@ use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n \n-use alloc::{Global, Alloc, Layout, Void, box_free};\n+use alloc::{Global, Alloc, Layout, Opaque, box_free};\n use string::String;\n use vec::Vec;\n \n@@ -737,7 +737,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n         // In the event of a panic, elements that have been written\n         // into the new RcBox will be dropped, then the memory freed.\n         struct Guard<T> {\n-            mem: NonNull<Void>,\n+            mem: NonNull<Opaque>,\n             elems: *mut T,\n             layout: Layout,\n             n_elems: usize,\n@@ -760,7 +760,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n             let v_ptr = v as *const [T];\n             let ptr = Self::allocate_for_ptr(v_ptr);\n \n-            let mem = ptr as *mut _ as *mut Void;\n+            let mem = ptr as *mut _ as *mut Opaque;\n             let layout = Layout::for_value(&*ptr);\n \n             // Pointer to first element\n@@ -844,7 +844,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n                 self.dec_weak();\n \n                 if self.weak() == 0 {\n-                    Global.dealloc(self.ptr.as_void(), Layout::for_value(self.ptr.as_ref()));\n+                    Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()));\n                 }\n             }\n         }\n@@ -1268,7 +1268,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n             // the weak count starts at 1, and will only go to zero if all\n             // the strong pointers have disappeared.\n             if self.weak() == 0 {\n-                Global.dealloc(self.ptr.as_void(), Layout::for_value(self.ptr.as_ref()));\n+                Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()));\n             }\n         }\n     }"}, {"sha": "fd8109e2a4aab3d72d280c6fbab55bb44d9f611a", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -41,7 +41,7 @@ const MIN_ALIGN: usize = 8;\n #[allow(dead_code)]\n const MIN_ALIGN: usize = 16;\n \n-use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout, Void};\n+use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout, Opaque};\n use core::ptr::NonNull;\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n@@ -50,25 +50,25 @@ pub struct System;\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl Alloc for System {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Void>, layout: Layout) {\n+    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n         GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Void>,\n+                      ptr: NonNull<Opaque>,\n                       layout: Layout,\n-                      new_size: usize) -> Result<NonNull<Void>, AllocErr> {\n+                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n         NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n     }\n \n@@ -82,25 +82,25 @@ unsafe impl Alloc for System {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl<'a> Alloc for &'a System {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc(*self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc_zeroed(*self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Void>, layout: Layout) {\n+    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n         GlobalAlloc::dealloc(*self, ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Void>,\n+                      ptr: NonNull<Opaque>,\n                       layout: Layout,\n-                      new_size: usize) -> Result<NonNull<Void>, AllocErr> {\n+                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n         NonNull::new(GlobalAlloc::realloc(*self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n     }\n \n@@ -112,13 +112,13 @@ unsafe impl<'a> Alloc for &'a System {\n \n #[cfg(any(windows, unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n mod realloc_fallback {\n-    use core::alloc::{GlobalAlloc, Void, Layout};\n+    use core::alloc::{GlobalAlloc, Opaque, Layout};\n     use core::cmp;\n     use core::ptr;\n \n     impl super::System {\n-        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut Void, old_layout: Layout,\n-                                              new_size: usize) -> *mut Void {\n+        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut Opaque, old_layout: Layout,\n+                                              new_size: usize) -> *mut Opaque {\n             // Docs for GlobalAlloc::realloc require this to be valid:\n             let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n \n@@ -141,30 +141,31 @@ mod platform {\n \n     use MIN_ALIGN;\n     use System;\n-    use core::alloc::{GlobalAlloc, Layout, Void};\n+    use core::alloc::{GlobalAlloc, Layout, Opaque};\n \n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n+        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n             if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::malloc(layout.size()) as *mut Void\n+                libc::malloc(layout.size()) as *mut Opaque\n             } else {\n                 #[cfg(target_os = \"macos\")]\n                 {\n                     if layout.align() > (1 << 31) {\n-                        // FIXME: use Void::null_mut https://github.com/rust-lang/rust/issues/49659\n-                        return 0 as *mut Void\n+                        // FIXME: use Opaque::null_mut\n+                        // https://github.com/rust-lang/rust/issues/49659\n+                        return 0 as *mut Opaque\n                     }\n                 }\n                 aligned_malloc(&layout)\n             }\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Void {\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n             if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::calloc(layout.size(), 1) as *mut Void\n+                libc::calloc(layout.size(), 1) as *mut Opaque\n             } else {\n                 let ptr = self.alloc(layout.clone());\n                 if !ptr.is_null() {\n@@ -175,24 +176,23 @@ mod platform {\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut Void, _layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut Opaque, _layout: Layout) {\n             libc::free(ptr as *mut libc::c_void)\n         }\n \n         #[inline]\n-        unsafe fn realloc(&self, ptr: *mut Void, old_layout: Layout, new_size: usize) -> *mut Void {\n-            let align = old_layout.align();\n-            if align <= MIN_ALIGN && align <= new_size {\n-                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut Void\n+        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n+                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut Opaque\n             } else {\n-                self.realloc_fallback(ptr, old_layout, new_size)\n+                self.realloc_fallback(ptr, layout, new_size)\n             }\n         }\n     }\n \n     #[cfg(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\"))]\n     #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut Void {\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut Opaque {\n         // On android we currently target API level 9 which unfortunately\n         // doesn't have the `posix_memalign` API used below. Instead we use\n         // `memalign`, but this unfortunately has the property on some systems\n@@ -210,19 +210,19 @@ mod platform {\n         // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n         // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n         //                                       /memory/aligned_memory.cc\n-        libc::memalign(layout.align(), layout.size()) as *mut Void\n+        libc::memalign(layout.align(), layout.size()) as *mut Opaque\n     }\n \n     #[cfg(not(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\")))]\n     #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut Void {\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut Opaque {\n         let mut out = ptr::null_mut();\n         let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n         if ret != 0 {\n-            // FIXME: use Void::null_mut https://github.com/rust-lang/rust/issues/49659\n-            0 as *mut Void\n+            // FIXME: use Opaque::null_mut https://github.com/rust-lang/rust/issues/49659\n+            0 as *mut Opaque\n         } else {\n-            out as *mut Void\n+            out as *mut Opaque\n         }\n     }\n }\n@@ -232,7 +232,7 @@ mod platform {\n mod platform {\n     use MIN_ALIGN;\n     use System;\n-    use core::alloc::{GlobalAlloc, Void, Layout};\n+    use core::alloc::{GlobalAlloc, Opaque, Layout};\n \n     type LPVOID = *mut u8;\n     type HANDLE = LPVOID;\n@@ -264,7 +264,7 @@ mod platform {\n     }\n \n     #[inline]\n-    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut Void {\n+    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut Opaque {\n         let ptr = if layout.align() <= MIN_ALIGN {\n             HeapAlloc(GetProcessHeap(), flags, layout.size())\n         } else {\n@@ -276,23 +276,23 @@ mod platform {\n                 align_ptr(ptr, layout.align())\n             }\n         };\n-        ptr as *mut Void\n+        ptr as *mut Opaque\n     }\n \n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n+        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n             allocate_with_flags(layout, 0)\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Void {\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n             allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut Void, layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n             if layout.align() <= MIN_ALIGN {\n                 let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n                 debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n@@ -306,12 +306,11 @@ mod platform {\n         }\n \n         #[inline]\n-        unsafe fn realloc(&self, ptr: *mut Void, old_layout: Layout, new_size: usize) -> *mut Void {\n-            let align = old_layout.align();\n-            if align <= MIN_ALIGN {\n-                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut Void\n+        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+            if layout.align() <= MIN_ALIGN {\n+                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut Opaque\n             } else {\n-                self.realloc_fallback(ptr, old_layout, new_size)\n+                self.realloc_fallback(ptr, layout, new_size)\n             }\n         }\n     }\n@@ -338,7 +337,7 @@ mod platform {\n mod platform {\n     extern crate dlmalloc;\n \n-    use core::alloc::{GlobalAlloc, Layout, Void};\n+    use core::alloc::{GlobalAlloc, Layout, Opaque};\n     use System;\n \n     // No need for synchronization here as wasm is currently single-threaded\n@@ -347,23 +346,23 @@ mod platform {\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n-            DLMALLOC.malloc(layout.size(), layout.align()) as *mut Void\n+        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+            DLMALLOC.malloc(layout.size(), layout.align()) as *mut Opaque\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Void {\n-            DLMALLOC.calloc(layout.size(), layout.align()) as *mut Void\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n+            DLMALLOC.calloc(layout.size(), layout.align()) as *mut Opaque\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut Void, layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n             DLMALLOC.free(ptr as *mut u8, layout.size(), layout.align())\n         }\n \n         #[inline]\n-        unsafe fn realloc(&self, ptr: *mut Void, layout: Layout, new_size: usize) -> *mut Void {\n-            DLMALLOC.realloc(ptr as *mut u8, layout.size(), layout.align(), new_size) as *mut Void\n+        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+            DLMALLOC.realloc(ptr as *mut u8, layout.size(), layout.align(), new_size) as *mut Opaque\n         }\n     }\n }"}, {"sha": "fdba91bec8013a92923ce95a9ad4d5412b0e19d5", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -24,12 +24,12 @@ use ptr::{self, NonNull};\n extern {\n     /// An opaque, unsized type. Used for pointers to allocated memory.\n     ///\n-    /// This type can only be used behind a pointer like `*mut Void` or `ptr::NonNull<Void>`.\n+    /// This type can only be used behind a pointer like `*mut Opaque` or `ptr::NonNull<Opaque>`.\n     /// Such pointers are similar to C\u2019s `void*` type.\n-    pub type Void;\n+    pub type Opaque;\n }\n \n-impl Void {\n+impl Opaque {\n     /// Similar to `std::ptr::null`, which requires `T: Sized`.\n     pub fn null() -> *const Self {\n         0 as _\n@@ -44,7 +44,7 @@ impl Void {\n /// Represents the combination of a starting address and\n /// a total capacity of the returned block.\n #[derive(Debug)]\n-pub struct Excess(pub NonNull<Void>, pub usize);\n+pub struct Excess(pub NonNull<Opaque>, pub usize);\n \n fn size_align<T>() -> (usize, usize) {\n     (mem::size_of::<T>(), mem::align_of::<T>())\n@@ -387,11 +387,11 @@ impl From<AllocErr> for CollectionAllocErr {\n \n // FIXME: docs\n pub unsafe trait GlobalAlloc {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Void;\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque;\n \n-    unsafe fn dealloc(&self, ptr: *mut Void, layout: Layout);\n+    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout);\n \n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Void {\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n         let size = layout.size();\n         let ptr = self.alloc(layout);\n         if !ptr.is_null() {\n@@ -404,7 +404,7 @@ pub unsafe trait GlobalAlloc {\n     ///\n     /// `new_size`, when rounded up to the nearest multiple of `old_layout.align()`,\n     /// must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n-    unsafe fn realloc(&self, ptr: *mut Void, old_layout: Layout, new_size: usize) -> *mut Void {\n+    unsafe fn realloc(&self, ptr: *mut Opaque, old_layout: Layout, new_size: usize) -> *mut Opaque {\n         let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n         let new_ptr = self.alloc(new_layout);\n         if !new_ptr.is_null() {\n@@ -554,7 +554,7 @@ pub unsafe trait Alloc {\n     /// Clients wishing to abort computation in response to an\n     /// allocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr>;\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr>;\n \n     /// Deallocate the memory referenced by `ptr`.\n     ///\n@@ -571,7 +571,7 @@ pub unsafe trait Alloc {\n     /// * In addition to fitting the block of memory `layout`, the\n     ///   alignment of the `layout` must match the alignment used\n     ///   to allocate that block of memory.\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Void>, layout: Layout);\n+    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout);\n \n     /// Allocator-specific method for signaling an out-of-memory\n     /// condition.\n@@ -689,9 +689,9 @@ pub unsafe trait Alloc {\n     /// reallocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n     unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Void>,\n+                      ptr: NonNull<Opaque>,\n                       layout: Layout,\n-                      new_size: usize) -> Result<NonNull<Void>, AllocErr> {\n+                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n         let old_size = layout.size();\n \n         if new_size >= old_size {\n@@ -732,7 +732,7 @@ pub unsafe trait Alloc {\n     /// Clients wishing to abort computation in response to an\n     /// allocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n         let size = layout.size();\n         let p = self.alloc(layout);\n         if let Ok(p) = p {\n@@ -781,7 +781,7 @@ pub unsafe trait Alloc {\n     /// reallocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n     unsafe fn realloc_excess(&mut self,\n-                             ptr: NonNull<Void>,\n+                             ptr: NonNull<Opaque>,\n                              layout: Layout,\n                              new_size: usize) -> Result<Excess, AllocErr> {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n@@ -826,7 +826,7 @@ pub unsafe trait Alloc {\n     /// `grow_in_place` failures without aborting, or to fall back on\n     /// another reallocation method before resorting to an abort.\n     unsafe fn grow_in_place(&mut self,\n-                            ptr: NonNull<Void>,\n+                            ptr: NonNull<Opaque>,\n                             layout: Layout,\n                             new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n@@ -881,7 +881,7 @@ pub unsafe trait Alloc {\n     /// `shrink_in_place` failures without aborting, or to fall back\n     /// on another reallocation method before resorting to an abort.\n     unsafe fn shrink_in_place(&mut self,\n-                              ptr: NonNull<Void>,\n+                              ptr: NonNull<Opaque>,\n                               layout: Layout,\n                               new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n@@ -960,7 +960,7 @@ pub unsafe trait Alloc {\n     {\n         let k = Layout::new::<T>();\n         if k.size() > 0 {\n-            self.dealloc(ptr.as_void(), k);\n+            self.dealloc(ptr.as_opaque(), k);\n         }\n     }\n \n@@ -1048,7 +1048,7 @@ pub unsafe trait Alloc {\n         match (Layout::array::<T>(n_old), Layout::array::<T>(n_new)) {\n             (Ok(ref k_old), Ok(ref k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n                 debug_assert!(k_old.align() == k_new.align());\n-                self.realloc(ptr.as_void(), k_old.clone(), k_new.size()).map(NonNull::cast)\n+                self.realloc(ptr.as_opaque(), k_old.clone(), k_new.size()).map(NonNull::cast)\n             }\n             _ => {\n                 Err(AllocErr)\n@@ -1081,7 +1081,7 @@ pub unsafe trait Alloc {\n     {\n         match Layout::array::<T>(n) {\n             Ok(ref k) if k.size() > 0 => {\n-                Ok(self.dealloc(ptr.as_void(), k.clone()))\n+                Ok(self.dealloc(ptr.as_opaque(), k.clone()))\n             }\n             _ => {\n                 Err(AllocErr)"}, {"sha": "4a7d7c410eb16eebb850da3bd1cb9becb67af717", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -2751,9 +2751,9 @@ impl<T: ?Sized> NonNull<T> {\n         }\n     }\n \n-    /// Cast to a `Void` pointer\n+    /// Cast to an `Opaque` pointer\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub fn as_void(self) -> NonNull<::alloc::Void> {\n+    pub fn as_opaque(self) -> NonNull<::alloc::Opaque> {\n         unsafe {\n             NonNull::new_unchecked(self.as_ptr() as _)\n         }"}, {"sha": "305502e7f063b562ac1d298925911ebcc325ce44", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -221,7 +221,7 @@ impl<'a> AllocFnFactory<'a> {\n                 let ident = ident();\n                 args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n                 let arg = self.cx.expr_ident(self.span, ident);\n-                self.cx.expr_cast(self.span, arg, self.ptr_void())\n+                self.cx.expr_cast(self.span, arg, self.ptr_opaque())\n             }\n \n             AllocatorTy::Usize => {\n@@ -276,13 +276,13 @@ impl<'a> AllocFnFactory<'a> {\n         self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n     }\n \n-    fn ptr_void(&self) -> P<Ty> {\n-        let void = self.cx.path(self.span, vec![\n+    fn ptr_opaque(&self) -> P<Ty> {\n+        let opaque = self.cx.path(self.span, vec![\n             self.core,\n             Ident::from_str(\"alloc\"),\n-            Ident::from_str(\"Void\"),\n+            Ident::from_str(\"Opaque\"),\n         ]);\n-        let ty_void = self.cx.ty_path(void);\n-        self.cx.ty_ptr(self.span, ty_void, Mutability::Mutable)\n+        let ty_opaque = self.cx.ty_path(opaque);\n+        self.cx.ty_ptr(self.span, ty_opaque, Mutability::Mutable)\n     }\n }"}, {"sha": "ff578ec42d23088ce2594175b24f3c4aeddce1b8", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -21,7 +21,7 @@\n #[doc(hidden)]\n #[allow(unused_attributes)]\n pub mod __default_lib_allocator {\n-    use super::{System, Layout, GlobalAlloc, Void};\n+    use super::{System, Layout, GlobalAlloc, Opaque};\n     // for symbol names src/librustc/middle/allocator.rs\n     // for signatures src/librustc_allocator/lib.rs\n \n@@ -46,7 +46,7 @@ pub mod __default_lib_allocator {\n     pub unsafe extern fn __rdl_dealloc(ptr: *mut u8,\n                                        size: usize,\n                                        align: usize) {\n-        System.dealloc(ptr as *mut Void, Layout::from_size_align_unchecked(size, align))\n+        System.dealloc(ptr as *mut Opaque, Layout::from_size_align_unchecked(size, align))\n     }\n \n     #[no_mangle]\n@@ -56,7 +56,7 @@ pub mod __default_lib_allocator {\n                                        align: usize,\n                                        new_size: usize) -> *mut u8 {\n         let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-        System.realloc(ptr as *mut Void, old_layout, new_size) as *mut u8\n+        System.realloc(ptr as *mut Opaque, old_layout, new_size) as *mut u8\n     }\n \n     #[no_mangle]"}, {"sha": "93f059076d794ea84074ceb11de91b24e43255f7", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -1183,7 +1183,7 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n         debug_assert!(!oflo, \"should be impossible\");\n \n         unsafe {\n-            Global.dealloc(NonNull::new_unchecked(self.hashes.ptr()).as_void(),\n+            Global.dealloc(NonNull::new_unchecked(self.hashes.ptr()).as_opaque(),\n                            Layout::from_size_align(size, align).unwrap());\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here."}, {"sha": "62fd2ade1ca5c597805d3c0852e0ea556332d8bc", "filename": "src/test/run-make-fulldeps/std-core-cycle/bar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -16,11 +16,11 @@ use std::alloc::*;\n pub struct A;\n \n unsafe impl GlobalAlloc for A {\n-    unsafe fn alloc(&self, _: Layout) -> *mut Void {\n+    unsafe fn alloc(&self, _: Layout) -> *mut Opaque {\n         loop {}\n     }\n \n-    unsafe fn dealloc(&self, _ptr: *mut Void, _: Layout) {\n+    unsafe fn dealloc(&self, _ptr: *mut Opaque, _: Layout) {\n         loop {}\n     }\n }"}, {"sha": "e6a2e22983b25efd4af91bae5c7edea1f785d3e8", "filename": "src/test/run-pass/allocator/auxiliary/custom.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -13,18 +13,18 @@\n #![feature(heap_api, allocator_api)]\n #![crate_type = \"rlib\"]\n \n-use std::heap::{GlobalAlloc, System, Layout, Void};\n+use std::heap::{GlobalAlloc, System, Layout, Opaque};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n pub struct A(pub AtomicUsize);\n \n unsafe impl GlobalAlloc for A {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n         self.0.fetch_add(1, Ordering::SeqCst);\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&self, ptr: *mut Void, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n         self.0.fetch_add(1, Ordering::SeqCst);\n         System.dealloc(ptr, layout)\n     }"}, {"sha": "415d39a593e16b6d0254690459d62a5c84689cfc", "filename": "src/test/run-pass/allocator/custom.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -15,20 +15,20 @@\n \n extern crate helper;\n \n-use std::alloc::{self, Global, Alloc, System, Layout, Void};\n+use std::alloc::{self, Global, Alloc, System, Layout, Opaque};\n use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n \n static HITS: AtomicUsize = ATOMIC_USIZE_INIT;\n \n struct A;\n \n unsafe impl alloc::GlobalAlloc for A {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n         HITS.fetch_add(1, Ordering::SeqCst);\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&self, ptr: *mut Void, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n         HITS.fetch_add(1, Ordering::SeqCst);\n         System.dealloc(ptr, layout)\n     }"}, {"sha": "38cc23c16a9766a39ba4e979c14c55531ce30771", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f607a3872addf380846cae28661a777ec3e3c9a2/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=f607a3872addf380846cae28661a777ec3e3c9a2", "patch": "@@ -64,15 +64,15 @@ unsafe fn test_triangle() -> bool {\n             println!(\"deallocate({:?}, {:?}\", ptr, layout);\n         }\n \n-        Global.dealloc(NonNull::new_unchecked(ptr).as_void(), layout);\n+        Global.dealloc(NonNull::new_unchecked(ptr).as_opaque(), layout);\n     }\n \n     unsafe fn reallocate(ptr: *mut u8, old: Layout, new: Layout) -> *mut u8 {\n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?})\", ptr, old, new);\n         }\n \n-        let ret = Global.realloc(NonNull::new_unchecked(ptr).as_void(), old.clone(), new.size())\n+        let ret = Global.realloc(NonNull::new_unchecked(ptr).as_opaque(), old.clone(), new.size())\n             .unwrap_or_else(|_| Global.oom());\n \n         if PRINT {"}]}