{"sha": "257fa7aa6d03157476f0d6acd9a0b4c28a3877ec", "node_id": "C_kwDOAAsO6NoAKDI1N2ZhN2FhNmQwMzE1NzQ3NmYwZDZhY2Q5YTBiNGMyOGEzODc3ZWM", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-11-24T01:55:14Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-12-01T23:40:53Z"}, "message": "Drop splats for Simd<T, _>\n\nUnfortunately, splatting impls currently break several crates.\nRust needs more time to review possible mitigations, so\ndrop the impls for the `impl Add<T> for Simd<T, _>` pattern, for now.", "tree": {"sha": "52935e1cc3e0def342fe69ce051d08b8938cf6ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52935e1cc3e0def342fe69ce051d08b8938cf6ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec", "html_url": "https://github.com/rust-lang/rust/commit/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6094f22ceb6a697bfcfc3e972170f33badc8f6ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/6094f22ceb6a697bfcfc3e972170f33badc8f6ee", "html_url": "https://github.com/rust-lang/rust/commit/6094f22ceb6a697bfcfc3e972170f33badc8f6ee"}], "stats": {"total": 208, "additions": 11, "deletions": 197}, "files": [{"sha": "43280feebbd67cdd14ed33a08b579881118d3aa2", "filename": "crates/core_simd/examples/nbody.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec/crates%2Fcore_simd%2Fexamples%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec/crates%2Fcore_simd%2Fexamples%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fnbody.rs?ref=257fa7aa6d03157476f0d6acd9a0b4c28a3877ec", "patch": "@@ -97,7 +97,7 @@ mod nbody {\n         let sun = &mut sun[0];\n         for body in rest {\n             let m_ratio = body.mass / SOLAR_MASS;\n-            sun.v -= body.v * m_ratio;\n+            sun.v -= body.v * Simd::splat(m_ratio);\n         }\n     }\n \n@@ -143,14 +143,14 @@ mod nbody {\n         let mut i = 0;\n         for j in 0..N_BODIES {\n             for k in j + 1..N_BODIES {\n-                let f = r[i] * mag[i];\n-                bodies[j].v -= f * bodies[k].mass;\n-                bodies[k].v += f * bodies[j].mass;\n+                let f = r[i] * Simd::splat(mag[i]);\n+                bodies[j].v -= f * Simd::splat(bodies[k].mass);\n+                bodies[k].v += f * Simd::splat(bodies[j].mass);\n                 i += 1\n             }\n         }\n         for body in bodies {\n-            body.x += dt * body.v\n+            body.x += Simd::splat(dt) * body.v\n         }\n     }\n "}, {"sha": "7435b6df9186098a4e1ce5c3b4f8b61ae0a8316b", "filename": "crates/core_simd/src/math.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=257fa7aa6d03157476f0d6acd9a0b4c28a3877ec", "patch": "@@ -17,7 +17,7 @@ macro_rules! impl_uint_arith {\n             /// let max = Simd::splat(MAX);\n             /// let unsat = x + max;\n             /// let sat = x.saturating_add(max);\n-            /// assert_eq!(x - 1, unsat);\n+            /// assert_eq!(unsat, Simd::from_array([1, 0, MAX, MAX - 1]));\n             /// assert_eq!(sat, max);\n             /// ```\n             #[inline]\n@@ -37,7 +37,7 @@ macro_rules! impl_uint_arith {\n             /// let max = Simd::splat(MAX);\n             /// let unsat = x - max;\n             /// let sat = x.saturating_sub(max);\n-            /// assert_eq!(unsat, x + 1);\n+            /// assert_eq!(unsat, Simd::from_array([3, 2, 1, 0]));\n             /// assert_eq!(sat, Simd::splat(0));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n@@ -105,7 +105,7 @@ macro_rules! impl_int_arith {\n             #[inline]\n             pub fn abs(self) -> Self {\n                 const SHR: $ty = <$ty>::BITS as $ty - 1;\n-                let m = self >> SHR;\n+                let m = self >> Simd::splat(SHR);\n                 (self^m) - m\n             }\n \n@@ -128,7 +128,7 @@ macro_rules! impl_int_arith {\n             pub fn saturating_abs(self) -> Self {\n                 // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n                 const SHR: $ty = <$ty>::BITS as $ty - 1;\n-                let m = self >> SHR;\n+                let m = self >> Simd::splat(SHR);\n                 (self^m).saturating_sub(m)\n             }\n "}, {"sha": "3582c57870b9e83f0420642dc67865d6ed08ec8a", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=257fa7aa6d03157476f0d6acd9a0b4c28a3877ec", "patch": "@@ -118,34 +118,6 @@ macro_rules! impl_op {\n                 }\n             }\n         }\n-\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<$scalar> for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                type Output = Self;\n-\n-                #[inline]\n-                fn $trait_fn(self, rhs: $scalar) -> Self::Output {\n-                    core::ops::$trait::$trait_fn(self, Self::splat(rhs))\n-                }\n-            }\n-        }\n-\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<Simd<$scalar, LANES>> for $scalar\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                type Output = Simd<$scalar, LANES>;\n-\n-                #[inline]\n-                fn $trait_fn(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n-                    core::ops::$trait::$trait_fn(Simd::splat(self), rhs)\n-                }\n-            }\n-        }\n     };\n }\n \n@@ -202,43 +174,6 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n             }\n \n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Div<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn div(self, rhs: $scalar) -> Self::Output {\n-                        if rhs == 0 {\n-                            panic!(\"attempt to divide by zero\");\n-                        }\n-                        if <$scalar>::MIN != 0 &&\n-                            self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n-                            rhs == -1 as _ {\n-                                panic!(\"attempt to divide with overflow\");\n-                        }\n-                        let rhs = Self::splat(rhs);\n-                        unsafe { intrinsics::simd_div(self, rhs) }\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Div<Simd<$scalar, LANES>> for $scalar\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Simd<$scalar, LANES>;\n-\n-                    #[inline]\n-                    fn div(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n-                        Simd::splat(self) / rhs\n-                    }\n-                }\n-            }\n-\n             // remainder panics on zero divisor\n             impl_ref_ops! {\n                 impl<const LANES: usize> core::ops::Rem<Self> for Simd<$scalar, LANES>\n@@ -268,43 +203,6 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n             }\n \n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Rem<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn rem(self, rhs: $scalar) -> Self::Output {\n-                        if rhs == 0 {\n-                            panic!(\"attempt to calculate the remainder with a divisor of zero\");\n-                        }\n-                        if <$scalar>::MIN != 0 &&\n-                            self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n-                            rhs == -1 as _ {\n-                                panic!(\"attempt to calculate the remainder with overflow\");\n-                        }\n-                        let rhs = Self::splat(rhs);\n-                        unsafe { intrinsics::simd_rem(self, rhs) }\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Rem<Simd<$scalar, LANES>> for $scalar\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Simd<$scalar, LANES>;\n-\n-                    #[inline]\n-                    fn rem(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n-                        Simd::splat(self) % rhs\n-                    }\n-                }\n-            }\n-\n             // shifts panic on overflow\n             impl_ref_ops! {\n                 impl<const LANES: usize> core::ops::Shl<Self> for Simd<$scalar, LANES>\n@@ -328,24 +226,6 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n             }\n \n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Shl<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn shl(self, rhs: $scalar) -> Self::Output {\n-                        if invalid_shift_rhs(rhs) {\n-                            panic!(\"attempt to shift left with overflow\");\n-                        }\n-                        let rhs = Self::splat(rhs);\n-                        unsafe { intrinsics::simd_shl(self, rhs) }\n-                    }\n-                }\n-            }\n-\n             impl_ref_ops! {\n                 impl<const LANES: usize> core::ops::Shr<Self> for Simd<$scalar, LANES>\n                 where\n@@ -367,24 +247,6 @@ macro_rules! impl_unsigned_int_ops {\n                     }\n                 }\n             }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Shr<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn shr(self, rhs: $scalar) -> Self::Output {\n-                        if invalid_shift_rhs(rhs) {\n-                            panic!(\"attempt to shift with overflow\");\n-                        }\n-                        let rhs = Self::splat(rhs);\n-                        unsafe { intrinsics::simd_shr(self, rhs) }\n-                    }\n-                }\n-            }\n         )*\n     };\n }"}, {"sha": "c668d9a6eaee35785e7eb84b7bc5a01f7d317bc8", "filename": "crates/core_simd/src/vector/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=257fa7aa6d03157476f0d6acd9a0b4c28a3877ec", "patch": "@@ -23,7 +23,7 @@ where\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n-            mem::transmute_copy(&{ x + (addend * mem::size_of::<T>()) })\n+            mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })\n         }\n     }\n }\n@@ -49,7 +49,7 @@ where\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n-            mem::transmute_copy(&{ x + (addend * mem::size_of::<T>()) })\n+            mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })\n         }\n     }\n }"}, {"sha": "43ddde4c55e0162db189c5c4270a31695f69f021", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=257fa7aa6d03157476f0d6acd9a0b4c28a3877ec", "patch": "@@ -38,37 +38,13 @@ macro_rules! impl_binary_op_test {\n                     );\n                 }\n \n-                fn scalar_rhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &<Simd<$scalar, LANES> as core::ops::$trait<$scalar>>::$fn,\n-                        &$scalar_fn,\n-                        &|_, _| true,\n-                    );\n-                }\n-\n-                fn scalar_lhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_lhs_elementwise(\n-                        &<$scalar as core::ops::$trait<Simd<$scalar, LANES>>>::$fn,\n-                        &$scalar_fn,\n-                        &|_, _| true,\n-                    );\n-                }\n-\n                 fn assign<const LANES: usize>() {\n                     test_helpers::test_binary_elementwise(\n                         &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n                         &$scalar_fn,\n                         &|_, _| true,\n                     );\n                 }\n-\n-                fn assign_scalar_rhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n-                        &$scalar_fn,\n-                        &|_, _| true,\n-                    );\n-                }\n             }\n         }\n     };\n@@ -99,37 +75,13 @@ macro_rules! impl_binary_checked_op_test {\n                     );\n                 }\n \n-                fn scalar_rhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &<Simd<$scalar, LANES> as core::ops::$trait<$scalar>>::$fn,\n-                        &$scalar_fn,\n-                        &|x, y| x.iter().all(|x| $check_fn(*x, y)),\n-                    );\n-                }\n-\n-                fn scalar_lhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_lhs_elementwise(\n-                        &<$scalar as core::ops::$trait<Simd<$scalar, LANES>>>::$fn,\n-                        &$scalar_fn,\n-                        &|x, y| y.iter().all(|y| $check_fn(x, *y)),\n-                    );\n-                }\n-\n                 fn assign<const LANES: usize>() {\n                     test_helpers::test_binary_elementwise(\n                         &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n                         &$scalar_fn,\n                         &|x, y| x.iter().zip(y.iter()).all(|(x, y)| $check_fn(*x, *y)),\n                     )\n                 }\n-\n-                fn assign_scalar_rhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n-                        &$scalar_fn,\n-                        &|x, y| x.iter().all(|x| $check_fn(*x, y)),\n-                    )\n-                }\n             }\n         }\n     };"}]}