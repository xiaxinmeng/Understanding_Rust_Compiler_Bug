{"sha": "f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "node_id": "C_kwDOAAsO6NoAKGY5MGQ1N2QwNmViYzdmMjUwYjYwYjljYWI1ODNmMTExZDlhNWZiOWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-17T06:26:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-17T06:26:55Z"}, "message": "Auto merge of #112687 - compiler-errors:simplify-impl-source, r=lcnr\n\nSimplify `ImplSource` candidates a bit\n\nReduce the number of impl source candidates, which will hopefully make our life easier when trying to adapt things like `SelectionContext::select` and `codegen_select_candidate` for the new solver.\n\nr? `@lcnr` but feel free to reassign", "tree": {"sha": "700356c39dce158d2b3c87d9593766137140fb14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/700356c39dce158d2b3c87d9593766137140fb14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "html_url": "https://github.com/rust-lang/rust/commit/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d7d82472617a4a0fea59c7e239c8a48c8ac5c34", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d7d82472617a4a0fea59c7e239c8a48c8ac5c34", "html_url": "https://github.com/rust-lang/rust/commit/1d7d82472617a4a0fea59c7e239c8a48c8ac5c34"}, {"sha": "d97d4ebecc502bcb5eda2cdaa513e0e7922a377e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e", "html_url": "https://github.com/rust-lang/rust/commit/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e"}], "stats": {"total": 570, "additions": 186, "deletions": 384}, "files": [{"sha": "106cf1114749a48d5781023e6ac3ac91de452e43", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "patch": "@@ -781,8 +781,17 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                             );\n                             return;\n                         }\n-                        Ok(Some(ImplSource::Closure(data))) => {\n-                            if !tcx.is_const_fn_raw(data.closure_def_id) {\n+                        // Closure: Fn{Once|Mut}\n+                        Ok(Some(ImplSource::Builtin(_)))\n+                            if poly_trait_pred.self_ty().skip_binder().is_closure()\n+                                && tcx.fn_trait_kind_from_def_id(trait_id).is_some() =>\n+                        {\n+                            let ty::Closure(closure_def_id, substs) =\n+                                *poly_trait_pred.self_ty().no_bound_vars().unwrap().kind()\n+                            else {\n+                                unreachable!()\n+                            };\n+                            if !tcx.is_const_fn_raw(closure_def_id) {\n                                 self.check_op(ops::FnCallNonConst {\n                                     caller,\n                                     callee,"}, {"sha": "a2d23425f3bc254e94ab84f6a4e781c1d64b0ea7", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "patch": "@@ -172,7 +172,7 @@ impl Qualif for NeedsNonConstDrop {\n \n         if !matches!(\n             impl_src,\n-            ImplSource::ConstDestruct(_) | ImplSource::Param(_, ty::BoundConstness::ConstIfConst)\n+            ImplSource::Builtin(_) | ImplSource::Param(_, ty::BoundConstness::ConstIfConst)\n         ) {\n             // If our const destruct candidate is not ConstDestruct or implied by the param env,\n             // then it's bad"}, {"sha": "492b7228488fd6de19196969fcddccc016f0b9e8", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 11, "deletions": 145, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "patch": "@@ -646,97 +646,53 @@ pub enum ImplSource<'tcx, N> {\n     /// ImplSource identifying a particular impl.\n     UserDefined(ImplSourceUserDefinedData<'tcx, N>),\n \n-    /// ImplSource for auto trait implementations.\n-    /// This carries the information and nested obligations with regards\n-    /// to an auto implementation for a trait `Trait`. The nested obligations\n-    /// ensure the trait implementation holds for all the constituent types.\n-    AutoImpl(ImplSourceAutoImplData<N>),\n-\n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter. The `Vec<N>` represents the\n     /// obligations incurred from normalizing the where-clause (if\n     /// any).\n     Param(Vec<N>, ty::BoundConstness),\n \n     /// Virtual calls through an object.\n-    Object(ImplSourceObjectData<'tcx, N>),\n+    Object(ImplSourceObjectData<N>),\n \n     /// Successful resolution for a builtin trait.\n-    Builtin(ImplSourceBuiltinData<N>),\n+    Builtin(Vec<N>),\n \n     /// ImplSource for trait upcasting coercion\n-    TraitUpcasting(ImplSourceTraitUpcastingData<'tcx, N>),\n-\n-    /// ImplSource automatically generated for a closure. The `DefId` is the ID\n-    /// of the closure expression. This is an `ImplSource::UserDefined` in spirit, but the\n-    /// impl is generated by the compiler and does not appear in the source.\n-    Closure(ImplSourceClosureData<'tcx, N>),\n-\n-    /// Same as above, but for a function pointer type with the given signature.\n-    FnPointer(ImplSourceFnPointerData<'tcx, N>),\n-\n-    /// ImplSource automatically generated for a generator.\n-    Generator(ImplSourceGeneratorData<'tcx, N>),\n-\n-    /// ImplSource automatically generated for a generator backing an async future.\n-    Future(ImplSourceFutureData<'tcx, N>),\n+    TraitUpcasting(ImplSourceTraitUpcastingData<N>),\n \n     /// ImplSource for a trait alias.\n     TraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n-\n-    /// ImplSource for a `const Drop` implementation.\n-    ConstDestruct(ImplSourceConstDestructData<N>),\n }\n \n impl<'tcx, N> ImplSource<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {\n             ImplSource::UserDefined(i) => i.nested,\n-            ImplSource::Param(n, _) => n,\n-            ImplSource::Builtin(i) => i.nested,\n-            ImplSource::AutoImpl(d) => d.nested,\n-            ImplSource::Closure(c) => c.nested,\n-            ImplSource::Generator(c) => c.nested,\n-            ImplSource::Future(c) => c.nested,\n+            ImplSource::Param(n, _) | ImplSource::Builtin(n) => n,\n             ImplSource::Object(d) => d.nested,\n-            ImplSource::FnPointer(d) => d.nested,\n             ImplSource::TraitAlias(d) => d.nested,\n             ImplSource::TraitUpcasting(d) => d.nested,\n-            ImplSource::ConstDestruct(i) => i.nested,\n         }\n     }\n \n     pub fn borrow_nested_obligations(&self) -> &[N] {\n         match self {\n             ImplSource::UserDefined(i) => &i.nested,\n-            ImplSource::Param(n, _) => n,\n-            ImplSource::Builtin(i) => &i.nested,\n-            ImplSource::AutoImpl(d) => &d.nested,\n-            ImplSource::Closure(c) => &c.nested,\n-            ImplSource::Generator(c) => &c.nested,\n-            ImplSource::Future(c) => &c.nested,\n+            ImplSource::Param(n, _) | ImplSource::Builtin(n) => &n,\n             ImplSource::Object(d) => &d.nested,\n-            ImplSource::FnPointer(d) => &d.nested,\n             ImplSource::TraitAlias(d) => &d.nested,\n             ImplSource::TraitUpcasting(d) => &d.nested,\n-            ImplSource::ConstDestruct(i) => &i.nested,\n         }\n     }\n \n     pub fn borrow_nested_obligations_mut(&mut self) -> &mut [N] {\n         match self {\n             ImplSource::UserDefined(i) => &mut i.nested,\n-            ImplSource::Param(n, _) => n,\n-            ImplSource::Builtin(i) => &mut i.nested,\n-            ImplSource::AutoImpl(d) => &mut d.nested,\n-            ImplSource::Closure(c) => &mut c.nested,\n-            ImplSource::Generator(c) => &mut c.nested,\n-            ImplSource::Future(c) => &mut c.nested,\n+            ImplSource::Param(n, _) | ImplSource::Builtin(n) => n,\n             ImplSource::Object(d) => &mut d.nested,\n-            ImplSource::FnPointer(d) => &mut d.nested,\n             ImplSource::TraitAlias(d) => &mut d.nested,\n             ImplSource::TraitUpcasting(d) => &mut d.nested,\n-            ImplSource::ConstDestruct(i) => &mut i.nested,\n         }\n     }\n \n@@ -751,54 +707,23 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n                 nested: i.nested.into_iter().map(f).collect(),\n             }),\n             ImplSource::Param(n, ct) => ImplSource::Param(n.into_iter().map(f).collect(), ct),\n-            ImplSource::Builtin(i) => ImplSource::Builtin(ImplSourceBuiltinData {\n-                nested: i.nested.into_iter().map(f).collect(),\n-            }),\n+            ImplSource::Builtin(n) => ImplSource::Builtin(n.into_iter().map(f).collect()),\n             ImplSource::Object(o) => ImplSource::Object(ImplSourceObjectData {\n-                upcast_trait_ref: o.upcast_trait_ref,\n+                upcast_trait_def_id: o.upcast_trait_def_id,\n                 vtable_base: o.vtable_base,\n                 nested: o.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSource::AutoImpl(d) => ImplSource::AutoImpl(ImplSourceAutoImplData {\n-                trait_def_id: d.trait_def_id,\n-                nested: d.nested.into_iter().map(f).collect(),\n-            }),\n-            ImplSource::Closure(c) => ImplSource::Closure(ImplSourceClosureData {\n-                closure_def_id: c.closure_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            ImplSource::Generator(c) => ImplSource::Generator(ImplSourceGeneratorData {\n-                generator_def_id: c.generator_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            ImplSource::Future(c) => ImplSource::Future(ImplSourceFutureData {\n-                generator_def_id: c.generator_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            ImplSource::FnPointer(p) => ImplSource::FnPointer(ImplSourceFnPointerData {\n-                fn_ty: p.fn_ty,\n-                nested: p.nested.into_iter().map(f).collect(),\n-            }),\n             ImplSource::TraitAlias(d) => ImplSource::TraitAlias(ImplSourceTraitAliasData {\n                 alias_def_id: d.alias_def_id,\n                 substs: d.substs,\n                 nested: d.nested.into_iter().map(f).collect(),\n             }),\n             ImplSource::TraitUpcasting(d) => {\n                 ImplSource::TraitUpcasting(ImplSourceTraitUpcastingData {\n-                    upcast_trait_ref: d.upcast_trait_ref,\n                     vtable_vptr_slot: d.vtable_vptr_slot,\n                     nested: d.nested.into_iter().map(f).collect(),\n                 })\n             }\n-            ImplSource::ConstDestruct(i) => {\n-                ImplSource::ConstDestruct(ImplSourceConstDestructData {\n-                    nested: i.nested.into_iter().map(f).collect(),\n-                })\n-            }\n         }\n     }\n }\n@@ -823,47 +748,7 @@ pub struct ImplSourceUserDefinedData<'tcx, N> {\n \n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n #[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceGeneratorData<'tcx, N> {\n-    pub generator_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the generator\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceFutureData<'tcx, N> {\n-    pub generator_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the generator\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceClosureData<'tcx, N> {\n-    pub closure_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the closure\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceAutoImplData<N> {\n-    pub trait_def_id: DefId,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceTraitUpcastingData<'tcx, N> {\n-    /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n-    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-\n+pub struct ImplSourceTraitUpcastingData<N> {\n     /// The vtable is formed by concatenating together the method lists of\n     /// the base object trait and all supertraits, pointers to supertrait vtable will\n     /// be provided when necessary; this is the position of `upcast_trait_ref`'s vtable\n@@ -873,17 +758,11 @@ pub struct ImplSourceTraitUpcastingData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceBuiltinData<N> {\n-    pub nested: Vec<N>,\n-}\n-\n #[derive(PartialEq, Eq, Clone, TyEncodable, TyDecodable, HashStable, Lift)]\n #[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceObjectData<'tcx, N> {\n+pub struct ImplSourceObjectData<N> {\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n-    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n+    pub upcast_trait_def_id: DefId,\n \n     /// The vtable is formed by concatenating together the method lists of\n     /// the base object trait and all supertraits, pointers to supertrait vtable will\n@@ -894,19 +773,6 @@ pub struct ImplSourceObjectData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceFnPointerData<'tcx, N> {\n-    pub fn_ty: Ty<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceConstDestructData<N> {\n-    pub nested: Vec<N>,\n-}\n-\n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct ImplSourceTraitAliasData<'tcx, N> {"}, {"sha": "ac02d6ed62f2e03c745a139c3672193b0053fb10", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 76, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "patch": "@@ -9,29 +9,17 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSource<'tcx, N> {\n         match *self {\n             super::ImplSource::UserDefined(ref v) => write!(f, \"{:?}\", v),\n \n-            super::ImplSource::AutoImpl(ref t) => write!(f, \"{:?}\", t),\n-\n-            super::ImplSource::Closure(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::ImplSource::Generator(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::ImplSource::Future(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::ImplSource::FnPointer(ref d) => write!(f, \"({:?})\", d),\n+            super::ImplSource::Builtin(ref d) => write!(f, \"{:?}\", d),\n \n             super::ImplSource::Object(ref d) => write!(f, \"{:?}\", d),\n \n             super::ImplSource::Param(ref n, ct) => {\n                 write!(f, \"ImplSourceParamData({:?}, {:?})\", n, ct)\n             }\n \n-            super::ImplSource::Builtin(ref d) => write!(f, \"{:?}\", d),\n-\n             super::ImplSource::TraitAlias(ref d) => write!(f, \"{:?}\", d),\n \n             super::ImplSource::TraitUpcasting(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::ImplSource::ConstDestruct(ref d) => write!(f, \"{:?}\", d),\n         }\n     }\n }\n@@ -46,78 +34,26 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceUserDefinedData<'tcx,\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceGeneratorData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"ImplSourceGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.generator_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceFutureData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"ImplSourceFutureData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.generator_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceClosureData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"ImplSourceClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.closure_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceBuiltinData<N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ImplSourceBuiltinData(nested={:?})\", self.nested)\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitUpcastingData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"ImplSourceTraitUpcastingData(upcast={:?}, vtable_vptr_slot={:?}, nested={:?})\",\n-            self.upcast_trait_ref, self.vtable_vptr_slot, self.nested\n-        )\n-    }\n-}\n-\n-impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceAutoImplData<N> {\n+impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitUpcastingData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"ImplSourceAutoImplData(trait_def_id={:?}, nested={:?})\",\n-            self.trait_def_id, self.nested\n+            \"ImplSourceTraitUpcastingData(vtable_vptr_slot={:?}, nested={:?})\",\n+            self.vtable_vptr_slot, self.nested\n         )\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceObjectData<'tcx, N> {\n+impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceObjectData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n             \"ImplSourceObjectData(upcast={:?}, vtable_base={}, nested={:?})\",\n-            self.upcast_trait_ref, self.vtable_base, self.nested\n+            self.upcast_trait_def_id, self.vtable_base, self.nested\n         )\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceFnPointerData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ImplSourceFnPointerData(fn_ty={:?}, nested={:?})\", self.fn_ty, self.nested)\n-    }\n-}\n-\n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n@@ -127,9 +63,3 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx,\n         )\n     }\n }\n-\n-impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceConstDestructData<N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ImplSourceConstDestructData(nested={:?})\", self.nested)\n-    }\n-}"}, {"sha": "8399fbfc5be624ab411cdb2bfb8e9180cfc2fb01", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "patch": "@@ -3,17 +3,14 @@\n use super::specialization_graph;\n use super::translate_substs;\n use super::util;\n+use super::ImplSourceUserDefinedData;\n use super::MismatchedProjectionTypes;\n use super::Obligation;\n use super::ObligationCause;\n use super::PredicateObligation;\n use super::Selection;\n use super::SelectionContext;\n use super::SelectionError;\n-use super::{\n-    ImplSourceClosureData, ImplSourceFnPointerData, ImplSourceFutureData, ImplSourceGeneratorData,\n-    ImplSourceUserDefinedData,\n-};\n use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n \n use crate::errors::InherentProjectionNormalizationOverflow;\n@@ -30,7 +27,6 @@ use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::at::At;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n use rustc_infer::infer::DefineOpaqueTypes;\n-use rustc_infer::traits::ImplSourceBuiltinData;\n use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n@@ -1721,11 +1717,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n         };\n \n         let eligible = match &impl_source {\n-            super::ImplSource::Closure(_)\n-            | super::ImplSource::Generator(_)\n-            | super::ImplSource::Future(_)\n-            | super::ImplSource::FnPointer(_)\n-            | super::ImplSource::TraitAlias(_) => true,\n+            super::ImplSource::TraitAlias(_) => true,\n             super::ImplSource::UserDefined(impl_data) => {\n                 // We have to be careful when projecting out of an\n                 // impl because of specialization. If we are not in\n@@ -1783,7 +1775,11 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 let self_ty = selcx.infcx.shallow_resolve(obligation.predicate.self_ty());\n \n                 let lang_items = selcx.tcx().lang_items();\n-                if lang_items.discriminant_kind_trait() == Some(poly_trait_ref.def_id()) {\n+                if [lang_items.gen_trait(), lang_items.future_trait()].contains(&Some(poly_trait_ref.def_id()))\n+                    || selcx.tcx().fn_trait_kind_from_def_id(poly_trait_ref.def_id()).is_some()\n+                {\n+                    true\n+                } else if lang_items.discriminant_kind_trait() == Some(poly_trait_ref.def_id()) {\n                     match self_ty.kind() {\n                         ty::Bool\n                         | ty::Char\n@@ -1930,9 +1926,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // why we special case object types.\n                 false\n             }\n-            super::ImplSource::AutoImpl(..)\n-            | super::ImplSource::TraitUpcasting(_)\n-            | super::ImplSource::ConstDestruct(_) => {\n+            | super::ImplSource::TraitUpcasting(_) => {\n                 // These traits have no associated types.\n                 selcx.tcx().sess.delay_span_bug(\n                     obligation.cause.span,\n@@ -1996,17 +1990,27 @@ fn confirm_select_candidate<'cx, 'tcx>(\n ) -> Progress<'tcx> {\n     match impl_source {\n         super::ImplSource::UserDefined(data) => confirm_impl_candidate(selcx, obligation, data),\n-        super::ImplSource::Generator(data) => confirm_generator_candidate(selcx, obligation, data),\n-        super::ImplSource::Future(data) => confirm_future_candidate(selcx, obligation, data),\n-        super::ImplSource::Closure(data) => confirm_closure_candidate(selcx, obligation, data),\n-        super::ImplSource::FnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n-        super::ImplSource::Builtin(data) => confirm_builtin_candidate(selcx, obligation, data),\n+        super::ImplSource::Builtin(data) => {\n+            let trait_def_id = obligation.predicate.trait_def_id(selcx.tcx());\n+            let lang_items = selcx.tcx().lang_items();\n+            if lang_items.gen_trait() == Some(trait_def_id) {\n+                confirm_generator_candidate(selcx, obligation, data)\n+            } else if lang_items.future_trait() == Some(trait_def_id) {\n+                confirm_future_candidate(selcx, obligation, data)\n+            } else if selcx.tcx().fn_trait_kind_from_def_id(trait_def_id).is_some() {\n+                if obligation.predicate.self_ty().is_closure() {\n+                    confirm_closure_candidate(selcx, obligation, data)\n+                } else {\n+                    confirm_fn_pointer_candidate(selcx, obligation, data)\n+                }\n+            } else {\n+                confirm_builtin_candidate(selcx, obligation, data)\n+            }\n+        }\n         super::ImplSource::Object(_)\n-        | super::ImplSource::AutoImpl(..)\n         | super::ImplSource::Param(..)\n         | super::ImplSource::TraitUpcasting(_)\n-        | super::ImplSource::TraitAlias(..)\n-        | super::ImplSource::ConstDestruct(_) => {\n+        | super::ImplSource::TraitAlias(..) => {\n             // we don't create Select candidates with this kind of resolution\n             span_bug!(\n                 obligation.cause.span,\n@@ -2020,9 +2024,14 @@ fn confirm_select_candidate<'cx, 'tcx>(\n fn confirm_generator_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    impl_source: ImplSourceGeneratorData<'tcx, PredicateObligation<'tcx>>,\n+    nested: Vec<PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let gen_sig = impl_source.substs.as_generator().poly_sig();\n+    let ty::Generator(_, substs, _) =\n+        selcx.infcx.shallow_resolve(obligation.predicate.self_ty()).kind()\n+    else {\n+        unreachable!()\n+    };\n+    let gen_sig = substs.as_generator().poly_sig();\n     let Normalized { value: gen_sig, obligations } = normalize_with_depth(\n         selcx,\n         obligation.param_env,\n@@ -2060,16 +2069,21 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n     });\n \n     confirm_param_env_candidate(selcx, obligation, predicate, false)\n-        .with_addl_obligations(impl_source.nested)\n+        .with_addl_obligations(nested)\n         .with_addl_obligations(obligations)\n }\n \n fn confirm_future_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    impl_source: ImplSourceFutureData<'tcx, PredicateObligation<'tcx>>,\n+    nested: Vec<PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let gen_sig = impl_source.substs.as_generator().poly_sig();\n+    let ty::Generator(_, substs, _) =\n+        selcx.infcx.shallow_resolve(obligation.predicate.self_ty()).kind()\n+    else {\n+        unreachable!()\n+    };\n+    let gen_sig = substs.as_generator().poly_sig();\n     let Normalized { value: gen_sig, obligations } = normalize_with_depth(\n         selcx,\n         obligation.param_env,\n@@ -2099,14 +2113,14 @@ fn confirm_future_candidate<'cx, 'tcx>(\n     });\n \n     confirm_param_env_candidate(selcx, obligation, predicate, false)\n-        .with_addl_obligations(impl_source.nested)\n+        .with_addl_obligations(nested)\n         .with_addl_obligations(obligations)\n }\n \n fn confirm_builtin_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    data: ImplSourceBuiltinData<PredicateObligation<'tcx>>,\n+    data: Vec<PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n     let self_ty = obligation.predicate.self_ty();\n@@ -2154,15 +2168,15 @@ fn confirm_builtin_candidate<'cx, 'tcx>(\n \n     confirm_param_env_candidate(selcx, obligation, ty::Binder::dummy(predicate), false)\n         .with_addl_obligations(obligations)\n-        .with_addl_obligations(data.nested)\n+        .with_addl_obligations(data)\n }\n \n fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    fn_pointer_impl_source: ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>,\n+    nested: Vec<PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let fn_type = selcx.infcx.shallow_resolve(fn_pointer_impl_source.fn_ty);\n+    let fn_type = selcx.infcx.shallow_resolve(obligation.predicate.self_ty());\n     let sig = fn_type.fn_sig(selcx.tcx());\n     let Normalized { value: sig, obligations } = normalize_with_depth(\n         selcx,\n@@ -2173,16 +2187,21 @@ fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     );\n \n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n-        .with_addl_obligations(fn_pointer_impl_source.nested)\n+        .with_addl_obligations(nested)\n         .with_addl_obligations(obligations)\n }\n \n fn confirm_closure_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    impl_source: ImplSourceClosureData<'tcx, PredicateObligation<'tcx>>,\n+    nested: Vec<PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let closure_sig = impl_source.substs.as_closure().sig();\n+    let ty::Closure(_, substs) =\n+        selcx.infcx.shallow_resolve(obligation.predicate.self_ty()).kind()\n+    else {\n+        unreachable!()\n+    };\n+    let closure_sig = substs.as_closure().sig();\n     let Normalized { value: closure_sig, obligations } = normalize_with_depth(\n         selcx,\n         obligation.param_env,\n@@ -2194,7 +2213,7 @@ fn confirm_closure_candidate<'cx, 'tcx>(\n     debug!(?obligation, ?closure_sig, ?obligations, \"confirm_closure_candidate\");\n \n     confirm_callable_candidate(selcx, obligation, closure_sig, util::TupleArgumentsFlag::No)\n-        .with_addl_obligations(impl_source.nested)\n+        .with_addl_obligations(nested)\n         .with_addl_obligations(obligations)\n }\n "}, {"sha": "3c356978d5ca80931efbf52b4a0bb68f5ca538a8", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "patch": "@@ -27,11 +27,9 @@ use crate::traits::vtable::{\n };\n use crate::traits::{\n     BuiltinDerivedObligation, ImplDerivedObligation, ImplDerivedObligationCause, ImplSource,\n-    ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n-    ImplSourceConstDestructData, ImplSourceFnPointerData, ImplSourceFutureData,\n-    ImplSourceGeneratorData, ImplSourceObjectData, ImplSourceTraitAliasData,\n-    ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized, Obligation,\n-    ObligationCause, OutputTypeParameterMismatch, PredicateObligation, Selection, SelectionError,\n+    ImplSourceObjectData, ImplSourceTraitAliasData, ImplSourceTraitUpcastingData,\n+    ImplSourceUserDefinedData, Normalized, Obligation, ObligationCause,\n+    OutputTypeParameterMismatch, PredicateObligation, Selection, SelectionError,\n     TraitNotObjectSafe, TraitObligation, Unimplemented,\n };\n \n@@ -72,7 +70,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             AutoImplCandidate => {\n                 let data = self.confirm_auto_impl_candidate(obligation);\n-                ImplSource::AutoImpl(data)\n+                ImplSource::Builtin(data)\n             }\n \n             ProjectionCandidate(idx, constness) => {\n@@ -87,22 +85,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ClosureCandidate { .. } => {\n                 let vtable_closure = self.confirm_closure_candidate(obligation)?;\n-                ImplSource::Closure(vtable_closure)\n+                ImplSource::Builtin(vtable_closure)\n             }\n \n             GeneratorCandidate => {\n                 let vtable_generator = self.confirm_generator_candidate(obligation)?;\n-                ImplSource::Generator(vtable_generator)\n+                ImplSource::Builtin(vtable_generator)\n             }\n \n             FutureCandidate => {\n                 let vtable_future = self.confirm_future_candidate(obligation)?;\n-                ImplSource::Future(vtable_future)\n+                ImplSource::Builtin(vtable_future)\n             }\n \n             FnPointerCandidate { is_const } => {\n                 let data = self.confirm_fn_pointer_candidate(obligation, is_const)?;\n-                ImplSource::FnPointer(data)\n+                ImplSource::Builtin(data)\n             }\n \n             TraitAliasCandidate => {\n@@ -114,7 +112,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // This indicates something like `Trait + Send: Send`. In this case, we know that\n                 // this holds because that's what the object type is telling us, and there's really\n                 // no additional obligations to prove and no types in particular to unify, etc.\n-                ImplSource::Param(Vec::new(), ty::BoundConstness::NotConst)\n+                ImplSource::Builtin(Vec::new())\n             }\n \n             BuiltinUnsizeCandidate => {\n@@ -129,7 +127,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ConstDestructCandidate(def_id) => {\n                 let data = self.confirm_const_destruct_candidate(obligation, def_id)?;\n-                ImplSource::ConstDestruct(data)\n+                ImplSource::Builtin(data)\n             }\n         };\n \n@@ -244,7 +242,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         has_nested: bool,\n-    ) -> ImplSourceBuiltinData<PredicateObligation<'tcx>> {\n+    ) -> Vec<PredicateObligation<'tcx>> {\n         debug!(?obligation, ?has_nested, \"confirm_builtin_candidate\");\n \n         let lang_items = self.tcx().lang_items();\n@@ -277,14 +275,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?obligations);\n \n-        ImplSourceBuiltinData { nested: obligations }\n+        obligations\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn confirm_transmutability_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<ImplSourceBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         use rustc_transmute::{Answer, Condition};\n         #[instrument(level = \"debug\", skip(tcx, obligation, predicate))]\n         fn flatten_answer_tree<'tcx>(\n@@ -369,7 +367,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         debug!(?fully_flattened);\n-        Ok(ImplSourceBuiltinData { nested: fully_flattened })\n+        Ok(fully_flattened)\n     }\n \n     /// This handles the case where an `auto trait Foo` impl is being used.\n@@ -380,7 +378,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_auto_impl_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> ImplSourceAutoImplData<PredicateObligation<'tcx>> {\n+    ) -> Vec<PredicateObligation<'tcx>> {\n         debug!(?obligation, \"confirm_auto_impl_candidate\");\n \n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.self_ty());\n@@ -394,7 +392,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         trait_def_id: DefId,\n         nested: ty::Binder<'tcx, Vec<Ty<'tcx>>>,\n-    ) -> ImplSourceAutoImplData<PredicateObligation<'tcx>> {\n+    ) -> Vec<PredicateObligation<'tcx>> {\n         debug!(?nested, \"vtable_auto_impl\");\n         ensure_sufficient_stack(|| {\n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n@@ -424,7 +422,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             debug!(?obligations, \"vtable_auto_impl\");\n \n-            ImplSourceAutoImplData { trait_def_id, nested: obligations }\n+            obligations\n         })\n     }\n \n@@ -487,7 +485,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         index: usize,\n-    ) -> Result<ImplSourceObjectData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+    ) -> Result<ImplSourceObjectData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let tcx = self.tcx();\n         debug!(?obligation, ?index, \"confirm_object_candidate\");\n \n@@ -654,15 +652,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             (unnormalized_upcast_trait_ref, ty::Binder::dummy(object_trait_ref)),\n         );\n \n-        Ok(ImplSourceObjectData { upcast_trait_ref, vtable_base, nested })\n+        Ok(ImplSourceObjectData {\n+            upcast_trait_def_id: upcast_trait_ref.def_id(),\n+            vtable_base,\n+            nested,\n+        })\n     }\n \n     fn confirm_fn_pointer_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         is_const: bool,\n-    ) -> Result<ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>>\n-    {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         debug!(?obligation, \"confirm_fn_pointer_candidate\");\n \n         let tcx = self.tcx();\n@@ -714,7 +715,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let tr = ty::TraitRef::from_lang_item(self.tcx(), LangItem::Sized, cause.span, [output_ty]);\n         nested.push(Obligation::new(self.infcx.tcx, cause, obligation.param_env, tr));\n \n-        Ok(ImplSourceFnPointerData { fn_ty: self_ty, nested })\n+        Ok(nested)\n     }\n \n     fn confirm_trait_alias_candidate(\n@@ -746,8 +747,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_generator_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<ImplSourceGeneratorData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>>\n-    {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n@@ -780,13 +780,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let nested = self.confirm_poly_trait_refs(obligation, trait_ref)?;\n         debug!(?trait_ref, ?nested, \"generator candidate obligations\");\n \n-        Ok(ImplSourceGeneratorData { generator_def_id, substs, nested })\n+        Ok(nested)\n     }\n \n     fn confirm_future_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<ImplSourceFutureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n@@ -810,14 +810,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let nested = self.confirm_poly_trait_refs(obligation, trait_ref)?;\n         debug!(?trait_ref, ?nested, \"future candidate obligations\");\n \n-        Ok(ImplSourceFutureData { generator_def_id, substs, nested })\n+        Ok(nested)\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn confirm_closure_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<ImplSourceClosureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let kind = self\n             .tcx()\n             .fn_trait_kind_from_def_id(obligation.predicate.def_id())\n@@ -844,7 +844,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ));\n         }\n \n-        Ok(ImplSourceClosureData { closure_def_id, substs, nested })\n+        Ok(nested)\n     }\n \n     /// In the case of closure types and fn pointers,\n@@ -912,8 +912,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         idx: usize,\n-    ) -> Result<ImplSourceTraitUpcastingData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>>\n-    {\n+    ) -> Result<ImplSourceTraitUpcastingData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let tcx = self.tcx();\n \n         // `assemble_candidates_for_unsizing` should ensure there are no late-bound\n@@ -1010,13 +1009,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let vtable_vptr_slot =\n             prepare_vtable_segments(tcx, source_trait_ref, vtable_segment_callback).unwrap();\n \n-        Ok(ImplSourceTraitUpcastingData { upcast_trait_ref, vtable_vptr_slot, nested })\n+        Ok(ImplSourceTraitUpcastingData { vtable_vptr_slot, nested })\n     }\n \n     fn confirm_builtin_unsize_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<ImplSourceBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let tcx = self.tcx();\n \n         // `assemble_candidates_for_unsizing` should ensure there are no late-bound\n@@ -1217,17 +1216,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => bug!(\"source: {source}, target: {target}\"),\n         };\n \n-        Ok(ImplSourceBuiltinData { nested })\n+        Ok(nested)\n     }\n \n     fn confirm_const_destruct_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         impl_def_id: Option<DefId>,\n-    ) -> Result<ImplSourceConstDestructData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         // `~const Destruct` in a non-const environment is always trivially true, since our type is `Drop`\n         if !obligation.is_const() {\n-            return Ok(ImplSourceConstDestructData { nested: vec![] });\n+            return Ok(vec![]);\n         }\n \n         let drop_trait = self.tcx().require_lang_item(LangItem::Drop, None);\n@@ -1381,6 +1380,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         }\n \n-        Ok(ImplSourceConstDestructData { nested })\n+        Ok(nested)\n     }\n }"}, {"sha": "906c357e8ca7ed95ed097f00f168552a6f66405f", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "patch": "@@ -243,12 +243,12 @@ pub fn upcast_choices<'tcx>(\n /// `object.upcast_trait_ref`) within the vtable for `object`.\n pub fn get_vtable_index_of_object_method<'tcx, N>(\n     tcx: TyCtxt<'tcx>,\n-    object: &super::ImplSourceObjectData<'tcx, N>,\n+    object: &super::ImplSourceObjectData<N>,\n     method_def_id: DefId,\n ) -> Option<usize> {\n     // Count number of methods preceding the one we are selecting and\n     // add them to the total offset.\n-    tcx.own_existential_vtable_entries(object.upcast_trait_ref.def_id())\n+    tcx.own_existential_vtable_entries(object.upcast_trait_def_id)\n         .iter()\n         .copied()\n         .position(|def_id| def_id == method_def_id)"}, {"sha": "45b1075b6023af5529037b591f11ac20c9dba48f", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 62, "deletions": 83, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "patch": "@@ -177,85 +177,6 @@ fn resolve_associated_item<'tcx>(\n \n             Some(ty::Instance::new(leaf_def.item.def_id, substs))\n         }\n-        traits::ImplSource::Generator(generator_data) => {\n-            if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::resume {\n-                // For compiler developers who'd like to add new items to `Generator`,\n-                // you either need to generate a shim body, or perhaps return\n-                // `InstanceDef::Item` pointing to a trait default method body if\n-                // it is given a default implementation by the trait.\n-                span_bug!(\n-                    tcx.def_span(generator_data.generator_def_id),\n-                    \"no definition for `{trait_ref}::{}` for built-in generator type\",\n-                    tcx.item_name(trait_item_id)\n-                )\n-            }\n-            Some(Instance {\n-                def: ty::InstanceDef::Item(generator_data.generator_def_id),\n-                substs: generator_data.substs,\n-            })\n-        }\n-        traits::ImplSource::Future(future_data) => {\n-            if Some(trait_item_id) == tcx.lang_items().future_poll_fn() {\n-                // `Future::poll` is generated by the compiler.\n-                Some(Instance {\n-                    def: ty::InstanceDef::Item(future_data.generator_def_id),\n-                    substs: future_data.substs,\n-                })\n-            } else {\n-                // All other methods are default methods of the `Future` trait.\n-                // (this assumes that `ImplSource::Future` is only used for methods on `Future`)\n-                debug_assert!(tcx.defaultness(trait_item_id).has_value());\n-                Some(Instance::new(trait_item_id, rcvr_substs))\n-            }\n-        }\n-        traits::ImplSource::Closure(closure_data) => {\n-            if cfg!(debug_assertions)\n-                && ![sym::call, sym::call_mut, sym::call_once]\n-                    .contains(&tcx.item_name(trait_item_id))\n-            {\n-                // For compiler developers who'd like to add new items to `Fn`/`FnMut`/`FnOnce`,\n-                // you either need to generate a shim body, or perhaps return\n-                // `InstanceDef::Item` pointing to a trait default method body if\n-                // it is given a default implementation by the trait.\n-                span_bug!(\n-                    tcx.def_span(closure_data.closure_def_id),\n-                    \"no definition for `{trait_ref}::{}` for built-in closure type\",\n-                    tcx.item_name(trait_item_id)\n-                )\n-            }\n-            let trait_closure_kind = tcx.fn_trait_kind_from_def_id(trait_id).unwrap();\n-            Instance::resolve_closure(\n-                tcx,\n-                closure_data.closure_def_id,\n-                closure_data.substs,\n-                trait_closure_kind,\n-            )\n-        }\n-        traits::ImplSource::FnPointer(ref data) => match data.fn_ty.kind() {\n-            ty::FnDef(..) | ty::FnPtr(..) => {\n-                if cfg!(debug_assertions)\n-                    && ![sym::call, sym::call_mut, sym::call_once]\n-                        .contains(&tcx.item_name(trait_item_id))\n-                {\n-                    // For compiler developers who'd like to add new items to `Fn`/`FnMut`/`FnOnce`,\n-                    // you either need to generate a shim body, or perhaps return\n-                    // `InstanceDef::Item` pointing to a trait default method body if\n-                    // it is given a default implementation by the trait.\n-                    bug!(\n-                        \"no definition for `{trait_ref}::{}` for built-in fn type\",\n-                        tcx.item_name(trait_item_id)\n-                    )\n-                }\n-                Some(Instance {\n-                    def: ty::InstanceDef::FnPtrShim(trait_item_id, data.fn_ty),\n-                    substs: rcvr_substs,\n-                })\n-            }\n-            _ => bug!(\n-                \"no built-in definition for `{trait_ref}::{}` for non-fn type\",\n-                tcx.item_name(trait_item_id)\n-            ),\n-        },\n         traits::ImplSource::Object(ref data) => {\n             traits::get_vtable_index_of_object_method(tcx, data, trait_item_id).map(|index| {\n                 Instance {\n@@ -308,15 +229,73 @@ fn resolve_associated_item<'tcx>(\n                         span: tcx.def_span(trait_item_id),\n                     })\n                 }\n+            } else if Some(trait_ref.def_id) == lang_items.future_trait() {\n+                let ty::Generator(generator_def_id, substs, _) = *rcvr_substs.type_at(0).kind() else {\n+                    bug!()\n+                };\n+                if Some(trait_item_id) == tcx.lang_items().future_poll_fn() {\n+                    // `Future::poll` is generated by the compiler.\n+                    Some(Instance { def: ty::InstanceDef::Item(generator_def_id), substs: substs })\n+                } else {\n+                    // All other methods are default methods of the `Future` trait.\n+                    // (this assumes that `ImplSource::Builtin` is only used for methods on `Future`)\n+                    debug_assert!(tcx.defaultness(trait_item_id).has_value());\n+                    Some(Instance::new(trait_item_id, rcvr_substs))\n+                }\n+            } else if Some(trait_ref.def_id) == lang_items.gen_trait() {\n+                let ty::Generator(generator_def_id, substs, _) = *rcvr_substs.type_at(0).kind() else {\n+                    bug!()\n+                };\n+                if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::resume {\n+                    // For compiler developers who'd like to add new items to `Generator`,\n+                    // you either need to generate a shim body, or perhaps return\n+                    // `InstanceDef::Item` pointing to a trait default method body if\n+                    // it is given a default implementation by the trait.\n+                    span_bug!(\n+                        tcx.def_span(generator_def_id),\n+                        \"no definition for `{trait_ref}::{}` for built-in generator type\",\n+                        tcx.item_name(trait_item_id)\n+                    )\n+                }\n+                Some(Instance { def: ty::InstanceDef::Item(generator_def_id), substs })\n+            } else if tcx.fn_trait_kind_from_def_id(trait_ref.def_id).is_some() {\n+                // FIXME: This doesn't check for malformed libcore that defines, e.g.,\n+                // `trait Fn { fn call_once(&self) { .. } }`. This is mostly for extension\n+                // methods.\n+                if cfg!(debug_assertions)\n+                    && ![sym::call, sym::call_mut, sym::call_once]\n+                        .contains(&tcx.item_name(trait_item_id))\n+                {\n+                    // For compiler developers who'd like to add new items to `Fn`/`FnMut`/`FnOnce`,\n+                    // you either need to generate a shim body, or perhaps return\n+                    // `InstanceDef::Item` pointing to a trait default method body if\n+                    // it is given a default implementation by the trait.\n+                    bug!(\n+                        \"no definition for `{trait_ref}::{}` for built-in callable type\",\n+                        tcx.item_name(trait_item_id)\n+                    )\n+                }\n+                match *rcvr_substs.type_at(0).kind() {\n+                    ty::Closure(closure_def_id, substs) => {\n+                        let trait_closure_kind = tcx.fn_trait_kind_from_def_id(trait_id).unwrap();\n+                        Instance::resolve_closure(tcx, closure_def_id, substs, trait_closure_kind)\n+                    }\n+                    ty::FnDef(..) | ty::FnPtr(..) => Some(Instance {\n+                        def: ty::InstanceDef::FnPtrShim(trait_item_id, rcvr_substs.type_at(0)),\n+                        substs: rcvr_substs,\n+                    }),\n+                    _ => bug!(\n+                        \"no built-in definition for `{trait_ref}::{}` for non-fn type\",\n+                        tcx.item_name(trait_item_id)\n+                    ),\n+                }\n             } else {\n                 None\n             }\n         }\n-        traits::ImplSource::AutoImpl(..)\n-        | traits::ImplSource::Param(..)\n+        traits::ImplSource::Param(..)\n         | traits::ImplSource::TraitAlias(..)\n-        | traits::ImplSource::TraitUpcasting(_)\n-        | traits::ImplSource::ConstDestruct(_) => None,\n+        | traits::ImplSource::TraitUpcasting(_) => None,\n     })\n }\n "}]}