{"sha": "58dc448f8c29d0262f2cde76a9d21343921b23fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZGM0NDhmOGMyOWQwMjYyZjJjZGU3NmE5ZDIxMzQzOTIxYjIzZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-05T11:29:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-05T11:29:47Z"}, "message": "Auto merge of #35787 - canndrew:bang_type_refactor_check, r=eddyb\n\nTypecheck refactor for `!`\n\nPing @nikomatsakis @eddyb. This is the PR for the typeck refactor for `!`. Is this what you guys had in mind? Is there anything else that needs doing on it?", "tree": {"sha": "cbd388c8aedbbb51618d0e95c39b67729d18911a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbd388c8aedbbb51618d0e95c39b67729d18911a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58dc448f8c29d0262f2cde76a9d21343921b23fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58dc448f8c29d0262f2cde76a9d21343921b23fd", "html_url": "https://github.com/rust-lang/rust/commit/58dc448f8c29d0262f2cde76a9d21343921b23fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58dc448f8c29d0262f2cde76a9d21343921b23fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dbf600d159a5c65b53419f1669834d1f81496a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dbf600d159a5c65b53419f1669834d1f81496a7", "html_url": "https://github.com/rust-lang/rust/commit/2dbf600d159a5c65b53419f1669834d1f81496a7"}, {"sha": "c9a340e546ac2c708d6f334a83cfbf6a38810255", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9a340e546ac2c708d6f334a83cfbf6a38810255", "html_url": "https://github.com/rust-lang/rust/commit/c9a340e546ac2c708d6f334a83cfbf6a38810255"}], "stats": {"total": 599, "additions": 272, "deletions": 327}, "files": [{"sha": "c67b98761aa6ed50bbe10aba761117fdf82647ab", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 44, "deletions": 52, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=58dc448f8c29d0262f2cde76a9d21343921b23fd", "patch": "@@ -32,17 +32,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"check_pat(pat={:?},expected={:?})\", pat, expected);\n \n-        match pat.node {\n+        let ty = match pat.node {\n             PatKind::Wild => {\n-                self.write_ty(pat.id, expected);\n+                expected\n             }\n             PatKind::Lit(ref lt) => {\n-                self.check_expr(&lt);\n-                let expr_ty = self.expr_ty(&lt);\n+                let ty = self.check_expr(&lt);\n \n                 // Byte string patterns behave the same way as array patterns\n                 // They can denote both statically and dynamically sized byte arrays\n-                let mut pat_ty = expr_ty;\n+                let mut pat_ty = ty;\n                 if let hir::ExprLit(ref lt) = lt.node {\n                     if let ast::LitKind::ByteStr(_) = lt.node {\n                         let expected_ty = self.structurally_resolved_type(pat.span, expected);\n@@ -55,28 +54,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                self.write_ty(pat.id, pat_ty);\n-\n                 // somewhat surprising: in this case, the subtyping\n                 // relation goes the opposite way as the other\n                 // cases. Actually what we really want is not a subtyping\n                 // relation at all but rather that there exists a LUB (so\n                 // that they can be compared). However, in practice,\n                 // constants are always scalars or strings.  For scalars\n-                // subtyping is irrelevant, and for strings `expr_ty` is\n+                // subtyping is irrelevant, and for strings `ty` is\n                 // type is `&'static str`, so if we say that\n                 //\n                 //     &'static str <: expected\n                 //\n                 // that's equivalent to there existing a LUB.\n                 self.demand_suptype(pat.span, expected, pat_ty);\n+                pat_ty\n             }\n             PatKind::Range(ref begin, ref end) => {\n-                self.check_expr(begin);\n-                self.check_expr(end);\n-\n-                let lhs_ty = self.expr_ty(begin);\n-                let rhs_ty = self.expr_ty(end);\n+                let lhs_ty = self.check_expr(begin);\n+                let rhs_ty = self.check_expr(end);\n \n                 // Check that both end-points are of numeric or char type.\n                 let numeric_or_char = |ty: Ty| ty.is_numeric() || ty.is_char();\n@@ -105,11 +100,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // it to type the entire expression.\n                 let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n \n-                self.write_ty(pat.id, common_type);\n-\n                 // subtyping doesn't matter here, as the value is some kind of scalar\n                 self.demand_eqtype(pat.span, expected, lhs_ty);\n                 self.demand_eqtype(pat.span, expected, rhs_ty);\n+                common_type\n             }\n             PatKind::Binding(bm, _, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);\n@@ -136,8 +130,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                self.write_ty(pat.id, typ);\n-\n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n                 match tcx.expect_def(pat.id) {\n@@ -154,16 +146,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(ref p) = *sub {\n                     self.check_pat(&p, expected);\n                 }\n+\n+                typ\n             }\n             PatKind::TupleStruct(ref path, ref subpats, ddpos) => {\n-                self.check_pat_tuple_struct(pat, path, &subpats, ddpos, expected);\n+                self.check_pat_tuple_struct(pat, path, &subpats, ddpos, expected)\n             }\n             PatKind::Path(ref opt_qself, ref path) => {\n                 let opt_qself_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n-                self.check_pat_path(pat, opt_qself_ty, path, expected);\n+                self.check_pat_path(pat, opt_qself_ty, path, expected)\n             }\n             PatKind::Struct(ref path, ref fields, etc) => {\n-                self.check_pat_struct(pat, path, fields, etc, expected);\n+                self.check_pat_struct(pat, path, fields, etc, expected)\n             }\n             PatKind::Tuple(ref elements, ddpos) => {\n                 let mut expected_len = elements.len();\n@@ -178,11 +172,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 let element_tys: Vec<_> = (0 .. max_len).map(|_| self.next_ty_var()).collect();\n                 let pat_ty = tcx.mk_tup(element_tys.clone());\n-                self.write_ty(pat.id, pat_ty);\n                 self.demand_eqtype(pat.span, expected, pat_ty);\n                 for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n                     self.check_pat(elem, &element_tys[i]);\n                 }\n+                pat_ty\n             }\n             PatKind::Box(ref inner) => {\n                 let inner_ty = self.next_ty_var();\n@@ -193,11 +187,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // think any errors can be introduced by using\n                     // `demand::eqtype`.\n                     self.demand_eqtype(pat.span, expected, uniq_ty);\n-                    self.write_ty(pat.id, uniq_ty);\n                     self.check_pat(&inner, inner_ty);\n+                    uniq_ty\n                 } else {\n-                    self.write_error(pat.id);\n                     self.check_pat(&inner, tcx.types.err);\n+                    tcx.types.err\n                 }\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n@@ -225,11 +219,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     };\n \n-                    self.write_ty(pat.id, rptr_ty);\n                     self.check_pat(&inner, inner_ty);\n+                    rptr_ty\n                 } else {\n-                    self.write_error(pat.id);\n                     self.check_pat(&inner, tcx.types.err);\n+                    tcx.types.err\n                 }\n             }\n             PatKind::Vec(ref before, ref slice, ref after) => {\n@@ -281,8 +275,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                self.write_ty(pat.id, expected_ty);\n-\n                 for elt in before {\n                     self.check_pat(&elt, inner_ty);\n                 }\n@@ -292,8 +284,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 for elt in after {\n                     self.check_pat(&elt, inner_ty);\n                 }\n+                expected_ty\n             }\n-        }\n+        };\n+\n+        self.write_ty(pat.id, ty);\n \n         // (*) In most of the cases above (literals and constants being\n         // the exception), we relate types using strict equality, evewn\n@@ -371,7 +366,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        discrim: &'gcx hir::Expr,\n                        arms: &'gcx [hir::Arm],\n                        expected: Expectation<'tcx>,\n-                       match_src: hir::MatchSource) {\n+                       match_src: hir::MatchSource) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n         // Not entirely obvious: if matches may create ref bindings, we\n@@ -385,8 +380,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         });\n         let discrim_ty;\n         if let Some(m) = contains_ref_bindings {\n-            self.check_expr_with_lvalue_pref(discrim, LvaluePreference::from_mutbl(m));\n-            discrim_ty = self.expr_ty(discrim);\n+            discrim_ty = self.check_expr_with_lvalue_pref(discrim, LvaluePreference::from_mutbl(m));\n         } else {\n             // ...but otherwise we want to use any supertype of the\n             // discriminant. This is sort of a workaround, see note (*) in\n@@ -425,12 +419,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             _ => result_ty\n         };\n+\n         for (i, arm) in arms.iter().enumerate() {\n             if let Some(ref e) = arm.guard {\n                 self.check_expr_has_type(e, tcx.types.bool);\n             }\n-            self.check_expr_with_expectation(&arm.body, expected);\n-            let arm_ty = self.expr_ty(&arm.body);\n+            let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n \n             if result_ty.references_error() || arm_ty.references_error() {\n                 result_ty = tcx.types.err;\n@@ -460,10 +454,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     })\n             } else if i == 0 {\n                 // Special-case the first arm, as it has no \"previous expressions\".\n-                self.try_coerce(&arm.body, coerce_first)\n+                self.try_coerce(&arm.body, arm_ty, coerce_first)\n             } else {\n                 let prev_arms = || arms[..i].iter().map(|arm| &*arm.body);\n-                self.try_find_coercion_lub(origin, prev_arms, result_ty, &arm.body)\n+                self.try_find_coercion_lub(origin, prev_arms, result_ty, &arm.body, arm_ty)\n             };\n \n             result_ty = match result {\n@@ -480,7 +474,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n         }\n \n-        self.write_ty(expr.id, result_ty);\n+        result_ty\n     }\n }\n \n@@ -490,39 +484,38 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         path: &hir::Path,\n                         fields: &'gcx [Spanned<hir::FieldPat>],\n                         etc: bool,\n-                        expected: Ty<'tcx>)\n+                        expected: Ty<'tcx>) -> Ty<'tcx>\n     {\n         // Resolve the path and check the definition for errors.\n         let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(path, pat.id,\n                                                                                  pat.span) {\n             variant_ty\n         } else {\n-            self.write_error(pat.id);\n             for field in fields {\n                 self.check_pat(&field.node.pat, self.tcx.types.err);\n             }\n-            return;\n+            return self.tcx.types.err;\n         };\n \n         // Type check the path.\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns.\n         self.check_struct_pat_fields(pat_ty, pat.span, variant, fields, etc);\n+        pat_ty\n     }\n \n     fn check_pat_path(&self,\n                       pat: &hir::Pat,\n                       opt_self_ty: Option<Ty<'tcx>>,\n                       path: &hir::Path,\n-                      expected: Ty<'tcx>)\n+                      expected: Ty<'tcx>) -> Ty<'tcx>\n     {\n         let tcx = self.tcx;\n         let report_unexpected_def = || {\n             span_err!(tcx.sess, pat.span, E0533,\n                       \"`{}` does not name a unit variant, unit struct or a constant\",\n                       pprust::path_to_string(path));\n-            self.write_error(pat.id);\n         };\n \n         // Resolve the path and check the definition for errors.\n@@ -531,18 +524,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n-                self.write_error(pat.id);\n-                return;\n+                return tcx.types.err;\n             }\n             Def::Method(..) => {\n                 report_unexpected_def();\n-                return;\n+                return tcx.types.err;\n             }\n             Def::Variant(..) | Def::Struct(..) => {\n                 let variant = tcx.expect_variant_def(def);\n                 if variant.kind != VariantKind::Unit {\n                     report_unexpected_def();\n-                    return;\n+                    return tcx.types.err;\n                 }\n             }\n             Def::Const(..) | Def::AssociatedConst(..) => {} // OK\n@@ -552,18 +544,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Type check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n         self.demand_suptype(pat.span, expected, pat_ty);\n+        pat_ty\n     }\n \n     fn check_pat_tuple_struct(&self,\n                               pat: &hir::Pat,\n                               path: &hir::Path,\n                               subpats: &'gcx [P<hir::Pat>],\n                               ddpos: Option<usize>,\n-                              expected: Ty<'tcx>)\n+                              expected: Ty<'tcx>) -> Ty<'tcx>\n     {\n         let tcx = self.tcx;\n         let on_error = || {\n-            self.write_error(pat.id);\n             for pat in subpats {\n                 self.check_pat(&pat, tcx.types.err);\n             }\n@@ -587,11 +579,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n                 on_error();\n-                return;\n+                return tcx.types.err;\n             }\n             Def::Const(..) | Def::AssociatedConst(..) | Def::Method(..) => {\n                 report_unexpected_def(false);\n-                return;\n+                return tcx.types.err;\n             }\n             Def::Variant(..) | Def::Struct(..) => {\n                 tcx.expect_variant_def(def)\n@@ -604,20 +596,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             report_unexpected_def(true);\n         } else if variant.kind != VariantKind::Tuple {\n             report_unexpected_def(false);\n-            return;\n+            return tcx.types.err;\n         }\n \n         // Type check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n-\n         let pat_ty = if pat_ty.is_fn() {\n             // Replace constructor type with constructed type for tuple struct patterns.\n             tcx.no_late_bound_regions(&pat_ty.fn_ret()).unwrap()\n         } else {\n             // Leave the type as is for unit structs (backward compatibility).\n             pat_ty\n         };\n-        self.write_ty(pat.id, pat_ty);\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns.\n@@ -650,7 +640,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                variant.fields.len(), fields_ending, subpats.len()))\n                 .emit();\n             on_error();\n+            return tcx.types.err;\n         }\n+        pat_ty\n     }\n \n     fn check_struct_pat_fields(&self,"}, {"sha": "5bd4f13a1119c7e9a9144a48d197bd99d6f2cc75", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=58dc448f8c29d0262f2cde76a9d21343921b23fd", "patch": "@@ -15,7 +15,7 @@ use CrateCtxt;\n use middle::cstore::LOCAL_CRATE;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use rustc::infer;\n+use rustc::{infer, traits};\n use rustc::ty::{self, LvaluePreference, Ty};\n use syntax::parse::token;\n use syntax::ptr::P;\n@@ -45,10 +45,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       call_expr: &'gcx hir::Expr,\n                       callee_expr: &'gcx hir::Expr,\n                       arg_exprs: &'gcx [P<hir::Expr>],\n-                      expected: Expectation<'tcx>)\n+                      expected: Expectation<'tcx>) -> Ty<'tcx>\n     {\n-        self.check_expr(callee_expr);\n-        let original_callee_ty = self.expr_ty(callee_expr);\n+        let original_callee_ty = self.check_expr(callee_expr);\n \n         let mut autoderef = self.autoderef(callee_expr.span, original_callee_ty);\n         let result = autoderef.by_ref().flat_map(|(adj_ty, idx)| {\n@@ -57,25 +56,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let callee_ty = autoderef.unambiguous_final_ty();\n         autoderef.finalize(LvaluePreference::NoPreference, Some(callee_expr));\n \n-        match result {\n+        let output = match result {\n             None => {\n                 // this will report an error since original_callee_ty is not a fn\n-                self.confirm_builtin_call(call_expr, original_callee_ty, arg_exprs, expected);\n+                self.confirm_builtin_call(call_expr, original_callee_ty, arg_exprs, expected)\n             }\n \n             Some(CallStep::Builtin) => {\n-                self.confirm_builtin_call(call_expr, callee_ty, arg_exprs, expected);\n+                self.confirm_builtin_call(call_expr, callee_ty, arg_exprs, expected)\n             }\n \n             Some(CallStep::DeferredClosure(fn_sig)) => {\n-                self.confirm_deferred_closure_call(call_expr, arg_exprs, expected, fn_sig);\n+                self.confirm_deferred_closure_call(call_expr, arg_exprs, expected, fn_sig)\n             }\n \n             Some(CallStep::Overloaded(method_callee)) => {\n                 self.confirm_overloaded_call(call_expr, callee_expr,\n-                                             arg_exprs, expected, method_callee);\n+                                             arg_exprs, expected, method_callee)\n             }\n-        }\n+        };\n+\n+        // we must check that return type of called functions is WF:\n+        self.register_wf_obligation(output, call_expr.span, traits::MiscObligation);\n+\n+        output\n     }\n \n     fn try_overloaded_call_step(&self,\n@@ -181,7 +185,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             call_expr: &hir::Expr,\n                             callee_ty: Ty<'tcx>,\n                             arg_exprs: &'gcx [P<hir::Expr>],\n-                            expected: Expectation<'tcx>)\n+                            expected: Expectation<'tcx>) -> Ty<'tcx>\n     {\n         let error_fn_sig;\n \n@@ -245,14 +249,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   fn_sig.variadic,\n                                   TupleArgumentsFlag::DontTupleArguments);\n \n-        self.write_call(call_expr, fn_sig.output);\n+        fn_sig.output\n     }\n \n     fn confirm_deferred_closure_call(&self,\n                                      call_expr: &hir::Expr,\n                                      arg_exprs: &'gcx [P<hir::Expr>],\n                                      expected: Expectation<'tcx>,\n-                                     fn_sig: ty::FnSig<'tcx>)\n+                                     fn_sig: ty::FnSig<'tcx>) -> Ty<'tcx>\n     {\n         // `fn_sig` is the *signature* of the cosure being called. We\n         // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n@@ -272,15 +276,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   fn_sig.variadic,\n                                   TupleArgumentsFlag::TupleArguments);\n \n-        self.write_call(call_expr, fn_sig.output);\n+        fn_sig.output\n     }\n \n     fn confirm_overloaded_call(&self,\n                                call_expr: &hir::Expr,\n                                callee_expr: &'gcx hir::Expr,\n                                arg_exprs: &'gcx [P<hir::Expr>],\n                                expected: Expectation<'tcx>,\n-                               method_callee: ty::MethodCallee<'tcx>)\n+                               method_callee: ty::MethodCallee<'tcx>) -> Ty<'tcx>\n     {\n         let output_type =\n             self.check_method_argument_types(call_expr.span,\n@@ -289,9 +293,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              arg_exprs,\n                                              TupleArgumentsFlag::TupleArguments,\n                                              expected);\n-        self.write_call(call_expr, output_type);\n \n         self.write_overloaded_call_method_map(call_expr, method_callee);\n+        output_type\n     }\n \n     fn write_overloaded_call_method_map(&self,"}, {"sha": "0c9da86563ab21af6f8be9965a4e3776852050f2", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=58dc448f8c29d0262f2cde76a9d21343921b23fd", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (None, Some(t_cast)) => {\n                 if let ty::TyFnDef(.., f) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n-                    let res = fcx.try_coerce(self.expr, fcx.tcx.mk_fn_ptr(f));\n+                    let res = fcx.try_coerce(self.expr, self.expr_ty, fcx.tcx.mk_fn_ptr(f));\n                     if !res.is_ok() {\n                         return Err(CastError::NonScalar);\n                     }\n@@ -471,7 +471,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        fcx.try_coerce(self.expr, self.cast_ty).is_ok()\n+        fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty).is_ok()\n     }\n \n }"}, {"sha": "9e41d1b5676e45d1454d081d9680a69fd81c20c5", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=58dc448f8c29d0262f2cde76a9d21343921b23fd", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               _capture: hir::CaptureClause,\n                               decl: &'gcx hir::FnDecl,\n                               body: &'gcx hir::Block,\n-                              expected: Expectation<'tcx>) {\n+                              expected: Expectation<'tcx>) -> Ty<'tcx> {\n         debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n                expr,\n                expected);\n@@ -44,7 +44,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                      opt_kind: Option<ty::ClosureKind>,\n                      decl: &'gcx hir::FnDecl,\n                      body: &'gcx hir::Block,\n-                     expected_sig: Option<ty::FnSig<'tcx>>) {\n+                     expected_sig: Option<ty::FnSig<'tcx>>) -> Ty<'tcx> {\n         let expr_def_id = self.tcx.map.local_def_id(expr.id);\n \n         debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n@@ -70,8 +70,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.parameter_environment.free_substs,\n             upvar_tys);\n \n-        self.write_ty(expr.id, closure_type);\n-\n         let fn_sig = self.tcx.liberate_late_bound_regions(\n             self.tcx.region_maps.call_site_extent(expr.id, body.id), &fn_ty.sig);\n         let fn_sig =\n@@ -93,6 +91,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Some(kind) => { self.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind); }\n             None => { }\n         }\n+\n+        closure_type\n     }\n \n     fn deduce_expectations_from_expected_type(&self, expected_ty: Ty<'tcx>)"}, {"sha": "98a05989b140d97881b25adddeb5bb9bd6e6df90", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=58dc448f8c29d0262f2cde76a9d21343921b23fd", "patch": "@@ -630,9 +630,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// The expressions *must not* have any pre-existing adjustments.\n     pub fn try_coerce(&self,\n                       expr: &hir::Expr,\n+                      expr_ty: Ty<'tcx>,\n                       target: Ty<'tcx>)\n                       -> RelateResult<'tcx, Ty<'tcx>> {\n-        let source = self.resolve_type_vars_with_obligations(self.expr_ty(expr));\n+        let source = self.resolve_type_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n         let mut coerce = Coerce::new(self, TypeOrigin::ExprAssignable(expr.span));\n@@ -658,14 +659,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            origin: TypeOrigin,\n                                            exprs: E,\n                                            prev_ty: Ty<'tcx>,\n-                                           new: &'b hir::Expr)\n+                                           new: &'b hir::Expr,\n+                                           new_ty: Ty<'tcx>)\n                                            -> RelateResult<'tcx, Ty<'tcx>>\n         // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n         where E: Fn() -> I,\n               I: IntoIterator<Item=&'b hir::Expr> {\n \n         let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n-        let new_ty = self.resolve_type_vars_with_obligations(self.expr_ty(new));\n+        let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n         debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n \n         let trace = TypeTrace::types(origin, true, prev_ty, new_ty);\n@@ -741,7 +743,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     autoderefs: 1,\n                     autoref: Some(AutoPtr(_, mutbl_adj)),\n                     unsize: None\n-                })) => match self.expr_ty(expr).sty {\n+                })) => match self.node_ty(expr.id).sty {\n                     ty::TyRef(_, mt_orig) => {\n                         // Reborrow that we can safely ignore.\n                         mutbl_adj == mt_orig.mutbl"}, {"sha": "d622bc7f751d763d8f232dc2d145c9993c977447", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=58dc448f8c29d0262f2cde76a9d21343921b23fd", "patch": "@@ -53,11 +53,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Checks that the type of `expr` can be coerced to `expected`.\n-    pub fn demand_coerce(&self, expr: &hir::Expr, expected: Ty<'tcx>) {\n+    pub fn demand_coerce(&self, expr: &hir::Expr, checked_ty: Ty<'tcx>, expected: Ty<'tcx>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n-        if let Err(e) = self.try_coerce(expr, expected) {\n+        if let Err(e) = self.try_coerce(expr, checked_ty, expected) {\n             let origin = TypeOrigin::Misc(expr.span);\n-            let expr_ty = self.resolve_type_vars_with_obligations(self.expr_ty(expr));\n+            let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n             self.report_mismatched_types(origin, expected, expr_ty, e);\n         }\n     }"}, {"sha": "ab59fafb652099087028a0406a6202802c200523", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=58dc448f8c29d0262f2cde76a9d21343921b23fd", "patch": "@@ -472,7 +472,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                    i, expr, autoderef_count);\n \n             if autoderef_count > 0 {\n-                let mut autoderef = self.autoderef(expr.span, self.expr_ty(expr));\n+                let mut autoderef = self.autoderef(expr.span, self.node_ty(expr.id));\n                 autoderef.nth(autoderef_count).unwrap_or_else(|| {\n                     span_bug!(expr.span, \"expr was deref-able {} times but now isn't?\",\n                               autoderef_count);\n@@ -532,7 +532,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                 unsize: None\n                             }))), false)\n                     };\n-                    let index_expr_ty = self.expr_ty(&index_expr);\n+                    let index_expr_ty = self.node_ty(index_expr.id);\n \n                     let result = self.try_index_step(\n                         ty::MethodCall::expr(expr.id),\n@@ -547,7 +547,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     if let Some((input_ty, return_ty)) = result {\n                         self.demand_suptype(index_expr.span, input_ty, index_expr_ty);\n \n-                        let expr_ty = self.expr_ty(&expr);\n+                        let expr_ty = self.node_ty(expr.id);\n                         self.demand_suptype(expr.span, expr_ty, return_ty);\n                     }\n                 }\n@@ -558,7 +558,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     if self.tables.borrow().method_map.contains_key(&method_call) {\n                         let method = self.try_overloaded_deref(expr.span,\n                             Some(&base_expr),\n-                            self.expr_ty(&base_expr),\n+                            self.node_ty(base_expr.id),\n                             PreferMutLvalue);\n                         let method = method.expect(\"re-trying deref failed\");\n                         self.tables.borrow_mut().method_map.insert(method_call, method);"}, {"sha": "00fdcd59f7ceece1d30a798400b02fa44008c867", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 175, "deletions": 230, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=58dc448f8c29d0262f2cde76a9d21343921b23fd", "patch": "@@ -1534,14 +1534,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n                node_id, ty, self.tag());\n         self.tables.borrow_mut().node_types.insert(node_id, ty);\n-\n-        // Add adjustments to !-expressions\n-        if ty.is_never() {\n-            if let Some(hir::map::NodeExpr(_)) = self.tcx.map.find(node_id) {\n-                let adj = adjustment::AdjustNeverToAny(self.next_diverging_ty_var());\n-                self.write_adjustment(node_id, adj);\n-            }\n-        }\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n@@ -1708,7 +1700,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.add_obligations_for_parameters(cause, &bounds);\n \n         let ty_substituted = self.instantiate_type_scheme(path.span, substs, &ty);\n-        self.write_ty(node_id, ty_substituted);\n         self.write_substs(node_id, ty::ItemSubsts {\n             substs: substs\n         });\n@@ -1747,13 +1738,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.require_type_meets(ty, span, code, ty::BoundSized);\n     }\n \n-    pub fn require_expr_have_sized_type(&self,\n-                                        expr: &hir::Expr,\n-                                        code: traits::ObligationCauseCode<'tcx>)\n-    {\n-        self.require_type_is_sized(self.expr_ty(expr), expr.span, code);\n-    }\n-\n     pub fn register_builtin_bound(&self,\n                                   ty: Ty<'tcx>,\n                                   builtin_bound: ty::BuiltinBound,\n@@ -1779,26 +1763,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    pub fn expr_ty(&self, ex: &hir::Expr) -> Ty<'tcx> {\n-        if let Some(&adjustment::AdjustNeverToAny(ref t))\n-                = self.tables.borrow().adjustments.get(&ex.id) {\n-            return t;\n-        }\n-        match self.tables.borrow().node_types.get(&ex.id) {\n-            Some(&t) => t,\n-            None => {\n-                bug!(\"no type for expr in fcx {}\", self.tag());\n-            }\n-        }\n-    }\n-\n     /// Apply `adjustment` to the type of `expr`\n     pub fn adjust_expr_ty(&self,\n                           expr: &hir::Expr,\n                           adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n                           -> Ty<'tcx>\n     {\n-        let raw_ty = self.expr_ty(expr);\n+        let raw_ty = self.node_ty(expr.id);\n         let raw_ty = self.shallow_resolve(raw_ty);\n         let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n         raw_ty.adjust(self.tcx, expr.span, expr.id, adjustment, |method_call| {\n@@ -2583,13 +2554,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         Expectation::rvalue_hint(self, ty)\n                     });\n \n-                    self.check_expr_with_expectation(&arg,\n-                        expected.unwrap_or(ExpectHasType(formal_ty)));\n+                    let checked_ty = self.check_expr_with_expectation(&arg,\n+                                            expected.unwrap_or(ExpectHasType(formal_ty)));\n                     // 2. Coerce to the most detailed type that could be coerced\n                     //    to, which is `expected_ty` if `rvalue_hint` returns an\n                     //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n                     let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n-                    self.demand_coerce(&arg, coerce_ty.unwrap_or(formal_ty));\n+                    self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty));\n \n                     // 3. Relate the expected type and the formal one,\n                     //    if the expected type was used for the coercion.\n@@ -2620,12 +2591,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // arguments which we skipped above.\n         if variadic {\n             for arg in args.iter().skip(expected_arg_count) {\n-                self.check_expr(&arg);\n+                let arg_ty = self.check_expr(&arg);\n \n                 // There are a few types which get autopromoted when passed via varargs\n                 // in C but we just error out instead and require explicit casts.\n                 let arg_ty = self.structurally_resolved_type(arg.span,\n-                                                             self.expr_ty(&arg));\n+                                                             arg_ty);\n                 match arg_ty.sty {\n                     ty::TyFloat(ast::FloatTy::F32) => {\n                         self.type_error_message(arg.span, |t| {\n@@ -2666,12 +2637,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         (0..len).map(|_| self.tcx.types.err).collect()\n     }\n \n-    fn write_call(&self,\n-                  call_expr: &hir::Expr,\n-                  output: Ty<'tcx>) {\n-        self.write_ty(call_expr.id, output);\n-    }\n-\n     // AST fragment checking\n     fn check_lit(&self,\n                  lit: &ast::Lit,\n@@ -2721,41 +2686,43 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_eq_type(&self,\n                           expr: &'gcx hir::Expr,\n                           expected: Ty<'tcx>) {\n-        self.check_expr_with_hint(expr, expected);\n-        self.demand_eqtype(expr.span, expected, self.expr_ty(expr));\n+        let ty = self.check_expr_with_hint(expr, expected);\n+        self.demand_eqtype(expr.span, expected, ty);\n     }\n \n     pub fn check_expr_has_type(&self,\n                                expr: &'gcx hir::Expr,\n-                               expected: Ty<'tcx>) {\n-        self.check_expr_with_hint(expr, expected);\n-        self.demand_suptype(expr.span, expected, self.expr_ty(expr));\n+                               expected: Ty<'tcx>) -> Ty<'tcx> {\n+        let ty = self.check_expr_with_hint(expr, expected);\n+        self.demand_suptype(expr.span, expected, ty);\n+        ty\n     }\n \n     fn check_expr_coercable_to_type(&self,\n                                     expr: &'gcx hir::Expr,\n-                                    expected: Ty<'tcx>) {\n-        self.check_expr_with_hint(expr, expected);\n-        self.demand_coerce(expr, expected);\n+                                    expected: Ty<'tcx>) -> Ty<'tcx> {\n+        let ty = self.check_expr_with_hint(expr, expected);\n+        self.demand_coerce(expr, ty, expected);\n+        ty\n     }\n \n     fn check_expr_with_hint(&self, expr: &'gcx hir::Expr,\n-                            expected: Ty<'tcx>) {\n+                            expected: Ty<'tcx>) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, ExpectHasType(expected))\n     }\n \n     fn check_expr_with_expectation(&self,\n                                    expr: &'gcx hir::Expr,\n-                                   expected: Expectation<'tcx>) {\n+                                   expected: Expectation<'tcx>) -> Ty<'tcx> {\n         self.check_expr_with_expectation_and_lvalue_pref(expr, expected, NoPreference)\n     }\n \n-    fn check_expr(&self, expr: &'gcx hir::Expr)  {\n+    fn check_expr(&self, expr: &'gcx hir::Expr) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, NoExpectation)\n     }\n \n     fn check_expr_with_lvalue_pref(&self, expr: &'gcx hir::Expr,\n-                                   lvalue_pref: LvaluePreference)  {\n+                                   lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n         self.check_expr_with_expectation_and_lvalue_pref(expr, NoExpectation, lvalue_pref)\n     }\n \n@@ -2820,12 +2787,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          args: &'gcx [P<hir::Expr>],\n                          tps: &[P<hir::Ty>],\n                          expected: Expectation<'tcx>,\n-                         lvalue_pref: LvaluePreference) {\n+                         lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n         let rcvr = &args[0];\n-        self.check_expr_with_lvalue_pref(&rcvr, lvalue_pref);\n+        let rcvr_t = self.check_expr_with_lvalue_pref(&rcvr, lvalue_pref);\n \n         // no need to check for bot/err -- callee does that\n-        let expr_t = self.structurally_resolved_type(expr.span, self.expr_ty(&rcvr));\n+        let expr_t = self.structurally_resolved_type(expr.span, rcvr_t);\n \n         let tps = tps.iter().map(|ast_ty| self.to_ty(&ast_ty)).collect::<Vec<_>>();\n         let fn_ty = match self.lookup_method(method_name.span,\n@@ -2856,7 +2823,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                       DontTupleArguments,\n                                                       expected);\n \n-        self.write_call(expr, ret_ty);\n+        ret_ty\n     }\n \n     // A generic function for checking the then and else in an if\n@@ -2865,27 +2832,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        cond_expr: &'gcx hir::Expr,\n                        then_blk: &'gcx hir::Block,\n                        opt_else_expr: Option<&'gcx hir::Expr>,\n-                       id: ast::NodeId,\n                        sp: Span,\n-                       expected: Expectation<'tcx>) {\n-        self.check_expr_has_type(cond_expr, self.tcx.types.bool);\n+                       expected: Expectation<'tcx>) -> Ty<'tcx> {\n+        let cond_ty = self.check_expr_has_type(cond_expr, self.tcx.types.bool);\n \n         let expected = expected.adjust_for_branches(self);\n-        self.check_block_with_expected(then_blk, expected);\n-        let then_ty = self.node_ty(then_blk.id);\n+        let then_ty = self.check_block_with_expected(then_blk, expected);\n \n         let unit = self.tcx.mk_nil();\n         let (origin, expected, found, result) =\n         if let Some(else_expr) = opt_else_expr {\n-            self.check_expr_with_expectation(else_expr, expected);\n-            let else_ty = self.expr_ty(else_expr);\n+            let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let origin = TypeOrigin::IfExpression(sp);\n \n             // Only try to coerce-unify if we have a then expression\n             // to assign coercions to, otherwise it's () or diverging.\n             let result = if let Some(ref then) = then_blk.expr {\n                 let res = self.try_find_coercion_lub(origin, || Some(&**then),\n-                                                     then_ty, else_expr);\n+                                                     then_ty, else_expr, else_ty);\n \n                 // In case we did perform an adjustment, we have to update\n                 // the type of the block, because old trans still uses it.\n@@ -2918,9 +2882,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                  }))\n         };\n \n-        let if_ty = match result {\n+        match result {\n             Ok(ty) => {\n-                if self.expr_ty(cond_expr).references_error() {\n+                if cond_ty.references_error() {\n                     self.tcx.types.err\n                 } else {\n                     ty\n@@ -2930,20 +2894,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.report_mismatched_types(origin, expected, found, e);\n                 self.tcx.types.err\n             }\n-        };\n-\n-        self.write_ty(id, if_ty);\n+        }\n     }\n \n     // Check field access expressions\n     fn check_field(&self,\n                    expr: &'gcx hir::Expr,\n                    lvalue_pref: LvaluePreference,\n                    base: &'gcx hir::Expr,\n-                   field: &Spanned<ast::Name>) {\n-        self.check_expr_with_lvalue_pref(base, lvalue_pref);\n+                   field: &Spanned<ast::Name>) -> Ty<'tcx> {\n+        let expr_t = self.check_expr_with_lvalue_pref(base, lvalue_pref);\n         let expr_t = self.structurally_resolved_type(expr.span,\n-                                                     self.expr_ty(base));\n+                                                     expr_t);\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n         while let Some((base_t, autoderefs)) = autoderef.next() {\n@@ -2954,9 +2916,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n                             autoderef.finalize(lvalue_pref, Some(base));\n-                            self.write_ty(expr.id, field_ty);\n                             self.write_autoderef_adjustment(base.id, autoderefs);\n-                            return;\n+                            return field_ty;\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n                     }\n@@ -2968,7 +2929,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((did, field_ty)) = private_candidate {\n             let struct_path = self.tcx().item_path_str(did);\n-            self.write_ty(expr.id, field_ty);\n             let msg = format!(\"field `{}` of struct `{}` is private\", field.node, struct_path);\n             let mut err = self.tcx().sess.struct_span_err(expr.span, &msg);\n             // Also check if an accessible method exists, which is often what is meant.\n@@ -2977,8 +2937,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   field.node));\n             }\n             err.emit();\n+            field_ty\n         } else if field.node == keywords::Invalid.name() {\n-            self.write_error(expr.id);\n+            self.tcx().types.err\n         } else if self.method_exists(field.span, field.node, expr_t, expr.id, true) {\n             self.type_error_struct(field.span, |actual| {\n                 format!(\"attempted to take value of method `{}` on type \\\n@@ -2987,7 +2948,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 .help(\"maybe a `()` to call it is missing? \\\n                        If not, try an anonymous function\")\n                 .emit();\n-            self.write_error(expr.id);\n+            self.tcx().types.err\n         } else {\n             let mut err = self.type_error_struct(expr.span, |actual| {\n                 format!(\"attempted access of field `{}` on type `{}`, \\\n@@ -3005,7 +2966,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 _ => {}\n             }\n             err.emit();\n-            self.write_error(expr.id);\n+            self.tcx().types.err\n         }\n     }\n \n@@ -3037,10 +2998,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        expr: &'gcx hir::Expr,\n                        lvalue_pref: LvaluePreference,\n                        base: &'gcx hir::Expr,\n-                       idx: codemap::Spanned<usize>) {\n-        self.check_expr_with_lvalue_pref(base, lvalue_pref);\n+                       idx: codemap::Spanned<usize>) -> Ty<'tcx> {\n+        let expr_t = self.check_expr_with_lvalue_pref(base, lvalue_pref);\n         let expr_t = self.structurally_resolved_type(expr.span,\n-                                                     self.expr_ty(base));\n+                                                     expr_t);\n         let mut private_candidate = None;\n         let mut tuple_like = false;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n@@ -3070,9 +3031,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if let Some(field_ty) = field {\n                 autoderef.finalize(lvalue_pref, Some(base));\n-                self.write_ty(expr.id, field_ty);\n                 self.write_autoderef_adjustment(base.id, autoderefs);\n-                return;\n+                return field_ty;\n             }\n         }\n         autoderef.unambiguous_final_ty();\n@@ -3081,8 +3041,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let struct_path = self.tcx().item_path_str(did);\n             let msg = format!(\"field `{}` of struct `{}` is private\", idx.node, struct_path);\n             self.tcx().sess.span_err(expr.span, &msg);\n-            self.write_ty(expr.id, field_ty);\n-            return;\n+            return field_ty;\n         }\n \n         self.type_error_message(\n@@ -3102,7 +3061,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             },\n             expr_t);\n \n-        self.write_error(expr.id);\n+        self.tcx().types.err\n     }\n \n     fn report_unknown_field(&self,\n@@ -3205,17 +3164,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn check_struct_fields_on_error(&self,\n-                                    id: ast::NodeId,\n                                     fields: &'gcx [hir::Field],\n                                     base_expr: &'gcx Option<P<hir::Expr>>) {\n-        // Make sure to still write the types\n-        // otherwise we might ICE\n-        self.write_error(id);\n         for field in fields {\n             self.check_expr(&field.expr);\n         }\n         match *base_expr {\n-            Some(ref base) => self.check_expr(&base),\n+            Some(ref base) => {\n+                self.check_expr(&base);\n+            },\n             None => {}\n         }\n     }\n@@ -3267,22 +3224,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          expr: &hir::Expr,\n                          path: &hir::Path,\n                          fields: &'gcx [hir::Field],\n-                         base_expr: &'gcx Option<P<hir::Expr>>)\n+                         base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n     {\n         // Find the relevant variant\n-        let (variant, expr_ty) = if let Some(variant_ty) = self.check_struct_path(path, expr.id,\n-                                                                                  expr.span) {\n+        let (variant, struct_ty) = if let Some(variant_ty) = self.check_struct_path(path, expr.id,\n+                                                                                    expr.span) {\n             variant_ty\n         } else {\n-            self.check_struct_fields_on_error(expr.id, fields, base_expr);\n-            return;\n+            self.check_struct_fields_on_error(fields, base_expr);\n+            return self.tcx().types.err;\n         };\n \n-        self.check_expr_struct_fields(expr_ty, path.span, variant, fields,\n+        self.check_expr_struct_fields(struct_ty, path.span, variant, fields,\n                                       base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n-            self.check_expr_has_type(base_expr, expr_ty);\n-            match expr_ty.sty {\n+            self.check_expr_has_type(base_expr, struct_ty);\n+            match struct_ty.sty {\n                 ty::TyStruct(adt, substs) => {\n                     self.tables.borrow_mut().fru_field_types.insert(\n                         expr.id,\n@@ -3299,6 +3256,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n         }\n+        self.require_type_is_sized(struct_ty, expr.span, traits::StructInitializerSized);\n+        struct_ty\n     }\n \n \n@@ -3315,10 +3274,35 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_with_expectation_and_lvalue_pref(&self,\n                                                    expr: &'gcx hir::Expr,\n                                                    expected: Expectation<'tcx>,\n-                                                   lvalue_pref: LvaluePreference) {\n+                                                   lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n         debug!(\">> typechecking: expr={:?} expected={:?}\",\n                expr, expected);\n+        let ty = self.check_expr_kind(expr, expected, lvalue_pref);\n+\n+        self.write_ty(expr.id, ty);\n+\n+        debug!(\"type of expr({}) {} is...\", expr.id,\n+               pprust::expr_to_string(expr));\n+        debug!(\"... {:?}, expected is {:?}\",\n+               ty,\n+               expected);\n \n+        // Add adjustments to !-expressions\n+        if ty.is_never() {\n+            if let Some(hir::map::NodeExpr(_)) = self.tcx.map.find(expr.id) {\n+                let adj_ty = self.next_diverging_ty_var();\n+                let adj = adjustment::AdjustNeverToAny(adj_ty);\n+                self.write_adjustment(expr.id, adj);\n+                return adj_ty;\n+            }\n+        }\n+        ty\n+    }\n+\n+    fn check_expr_kind(&self,\n+                       expr: &'gcx hir::Expr,\n+                       expected: Expectation<'tcx>,\n+                       lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let id = expr.id;\n         match expr.node {\n@@ -3329,20 +3313,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     _ => NoExpectation\n                 }\n             });\n-            self.check_expr_with_expectation(subexpr, expected_inner);\n-            let referent_ty = self.expr_ty(&subexpr);\n-            self.write_ty(id, tcx.mk_box(referent_ty));\n+            let referent_ty = self.check_expr_with_expectation(subexpr, expected_inner);\n+            tcx.mk_box(referent_ty)\n           }\n \n           hir::ExprLit(ref lit) => {\n-            let typ = self.check_lit(&lit, expected);\n-            self.write_ty(id, typ);\n+            self.check_lit(&lit, expected)\n           }\n           hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            self.check_binop(expr, op, lhs, rhs);\n+            self.check_binop(expr, op, lhs, rhs)\n           }\n           hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            self.check_binop_assign(expr, op, lhs, rhs);\n+            self.check_binop_assign(expr, op, lhs, rhs)\n           }\n           hir::ExprUnary(unop, ref oprnd) => {\n             let expected_inner = match unop {\n@@ -3357,10 +3339,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 hir::UnDeref => lvalue_pref,\n                 _ => NoPreference\n             };\n-            self.check_expr_with_expectation_and_lvalue_pref(&oprnd,\n-                                                             expected_inner,\n-                                                             lvalue_pref);\n-            let mut oprnd_t = self.expr_ty(&oprnd);\n+            let mut oprnd_t = self.check_expr_with_expectation_and_lvalue_pref(&oprnd,\n+                                                                               expected_inner,\n+                                                                               lvalue_pref);\n \n             if !oprnd_t.references_error() {\n                 match unop {\n@@ -3402,7 +3383,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            self.write_ty(id, oprnd_t);\n+            oprnd_t\n           }\n           hir::ExprAddrOf(mutbl, ref oprnd) => {\n             let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n@@ -3421,10 +3402,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             });\n             let lvalue_pref = LvaluePreference::from_mutbl(mutbl);\n-            self.check_expr_with_expectation_and_lvalue_pref(&oprnd, hint, lvalue_pref);\n+            let ty = self.check_expr_with_expectation_and_lvalue_pref(&oprnd, hint, lvalue_pref);\n \n-            let tm = ty::TypeAndMut { ty: self.expr_ty(&oprnd), mutbl: mutbl };\n-            let oprnd_t = if tm.ty.references_error() {\n+            let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n+            if tm.ty.references_error() {\n                 tcx.types.err\n             } else {\n                 // Note: at this point, we cannot say what the best lifetime\n@@ -3442,25 +3423,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // as long as it needs to live.\n                 let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n                 tcx.mk_ref(region, tm)\n-            };\n-            self.write_ty(id, oprnd_t);\n+            }\n           }\n           hir::ExprPath(ref opt_qself, ref path) => {\n               let opt_self_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n               let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n                                                                          expr.id, expr.span);\n-              if def != Def::Err {\n-                  self.instantiate_value_path(segments, opt_ty, def, expr.span, id);\n+              let ty = if def != Def::Err {\n+                  self.instantiate_value_path(segments, opt_ty, def, expr.span, id)\n               } else {\n                   self.set_tainted_by_errors();\n-                  self.write_error(id);\n-              }\n+                  tcx.types.err\n+              };\n \n               // We always require that the type provided as the value for\n               // a type parameter outlives the moment of instantiation.\n               self.opt_node_ty_substs(expr.id, |item_substs| {\n                   self.add_wf_bounds(&item_substs.substs, expr);\n               });\n+\n+              ty\n           }\n           hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n               for output in outputs {\n@@ -3469,10 +3451,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               for input in inputs {\n                   self.check_expr(input);\n               }\n-              self.write_nil(id);\n+              tcx.mk_nil()\n           }\n-          hir::ExprBreak(_) => { self.write_never(id); }\n-          hir::ExprAgain(_) => { self.write_never(id); }\n+          hir::ExprBreak(_) => { tcx.types.never }\n+          hir::ExprAgain(_) => { tcx.types.never }\n           hir::ExprRet(ref expr_opt) => {\n             if let Some(ref e) = *expr_opt {\n                 self.check_expr_coercable_to_type(&e, self.ret_ty);\n@@ -3490,10 +3472,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         .emit();\n                 }\n             }\n-            self.write_never(id);\n+            tcx.types.never\n           }\n           hir::ExprAssign(ref lhs, ref rhs) => {\n-            self.check_expr_with_lvalue_pref(&lhs, PreferMutLvalue);\n+            let lhs_ty = self.check_expr_with_lvalue_pref(&lhs, PreferMutLvalue);\n \n             let tcx = self.tcx;\n             if !tcx.expr_is_lval(&lhs) {\n@@ -3506,66 +3488,53 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 .emit();\n             }\n \n-            let lhs_ty = self.expr_ty(&lhs);\n-            self.check_expr_coercable_to_type(&rhs, lhs_ty);\n-            let rhs_ty = self.expr_ty(&rhs);\n+            let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n \n-            self.require_expr_have_sized_type(&lhs, traits::AssignmentLhsSized);\n+            self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n \n             if lhs_ty.references_error() || rhs_ty.references_error() {\n-                self.write_error(id);\n+                tcx.types.err\n             } else {\n-                self.write_nil(id);\n+                tcx.mk_nil()\n             }\n           }\n           hir::ExprIf(ref cond, ref then_blk, ref opt_else_expr) => {\n             self.check_then_else(&cond, &then_blk, opt_else_expr.as_ref().map(|e| &**e),\n-                                 id, expr.span, expected);\n+                                 expr.span, expected)\n           }\n           hir::ExprWhile(ref cond, ref body, _) => {\n-            self.check_expr_has_type(&cond, tcx.types.bool);\n+            let cond_ty = self.check_expr_has_type(&cond, tcx.types.bool);\n             self.check_block_no_value(&body);\n-            let cond_ty = self.expr_ty(&cond);\n             let body_ty = self.node_ty(body.id);\n             if cond_ty.references_error() || body_ty.references_error() {\n-                self.write_error(id);\n+                tcx.types.err\n             }\n             else {\n-                self.write_nil(id);\n+                tcx.mk_nil()\n             }\n           }\n           hir::ExprLoop(ref body, _) => {\n             self.check_block_no_value(&body);\n             if !may_break(tcx, expr.id, &body) {\n-                self.write_never(id);\n+                tcx.types.never\n             } else {\n-                self.write_nil(id);\n+                tcx.mk_nil()\n             }\n           }\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n-            self.check_match(expr, &discrim, arms, expected, match_src);\n+            self.check_match(expr, &discrim, arms, expected, match_src)\n           }\n           hir::ExprClosure(capture, ref decl, ref body, _) => {\n-              self.check_expr_closure(expr, capture, &decl, &body, expected);\n+              self.check_expr_closure(expr, capture, &decl, &body, expected)\n           }\n           hir::ExprBlock(ref b) => {\n-            self.check_block_with_expected(&b, expected);\n-            self.write_ty(id, self.node_ty(b.id));\n+            self.check_block_with_expected(&b, expected)\n           }\n           hir::ExprCall(ref callee, ref args) => {\n-              self.check_call(expr, &callee, &args[..], expected);\n-\n-              // we must check that return type of called functions is WF:\n-              let ret_ty = self.expr_ty(expr);\n-              self.register_wf_obligation(ret_ty, expr.span, traits::MiscObligation);\n+              self.check_call(expr, &callee, &args[..], expected)\n           }\n           hir::ExprMethodCall(name, ref tps, ref args) => {\n-              self.check_method_call(expr, name, &args[..], &tps[..], expected, lvalue_pref);\n-              let arg_tys = args.iter().map(|a| self.expr_ty(&a));\n-              let args_err = arg_tys.fold(false, |rest_err, a| rest_err || a.references_error());\n-              if args_err {\n-                  self.write_error(id);\n-              }\n+              self.check_method_call(expr, name, &args[..], &tps[..], expected, lvalue_pref)\n           }\n           hir::ExprCast(ref e, ref t) => {\n             if let hir::TyFixedLengthVec(_, ref count_expr) = t.node {\n@@ -3576,34 +3545,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // if appropriate.\n             let t_cast = self.to_ty(t);\n             let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n-            self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n-            let t_expr = self.expr_ty(e);\n+            let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n             let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n \n             // Eagerly check for some obvious errors.\n             if t_expr.references_error() || t_cast.references_error() {\n-                self.write_error(id);\n+                tcx.types.err\n             } else {\n-                // Write a type for the whole expression, assuming everything is going\n-                // to work out Ok.\n-                self.write_ty(id, t_cast);\n-\n                 // Defer other checks until we're done type checking.\n                 let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n                 match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n                     Ok(cast_check) => {\n                         deferred_cast_checks.push(cast_check);\n+                        t_cast\n                     }\n                     Err(ErrorReported) => {\n-                        self.write_error(id);\n+                        tcx.types.err\n                     }\n                 }\n             }\n           }\n           hir::ExprType(ref e, ref t) => {\n             let typ = self.to_ty(&t);\n             self.check_expr_eq_type(&e, typ);\n-            self.write_ty(id, typ);\n+            typ\n           }\n           hir::ExprVec(ref args) => {\n             let uty = expected.to_option(self).and_then(|uty| {\n@@ -3617,16 +3582,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let coerce_to = uty.unwrap_or(unified);\n \n             for (i, e) in args.iter().enumerate() {\n-                self.check_expr_with_hint(e, coerce_to);\n-                let e_ty = self.expr_ty(e);\n+                let e_ty = self.check_expr_with_hint(e, coerce_to);\n                 let origin = TypeOrigin::Misc(e.span);\n \n                 // Special-case the first element, as it has no \"previous expressions\".\n                 let result = if i == 0 {\n-                    self.try_coerce(e, coerce_to)\n+                    self.try_coerce(e, e_ty, coerce_to)\n                 } else {\n                     let prev_elems = || args[..i].iter().map(|e| &**e);\n-                    self.try_find_coercion_lub(origin, prev_elems, unified, e)\n+                    self.try_find_coercion_lub(origin, prev_elems, unified, e, e_ty)\n                 };\n \n                 match result {\n@@ -3636,7 +3600,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            self.write_ty(id, tcx.mk_array(unified, args.len()));\n+            tcx.mk_array(unified, args.len())\n           }\n           hir::ExprRepeat(ref element, ref count_expr) => {\n             self.check_expr_has_type(&count_expr, tcx.types.usize);\n@@ -3660,8 +3624,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 None => {\n                     let t: Ty = self.next_ty_var();\n-                    self.check_expr_has_type(&element, t);\n-                    (self.expr_ty(&element), t)\n+                    let element_ty = self.check_expr_has_type(&element, t);\n+                    (element_ty, t)\n                 }\n             };\n \n@@ -3672,10 +3636,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             if element_ty.references_error() {\n-                self.write_error(id);\n+                tcx.types.err\n             } else {\n-                let t = tcx.mk_array(t, count);\n-                self.write_ty(id, t);\n+                tcx.mk_array(t, count)\n             }\n           }\n           hir::ExprTup(ref elts) => {\n@@ -3695,49 +3658,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         ety\n                     }\n                     _ => {\n-                        self.check_expr_with_expectation(&e, NoExpectation);\n-                        self.expr_ty(&e)\n+                        self.check_expr_with_expectation(&e, NoExpectation)\n                     }\n                 };\n                 err_field = err_field || t.references_error();\n                 t\n             }).collect();\n             if err_field {\n-                self.write_error(id);\n+                tcx.types.err\n             } else {\n-                let typ = tcx.mk_tup(elt_ts);\n-                self.write_ty(id, typ);\n+                tcx.mk_tup(elt_ts)\n             }\n           }\n           hir::ExprStruct(ref path, ref fields, ref base_expr) => {\n-            self.check_expr_struct(expr, path, fields, base_expr);\n-\n-            self.require_expr_have_sized_type(expr, traits::StructInitializerSized);\n+            self.check_expr_struct(expr, path, fields, base_expr)\n           }\n           hir::ExprField(ref base, ref field) => {\n-            self.check_field(expr, lvalue_pref, &base, field);\n+            self.check_field(expr, lvalue_pref, &base, field)\n           }\n           hir::ExprTupField(ref base, idx) => {\n-            self.check_tup_field(expr, lvalue_pref, &base, idx);\n+            self.check_tup_field(expr, lvalue_pref, &base, idx)\n           }\n           hir::ExprIndex(ref base, ref idx) => {\n-              self.check_expr_with_lvalue_pref(&base, lvalue_pref);\n-              self.check_expr(&idx);\n-\n-              let base_t = self.expr_ty(&base);\n-              let idx_t = self.expr_ty(&idx);\n+              let base_t = self.check_expr_with_lvalue_pref(&base, lvalue_pref);\n+              let idx_t = self.check_expr(&idx);\n \n               if base_t.references_error() {\n-                  self.write_ty(id, base_t);\n+                  base_t\n               } else if idx_t.references_error() {\n-                  self.write_ty(id, idx_t);\n+                  idx_t\n               } else {\n                   let base_t = self.structurally_resolved_type(expr.span, base_t);\n                   match self.lookup_indexing(expr, base, base_t, idx_t, lvalue_pref) {\n                       Some((index_ty, element_ty)) => {\n-                          let idx_expr_ty = self.expr_ty(idx);\n-                          self.demand_eqtype(expr.span, index_ty, idx_expr_ty);\n-                          self.write_ty(id, element_ty);\n+                          self.demand_eqtype(expr.span, index_ty, idx_t);\n+                          element_ty\n                       }\n                       None => {\n                           self.check_expr_has_type(&idx, self.tcx.types.err);\n@@ -3773,18 +3728,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               }\n                           }\n                           err.emit();\n-                          self.write_ty(id, self.tcx().types.err);\n+                          self.tcx().types.err\n                       }\n                   }\n               }\n            }\n         }\n-\n-        debug!(\"type of expr({}) {} is...\", expr.id,\n-               pprust::expr_to_string(expr));\n-        debug!(\"... {:?}, expected is {:?}\",\n-               self.expr_ty(expr),\n-               expected);\n     }\n \n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n@@ -3864,7 +3813,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_decl_initializer(&self,\n                                   local: &'gcx hir::Local,\n-                                  init: &'gcx hir::Expr)\n+                                  init: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n         let ref_bindings = self.tcx.pat_contains_ref_binding(&local.pat);\n \n@@ -3878,21 +3827,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // referent for the reference that results is *equal to* the\n             // type of the lvalue it is referencing, and not some\n             // supertype thereof.\n-            self.check_expr_with_lvalue_pref(init, LvaluePreference::from_mutbl(m));\n-            let init_ty = self.expr_ty(init);\n+            let init_ty = self.check_expr_with_lvalue_pref(init, LvaluePreference::from_mutbl(m));\n             self.demand_eqtype(init.span, init_ty, local_ty);\n+            init_ty\n         } else {\n             self.check_expr_coercable_to_type(init, local_ty)\n-        };\n+        }\n     }\n \n     pub fn check_decl_local(&self, local: &'gcx hir::Local)  {\n         let t = self.local_ty(local.span, local.id);\n         self.write_ty(local.id, t);\n \n         if let Some(ref init) = local.init {\n-            self.check_decl_initializer(local, &init);\n-            let init_ty = self.expr_ty(&init);\n+            let init_ty = self.check_decl_initializer(local, &init);\n             if init_ty.references_error() {\n                 self.write_ty(local.id, init_ty);\n             }\n@@ -3905,7 +3853,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn check_stmt(&self, stmt: &'gcx hir::Stmt)  {\n+    pub fn check_stmt(&self, stmt: &'gcx hir::Stmt) {\n         let node_id;\n         let mut saw_bot = false;\n         let mut saw_err = false;\n@@ -3925,17 +3873,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::StmtExpr(ref expr, id) => {\n             node_id = id;\n             // Check with expected type of ()\n-            self.check_expr_has_type(&expr, self.tcx.mk_nil());\n-            let expr_ty = self.expr_ty(&expr);\n-            saw_bot = saw_bot || self.type_var_diverges(expr_ty);\n-            saw_err = saw_err || expr_ty.references_error();\n+            let ty = self.check_expr_has_type(&expr, self.tcx.mk_nil());\n+            saw_bot = saw_bot || self.type_var_diverges(ty);\n+            saw_err = saw_err || ty.references_error();\n           }\n           hir::StmtSemi(ref expr, id) => {\n             node_id = id;\n-            self.check_expr(&expr);\n-            let expr_ty = self.expr_ty(&expr);\n-            saw_bot |= self.type_var_diverges(expr_ty);\n-            saw_err |= expr_ty.references_error();\n+            let ty = self.check_expr(&expr);\n+            saw_bot |= self.type_var_diverges(ty);\n+            saw_err |= ty.references_error();\n           }\n         }\n         if saw_bot {\n@@ -3945,13 +3891,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.write_error(node_id);\n         }\n         else {\n-            self.write_nil(node_id)\n+            self.write_nil(node_id);\n         }\n     }\n \n     pub fn check_block_no_value(&self, blk: &'gcx hir::Block)  {\n-        self.check_block_with_expected(blk, ExpectHasType(self.tcx.mk_nil()));\n-        let blkty = self.node_ty(blk.id);\n+        let blkty = self.check_block_with_expected(blk, ExpectHasType(self.tcx.mk_nil()));\n         if blkty.references_error() {\n             self.write_error(blk.id);\n         } else {\n@@ -3962,7 +3907,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_block_with_expected(&self,\n                                  blk: &'gcx hir::Block,\n-                                 expected: Expectation<'tcx>) {\n+                                 expected: Expectation<'tcx>) -> Ty<'tcx> {\n         let prev = {\n             let mut fcx_ps = self.ps.borrow_mut();\n             let unsafety_state = fcx_ps.recurse(blk);\n@@ -3999,13 +3944,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                            s_ty.is_never();\n             any_err = any_err || s_ty.references_error();\n         }\n-        match blk.expr {\n+        let ty = match blk.expr {\n             None => if any_err {\n-                self.write_error(blk.id);\n+                self.tcx.types.err\n             } else if any_diverges {\n-                self.write_ty(blk.id, self.next_diverging_ty_var());\n+                self.next_diverging_ty_var()\n             } else {\n-                self.write_nil(blk.id);\n+                self.tcx.mk_nil()\n             },\n             Some(ref e) => {\n                 if any_diverges && !warned {\n@@ -4022,22 +3967,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         ety\n                     }\n                     _ => {\n-                        self.check_expr_with_expectation(&e, expected);\n-                        self.expr_ty(&e)\n+                        self.check_expr_with_expectation(&e, expected)\n                     }\n                 };\n \n                 if any_err {\n-                    self.write_error(blk.id);\n+                    self.tcx.types.err\n                 } else if any_diverges {\n-                    self.write_ty(blk.id, self.next_diverging_ty_var());\n+                    self.next_diverging_ty_var()\n                 } else {\n-                    self.write_ty(blk.id, ety);\n+                    ety\n                 }\n             }\n         };\n+        self.write_ty(blk.id, ty);\n \n         *self.ps.borrow_mut() = prev;\n+        ty\n     }\n \n     // Instantiates the given path, which must refer to an item with the given\n@@ -4348,7 +4294,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n-        self.write_ty(node_id, ty_substituted);\n         self.write_substs(node_id, ty::ItemSubsts {\n             substs: substs\n         });"}, {"sha": "411bd7e7b5ca121a60f47ce1b2ff602cb83ce8e8", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc448f8c29d0262f2cde76a9d21343921b23fd/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=58dc448f8c29d0262f2cde76a9d21343921b23fd", "patch": "@@ -23,21 +23,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               expr: &'gcx hir::Expr,\n                               op: hir::BinOp,\n                               lhs_expr: &'gcx hir::Expr,\n-                              rhs_expr: &'gcx hir::Expr)\n+                              rhs_expr: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n-        self.check_expr_with_lvalue_pref(lhs_expr, PreferMutLvalue);\n+        let lhs_ty = self.check_expr_with_lvalue_pref(lhs_expr, PreferMutLvalue);\n \n-        let lhs_ty = self.resolve_type_vars_with_obligations(self.expr_ty(lhs_expr));\n+        let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n         let (rhs_ty, return_ty) =\n             self.check_overloaded_binop(expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::Yes);\n         let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n \n-        if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n+        let ty = if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var()\n+                    && is_builtin_binop(lhs_ty, rhs_ty, op) {\n             self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n-            self.write_nil(expr.id);\n+            self.tcx.mk_nil()\n         } else {\n-            self.write_ty(expr.id, return_ty);\n-        }\n+            return_ty\n+        };\n \n         let tcx = self.tcx;\n         if !tcx.expr_is_lval(lhs_expr) {\n@@ -49,14 +50,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 &format!(\"invalid expression for left-hand side\"))\n             .emit();\n         }\n+        ty\n     }\n \n     /// Check a potentially overloaded binary operator.\n     pub fn check_binop(&self,\n                        expr: &'gcx hir::Expr,\n                        op: hir::BinOp,\n                        lhs_expr: &'gcx hir::Expr,\n-                       rhs_expr: &'gcx hir::Expr)\n+                       rhs_expr: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n         let tcx = self.tcx;\n \n@@ -67,15 +69,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                lhs_expr,\n                rhs_expr);\n \n-        self.check_expr(lhs_expr);\n-        let lhs_ty = self.resolve_type_vars_with_obligations(self.expr_ty(lhs_expr));\n+        let lhs_ty = self.check_expr(lhs_expr);\n+        let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n \n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n                 // && and || are a simple case.\n                 self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n                 self.check_expr_coercable_to_type(rhs_expr, tcx.mk_bool());\n-                self.write_ty(expr.id, tcx.mk_bool());\n+                tcx.mk_bool()\n             }\n             _ => {\n                 // Otherwise, we always treat operators as if they are\n@@ -107,7 +109,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n                 }\n \n-                self.write_ty(expr.id, return_ty);\n+                return_ty\n             }\n         }\n     }"}]}