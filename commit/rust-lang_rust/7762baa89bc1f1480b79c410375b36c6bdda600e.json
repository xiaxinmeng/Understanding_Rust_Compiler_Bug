{"sha": "7762baa89bc1f1480b79c410375b36c6bdda600e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NjJiYWE4OWJjMWYxNDgwYjc5YzQxMDM3NWIzNmM2YmRkYTYwMGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-15T17:36:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-15T17:36:26Z"}, "message": "auto merge of #12282 : cmr/rust/cleanup-ptr, r=huonw", "tree": {"sha": "aed999c85af0ef7e8552a56a08cbb784e5b7a0c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aed999c85af0ef7e8552a56a08cbb784e5b7a0c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7762baa89bc1f1480b79c410375b36c6bdda600e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7762baa89bc1f1480b79c410375b36c6bdda600e", "html_url": "https://github.com/rust-lang/rust/commit/7762baa89bc1f1480b79c410375b36c6bdda600e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7762baa89bc1f1480b79c410375b36c6bdda600e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7aa4c477e7ccc51f19805c42b74cf22dfe22c39", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7aa4c477e7ccc51f19805c42b74cf22dfe22c39", "html_url": "https://github.com/rust-lang/rust/commit/a7aa4c477e7ccc51f19805c42b74cf22dfe22c39"}, {"sha": "254c155fca415359d998e79e9989b4219136ccdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/254c155fca415359d998e79e9989b4219136ccdc", "html_url": "https://github.com/rust-lang/rust/commit/254c155fca415359d998e79e9989b4219136ccdc"}], "stats": {"total": 356, "additions": 137, "deletions": 219}, "files": [{"sha": "c279ff314b474454dc961a5c2fa4949610c88eaa", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -229,7 +229,7 @@ impl<T: Send> Drop for Unique<T> {\n             let x = mem::uninit(); // dummy value to swap in\n             // We need to move the object out of the box, so that\n             // the destructor is called (at the end of this scope.)\n-            ptr::replace_ptr(self.ptr, x);\n+            ptr::replace(self.ptr, x);\n             free(self.ptr as *mut c_void)\n         }\n     }\n@@ -306,7 +306,7 @@ which would call back to `callback()` in Rust.\n The former example showed how a global function can be called from C code.\n However it is often desired that the callback is targetted to a special\n Rust object. This could be the object that represents the wrapper for the\n-respective C object. \n+respective C object.\n \n This can be achieved by passing an unsafe pointer to the object down to the\n C library. The C library can then include the pointer to the Rust object in\n@@ -335,7 +335,7 @@ extern {\n fn main() {\n     // Create the object that will be referenced in the callback\n     let rust_object = ~RustObject{a: 5, ...};\n-     \n+\n     unsafe {\n         // Gets a raw pointer to the object\n         let target_addr:*RustObject = ptr::to_unsafe_ptr(rust_object);\n@@ -380,8 +380,8 @@ Rust is to use channels (in `std::comm`) to forward data from the C thread\n that invoked the callback into a Rust task.\n \n If an asychronous callback targets a special object in the Rust address space\n-it is also absolutely necessary that no more callbacks are performed by the \n-C library after the respective Rust object gets destroyed. \n+it is also absolutely necessary that no more callbacks are performed by the\n+C library after the respective Rust object gets destroyed.\n This can be achieved by unregistering the callback in the object's\n destructor and designing the library in a way that guarantees that no\n callback will be performed after unregistration."}, {"sha": "28e7b9460dc7aee9571b64829d2d491d81ee2fd7", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -83,7 +83,7 @@ impl<T> Rawlink<T> {\n \n     /// Like Option::Some for Rawlink\n     fn some(n: &mut T) -> Rawlink<T> {\n-        Rawlink{p: ptr::to_mut_unsafe_ptr(n)}\n+        Rawlink{p: n}\n     }\n \n     /// Convert the `Rawlink` into an Option value"}, {"sha": "374f49a36be5e7144ebb6d431646a1d3f62d6254", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -33,7 +33,6 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::hashmap::{HashMap, HashSet};\n use std::ops;\n-use std::ptr::to_unsafe_ptr;\n use std::rc::Rc;\n use std::to_bytes;\n use std::to_str::ToStr;\n@@ -1137,7 +1136,7 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n         _ => {}\n     };\n \n-    let key = intern_key { sty: to_unsafe_ptr(&st) };\n+    let key = intern_key { sty: &st };\n \n     {\n         let mut interner = cx.interner.borrow_mut();\n@@ -1234,7 +1233,7 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n         flags: flags,\n     };\n \n-    let sty_ptr = to_unsafe_ptr(&t.sty);\n+    let sty_ptr = &t.sty as *sty;\n \n     let key = intern_key {\n         sty: sty_ptr,"}, {"sha": "cfcb467d7aa64e63967bc42728c9e7f2c462894a", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -1200,7 +1200,17 @@ impl<T> Pointer for *T {\n }\n impl<T> Pointer for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer(&(*self as *T), f)\n+        secret_pointer::<*T>(&(*self as *T), f)\n+    }\n+}\n+impl<'a, T> Pointer for &'a T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_pointer::<*T>(&(&**self as *T), f)\n+    }\n+}\n+impl<'a, T> Pointer for &'a mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_pointer::<*T>(&(&**self as *T), f)\n     }\n }\n "}, {"sha": "04ecb479060c4e46f68acfbe7782f64b7c4646a5", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -155,17 +155,15 @@ mod darwin_fd_limit {\n     pub unsafe fn raise_fd_limit() {\n         // The strategy here is to fetch the current resource limits, read the kern.maxfilesperproc\n         // sysctl value, and bump the soft resource limit for maxfiles up to the sysctl value.\n-        use ptr::{to_unsafe_ptr, to_mut_unsafe_ptr, mut_null};\n+        use ptr::mut_null;\n         use mem::size_of_val;\n         use os::last_os_error;\n \n         // Fetch the kern.maxfilesperproc value\n         let mut mib: [libc::c_int, ..2] = [CTL_KERN, KERN_MAXFILESPERPROC];\n         let mut maxfiles: libc::c_int = 0;\n         let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n-        if sysctl(to_mut_unsafe_ptr(&mut mib[0]), 2,\n-                  to_mut_unsafe_ptr(&mut maxfiles) as *mut libc::c_void,\n-                  to_mut_unsafe_ptr(&mut size),\n+        if sysctl(&mut mib[0], 2, &mut maxfiles as *mut libc::c_int as *mut libc::c_void, &mut size,\n                   mut_null(), 0) != 0 {\n             let err = last_os_error();\n             error!(\"raise_fd_limit: error calling sysctl: {}\", err);\n@@ -174,7 +172,7 @@ mod darwin_fd_limit {\n \n         // Fetch the current resource limits\n         let mut rlim = rlimit{rlim_cur: 0, rlim_max: 0};\n-        if getrlimit(RLIMIT_NOFILE, to_mut_unsafe_ptr(&mut rlim)) != 0 {\n+        if getrlimit(RLIMIT_NOFILE, &mut rlim) != 0 {\n             let err = last_os_error();\n             error!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n             return;\n@@ -184,7 +182,7 @@ mod darwin_fd_limit {\n         rlim.rlim_cur = ::cmp::min(maxfiles as rlim_t, rlim.rlim_max);\n \n         // Set our newly-increased resource limit\n-        if setrlimit(RLIMIT_NOFILE, to_unsafe_ptr(&rlim)) != 0 {\n+        if setrlimit(RLIMIT_NOFILE, &rlim) != 0 {\n             let err = last_os_error();\n             error!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n             return;"}, {"sha": "63196cd4f162efdb4261f007bc01f64567e57140", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -10,8 +10,6 @@\n \n //! Operations on managed box types\n \n-use ptr::to_unsafe_ptr;\n-\n #[cfg(not(test))] use cmp::*;\n \n /// Returns the refcount of a shared box (as just before calling this)\n@@ -24,8 +22,7 @@ pub fn refcount<T>(t: @T) -> uint {\n /// Determine if two shared boxes point to the same object\n #[inline]\n pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n-    let (a_ptr, b_ptr): (*T, *T) = (to_unsafe_ptr(&*a), to_unsafe_ptr(&*b));\n-    a_ptr == b_ptr\n+    &*a as *T == &*b as *T\n }\n \n #[cfg(not(test))]"}, {"sha": "037984d9e7fc775d1948f38976431fcd411551ef", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 36, "deletions": 74, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -102,10 +102,10 @@ pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n \n /**\n  * Swap the values at two mutable locations of the same type, without\n- * deinitialising or copying either one.\n+ * deinitialising either. They may overlap.\n  */\n #[inline]\n-pub unsafe fn swap_ptr<T>(x: *mut T, y: *mut T) {\n+pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n     let mut tmp: T = mem::uninit();\n     let t: *mut T = &mut tmp;\n@@ -122,19 +122,19 @@ pub unsafe fn swap_ptr<T>(x: *mut T, y: *mut T) {\n \n /**\n  * Replace the value at a mutable location with a new one, returning the old\n- * value, without deinitialising or copying either one.\n+ * value, without deinitialising either.\n  */\n #[inline]\n-pub unsafe fn replace_ptr<T>(dest: *mut T, mut src: T) -> T {\n+pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n     mem::swap(cast::transmute(dest), &mut src); // cannot overlap\n     src\n }\n \n /**\n- * Reads the value from `*src` and returns it. Does not copy `*src`.\n+ * Reads the value from `*src` and returns it.\n  */\n #[inline(always)]\n-pub unsafe fn read_ptr<T>(src: *T) -> T {\n+pub unsafe fn read<T>(src: *T) -> T {\n     let mut tmp: T = mem::uninit();\n     copy_nonoverlapping_memory(&mut tmp, src, 1);\n     tmp\n@@ -145,28 +145,16 @@ pub unsafe fn read_ptr<T>(src: *T) -> T {\n  * This currently prevents destructors from executing.\n  */\n #[inline(always)]\n-pub unsafe fn read_and_zero_ptr<T>(dest: *mut T) -> T {\n+pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n-    let tmp = read_ptr(&*dest);\n+    let tmp = read(&*dest);\n \n     // Now zero out `dest`:\n     zero_memory(dest, 1);\n \n     tmp\n }\n \n-/// Transform a region pointer - &T - to an unsafe pointer - *T.\n-#[inline]\n-pub fn to_unsafe_ptr<T>(thing: &T) -> *T {\n-    thing as *T\n-}\n-\n-/// Transform a mutable region pointer - &mut T - to a mutable unsafe pointer - *mut T.\n-#[inline]\n-pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n-    thing as *mut T\n-}\n-\n /**\n   Given a **T (pointer to an array of pointers),\n   iterate through each *T, up to the provided `len`,\n@@ -176,7 +164,7 @@ pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n */\n pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n     debug!(\"array_each_with_len: before iterate\");\n-    if arr as uint == 0 {\n+    if arr.is_null() {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }\n     //let start_ptr = *arr;\n@@ -197,108 +185,82 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n   Dragons be here.\n */\n pub unsafe fn array_each<T>(arr: **T, cb: |*T|) {\n-    if arr as uint == 0 {\n+    if arr.is_null()  {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }\n     let len = buf_len(arr);\n     debug!(\"array_each inferred len: {}\", len);\n     array_each_with_len(arr, len, cb);\n }\n \n-#[allow(missing_doc)]\n+/// Extension methods for raw pointers.\n pub trait RawPtr<T> {\n+    /// Returns the null pointer.\n     fn null() -> Self;\n+    /// Returns true if the pointer is equal to the null pointer.\n     fn is_null(&self) -> bool;\n-    fn is_not_null(&self) -> bool;\n+    /// Returns true if the pointer is not equal to the null pointer.\n+    fn is_not_null(&self) -> bool { !self.is_null() }\n+    /// Returns the value of this pointer (ie, the address it points to)\n     fn to_uint(&self) -> uint;\n+    /// Returns `None` if the pointer is null, or else returns the value wrapped\n+    /// in `Some`.\n+    ///\n+    /// # Safety Notes\n+    ///\n+    /// While this method is useful for null-safety, it is important to note\n+    /// that this is still an unsafe operation because the returned value could\n+    /// be pointing to invalid memory.\n     unsafe fn to_option(&self) -> Option<&T>;\n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end.\n     unsafe fn offset(self, count: int) -> Self;\n }\n \n-/// Extension methods for immutable pointers\n impl<T> RawPtr<T> for *T {\n-    /// Returns the null pointer.\n     #[inline]\n     fn null() -> *T { null() }\n \n-    /// Returns true if the pointer is equal to the null pointer.\n     #[inline]\n     fn is_null(&self) -> bool { *self == RawPtr::null() }\n \n-    /// Returns true if the pointer is not equal to the null pointer.\n     #[inline]\n-    fn is_not_null(&self) -> bool { *self != RawPtr::null() }\n+    fn to_uint(&self) -> uint { *self as uint }\n \n-    /// Returns the address of this pointer.\n     #[inline]\n-    fn to_uint(&self) -> uint { *self as uint }\n+    unsafe fn offset(self, count: int) -> *T { intrinsics::offset(self, count) }\n \n-    ///\n-    /// Returns `None` if the pointer is null, or else returns the value wrapped\n-    /// in `Some`.\n-    ///\n-    /// # Safety Notes\n-    ///\n-    /// While this method is useful for null-safety, it is important to note\n-    /// that this is still an unsafe operation because the returned value could\n-    /// be pointing to invalid memory.\n-    ///\n     #[inline]\n     unsafe fn to_option(&self) -> Option<&T> {\n-        if self.is_null() { None } else {\n+        if self.is_null() {\n+            None\n+        } else {\n             Some(cast::transmute(*self))\n         }\n     }\n-\n-    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n-    /// the object, or one-byte-past-the-end.\n-    #[inline]\n-    unsafe fn offset(self, count: int) -> *T { intrinsics::offset(self, count) }\n }\n \n-/// Extension methods for mutable pointers\n impl<T> RawPtr<T> for *mut T {\n-    /// Returns the null pointer.\n     #[inline]\n     fn null() -> *mut T { mut_null() }\n \n-    /// Returns true if the pointer is equal to the null pointer.\n     #[inline]\n     fn is_null(&self) -> bool { *self == RawPtr::null() }\n \n-    /// Returns true if the pointer is not equal to the null pointer.\n     #[inline]\n-    fn is_not_null(&self) -> bool { *self != RawPtr::null() }\n+    fn to_uint(&self) -> uint { *self as uint }\n \n-    /// Returns the address of this pointer.\n     #[inline]\n-    fn to_uint(&self) -> uint { *self as uint }\n+    unsafe fn offset(self, count: int) -> *mut T { intrinsics::offset(self as *T, count) as *mut T }\n \n-    ///\n-    /// Returns `None` if the pointer is null, or else returns the value wrapped\n-    /// in `Some`.\n-    ///\n-    /// # Safety Notes\n-    ///\n-    /// While this method is useful for null-safety, it is important to note\n-    /// that this is still an unsafe operation because the returned value could\n-    /// be pointing to invalid memory.\n-    ///\n     #[inline]\n     unsafe fn to_option(&self) -> Option<&T> {\n-        if self.is_null() { None } else {\n+        if self.is_null() {\n+            None\n+        } else {\n             Some(cast::transmute(*self))\n         }\n     }\n-\n-    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n-    /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n-    /// undefined behaviour.\n-    ///\n-    /// This method should be preferred over `offset` when the guarantee can be\n-    /// satisfied, to enable better optimization.\n-    #[inline]\n-    unsafe fn offset(self, count: int) -> *mut T { intrinsics::offset(self as *T, count) as *mut T }\n }\n \n // Equality for pointers"}, {"sha": "ea3d5e0edac0186e3f04214c3a3ff1c0567dc67b", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -24,13 +24,13 @@ pointers, and then storing the parent pointers as `Weak` pointers.\n */\n \n use cast::transmute;\n-use ops::Drop;\n-use cmp::{Eq, Ord};\n use clone::{Clone, DeepClone};\n+use cmp::{Eq, Ord};\n use kinds::marker;\n-use rt::global_heap::exchange_free;\n-use ptr::read_ptr;\n+use ops::Drop;\n use option::{Option, Some, None};\n+use ptr;\n+use rt::global_heap::exchange_free;\n \n struct RcBox<T> {\n     value: T,\n@@ -85,7 +85,7 @@ impl<T> Drop for Rc<T> {\n             if self.ptr != 0 as *mut RcBox<T> {\n                 (*self.ptr).strong -= 1;\n                 if (*self.ptr).strong == 0 {\n-                    read_ptr(self.borrow()); // destroy the contained object\n+                    ptr::read(self.borrow()); // destroy the contained object\n \n                     // remove the implicit \"strong weak\" pointer now\n                     // that we've destroyed the contents."}, {"sha": "fb2053ddaf61594206962cec3d1f7e158e8c9f1a", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -22,7 +22,6 @@ use container::Container;\n use io;\n use iter::Iterator;\n use option::{Some, None, Option};\n-use ptr;\n use ptr::RawPtr;\n use reflect;\n use reflect::{MovePtr, align};\n@@ -230,7 +229,7 @@ impl<'a> ReprVisitor<'a> {\n     }\n \n     pub fn write_unboxed_vec_repr(&mut self, _: uint, v: &raw::Vec<()>, inner: *TyDesc) -> bool {\n-        self.write_vec_range(ptr::to_unsafe_ptr(&v.data), v.fill, inner)\n+        self.write_vec_range(&v.data, v.fill, inner)\n     }\n \n     fn write_escaped_char(&mut self, ch: char, is_str: bool) -> bool {\n@@ -319,7 +318,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         if_ok!(self, self.writer.write(['@' as u8]));\n         self.write_mut_qualifier(mtbl);\n         self.get::<&raw::Box<()>>(|this, b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *u8;\n+            let p = &b.data as *() as *u8;\n             this.visit_ptr_inner(p, inner)\n         })\n     }\n@@ -387,7 +386,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                         _: uint, inner: *TyDesc) -> bool {\n         let assumed_size = if sz == 0 { n } else { sz };\n         self.get::<()>(|this, b| {\n-            this.write_vec_range(ptr::to_unsafe_ptr(b), assumed_size, inner)\n+            this.write_vec_range(b, assumed_size, inner)\n         })\n     }\n \n@@ -606,7 +605,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n     unsafe {\n-        let ptr = ptr::to_unsafe_ptr(object) as *u8;\n+        let ptr = object as *T as *u8;\n         let tydesc = get_tydesc::<T>();\n         let u = ReprVisitor(ptr, writer);\n         let mut v = reflect::MovePtrAdaptor(u);"}, {"sha": "7ce760040e65ec0046b1ecc35665761e6cbff202", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -363,7 +363,7 @@ impl<T: Send> Buffer<T> {\n     // very unsafe method which the caller needs to treat specially in case a\n     // race is lost.\n     unsafe fn get(&self, i: int) -> T {\n-        ptr::read_ptr(self.storage.offset(i & self.mask()))\n+        ptr::read(self.storage.offset(i & self.mask()))\n     }\n \n     // Unsafe because this unsafely overwrites possibly uninitialized or"}, {"sha": "1cdf5998e8b203cfe1bf983d1b12ef6e41110e09", "filename": "src/libstd/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -509,10 +509,10 @@ fn avoid_copying_the_body(spawnfn: |v: proc()|) {\n     let (p, ch) = Chan::<uint>::new();\n \n     let x = ~1;\n-    let x_in_parent = ptr::to_unsafe_ptr(&*x) as uint;\n+    let x_in_parent = (&*x) as *int as uint;\n \n     spawnfn(proc() {\n-        let x_in_child = ptr::to_unsafe_ptr(&*x) as uint;\n+        let x_in_child = (&*x) as *int as uint;\n         ch.send(x_in_child);\n     });\n "}, {"sha": "f8f9f82b657a5830784598b5ad59b7a722ff1fc5", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -102,6 +102,7 @@ There are a number of free functions that create or take vectors, for example:\n #[warn(non_camel_case_types)];\n \n use cast;\n+use cast::transmute;\n use ops::Drop;\n use clone::{Clone, DeepClone};\n use container::{Container, Mutable};\n@@ -112,7 +113,6 @@ use default::Default;\n use iter::*;\n use num::{Integer, CheckedAdd, Saturating, checked_next_power_of_two};\n use option::{None, Option, Some};\n-use ptr::to_unsafe_ptr;\n use ptr;\n use ptr::RawPtr;\n use rt::global_heap::{malloc_raw, realloc_raw, exchange_free};\n@@ -188,7 +188,7 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n         let ptr = malloc_raw(size) as *mut Vec<()>;\n         (*ptr).alloc = alloc;\n         (*ptr).fill = 0;\n-        cast::transmute(ptr)\n+        transmute(ptr)\n     }\n }\n \n@@ -216,7 +216,7 @@ pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> ~[A] {\n  */\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n-        cast::transmute(Slice { data: s, len: 1 })\n+        transmute(Slice { data: s, len: 1 })\n     }\n }\n \n@@ -225,8 +225,8 @@ pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n  */\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n-        let ptr: *A = cast::transmute(s);\n-        cast::transmute(Slice { data: ptr, len: 1 })\n+        let ptr: *A = transmute(s);\n+        transmute(Slice { data: ptr, len: 1 })\n     }\n }\n \n@@ -991,7 +991,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n         unsafe {\n-            cast::transmute(Slice {\n+            transmute(Slice {\n                     data: self.as_ptr().offset(start as int),\n                     len: (end - start)\n                 })\n@@ -1109,7 +1109,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n \n     #[inline]\n     unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n-        cast::transmute(self.repr().data.offset(index as int))\n+        transmute(self.repr().data.offset(index as int))\n     }\n \n     #[inline]\n@@ -1144,15 +1144,15 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     fn shift_ref(&mut self) -> Option<&'a T> {\n         if self.len() == 0 { return None; }\n         unsafe {\n-            let s: &mut Slice<T> = cast::transmute(self);\n+            let s: &mut Slice<T> = transmute(self);\n             Some(&*raw::shift_ptr(s))\n         }\n     }\n \n     fn pop_ref(&mut self) -> Option<&'a T> {\n         if self.len() == 0 { return None; }\n         unsafe {\n-            let s: &mut Slice<T> = cast::transmute(self);\n+            let s: &mut Slice<T> = transmute(self);\n             Some(&*raw::pop_ptr(s))\n         }\n     }\n@@ -1417,8 +1417,8 @@ impl<T> OwnedVector<T> for ~[T] {\n     #[inline]\n     fn move_iter(self) -> MoveItems<T> {\n         unsafe {\n-            let iter = cast::transmute(self.iter());\n-            let ptr = cast::transmute(self);\n+            let iter = transmute(self.iter());\n+            let ptr = transmute(self);\n             MoveItems { allocation: ptr, iter: iter }\n         }\n     }\n@@ -1432,7 +1432,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         // Only make the (slow) call into the runtime if we have to\n         if self.capacity() < n {\n             unsafe {\n-                let ptr: *mut *mut Vec<()> = cast::transmute(self);\n+                let ptr: *mut *mut Vec<()> = transmute(self);\n                 let alloc = n * mem::nonzero_size_of::<T>();\n                 let size = alloc + mem::size_of::<Vec<()>>();\n                 if alloc / mem::nonzero_size_of::<T>() != n || size < alloc {\n@@ -1463,14 +1463,14 @@ impl<T> OwnedVector<T> for ~[T] {\n     #[inline]\n     fn capacity(&self) -> uint {\n         unsafe {\n-            let repr: **Vec<()> = cast::transmute(self);\n+            let repr: **Vec<()> = transmute(self);\n             (**repr).alloc / mem::nonzero_size_of::<T>()\n         }\n     }\n \n     fn shrink_to_fit(&mut self) {\n         unsafe {\n-            let ptr: *mut *mut Vec<()> = cast::transmute(self);\n+            let ptr: *mut *mut Vec<()> = transmute(self);\n             let alloc = (**ptr).fill;\n             let size = alloc + mem::size_of::<Vec<()>>();\n             *ptr = realloc_raw(*ptr as *mut u8, size) as *mut Vec<()>;\n@@ -1481,7 +1481,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     #[inline]\n     fn push(&mut self, t: T) {\n         unsafe {\n-            let repr: **Vec<()> = cast::transmute(&mut *self);\n+            let repr: **Vec<()> = transmute(&mut *self);\n             let fill = (**repr).fill;\n             if (**repr).alloc <= fill {\n                 self.reserve_additional(1);\n@@ -1493,10 +1493,10 @@ impl<T> OwnedVector<T> for ~[T] {\n         // This doesn't bother to make sure we have space.\n         #[inline] // really pretty please\n         unsafe fn push_fast<T>(this: &mut ~[T], t: T) {\n-            let repr: **mut Vec<u8> = cast::transmute(this);\n+            let repr: **mut Vec<u8> = transmute(this);\n             let fill = (**repr).fill;\n             (**repr).fill += mem::nonzero_size_of::<T>();\n-            let p = to_unsafe_ptr(&((**repr).data));\n+            let p = &((**repr).data) as *u8;\n             let p = p.offset(fill as int) as *mut T;\n             mem::move_val_init(&mut(*p), t);\n         }\n@@ -1521,10 +1521,10 @@ impl<T> OwnedVector<T> for ~[T] {\n         match self.len() {\n             0  => None,\n             ln => {\n-                let valptr = ptr::to_mut_unsafe_ptr(&mut self[ln - 1u]);\n+                let valptr = &mut self[ln - 1u] as *mut T;\n                 unsafe {\n                     self.set_len(ln - 1u);\n-                    Some(ptr::read_ptr(&*valptr))\n+                    Some(ptr::read(&*valptr))\n                 }\n             }\n         }\n@@ -1568,7 +1568,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                 let ptr = self.as_mut_ptr().offset(i as int);\n                 // copy it out, unsafely having a copy of the value on\n                 // the stack and in the vector at the same time.\n-                let ret = Some(ptr::read_ptr(ptr as *T));\n+                let ret = Some(ptr::read(ptr as *T));\n \n                 // Shift everything down to fill in that spot.\n                 ptr::copy_memory(ptr, &*ptr.offset(1), len - i - 1);\n@@ -1598,7 +1598,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             let p = self.as_mut_ptr();\n             // This loop is optimized out for non-drop types.\n             for i in range(newlen, oldlen) {\n-                ptr::read_and_zero_ptr(p.offset(i as int));\n+                ptr::read_and_zero(p.offset(i as int));\n             }\n         }\n         unsafe { self.set_len(newlen); }\n@@ -1648,7 +1648,7 @@ impl<T> OwnedVector<T> for ~[T] {\n \n     #[inline]\n     unsafe fn set_len(&mut self, new_len: uint) {\n-        let repr: **mut Vec<()> = cast::transmute(self);\n+        let repr: **mut Vec<()> = transmute(self);\n         (**repr).fill = new_len * mem::nonzero_size_of::<T>();\n     }\n }\n@@ -1844,7 +1844,7 @@ fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n             // `.offset(j)` is always in bounds.\n \n             if i != j {\n-                let tmp = ptr::read_ptr(read_ptr);\n+                let tmp = ptr::read(read_ptr);\n                 ptr::copy_memory(buf_v.offset(j + 1),\n                                  &*buf_v.offset(j),\n                                  (i - j) as uint);\n@@ -2269,7 +2269,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n         unsafe {\n-            cast::transmute(Slice {\n+            transmute(Slice {\n                     data: self.as_mut_ptr().offset(start as int) as *T,\n                     len: (end - start)\n                 })\n@@ -2338,15 +2338,15 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n         if self.len() == 0 { return None; }\n         unsafe {\n-            let s: &mut Slice<T> = cast::transmute(self);\n+            let s: &mut Slice<T> = transmute(self);\n             Some(cast::transmute_mut(&*raw::shift_ptr(s)))\n         }\n     }\n \n     fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n         if self.len() == 0 { return None; }\n         unsafe {\n-            let s: &mut Slice<T> = cast::transmute(self);\n+            let s: &mut Slice<T> = transmute(self);\n             Some(cast::transmute_mut(&*raw::pop_ptr(s)))\n         }\n     }\n@@ -2357,7 +2357,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n             // them to their raw pointers to do the swap\n             let pa: *mut T = &mut self[a];\n             let pb: *mut T = &mut self[b];\n-            ptr::swap_ptr(pa, pb);\n+            ptr::swap(pa, pb);\n         }\n     }\n \n@@ -2385,7 +2385,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n \n     #[inline]\n     unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n-        cast::transmute((self.repr().data as *mut T).offset(index as int))\n+        transmute((self.repr().data as *mut T).offset(index as int))\n     }\n \n     #[inline]\n@@ -2484,7 +2484,7 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n \n /// Unsafe operations\n pub mod raw {\n-    use cast;\n+    use cast::transmute;\n     use ptr;\n     use ptr::RawPtr;\n     use vec::{with_capacity, MutableVector, OwnedVector};\n@@ -2497,7 +2497,7 @@ pub mod raw {\n     #[inline]\n     pub unsafe fn buf_as_slice<T,U>(p: *T, len: uint, f: |v: &[T]| -> U)\n                                -> U {\n-        f(cast::transmute(Slice {\n+        f(transmute(Slice {\n             data: p,\n             len: len\n         }))\n@@ -2514,7 +2514,7 @@ pub mod raw {\n                                    len: uint,\n                                    f: |v: &mut [T]| -> U)\n                                    -> U {\n-        f(cast::transmute(Slice {\n+        f(transmute(Slice {\n             data: p as *T,\n             len: len\n         }))\n@@ -2698,12 +2698,12 @@ macro_rules! iterator {\n                             // purposefully don't use 'ptr.offset' because for\n                             // vectors with 0-size elements this would return the\n                             // same pointer.\n-                            cast::transmute(self.ptr as uint + 1)\n+                            transmute(self.ptr as uint + 1)\n                         } else {\n                             self.ptr.offset(1)\n                         };\n \n-                        Some(cast::transmute(old))\n+                        Some(transmute(old))\n                     }\n                 }\n             }\n@@ -2726,11 +2726,11 @@ macro_rules! iterator {\n                     } else {\n                         self.end = if mem::size_of::<T>() == 0 {\n                             // See above for why 'ptr.offset' isn't used\n-                            cast::transmute(self.end as uint - 1)\n+                            transmute(self.end as uint - 1)\n                         } else {\n                             self.end.offset(-1)\n                         };\n-                        Some(cast::transmute(self.end))\n+                        Some(transmute(self.end))\n                     }\n                 }\n             }\n@@ -2749,7 +2749,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     fn idx(&self, index: uint) -> Option<&'a T> {\n         unsafe {\n             if index < self.indexable() {\n-                cast::transmute(self.ptr.offset(index as int))\n+                transmute(self.ptr.offset(index as int))\n             } else {\n                 None\n             }\n@@ -2895,7 +2895,7 @@ impl<T> Iterator<T> for MoveItems<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> {\n         unsafe {\n-            self.iter.next().map(|x| ptr::read_ptr(x))\n+            self.iter.next().map(|x| ptr::read(x))\n         }\n     }\n \n@@ -2909,7 +2909,7 @@ impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         unsafe {\n-            self.iter.next_back().map(|x| ptr::read_ptr(x))\n+            self.iter.next_back().map(|x| ptr::read(x))\n         }\n     }\n }"}, {"sha": "a450aab127bc43be17d36fc4971ef9543aa0ede2", "filename": "src/libstd/vec_ng.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -22,7 +22,7 @@ use cast::{forget, transmute};\n use rt::global_heap::{malloc_raw, realloc_raw};\n use vec::{ImmutableVector, Items, MutableVector};\n use unstable::raw::Slice;\n-use ptr::read_ptr;\n+use ptr;\n use ptr::RawPtr;\n use libc::{free, c_void};\n \n@@ -117,7 +117,7 @@ impl<T> Vec<T> {\n         } else {\n             unsafe {\n                 self.len -= 1;\n-                Some(read_ptr(self.as_slice().unsafe_ref(self.len())))\n+                Some(ptr::read(self.as_slice().unsafe_ref(self.len())))\n             }\n         }\n     }\n@@ -147,7 +147,7 @@ impl<T> Vec<T> {\n             let mut i = len;\n             // drop any extra elements\n             while i < self.len {\n-                read_ptr(self.as_slice().unsafe_ref(i));\n+                ptr::read(self.as_slice().unsafe_ref(i));\n                 i += 1;\n             }\n         }\n@@ -188,7 +188,7 @@ impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         unsafe {\n             for x in self.as_mut_slice().iter() {\n-                read_ptr(x);\n+                ptr::read(x);\n             }\n             free(self.ptr as *mut c_void)\n         }\n@@ -204,7 +204,7 @@ impl<T> Iterator<T> for MoveItems<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> {\n         unsafe {\n-            self.iter.next().map(|x| read_ptr(x))\n+            self.iter.next().map(|x| ptr::read(x))\n         }\n     }\n \n@@ -218,7 +218,7 @@ impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         unsafe {\n-            self.iter.next_back().map(|x| read_ptr(x))\n+            self.iter.next_back().map(|x| ptr::read(x))\n         }\n     }\n }"}, {"sha": "799f5b4d5320cb5777dfcc6c0edaf641c873db7f", "filename": "src/test/compile-fail/issue-3096-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::ptr;\n-\n enum bottom { }\n \n fn main() {\n-    let x = ptr::to_unsafe_ptr(&()) as *bottom;\n+    let x = &() as *() as *bottom;\n     match x { } //~ ERROR non-exhaustive patterns\n }"}, {"sha": "4aedb4e96cfa32f845ed258724f8c3d77ff525bd", "filename": "src/test/run-pass/borrowck-borrow-from-expr-block.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -10,15 +10,13 @@\n \n #[feature(managed_boxes)];\n \n-use std::ptr;\n-\n fn borrow(x: &int, f: |x: &int|) {\n     f(x)\n }\n \n fn test1(x: @~int) {\n     borrow(&*(*x).clone(), |p| {\n-        let x_a = ptr::to_unsafe_ptr(&**x);\n+        let x_a = &**x as *int;\n         assert!((x_a as uint) != (p as *int as uint));\n         assert_eq!(unsafe{*x_a}, *p);\n     })"}, {"sha": "5cdda81c43604d436c5ff20dd0edf0205392b502", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -14,8 +14,6 @@\n \n #[feature(managed_boxes)];\n \n-use std::ptr;\n-\n fn borrow(x: &int, f: |x: &int|) {\n     let before = *x;\n     f(x);\n@@ -29,12 +27,11 @@ pub fn main() {\n     let mut x = @F {f: ~3};\n     borrow(x.f, |b_x| {\n         assert_eq!(*b_x, 3);\n-        assert_eq!(ptr::to_unsafe_ptr(&(*x.f)), ptr::to_unsafe_ptr(&(*b_x)));\n+        assert_eq!(&(*x.f) as *int, &(*b_x) as *int);\n         x = @F {f: ~4};\n \n-        info!(\"ptr::to_unsafe_ptr(*b_x) = {:x}\",\n-               ptr::to_unsafe_ptr(&(*b_x)) as uint);\n+        info!(\"&*b_x = {:p}\", &(*b_x));\n         assert_eq!(*b_x, 3);\n-        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(*b_x)));\n+        assert!(&(*x.f) as *int != &(*b_x) as *int);\n     })\n }"}, {"sha": "3050d6fa0113005172c991a250f4ed45877a0240", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -14,8 +14,6 @@\n \n #[feature(managed_boxes)];\n \n-use std::ptr;\n-\n fn borrow(x: &int, f: |x: &int|) {\n     let before = *x;\n     f(x);\n@@ -29,12 +27,11 @@ pub fn main() {\n     let mut x = ~@F{f: ~3};\n     borrow(x.f, |b_x| {\n         assert_eq!(*b_x, 3);\n-        assert_eq!(ptr::to_unsafe_ptr(&(*x.f)), ptr::to_unsafe_ptr(&(*b_x)));\n+        assert_eq!(&(*x.f) as *int, &(*b_x) as *int);\n         *x = @F{f: ~4};\n \n-        info!(\"ptr::to_unsafe_ptr(*b_x) = {:x}\",\n-               ptr::to_unsafe_ptr(&(*b_x)) as uint);\n+        info!(\"&*b_x = {:p}\", &(*b_x));\n         assert_eq!(*b_x, 3);\n-        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(*b_x)));\n+        assert!(&(*x.f) as *int != &(*b_x) as *int);\n     })\n }"}, {"sha": "76dfbffc09c0667d61df085d755fe1291766e791", "filename": "src/test/run-pass/borrowck-preserve-box.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -14,8 +14,6 @@\n \n #[feature(managed_boxes)];\n \n-use std::ptr;\n-\n fn borrow(x: &int, f: |x: &int|) {\n     let before = *x;\n     f(x);\n@@ -27,12 +25,11 @@ pub fn main() {\n     let mut x = @3;\n     borrow(x, |b_x| {\n         assert_eq!(*b_x, 3);\n-        assert_eq!(ptr::to_unsafe_ptr(&(*x)), ptr::to_unsafe_ptr(&(*b_x)));\n+        assert_eq!(&(*x) as *int, &(*b_x) as *int);\n         x = @22;\n \n-        info!(\"ptr::to_unsafe_ptr(*b_x) = {:x}\",\n-               ptr::to_unsafe_ptr(&(*b_x)) as uint);\n+        info!(\"&*b_x = {:p}\", &(*b_x));\n         assert_eq!(*b_x, 3);\n-        assert!(ptr::to_unsafe_ptr(&(*x)) != ptr::to_unsafe_ptr(&(*b_x)));\n+        assert!(&(*x) as *int != &(*b_x) as *int);\n     })\n }"}, {"sha": "00e59f5132db7eac0901b4ae8266fddc95a7f264", "filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -14,8 +14,6 @@\n \n #[feature(managed_boxes)];\n \n-use std::ptr;\n-\n fn borrow(x: &int, f: |x: &int|) {\n     let before = *x;\n     f(x);\n@@ -29,12 +27,11 @@ pub fn main() {\n     let mut x = @F {f: ~3};\n     borrow((*x).f, |b_x| {\n         assert_eq!(*b_x, 3);\n-        assert_eq!(ptr::to_unsafe_ptr(&(*x.f)), ptr::to_unsafe_ptr(&(*b_x)));\n+        assert_eq!(&(*x.f) as *int, &(*b_x) as *int);\n         x = @F {f: ~4};\n \n-        info!(\"ptr::to_unsafe_ptr(*b_x) = {:x}\",\n-               ptr::to_unsafe_ptr(&(*b_x)) as uint);\n+        info!(\"&*b_x = {:p}\", &(*b_x));\n         assert_eq!(*b_x, 3);\n-        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(*b_x)));\n+        assert!(&(*x.f) as *int != &(*b_x) as *int);\n     })\n }"}, {"sha": "1fa78628d8ae2f67610489704d9936e2966a3af8", "filename": "src/test/run-pass/cap-clause-move.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a7aa4c477e7ccc51f19805c42b74cf22dfe22c39/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7aa4c477e7ccc51f19805c42b74cf22dfe22c39/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs?ref=a7aa4c477e7ccc51f19805c42b74cf22dfe22c39", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::ptr;\n-\n-pub fn main() {\n-    let x = ~3;\n-    let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n-    let snd_move: proc() -> uint = proc() ptr::to_unsafe_ptr(&(*x)) as uint;\n-    assert_eq!(snd_move(), y);\n-\n-    let x = ~4;\n-    let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n-    let lam_move: proc() -> uint = proc() ptr::to_unsafe_ptr(&(*x)) as uint;\n-    assert_eq!(lam_move(), y);\n-}"}, {"sha": "87363c0e55e869ae3dbb366a88aef639366d7184", "filename": "src/test/run-pass/const-region-ptrs-noncopy.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::ptr;\n-\n type Big = [u64, ..8];\n struct Pair<'a> { a: int, b: &'a Big }\n static x: &'static Big = &([13, 14, 10, 13, 11, 14, 14, 15]);\n static y: &'static Pair<'static> = &Pair {a: 15, b: x};\n \n pub fn main() {\n-    assert_eq!(ptr::to_unsafe_ptr(x), ptr::to_unsafe_ptr(y.b));\n+    assert_eq!(x as *Big, y.b as *Big);\n }"}, {"sha": "5763c61379865a88fef04703b0a2b908a1b2420a", "filename": "src/test/run-pass/enum-alignment.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-alignment.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -9,12 +9,10 @@\n // except according to those terms.\n \n use std::cast;\n-use std::ptr;\n use std::mem;\n \n fn addr_of<T>(ptr: &T) -> uint {\n-    let ptr = ptr::to_unsafe_ptr(ptr);\n-    ptr as uint\n+    ptr as *T as uint\n }\n \n fn is_aligned<T>(ptr: &T) -> bool {"}, {"sha": "083d2e167a0757e54beb71f4cfa07b06831ee7ee", "filename": "src/test/run-pass/stable-addr-of.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -10,9 +10,7 @@\n \n // Issue #2040\n \n-use std::ptr;\n-\n pub fn main() {\n     let foo = 1;\n-    assert_eq!(ptr::to_unsafe_ptr(&foo), ptr::to_unsafe_ptr(&foo));\n+    assert_eq!(&foo as *int, &foo as *int);\n }"}, {"sha": "d9cf585ad6c0a293cf8835d67aa9695c7fa68f75", "filename": "src/test/run-pass/swap-overlapping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -25,7 +25,7 @@ pub fn main() {\n \n fn do_swap(test: &mut TestDescAndFn) {\n     unsafe {\n-        ptr::swap_ptr(test, test);\n+        ptr::swap(test, test);\n     }\n }\n "}, {"sha": "944c498ede37fd1436aeec696d2bf0a173b6d1ff", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::ptr;\n use std::task;\n \n pub fn main() {\n     let (p, ch) = Chan::<uint>::new();\n \n     let x = ~1;\n-    let x_in_parent = ptr::to_unsafe_ptr(&(*x)) as uint;\n+    let x_in_parent = &(*x) as *int as uint;\n \n     task::spawn(proc() {\n-        let x_in_child = ptr::to_unsafe_ptr(&(*x)) as uint;\n+        let x_in_child = &(*x) as *int as uint;\n         ch.send(x_in_child);\n     });\n "}, {"sha": "9efa6c1b9646ad754a64b2cf2d831a3d43901367", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7762baa89bc1f1480b79c410375b36c6bdda600e/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=7762baa89bc1f1480b79c410375b36c6bdda600e", "patch": "@@ -11,7 +11,6 @@\n #[feature(managed_boxes)];\n \n use std::cell::RefCell;\n-use std::ptr;\n \n enum maybe_pointy {\n     none,\n@@ -24,7 +23,7 @@ struct Pointy {\n }\n \n fn make_uniq_closure<A:Send>(a: A) -> proc() -> uint {\n-    let result: proc() -> uint = proc() ptr::to_unsafe_ptr(&a) as uint;\n+    let result: proc() -> uint = proc() &a as *A as uint;\n     result\n }\n "}]}