{"sha": "ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMTJiN2IzMDhjZjc5YTYxZTRmNTc4ZTZmMjFiNTFmZmQ1MzVlMWE=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-21T01:15:52Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-21T01:15:52Z"}, "message": "Rollup merge of #24571 - steveklabnik:editing, r=alexcrichton\n\nA bunch of chapters, fixes an issue or two as well.\r\n\r\nr? @alexcrichton", "tree": {"sha": "297e5abf782263f625dc89ead9e9e68b5dd9394c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/297e5abf782263f625dc89ead9e9e68b5dd9394c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "html_url": "https://github.com/rust-lang/rust/commit/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de13f95f2133e54a8a9d68d55daddbf4c399f1ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/de13f95f2133e54a8a9d68d55daddbf4c399f1ab", "html_url": "https://github.com/rust-lang/rust/commit/de13f95f2133e54a8a9d68d55daddbf4c399f1ab"}, {"sha": "14af25797f99cb70379669fe17092fabcae6fabc", "url": "https://api.github.com/repos/rust-lang/rust/commits/14af25797f99cb70379669fe17092fabcae6fabc", "html_url": "https://github.com/rust-lang/rust/commit/14af25797f99cb70379669fe17092fabcae6fabc"}], "stats": {"total": 907, "additions": 404, "deletions": 503}, "files": [{"sha": "ec886899e6fe931ddd500676a76e6cd698058bd1", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "patch": "@@ -14,7 +14,6 @@\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n     * [FFI](ffi.md)\n-    * [Deref coercions](deref-coercions.md)\n * [Syntax and Semantics](syntax-and-semantics.md)\n     * [Variable Bindings](variable-bindings.md)\n     * [Functions](functions.md)\n@@ -30,15 +29,15 @@\n     * [Move semantics](move-semantics.md)\n     * [Enums](enums.md)\n     * [Match](match.md)\n-    * [Patterns](patterns.md)\n     * [Structs](structs.md)\n+    * [Patterns](patterns.md)\n     * [Method Syntax](method-syntax.md)\n-    * [Drop](drop.md)\n     * [Vectors](vectors.md)\n     * [Strings](strings.md)\n+    * [Generics](generics.md)\n     * [Traits](traits.md)\n     * [Operators and Overloading](operators-and-overloading.md)\n-    * [Generics](generics.md)\n+    * [Drop](drop.md)\n     * [if let](if-let.md)\n     * [Trait Objects](trait-objects.md)\n     * [Closures](closures.md)\n@@ -53,6 +52,7 @@\n     * [Casting between types](casting-between-types.md)\n     * [Associated Types](associated-types.md)\n     * [Unsized Types](unsized-types.md)\n+    * [Deref coercions](deref-coercions.md)\n     * [Macros](macros.md)\n     * [`unsafe` Code](unsafe-code.md)\n * [Nightly Rust](nightly-rust.md)"}, {"sha": "80ea25eb35ce92125c82027c7275bf10bba3353e", "filename": "src/doc/trpl/enums.md", "status": "modified", "additions": 25, "deletions": 104, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fenums.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fenums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fenums.md?ref=ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "patch": "@@ -1,11 +1,9 @@\n % Enums\n \n-Finally, Rust has a \"sum type\", an *enum*. Enums are an incredibly useful\n-feature of Rust, and are used throughout the standard library. An `enum` is\n-a type which relates a set of alternates to a specific name. For example, below\n-we define `Character` to be either a `Digit` or something else. These\n-can be used via their fully scoped names: `Character::Other` (more about `::`\n-below).\n+Rust has a \u2018sum type\u2019, an `enum`. Enums are an incredibly useful feature of\n+Rust, and are used throughout the standard library. An `enum` is a type which\n+relates a set of alternates to a specific name. For example, below we define\n+`Character` to be either a `Digit` or something else.\n \n ```rust\n enum Character {\n@@ -14,14 +12,14 @@ enum Character {\n }\n ```\n \n-Most normal types are allowed as the variant components of an `enum`. Here are\n-some examples:\n+Most types are allowed as the variant components of an `enum`. Here are some\n+examples:\n \n ```rust\n struct Empty;\n struct Color(i32, i32, i32);\n struct Length(i32);\n-struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n+struct Stats { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n struct HeightDatabase(Vec<i32>);\n ```\n \n@@ -30,12 +28,12 @@ In `Character`, for instance, `Digit` gives a meaningful name for an `i32`\n value, where `Other` is only a name. However, the fact that they represent\n distinct categories of `Character` is a very useful property.\n \n-As with structures, the variants of an enum by default are not comparable with\n-equality operators (`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not\n-support other binary operations such as `*` and `+`. As such, the following code\n-is invalid for the example `Character` type:\n+The variants of an `enum` by default are not comparable with equality operators\n+(`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not support other\n+binary operations such as `*` and `+`. As such, the following code is invalid\n+for the example `Character` type:\n \n-```{rust,ignore}\n+```rust,ignore\n // These assignments both succeed\n let ten  = Character::Digit(10);\n let four = Character::Digit(4);\n@@ -50,98 +48,21 @@ let four_is_smaller = four <= ten;\n let four_equals_ten = four == ten;\n ```\n \n-This may seem rather limiting, but it's a limitation which we can overcome.\n-There are two ways: by implementing equality ourselves, or by pattern matching\n-variants with [`match`][match] expressions, which you'll learn in the next\n-chapter. We don't know enough about Rust to implement equality yet, but we can\n-use the `Ordering` enum from the standard library, which does:\n+We use the `::` syntax to use the name of each variant: They\u2019re scoped by the name\n+of the `enum` itself. This allows both of these to work:\n \n-```\n-enum Ordering {\n-    Less,\n-    Equal,\n-    Greater,\n-}\n-```\n-\n-Because `Ordering` has already been defined for us, we will import it with the\n-`use` keyword. Here's an example of how it is used:\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y); // ordering: Ordering\n-\n-    if ordering == Ordering::Less {\n-        println!(\"less\");\n-    } else if ordering == Ordering::Greater {\n-        println!(\"greater\");\n-    } else if ordering == Ordering::Equal {\n-        println!(\"equal\");\n-    }\n-}\n-```\n-\n-The `::` symbol is used to indicate a namespace. In this case, `Ordering` lives\n-in the `cmp` submodule of the `std` module. We'll talk more about modules later\n-in the guide. For now, all you need to know is that you can `use` things from\n-the standard library if you need them.\n-\n-Okay, let's talk about the actual code in the example. `cmp` is a function that\n-compares two things, and returns an `Ordering`. We return either\n-`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on\n-whether the first value is less than, greater than, or equal to the second. Note\n-that each variant of the `enum` is namespaced under the `enum` itself: it's\n-`Ordering::Greater`, not `Greater`.\n-\n-The `ordering` variable has the type `Ordering`, and so contains one of the\n-three values. We then do a bunch of `if`/`else` comparisons to check which\n-one it is.\n-\n-This `Ordering::Greater` notation is too long. Let's use another form of `use`\n-to import the `enum` variants instead. This will avoid full scoping:\n-\n-```{rust}\n-use std::cmp::Ordering::{self, Equal, Less, Greater};\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y); // ordering: Ordering\n-\n-    if ordering == Less { println!(\"less\"); }\n-    else if ordering == Greater { println!(\"greater\"); }\n-    else if ordering == Equal { println!(\"equal\"); }\n-}\n+```rust,ignore\n+Character::Digit(10);\n+Hand::Digit;\n ```\n \n-Importing variants is convenient and compact, but can also cause name conflicts,\n-so do this with caution. For this reason, it's normally considered better style\n-to `use` an enum rather than its variants directly.\n+Both variants are named `Digit`, but since they\u2019re scoped to the `enum` name,\n \n-As you can see, `enum`s are quite a powerful tool for data representation, and\n-are even more useful when they're [generic][generics] across types. Before we\n-get to generics, though, let's talk about how to use enums with pattern\n-matching, a tool that will let us deconstruct sum types (the type theory term\n-for enums) like `Ordering` in a very elegant way that avoids all these messy\n-and brittle `if`/`else`s.\n+Not supporting these operations may seem rather limiting, but it\u2019s a limitation\n+which we can overcome. There are two ways: by implementing equality ourselves,\n+or by pattern matching variants with [`match`][match] expressions, which you\u2019ll\n+learn in the next section. We don\u2019t know enough about Rust to implement\n+equality yet, but we\u2019ll find out in the [`traits`][traits] section.\n \n-[match]: ./match.html\n-[generics]: ./generics.html\n+[match]: match.html\n+[traits]: traits.html"}, {"sha": "517a6e6064253295a6292e1a6b2a3e0147f5b2bd", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 50, "deletions": 103, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "patch": "@@ -1,31 +1,13 @@\n % Generics\n \n Sometimes, when writing a function or data type, we may want it to work for\n-multiple types of arguments. For example, remember our `OptionalInt` type?\n+multiple types of arguments. Luckily, Rust has a feature that gives us a better\n+way: generics. Generics are called \u2018parametric polymorphism\u2019 in type theory,\n+which means that they are types or functions that have multiple forms (\u2018poly\u2019\n+is multiple, \u2018morph\u2019 is form) over a given parameter (\u2018parametric\u2019).\n \n-```{rust}\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-```\n-\n-If we wanted to also have an `OptionalFloat64`, we would need a new enum:\n-\n-```{rust}\n-enum OptionalFloat64 {\n-    Valuef64(f64),\n-    Missingf64,\n-}\n-```\n-\n-This is really unfortunate. Luckily, Rust has a feature that gives us a better\n-way: generics. Generics are called *parametric polymorphism* in type theory,\n-which means that they are types or functions that have multiple forms (*poly*\n-is multiple, *morph* is form) over a given parameter (*parametric*).\n-\n-Anyway, enough with type theory declarations, let's check out the generic form\n-of `OptionalInt`. It is actually provided by Rust itself, and looks like this:\n+Anyway, enough with type theory, let\u2019s check out some generic code. Rust\u2019s\n+standard library provides a type, `Option<T>`, that\u2019s generic:\n \n ```rust\n enum Option<T> {\n@@ -34,144 +16,109 @@ enum Option<T> {\n }\n ```\n \n-The `<T>` part, which you've seen a few times before, indicates that this is\n+The `<T>` part, which you\u2019ve seen a few times before, indicates that this is\n a generic data type. Inside the declaration of our enum, wherever we see a `T`,\n-we substitute that type for the same type used in the generic. Here's an\n+we substitute that type for the same type used in the generic. Here\u2019s an\n example of using `Option<T>`, with some extra type annotations:\n \n-```{rust}\n+```rust\n let x: Option<i32> = Some(5);\n ```\n \n In the type declaration, we say `Option<i32>`. Note how similar this looks to\n `Option<T>`. So, in this particular `Option`, `T` has the value of `i32`. On\n the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5`.\n-Since that's an `i32`, the two sides match, and Rust is happy. If they didn't\n-match, we'd get an error:\n+Since that\u2019s an `i32`, the two sides match, and Rust is happy. If they didn\u2019t\n+match, we\u2019d get an error:\n \n-```{rust,ignore}\n+```rust,ignore\n let x: Option<f64> = Some(5);\n // error: mismatched types: expected `core::option::Option<f64>`,\n // found `core::option::Option<_>` (expected f64 but found integral variable)\n ```\n \n-That doesn't mean we can't make `Option<T>`s that hold an `f64`! They just have to\n-match up:\n+That doesn\u2019t mean we can\u2019t make `Option<T>`s that hold an `f64`! They just have\n+to match up:\n \n-```{rust}\n+```rust\n let x: Option<i32> = Some(5);\n let y: Option<f64> = Some(5.0f64);\n ```\n \n This is just fine. One definition, multiple uses.\n \n-Generics don't have to only be generic over one type. Consider Rust's built-in\n-`Result<T, E>` type:\n+Generics don\u2019t have to only be generic over one type. Consider another type from Rust\u2019s standard library that\u2019s similar, `Result<T, E>`:\n \n-```{rust}\n+```rust\n enum Result<T, E> {\n     Ok(T),\n     Err(E),\n }\n ```\n \n This type is generic over _two_ types: `T` and `E`. By the way, the capital letters\n-can be any letter you'd like. We could define `Result<T, E>` as:\n+can be any letter you\u2019d like. We could define `Result<T, E>` as:\n \n-```{rust}\n+```rust\n enum Result<A, Z> {\n     Ok(A),\n     Err(Z),\n }\n ```\n \n if we wanted to. Convention says that the first generic parameter should be\n-`T`, for 'type,' and that we use `E` for 'error.' Rust doesn't care, however.\n+`T`, for \u2018type\u2019, and that we use `E` for \u2018error\u2019. Rust doesn\u2019t care, however.\n \n The `Result<T, E>` type is intended to be used to return the result of a\n-computation, and to have the ability to return an error if it didn't work out.\n-Here's an example:\n-\n-```{rust}\n-let x: Result<f64, String> = Ok(2.3f64);\n-let y: Result<f64, String> = Err(\"There was an error.\".to_string());\n-```\n+computation, and to have the ability to return an error if it didn\u2019t work out.\n \n-This particular Result will return an `f64` if there's a success, and a\n-`String` if there's a failure. Let's write a function that uses `Result<T, E>`:\n+## Generic functions\n \n-```{rust}\n-fn inverse(x: f64) -> Result<f64, String> {\n-    if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n+We can write functions that take generic types with a similar syntax:\n \n-    Ok(1.0f64 / x)\n+```rust\n+fn takes_anything<T>(x: T) {\n+    // do something with x\n }\n ```\n \n-We don't want to take the inverse of zero, so we check to make sure that we\n-weren't passed zero. If we were, then we return an `Err`, with a message. If\n-it's okay, we return an `Ok`, with the answer.\n+The syntax has two parts: the `<T>` says \u201cthis function is generic over one\n+type, `T`\u201d, and the `x: T` says \u201cx has the type `T`.\u201d\n \n-Why does this matter? Well, remember how `match` does exhaustive matches?\n-Here's how this function gets used:\n+Multiple arguments can have the same generic type:\n \n-```{rust}\n-# fn inverse(x: f64) -> Result<f64, String> {\n-#     if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n-#     Ok(1.0f64 / x)\n-# }\n-let x = inverse(25.0f64);\n-\n-match x {\n-    Ok(x) => println!(\"The inverse of 25 is {}\", x),\n-    Err(msg) => println!(\"Error: {}\", msg),\n+```rust\n+fn takes_two_of_the_same_things<T>(x: T, y: T) {\n+    // ...\n }\n ```\n \n-The `match` enforces that we handle the `Err` case. In addition, because the\n-answer is wrapped up in an `Ok`, we can't just use the result without doing\n-the match:\n-\n-```{rust,ignore}\n-let x = inverse(25.0f64);\n-println!(\"{}\", x + 2.0f64); // error: binary operation `+` cannot be applied\n-           // to type `core::result::Result<f64,collections::string::String>`\n-```\n-\n-This function is great, but there's one other problem: it only works for 64 bit\n-floating point values. What if we wanted to handle 32 bit floating point as\n-well? We'd have to write this:\n+We could write a version that takes multiple types:\n \n-```{rust}\n-fn inverse32(x: f32) -> Result<f32, String> {\n-    if x == 0.0f32 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0f32 / x)\n+```rust\n+fn takes_two_things<T, U>(x: T, y: U) {\n+    // ...\n }\n ```\n \n-Bummer. What we need is a *generic function*. Luckily, we can write one!\n-However, it won't _quite_ work yet. Before we get into that, let's talk syntax.\n-A generic version of `inverse` would look something like this:\n+Generic functions are most useful with \u2018trait bounds\u2019, which we\u2019ll cover in the\n+[section on traits][traits].\n \n-```{rust,ignore}\n-fn inverse<T>(x: T) -> Result<T, String> {\n-    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n+[traits]: traits.html\n \n-    Ok(1.0 / x)\n-}\n-```\n+## Generic structs\n \n-Just like how we had `Option<T>`, we use a similar syntax for `inverse<T>`.\n-We can then use `T` inside the rest of the signature: `x` has type `T`, and half\n-of the `Result` has type `T`. However, if we try to compile that example, we'll get\n-an error:\n+You can store a generic type in a `struct` as well:\n \n-```text\n-error: binary operation `==` cannot be applied to type `T`\n ```\n+struct Point<T> {\n+    x: T,\n+    y: T,\n+}\n \n-Because `T` can be _any_ type, it may be a type that doesn't implement `==`,\n-and therefore, the first line would be wrong. What do we do?\n+let int_origin = Point { x: 0, y: 0 };\n+let float_origin = Point { x: 0.0, y: 0.0 };\n+```\n \n-To fix this example, we need to learn about another Rust feature: traits.\n+Similarly to functions, the `<T>` is where we declare the generic parameters,\n+and we then use `x: T` in the type declaration, too."}, {"sha": "2c0c8ea73c03c5b6ec6169b609af0d8a36d615b0", "filename": "src/doc/trpl/match.md", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "patch": "@@ -1,10 +1,8 @@\n % Match\n \n-Often, a simple `if`/`else` isn\u2019t enough, because you have more than two\n-possible options. Also, `else` conditions can get incredibly complicated, so\n-what\u2019s the solution?\n-\n-Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n+Often, a simple [`if`][if]/`else` isn\u2019t enough, because you have more than two\n+possible options. Also, conditions can get quite complex. Rust\n+has a keyword, `match`, that allows you to replace complicated `if`/`else`\n groupings with something more powerful. Check it out:\n \n ```rust\n@@ -20,28 +18,31 @@ match x {\n }\n ```\n \n-`match` takes an expression and then branches based on its value. Each *arm* of\n+[if]: if.html\n+\n+`match` takes an expression and then branches based on its value. Each \u2018arm\u2019 of\n the branch is of the form `val => expression`. When the value matches, that arm\u2019s\n expression will be evaluated. It\u2019s called `match` because of the term \u2018pattern\n matching\u2019, which `match` is an implementation of. There\u2019s an [entire section on\n-patterns][patterns] coming up next, that covers all the options that fit here.\n+patterns][patterns] that covers all the patterns that are possible here.\n \n [patterns]: patterns.html\n \n-So what\u2019s the big advantage here? Well, there are a few. First of all, `match`\n-enforces *exhaustiveness checking*. Do you see that last arm, the one with the\n+So what\u2019s the big advantage? Well, there are a few. First of all, `match`\n+enforces \u2018exhaustiveness checking\u2019. Do you see that last arm, the one with the\n underscore (`_`)? If we remove that arm, Rust will give us an error:\n \n ```text\n error: non-exhaustive patterns: `_` not covered\n ```\n \n In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n-integer, Rust knows that it can have a number of different values \u2013 for example,\n-`6`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n-to compile. `_` acts like a \u2018catch-all arm\u2019. If none of the other arms match,\n-the arm with `_` will, and since we have this catch-all arm, we now have an arm\n-for every possible value of `x`, and so our program will compile successfully.\n+integer, Rust knows that it can have a number of different values \u2013 for\n+example, `6`. Without the `_`, however, there is no arm that could match, and\n+so Rust refuses to compile the code. `_` acts like a \u2018catch-all arm\u2019. If none\n+of the other arms match, the arm with `_` will, and since we have this\n+catch-all arm, we now have an arm for every possible value of `x`, and so our\n+program will compile successfully.\n \n `match` is also an expression, which means we can use it on the right-hand\n side of a `let` binding or directly where an expression is used:\n@@ -59,4 +60,4 @@ let numer = match x {\n };\n ```\n \n-Sometimes, it\u2019s a nice way of converting things.\n+Sometimes it\u2019s a nice way of converting something from one type to another."}, {"sha": "5853f3d679c5f5231f185af1d1d940eed1a30c70", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "patch": "@@ -3,27 +3,26 @@\n Functions are great, but if you want to call a bunch of them on some data, it\n can be awkward. Consider this code:\n \n-```{rust,ignore}\n+```rust,ignore\n baz(bar(foo)));\n ```\n \n-We would read this left-to right, and so we see \"baz bar foo.\" But this isn't the\n-order that the functions would get called in, that's inside-out: \"foo bar baz.\"\n-Wouldn't it be nice if we could do this instead?\n+We would read this left-to right, and so we see \u2018baz bar foo\u2019. But this isn\u2019t the\n+order that the functions would get called in, that\u2019s inside-out: \u2018foo bar baz\u2019.\n+Wouldn\u2019t it be nice if we could do this instead?\n \n-```{rust,ignore}\n+```rust,ignore\n foo.bar().baz();\n ```\n \n Luckily, as you may have guessed with the leading question, you can! Rust provides\n-the ability to use this *method call syntax* via the `impl` keyword.\n+the ability to use this \u2018method call syntax\u2019 via the `impl` keyword.\n \n ## Method calls\n \n-Here's how it works:\n+Here\u2019s how it works:\n \n-```{rust}\n-# #![feature(core)]\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -44,15 +43,23 @@ fn main() {\n \n This will print `12.566371`.\n \n-We've made a struct that represents a circle. We then write an `impl` block,\n-and inside it, define a method, `area`. Methods take a  special first\n-parameter, of which there are three variants: `self`, `&self`, and `&mut self`.\n-You can think of this first parameter as being the `foo` in `foo.bar()`. The three\n-variants correspond to the three kinds of things `foo` could be: `self` if it's\n-just a value on the stack, `&self` if it's a reference, and `&mut self` if it's\n-a mutable reference. We should default to using `&self`, as you should prefer\n-borrowing over taking ownership, as well as taking immutable references\n-over mutable ones. Here's an example of all three variants:\n+\n+\n+We\u2019ve made a struct that represents a circle. We then write an `impl` block,\n+and inside it, define a method, `area`.\n+\n+Methods take a  special first parameter, of which there are three variants:\n+`self`, `&self`, and `&mut self`. You can think of this first parameter as\n+being the `foo` in `foo.bar()`. The three variants correspond to the three\n+kinds of things `foo` could be: `self` if it\u2019s just a value on the stack,\n+`&self` if it\u2019s a reference, and `&mut self` if it\u2019s a mutable reference.\n+Because we took the `&self` parameter to `area`, we can use it just like any\n+other parameter. Because we know it\u2019s a `Circle`, we can access the `radius`\n+just like we would with any other struct. \n+\n+We should default to using `&self`, as you should prefer borrowing over taking\n+ownership, as well as taking immutable references over mutable ones. Here\u2019s an\n+example of all three variants:\n \n ```rust\n struct Circle {\n@@ -76,20 +83,13 @@ impl Circle {\n }\n ```\n \n-Finally, as you may remember, the value of the area of a circle is `\u03c0*r\u00b2`.\n-Because we took the `&self` parameter to `area`, we can use it just like any\n-other parameter. Because we know it's a `Circle`, we can access the `radius`\n-just like we would with any other struct. An import of \u03c0 and some\n-multiplications later, and we have our area.\n-\n ## Chaining method calls\n \n So, now we know how to call a method, such as `foo.bar()`. But what about our\n-original example, `foo.bar().baz()`? This is called 'method chaining', and we\n+original example, `foo.bar().baz()`? This is called \u2018method chaining\u2019, and we\n can do it by returning `self`.\n \n ```\n-# #![feature(core)]\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -124,13 +124,13 @@ fn grow(&self) -> Circle {\n # Circle } }\n ```\n \n-We just say we're returning a `Circle`. With this method, we can grow a new\n+We just say we\u2019re returning a `Circle`. With this method, we can grow a new\n circle to any arbitrary size.\n \n ## Static methods\n \n-You can also define methods that do not take a `self` parameter. Here's a\n-pattern that's very common in Rust code:\n+You can also define methods that do not take a `self` parameter. Here\u2019s a\n+pattern that\u2019s very common in Rust code:\n \n ```\n struct Circle {\n@@ -154,20 +154,19 @@ fn main() {\n }\n ```\n \n-This *static method* builds a new `Circle` for us. Note that static methods\n+This \u2018static method\u2019 builds a new `Circle` for us. Note that static methods\n are called with the `Struct::method()` syntax, rather than the `ref.method()`\n syntax.\n \n ## Builder Pattern\n \n-Let's say that we want our users to be able to create Circles, but we will\n+Let\u2019s say that we want our users to be able to create Circles, but we will\n allow them to only set the properties they care about. Otherwise, the `x`\n-and `y` attributes will be `0.0`, and the `radius` will be `1.0`. Rust doesn't\n+and `y` attributes will be `0.0`, and the `radius` will be `1.0`. Rust doesn\u2019t\n have method overloading, named arguments, or variable arguments. We employ\n the builder pattern instead. It looks like this:\n \n ```\n-# #![feature(core)]\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -224,9 +223,9 @@ fn main() {\n }\n ```\n \n-What we've done here is make another struct, `CircleBuilder`. We've defined our\n-builder methods on it. We've also defined our `area()` method on `Circle`. We\n+What we\u2019ve done here is make another struct, `CircleBuilder`. We\u2019ve defined our\n+builder methods on it. We\u2019ve also defined our `area()` method on `Circle`. We\n also made one more method on `CircleBuilder`: `finalize()`. This method creates\n-our final `Circle` from the builder. Now, we've used the type system to enforce\n+our final `Circle` from the builder. Now, we\u2019ve used the type system to enforce\n our concerns: we can use the methods on `CircleBuilder` to constrain making\n `Circle`s in any way we choose."}, {"sha": "97a3dfe8a7640c688070a6e059b570273e43dab2", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "patch": "@@ -21,6 +21,8 @@ match x {\n }\n ```\n \n+This prints `one`.\n+\n # Multiple patterns\n \n You can match multiple patterns with `|`:\n@@ -35,6 +37,8 @@ match x {\n }\n ```\n \n+This prints `one or two`.\n+\n # Ranges\n \n You can match a range of values with `...`:\n@@ -48,7 +52,21 @@ match x {\n }\n ```\n \n-Ranges are mostly used with integers and single characters.\n+This prints `one through five`.\n+\n+Ranges are mostly used with integers and `char`s:\n+\n+```rust\n+let x = '\ud83d\udc85';\n+\n+match x {\n+    'a' ... 'j' => println!(\"early letter\"),\n+    'k' ... 'z' => println!(\"late letter\"),\n+    _ => println!(\"something else\"),\n+}\n+```\n+\n+This prints `something else`\n \n # Bindings\n \n@@ -64,6 +82,8 @@ match x {\n }\n ```\n \n+This prints `got a range element 1`.\n+\n # Ignoring variants\n \n If you\u2019re matching on an enum which has variants, you can use `..` to\n@@ -83,6 +103,8 @@ match x {\n }\n ```\n \n+This prints `Got an int!`.\n+\n # Guards\n \n You can introduce \u2018match guards\u2019 with `if`:\n@@ -102,6 +124,8 @@ match x {\n }\n ```\n \n+This prints `Got an int!`\n+\n # ref and ref mut\n \n If you want to get a [reference][ref], use the `ref` keyword:\n@@ -114,6 +138,8 @@ match x {\n }\n ```\n \n+This prints `Got a reference to 5`.\n+\n [ref]: references-and-borrowing.html\n \n Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n@@ -130,7 +156,7 @@ match x {\n \n # Destructuring\n \n-If you have a compound data type, like a `struct`, you can destructure it\n+If you have a compound data type, like a [`struct`][struct], you can destructure it\n inside of a pattern:\n \n ```rust\n@@ -146,6 +172,8 @@ match origin {\n }\n ```\n \n+[struct]: structs.html\n+\n If we only care about some of the values, we don\u2019t have to give them all names:\n \n ```rust\n@@ -161,6 +189,8 @@ match origin {\n }\n ```\n \n+This prints `x is 0`.\n+\n You can do this kind of match on any member, not just the first:\n \n ```rust\n@@ -176,6 +206,8 @@ match origin {\n }\n ```\n \n+This prints `y is 0`.\n+\n This \u2018destructuring\u2019 behavior works on any compound data type, like\n [tuples][tuples] or [enums][enums].\n \n@@ -187,10 +219,10 @@ This \u2018destructuring\u2019 behavior works on any compound data type, like\n Whew! That\u2019s a lot of different ways to match things, and they can all be\n mixed and matched, depending on what you\u2019re doing:\n \n-```{rust,ignore}\n+```rust,ignore\n match x {\n     Foo { x: Some(ref name), y: None } => ...\n }\n ```\n \n-Patterns are very powerful.  Make good use of them.\n+Patterns are very powerful. Make good use of them."}, {"sha": "6ed4c7cb1b379bea10ec9e1d1e1546cb965ed1c9", "filename": "src/doc/trpl/strings.md", "status": "modified", "additions": 91, "deletions": 23, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstrings.md?ref=ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "patch": "@@ -1,36 +1,34 @@\n % Strings\n \n-Strings are an important concept for any programmer to master. Rust's string\n+Strings are an important concept for any programmer to master. Rust\u2019s string\n handling system is a bit different from other languages, due to its systems\n focus. Any time you have a data structure of variable size, things can get\n-tricky, and strings are a re-sizable data structure. That being said, Rust's\n+tricky, and strings are a re-sizable data structure. That being said, Rust\u2019s\n strings also work differently than in some other systems languages, such as C.\n \n-Let's dig into the details. A *string* is a sequence of Unicode scalar values\n-encoded as a stream of UTF-8 bytes. All strings are guaranteed to be\n-validly encoded UTF-8 sequences. Additionally, strings are not null-terminated\n-and can contain null bytes.\n+Let\u2019s dig into the details. A \u2018string\u2019 is a sequence of Unicode scalar values\n+encoded as a stream of UTF-8 bytes. All strings are guaranteed to be a valid\n+encoding of UTF-8 sequences. Additionally, unlike some systems languages,\n+strings are not null-terminated and can contain null bytes.\n \n-Rust has two main types of strings: `&str` and `String`.\n+Rust has two main types of strings: `&str` and `String`. Let\u2019s talk about\n+`&str` first. These are called \u2018string slices\u2019. String literals are of the type\n+`&'static str`:\n \n-The first kind is a `&str`. These are called *string slices*. String literals\n-are of the type `&str`:\n-\n-```{rust}\n-let string = \"Hello there.\"; // string: &str\n+```rust\n+let string = \"Hello there.\"; // string: &'static str\n ```\n \n-This string is statically allocated, meaning that it's saved inside our\n+This string is statically allocated, meaning that it\u2019s saved inside our\n compiled program, and exists for the entire duration it runs. The `string`\n binding is a reference to this statically allocated string. String slices\n have a fixed size, and cannot be mutated.\n \n-A `String`, on the other hand, is a heap-allocated string. This string\n-is growable, and is also guaranteed to be UTF-8. `String`s are\n-commonly created by converting from a string slice using the\n-`to_string` method.\n+A `String`, on the other hand, is a heap-allocated string. This string is\n+growable, and is also guaranteed to be UTF-8. `String`s are commonly created by\n+converting from a string slice using the `to_string` method.\n \n-```{rust}\n+```rust\n let mut s = \"Hello\".to_string(); // mut s: String\n println!(\"{}\", s);\n \n@@ -54,8 +52,78 @@ fn main() {\n Viewing a `String` as a `&str` is cheap, but converting the `&str` to a\n `String` involves allocating memory. No reason to do that unless you have to!\n \n-That's the basics of strings in Rust! They're probably a bit more complicated\n-than you are used to, if you come from a scripting language, but when the\n-low-level details matter, they really matter. Just remember that `String`s\n-allocate memory and control their data, while `&str`s are a reference to\n-another string, and you'll be all set.\n+## Indexing\n+\n+Because strings are valid UTF-8, strings do not support indexing:\n+\n+```rust,ignore\n+let s = \"hello\";\n+\n+println!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n+```\n+\n+Usually, access to a vector with `[]` is very fast. But, because each character\n+in a UTF-8 encoded string can be multiple bytes, you have to walk over the\n+string to find the n\u1d57\u02b0 letter of a string. This is a significantly more\n+expensive operation, and we don\u2019t want to be misleading. Furthermore, \u2018letter\u2019\n+isn\u2019t something defined in Unicode, exactly. We can choose to look at a string as\n+individual bytes, or as codepoints:\n+\n+```rust\n+let hachiko = \"\u5fe0\u72ac\u30cf\u30c1\u516c\";\n+\n+for b in hachiko.as_bytes() {\n+print!(\"{}, \", b);\n+}\n+\n+println!(\"\");\n+\n+for c in hachiko.chars() {\n+print!(\"{}, \", c);\n+}\n+\n+println!(\"\");\n+```\n+\n+This prints:\n+\n+```text\n+229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172, \n+\u5fe0, \u72ac, \u30cf, \u30c1, \u516c, \n+```\n+\n+As you can see, there are more bytes than `char`s.\n+\n+You can get something similar to an index like this:\n+\n+```rust\n+# let hachiko = \"\u5fe0\u72ac\u30cf\u30c1\u516c\";\n+let dog = hachiko.chars().nth(1); // kinda like hachiko[1]\n+```\n+\n+This emphasizes that we have to go through the whole list of `chars`.\n+\n+## Concatenation\n+\n+If you have a `String`, you can concatenate a `&str` to the end of it:\n+\n+```rust\n+let hello = \"Hello \".to_string();\n+let world = \"world!\";\n+\n+let hello_world = hello + world;\n+```\n+\n+But if you have two `String`s, you need an `&`:\n+\n+```rust\n+let hello = \"Hello \".to_string();\n+let world = \"world!\".to_string();\n+\n+let hello_world = hello + &world;\n+```\n+\n+This is because `&String` can automatically coerece to a `&str`. This is a\n+feature called \u2018[`Deref` coercions][dc]\u2019.\n+\n+[dc]: deref-coercions.html"}, {"sha": "ff249d6043c102039601ae04257c4835182458d8", "filename": "src/doc/trpl/structs.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstructs.md?ref=ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "patch": "@@ -1,6 +1,6 @@\n % Structs\n \n-Structs are a way of creating more complex datatypes. For example, if we were\n+Structs are a way of creating more complex data types. For example, if we were\n doing calculations involving coordinates in 2D space, we would need both an `x`\n and a `y` value:\n \n@@ -24,12 +24,12 @@ fn main() {\n }\n ```\n \n-There\u2019s a lot going on here, so let\u2019s break it down. We declare a struct with\n-the `struct` keyword, and then with a name. By convention, structs begin with a\n-capital letter and are also camel cased: `PointInSpace`, not `Point_In_Space`.\n+There\u2019s a lot going on here, so let\u2019s break it down. We declare a `struct` with\n+the `struct` keyword, and then with a name. By convention, `struct`s begin with\n+a capital letter and are camel cased: `PointInSpace`, not `Point_In_Space`.\n \n We can create an instance of our struct via `let`, as usual, but we use a `key:\n-value` style syntax to set each field. The order doesn't need to be the same as\n+value` style syntax to set each field. The order doesn\u2019t need to be the same as\n in the original declaration.\n \n Finally, because fields have names, we can access the field through dot"}, {"sha": "7330e42ccf689dd8cbf1fb18d0fac01897c19d79", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 100, "deletions": 188, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "patch": "@@ -1,10 +1,9 @@\n % Traits\n \n-Do you remember the `impl` keyword, used to call a function with method\n-syntax?\n+Do you remember the `impl` keyword, used to call a function with [method\n+syntax][methodsyntax]?\n \n-```{rust}\n-# #![feature(core)]\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -18,11 +17,12 @@ impl Circle {\n }\n ```\n \n+[methodsyntax]: method-syntax.html\n+\n Traits are similar, except that we define a trait with just the method\n signature, then implement the trait for that struct. Like this:\n \n-```{rust}\n-# #![feature(core)]\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -41,20 +41,13 @@ impl HasArea for Circle {\n ```\n \n As you can see, the `trait` block looks very similar to the `impl` block,\n-but we don't define a body, just a type signature. When we `impl` a trait,\n+but we don\u2019t define a body, just a type signature. When we `impl` a trait,\n we use `impl Trait for Item`, rather than just `impl Item`.\n \n-So what's the big deal? Remember the error we were getting with our generic\n-`inverse` function?\n-\n-```text\n-error: binary operation `==` cannot be applied to type `T`\n-```\n-\n We can use traits to constrain our generics. Consider this function, which\n does not compile, and gives us a similar error:\n \n-```{rust,ignore}\n+```rust,ignore\n fn print_area<T>(shape: T) {\n     println!(\"This shape has an area of {}\", shape.area());\n }\n@@ -66,11 +59,11 @@ Rust complains:\n error: type `T` does not implement any method in scope named `area`\n ```\n \n-Because `T` can be any type, we can't be sure that it implements the `area`\n-method. But we can add a *trait constraint* to our generic `T`, ensuring\n+Because `T` can be any type, we can\u2019t be sure that it implements the `area`\n+method. But we can add a \u2018trait constraint\u2019 to our generic `T`, ensuring\n that it does:\n \n-```{rust}\n+```rust\n # trait HasArea {\n #     fn area(&self) -> f64;\n # }\n@@ -83,10 +76,9 @@ The syntax `<T: HasArea>` means `any type that implements the HasArea trait`.\n Because traits define function type signatures, we can be sure that any type\n which implements `HasArea` will have an `.area()` method.\n \n-Here's an extended example of how this works:\n+Here\u2019s an extended example of how this works:\n \n-```{rust}\n-# #![feature(core)]\n+```rust\n trait HasArea {\n     fn area(&self) -> f64;\n }\n@@ -144,10 +136,10 @@ This shape has an area of 3.141593\n This shape has an area of 1\n ```\n \n-As you can see, `print_area` is now generic, but also ensures that we\n-have passed in the correct types. If we pass in an incorrect type:\n+As you can see, `print_area` is now generic, but also ensures that we have\n+passed in the correct types. If we pass in an incorrect type:\n \n-```{rust,ignore}\n+```rust,ignore\n print_area(5);\n ```\n \n@@ -157,11 +149,11 @@ We get a compile-time error:\n error: failed to find an implementation of trait main::HasArea for int\n ```\n \n-So far, we've only added trait implementations to structs, but you can\n-implement a trait for any type. So technically, we _could_ implement\n-`HasArea` for `i32`:\n+So far, we\u2019ve only added trait implementations to structs, but you can\n+implement a trait for any type. So technically, we _could_ implement `HasArea`\n+for `i32`:\n \n-```{rust}\n+```rust\n trait HasArea {\n     fn area(&self) -> f64;\n }\n@@ -181,102 +173,57 @@ It is considered poor style to implement methods on such primitive types, even\n though it is possible.\n \n This may seem like the Wild West, but there are two other restrictions around\n-implementing traits that prevent this from getting out of hand. First, traits\n-must be `use`d in any scope where you wish to use the trait's method. So for\n-example, this does not work:\n+implementing traits that prevent this from getting out of hand. The first is\n+that if the trait isn\u2019t defined in your scope, it doesn\u2019t apply. Here\u2019s an\n+example: the standard library provides a [`Write`][write] trait which adds\n+extra functionality to `File`s, for doing file I/O. By default, a `File`\n+won\u2019t have its methods:\n \n-```{rust,ignore}\n-mod shapes {\n-    use std::f64::consts;\n+[write]: ../std/io/trait.Write.html\n \n-    trait HasArea {\n-        fn area(&self) -> f64;\n-    }\n-\n-    struct Circle {\n-        x: f64,\n-        y: f64,\n-        radius: f64,\n-    }\n-\n-    impl HasArea for Circle {\n-        fn area(&self) -> f64 {\n-            consts::PI * (self.radius * self.radius)\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let c = shapes::Circle {\n-        x: 0.0f64,\n-        y: 0.0f64,\n-        radius: 1.0f64,\n-    };\n-\n-    println!(\"{}\", c.area());\n-}\n+```rust,ignore\n+let mut f = std::fs::File::open(\"foo.txt\").ok().expect(\"Couldn\u2019t open foo.txt\");\n+let result = f.write(\"whatever\".as_bytes());\n+# result.unwrap(); // ignore the erorr\n ```\n \n-Now that we've moved the structs and traits into their own module, we get an\n-error:\n+Here\u2019s the error:\n \n ```text\n-error: type `shapes::Circle` does not implement any method in scope named `area`\n-```\n+error: type `std::fs::File` does not implement any method in scope named `write`\n \n-If we add a `use` line right above `main` and make the right things public,\n-everything is fine:\n-\n-```{rust}\n-# #![feature(core)]\n-mod shapes {\n-    use std::f64::consts;\n-\n-    pub trait HasArea {\n-        fn area(&self) -> f64;\n-    }\n-\n-    pub struct Circle {\n-        pub x: f64,\n-        pub y: f64,\n-        pub radius: f64,\n-    }\n-\n-    impl HasArea for Circle {\n-        fn area(&self) -> f64 {\n-            consts::PI * (self.radius * self.radius)\n-        }\n-    }\n-}\n+let result = f.write(b\u201dwhatever\u201d);\n+               ^~~~~~~~~~~~~~~~~~\n+```\n \n-use shapes::HasArea;\n+We need to `use` the `Write` trait first:\n \n-fn main() {\n-    let c = shapes::Circle {\n-        x: 0.0f64,\n-        y: 0.0f64,\n-        radius: 1.0f64,\n-    };\n+```rust,ignore\n+use std::io::Write;\n \n-    println!(\"{}\", c.area());\n-}\n+let mut f = std::fs::File::open(\"foo.txt\").ok().expect(\"Couldn\u2019t open foo.txt\");\n+let result = f.write(\"whatever\".as_bytes());\n+# result.unwrap(); // ignore the erorr\n ```\n \n+This will compile without error.\n+\n This means that even if someone does something bad like add methods to `int`,\n-it won't affect you, unless you `use` that trait.\n+it won\u2019t affect you, unless you `use` that trait.\n \n-There's one more restriction on implementing traits. Either the trait or the\n-type you're writing the `impl` for must be inside your crate. So, we could\n-implement the `HasArea` type for `i32`, because `HasArea` is in our crate.  But\n+There\u2019s one more restriction on implementing traits. Either the trait or the\n+type you\u2019re writing the `impl` for must be defined by you. So, we could\n+implement the `HasArea` type for `i32`, because `HasArea` is in our code. But\n if we tried to implement `Float`, a trait provided by Rust, for `i32`, we could\n-not, because both the trait and the type aren't in our crate.\n+not, because neither the trait nor the type are in our code.\n \n One last thing about traits: generic functions with a trait bound use\n-*monomorphization* (*mono*: one, *morph*: form), so they are statically\n-dispatched. What's that mean? Check out the chapter on [trait\n-objects](trait-objects.html) for more.\n+\u2018monomorphization\u2019 (mono: one, morph: form), so they are statically dispatched.\n+What\u2019s that mean? Check out the chapter on [trait objects][to] for more details.\n+\n+[to]: trait-objects.html\n \n-## Multiple trait bounds\n+# Multiple trait bounds\n \n You\u2019ve seen that you can bound a generic type parameter with a trait:\n \n@@ -299,10 +246,10 @@ fn foo<T: Clone + Debug>(x: T) {\n \n `T` now needs to be both `Clone` as well as `Debug`.\n \n-## Where clause\n+# Where clause\n \n Writing functions with only a few generic types and a small number of trait\n-bounds isn't too bad, but as the number increases, the syntax gets increasingly\n+bounds isn\u2019t too bad, but as the number increases, the syntax gets increasingly\n awkward:\n \n ```\n@@ -318,7 +265,7 @@ fn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n The name of the function is on the far left, and the parameter list is on the\n far right. The bounds are getting in the way.\n \n-Rust has a solution, and it's called a '`where` clause':\n+Rust has a solution, and it\u2019s called a \u2018`where` clause\u2019:\n \n ```\n use std::fmt::Debug;\n@@ -389,84 +336,9 @@ This shows off the additional feature of `where` clauses: they allow bounds\n where the left-hand side is an arbitrary type (`i32` in this case), not just a\n plain type parameter (like `T`).\n \n-## Our `inverse` Example\n-\n-Back in [Generics](generics.html), we were trying to write code like this:\n-\n-```{rust,ignore}\n-fn inverse<T>(x: T) -> Result<T, String> {\n-    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0 / x)\n-}\n-```\n-\n-If we try to compile it, we get this error:\n-\n-```text\n-error: binary operation `==` cannot be applied to type `T`\n-```\n-\n-This is because `T` is too generic: we don't know if a random `T` can be\n-compared. For that, we can use trait bounds. It doesn't quite work, but try\n-this:\n-\n-```{rust,ignore}\n-fn inverse<T: PartialEq>(x: T) -> Result<T, String> {\n-    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0 / x)\n-}\n-```\n-\n-You should get this error:\n-\n-```text\n-error: mismatched types:\n- expected `T`,\n-    found `_`\n-(expected type parameter,\n-    found floating-point variable)\n-```\n-\n-So this won't work. While our `T` is `PartialEq`, we expected to have another `T`,\n-but instead, we found a floating-point variable. We need a different bound. `Float`\n-to the rescue:\n-\n-```\n-# #![feature(std_misc)]\n-use std::num::Float;\n-\n-fn inverse<T: Float>(x: T) -> Result<T, String> {\n-    if x == Float::zero() { return Err(\"x cannot be zero!\".to_string()) }\n-\n-    let one: T = Float::one();\n-    Ok(one / x)\n-}\n-```\n-\n-We've had to replace our generic `0.0` and `1.0` with the appropriate methods\n-from the `Float` trait. Both `f32` and `f64` implement `Float`, so our function\n-works just fine:\n-\n-```\n-# #![feature(std_misc)]\n-# use std::num::Float;\n-# fn inverse<T: Float>(x: T) -> Result<T, String> {\n-#     if x == Float::zero() { return Err(\"x cannot be zero!\".to_string()) }\n-#     let one: T = Float::one();\n-#     Ok(one / x)\n-# }\n-println!(\"the inverse of {} is {:?}\", 2.0f32, inverse(2.0f32));\n-println!(\"the inverse of {} is {:?}\", 2.0f64, inverse(2.0f64));\n-\n-println!(\"the inverse of {} is {:?}\", 0.0f32, inverse(0.0f32));\n-println!(\"the inverse of {} is {:?}\", 0.0f64, inverse(0.0f64));\n-```\n-\n-## Default methods\n+# Default methods\n \n-There's one last feature of traits we should cover: default methods. It's\n+There\u2019s one last feature of traits we should cover: default methods. It\u2019s\n easiest just to show an example:\n \n ```rust\n@@ -477,8 +349,8 @@ trait Foo {\n }\n ```\n \n-Implementors of the `Foo` trait need to implement `bar()`, but they don't\n-need to implement `baz()`. They'll get this default behavior. They can\n+Implementors of the `Foo` trait need to implement `bar()`, but they don\u2019t\n+need to implement `baz()`. They\u2019ll get this default behavior. They can\n override the default if they so choose:\n \n ```rust\n@@ -506,3 +378,43 @@ default.baz(); // prints \"We called baz.\"\n let over = OverrideDefault;\n over.baz(); // prints \"Override baz!\"\n ```\n+\n+# Inheritance\n+\n+Sometimes, implementing a trait requires implementing another trait:\n+\n+```rust\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+trait FooBar : Foo {\n+    fn foobar(&self);\n+}\n+```\n+\n+Implementors of `FooBar` must also implement `Foo`, like this:\n+\n+```rust\n+# trait Foo {\n+#     fn foo(&self);\n+# }\n+# trait FooBar : Foo {\n+#     fn foobar(&self);\n+# }\n+struct Baz;\n+\n+impl Foo for Baz {\n+    fn foo(&self) { println!(\"foo\"); }\n+}\n+\n+impl FooBar for Baz {\n+    fn foobar(&self) { println!(\"foobar\"); }\n+}\n+```\n+\n+If we forget to implement `Foo`, Rust will tell us:\n+\n+```text\n+error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]\n+```"}, {"sha": "965cb218c699a1ecec1a4d5a2ed3dc9b675a9b21", "filename": "src/doc/trpl/vectors.md", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff12b7b308cf79a61e4f578e6f21b51ffd535e1a/src%2Fdoc%2Ftrpl%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvectors.md?ref=ff12b7b308cf79a61e4f578e6f21b51ffd535e1a", "patch": "@@ -1,37 +1,58 @@\n % Vectors\n \n-A *vector* is a dynamic or \"growable\" array, implemented as the standard\n-library type [`Vec<T>`](../std/vec/) (Where `<T>` is a [Generic](./generics.md)\n-statement). Vectors always allocate their data on the heap. Vectors are to\n-[slices][slices] what [`String`][string] is to `&str`. You can\n-create them with the `vec!` macro:\n-\n-```{rust}\n-let v = vec![1, 2, 3]; // v: Vec<i32>\n-```\n+A \u2018vector\u2019 is a dynamic or \u2018growable\u2019 array, implemented as the standard\n+library type [`Vec<T>`][vec]. That `<T>` is a [generic][generic], meaning we\n+can have vectors of any type. Vectors always allocate their data on the heap.\n+You can create them with the `vec!` macro:\n \n-[slices]: primitive-types.html#slices\n-[string]: strings.html\n+```rust\n+let v = vec![1, 2, 3, 4, 5]; // v: Vec<i32>\n+```\n \n-(Notice that unlike the `println!` macro we've used in the past, we use square\n-brackets `[]` with `vec!`. Rust allows you to use either in either situation,\n+(Notice that unlike the `println!` macro we\u2019ve used in the past, we use square\n+brackets `[]` with `vec!` macro. Rust allows you to use either in either situation,\n this is just convention.)\n \n-There's an alternate form of `vec!` for repeating an initial value:\n+There\u2019s an alternate form of `vec!` for repeating an initial value:\n \n ```\n let v = vec![0; 10]; // ten zeroes\n ```\n \n-You can get the length of, iterate over, and subscript vectors just like\n-arrays. In addition, (mutable) vectors can grow automatically:\n+## Accessing elements\n \n-```{rust}\n-let mut nums = vec![1, 2, 3]; // mut nums: Vec<i32>\n+To get the value at a particular index in the vector, we use `[]`s:\n \n-nums.push(4);\n+```rust\n+let v = vec![1, 2, 3, 4, 5];\n \n-println!(\"The length of nums is now {}\", nums.len()); // Prints 4\n+println!(\"The third element of v is {}\", v[2]);\n ```\n \n-Vectors have many more useful methods.\n+The indices count from `0`, so the third element is `v[2]`.\n+\n+## Iterating\n+\n+Once you have a vector, you can iterate through its elements with `for`. There\n+are three versions:\n+\n+```rust\n+let mut v = vec![1, 2, 3, 4, 5];\n+\n+for i in &v {\n+    println!(\"A reference to {}\", i);\n+}\n+\n+for i in &mut v {\n+    println!(\"A mutable reference to {}\", i);\n+}\n+\n+for i in v {\n+    println!(\"Take ownership of the vector and its element {}\", i);\n+}\n+```\n+\n+Vectors have many more useful methods, which you can read about in [their\n+API documentation][vec].\n+\n+[vec]: ../std/vec/index.html"}]}