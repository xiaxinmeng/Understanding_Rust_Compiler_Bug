{"sha": "78b7d4944c64cb6810c168bcd7edc4e900169464", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4YjdkNDk0NGM2NGNiNjgxMGMxNjhiY2Q3ZWRjNGU5MDAxNjk0NjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-08T01:50:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-08T01:50:28Z"}, "message": "Auto merge of #5576 - ebroto:manual_async_fn, r=flip1995\n\nAdd the manual_async_fn lint\n\nchangelog: Added the `manual_async_fn` lint to warn on functions that can be simplified using async syntax\n\nCloses #5503", "tree": {"sha": "2021e525e0b9ab6468472cceb49a9ac580f23335", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2021e525e0b9ab6468472cceb49a9ac580f23335"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78b7d4944c64cb6810c168bcd7edc4e900169464", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78b7d4944c64cb6810c168bcd7edc4e900169464", "html_url": "https://github.com/rust-lang/rust/commit/78b7d4944c64cb6810c168bcd7edc4e900169464", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78b7d4944c64cb6810c168bcd7edc4e900169464/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b63868dedb06a2637917ef2ee3fe96dc83ff9d50", "url": "https://api.github.com/repos/rust-lang/rust/commits/b63868dedb06a2637917ef2ee3fe96dc83ff9d50", "html_url": "https://github.com/rust-lang/rust/commit/b63868dedb06a2637917ef2ee3fe96dc83ff9d50"}, {"sha": "3e4bc026e2706b1cb21bad6d55726f8b5a1d4cf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e4bc026e2706b1cb21bad6d55726f8b5a1d4cf1", "html_url": "https://github.com/rust-lang/rust/commit/3e4bc026e2706b1cb21bad6d55726f8b5a1d4cf1"}], "stats": {"total": 424, "additions": 421, "deletions": 3}, "files": [{"sha": "8457d6ad05cf9d876fe7739d364189234bb9980d", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/78b7d4944c64cb6810c168bcd7edc4e900169464/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/78b7d4944c64cb6810c168bcd7edc4e900169464/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=78b7d4944c64cb6810c168bcd7edc4e900169464", "patch": "@@ -1422,6 +1422,7 @@ Released 2018-09-13\n [`lossy_float_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#lossy_float_literal\n [`macro_use_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#macro_use_imports\n [`main_recursion`]: https://rust-lang.github.io/rust-clippy/master/index.html#main_recursion\n+[`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic"}, {"sha": "fb2e9932b8e49a885f4fb45f443107b7ba1eb416", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78b7d4944c64cb6810c168bcd7edc4e900169464/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b7d4944c64cb6810c168bcd7edc4e900169464/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=78b7d4944c64cb6810c168bcd7edc4e900169464", "patch": "@@ -247,6 +247,7 @@ mod literal_representation;\n mod loops;\n mod macro_use;\n mod main_recursion;\n+mod manual_async_fn;\n mod manual_non_exhaustive;\n mod map_clone;\n mod map_unit_fn;\n@@ -629,6 +630,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &loops::WHILE_LET_ON_ITERATOR,\n         &macro_use::MACRO_USE_IMPORTS,\n         &main_recursion::MAIN_RECURSION,\n+        &manual_async_fn::MANUAL_ASYNC_FN,\n         &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n         &map_clone::MAP_CLONE,\n         &map_unit_fn::OPTION_MAP_UNIT_FN,\n@@ -1067,6 +1069,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n     store.register_late_pass(|| box match_on_vec_items::MatchOnVecItems);\n     store.register_early_pass(|| box manual_non_exhaustive::ManualNonExhaustive);\n+    store.register_late_pass(|| box manual_async_fn::ManualAsyncFn);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1284,6 +1287,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::WHILE_LET_LOOP),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n+        LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n@@ -1478,6 +1482,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::NEEDLESS_RANGE_LOOP),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n+        LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),"}, {"sha": "cb72a24058234dcafce74496cc8431f2391f67db", "filename": "clippy_lints/src/manual_async_fn.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/78b7d4944c64cb6810c168bcd7edc4e900169464/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b7d4944c64cb6810c168bcd7edc4e900169464/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=78b7d4944c64cb6810c168bcd7edc4e900169464", "patch": "@@ -0,0 +1,159 @@\n+use crate::utils::paths::FUTURE_FROM_GENERATOR;\n+use crate::utils::{match_function_call, snippet_block, snippet_opt, span_lint_and_then};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{\n+    AsyncGeneratorKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, GeneratorKind, GenericBound, HirId, IsAsync,\n+    ItemKind, TraitRef, Ty, TyKind, TypeBindingKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** It checks for manual implementations of `async` functions.\n+    ///\n+    /// **Why is this bad?** It's more idiomatic to use the dedicated syntax.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::future::Future;\n+    ///\n+    /// fn foo() -> impl Future<Output = i32> { async { 42 } }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::future::Future;\n+    ///\n+    /// async fn foo() -> i32 { 42 }\n+    /// ```\n+    pub MANUAL_ASYNC_FN,\n+    style,\n+    \"manual implementations of `async` functions can be simplified using the dedicated syntax\"\n+}\n+\n+declare_lint_pass!(ManualAsyncFn => [MANUAL_ASYNC_FN]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ManualAsyncFn {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'_>,\n+        body: &'tcx Body<'_>,\n+        span: Span,\n+        _: HirId,\n+    ) {\n+        if_chain! {\n+            if let Some(header) = kind.header();\n+            if let IsAsync::NotAsync = header.asyncness;\n+            // Check that this function returns `impl Future`\n+            if let FnRetTy::Return(ret_ty) = decl.output;\n+            if let Some(trait_ref) = future_trait_ref(cx, ret_ty);\n+            if let Some(output) = future_output_ty(trait_ref);\n+            // Check that the body of the function consists of one async block\n+            if let ExprKind::Block(block, _) = body.value.kind;\n+            if block.stmts.is_empty();\n+            if let Some(closure_body) = desugared_async_block(cx, block);\n+            then {\n+                let header_span = span.with_hi(ret_ty.span.hi());\n+\n+                span_lint_and_then(\n+                    cx,\n+                    MANUAL_ASYNC_FN,\n+                    header_span,\n+                    \"this function can be simplified using the `async fn` syntax\",\n+                    |diag| {\n+                        if_chain! {\n+                            if let Some(header_snip) = snippet_opt(cx, header_span);\n+                            if let Some(ret_pos) = header_snip.rfind(\"->\");\n+                            if let Some((ret_sugg, ret_snip)) = suggested_ret(cx, output);\n+                            then {\n+                                let help = format!(\"make the function `async` and {}\", ret_sugg);\n+                                diag.span_suggestion(\n+                                    header_span,\n+                                    &help,\n+                                    format!(\"async {}{}\", &header_snip[..ret_pos], ret_snip),\n+                                    Applicability::MachineApplicable\n+                                );\n+\n+                                let body_snip = snippet_block(cx, closure_body.value.span, \"..\", Some(block.span));\n+                                diag.span_suggestion(\n+                                    block.span,\n+                                    \"move the body of the async block to the enclosing function\",\n+                                    body_snip.to_string(),\n+                                    Applicability::MachineApplicable\n+                                );\n+                            }\n+                        }\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn future_trait_ref<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &'tcx Ty<'tcx>) -> Option<&'tcx TraitRef<'tcx>> {\n+    if_chain! {\n+        if let TyKind::Def(item_id, _) = ty.kind;\n+        let item = cx.tcx.hir().item(item_id.id);\n+        if let ItemKind::OpaqueTy(opaque) = &item.kind;\n+        if opaque.bounds.len() == 1;\n+        if let GenericBound::Trait(poly, _) = &opaque.bounds[0];\n+        if poly.trait_ref.trait_def_id() == cx.tcx.lang_items().future_trait();\n+        then {\n+            return Some(&poly.trait_ref);\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn future_output_ty<'tcx>(trait_ref: &'tcx TraitRef<'tcx>) -> Option<&'tcx Ty<'tcx>> {\n+    if_chain! {\n+        if let Some(segment) = trait_ref.path.segments.last();\n+        if let Some(args) = segment.args;\n+        if args.bindings.len() == 1;\n+        let binding = &args.bindings[0];\n+        if binding.ident.as_str() == \"Output\";\n+        if let TypeBindingKind::Equality{ty: output} = binding.kind;\n+        then {\n+            return Some(output)\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn desugared_async_block<'tcx>(cx: &LateContext<'_, 'tcx>, block: &'tcx Block<'tcx>) -> Option<&'tcx Body<'tcx>> {\n+    if_chain! {\n+        if let Some(block_expr) = block.expr;\n+        if let Some(args) = match_function_call(cx, block_expr, &FUTURE_FROM_GENERATOR);\n+        if args.len() == 1;\n+        if let Expr{kind: ExprKind::Closure(_, _, body_id, ..), ..} = args[0];\n+        let closure_body = cx.tcx.hir().body(body_id);\n+        if let Some(GeneratorKind::Async(AsyncGeneratorKind::Block)) = closure_body.generator_kind;\n+        then {\n+            return Some(closure_body);\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn suggested_ret(cx: &LateContext<'_, '_>, output: &Ty<'_>) -> Option<(&'static str, String)> {\n+    match output.kind {\n+        TyKind::Tup(tys) if tys.is_empty() => {\n+            let sugg = \"remove the return type\";\n+            Some((sugg, \"\".into()))\n+        },\n+        _ => {\n+            let sugg = \"return the output of the future directly\";\n+            snippet_opt(cx, output.span).map(|snip| (sugg, format!(\"-> {}\", snip)))\n+        },\n+    }\n+}"}, {"sha": "b3ad2ad9d9987e73205b42299003e146a7c80bd6", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/78b7d4944c64cb6810c168bcd7edc4e900169464/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b7d4944c64cb6810c168bcd7edc4e900169464/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=78b7d4944c64cb6810c168bcd7edc4e900169464", "patch": "@@ -42,6 +42,7 @@ pub const FMT_ARGUMENTS_NEW_V1_FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\n pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_TRAIT: [&str; 3] = [\"core\", \"convert\", \"From\"];\n+pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n pub const HASH: [&str; 2] = [\"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];"}, {"sha": "51d1cb2216a954c55e5907abc8c5885af1ea1a10", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/78b7d4944c64cb6810c168bcd7edc4e900169464/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b7d4944c64cb6810c168bcd7edc4e900169464/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=78b7d4944c64cb6810c168bcd7edc4e900169464", "patch": "@@ -1081,6 +1081,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"main_recursion\",\n     },\n+    Lint {\n+        name: \"manual_async_fn\",\n+        group: \"style\",\n+        desc: \"manual implementations of `async` functions can be simplified using the dedicated syntax\",\n+        deprecation: None,\n+        module: \"manual_async_fn\",\n+    },\n     Lint {\n         name: \"manual_memcpy\",\n         group: \"perf\","}, {"sha": "d3a920de4b6ad8a685f3c04096a3afd414826998", "filename": "tests/ui/future_not_send.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/78b7d4944c64cb6810c168bcd7edc4e900169464/tests%2Fui%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b7d4944c64cb6810c168bcd7edc4e900169464/tests%2Fui%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffuture_not_send.rs?ref=78b7d4944c64cb6810c168bcd7edc4e900169464", "patch": "@@ -41,6 +41,7 @@ impl Dummy {\n         self.private_future().await;\n     }\n \n+    #[allow(clippy::manual_async_fn)]\n     pub fn public_send(&self) -> impl std::future::Future<Output = bool> {\n         async { false }\n     }"}, {"sha": "d1863701bfe7c14dd0cd0a161d3b224530b4343e", "filename": "tests/ui/future_not_send.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78b7d4944c64cb6810c168bcd7edc4e900169464/tests%2Fui%2Ffuture_not_send.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78b7d4944c64cb6810c168bcd7edc4e900169464/tests%2Fui%2Ffuture_not_send.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffuture_not_send.stderr?ref=78b7d4944c64cb6810c168bcd7edc4e900169464", "patch": "@@ -96,13 +96,13 @@ LL |     }\n    = note: `std::rc::Rc<[u8]>` doesn't implement `std::marker::Sync`\n \n error: future cannot be sent between threads safely\n-  --> $DIR/future_not_send.rs:49:37\n+  --> $DIR/future_not_send.rs:50:37\n    |\n LL | async fn generic_future<T>(t: T) -> T\n    |                                     ^ future returned by `generic_future` is not `Send`\n    |\n note: future is not `Send` as this value is used across an await\n-  --> $DIR/future_not_send.rs:54:5\n+  --> $DIR/future_not_send.rs:55:5\n    |\n LL |     let rt = &t;\n    |         -- has type `&T` which is not `Send`\n@@ -114,7 +114,7 @@ LL | }\n    = note: `T` doesn't implement `std::marker::Sync`\n \n error: future cannot be sent between threads safely\n-  --> $DIR/future_not_send.rs:65:34\n+  --> $DIR/future_not_send.rs:66:34\n    |\n LL | async fn unclear_future<T>(t: T) {}\n    |                                  ^"}, {"sha": "6bb1032a17299108a9a2603662e5b25531e7114f", "filename": "tests/ui/manual_async_fn.fixed", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/78b7d4944c64cb6810c168bcd7edc4e900169464/tests%2Fui%2Fmanual_async_fn.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/78b7d4944c64cb6810c168bcd7edc4e900169464/tests%2Fui%2Fmanual_async_fn.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_async_fn.fixed?ref=78b7d4944c64cb6810c168bcd7edc4e900169464", "patch": "@@ -0,0 +1,67 @@\n+// run-rustfix\n+// edition:2018\n+#![warn(clippy::manual_async_fn)]\n+#![allow(unused)]\n+\n+use std::future::Future;\n+\n+async fn fut() -> i32 { 42 }\n+\n+async fn empty_fut()  {}\n+\n+async fn core_fut() -> i32 { 42 }\n+\n+// should be ignored\n+fn has_other_stmts() -> impl core::future::Future<Output = i32> {\n+    let _ = 42;\n+    async move { 42 }\n+}\n+\n+// should be ignored\n+fn not_fut() -> i32 {\n+    42\n+}\n+\n+// should be ignored\n+async fn already_async() -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+struct S {}\n+impl S {\n+    async fn inh_fut() -> i32 {\n+        // NOTE: this code is here just to check that the identation is correct in the suggested fix\n+        let a = 42;\n+        let b = 21;\n+        if a < b {\n+            let c = 21;\n+            let d = 42;\n+            if c < d {\n+                let _ = 42;\n+            }\n+        }\n+        42\n+    }\n+\n+    async fn meth_fut(&self) -> i32 { 42 }\n+\n+    async fn empty_fut(&self)  {}\n+\n+    // should be ignored\n+    fn not_fut(&self) -> i32 {\n+        42\n+    }\n+\n+    // should be ignored\n+    fn has_other_stmts() -> impl core::future::Future<Output = i32> {\n+        let _ = 42;\n+        async move { 42 }\n+    }\n+\n+    // should be ignored\n+    async fn already_async(&self) -> impl Future<Output = i32> {\n+        async { 42 }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d50c919188be13c4ff4111fa17e604771453da13", "filename": "tests/ui/manual_async_fn.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/78b7d4944c64cb6810c168bcd7edc4e900169464/tests%2Fui%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b7d4944c64cb6810c168bcd7edc4e900169464/tests%2Fui%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_async_fn.rs?ref=78b7d4944c64cb6810c168bcd7edc4e900169464", "patch": "@@ -0,0 +1,79 @@\n+// run-rustfix\n+// edition:2018\n+#![warn(clippy::manual_async_fn)]\n+#![allow(unused)]\n+\n+use std::future::Future;\n+\n+fn fut() -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+fn empty_fut() -> impl Future<Output = ()> {\n+    async {}\n+}\n+\n+fn core_fut() -> impl core::future::Future<Output = i32> {\n+    async move { 42 }\n+}\n+\n+// should be ignored\n+fn has_other_stmts() -> impl core::future::Future<Output = i32> {\n+    let _ = 42;\n+    async move { 42 }\n+}\n+\n+// should be ignored\n+fn not_fut() -> i32 {\n+    42\n+}\n+\n+// should be ignored\n+async fn already_async() -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+struct S {}\n+impl S {\n+    fn inh_fut() -> impl Future<Output = i32> {\n+        async {\n+            // NOTE: this code is here just to check that the identation is correct in the suggested fix\n+            let a = 42;\n+            let b = 21;\n+            if a < b {\n+                let c = 21;\n+                let d = 42;\n+                if c < d {\n+                    let _ = 42;\n+                }\n+            }\n+            42\n+        }\n+    }\n+\n+    fn meth_fut(&self) -> impl Future<Output = i32> {\n+        async { 42 }\n+    }\n+\n+    fn empty_fut(&self) -> impl Future<Output = ()> {\n+        async {}\n+    }\n+\n+    // should be ignored\n+    fn not_fut(&self) -> i32 {\n+        42\n+    }\n+\n+    // should be ignored\n+    fn has_other_stmts() -> impl core::future::Future<Output = i32> {\n+        let _ = 42;\n+        async move { 42 }\n+    }\n+\n+    // should be ignored\n+    async fn already_async(&self) -> impl Future<Output = i32> {\n+        async { 42 }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f278ee41aa335607a9f26dd265ddb16bcc9206d7", "filename": "tests/ui/manual_async_fn.stderr", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/78b7d4944c64cb6810c168bcd7edc4e900169464/tests%2Fui%2Fmanual_async_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78b7d4944c64cb6810c168bcd7edc4e900169464/tests%2Fui%2Fmanual_async_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_async_fn.stderr?ref=78b7d4944c64cb6810c168bcd7edc4e900169464", "patch": "@@ -0,0 +1,98 @@\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:8:1\n+   |\n+LL | fn fut() -> impl Future<Output = i32> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::manual-async-fn` implied by `-D warnings`\n+help: make the function `async` and return the output of the future directly\n+   |\n+LL | async fn fut() -> i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL | fn fut() -> impl Future<Output = i32> { 42 }\n+   |                                       ^^^^^^\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:12:1\n+   |\n+LL | fn empty_fut() -> impl Future<Output = ()> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and remove the return type\n+   |\n+LL | async fn empty_fut()  {\n+   | ^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL | fn empty_fut() -> impl Future<Output = ()> {}\n+   |                                            ^^\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:16:1\n+   |\n+LL | fn core_fut() -> impl core::future::Future<Output = i32> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and return the output of the future directly\n+   |\n+LL | async fn core_fut() -> i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL | fn core_fut() -> impl core::future::Future<Output = i32> { 42 }\n+   |                                                          ^^^^^^\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:38:5\n+   |\n+LL |     fn inh_fut() -> impl Future<Output = i32> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and return the output of the future directly\n+   |\n+LL |     async fn inh_fut() -> i32 {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL |     fn inh_fut() -> impl Future<Output = i32> {\n+LL |         // NOTE: this code is here just to check that the identation is correct in the suggested fix\n+LL |         let a = 42;\n+LL |         let b = 21;\n+LL |         if a < b {\n+LL |             let c = 21;\n+ ...\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:54:5\n+   |\n+LL |     fn meth_fut(&self) -> impl Future<Output = i32> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and return the output of the future directly\n+   |\n+LL |     async fn meth_fut(&self) -> i32 {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL |     fn meth_fut(&self) -> impl Future<Output = i32> { 42 }\n+   |                                                     ^^^^^^\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:58:5\n+   |\n+LL |     fn empty_fut(&self) -> impl Future<Output = ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and remove the return type\n+   |\n+LL |     async fn empty_fut(&self)  {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL |     fn empty_fut(&self) -> impl Future<Output = ()> {}\n+   |                                                     ^^\n+\n+error: aborting due to 6 previous errors\n+"}]}