{"sha": "b1d2a00b4a8846900b2456a4bda7952af26b8625", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZDJhMDBiNGE4ODQ2OTAwYjI0NTZhNGJkYTc5NTJhZjI2Yjg2MjU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-29T11:36:57Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-29T12:03:24Z"}, "message": "Remove support for obj dtors", "tree": {"sha": "eec9b4297afeac844a9070cf7872099963840599", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eec9b4297afeac844a9070cf7872099963840599"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1d2a00b4a8846900b2456a4bda7952af26b8625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1d2a00b4a8846900b2456a4bda7952af26b8625", "html_url": "https://github.com/rust-lang/rust/commit/b1d2a00b4a8846900b2456a4bda7952af26b8625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1d2a00b4a8846900b2456a4bda7952af26b8625/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30d2e358be6104adeabba5a7acb6d93f39b30d4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/30d2e358be6104adeabba5a7acb6d93f39b30d4b", "html_url": "https://github.com/rust-lang/rust/commit/30d2e358be6104adeabba5a7acb6d93f39b30d4b"}], "stats": {"total": 342, "additions": 19, "deletions": 323}, "files": [{"sha": "24cd256855cc7ad7ce519c7a29731df4650e837e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 11, "deletions": 61, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b1d2a00b4a8846900b2456a4bda7952af26b8625", "patch": "@@ -1327,11 +1327,10 @@ fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n                 cx.build.GEP(body,\n                              ~[C_int(0), C_int(abi::obj_body_elt_tydesc)]);\n             let tydesc = cx.build.Load(tydescptr);\n-            let cx_ = maybe_call_dtor(cx, v0);\n             let ti = none[@tydesc_info];\n-            call_tydesc_glue_full(cx_, body, tydesc,\n+            call_tydesc_glue_full(cx, body, tydesc,\n                                   abi::tydesc_field_drop_glue, ti);\n-            trans_non_gc_free(cx_, b)\n+            trans_non_gc_free(cx, b)\n           }\n           ty::ty_fn(_, _, _, _, _) {\n             let box_cell =\n@@ -2318,28 +2317,6 @@ fn call_tydesc_glue(cx: &@block_ctxt, v: ValueRef, t: &ty::t, field: int) ->\n     ret rslt(td.bcx, C_nil());\n }\n \n-fn maybe_call_dtor(cx: &@block_ctxt, v: ValueRef) -> @block_ctxt {\n-    let vtbl = cx.build.GEP(v, ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n-    vtbl = cx.build.Load(vtbl);\n-    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), 1u));\n-    vtbl = cx.build.PointerCast(vtbl, vtbl_type);\n-\n-    let dtor_ptr = cx.build.GEP(vtbl, ~[C_int(0), C_int(0)]);\n-    dtor_ptr = cx.build.Load(dtor_ptr);\n-    dtor_ptr = cx.build.BitCast(dtor_ptr, T_ptr(T_dtor(bcx_ccx(cx), cx.sp)));\n-    let dtor_cx = new_sub_block_ctxt(cx, \"dtor\");\n-    let after_cx = new_sub_block_ctxt(cx, \"after_dtor\");\n-    let test =\n-        cx.build.ICmp(lib::llvm::LLVMIntNE, dtor_ptr,\n-                      C_null(val_ty(dtor_ptr)));\n-    cx.build.CondBr(test, dtor_cx.llbb, after_cx.llbb);\n-    let me = dtor_cx.build.Load(v);\n-    dtor_cx.build.FastCall(dtor_ptr,\n-                           ~[C_null(T_ptr(T_nil())), cx.fcx.lltaskptr, me]);\n-    dtor_cx.build.Br(after_cx.llbb);\n-    ret after_cx;\n-}\n-\n fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: &ty::t,\n                  llop: ValueRef) -> result {\n     // We can't use call_tydesc_glue_full() and friends here because compare\n@@ -3943,8 +3920,7 @@ fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n       ast::expr_call(f, args) {\n         let pair =\n             create_real_fn_pair(cx, iter_body_llty, lliterbody, llenv.ptr);\n-        r =\n-            trans_call(cx, f, some[ValueRef](cx.build.Load(pair)), args,\n+        r = trans_call(cx, f, some[ValueRef](cx.build.Load(pair)), args,\n                        seq.id);\n         ret rslt(r.bcx, C_nil());\n       }\n@@ -4177,11 +4153,10 @@ fn trans_field(cx: &@block_ctxt, sp: &span, v: ValueRef, t0: &ty::t,\n             r.bcx.build.GEP(r.val, ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n         vtbl = r.bcx.build.Load(vtbl);\n \n-        let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 2u));\n+        let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n         vtbl = cx.build.PointerCast(vtbl, vtbl_type);\n \n-        // +1 because slot #0 contains the destructor\n-        let v = r.bcx.build.GEP(vtbl, ~[C_int(0), C_int(ix + 1u as int)]);\n+        let v = r.bcx.build.GEP(vtbl, ~[C_int(0), C_int(ix as int)]);\n         let fn_ty: ty::t = ty::method_ty_to_fn_ty(bcx_tcx(cx), methods.(ix));\n         let tcx = bcx_tcx(cx);\n         let ll_fn_ty =\n@@ -5701,8 +5676,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         {fields:\n              std::ivec::map(ast::obj_field_from_anon_obj_field,\n                             additional_fields),\n-         methods: anon_obj.methods,\n-         dtor: none[@ast::method]};\n+         methods: anon_obj.methods};\n \n     let inner_obj_ty: ty::t;\n     let vtbl;\n@@ -6666,13 +6640,12 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n       }\n     }\n \n-    // Pick out the original method from the vtable.  The +1 is because slot\n-    // #0 contains the destructor.\n-    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 2u));\n+    // Pick out the original method from the vtable.\n+    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n     llinner_obj_vtbl = bcx.build.PointerCast(llinner_obj_vtbl, vtbl_type);\n \n     let llorig_mthd =\n-        bcx.build.GEP(llinner_obj_vtbl, ~[C_int(0), C_int(ix + 1u as int)]);\n+        bcx.build.GEP(llinner_obj_vtbl, ~[C_int(0), C_int(ix as int)]);\n \n     // Set up the original method to be called.\n     let orig_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n@@ -6756,16 +6729,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n                inner_obj_ty: option::t[ty::t],\n                additional_field_tys: &ty::t[]) -> ValueRef {\n \n-    let dtor = C_null(T_ptr(T_i8()));\n-    alt ob.dtor {\n-      some(d) {\n-        let dtor_1 = trans_dtor(cx, outer_obj_ty, ty_params, d);\n-        dtor = llvm::LLVMConstBitCast(dtor_1, val_ty(dtor));\n-      }\n-      none. { }\n-    }\n-\n-    let llmethods: ValueRef[] = ~[dtor];\n+    let llmethods: ValueRef[] = ~[];\n     let meths: vtbl_mthd[] = ~[];\n     let backwarding_vtbl: option::t[ValueRef] = none;\n \n@@ -6911,28 +6875,14 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n     ret gvar;\n }\n \n-fn trans_dtor(cx: @local_ctxt, outer_obj_ty: ty::t,\n-              ty_params: &ast::ty_param[],\n-              dtor: &@ast::method) -> ValueRef {\n-    let llfnty = T_dtor(cx.ccx, dtor.span);\n-    let s: str = mangle_internal_name_by_path(cx.ccx, cx.path + ~[\"drop\"]);\n-    let llfn: ValueRef = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n-    cx.ccx.item_ids.insert(dtor.node.id, llfn);\n-    cx.ccx.item_symbols.insert(dtor.node.id, s);\n-    trans_fn(cx, dtor.span, dtor.node.meth, llfn, some(outer_obj_ty),\n-             ty_params, dtor.node.id);\n-    ret llfn;\n-}\n-\n fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n                            outer_obj_ty: ty::t) -> ValueRef {\n \n     // This vtbl needs to have slots for all of the methods on an inner\n     // object, and it needs to forward them to the corresponding slots on the\n     // outer object.  All we know about either one are their types.\n \n-    let dtor = C_null(T_ptr(T_i8()));\n-    let llmethods: ValueRef[] = ~[dtor];\n+    let llmethods: ValueRef[] = ~[];\n     let meths: vtbl_mthd[]= ~[];\n \n     // Gather up methods on the inner object."}, {"sha": "a15bf118bf17ed867279f2fc56991bc56ce05008", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=b1d2a00b4a8846900b2456a4bda7952af26b8625", "patch": "@@ -542,11 +542,6 @@ fn T_glue_fn(cx: &crate_ctxt) -> TypeRef {\n     ret t;\n }\n \n-fn T_dtor(ccx: &@crate_ctxt, sp: &span) -> TypeRef {\n-    ret type_of_fn_full(ccx, sp, ast::proto_fn, true, ~[],\n-                        ty::mk_nil(ccx.tcx), 0u);\n-}\n-\n fn T_cmp_glue_fn(cx: &crate_ctxt) -> TypeRef {\n     let s = \"cmp_glue_fn\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }"}, {"sha": "51c7d9708eb6453a325588044a5e9311ea2c0dd1", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=b1d2a00b4a8846900b2456a4bda7952af26b8625", "patch": "@@ -67,7 +67,6 @@ fn find_pre_post_obj(ccx: &crate_ctxt, o: _obj) {\n         find_pre_post_fn(fcx, m.node.meth);\n     }\n     for m: @method  in o.methods { do_a_method(ccx, m); }\n-    option::map[@method, ()](bind do_a_method(ccx, _), o.dtor);\n }\n \n fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {"}, {"sha": "18094658aeeab3a1fa7bb6113d0406dbaa9aec68", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=b1d2a00b4a8846900b2456a4bda7952af26b8625", "patch": "@@ -805,18 +805,6 @@ mod collect {\n                 write::ty_only(cx.tcx, fld.id, args.(i).ty);\n                 i += 1u;\n             }\n-\n-\n-            // Finally, write in the type of the destructor.\n-            alt object.dtor {\n-              none. {/* nothing to do */ }\n-              some(m) {\n-                let t =\n-                    ty::mk_fn(cx.tcx, ast::proto_fn, ~[], ty::mk_nil(cx.tcx),\n-                              ast::return, ~[]);\n-                write::ty_only(cx.tcx, m.node.id, t);\n-              }\n-            }\n           }\n           ast::item_res(f, dtor_id, tps, ctor_id) {\n             let t_arg = ty_of_arg(cx, f.decl.inputs.(0));\n@@ -2624,7 +2612,6 @@ fn check_item(ccx: @crate_ctxt, it: &@ast::item) {\n \n         // Typecheck the methods.\n         for method: @ast::method  in ob.methods { check_method(ccx, method); }\n-        option::may[@ast::method](bind check_method(ccx, _), ob.dtor);\n \n         // Now remove the info from the stack.\n         ivec::pop[obj_info](ccx.obj_infos);"}, {"sha": "d71a2b0b168d921c8bdc9094d023bb34292e632f", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=b1d2a00b4a8846900b2456a4bda7952af26b8625", "patch": "@@ -524,8 +524,7 @@ type obj_field = {mut: mutability, ty: @ty, ident: ident, id: node_id};\n type anon_obj_field =\n     {mut: mutability, ty: @ty, expr: @expr, ident: ident, id: node_id};\n \n-type _obj =\n-    {fields: obj_field[], methods: (@method)[], dtor: option::t[@method]};\n+type _obj = {fields: obj_field[], methods: (@method)[]};\n \n type anon_obj =\n     // New fields and methods, if they exist.\n@@ -590,16 +589,10 @@ tag item_ {\n     item_ty(@ty, ty_param[]);\n     item_tag(variant[], ty_param[]);\n     item_obj(_obj, ty_param[], /* constructor id */node_id);\n-    item_res(\n-             /* dtor */\n-             _fn,\n-\n-             /* dtor id */\n-             node_id,\n+    item_res(_fn, /* dtor */\n+             node_id, /* dtor id */\n              ty_param[],\n-\n-             /* ctor id */\n-             node_id);\n+             node_id /* ctor id */);\n }\n \n type native_item ="}, {"sha": "fee5b03174deefdcec89db5093ed24204a1d2842", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=b1d2a00b4a8846900b2456a4bda7952af26b8625", "patch": "@@ -232,8 +232,8 @@ fn noop_fold_item_underscore(i: &item_, fld: ast_fold) -> item_ {\n           }\n           item_obj(o, typms, d) {\n             item_obj({fields: ivec::map(fold_obj_field, o.fields),\n-                      methods: ivec::map(fld.fold_method, o.methods),\n-                      dtor: option::map(fld.fold_method, o.dtor)}, typms, d)\n+                      methods: ivec::map(fld.fold_method, o.methods)},\n+                     typms, d)\n           }\n           item_res(dtor, did, typms, cid) {\n             item_res(fld.fold_fn(dtor), did, typms, cid)"}, {"sha": "fa570aeee8af0ac899cb9b4c11dbb5272913a55c", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=b1d2a00b4a8846900b2456a4bda7952af26b8625", "patch": "@@ -1816,24 +1816,6 @@ fn parse_method(p: &parser) -> @ast::method {\n     ret @spanned(lo, f.body.span.hi, meth);\n }\n \n-fn parse_dtor(p: &parser) -> @ast::method {\n-    let lo = p.get_last_lo_pos();\n-    let b: ast::blk = parse_block(p);\n-    let inputs: ast::arg[] = ~[];\n-    let output: @ast::ty = @spanned(lo, lo, ast::ty_nil);\n-    // I guess dtors can't have constraints?\n-    let d: ast::fn_decl = {\n-        inputs: inputs,\n-        output: output,\n-        purity: ast::impure_fn,\n-        cf: ast::return,\n-        constraints: ~[]\n-    };\n-    let f: ast::_fn = {decl: d, proto: ast::proto_fn, body: b};\n-    let m: ast::method_ = {ident: \"drop\", meth: f, id: p.get_id()};\n-    ret @spanned(lo, f.body.span.hi, m);\n-}\n-\n fn parse_item_obj(p: &parser, attrs: &ast::attribute[]) ->\n    @ast::item {\n     let lo = p.get_last_lo_pos();\n@@ -1843,16 +1825,13 @@ fn parse_item_obj(p: &parser, attrs: &ast::attribute[]) ->\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                   parse_obj_field, p);\n     let meths: (@ast::method)[] = ~[];\n-    let dtor: option::t[@ast::method] = none;\n     expect(p, token::LBRACE);\n     while p.peek() != token::RBRACE {\n-        if eat_word(p, \"drop\") {\n-            dtor = some(parse_dtor(p));\n-        } else { meths += ~[parse_method(p)]; }\n+        meths += ~[parse_method(p)];\n     }\n     let hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n-    let ob: ast::_obj = {fields: fields.node, methods: meths, dtor: dtor};\n+    let ob: ast::_obj = {fields: fields.node, methods: meths};\n     ret mk_item(p, lo, hi, ident, ast::item_obj(ob, ty_params, p.get_id()),\n                 attrs);\n }"}, {"sha": "bf5460452b4ac6d830a725d5be108031e3a6c6a9", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=b1d2a00b4a8846900b2456a4bda7952af26b8625", "patch": "@@ -510,14 +510,6 @@ fn print_item(s: &ps, item: &@ast::item) {\n             word(s.s, \" \");\n             print_block(s, meth.node.meth.body);\n         }\n-        alt _obj.dtor {\n-          some(dtor) {\n-            space(s.s);\n-            head(s, \"drop\");\n-            print_block(s, dtor.node.meth.body);\n-          }\n-          _ { }\n-        }\n         bclose(s, item.span);\n       }\n       ast::item_res(dt, dt_id, tps, ct_id) {"}, {"sha": "3c2eb231647046012a7ac06c179fbee638e11d27", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=b1d2a00b4a8846900b2456a4bda7952af26b8625", "patch": "@@ -106,13 +106,6 @@ fn visit_item[E](i: &@item, e: &E, v: &vt[E]) {\n             v.visit_fn(m.node.meth, ~[], m.span, some(m.node.ident),\n                        m.node.id, e, v);\n         }\n-        alt ob.dtor {\n-          none. { }\n-          some(m) {\n-            v.visit_fn(m.node.meth, ~[], m.span, some(m.node.ident),\n-                       m.node.id, e, v);\n-          }\n-        }\n       }\n     }\n }"}, {"sha": "c0edb95009e19d412243e28b9fb85d30d5be46b3", "filename": "src/comp/syntax/walk.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fsyntax%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d2a00b4a8846900b2456a4bda7952af26b8625/src%2Fcomp%2Fsyntax%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fwalk.rs?ref=b1d2a00b4a8846900b2456a4bda7952af26b8625", "patch": "@@ -118,13 +118,6 @@ fn walk_item(v: &ast_visitor, i: @ast::item) {\n                     m.node.id);\n             v.visit_method_post(m);\n         }\n-        alt ob.dtor {\n-          none. { }\n-          some(m) {\n-            walk_fn(v, m.node.meth, ~[], m.span, some(m.node.ident),\n-                    m.node.id);\n-          }\n-        }\n       }\n     }\n     v.visit_item_post(i);"}, {"sha": "918939bab0c3424ec7f8347636aa17206ca8f59b", "filename": "src/test/compile-fail/capture2.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30d2e358be6104adeabba5a7acb6d93f39b30d4b/src%2Ftest%2Fcompile-fail%2Fcapture2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d2e358be6104adeabba5a7acb6d93f39b30d4b/src%2Ftest%2Fcompile-fail%2Fcapture2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcapture2.rs?ref=30d2e358be6104adeabba5a7acb6d93f39b30d4b", "patch": "@@ -1,14 +0,0 @@\n-// -*- rust -*-\n-\n-// error-pattern: attempted dynamic environment-capture\n-\n-fn f(x: bool) { }\n-\n-obj foobar(x: bool)\n-    {drop {\n-         let y = x;\n-         fn test() { f(y); }\n-     }\n-}\n-\n-fn main() { }\n\\ No newline at end of file"}, {"sha": "c3c824d7c6f5f1cae0eaf783e2723eafea8a5245", "filename": "src/test/compile-fail/use-uninit-dtor.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30d2e358be6104adeabba5a7acb6d93f39b30d4b/src%2Ftest%2Fcompile-fail%2Fuse-uninit-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d2e358be6104adeabba5a7acb6d93f39b30d4b/src%2Ftest%2Fcompile-fail%2Fuse-uninit-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit-dtor.rs?ref=30d2e358be6104adeabba5a7acb6d93f39b30d4b", "patch": "@@ -1,6 +0,0 @@\n-// error-pattern:Unsatisfied precondition\n-\n-fn main() {\n-    obj foo(x: int) {drop { let baz: int; log baz; } }\n-    fail;\n-}\n\\ No newline at end of file"}, {"sha": "ae504a7916fad1485ca40b5babb34e2762e74e62", "filename": "src/test/run-pass/destructor-ordering.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/30d2e358be6104adeabba5a7acb6d93f39b30d4b/src%2Ftest%2Frun-pass%2Fdestructor-ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d2e358be6104adeabba5a7acb6d93f39b30d4b/src%2Ftest%2Frun-pass%2Fdestructor-ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdestructor-ordering.rs?ref=30d2e358be6104adeabba5a7acb6d93f39b30d4b", "patch": "@@ -1,123 +0,0 @@\n-// xfail-stage0\n-// xfail-stage1\n-// xfail-stage2\n-// xfail-stage3\n-// This test checks that destructors run in the right order.  Because\n-// stateful objects can't have destructors, we have the destructors\n-// record their expected order into a channel when they execute (so\n-// the object becomes 'io' rather than 'state').  Then each test case\n-// asserts that the channel produces values in ascending order.\n-//\n-// FIXME: Write an int->str function and concatenate the whole failure\n-// message into a single log statement (or, even better, a print).\n-//\n-// FIXME: check_order should take only 1 line in a test, not 2+a block\n-// block. Since destructor-having objects can't refer to mutable state\n-// (like the port), we'd need a with-like construct to do the same for\n-// stateful objects within a scope.\n-//\n-// FIXME #21: Each test should execute in its own task, so it can fail\n-// independently, writing its error message to a channel that the\n-// parent task aggregates.\n-\n-type order_info = rec(int order, str msg);\n-\n-io fn check_order(port[order_info] expected_p) {\n-  chan(expected_p) <| rec(order=-1, msg=\"\");\n-  let mutable int actual = 0;\n-  // FIXME #121: Workaround for while(true) bug.\n-  auto expected; expected_p |> expected;\n-  auto done = -1;  // FIXME: Workaround for typechecking bug.\n-  while(expected.order != done) {\n-    if (expected.order != actual) {\n-      log expected.order;\n-      log \" != \";\n-      log actual;\n-      log expected.msg;\n-      fail;\n-    }\n-    actual += 1;\n-    expected_p |> expected;\n-  }\n-}\n-\n-\n-obj dorder(chan[order_info] expected, int order, str message) {\n-  drop {\n-    expected <| rec(order=order, msg=message);\n-  }\n-}\n-\n-io fn test_simple() {\n-  let port[order_info] tracker_p = port();\n-  auto tracker = chan(tracker_p);\n-  dorder(tracker, 1, \"Reverse decl order\");\n-  dorder(tracker, 0, \"Reverse decl order\");\n-  check_order(tracker_p);\n-}\n-\n-io fn test_block() {\n-  let port[order_info] tracker_p = port();\n-  auto tracker = chan(tracker_p);\n-  {\n-    dorder(tracker, 2, \"Before block\");\n-    {\n-      dorder(tracker, 0, \"Inside block\");\n-    }\n-    dorder(tracker, 1, \"After block\");\n-  }\n-  check_order(tracker_p);\n-}\n-\n-io fn test_decl_v_init() {\n-  let port[order_info] tracker_p = port();\n-  auto tracker = chan(tracker_p);\n-  {\n-    auto var1;\n-    auto var2;\n-    var2 = dorder(tracker, 0, \"decl, not init\");\n-    var1 = dorder(tracker, 1, \"decl, not init\");\n-  }\n-  check_order(tracker_p);\n-}\n-\n-io fn test_overwritten_obj() {\n-  let port[order_info] tracker_p = port();\n-  auto tracker = chan(tracker_p);\n-  {\n-    auto var1 = dorder(tracker, 0, \"overwritten object destroyed first\");\n-    auto var2 = dorder(tracker, 2, \"destroyed at end of scope\");\n-    var1 = dorder(tracker, 3, \"overwriter deleted in rev decl order\");\n-    {\n-      dorder(tracker, 1, \"overwritten object destroyed before end of scope\");\n-    }\n-  }\n-  check_order(tracker_p);\n-}\n-\n-// Used to embed dorder objects into an expression.  Note that the\n-// parameters don't get destroyed.\n-fn combine_dorders(dorder d1, dorder d2) -> int {\n-  ret 1;\n-}\n-io fn test_expression_destroyed_right_to_left() {\n-  let port[order_info] tracker_p = port();\n-  auto tracker = chan(tracker_p);\n-  {\n-    combine_dorders(dorder(tracker, 4, \"\"), dorder(tracker, 3, \"\"))\n-      / combine_dorders(dorder(tracker, 2, \"\"), dorder(tracker, 1, \"\"));\n-    {\n-      dorder(tracker, 0,\n-             \"expression objects live to end of block, not statement\");\n-    }\n-  }\n-  check_order(tracker_p);\n-}\n-\n-io fn main() {\n-  test_simple();\n-  test_block();\n-  test_decl_v_init();\n-  test_overwritten_obj();\n-  test_expression_destroyed_right_to_left();\n-}"}, {"sha": "ed018c2eabe145f90cac6ff01614347b75b59e83", "filename": "src/test/run-pass/obj-dtor-2.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30d2e358be6104adeabba5a7acb6d93f39b30d4b/src%2Ftest%2Frun-pass%2Fobj-dtor-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d2e358be6104adeabba5a7acb6d93f39b30d4b/src%2Ftest%2Frun-pass%2Fobj-dtor-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-dtor-2.rs?ref=30d2e358be6104adeabba5a7acb6d93f39b30d4b", "patch": "@@ -1,9 +0,0 @@\n-\n-\n-obj foo(x: @mutable int) {drop { log \"running dtor\"; *x = *x + 1; } }\n-\n-fn main() {\n-    let mbox = @mutable 10;\n-    { let x = foo(mbox); }\n-    assert (*mbox == 11);\n-}\n\\ No newline at end of file"}, {"sha": "416e399a6b590a5926a71bb8e952e98af58b51e3", "filename": "src/test/run-pass/obj-dtor.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/30d2e358be6104adeabba5a7acb6d93f39b30d4b/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d2e358be6104adeabba5a7acb6d93f39b30d4b/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-dtor.rs?ref=30d2e358be6104adeabba5a7acb6d93f39b30d4b", "patch": "@@ -1,33 +0,0 @@\n-\n-\n-\n-// xfail-stage0\n-// xfail-stage1\n-// xfail-stage2\n-// xfail-stage3\n-obj worker(c: chan[int]) {drop { log \"in dtor\"; c <| 10; } }\n-\n-fn do_work(c: chan[int]) {\n-    log \"in child task\";\n-    { let w: worker = worker(c); log \"constructed worker\"; }\n-    log \"destructed worker\";\n-    while true {\n-        // Deadlock-condition not handled properly yet, need to avoid\n-        // exiting the child early.\n-\n-        c <| 11;\n-        yield;\n-    }\n-}\n-\n-fn main() {\n-    let p: port[int] = port();\n-    log \"spawning worker\";\n-    let w = spawn do_work(chan(p));\n-    let i: int;\n-    log \"parent waiting for shutdown\";\n-    p |> i;\n-    log \"received int\";\n-    assert (i == 10);\n-    log \"int is OK, child-dtor ran as expected\";\n-}\n\\ No newline at end of file"}]}