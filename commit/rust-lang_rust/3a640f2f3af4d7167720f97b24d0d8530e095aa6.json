{"sha": "3a640f2f3af4d7167720f97b24d0d8530e095aa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNjQwZjJmM2FmNGQ3MTY3NzIwZjk3YjI0ZDBkODUzMGUwOTVhYTY=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-10-09T10:04:44Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-10-10T13:52:57Z"}, "message": "Clean up hard to follow control flow", "tree": {"sha": "b486d27c2b37abb93836a4f9799f238684230bc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b486d27c2b37abb93836a4f9799f238684230bc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a640f2f3af4d7167720f97b24d0d8530e095aa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a640f2f3af4d7167720f97b24d0d8530e095aa6", "html_url": "https://github.com/rust-lang/rust/commit/3a640f2f3af4d7167720f97b24d0d8530e095aa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a640f2f3af4d7167720f97b24d0d8530e095aa6/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90e0fedb5622e2043042927f9accde4aa5ed1e9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/90e0fedb5622e2043042927f9accde4aa5ed1e9d", "html_url": "https://github.com/rust-lang/rust/commit/90e0fedb5622e2043042927f9accde4aa5ed1e9d"}], "stats": {"total": 87, "additions": 45, "deletions": 42}, "files": [{"sha": "61a61a925b057d3e813efdc3e0af628799a963a1", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 45, "deletions": 42, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3a640f2f3af4d7167720f97b24d0d8530e095aa6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a640f2f3af4d7167720f97b24d0d8530e095aa6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3a640f2f3af4d7167720f97b24d0d8530e095aa6", "patch": "@@ -291,20 +291,40 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n         });\n         debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n-        let result = match result {\n-            Ok((_, Res::Err)) => Err(()),\n-            x => x,\n+        let result = match result.map(|(_, res)| res) {\n+            Ok(Res::Err) | Err(()) => {\n+                // resolver doesn't know about true and false so we'll have to resolve them\n+                // manually as bool\n+                if let Some((_, res)) = is_bool_value(path_str, ns) { Ok(res) } else { Err(()) }\n+            }\n+            Ok(res) => Ok(res.map_id(|_| panic!(\"unexpected node_id\"))),\n         };\n \n-        if let Ok((_, res)) = result {\n-            let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-            // In case this is a trait item, skip the\n-            // early return and try looking for the trait.\n-            let value = match res {\n-                Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => true,\n-                Res::Def(DefKind::AssocTy, _) => false,\n+        if let Ok(res) = result {\n+            match res {\n+                Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => {\n+                    if ns != ValueNS {\n+                        return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n+                    } else {\n+                        // In case this is a trait item, skip the\n+                        // early return and try looking for the trait.\n+                    }\n+                }\n+                Res::Def(DefKind::AssocTy, _) => {\n+                    if ns == ValueNS {\n+                        return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n+                    } else {\n+                        // In case this is a trait item, skip the\n+                        // early return and try looking for the trait.\n+                    }\n+                }\n                 Res::Def(DefKind::Variant, _) => {\n-                    return handle_variant(cx, res, extra_fragment);\n+                    if extra_fragment.is_some() {\n+                        return Err(ErrorKind::AnchorFailure(\n+                            AnchorFailure::RustdocAnchorConflict(res),\n+                        ));\n+                    }\n+                    return handle_variant(cx, res);\n                 }\n                 // Not a trait item; just return what we found.\n                 Res::PrimTy(ty) => {\n@@ -321,17 +341,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 _ => {\n                     return Ok((res, extra_fragment.clone()));\n                 }\n-            };\n-\n-            if value != (ns == ValueNS) {\n-                return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n             }\n-        // FIXME: why is this necessary?\n-        } else if let Some((path, prim)) = is_primitive(path_str, ns) {\n-            if extra_fragment.is_some() {\n-                return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(prim)));\n-            }\n-            return Ok((prim, Some(path.to_owned())));\n         }\n \n         // Try looking for methods and associated items.\n@@ -1936,21 +1946,17 @@ fn privacy_error(\n fn handle_variant(\n     cx: &DocContext<'_>,\n     res: Res,\n-    extra_fragment: &Option<String>,\n ) -> Result<(Res, Option<String>), ErrorKind<'static>> {\n     use rustc_middle::ty::DefIdTree;\n \n-    if extra_fragment.is_some() {\n-        return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res)));\n-    }\n-    let parent = if let Some(parent) = cx.tcx.parent(res.def_id()) {\n-        parent\n-    } else {\n-        return Err(ResolutionFailure::NoParentItem.into());\n-    };\n-    let parent_def = Res::Def(DefKind::Enum, parent);\n-    let variant = cx.tcx.expect_variant_res(res);\n-    Ok((parent_def, Some(format!(\"variant.{}\", variant.ident.name))))\n+    cx.tcx.parent(res.def_id()).map_or_else(\n+        || Err(ResolutionFailure::NoParentItem.into()),\n+        |parent| {\n+            let parent_def = Res::Def(DefKind::Enum, parent);\n+            let variant = cx.tcx.expect_variant_res(res);\n+            Ok((parent_def, Some(format!(\"variant.{}\", variant.ident.name))))\n+        },\n+    )\n }\n \n const PRIMITIVES: &[(&str, Res)] = &[\n@@ -1970,19 +1976,16 @@ const PRIMITIVES: &[(&str, Res)] = &[\n     (\"f64\", Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F64))),\n     (\"str\", Res::PrimTy(hir::PrimTy::Str)),\n     (\"bool\", Res::PrimTy(hir::PrimTy::Bool)),\n-    (\"true\", Res::PrimTy(hir::PrimTy::Bool)),\n-    (\"false\", Res::PrimTy(hir::PrimTy::Bool)),\n     (\"char\", Res::PrimTy(hir::PrimTy::Char)),\n ];\n \n fn is_primitive(path_str: &str, ns: Namespace) -> Option<(&'static str, Res)> {\n-    if ns == TypeNS {\n-        PRIMITIVES\n-            .iter()\n-            .filter(|x| x.0 == path_str)\n-            .copied()\n-            .map(|x| if x.0 == \"true\" || x.0 == \"false\" { (\"bool\", x.1) } else { x })\n-            .next()\n+    if ns == TypeNS { PRIMITIVES.iter().find(|x| x.0 == path_str).copied() } else { None }\n+}\n+\n+fn is_bool_value(path_str: &str, ns: Namespace) -> Option<(&'static str, Res)> {\n+    if ns == TypeNS && (path_str == \"true\" || path_str == \"false\") {\n+        Some((\"bool\", Res::PrimTy(hir::PrimTy::Bool)))\n     } else {\n         None\n     }"}]}