{"sha": "f85fbcb67fd7d82aaeb784b80997cac54ecdc999", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NWZiY2I2N2ZkN2Q4MmFhZWI3ODRiODA5OTdjYWM1NGVjZGM5OTk=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-26T19:58:58Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-26T19:58:58Z"}, "message": "Revert \"Clean up a bunch of box related code.\"\n\nThis reverts commit bacf9e9887872a40d16798813aa66b6916cc6a4e.", "tree": {"sha": "24a45012575897f9a47c1ef5cbccb751a4cb2f57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24a45012575897f9a47c1ef5cbccb751a4cb2f57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f85fbcb67fd7d82aaeb784b80997cac54ecdc999", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f85fbcb67fd7d82aaeb784b80997cac54ecdc999", "html_url": "https://github.com/rust-lang/rust/commit/f85fbcb67fd7d82aaeb784b80997cac54ecdc999", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f85fbcb67fd7d82aaeb784b80997cac54ecdc999/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6141f5ce5a6da9dd67f96585feda88e4cbc747d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6141f5ce5a6da9dd67f96585feda88e4cbc747d9", "html_url": "https://github.com/rust-lang/rust/commit/6141f5ce5a6da9dd67f96585feda88e4cbc747d9"}], "stats": {"total": 65, "additions": 38, "deletions": 27}, "files": [{"sha": "05ec7d074c8be60f85fd7bd461d06e385d9d0082", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f85fbcb67fd7d82aaeb784b80997cac54ecdc999/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85fbcb67fd7d82aaeb784b80997cac54ecdc999/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f85fbcb67fd7d82aaeb784b80997cac54ecdc999", "patch": "@@ -398,16 +398,18 @@ fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef) ->\n     ret {box: box, body: body};\n }\n \n-fn malloc_general(bcx: block, t: ty::t, heap: heap) ->\n-    {box: ValueRef, body: ValueRef} {\n-    malloc_general_dyn(bcx, t, heap,\n-                       llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n-}\n fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n-    malloc_general(bcx, t, heap_shared)\n+    malloc_general_dyn(bcx, t, heap_shared,\n+                       llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n }\n fn malloc_unique(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n-    malloc_general(bcx, t, heap_exchange)\n+    malloc_general_dyn(bcx, t, heap_exchange,\n+                       llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n+}\n+\n+fn malloc_unique_dyn(bcx: block, t: ty::t, size: ValueRef\n+                    ) -> {box: ValueRef, body: ValueRef} {\n+    malloc_general_dyn(bcx, t, heap_exchange, size)\n }\n \n // Type descriptor and type glue stuff\n@@ -1485,19 +1487,6 @@ fn trans_lit(cx: block, e: @ast::expr, lit: ast::lit, dest: dest) -> block {\n     }\n }\n \n-\n-fn trans_boxed_expr(bcx: block, contents: @ast::expr,\n-                    t: ty::t, heap: heap,\n-                    dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_boxed_expr\");\n-    let {box, body} = malloc_general(bcx, t, heap);\n-    add_clean_free(bcx, box, true);\n-    let bcx = trans_expr_save_in(bcx, contents, body);\n-    revoke_clean(bcx, box);\n-    ret store_in_dest(bcx, box, dest);\n-}\n-\n-\n fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n                un_expr: @ast::expr, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_unary\");\n@@ -1520,25 +1509,35 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n     alt op {\n       ast::not {\n         let {bcx, val} = trans_temp_expr(bcx, e);\n-        store_in_dest(bcx, Not(bcx, val), dest)\n+        ret store_in_dest(bcx, Not(bcx, val), dest);\n       }\n       ast::neg {\n         let {bcx, val} = trans_temp_expr(bcx, e);\n         let neg = if ty::type_is_fp(e_ty) {\n             FNeg(bcx, val)\n         } else { Neg(bcx, val) };\n-        store_in_dest(bcx, neg, dest)\n+        ret store_in_dest(bcx, neg, dest);\n       }\n       ast::box(_) {\n-        trans_boxed_expr(bcx, e, e_ty, heap_shared, dest)\n+        let mut {box, body} = malloc_boxed(bcx, e_ty);\n+        add_clean_free(bcx, box, false);\n+        // Cast the body type to the type of the value. This is needed to\n+        // make enums work, since enums have a different LLVM type depending\n+        // on whether they're boxed or not\n+        let ccx = bcx.ccx();\n+        let llety = T_ptr(type_of(ccx, e_ty));\n+        body = PointerCast(bcx, body, llety);\n+        let bcx = trans_expr_save_in(bcx, e, body);\n+        revoke_clean(bcx, box);\n+        ret store_in_dest(bcx, box, dest);\n       }\n       ast::uniq(_) {\n-        trans_boxed_expr(bcx, e, e_ty, heap_exchange, dest)\n+        ret uniq::trans_uniq(bcx, e, un_expr.id, dest);\n       }\n       ast::deref {\n         bcx.sess().bug(\"deref expressions should have been \\\n                                translated using trans_lval(), not \\\n-                               trans_unary()\")\n+                               trans_unary()\");\n       }\n     }\n }"}, {"sha": "ec4fd7680baf79f7a7a04259a2e00160718b4967", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f85fbcb67fd7d82aaeb784b80997cac54ecdc999/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85fbcb67fd7d82aaeb784b80997cac54ecdc999/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=f85fbcb67fd7d82aaeb784b80997cac54ecdc999", "patch": "@@ -5,7 +5,19 @@ import build::*;\n import base::*;\n import shape::llsize_of;\n \n-export make_free_glue, autoderef, duplicate;\n+export trans_uniq, make_free_glue, autoderef, duplicate;\n+\n+fn trans_uniq(bcx: block, contents: @ast::expr,\n+              node_id: ast::node_id, dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"uniq::trans_uniq\");\n+    let uniq_ty = node_id_type(bcx, node_id);\n+    let contents_ty = content_ty(uniq_ty);\n+    let {box, body} = malloc_unique(bcx, contents_ty);\n+    add_clean_free(bcx, box, true);\n+    let bcx = trans_expr_save_in(bcx, contents, body);\n+    revoke_clean(bcx, box);\n+    ret store_in_dest(bcx, box, dest);\n+}\n \n fn make_free_glue(bcx: block, vptr: ValueRef, t: ty::t)\n     -> block {\n@@ -52,4 +64,4 @@ fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     Store(bcx, td, dst_tydesc_ptr);\n \n     ret rslt(bcx, dst_box);\n-}\n+}\n\\ No newline at end of file"}]}