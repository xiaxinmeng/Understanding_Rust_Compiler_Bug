{"sha": "4f13879218c736e77350d56b9a053d3f009e2ddb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMTM4NzkyMThjNzM2ZTc3MzUwZDU2YjlhMDUzZDNmMDA5ZTJkZGI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-19T01:43:07Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-19T01:43:07Z"}, "message": "rustc: Allocate derived tydescs before dynamically sized allocas", "tree": {"sha": "8fae1b9a8baf7664e3e8d77271db1ad8c520654f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fae1b9a8baf7664e3e8d77271db1ad8c520654f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f13879218c736e77350d56b9a053d3f009e2ddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f13879218c736e77350d56b9a053d3f009e2ddb", "html_url": "https://github.com/rust-lang/rust/commit/4f13879218c736e77350d56b9a053d3f009e2ddb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f13879218c736e77350d56b9a053d3f009e2ddb/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "877f001512b2ce16d86d5d4cf16d81e509294d79", "url": "https://api.github.com/repos/rust-lang/rust/commits/877f001512b2ce16d86d5d4cf16d81e509294d79", "html_url": "https://github.com/rust-lang/rust/commit/877f001512b2ce16d86d5d4cf16d81e509294d79"}], "stats": {"total": 112, "additions": 74, "deletions": 38}, "files": [{"sha": "f2e35ad0546515027fd3c8ac72c4f270cef141bb", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 74, "deletions": 38, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/4f13879218c736e77350d56b9a053d3f009e2ddb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f13879218c736e77350d56b9a053d3f009e2ddb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4f13879218c736e77350d56b9a053d3f009e2ddb", "patch": "@@ -191,20 +191,28 @@ type fn_ctxt =\n         // administrative activities that have to happen in only one place in\n         // the function, due to LLVM's quirks.\n \n-        // A block for all the function's allocas, so that LLVM will coalesce\n-        // them into a single alloca call.\n-        mutable BasicBlockRef llallocas,\n+        // A block for all the function's static allocas, so that LLVM will\n+        // coalesce them into a single alloca call.\n+        mutable BasicBlockRef llstaticallocas,\n \n         // A block containing code that copies incoming arguments to space\n-        // already allocated by code in the llallocas block.  (LLVM requires\n-        // that arguments be copied to local allocas before allowing most any\n-        // operation to be performed on them.)\n+        // already allocated by code in one of the llallocas blocks.  (LLVM\n+        // requires that arguments be copied to local allocas before allowing\n+        // most any operation to be performed on them.)\n         mutable BasicBlockRef llcopyargs,\n \n-        // A block containing derived tydescs received from the runtime.  See\n-        // description of derived_tydescs, below.\n+        // The first block containing derived tydescs received from the\n+        // runtime.  See description of derived_tydescs, below.\n+        mutable BasicBlockRef llderivedtydescs_first,\n+\n+        // The last block of the llderivedtydescs group.\n         mutable BasicBlockRef llderivedtydescs,\n \n+        // A block for all of the dynamically sized allocas.  This must be\n+        // after llderivedtydescs, because these sometimes depend on\n+        // information computed from derived tydescs.\n+        mutable BasicBlockRef lldynamicallocas,\n+\n         // FIXME: Is llcopyargs actually the block containing the allocas for\n         // incoming function arguments?  Or is it merely the block containing\n         // code that copies incoming args to space already alloca'd by code in\n@@ -1173,11 +1181,11 @@ fn align_of(&@block_ctxt cx, &ty::t t) -> result {\n }\n \n fn alloca(&@block_ctxt cx, TypeRef t) -> ValueRef {\n-    ret new_builder(cx.fcx.llallocas).Alloca(t);\n+    ret new_builder(cx.fcx.llstaticallocas).Alloca(t);\n }\n \n fn array_alloca(&@block_ctxt cx, TypeRef t, ValueRef n) -> ValueRef {\n-    ret new_builder(cx.fcx.llallocas).ArrayAlloca(t, n);\n+    ret new_builder(cx.fcx.lldynamicallocas).ArrayAlloca(t, n);\n }\n \n \n@@ -3556,7 +3564,7 @@ mod ivec {\n \n         auto bcx;\n         if (dynamic) {\n-            bcx = llallocas_block_ctxt(cx.fcx);\n+            bcx = llderivedtydescs_block_ctxt(cx.fcx);\n         } else {\n             bcx = cx;\n         }\n@@ -3565,26 +3573,25 @@ mod ivec {\n         auto rslt = size_of(bcx, unit_ty);\n         bcx = rslt.bcx;\n         llunitsz = rslt.val;\n-        if (dynamic) { bcx.fcx.llallocas = bcx.llbb; }\n+\n+        if (dynamic) { cx.fcx.llderivedtydescs = bcx.llbb; }\n \n         auto llalen = bcx.build.Mul(llunitsz,\n                                     C_uint(abi::ivec_default_length));\n \n         auto llptr;\n         auto llunitty = type_of_or_i8(bcx, unit_ty);\n+        auto bcx_result;\n         if (dynamic) {\n             auto llarraysz = bcx.build.Add(llsize_of(T_opaque_ivec()),\n                                            llalen);\n             auto llvecptr = array_alloca(bcx, T_i8(), llarraysz);\n-            llptr = bcx.build.PointerCast(llvecptr, T_ptr(T_opaque_ivec()));\n-        } else {\n-            llptr = alloca(bcx, T_ivec(llunitty));\n-        }\n \n-        auto bcx_result;\n-        if (dynamic) {\n             bcx_result = cx;\n+            llptr = bcx_result.build.PointerCast(llvecptr,\n+                                                 T_ptr(T_opaque_ivec()));\n         } else {\n+            llptr = alloca(bcx, T_ivec(llunitty));\n             bcx_result = bcx;\n         }\n \n@@ -6753,27 +6760,51 @@ iter block_locals(&ast::block b) -> @ast::local {\n     }\n }\n \n-fn llallocas_block_ctxt(&@fn_ctxt fcx) -> @block_ctxt {\n+fn llstaticallocas_block_ctxt(&@fn_ctxt fcx) -> @block_ctxt {\n+    let vec[cleanup] cleanups = [];\n+    ret @rec(llbb=fcx.llstaticallocas,\n+             build=new_builder(fcx.llstaticallocas),\n+             parent=parent_none,\n+             kind=SCOPE_BLOCK,\n+             mutable cleanups=cleanups,\n+             sp=fcx.sp,\n+             fcx=fcx);\n+}\n+\n+fn llderivedtydescs_block_ctxt(&@fn_ctxt fcx) -> @block_ctxt {\n+    let vec[cleanup] cleanups = [];\n+    ret @rec(llbb=fcx.llderivedtydescs,\n+             build=new_builder(fcx.llderivedtydescs),\n+             parent=parent_none,\n+             kind=SCOPE_BLOCK,\n+             mutable cleanups=cleanups,\n+             sp=fcx.sp,\n+             fcx=fcx);\n+}\n+\n+fn lldynamicallocas_block_ctxt(&@fn_ctxt fcx) -> @block_ctxt {\n     let vec[cleanup] cleanups = [];\n-    ret @rec(llbb=fcx.llallocas,\n-             build=new_builder(fcx.llallocas),\n+    ret @rec(llbb=fcx.lldynamicallocas,\n+             build=new_builder(fcx.lldynamicallocas),\n              parent=parent_none,\n              kind=SCOPE_BLOCK,\n              mutable cleanups=cleanups,\n              sp=fcx.sp,\n              fcx=fcx);\n }\n \n+\n+\n fn alloc_ty(&@block_ctxt cx, &ty::t t) -> result {\n     auto val = C_int(0);\n     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         // NB: we have to run this particular 'size_of' in a\n-        // block_ctxt built on the llallocas block for the fn,\n+        // block_ctxt built on the llderivedtydescs block for the fn,\n         // so that the size dominates the array_alloca that\n         // comes next.\n \n-        auto n = size_of(llallocas_block_ctxt(cx.fcx), t);\n-        cx.fcx.llallocas = n.bcx.llbb;\n+        auto n = size_of(llderivedtydescs_block_ctxt(cx.fcx), t);\n+        cx.fcx.llderivedtydescs = n.bcx.llbb;\n         val = array_alloca(cx, T_i8(), n.val);\n     } else { val = alloca(cx, type_of(cx.fcx.lcx.ccx, cx.sp, t)); }\n     // NB: since we've pushed all size calculations in this\n@@ -6862,13 +6893,14 @@ fn new_local_ctxt(&@crate_ctxt ccx) -> @local_ctxt {\n }\n \n \n-// Creates the standard trio of basic blocks: allocas, copy-args, and derived\n-// tydescs.\n+// Creates the standard quartet of basic blocks: static allocas, copy args,\n+// derived tydescs, and dynamic allocas.\n fn mk_standard_basic_blocks(ValueRef llfn) ->\n-   tup(BasicBlockRef, BasicBlockRef, BasicBlockRef) {\n-    ret tup(llvm::LLVMAppendBasicBlock(llfn, str::buf(\"allocas\")),\n+   tup(BasicBlockRef, BasicBlockRef, BasicBlockRef, BasicBlockRef) {\n+    ret tup(llvm::LLVMAppendBasicBlock(llfn, str::buf(\"static_allocas\")),\n             llvm::LLVMAppendBasicBlock(llfn, str::buf(\"copy_args\")),\n-            llvm::LLVMAppendBasicBlock(llfn, str::buf(\"derived_tydescs\")));\n+            llvm::LLVMAppendBasicBlock(llfn, str::buf(\"derived_tydescs\")),\n+            llvm::LLVMAppendBasicBlock(llfn, str::buf(\"dynamic_allocas\")));\n }\n \n \n@@ -6893,9 +6925,11 @@ fn new_fn_ctxt(@local_ctxt cx, &span sp, ValueRef llfndecl) -> @fn_ctxt {\n              lltaskptr=lltaskptr,\n              llenv=llenv,\n              llretptr=llretptr,\n-             mutable llallocas=llbbs._0,\n+             mutable llstaticallocas=llbbs._0,\n              mutable llcopyargs=llbbs._1,\n+             mutable llderivedtydescs_first=llbbs._2,\n              mutable llderivedtydescs=llbbs._2,\n+             mutable lldynamicallocas=llbbs._3,\n              mutable llself=none[val_self_pair],\n              mutable lliterbody=none[ValueRef],\n              llargs=llargs,\n@@ -6973,7 +7007,7 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx, ast::proto proto,\n // allocas immediately upon entry; this permits us to GEP into structures we\n // were passed and whatnot. Apparently mem2reg will mop up.\n fn copy_any_self_to_alloca(@fn_ctxt fcx, option::t[ty_self_pair] ty_self) {\n-    auto bcx = llallocas_block_ctxt(fcx);\n+    auto bcx = llstaticallocas_block_ctxt(fcx);\n     alt ({ fcx.llself }) {\n         case (some(?pair)) {\n             alt (ty_self) {\n@@ -7045,7 +7079,7 @@ fn ret_ty_of_fn(&@crate_ctxt ccx, ast::ann ann) -> ty::t {\n }\n \n fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, val_self_pair llself) {\n-    auto bcx = llallocas_block_ctxt(fcx);\n+    auto bcx = llstaticallocas_block_ctxt(fcx);\n     let vec[ty::t] field_tys = [];\n     for (ast::obj_field f in bcx.fcx.lcx.obj_fields) {\n         field_tys += [node_ann_type(bcx.fcx.lcx.ccx, f.ann)];\n@@ -7088,20 +7122,22 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, val_self_pair llself) {\n     i = 0;\n     for (ast::obj_field f in fcx.lcx.obj_fields) {\n         auto rslt = GEP_tup_like(bcx, fields_tup_ty, obj_fields, [0, i]);\n-        bcx = llallocas_block_ctxt(fcx);\n+        bcx = llstaticallocas_block_ctxt(fcx);\n         auto llfield = rslt.val;\n         fcx.llobjfields.insert(f.id, llfield);\n         i += 1;\n     }\n-    fcx.llallocas = bcx.llbb;\n+    fcx.llstaticallocas = bcx.llbb;\n }\n \n \n-// Ties up the llallocas -> llcopyargs -> llderivedtydescs -> lltop edges.\n+// Ties up the llstaticallocas -> llcopyargs -> llderivedtydescs ->\n+// lldynamicallocas -> lltop edges.\n fn finish_fn(&@fn_ctxt fcx, BasicBlockRef lltop) {\n-    new_builder(fcx.llallocas).Br(fcx.llcopyargs);\n-    new_builder(fcx.llcopyargs).Br(fcx.llderivedtydescs);\n-    new_builder(fcx.llderivedtydescs).Br(lltop);\n+    new_builder(fcx.llstaticallocas).Br(fcx.llcopyargs);\n+    new_builder(fcx.llcopyargs).Br(fcx.llderivedtydescs_first);\n+    new_builder(fcx.llderivedtydescs).Br(fcx.lldynamicallocas);\n+    new_builder(fcx.lldynamicallocas).Br(lltop);\n }\n \n "}]}