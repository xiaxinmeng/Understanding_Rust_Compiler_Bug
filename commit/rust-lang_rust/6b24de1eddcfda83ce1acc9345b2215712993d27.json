{"sha": "6b24de1eddcfda83ce1acc9345b2215712993d27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMjRkZTFlZGRjZmRhODNjZTFhY2M5MzQ1YjIyMTU3MTI5OTNkMjc=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-10-05T20:33:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-05T20:33:10Z"}, "message": "Rollup merge of #54078 - GabrielMajeri:expand-sync-docs, r=steveklabnik\n\nExpand the documentation for the `std::sync` module\n\nI've tried to expand the documentation for Rust's synchronization primitives. The module level documentation explains why synchronization is required when working with a multiprocessor system,\nand then links to the appropiate structure in this module.\n\nFixes #29377, since this should be the last item on the checklist (documentation for `Atomic*` was fixed in #44854, but not ticked off the checklist).", "tree": {"sha": "61aa38c6010af9363c9432db35ed03fa33a47d3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61aa38c6010af9363c9432db35ed03fa33a47d3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b24de1eddcfda83ce1acc9345b2215712993d27", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbt8qGCRBK7hj4Ov3rIwAAdHIIAFJvJE8UclGHMrOM9laowdBH\nsClcU71zENN2oaZiyZRAKD3zSDcXCGY/ruuwcLBcwEwITC/HJjfErrJ6CZVFbCJE\ndE+8UMorr9ZF20E0f4K7f7VTmNslmmaIjr5ZLOYw21Aq7qORDmgCREUq4Y7fCTEH\n7xCqZcKa3BGs5kx9WbGBmx7LGfHlHN/7KFLeGJy7KB7YSRYm0w1DkDRjsmcziiIt\ngk5bqGGxtvtGwwK1xC6uuyor+qj+mKsv8aNWjJ1yXfJcM+EgHse8Q/ekZncQ+Mkd\nySnnwguiOTMBSmhPMu9amV7P3kBzmHkwOt+B8XKWfyK9pPhbtEItDImqMyrg1Ig=\n=o3Rc\n-----END PGP SIGNATURE-----\n", "payload": "tree 61aa38c6010af9363c9432db35ed03fa33a47d3d\nparent 2155f27b640c14d2f518a4585f7419ab9a334374\nparent 6ba55847129e9a35b477e43b7a381ca00fd2a339\nauthor Pietro Albini <pietro@pietroalbini.org> 1538771590 +0200\ncommitter GitHub <noreply@github.com> 1538771590 +0200\n\nRollup merge of #54078 - GabrielMajeri:expand-sync-docs, r=steveklabnik\n\nExpand the documentation for the `std::sync` module\n\nI've tried to expand the documentation for Rust's synchronization primitives. The module level documentation explains why synchronization is required when working with a multiprocessor system,\nand then links to the appropiate structure in this module.\n\nFixes #29377, since this should be the last item on the checklist (documentation for `Atomic*` was fixed in #44854, but not ticked off the checklist).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b24de1eddcfda83ce1acc9345b2215712993d27", "html_url": "https://github.com/rust-lang/rust/commit/6b24de1eddcfda83ce1acc9345b2215712993d27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b24de1eddcfda83ce1acc9345b2215712993d27/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2155f27b640c14d2f518a4585f7419ab9a334374", "url": "https://api.github.com/repos/rust-lang/rust/commits/2155f27b640c14d2f518a4585f7419ab9a334374", "html_url": "https://github.com/rust-lang/rust/commit/2155f27b640c14d2f518a4585f7419ab9a334374"}, {"sha": "6ba55847129e9a35b477e43b7a381ca00fd2a339", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ba55847129e9a35b477e43b7a381ca00fd2a339", "html_url": "https://github.com/rust-lang/rust/commit/6ba55847129e9a35b477e43b7a381ca00fd2a339"}], "stats": {"total": 152, "additions": 148, "deletions": 4}, "files": [{"sha": "d69ebc17622720200a1db22eb5262621e99946ce", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 148, "deletions": 4, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/6b24de1eddcfda83ce1acc9345b2215712993d27/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b24de1eddcfda83ce1acc9345b2215712993d27/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=6b24de1eddcfda83ce1acc9345b2215712993d27", "patch": "@@ -10,10 +10,154 @@\n \n //! Useful synchronization primitives.\n //!\n-//! This module contains useful safe and unsafe synchronization primitives.\n-//! Most of the primitives in this module do not provide any sort of locking\n-//! and/or blocking at all, but rather provide the necessary tools to build\n-//! other types of concurrent primitives.\n+//! ## The need for synchronization\n+//!\n+//! Conceptually, a Rust program is a series of operations which will\n+//! be executed on a computer. The timeline of events happening in the\n+//! program is consistent with the order of the operations in the code.\n+//!\n+//! Consider the following code, operating on some global static variables:\n+//!\n+//! ```rust\n+//! static mut A: u32 = 0;\n+//! static mut B: u32 = 0;\n+//! static mut C: u32 = 0;\n+//!\n+//! fn main() {\n+//!     unsafe {\n+//!         A = 3;\n+//!         B = 4;\n+//!         A = A + B;\n+//!         C = B;\n+//!         println!(\"{} {} {}\", A, B, C);\n+//!         C = A;\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! It appears as if some variables stored in memory are changed, an addition\n+//! is performed, result is stored in `A` and the variable `C` is\n+//! modified twice.\n+//!\n+//! When only a single thread is involved, the results are as expected:\n+//! the line `7 4 4` gets printed.\n+//!\n+//! As for what happens behind the scenes, when optimizations are enabled the\n+//! final generated machine code might look very different from the code:\n+//!\n+//! - The first store to `C` might be moved before the store to `A` or `B`,\n+//!   _as if_ we had written `C = 4; A = 3; B = 4`.\n+//!\n+//! - Assignment of `A + B` to `A` might be removed, since the sum can be stored\n+//!   in a temporary location until it gets printed, with the global variable\n+//!   never getting updated.\n+//!\n+//! - The final result could be determined just by looking at the code\n+//!   at compile time, so [constant folding] might turn the whole\n+//!   block into a simple `println!(\"7 4 4\")`.\n+//!\n+//! The compiler is allowed to perform any combination of these\n+//! optimizations, as long as the final optimized code, when executed,\n+//! produces the same results as the one without optimizations.\n+//!\n+//! Due to the [concurrency] involved in modern computers, assumptions\n+//! about the program's execution order are often wrong. Access to\n+//! global variables can lead to nondeterministic results, **even if**\n+//! compiler optimizations are disabled, and it is **still possible**\n+//! to introduce synchronization bugs.\n+//!\n+//! Note that thanks to Rust's safety guarantees, accessing global (static)\n+//! variables requires `unsafe` code, assuming we don't use any of the\n+//! synchronization primitives in this module.\n+//!\n+//! [constant folding]: https://en.wikipedia.org/wiki/Constant_folding\n+//! [concurrency]: https://en.wikipedia.org/wiki/Concurrency_(computer_science)\n+//!\n+//! ## Out-of-order execution\n+//!\n+//! Instructions can execute in a different order from the one we define, due to\n+//! various reasons:\n+//!\n+//! - The **compiler** reordering instructions: If the compiler can issue an\n+//!   instruction at an earlier point, it will try to do so. For example, it\n+//!   might hoist memory loads at the top of a code block, so that the CPU can\n+//!   start [prefetching] the values from memory.\n+//!\n+//!   In single-threaded scenarios, this can cause issues when writing\n+//!   signal handlers or certain kinds of low-level code.\n+//!   Use [compiler fences] to prevent this reordering.\n+//!\n+//! - A **single processor** executing instructions [out-of-order]:\n+//!   Modern CPUs are capable of [superscalar] execution,\n+//!   i.e. multiple instructions might be executing at the same time,\n+//!   even though the machine code describes a sequential process.\n+//!\n+//!   This kind of reordering is handled transparently by the CPU.\n+//!\n+//! - A **multiprocessor** system executing multiple hardware threads\n+//!   at the same time: In multi-threaded scenarios, you can use two\n+//!   kinds of primitives to deal with synchronization:\n+//!   - [memory fences] to ensure memory accesses are made visibile to\n+//!   other CPUs in the right order.\n+//!   - [atomic operations] to ensure simultaneous access to the same\n+//!   memory location doesn't lead to undefined behavior.\n+//!\n+//! [prefetching]: https://en.wikipedia.org/wiki/Cache_prefetching\n+//! [compiler fences]: crate::sync::atomic::compiler_fence\n+//! [out-of-order]: https://en.wikipedia.org/wiki/Out-of-order_execution\n+//! [superscalar]: https://en.wikipedia.org/wiki/Superscalar_processor\n+//! [memory fences]: crate::sync::atomic::fence\n+//! [atomic operations]: crate::sync::atomic\n+//!\n+//! ## Higher-level synchronization objects\n+//!\n+//! Most of the low-level synchronization primitives are quite error-prone and\n+//! inconvenient to use, which is why the standard library also exposes some\n+//! higher-level synchronization objects.\n+//!\n+//! These abstractions can be built out of lower-level primitives.\n+//! For efficiency, the sync objects in the standard library are usually\n+//! implemented with help from the operating system's kernel, which is\n+//! able to reschedule the threads while they are blocked on acquiring\n+//! a lock.\n+//!\n+//! The following is an overview of the available synchronization\n+//! objects:\n+//!\n+//! - [`Arc`]: Atomically Reference-Counted pointer, which can be used\n+//!   in multithreaded environments to prolong the lifetime of some\n+//!   data until all the threads have finished using it.\n+//!\n+//! - [`Barrier`]: Ensures multiple threads will wait for each other\n+//!   to reach a point in the program, before continuing execution all\n+//!   together.\n+//!\n+//! - [`Condvar`]: Condition Variable, providing the ability to block\n+//!   a thread while waiting for an event to occur.\n+//!\n+//! - [`mpsc`]: Multi-producer, single-consumer queues, used for\n+//!   message-based communication. Can provide a lightweight\n+//!   inter-thread synchronisation mechanism, at the cost of some\n+//!   extra memory.\n+//!\n+//! - [`Mutex`]: Mutual Exclusion mechanism, which ensures that at\n+//!   most one thread at a time is able to access some data.\n+//!\n+//! - [`Once`]: Used for thread-safe, one-time initialization of a\n+//!   global variable.\n+//!\n+//! - [`RwLock`]: Provides a mutual exclusion mechanism which allows\n+//!   multiple readers at the same time, while allowing only one\n+//!   writer at a time. In some cases, this can be more efficient than\n+//!   a mutex.\n+//!\n+//! [`Arc`]: crate::sync::Arc\n+//! [`Barrier`]: crate::sync::Barrier\n+//! [`Condvar`]: crate::sync::Condvar\n+//! [`mpsc`]: crate::sync::mpsc\n+//! [`Mutex`]: crate::sync::Mutex\n+//! [`Once`]: crate::sync::Once\n+//! [`RwLock`]: crate::sync::RwLock\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}