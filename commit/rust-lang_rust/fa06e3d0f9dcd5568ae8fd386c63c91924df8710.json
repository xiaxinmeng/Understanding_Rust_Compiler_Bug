{"sha": "fa06e3d0f9dcd5568ae8fd386c63c91924df8710", "node_id": "C_kwDOAAsO6NoAKGZhMDZlM2QwZjlkY2Q1NTY4YWU4ZmQzODZjNjNjOTE5MjRkZjg3MTA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-06T12:00:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-06T12:00:35Z"}, "message": "Merge #11911\n\n11911: fix: Fix SearchScope using incorrect text ranges for macro-emitted inline modules r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "299e0442fa30dd41649e2a2f71567d8f315c5d65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/299e0442fa30dd41649e2a2f71567d8f315c5d65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa06e3d0f9dcd5568ae8fd386c63c91924df8710", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiTYDjCRBK7hj4Ov3rIwAAQlYIAIjzP/hwCWLuSy5LED/822Uj\nHUOHg83vpTHcX8YryPumJRteDguRE1D0QCKgz8Hgie92i4rN6QqSZW6nlLFZ6Ft7\niGAjFar6Tqe5+ZTvsMe3hpyylN/ang9VFPDOq38CeqDkGcJ4mYVGL+HRoQ+dCU1z\nnx5dfgvHtUdwFWiGgjtGHsd2Vbg7+fRx25Z+yfqpBfpw1rykbQ4syA3HYiQI7btU\nopE621Qt0W/PsXO3gb7N8Eznomb0evBtVR2ivBCvdOoNgvwQIDtDe3wngopYpOaL\nU7krUMUx3D9xOWi97YN3rG+bF7VXl+YwjGj4+wi95gjK48dMWYB1upJv1dShcQ0=\n=8JhB\n-----END PGP SIGNATURE-----\n", "payload": "tree 299e0442fa30dd41649e2a2f71567d8f315c5d65\nparent 2366d8e05f5f3585f95058fa7427cbde079914ed\nparent d9f6cee100fde49d3a76b3fac84b9b13cedf1898\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1649246435 +0000\ncommitter GitHub <noreply@github.com> 1649246435 +0000\n\nMerge #11911\n\n11911: fix: Fix SearchScope using incorrect text ranges for macro-emitted inline modules r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa06e3d0f9dcd5568ae8fd386c63c91924df8710", "html_url": "https://github.com/rust-lang/rust/commit/fa06e3d0f9dcd5568ae8fd386c63c91924df8710", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa06e3d0f9dcd5568ae8fd386c63c91924df8710/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2366d8e05f5f3585f95058fa7427cbde079914ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/2366d8e05f5f3585f95058fa7427cbde079914ed", "html_url": "https://github.com/rust-lang/rust/commit/2366d8e05f5f3585f95058fa7427cbde079914ed"}, {"sha": "d9f6cee100fde49d3a76b3fac84b9b13cedf1898", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9f6cee100fde49d3a76b3fac84b9b13cedf1898", "html_url": "https://github.com/rust-lang/rust/commit/d9f6cee100fde49d3a76b3fac84b9b13cedf1898"}], "stats": {"total": 148, "additions": 89, "deletions": 59}, "files": [{"sha": "e698726638a18e127a628816a9e9b2014aaec20d", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fa06e3d0f9dcd5568ae8fd386c63c91924df8710/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa06e3d0f9dcd5568ae8fd386c63c91924df8710/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=fa06e3d0f9dcd5568ae8fd386c63c91924df8710", "patch": "@@ -175,15 +175,17 @@ impl HirFileId {\n     /// For macro-expansion files, returns the file original source file the\n     /// expansion originated from.\n     pub fn original_file(self, db: &dyn db::AstDatabase) -> FileId {\n-        match self.0 {\n-            HirFileIdRepr::FileId(file_id) => file_id,\n-            HirFileIdRepr::MacroFile(macro_file) => {\n-                let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-                let file_id = match loc.eager {\n-                    Some(EagerCallInfo { included_file: Some(file), .. }) => file.into(),\n-                    _ => loc.kind.file_id(),\n-                };\n-                file_id.original_file(db)\n+        let mut file_id = self;\n+        loop {\n+            match file_id.0 {\n+                HirFileIdRepr::FileId(id) => break id,\n+                HirFileIdRepr::MacroFile(MacroFile { macro_call_id }) => {\n+                    let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_call_id);\n+                    file_id = match loc.eager {\n+                        Some(EagerCallInfo { included_file: Some(file), .. }) => file.into(),\n+                        _ => loc.kind.file_id(),\n+                    };\n+                }\n             }\n         }\n     }\n@@ -211,6 +213,24 @@ impl HirFileId {\n         }\n     }\n \n+    /// If this is a macro call, returns the syntax node of the very first macro call this file resides in.\n+    pub fn original_call_node(self, db: &dyn db::AstDatabase) -> Option<(FileId, SyntaxNode)> {\n+        let mut call = match self.0 {\n+            HirFileIdRepr::FileId(_) => return None,\n+            HirFileIdRepr::MacroFile(MacroFile { macro_call_id }) => {\n+                db.lookup_intern_macro_call(macro_call_id).kind.to_node(db)\n+            }\n+        };\n+        loop {\n+            match call.file_id.0 {\n+                HirFileIdRepr::FileId(file_id) => break Some((file_id, call.value)),\n+                HirFileIdRepr::MacroFile(MacroFile { macro_call_id }) => {\n+                    call = db.lookup_intern_macro_call(macro_call_id).kind.to_node(db);\n+                }\n+            }\n+        }\n+    }\n+\n     /// Return expansion information if it is a macro-expansion file\n     pub fn expansion_info(self, db: &dyn db::AstDatabase) -> Option<ExpansionInfo> {\n         match self.0 {\n@@ -675,9 +695,11 @@ impl<T> InFile<T> {\n     pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> InFile<U> {\n         InFile::new(self.file_id, f(self.value))\n     }\n+\n     pub fn as_ref(&self) -> InFile<&T> {\n         self.with_value(&self.value)\n     }\n+\n     pub fn file_syntax(&self, db: &dyn db::AstDatabase) -> SyntaxNode {\n         db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n     }"}, {"sha": "4a11fb73cd6d987aab3e1a84e4ea29873ac4b6d2", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 58, "deletions": 50, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/fa06e3d0f9dcd5568ae8fd386c63c91924df8710/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa06e3d0f9dcd5568ae8fd386c63c91924df8710/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=fa06e3d0f9dcd5568ae8fd386c63c91924df8710", "patch": "@@ -85,6 +85,7 @@ impl SearchScope {\n         SearchScope { entries }\n     }\n \n+    /// Build a search scope spanning the entire crate graph of files.\n     fn crate_graph(db: &RootDatabase) -> SearchScope {\n         let mut entries = FxHashMap::default();\n \n@@ -98,6 +99,7 @@ impl SearchScope {\n         SearchScope { entries }\n     }\n \n+    /// Build a search scope spanning all the reverse dependencies of the given crate.\n     fn reverse_dependencies(db: &RootDatabase, of: hir::Crate) -> SearchScope {\n         let mut entries = FxHashMap::default();\n         for rev_dep in of.transitive_reverse_dependencies(db) {\n@@ -109,6 +111,7 @@ impl SearchScope {\n         SearchScope { entries }\n     }\n \n+    /// Build a search scope spanning the given crate.\n     fn krate(db: &RootDatabase, of: hir::Crate) -> SearchScope {\n         let root_file = of.root_file(db);\n         let source_root_id = db.file_source_root(root_file);\n@@ -118,55 +121,55 @@ impl SearchScope {\n         }\n     }\n \n-    fn module(db: &RootDatabase, module: hir::Module) -> SearchScope {\n+    /// Build a search scope spanning the given module and all its submodules.\n+    fn module_and_children(db: &RootDatabase, module: hir::Module) -> SearchScope {\n         let mut entries = FxHashMap::default();\n \n-        let mut to_visit = vec![module];\n-        let mut is_first = true;\n+        let (file_id, range) = {\n+            let InFile { file_id, value } = module.definition_source(db);\n+            if let Some((file_id, call_source)) = file_id.original_call_node(db) {\n+                (file_id, Some(call_source.text_range()))\n+            } else {\n+                (\n+                    file_id.original_file(db),\n+                    match value {\n+                        ModuleSource::SourceFile(_) => None,\n+                        ModuleSource::Module(it) => Some(it.syntax().text_range()),\n+                        ModuleSource::BlockExpr(it) => Some(it.syntax().text_range()),\n+                    },\n+                )\n+            }\n+        };\n+        entries.insert(file_id, range);\n+\n+        let mut to_visit: Vec<_> = module.children(db).collect();\n         while let Some(module) = to_visit.pop() {\n-            let src = module.definition_source(db);\n-            let file_id = src.file_id.original_file(db);\n-            match src.value {\n-                ModuleSource::Module(m) => {\n-                    if is_first {\n-                        let range = Some(m.syntax().text_range());\n-                        entries.insert(file_id, range);\n-                    } else {\n-                        // We have already added the enclosing file to the search scope,\n-                        // so do nothing.\n-                    }\n-                }\n-                ModuleSource::BlockExpr(b) => {\n-                    if is_first {\n-                        let range = Some(b.syntax().text_range());\n-                        entries.insert(file_id, range);\n-                    } else {\n-                        // We have already added the enclosing file to the search scope,\n-                        // so do nothing.\n-                    }\n-                }\n-                ModuleSource::SourceFile(_) => {\n-                    entries.insert(file_id, None);\n-                }\n-            };\n-            is_first = false;\n+            if let InFile { file_id, value: ModuleSource::SourceFile(_) } =\n+                module.definition_source(db)\n+            {\n+                entries.insert(file_id.original_file(db), None);\n+            }\n             to_visit.extend(module.children(db));\n         }\n         SearchScope { entries }\n     }\n \n+    /// Build an empty search scope.\n     pub fn empty() -> SearchScope {\n         SearchScope::new(FxHashMap::default())\n     }\n \n+    /// Build a empty search scope spanning the given file.\n     pub fn single_file(file: FileId) -> SearchScope {\n         SearchScope::new(std::iter::once((file, None)).collect())\n     }\n \n+    /// Build a empty search scope spanning the text range of the given file.\n     pub fn file_range(range: FileRange) -> SearchScope {\n         SearchScope::new(std::iter::once((range.file_id, Some(range.range))).collect())\n     }\n \n+    /// Build a empty search scope spanning the given files.\n     pub fn files(files: &[FileId]) -> SearchScope {\n         SearchScope::new(files.iter().map(|f| (*f, None)).collect())\n     }\n@@ -177,29 +180,23 @@ impl SearchScope {\n             mem::swap(&mut small, &mut large)\n         }\n \n+        let intersect_ranges =\n+            |r1: Option<TextRange>, r2: Option<TextRange>| -> Option<Option<TextRange>> {\n+                match (r1, r2) {\n+                    (None, r) | (r, None) => Some(r),\n+                    (Some(r1), Some(r2)) => r1.intersect(r2).map(Some),\n+                }\n+            };\n         let res = small\n             .iter()\n-            .filter_map(|(file_id, r1)| {\n-                let r2 = large.get(file_id)?;\n-                let r = intersect_ranges(*r1, *r2)?;\n-                Some((*file_id, r))\n+            .filter_map(|(&file_id, &r1)| {\n+                let &r2 = large.get(&file_id)?;\n+                let r = intersect_ranges(r1, r2)?;\n+                Some((file_id, r))\n             })\n             .collect();\n \n-        return SearchScope::new(res);\n-\n-        fn intersect_ranges(\n-            r1: Option<TextRange>,\n-            r2: Option<TextRange>,\n-        ) -> Option<Option<TextRange>> {\n-            match (r1, r2) {\n-                (None, r) | (r, None) => Some(r),\n-                (Some(r1), Some(r2)) => {\n-                    let r = r1.intersect(r2)?;\n-                    Some(Some(r))\n-                }\n-            }\n-        }\n+        SearchScope::new(res)\n     }\n }\n \n@@ -282,7 +279,8 @@ impl Definition {\n                 hir::MacroKind::BuiltIn => SearchScope::crate_graph(db),\n                 // FIXME: We don't actually see derives in derive attributes as these do not\n                 // expand to something that references the derive macro in the output.\n-                // We could get around this by emitting dummy `use DeriveMacroPathHere as _;` items maybe?\n+                // We could get around this by doing pseudo expansions for proc_macro_derive like we\n+                // do for the derive attribute\n                 hir::MacroKind::Derive | hir::MacroKind::Attr | hir::MacroKind::ProcMacro => {\n                     SearchScope::reverse_dependencies(db, module.krate())\n                 }\n@@ -294,7 +292,7 @@ impl Definition {\n             return SearchScope::reverse_dependencies(db, module.krate());\n         }\n         if let Some(Visibility::Module(module)) = vis {\n-            return SearchScope::module(db, module.into());\n+            return SearchScope::module_and_children(db, module.into());\n         }\n \n         let range = match module_source {\n@@ -341,10 +339,12 @@ impl<'a> FindUsages<'a> {\n         self\n     }\n \n+    /// Limit the search to a given [`SearchScope`].\n     pub fn in_scope(self, scope: SearchScope) -> FindUsages<'a> {\n         self.set_scope(Some(scope))\n     }\n \n+    /// Limit the search to a given [`SearchScope`].\n     pub fn set_scope(mut self, scope: Option<SearchScope>) -> FindUsages<'a> {\n         assert!(self.scope.is_none());\n         self.scope = scope;\n@@ -420,6 +420,7 @@ impl<'a> FindUsages<'a> {\n                 Some(offset)\n             })\n         }\n+\n         fn scope_files<'a>(\n             sema: &'a Semantics<RootDatabase>,\n             scope: &'a SearchScope,\n@@ -433,6 +434,12 @@ impl<'a> FindUsages<'a> {\n             })\n         }\n \n+        // FIXME: There should be optimization potential here\n+        // Currently we try to descend everything we find which\n+        // means we call `Semantics::descend_into_macros` on\n+        // every textual hit. That function is notoriously\n+        // expensive even for things that do not get down mapped\n+        // into macros.\n         for (text, file_id, search_range) in scope_files(sema, &search_scope) {\n             let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n@@ -463,7 +470,8 @@ impl<'a> FindUsages<'a> {\n         // Search for `super` and `crate` resolving to our module\n         match self.def {\n             Definition::Module(module) => {\n-                let scope = search_scope.intersection(&SearchScope::module(self.sema.db, module));\n+                let scope = search_scope\n+                    .intersection(&SearchScope::module_and_children(self.sema.db, module));\n \n                 let is_crate_root = module.is_crate_root(self.sema.db);\n "}]}