{"sha": "c80dde43f992f3eb419899a34551b84c6301f8e8", "node_id": "C_kwDOAAsO6NoAKGM4MGRkZTQzZjk5MmYzZWI0MTk4OTlhMzQ1NTFiODRjNjMwMWY4ZTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-13T17:13:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-13T17:13:27Z"}, "message": "Auto merge of #99210 - Dylan-DPC:rollup-879cp1t, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #98574 (Lower let-else in MIR)\n - #99011 (`UnsafeCell` blocks niches inside its nested type from being available outside)\n - #99030 (diagnostics: error messages when struct literals fail to parse)\n - #99155 (Keep unstable target features for asm feature checking)\n - #99199 (Refactor: remove an unnecessary `span_to_snippet`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8cdaab3defdcc525a68f7dba82c23e62be66fa9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cdaab3defdcc525a68f7dba82c23e62be66fa9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c80dde43f992f3eb419899a34551b84c6301f8e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c80dde43f992f3eb419899a34551b84c6301f8e8", "html_url": "https://github.com/rust-lang/rust/commit/c80dde43f992f3eb419899a34551b84c6301f8e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c80dde43f992f3eb419899a34551b84c6301f8e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42bd138126b0a9d38d65bc9973e72de3c5b6c37f", "url": "https://api.github.com/repos/rust-lang/rust/commits/42bd138126b0a9d38d65bc9973e72de3c5b6c37f", "html_url": "https://github.com/rust-lang/rust/commit/42bd138126b0a9d38d65bc9973e72de3c5b6c37f"}, {"sha": "3933b2b310e9358b77269e69b0656d12a126e14a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3933b2b310e9358b77269e69b0656d12a126e14a", "html_url": "https://github.com/rust-lang/rust/commit/3933b2b310e9358b77269e69b0656d12a126e14a"}], "stats": {"total": 1660, "additions": 830, "deletions": 830}, "files": [{"sha": "7cbfe143b4d83d3701a7b30e5571f8e4d4322c1c", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 22, "deletions": 73, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1,8 +1,8 @@\n use crate::{ImplTraitContext, ImplTraitPosition, LoweringContext};\n-use rustc_ast::{AttrVec, Block, BlockCheckMode, Expr, Local, LocalKind, Stmt, StmtKind};\n+use rustc_ast::{Block, BlockCheckMode, Local, LocalKind, Stmt, StmtKind};\n use rustc_hir as hir;\n use rustc_session::parse::feature_err;\n-use rustc_span::{sym, DesugaringKind};\n+use rustc_span::sym;\n \n use smallvec::SmallVec;\n \n@@ -36,21 +36,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             match s.kind {\n                 StmtKind::Local(ref local) => {\n                     let hir_id = self.lower_node_id(s.id);\n-                    match &local.kind {\n-                        LocalKind::InitElse(init, els) => {\n-                            let e = self.lower_let_else(hir_id, local, init, els, tail);\n-                            expr = Some(e);\n-                            // remaining statements are in let-else expression\n-                            break;\n-                        }\n-                        _ => {\n-                            let local = self.lower_local(local);\n-                            self.alias_attrs(hir_id, local.hir_id);\n-                            let kind = hir::StmtKind::Local(local);\n-                            let span = self.lower_span(s.span);\n-                            stmts.push(hir::Stmt { hir_id, kind, span });\n-                        }\n-                    }\n+                    let local = self.lower_local(local);\n+                    self.alias_attrs(hir_id, local.hir_id);\n+                    let kind = hir::StmtKind::Local(local);\n+                    let span = self.lower_span(s.span);\n+                    stmts.push(hir::Stmt { hir_id, kind, span });\n                 }\n                 StmtKind::Item(ref it) => {\n                     stmts.extend(self.lower_item_ref(it).into_iter().enumerate().map(\n@@ -101,10 +91,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let init = l.kind.init().map(|init| self.lower_expr(init));\n         let hir_id = self.lower_node_id(l.id);\n         let pat = self.lower_pat(&l.pat);\n+        let els = if let LocalKind::InitElse(_, els) = &l.kind {\n+            if !self.tcx.features().let_else {\n+                feature_err(\n+                    &self.tcx.sess.parse_sess,\n+                    sym::let_else,\n+                    l.span,\n+                    \"`let...else` statements are unstable\",\n+                )\n+                .emit();\n+            }\n+            Some(self.lower_block(els, false))\n+        } else {\n+            None\n+        };\n         let span = self.lower_span(l.span);\n         let source = hir::LocalSource::Normal;\n         self.lower_attrs(hir_id, &l.attrs);\n-        self.arena.alloc(hir::Local { hir_id, ty, pat, init, span, source })\n+        self.arena.alloc(hir::Local { hir_id, ty, pat, init, els, span, source })\n     }\n \n     fn lower_block_check_mode(&mut self, b: &BlockCheckMode) -> hir::BlockCheckMode {\n@@ -115,59 +119,4 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n     }\n-\n-    fn lower_let_else(\n-        &mut self,\n-        stmt_hir_id: hir::HirId,\n-        local: &Local,\n-        init: &Expr,\n-        els: &Block,\n-        tail: &[Stmt],\n-    ) -> &'hir hir::Expr<'hir> {\n-        let ty = local\n-            .ty\n-            .as_ref()\n-            .map(|t| self.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Variable)));\n-        let span = self.lower_span(local.span);\n-        let span = self.mark_span_with_reason(DesugaringKind::LetElse, span, None);\n-        let init = self.lower_expr(init);\n-        let local_hir_id = self.lower_node_id(local.id);\n-        self.lower_attrs(local_hir_id, &local.attrs);\n-        let let_expr = {\n-            let lex = self.arena.alloc(hir::Let {\n-                hir_id: local_hir_id,\n-                pat: self.lower_pat(&local.pat),\n-                ty,\n-                init,\n-                span,\n-            });\n-            self.arena.alloc(self.expr(span, hir::ExprKind::Let(lex), AttrVec::new()))\n-        };\n-        let then_expr = {\n-            let (stmts, expr) = self.lower_stmts(tail);\n-            let block = self.block_all(span, stmts, expr);\n-            self.arena.alloc(self.expr_block(block, AttrVec::new()))\n-        };\n-        let else_expr = {\n-            let block = self.lower_block(els, false);\n-            self.arena.alloc(self.expr_block(block, AttrVec::new()))\n-        };\n-        self.alias_attrs(let_expr.hir_id, local_hir_id);\n-        self.alias_attrs(else_expr.hir_id, local_hir_id);\n-        let if_expr = self.arena.alloc(hir::Expr {\n-            hir_id: stmt_hir_id,\n-            span,\n-            kind: hir::ExprKind::If(let_expr, then_expr, Some(else_expr)),\n-        });\n-        if !self.tcx.features().let_else {\n-            feature_err(\n-                &self.tcx.sess.parse_sess,\n-                sym::let_else,\n-                local.span,\n-                \"`let...else` statements are unstable\",\n-            )\n-            .emit();\n-        }\n-        if_expr\n-    }\n }"}, {"sha": "4da3096f7c3aa9fecea17274ea678f2b1d84597f", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -2146,7 +2146,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             debug_assert!(!a.is_empty());\n             self.attrs.insert(hir_id.local_id, a);\n         }\n-        let local = hir::Local { hir_id, init, pat, source, span: self.lower_span(span), ty: None };\n+        let local = hir::Local {\n+            hir_id,\n+            init,\n+            pat,\n+            els: None,\n+            source,\n+            span: self.lower_span(span),\n+            ty: None,\n+        };\n         self.stmt(span, hir::StmtKind::Local(self.arena.alloc(local)))\n     }\n "}, {"sha": "6673d75d99df070de5b6a5bb6b3727b6c786bfd1", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -856,7 +856,6 @@ pub enum ReprAttr {\n     ReprSimd,\n     ReprTransparent,\n     ReprAlign(u32),\n-    ReprNoNiche,\n }\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n@@ -904,7 +903,6 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                     sym::packed => Some(ReprPacked(1)),\n                     sym::simd => Some(ReprSimd),\n                     sym::transparent => Some(ReprTransparent),\n-                    sym::no_niche => Some(ReprNoNiche),\n                     sym::align => {\n                         let mut err = struct_span_err!(\n                             diagnostic,\n@@ -943,7 +941,7 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                         Ok(literal) => acc.push(ReprPacked(literal)),\n                         Err(message) => literal_error = Some(message),\n                     };\n-                } else if matches!(name, sym::C | sym::simd | sym::transparent | sym::no_niche)\n+                } else if matches!(name, sym::C | sym::simd | sym::transparent)\n                     || int_type_of_word(name).is_some()\n                 {\n                     recognised = true;\n@@ -1001,7 +999,7 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                     } else {\n                         if matches!(\n                             meta_item.name_or_empty(),\n-                            sym::C | sym::simd | sym::transparent | sym::no_niche\n+                            sym::C | sym::simd | sym::transparent\n                         ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n                         {\n                             recognised = true;\n@@ -1039,7 +1037,7 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                         .emit();\n                     } else if matches!(\n                         meta_item.name_or_empty(),\n-                        sym::C | sym::simd | sym::transparent | sym::no_niche\n+                        sym::C | sym::simd | sym::transparent\n                     ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n                     {\n                         recognised = true;"}, {"sha": "0ceb63477c80961df33fab6236fecf9361afdbbe", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1598,21 +1598,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let return_ty = tcx.erase_regions(return_ty);\n \n             // to avoid panics\n-            if let Some(iter_trait) = tcx.get_diagnostic_item(sym::Iterator) {\n-                if self\n+            if let Some(iter_trait) = tcx.get_diagnostic_item(sym::Iterator)\n+                && self\n                     .infcx\n                     .type_implements_trait(iter_trait, return_ty, ty_params, self.param_env)\n                     .must_apply_modulo_regions()\n-                {\n-                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(return_span) {\n-                        err.span_suggestion_hidden(\n-                            return_span,\n-                            \"use `.collect()` to allocate the iterator\",\n-                            format!(\"{snippet}.collect::<Vec<_>>()\"),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n+            {\n+                err.span_suggestion_hidden(\n+                    return_span.shrink_to_hi(),\n+                    \"use `.collect()` to allocate the iterator\",\n+                    \".collect::<Vec<_>>()\",\n+                    Applicability::MaybeIncorrect,\n+                );\n             }\n         }\n "}, {"sha": "3ed3453c6c7b32f3b6e15310d04ad64e17b54d86", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -167,7 +167,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         }\n     }\n \n-    fn target_features(&self, _sess: &Session) -> Vec<rustc_span::Symbol> {\n+    fn target_features(&self, _sess: &Session, _allow_unstable: bool) -> Vec<rustc_span::Symbol> {\n         vec![]\n     }\n "}, {"sha": "c21e0c5a35b801438f954a30c71f6b0140de0cf0", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -140,8 +140,8 @@ impl CodegenBackend for GccCodegenBackend {\n         )\n     }\n \n-    fn target_features(&self, sess: &Session) -> Vec<Symbol> {\n-        target_features(sess)\n+    fn target_features(&self, sess: &Session, allow_unstable: bool) -> Vec<Symbol> {\n+        target_features(sess, allow_unstable)\n     }\n }\n \n@@ -298,12 +298,12 @@ pub fn target_cpu(sess: &Session) -> &str {\n     }\n }\n \n-pub fn target_features(sess: &Session) -> Vec<Symbol> {\n+pub fn target_features(sess: &Session, allow_unstable: bool) -> Vec<Symbol> {\n     supported_target_features(sess)\n         .iter()\n         .filter_map(\n             |&(feature, gate)| {\n-                if sess.is_nightly_build() || gate.is_none() { Some(feature) } else { None }\n+                if sess.is_nightly_build() || allow_unstable || gate.is_none() { Some(feature) } else { None }\n             },\n         )\n         .filter(|_feature| {"}, {"sha": "fb196ee9f5d0635592ecc1d2a0e8ba739db09839", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -324,8 +324,8 @@ impl CodegenBackend for LlvmCodegenBackend {\n         llvm_util::print_version();\n     }\n \n-    fn target_features(&self, sess: &Session) -> Vec<Symbol> {\n-        target_features(sess)\n+    fn target_features(&self, sess: &Session, allow_unstable: bool) -> Vec<Symbol> {\n+        target_features(sess, allow_unstable)\n     }\n \n     fn codegen_crate<'tcx>("}, {"sha": "5b3b7db12b7ced85539c16cb132e32661cfc5bd8", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -233,26 +233,29 @@ pub fn check_tied_features(\n \n // Used to generate cfg variables and apply features\n // Must express features in the way Rust understands them\n-pub fn target_features(sess: &Session) -> Vec<Symbol> {\n+pub fn target_features(sess: &Session, allow_unstable: bool) -> Vec<Symbol> {\n     let target_machine = create_informational_target_machine(sess);\n-    let mut features: Vec<Symbol> =\n-        supported_target_features(sess)\n-            .iter()\n-            .filter_map(|&(feature, gate)| {\n-                if sess.is_nightly_build() || gate.is_none() { Some(feature) } else { None }\n-            })\n-            .filter(|feature| {\n-                // check that all features in a given smallvec are enabled\n-                for llvm_feature in to_llvm_features(sess, feature) {\n-                    let cstr = SmallCStr::new(llvm_feature);\n-                    if !unsafe { llvm::LLVMRustHasFeature(target_machine, cstr.as_ptr()) } {\n-                        return false;\n-                    }\n+    let mut features: Vec<Symbol> = supported_target_features(sess)\n+        .iter()\n+        .filter_map(|&(feature, gate)| {\n+            if sess.is_nightly_build() || allow_unstable || gate.is_none() {\n+                Some(feature)\n+            } else {\n+                None\n+            }\n+        })\n+        .filter(|feature| {\n+            // check that all features in a given smallvec are enabled\n+            for llvm_feature in to_llvm_features(sess, feature) {\n+                let cstr = SmallCStr::new(llvm_feature);\n+                if !unsafe { llvm::LLVMRustHasFeature(target_machine, cstr.as_ptr()) } {\n+                    return false;\n                 }\n-                true\n-            })\n-            .map(|feature| Symbol::intern(feature))\n-            .collect();\n+            }\n+            true\n+        })\n+        .map(|feature| Symbol::intern(feature))\n+        .collect();\n \n     // LLVM 14 changed the ABI for i128 arguments to __float/__fix builtins on Win64\n     // (see https://reviews.llvm.org/D110413). This unstable target feature is intended for use"}, {"sha": "779bd3ea278ec25f36bfb979e2b754a861e8d4cc", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -59,7 +59,7 @@ impl<'tcx, T> Backend<'tcx> for T where\n pub trait CodegenBackend {\n     fn init(&self, _sess: &Session) {}\n     fn print(&self, _req: PrintRequest, _sess: &Session) {}\n-    fn target_features(&self, _sess: &Session) -> Vec<Symbol> {\n+    fn target_features(&self, _sess: &Session, _allow_unstable: bool) -> Vec<Symbol> {\n         vec![]\n     }\n     fn print_passes(&self) {}"}, {"sha": "7616e7a63d1079aa2cbc1fb592b2152be28a04ce", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -217,7 +217,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n         }\n \n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n-            if Some(def.did()) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n+            if def.is_unsafe_cell() {\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable\n                 // allocations."}, {"sha": "53bc2cc8a6980e14d1cbc516d477bb4f5a4727c4", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -821,7 +821,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // Special check preventing `UnsafeCell` in the inner part of constants\n         if let Some(def) = op.layout.ty.ty_adt_def() {\n             if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true, .. }))\n-                && Some(def.did()) == self.ecx.tcx.lang_items().unsafe_cell_type()\n+                && def.is_unsafe_cell()\n             {\n                 throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n             }"}, {"sha": "29464cf8c4e4fa1856269a66e30828b8c5d5076f", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -96,13 +96,13 @@ impl Qualif for HasMutInterior {\n     }\n \n     fn in_adt_inherently<'tcx>(\n-        cx: &ConstCx<'_, 'tcx>,\n+        _cx: &ConstCx<'_, 'tcx>,\n         adt: AdtDef<'tcx>,\n         _: SubstsRef<'tcx>,\n     ) -> bool {\n         // Exactly one type, `UnsafeCell`, has the `HasMutInterior` qualif inherently.\n         // It arises structurally for all other types.\n-        Some(adt.did()) == cx.tcx.lang_items().unsafe_cell_type()\n+        adt.is_unsafe_cell()\n     }\n }\n "}, {"sha": "117bdad971a208fef20b4b29830273877f262319", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -156,9 +156,6 @@ declare_features! (\n     (active, intrinsics, \"1.0.0\", None, None),\n     /// Allows using `#[lang = \"..\"]` attribute for linking items to special compiler logic.\n     (active, lang_items, \"1.0.0\", None, None),\n-    /// Allows `#[repr(no_niche)]` (an implementation detail of `rustc`,\n-    /// it is not on path for eventual stabilization).\n-    (active, no_niche, \"1.42.0\", None, None),\n     /// Allows using `#[omit_gdb_pretty_printer_section]`.\n     (active, omit_gdb_pretty_printer_section, \"1.5.0\", None, None),\n     /// Allows using `#[prelude_import]` on glob `use` items."}, {"sha": "ed874ae829b46df43c0632aa20e3f786dcd23583", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1316,6 +1316,8 @@ pub struct Local<'hir> {\n     pub ty: Option<&'hir Ty<'hir>>,\n     /// Initializer expression to set the value, if any.\n     pub init: Option<&'hir Expr<'hir>>,\n+    /// Else block for a `let...else` binding.\n+    pub els: Option<&'hir Block<'hir>>,\n     pub hir_id: HirId,\n     pub span: Span,\n     /// Can be `ForLoopDesugar` if the `let` statement is part of a `for` loop"}, {"sha": "b5d9769c578a5cb520dd19d1650f9474012ce70f", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -472,6 +472,9 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n     walk_list!(visitor, visit_expr, &local.init);\n     visitor.visit_id(local.hir_id);\n     visitor.visit_pat(&local.pat);\n+    if let Some(els) = local.els {\n+        visitor.visit_block(els);\n+    }\n     walk_list!(visitor, visit_ty, &local.ty);\n }\n "}, {"sha": "e3c97ec357e876808e221f01d6d6992bedc8936f", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -883,7 +883,12 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::SubItem(ii.hir_id()))\n     }\n \n-    pub fn print_local(&mut self, init: Option<&hir::Expr<'_>>, decl: impl Fn(&mut Self)) {\n+    pub fn print_local(\n+        &mut self,\n+        init: Option<&hir::Expr<'_>>,\n+        els: Option<&hir::Block<'_>>,\n+        decl: impl Fn(&mut Self),\n+    ) {\n         self.space_if_not_bol();\n         self.ibox(INDENT_UNIT);\n         self.word_nbsp(\"let\");\n@@ -897,14 +902,21 @@ impl<'a> State<'a> {\n             self.word_space(\"=\");\n             self.print_expr(init);\n         }\n+\n+        if let Some(els) = els {\n+            self.nbsp();\n+            self.word_space(\"else\");\n+            self.print_block(els);\n+        }\n+\n         self.end()\n     }\n \n     pub fn print_stmt(&mut self, st: &hir::Stmt<'_>) {\n         self.maybe_print_comment(st.span.lo());\n         match st.kind {\n             hir::StmtKind::Local(loc) => {\n-                self.print_local(loc.init, |this| this.print_local_decl(loc));\n+                self.print_local(loc.init, loc.els, |this| this.print_local_decl(loc));\n             }\n             hir::StmtKind::Item(item) => self.ann.nested(self, Nested::Item(item)),\n             hir::StmtKind::Expr(expr) => {\n@@ -1404,7 +1416,7 @@ impl<'a> State<'a> {\n \n                 // Print `let _t = $init;`:\n                 let temp = Ident::from_str(\"_t\");\n-                self.print_local(Some(init), |this| this.print_ident(temp));\n+                self.print_local(Some(init), None, |this| this.print_ident(temp));\n                 self.word(\";\");\n \n                 // Print `_t`:"}, {"sha": "f4b51b5a44243ae8f87e6e5c6881d6a697cc0d9f", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -48,7 +48,10 @@ pub fn add_configuration(\n ) {\n     let tf = sym::target_feature;\n \n-    let target_features = codegen_backend.target_features(sess);\n+    let unstable_target_features = codegen_backend.target_features(sess, true);\n+    sess.unstable_target_features.extend(unstable_target_features.iter().cloned());\n+\n+    let target_features = codegen_backend.target_features(sess, false);\n     sess.target_features.extend(target_features.iter().cloned());\n \n     cfg.extend(target_features.into_iter().map(|feat| (tf, Some(feat))));"}, {"sha": "aca481df2e113ccbdd33e1fc0d8cab85ee01342c", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -703,9 +703,8 @@ fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKi\n                 return true;\n             }\n \n-            // Types with a `#[repr(no_niche)]` attribute have their niche hidden.\n-            // The attribute is used by the UnsafeCell for example (the only use so far).\n-            if def.repr().hide_niche() {\n+            // `UnsafeCell` has its niche hidden.\n+            if def.is_unsafe_cell() {\n                 return false;\n             }\n "}, {"sha": "3e5f6bb8f0bcfd1f587d1a23c94f398427711505", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -182,6 +182,9 @@ pub enum StmtKind<'tcx> {\n         /// `let pat: ty = <INIT>`\n         initializer: Option<ExprId>,\n \n+        /// `let pat: ty = <INIT> else { <ELSE> }\n+        else_block: Option<Block>,\n+\n         /// The lint level for this `let` statement.\n         lint_level: LintLevel,\n     },"}, {"sha": "97249fdd175637e11747f19c8bef1f5f02df0341", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -167,11 +167,15 @@ pub fn walk_stmt<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, stmt: &Stm\n             init_scope: _,\n             ref pattern,\n             lint_level: _,\n+            else_block,\n         } => {\n             if let Some(init) = initializer {\n                 visitor.visit_expr(&visitor.thir()[*init]);\n             }\n             visitor.visit_pat(pattern);\n+            if let Some(block) = else_block {\n+                visitor.visit_block(block)\n+            }\n         }\n     }\n }"}, {"sha": "809406aff1878879802042e00a5db620c572f206", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -52,6 +52,8 @@ bitflags! {\n         /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n         /// (i.e., this flag is never set unless this ADT is an enum).\n         const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 8;\n+        /// Indicates whether the type is `UnsafeCell`.\n+        const IS_UNSAFE_CELL              = 1 << 9;\n     }\n }\n \n@@ -247,6 +249,9 @@ impl AdtDefData {\n         if Some(did) == tcx.lang_items().manually_drop() {\n             flags |= AdtFlags::IS_MANUALLY_DROP;\n         }\n+        if Some(did) == tcx.lang_items().unsafe_cell_type() {\n+            flags |= AdtFlags::IS_UNSAFE_CELL;\n+        }\n \n         AdtDefData { did, variants, flags, repr }\n     }\n@@ -333,6 +338,12 @@ impl<'tcx> AdtDef<'tcx> {\n         self.flags().contains(AdtFlags::IS_BOX)\n     }\n \n+    /// Returns `true` if this is UnsafeCell<T>.\n+    #[inline]\n+    pub fn is_unsafe_cell(self) -> bool {\n+        self.flags().contains(AdtFlags::IS_UNSAFE_CELL)\n+    }\n+\n     /// Returns `true` if this is `ManuallyDrop<T>`.\n     #[inline]\n     pub fn is_manually_drop(self) -> bool {"}, {"sha": "1ed41db099ca00cb9b9be790c6b904d610b3eed6", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -542,14 +542,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n             offsets[i as usize] = offset;\n \n-            if !repr.hide_niche() {\n-                if let Some(mut niche) = field.largest_niche {\n-                    let available = niche.available(dl);\n-                    if available > largest_niche_available {\n-                        largest_niche_available = available;\n-                        niche.offset += offset;\n-                        largest_niche = Some(niche);\n-                    }\n+            if let Some(mut niche) = field.largest_niche {\n+                let available = niche.available(dl);\n+                if available > largest_niche_available {\n+                    largest_niche_available = available;\n+                    niche.offset += offset;\n+                    largest_niche = Some(niche);\n                 }\n             }\n \n@@ -1078,6 +1076,29 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                     let mut st = self.univariant_uninterned(ty, &variants[v], &def.repr(), kind)?;\n                     st.variants = Variants::Single { index: v };\n+\n+                    if def.is_unsafe_cell() {\n+                        let hide_niches = |scalar: &mut _| match scalar {\n+                            Scalar::Initialized { value, valid_range } => {\n+                                *valid_range = WrappingRange::full(value.size(dl))\n+                            }\n+                            // Already doesn't have any niches\n+                            Scalar::Union { .. } => {}\n+                        };\n+                        match &mut st.abi {\n+                            Abi::Uninhabited => {}\n+                            Abi::Scalar(scalar) => hide_niches(scalar),\n+                            Abi::ScalarPair(a, b) => {\n+                                hide_niches(a);\n+                                hide_niches(b);\n+                            }\n+                            Abi::Vector { element, count: _ } => hide_niches(element),\n+                            Abi::Aggregate { sized: _ } => {}\n+                        }\n+                        st.largest_niche = None;\n+                        return Ok(tcx.intern_layout(st));\n+                    }\n+\n                     let (start, end) = self.tcx.layout_scalar_valid_range(def.did());\n                     match st.abi {\n                         Abi::Scalar(ref mut scalar) | Abi::ScalarPair(ref mut scalar, _) => {\n@@ -1106,11 +1127,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             }\n \n                             // Update `largest_niche` if we have introduced a larger niche.\n-                            let niche = if def.repr().hide_niche() {\n-                                None\n-                            } else {\n-                                Niche::from_scalar(dl, Size::ZERO, *scalar)\n-                            };\n+                            let niche = Niche::from_scalar(dl, Size::ZERO, *scalar);\n                             if let Some(niche) = niche {\n                                 match st.largest_niche {\n                                     Some(largest_niche) => {"}, {"sha": "c2c7b3df844ada6c5f43c7db1db43f971abc88b6", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1720,11 +1720,9 @@ bitflags! {\n         const IS_TRANSPARENT     = 1 << 2;\n         // Internal only for now. If true, don't reorder fields.\n         const IS_LINEAR          = 1 << 3;\n-        // If true, don't expose any niche to type's context.\n-        const HIDE_NICHE         = 1 << 4;\n         // If true, the type's layout can be randomized using\n         // the seed stored in `ReprOptions.layout_seed`\n-        const RANDOMIZE_LAYOUT   = 1 << 5;\n+        const RANDOMIZE_LAYOUT   = 1 << 4;\n         // Any of these flags being set prevent field reordering optimisation.\n         const IS_UNOPTIMISABLE   = ReprFlags::IS_C.bits\n                                  | ReprFlags::IS_SIMD.bits\n@@ -1781,7 +1779,6 @@ impl ReprOptions {\n                         ReprFlags::empty()\n                     }\n                     attr::ReprTransparent => ReprFlags::IS_TRANSPARENT,\n-                    attr::ReprNoNiche => ReprFlags::HIDE_NICHE,\n                     attr::ReprSimd => ReprFlags::IS_SIMD,\n                     attr::ReprInt(i) => {\n                         size = Some(i);\n@@ -1834,11 +1831,6 @@ impl ReprOptions {\n         self.flags.contains(ReprFlags::IS_LINEAR)\n     }\n \n-    #[inline]\n-    pub fn hide_niche(&self) -> bool {\n-        self.flags.contains(ReprFlags::HIDE_NICHE)\n-    }\n-\n     /// Returns the discriminant type, given these `repr` options.\n     /// This must only be called on enums!\n     pub fn discr_type(&self) -> attr::IntType {"}, {"sha": "cb8be51a08562e9463f9505464a9b8d609a5f61c", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -99,6 +99,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     ref pattern,\n                     initializer,\n                     lint_level,\n+                    else_block,\n                 } => {\n                     let ignores_expr_result = matches!(*pattern.kind, PatKind::Wild);\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n@@ -124,18 +125,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 |this| {\n                                     let scope = (*init_scope, source_info);\n                                     this.in_scope(scope, *lint_level, |this| {\n-                                        this.declare_bindings(\n-                                            visibility_scope,\n-                                            remainder_span,\n-                                            pattern,\n-                                            ArmHasGuard(false),\n-                                            Some((None, initializer_span)),\n-                                        );\n-                                        this.expr_into_pattern(block, pattern.clone(), init)\n+                                        if let Some(else_block) = else_block {\n+                                            this.ast_let_else(\n+                                                block,\n+                                                init,\n+                                                initializer_span,\n+                                                else_block,\n+                                                visibility_scope,\n+                                                remainder_span,\n+                                                pattern,\n+                                            )\n+                                        } else {\n+                                            this.declare_bindings(\n+                                                visibility_scope,\n+                                                remainder_span,\n+                                                pattern,\n+                                                ArmHasGuard(false),\n+                                                Some((None, initializer_span)),\n+                                            );\n+                                            this.expr_into_pattern(block, pattern.clone(), init) // irrefutable pattern\n+                                        }\n                                     })\n-                                }\n+                                },\n                             )\n-                        );\n+                        )\n                     } else {\n                         let scope = (*init_scope, source_info);\n                         unpack!(this.in_scope(scope, *lint_level, |this| {"}, {"sha": "7067a48b783ec24ad61e1c066db7c6120249c738", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1615,7 +1615,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // those N possible outcomes, create a (initially empty)\n         // vector of candidates. Those are the candidates that still\n         // apply if the test has that particular outcome.\n-        debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n+        debug!(\"test_candidates: test={:?} match_pair={:?}\", test, match_pair);\n         let mut target_candidates: Vec<Vec<&mut Candidate<'pat, 'tcx>>> = vec![];\n         target_candidates.resize_with(test.targets(), Default::default);\n \n@@ -1635,8 +1635,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n         // at least the first candidate ought to be tested\n         assert!(total_candidate_count > candidates.len());\n-        debug!(\"tested_candidates: {}\", total_candidate_count - candidates.len());\n-        debug!(\"untested_candidates: {}\", candidates.len());\n+        debug!(\"test_candidates: tested_candidates: {}\", total_candidate_count - candidates.len());\n+        debug!(\"test_candidates: untested_candidates: {}\", candidates.len());\n \n         // HACK(matthewjasper) This is a closure so that we can let the test\n         // create its blocks before the rest of the match. This currently\n@@ -2274,4 +2274,75 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"declare_binding: vars={:?}\", locals);\n         self.var_indices.insert(var_id, locals);\n     }\n+\n+    pub(crate) fn ast_let_else(\n+        &mut self,\n+        mut block: BasicBlock,\n+        init: &Expr<'tcx>,\n+        initializer_span: Span,\n+        else_block: &Block,\n+        visibility_scope: Option<SourceScope>,\n+        remainder_span: Span,\n+        pattern: &Pat<'tcx>,\n+    ) -> BlockAnd<()> {\n+        let scrutinee = unpack!(block = self.lower_scrutinee(block, init, initializer_span));\n+        let pat = Pat { ty: init.ty, span: else_block.span, kind: Box::new(PatKind::Wild) };\n+        let mut wildcard = Candidate::new(scrutinee.clone(), &pat, false);\n+        self.declare_bindings(\n+            visibility_scope,\n+            remainder_span,\n+            pattern,\n+            ArmHasGuard(false),\n+            Some((None, initializer_span)),\n+        );\n+        let mut candidate = Candidate::new(scrutinee.clone(), pattern, false);\n+        let fake_borrow_temps = self.lower_match_tree(\n+            block,\n+            initializer_span,\n+            pattern.span,\n+            false,\n+            &mut [&mut candidate, &mut wildcard],\n+        );\n+        // This block is for the matching case\n+        let matching = self.bind_pattern(\n+            self.source_info(pattern.span),\n+            candidate,\n+            None,\n+            &fake_borrow_temps,\n+            initializer_span,\n+            None,\n+            None,\n+            None,\n+        );\n+        // This block is for the failure case\n+        let failure = self.bind_pattern(\n+            self.source_info(else_block.span),\n+            wildcard,\n+            None,\n+            &fake_borrow_temps,\n+            initializer_span,\n+            None,\n+            None,\n+            None,\n+        );\n+        // This place is not really used because this destination place\n+        // should never be used to take values at the end of the failure\n+        // block.\n+        let dummy_place = Place { local: RETURN_PLACE, projection: ty::List::empty() };\n+        let failure_block;\n+        unpack!(\n+            failure_block = self.ast_block(\n+                dummy_place,\n+                failure,\n+                else_block,\n+                self.source_info(else_block.span),\n+            )\n+        );\n+        self.cfg.terminate(\n+            failure_block,\n+            self.source_info(else_block.span),\n+            TerminatorKind::Unreachable,\n+        );\n+        matching.unit()\n+    }\n }"}, {"sha": "dccaa61ed89d45faabdd89b666532a55b6d1b394", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -74,6 +74,8 @@ impl<'tcx> Cx<'tcx> {\n                             )),\n                         };\n \n+                        let else_block = local.els.map(|els| self.mirror_block(els));\n+\n                         let mut pattern = self.pattern_from_hir(local.pat);\n                         debug!(?pattern);\n \n@@ -110,6 +112,7 @@ impl<'tcx> Cx<'tcx> {\n                                 },\n                                 pattern,\n                                 initializer: local.init.map(|init| self.mirror_expr(init)),\n+                                else_block,\n                                 lint_level: LintLevel::Explicit(local.hir_id),\n                             },\n                             opt_destruction_scope: opt_dxn_ext,"}, {"sha": "5bd1fad0bcb9f9cbbe1e9ec2edfff178451afd97", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -21,7 +21,7 @@ use rustc_session::lint::builtin::{\n };\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n-use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span};\n+use rustc_span::{BytePos, Span};\n \n pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match def_id.as_local() {\n@@ -77,14 +77,20 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, '_, 'tcx> {\n \n     fn visit_local(&mut self, loc: &'tcx hir::Local<'tcx>) {\n         intravisit::walk_local(self, loc);\n+        let els = loc.els;\n+        if let Some(init) = loc.init && els.is_some() {\n+            self.check_let(&loc.pat, init, loc.span);\n+        }\n \n         let (msg, sp) = match loc.source {\n             hir::LocalSource::Normal => (\"local binding\", Some(loc.span)),\n             hir::LocalSource::AsyncFn => (\"async fn binding\", None),\n             hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n             hir::LocalSource::AssignDesugar(_) => (\"destructuring assignment binding\", None),\n         };\n-        self.check_irrefutable(&loc.pat, msg, sp);\n+        if els.is_none() {\n+            self.check_irrefutable(&loc.pat, msg, sp);\n+        }\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n@@ -1125,17 +1131,16 @@ fn let_source_parent(tcx: TyCtxt<'_>, parent: HirId, pat_id: Option<HirId>) -> L\n         }) if Some(*hir_id) == pat_id => {\n             return LetSource::IfLetGuard;\n         }\n-        hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Let(..), span, .. }) => {\n-            let expn_data = span.ctxt().outer_expn_data();\n-            if let ExpnKind::Desugaring(DesugaringKind::LetElse) = expn_data.kind {\n-                return LetSource::LetElse(expn_data.call_site);\n-            }\n-        }\n         _ => {}\n     }\n \n     let parent_parent = hir.get_parent_node(parent);\n     let parent_parent_node = hir.get(parent_parent);\n+    if let hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(_), span, .. }) =\n+        parent_parent_node\n+    {\n+        return LetSource::LetElse(*span);\n+    }\n \n     let parent_parent_parent = hir.get_parent_node(parent_parent);\n     let parent_parent_parent_parent = hir.get_parent_node(parent_parent_parent);"}, {"sha": "c48aa9a90efbed5bcea47076471e9b0366ced87c", "filename": "compiler/rustc_mir_transform/src/remove_uninit_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -102,7 +102,7 @@ fn is_needs_drop_and_init<'tcx>(\n     let field_needs_drop_and_init = |(f, f_ty, mpi)| {\n         let child = move_path_children_matching(move_data, mpi, |x| x.is_field_to(f));\n         let Some(mpi) = child else {\n-            return f_ty.needs_drop(tcx, param_env);\n+            return Ty::needs_drop(f_ty, tcx, param_env);\n         };\n \n         is_needs_drop_and_init(tcx, param_env, maybe_inits, move_data, f_ty, mpi)"}, {"sha": "0d9c57908c1e3620d12eee09236ea06f83fed65b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -3028,6 +3028,11 @@ impl<'a> Parser<'a> {\n                 }\n             };\n \n+            let is_shorthand = parsed_field.as_ref().map_or(false, |f| f.is_shorthand);\n+            // A shorthand field can be turned into a full field with `:`.\n+            // We should point this out.\n+            self.check_or_expected(!is_shorthand, TokenType::Token(token::Colon));\n+\n             match self.expect_one_of(&[token::Comma], &[token::CloseDelim(close_delim)]) {\n                 Ok(_) => {\n                     if let Some(f) = parsed_field.or(recovery_field) {\n@@ -3048,6 +3053,19 @@ impl<'a> Parser<'a> {\n                                 \",\",\n                                 Applicability::MachineApplicable,\n                             );\n+                        } else if is_shorthand\n+                            && (AssocOp::from_token(&self.token).is_some()\n+                                || matches!(&self.token.kind, token::OpenDelim(_))\n+                                || self.token.kind == token::Dot)\n+                        {\n+                            // Looks like they tried to write a shorthand, complex expression.\n+                            let ident = parsed_field.expect(\"is_shorthand implies Some\").ident;\n+                            e.span_suggestion(\n+                                ident.span.shrink_to_lo(),\n+                                \"try naming a field\",\n+                                &format!(\"{ident}: \"),\n+                                Applicability::HasPlaceholders,\n+                            );\n                         }\n                     }\n                     if !recover {"}, {"sha": "20d03d797fed1531a8c0ace9e92489a721077c10", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1808,21 +1808,6 @@ impl CheckAttrVisitor<'_> {\n                         _ => (\"a\", \"struct, enum, or union\"),\n                     }\n                 }\n-                sym::no_niche => {\n-                    if !self.tcx.features().enabled(sym::no_niche) {\n-                        feature_err(\n-                            &self.tcx.sess.parse_sess,\n-                            sym::no_niche,\n-                            hint.span(),\n-                            \"the attribute `repr(no_niche)` is currently unstable\",\n-                        )\n-                        .emit();\n-                    }\n-                    match target {\n-                        Target::Struct | Target::Enum => continue,\n-                        _ => (\"a\", \"struct or enum\"),\n-                    }\n-                }\n                 sym::i8\n                 | sym::u8\n                 | sym::i16\n@@ -1870,10 +1855,8 @@ impl CheckAttrVisitor<'_> {\n         // This is not ideal, but tracking precisely which ones are at fault is a huge hassle.\n         let hint_spans = hints.iter().map(|hint| hint.span());\n \n-        // Error on repr(transparent, <anything else apart from no_niche>).\n-        let non_no_niche = |hint: &&NestedMetaItem| hint.name_or_empty() != sym::no_niche;\n-        let non_no_niche_count = hints.iter().filter(non_no_niche).count();\n-        if is_transparent && non_no_niche_count > 1 {\n+        // Error on repr(transparent, <anything else>).\n+        if is_transparent && hints.len() > 1 {\n             let hint_spans: Vec<_> = hint_spans.clone().collect();\n             struct_span_err!(\n                 self.tcx.sess,"}, {"sha": "eed3e1579a2313fc6bd67de639bb633d4250f8c7", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -278,7 +278,7 @@ impl<'tcx> IrMaps<'tcx> {\n                     pats.extend(inner_pat.iter());\n                 }\n                 Struct(_, fields, _) => {\n-                    let (short, not_short): (Vec<&_>, Vec<&_>) =\n+                    let (short, not_short): (Vec<_>, _) =\n                         fields.iter().partition(|f| f.is_shorthand);\n                     shorthand_field_ids.extend(short.iter().map(|f| f.pat.hir_id));\n                     pats.extend(not_short.iter().map(|f| f.pat));\n@@ -298,7 +298,7 @@ impl<'tcx> IrMaps<'tcx> {\n             }\n         }\n \n-        return shorthand_field_ids;\n+        shorthand_field_ids\n     }\n \n     fn add_from_pat(&mut self, pat: &hir::Pat<'tcx>) {\n@@ -368,6 +368,9 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n \n     fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n         self.add_from_pat(&local.pat);\n+        if local.els.is_some() {\n+            self.add_live_node_for_node(local.hir_id, ExprNode(local.span, local.hir_id));\n+        }\n         intravisit::walk_local(self, local);\n     }\n \n@@ -800,8 +803,40 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 // initialization, which is mildly more complex than checking\n                 // once at the func header but otherwise equivalent.\n \n-                let succ = self.propagate_through_opt_expr(local.init, succ);\n-                self.define_bindings_in_pat(&local.pat, succ)\n+                if let Some(els) = local.els {\n+                    // Eventually, `let pat: ty = init else { els };` is mostly equivalent to\n+                    // `let (bindings, ...) = match init { pat => (bindings, ...), _ => els };`\n+                    // except that extended lifetime applies at the `init` location.\n+                    //\n+                    //       (e)\n+                    //        |\n+                    //        v\n+                    //      (expr)\n+                    //      /   \\\n+                    //     |     |\n+                    //     v     v\n+                    // bindings  els\n+                    //     |\n+                    //     v\n+                    // ( succ )\n+                    //\n+                    if let Some(init) = local.init {\n+                        let else_ln = self.propagate_through_block(els, succ);\n+                        let ln = self.live_node(local.hir_id, local.span);\n+                        self.init_from_succ(ln, succ);\n+                        self.merge_from_succ(ln, else_ln);\n+                        let succ = self.propagate_through_expr(init, ln);\n+                        self.define_bindings_in_pat(&local.pat, succ)\n+                    } else {\n+                        span_bug!(\n+                            stmt.span,\n+                            \"variable is uninitialized but an unexpected else branch is found\"\n+                        )\n+                    }\n+                } else {\n+                    let succ = self.propagate_through_opt_expr(local.init, succ);\n+                    self.define_bindings_in_pat(&local.pat, succ)\n+                }\n             }\n             hir::StmtKind::Item(..) => succ,\n             hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => {\n@@ -1121,7 +1156,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         //     (rvalue)          ||       (rvalue)\n         //         |             ||           |\n         //         v             ||           v\n-        // (write of place)     ||   (place components)\n+        // (write of place)      ||   (place components)\n         //         |             ||           |\n         //         v             ||           v\n         //      (succ)           ||        (succ)"}, {"sha": "a820f700869b211ef7b6e0ef63386cc36656025c", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -508,7 +508,7 @@ impl<'a> Resolver<'a> {\n                     E0401,\n                     \"can't use generic parameters from outer function\",\n                 );\n-                err.span_label(span, \"use of generic parameter from outer function\".to_string());\n+                err.span_label(span, \"use of generic parameter from outer function\");\n \n                 let sm = self.session.source_map();\n                 match outer_res {\n@@ -990,7 +990,7 @@ impl<'a> Resolver<'a> {\n                     E0735,\n                     \"generic parameters cannot use `Self` in their defaults\"\n                 );\n-                err.span_label(span, \"`Self` in generic parameter default\".to_string());\n+                err.span_label(span, \"`Self` in generic parameter default\");\n                 err\n             }\n             ResolutionError::UnreachableLabel { name, definition_span, suggestion } => {"}, {"sha": "a4175f4c5f37731a9e8cc0aa679760cf16130038", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -82,14 +82,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     pub fn new(save_ctxt: SaveContext<'tcx>) -> DumpVisitor<'tcx> {\n         let span_utils = SpanUtils::new(&save_ctxt.tcx.sess);\n         let dumper = Dumper::new(save_ctxt.config.clone());\n-        DumpVisitor {\n-            tcx: save_ctxt.tcx,\n-            save_ctxt,\n-            dumper,\n-            span: span_utils,\n-            // mac_defs: FxHashSet::default(),\n-            // macro_calls: FxHashSet::default(),\n-        }\n+        DumpVisitor { tcx: save_ctxt.tcx, save_ctxt, dumper, span: span_utils }\n     }\n \n     pub fn analysis(&self) -> &rls_data::Analysis {\n@@ -1425,9 +1418,10 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n         self.process_macro_use(l.span);\n         self.process_var_decl(&l.pat);\n \n-        // Just walk the initializer and type (don't want to walk the pattern again).\n+        // Just walk the initializer, the else branch and type (don't want to walk the pattern again).\n         walk_list!(self, visit_ty, &l.ty);\n         walk_list!(self, visit_expr, &l.init);\n+        walk_list!(self, visit_block, l.els);\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {"}, {"sha": "16f4a099d80c078ccbf20677cb56bbe5b103f224", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -194,6 +194,9 @@ pub struct Session {\n \n     /// Set of enabled features for the current target.\n     pub target_features: FxHashSet<Symbol>,\n+\n+    /// Set of enabled features for the current target, including unstable ones.\n+    pub unstable_target_features: FxHashSet<Symbol>,\n }\n \n pub struct PerfStats {\n@@ -1390,6 +1393,7 @@ pub fn build_session(\n         miri_unleashed_features: Lock::new(Default::default()),\n         asm_arch,\n         target_features: FxHashSet::default(),\n+        unstable_target_features: FxHashSet::default(),\n     };\n \n     validate_commandline_args_with_session_available(&sess);"}, {"sha": "29879c48b04ae04fab3eb75a4ebc4c00d35963cf", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1141,7 +1141,6 @@ pub enum DesugaringKind {\n     Async,\n     Await,\n     ForLoop,\n-    LetElse,\n     WhileLoop,\n }\n \n@@ -1157,7 +1156,6 @@ impl DesugaringKind {\n             DesugaringKind::YeetExpr => \"`do yeet` expression\",\n             DesugaringKind::OpaqueTy => \"`impl Trait`\",\n             DesugaringKind::ForLoop => \"`for` loop\",\n-            DesugaringKind::LetElse => \"`let...else`\",\n             DesugaringKind::WhileLoop => \"`while` loop\",\n         }\n     }"}, {"sha": "99912b491cb7d912001f0e89bd713ea68456e418", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -980,7 +980,6 @@ symbols! {\n         no_link,\n         no_main,\n         no_mangle,\n-        no_niche,\n         no_sanitize,\n         no_stack_check,\n         no_start,\n@@ -1153,7 +1152,6 @@ symbols! {\n         repr128,\n         repr_align,\n         repr_align_enum,\n-        repr_no_niche,\n         repr_packed,\n         repr_simd,\n         repr_transparent,"}, {"sha": "b08fc482186029fbbe3f818e6e11353ac39bd371", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1311,7 +1311,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         visitor.visit_body(&body);\n \n         let typeck_results = self.in_progress_typeck_results.map(|t| t.borrow()).unwrap();\n-        let Some(liberated_sig) = typeck_results.liberated_fn_sigs().get(fn_hir_id) else { return false; };\n+        let Some(liberated_sig) = typeck_results.liberated_fn_sigs().get(fn_hir_id).copied() else { return false; };\n \n         let ret_types = visitor\n             .returns"}, {"sha": "30b76b922c77a7f06e0ce77a26b2d7527943093d", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -997,26 +997,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         coerce.coerce(self, &self.misc(sp), then_expr, then_ty);\n \n         if let Some(else_expr) = opt_else_expr {\n-            let else_ty = if sp.desugaring_kind() == Some(DesugaringKind::LetElse) {\n-                // todo introduce `check_expr_with_expectation(.., Expectation::LetElse)`\n-                //   for errors that point to the offending expression rather than the entire block.\n-                //   We could use `check_expr_eq_type(.., tcx.types.never)`, but then there is no\n-                //   way to detect that the expected type originated from let-else and provide\n-                //   a customized error.\n-                let else_ty = self.check_expr(else_expr);\n-                let cause = self.cause(else_expr.span, ObligationCauseCode::LetElse);\n-\n-                if let Some(mut err) =\n-                    self.demand_eqtype_with_origin(&cause, self.tcx.types.never, else_ty)\n-                {\n-                    err.emit();\n-                    self.tcx.ty_error()\n-                } else {\n-                    else_ty\n-                }\n-            } else {\n-                self.check_expr_with_expectation(else_expr, expected)\n-            };\n+            let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let else_diverges = self.diverges.get();\n \n             let opt_suggest_box_span = self.opt_suggest_box_span(else_ty, orig_expected);"}, {"sha": "60ee2233ed9c0f7311ebe20282e308faf7827da6", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1215,6 +1215,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.check_pat_top(&decl.pat, decl_ty, ty_span, origin_expr);\n         let pat_ty = self.node_ty(decl.pat.hir_id);\n         self.overwrite_local_ty_if_err(decl.hir_id, decl.pat, decl_ty, pat_ty);\n+\n+        if let Some(blk) = decl.els {\n+            let previous_diverges = self.diverges.get();\n+            let else_ty = self.check_block_with_expected(blk, NoExpectation);\n+            let cause = self.cause(blk.span, ObligationCauseCode::LetElse);\n+            if let Some(mut err) =\n+                self.demand_eqtype_with_origin(&cause, self.tcx.types.never, else_ty)\n+            {\n+                err.emit();\n+            }\n+            self.diverges.set(previous_diverges);\n+        }\n     }\n \n     /// Type check a `let` statement.\n@@ -1236,8 +1248,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let old_has_errors = self.has_errors.replace(false);\n \n         match stmt.kind {\n-            hir::StmtKind::Local(ref l) => {\n-                self.check_decl_local(&l);\n+            hir::StmtKind::Local(l) => {\n+                self.check_decl_local(l);\n             }\n             // Ignore for now.\n             hir::StmtKind::Item(_) => {}"}, {"sha": "8f34a970f6ff7694ea9eb69468d0392e0e21f934", "filename": "compiler/rustc_typeck/src/check/gather_locals.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -16,19 +16,20 @@ pub(super) struct Declaration<'a> {\n     pub ty: Option<&'a hir::Ty<'a>>,\n     pub span: Span,\n     pub init: Option<&'a hir::Expr<'a>>,\n+    pub els: Option<&'a hir::Block<'a>>,\n }\n \n impl<'a> From<&'a hir::Local<'a>> for Declaration<'a> {\n     fn from(local: &'a hir::Local<'a>) -> Self {\n-        let hir::Local { hir_id, pat, ty, span, init, .. } = *local;\n-        Declaration { hir_id, pat, ty, span, init }\n+        let hir::Local { hir_id, pat, ty, span, init, els, source: _ } = *local;\n+        Declaration { hir_id, pat, ty, span, init, els }\n     }\n }\n \n impl<'a> From<&'a hir::Let<'a>> for Declaration<'a> {\n     fn from(let_expr: &'a hir::Let<'a>) -> Self {\n         let hir::Let { hir_id, pat, ty, span, init } = *let_expr;\n-        Declaration { hir_id, pat, ty, span, init: Some(init) }\n+        Declaration { hir_id, pat, ty, span, init: Some(init), els: None }\n     }\n }\n \n@@ -101,7 +102,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n         self.declare(local.into());\n-        intravisit::walk_local(self, local);\n+        intravisit::walk_local(self, local)\n     }\n \n     fn visit_let_expr(&mut self, let_expr: &'tcx hir::Let<'tcx>) {"}, {"sha": "a1a92c62ad22f070af9be63604a71e45329dc3e6", "filename": "compiler/rustc_typeck/src/check/region.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -460,6 +460,7 @@ fn resolve_local<'tcx>(\n     visitor: &mut RegionResolutionVisitor<'tcx>,\n     pat: Option<&'tcx hir::Pat<'tcx>>,\n     init: Option<&'tcx hir::Expr<'tcx>>,\n+    els: Option<&'tcx hir::Block<'tcx>>,\n ) {\n     debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n \n@@ -537,13 +538,18 @@ fn resolve_local<'tcx>(\n         }\n     }\n \n-    // Make sure we visit the initializer first, so expr_and_pat_count remains correct\n+    // Make sure we visit the initializer first, so expr_and_pat_count remains correct.\n+    // The correct order, as shared between generator_interior, drop_ranges and intravisitor,\n+    // is to walk initializer, followed by pattern bindings, finally followed by the `else` block.\n     if let Some(expr) = init {\n         visitor.visit_expr(expr);\n     }\n     if let Some(pat) = pat {\n         visitor.visit_pat(pat);\n     }\n+    if let Some(els) = els {\n+        visitor.visit_block(els);\n+    }\n \n     /// Returns `true` if `pat` match the `P&` non-terminal.\n     ///\n@@ -764,7 +770,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n             // (i.e., `'static`), which means that after `g` returns, it drops,\n             // and all the associated destruction scope rules apply.\n             self.cx.var_parent = None;\n-            resolve_local(self, None, Some(&body.value));\n+            resolve_local(self, None, Some(&body.value), None);\n         }\n \n         if body.generator_kind.is_some() {\n@@ -791,7 +797,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         resolve_expr(self, ex);\n     }\n     fn visit_local(&mut self, l: &'tcx Local<'tcx>) {\n-        resolve_local(self, Some(&l.pat), l.init);\n+        resolve_local(self, Some(&l.pat), l.init, l.els)\n     }\n }\n "}, {"sha": "9795be1a912ad960d3413a3ddb9951cf63f1dfd4", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -3196,7 +3196,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n /// Computes the set of target features used in a function for the purposes of\n /// inline assembly.\n fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, did: DefId) -> &'tcx FxHashSet<Symbol> {\n-    let mut target_features = tcx.sess.target_features.clone();\n+    let mut target_features = tcx.sess.unstable_target_features.clone();\n     if tcx.def_kind(did).has_codegen_attrs() {\n         let attrs = tcx.codegen_fn_attrs(did);\n         target_features.extend(&attrs.target_features);"}, {"sha": "9d7420acd2662661182420ba50673dc733fddb87", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 115, "deletions": 91, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -2,7 +2,10 @@\n //! normal visitor, which just walks the entire body in one shot, the\n //! `ExprUseVisitor` determines how expressions are being used.\n \n+use std::slice::from_ref;\n+\n use hir::def::DefKind;\n+use hir::Expr;\n // Export these here so that Clippy can use them.\n pub use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection};\n \n@@ -252,96 +255,16 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Let(hir::Let { pat, init, .. }) => {\n-                self.walk_local(init, pat, |t| t.borrow_expr(init, ty::ImmBorrow));\n+                self.walk_local(init, pat, None, |t| t.borrow_expr(init, ty::ImmBorrow))\n             }\n \n             hir::ExprKind::Match(ref discr, arms, _) => {\n                 let discr_place = return_if_err!(self.mc.cat_expr(discr));\n-\n-                // Matching should not always be considered a use of the place, hence\n-                // discr does not necessarily need to be borrowed.\n-                // We only want to borrow discr if the pattern contain something other\n-                // than wildcards.\n-                let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n-                let mut needs_to_be_read = false;\n-                for arm in arms.iter() {\n-                    return_if_err!(mc.cat_pattern(discr_place.clone(), arm.pat, |place, pat| {\n-                        match &pat.kind {\n-                            PatKind::Binding(.., opt_sub_pat) => {\n-                                // If the opt_sub_pat is None, than the binding does not count as\n-                                // a wildcard for the purpose of borrowing discr.\n-                                if opt_sub_pat.is_none() {\n-                                    needs_to_be_read = true;\n-                                }\n-                            }\n-                            PatKind::Path(qpath) => {\n-                                // A `Path` pattern is just a name like `Foo`. This is either a\n-                                // named constant or else it refers to an ADT variant\n-\n-                                let res = self.mc.typeck_results.qpath_res(qpath, pat.hir_id);\n-                                match res {\n-                                    Res::Def(DefKind::Const, _)\n-                                    | Res::Def(DefKind::AssocConst, _) => {\n-                                        // Named constants have to be equated with the value\n-                                        // being matched, so that's a read of the value being matched.\n-                                        //\n-                                        // FIXME: We don't actually  reads for ZSTs.\n-                                        needs_to_be_read = true;\n-                                    }\n-                                    _ => {\n-                                        // Otherwise, this is a struct/enum variant, and so it's\n-                                        // only a read if we need to read the discriminant.\n-                                        needs_to_be_read |= is_multivariant_adt(place.place.ty());\n-                                    }\n-                                }\n-                            }\n-                            PatKind::TupleStruct(..) | PatKind::Struct(..) | PatKind::Tuple(..) => {\n-                                // For `Foo(..)`, `Foo { ... }` and `(...)` patterns, check if we are matching\n-                                // against a multivariant enum or struct. In that case, we have to read\n-                                // the discriminant. Otherwise this kind of pattern doesn't actually\n-                                // read anything (we'll get invoked for the `...`, which may indeed\n-                                // perform some reads).\n-\n-                                let place_ty = place.place.ty();\n-                                needs_to_be_read |= is_multivariant_adt(place_ty);\n-                            }\n-                            PatKind::Lit(_) | PatKind::Range(..) => {\n-                                // If the PatKind is a Lit or a Range then we want\n-                                // to borrow discr.\n-                                needs_to_be_read = true;\n-                            }\n-                            PatKind::Or(_)\n-                            | PatKind::Box(_)\n-                            | PatKind::Slice(..)\n-                            | PatKind::Ref(..)\n-                            | PatKind::Wild => {\n-                                // If the PatKind is Or, Box, Slice or Ref, the decision is made later\n-                                // as these patterns contains subpatterns\n-                                // If the PatKind is Wild, the decision is made based on the other patterns being\n-                                // examined\n-                            }\n-                        }\n-                    }));\n-                }\n-\n-                if needs_to_be_read {\n-                    self.borrow_expr(discr, ty::ImmBorrow);\n-                } else {\n-                    let closure_def_id = match discr_place.place.base {\n-                        PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id.to_def_id()),\n-                        _ => None,\n-                    };\n-\n-                    self.delegate.fake_read(\n-                        &discr_place,\n-                        FakeReadCause::ForMatchedPlace(closure_def_id),\n-                        discr_place.hir_id,\n-                    );\n-\n-                    // We always want to walk the discriminant. We want to make sure, for instance,\n-                    // that the discriminant has been initialized.\n-                    self.walk_expr(discr);\n-                }\n+                self.maybe_read_scrutinee(\n+                    discr,\n+                    discr_place.clone(),\n+                    arms.iter().map(|arm| arm.pat),\n+                );\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n@@ -453,8 +376,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     fn walk_stmt(&mut self, stmt: &hir::Stmt<'_>) {\n         match stmt.kind {\n-            hir::StmtKind::Local(hir::Local { pat, init: Some(expr), .. }) => {\n-                self.walk_local(expr, pat, |_| {});\n+            hir::StmtKind::Local(hir::Local { pat, init: Some(expr), els, .. }) => {\n+                self.walk_local(expr, pat, *els, |_| {})\n             }\n \n             hir::StmtKind::Local(_) => {}\n@@ -470,13 +393,114 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_local<F>(&mut self, expr: &hir::Expr<'_>, pat: &hir::Pat<'_>, mut f: F)\n-    where\n+    fn maybe_read_scrutinee<'t>(\n+        &mut self,\n+        discr: &Expr<'_>,\n+        discr_place: PlaceWithHirId<'tcx>,\n+        pats: impl Iterator<Item = &'t hir::Pat<'t>>,\n+    ) {\n+        // Matching should not always be considered a use of the place, hence\n+        // discr does not necessarily need to be borrowed.\n+        // We only want to borrow discr if the pattern contain something other\n+        // than wildcards.\n+        let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n+        let mut needs_to_be_read = false;\n+        for pat in pats {\n+            return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n+                match &pat.kind {\n+                    PatKind::Binding(.., opt_sub_pat) => {\n+                        // If the opt_sub_pat is None, than the binding does not count as\n+                        // a wildcard for the purpose of borrowing discr.\n+                        if opt_sub_pat.is_none() {\n+                            needs_to_be_read = true;\n+                        }\n+                    }\n+                    PatKind::Path(qpath) => {\n+                        // A `Path` pattern is just a name like `Foo`. This is either a\n+                        // named constant or else it refers to an ADT variant\n+\n+                        let res = self.mc.typeck_results.qpath_res(qpath, pat.hir_id);\n+                        match res {\n+                            Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => {\n+                                // Named constants have to be equated with the value\n+                                // being matched, so that's a read of the value being matched.\n+                                //\n+                                // FIXME: We don't actually  reads for ZSTs.\n+                                needs_to_be_read = true;\n+                            }\n+                            _ => {\n+                                // Otherwise, this is a struct/enum variant, and so it's\n+                                // only a read if we need to read the discriminant.\n+                                needs_to_be_read |= is_multivariant_adt(place.place.ty());\n+                            }\n+                        }\n+                    }\n+                    PatKind::TupleStruct(..) | PatKind::Struct(..) | PatKind::Tuple(..) => {\n+                        // For `Foo(..)`, `Foo { ... }` and `(...)` patterns, check if we are matching\n+                        // against a multivariant enum or struct. In that case, we have to read\n+                        // the discriminant. Otherwise this kind of pattern doesn't actually\n+                        // read anything (we'll get invoked for the `...`, which may indeed\n+                        // perform some reads).\n+\n+                        let place_ty = place.place.ty();\n+                        needs_to_be_read |= is_multivariant_adt(place_ty);\n+                    }\n+                    PatKind::Lit(_) | PatKind::Range(..) => {\n+                        // If the PatKind is a Lit or a Range then we want\n+                        // to borrow discr.\n+                        needs_to_be_read = true;\n+                    }\n+                    PatKind::Or(_)\n+                    | PatKind::Box(_)\n+                    | PatKind::Slice(..)\n+                    | PatKind::Ref(..)\n+                    | PatKind::Wild => {\n+                        // If the PatKind is Or, Box, Slice or Ref, the decision is made later\n+                        // as these patterns contains subpatterns\n+                        // If the PatKind is Wild, the decision is made based on the other patterns being\n+                        // examined\n+                    }\n+                }\n+            }));\n+        }\n+\n+        if needs_to_be_read {\n+            self.borrow_expr(discr, ty::ImmBorrow);\n+        } else {\n+            let closure_def_id = match discr_place.place.base {\n+                PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id.to_def_id()),\n+                _ => None,\n+            };\n+\n+            self.delegate.fake_read(\n+                &discr_place,\n+                FakeReadCause::ForMatchedPlace(closure_def_id),\n+                discr_place.hir_id,\n+            );\n+\n+            // We always want to walk the discriminant. We want to make sure, for instance,\n+            // that the discriminant has been initialized.\n+            self.walk_expr(discr);\n+        }\n+    }\n+\n+    fn walk_local<F>(\n+        &mut self,\n+        expr: &hir::Expr<'_>,\n+        pat: &hir::Pat<'_>,\n+        els: Option<&hir::Block<'_>>,\n+        mut f: F,\n+    ) where\n         F: FnMut(&mut Self),\n     {\n         self.walk_expr(expr);\n         let expr_place = return_if_err!(self.mc.cat_expr(expr));\n         f(self);\n+        if let Some(els) = els {\n+            // borrowing because we need to test the descriminant\n+            self.maybe_read_scrutinee(expr, expr_place.clone(), from_ref(pat).iter());\n+            self.walk_block(els)\n+        }\n         self.walk_irrefutable_pat(&expr_place, &pat);\n     }\n \n@@ -667,7 +691,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         let ExprUseVisitor { ref mc, body_owner: _, ref mut delegate } = *self;\n         return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n-                debug!(\"walk_pat: binding place={:?} pat={:?}\", place, pat,);\n+                debug!(\"walk_pat: binding place={:?} pat={:?}\", place, pat);\n                 if let Some(bm) =\n                     mc.typeck_results.extract_binding_mode(tcx.sess, pat.hir_id, pat.span)\n                 {"}, {"sha": "8a37fadc56f4c8ef583f50fbac292c13ad4cb418", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1856,7 +1856,6 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n #[lang = \"unsafe_cell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(transparent)]\n-#[repr(no_niche)] // rust-lang/rust#68303.\n pub struct UnsafeCell<T: ?Sized> {\n     value: T,\n }"}, {"sha": "f24a7ab61ae8903cd98dfdb3fcb1b992f8834220", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -191,7 +191,6 @@\n #![feature(never_type)]\n #![feature(no_core)]\n #![feature(no_coverage)] // rust-lang/rust#84605\n-#![feature(no_niche)] // rust-lang/rust#68303\n #![feature(platform_intrinsics)]\n #![feature(prelude_import)]\n #![feature(repr_simd)]"}, {"sha": "bb6201861dff6054db076b225318cd35a210fbd6", "filename": "src/test/ui/asm/issue-99071.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fasm%2Fissue-99071.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fasm%2Fissue-99071.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-99071.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -0,0 +1,21 @@\n+// compile-flags: --target thumbv6m-none-eabi\n+// needs-llvm-components: arm\n+// needs-asm-support\n+\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![no_core]\n+#![crate_type = \"rlib\"]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+pub fn foo() {\n+    unsafe {\n+        asm!(\"\", in(\"r8\") 0);\n+        //~^ cannot use register `r8`: high registers (r8+) can only be used as clobbers in Thumb-1 code\n+    }\n+}"}, {"sha": "47386ffa4a8c9584f2866cb253764633b306272f", "filename": "src/test/ui/asm/issue-99071.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fasm%2Fissue-99071.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fasm%2Fissue-99071.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-99071.stderr?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -0,0 +1,8 @@\n+error: cannot use register `r8`: high registers (r8+) can only be used as clobbers in Thumb-1 code\n+  --> $DIR/issue-99071.rs:18:18\n+   |\n+LL |         asm!(\"\", in(\"r8\") 0);\n+   |                  ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "7ea07ae9add1bd7c66430df957460f1235de7dd7", "filename": "src/test/ui/async-await/async-await-let-else.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -0,0 +1,53 @@\n+// edition:2021\n+#![feature(let_else)]\n+use std::rc::Rc;\n+\n+async fn foo(x: Option<bool>) {\n+    let Some(_) = x else {\n+        let r = Rc::new(());\n+        bar().await\n+    };\n+}\n+\n+async fn bar() -> ! {\n+    panic!()\n+}\n+\n+fn is_send<T: Send>(_: T) {}\n+\n+async fn foo2(x: Option<bool>) {\n+    let Some(_) = x else {\n+        bar2(Rc::new(())).await\n+    };\n+}\n+\n+async fn bar2<T>(_: T) -> ! {\n+    panic!()\n+}\n+\n+async fn foo3(x: Option<bool>) {\n+    let Some(_) = x else {\n+        (Rc::new(()), bar().await);\n+        return;\n+    };\n+}\n+\n+async fn foo4(x: Option<bool>) {\n+    let Some(_) = x else {\n+        let r = Rc::new(());\n+        bar().await;\n+        println!(\"{:?}\", r);\n+        return;\n+    };\n+}\n+\n+fn main() {\n+    is_send(foo(Some(true)));\n+    //~^ ERROR future cannot be sent between threads safely\n+    is_send(foo2(Some(true)));\n+    //~^ ERROR future cannot be sent between threads safely\n+    is_send(foo3(Some(true)));\n+    //~^ ERROR future cannot be sent between threads safely\n+    is_send(foo4(Some(true)));\n+    //~^ ERROR future cannot be sent between threads safely\n+}"}, {"sha": "4d23e27c426b280a0ca768942c3140c3a3345ae5", "filename": "src/test/ui/async-await/async-await-let-else.stderr", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.stderr?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -0,0 +1,94 @@\n+error: future cannot be sent between threads safely\n+  --> $DIR/async-await-let-else.rs:45:13\n+   |\n+LL |     is_send(foo(Some(true)));\n+   |             ^^^^^^^^^^^^^^^ future returned by `foo` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-await-let-else.rs:8:14\n+   |\n+LL |         let r = Rc::new(());\n+   |             - has type `Rc<()>` which is not `Send`\n+LL |         bar().await\n+   |              ^^^^^^ await occurs here, with `r` maybe used later\n+LL |     };\n+   |     - `r` is later dropped here\n+note: required by a bound in `is_send`\n+  --> $DIR/async-await-let-else.rs:16:15\n+   |\n+LL | fn is_send<T: Send>(_: T) {}\n+   |               ^^^^ required by this bound in `is_send`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/async-await-let-else.rs:47:13\n+   |\n+LL |     is_send(foo2(Some(true)));\n+   |             ^^^^^^^^^^^^^^^^ future returned by `foo2` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-await-let-else.rs:20:26\n+   |\n+LL |         bar2(Rc::new(())).await\n+   |              ----------- ^^^^^^ await occurs here, with `Rc::new(())` maybe used later\n+   |              |\n+   |              has type `Rc<()>` which is not `Send`\n+LL |     };\n+   |      - `Rc::new(())` is later dropped here\n+note: required by a bound in `is_send`\n+  --> $DIR/async-await-let-else.rs:16:15\n+   |\n+LL | fn is_send<T: Send>(_: T) {}\n+   |               ^^^^ required by this bound in `is_send`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/async-await-let-else.rs:49:13\n+   |\n+LL |     is_send(foo3(Some(true)));\n+   |             ^^^^^^^^^^^^^^^^ future returned by `foo3` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-await-let-else.rs:30:28\n+   |\n+LL |         (Rc::new(()), bar().await);\n+   |          -----------       ^^^^^^ await occurs here, with `Rc::new(())` maybe used later\n+   |          |\n+   |          has type `Rc<()>` which is not `Send`\n+note: `Rc::new(())` is later dropped here\n+  --> $DIR/async-await-let-else.rs:30:35\n+   |\n+LL |         (Rc::new(()), bar().await);\n+   |                                   ^\n+note: required by a bound in `is_send`\n+  --> $DIR/async-await-let-else.rs:16:15\n+   |\n+LL | fn is_send<T: Send>(_: T) {}\n+   |               ^^^^ required by this bound in `is_send`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/async-await-let-else.rs:51:13\n+   |\n+LL |     is_send(foo4(Some(true)));\n+   |             ^^^^^^^^^^^^^^^^ future returned by `foo4` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-await-let-else.rs:38:14\n+   |\n+LL |         let r = Rc::new(());\n+   |             - has type `Rc<()>` which is not `Send`\n+LL |         bar().await;\n+   |              ^^^^^^ await occurs here, with `r` maybe used later\n+...\n+LL |     };\n+   |     - `r` is later dropped here\n+note: required by a bound in `is_send`\n+  --> $DIR/async-await-let-else.rs:16:15\n+   |\n+LL | fn is_send<T: Send>(_: T) {}\n+   |               ^^^^ required by this bound in `is_send`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "73b32066fadcd3addb3e6def2ed0b5c390b2b455", "filename": "src/test/ui/layout/unsafe-cell-hides-niche.rs", "status": "modified", "additions": 64, "deletions": 14, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flayout%2Funsafe-cell-hides-niche.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flayout%2Funsafe-cell-hides-niche.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Funsafe-cell-hides-niche.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -3,30 +3,80 @@\n // test checks that an `Option<UnsafeCell<NonZeroU32>>` has the same\n // size in memory as an `Option<UnsafeCell<u32>>` (namely, 8 bytes).\n \n-// run-pass\n+// check-pass\n+// compile-flags: --crate-type=lib\n+// only-x86\n \n-#![feature(no_niche)]\n+#![feature(repr_simd)]\n \n-use std::cell::UnsafeCell;\n+use std::cell::{UnsafeCell, RefCell, Cell};\n use std::mem::size_of;\n use std::num::NonZeroU32 as N32;\n+use std::sync::{Mutex, RwLock};\n \n struct Wrapper<T>(T);\n \n #[repr(transparent)]\n struct Transparent<T>(T);\n \n-#[repr(no_niche)]\n-struct NoNiche<T>(T);\n+struct NoNiche<T>(UnsafeCell<T>);\n \n-fn main() {\n-    assert_eq!(size_of::<Option<Wrapper<u32>>>(),     8);\n-    assert_eq!(size_of::<Option<Wrapper<N32>>>(),     4);\n-    assert_eq!(size_of::<Option<Transparent<u32>>>(), 8);\n-    assert_eq!(size_of::<Option<Transparent<N32>>>(), 4);\n-    assert_eq!(size_of::<Option<NoNiche<u32>>>(),     8);\n-    assert_eq!(size_of::<Option<NoNiche<N32>>>(),     8);\n+struct Size<const S: usize>;\n \n-    assert_eq!(size_of::<Option<UnsafeCell<u32>>>(),  8);\n-    assert_eq!(size_of::<Option<UnsafeCell<N32>>>(),  8);\n+macro_rules! check_sizes {\n+    (check_one_specific_size: $ty:ty, $size:expr) => {\n+        const _: Size::<{$size}> = Size::<{size_of::<$ty>()}>;\n+    };\n+    // Any tests run on `UnsafeCell` must be the same for `Cell`\n+    (UnsafeCell<$ty:ty>: $size:expr => $optioned_size:expr) => {\n+        check_sizes!(Cell<$ty>: $size => $optioned_size);\n+        check_sizes!(@actual_check: UnsafeCell<$ty>: $size => $optioned_size);\n+    };\n+    ($ty:ty: $size:expr => $optioned_size:expr) => {\n+        check_sizes!(@actual_check: $ty: $size => $optioned_size);\n+    };\n+    // This branch does the actual checking logic, the `@actual_check` prefix is here to distinguish\n+    // it from other branches and not accidentally match any.\n+    (@actual_check: $ty:ty: $size:expr => $optioned_size:expr) => {\n+        check_sizes!(check_one_specific_size: $ty, $size);\n+        check_sizes!(check_one_specific_size: Option<$ty>, $optioned_size);\n+        check_sizes!(check_no_niche_opt: $size != $optioned_size, $ty);\n+    };\n+    // only check that there is no niche (size goes up when wrapped in an option),\n+    // don't check actual sizes\n+    ($ty:ty) => {\n+        check_sizes!(check_no_niche_opt: true, $ty);\n+    };\n+    (check_no_niche_opt: $no_niche_opt:expr, $ty:ty) => {\n+        const _: () = if $no_niche_opt { assert!(size_of::<$ty>() < size_of::<Option<$ty>>()); };\n+    };\n }\n+\n+const PTR_SIZE: usize = std::mem::size_of::<*const ()>();\n+\n+check_sizes!(Wrapper<u32>:     4 => 8);\n+check_sizes!(Wrapper<N32>:     4 => 4); // (\u2713 niche opt)\n+check_sizes!(Transparent<u32>: 4 => 8);\n+check_sizes!(Transparent<N32>: 4 => 4); // (\u2713 niche opt)\n+check_sizes!(NoNiche<u32>:     4 => 8);\n+check_sizes!(NoNiche<N32>:     4 => 8);\n+\n+check_sizes!(UnsafeCell<u32>:  4 => 8);\n+check_sizes!(UnsafeCell<N32>:  4 => 8);\n+\n+check_sizes!(UnsafeCell<&()>: PTR_SIZE => PTR_SIZE * 2);\n+check_sizes!(   RefCell<&()>: PTR_SIZE * 2 => PTR_SIZE * 3);\n+\n+check_sizes!(RwLock<&()>);\n+check_sizes!(Mutex<&()>);\n+\n+check_sizes!(UnsafeCell<&[i32]>: PTR_SIZE * 2 => PTR_SIZE * 3);\n+check_sizes!(UnsafeCell<(&(), &())>: PTR_SIZE * 2 => PTR_SIZE * 3);\n+\n+trait Trait {}\n+check_sizes!(UnsafeCell<&dyn Trait>: PTR_SIZE * 2 => PTR_SIZE * 3);\n+\n+#[repr(simd)]\n+pub struct Vec4<T>([T; 4]);\n+\n+check_sizes!(UnsafeCell<Vec4<N32>>: 16 => 32);"}, {"sha": "065787cab08ff65200d12ac52469bb05d39d700f", "filename": "src/test/ui/let-else/let-else-binding-explicit-mut-annotated.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-annotated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-annotated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-annotated.stderr?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/let-else-binding-explicit-mut-annotated.rs:9:37\n    |\n LL |     let Some(n): &mut Option<i32> = &&Some(5i32) else { return };\n-   |                                     ^^^^^^^^^^^^ types differ in mutability\n+   |                  ----------------   ^^^^^^^^^^^^ types differ in mutability\n+   |                  |\n+   |                  expected due to this\n    |\n    = note: expected mutable reference `&mut Option<i32>`\n                       found reference `&&Option<i32>`\n@@ -11,7 +13,9 @@ error[E0308]: mismatched types\n   --> $DIR/let-else-binding-explicit-mut-annotated.rs:13:37\n    |\n LL |     let Some(n): &mut Option<i32> = &&mut Some(5i32) else { return };\n-   |                                     ^^^^^^^^^^^^^^^^ types differ in mutability\n+   |                  ----------------   ^^^^^^^^^^^^^^^^ types differ in mutability\n+   |                  |\n+   |                  expected due to this\n    |\n    = note: expected mutable reference `&mut Option<i32>`\n                       found reference `&&mut Option<i32>`"}, {"sha": "3d647a4c05d86524167bc57b84e279597b8924ed", "filename": "src/test/ui/let-else/let-else-check.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.stderr?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1,8 +1,8 @@\n error: unused variable: `x`\n-  --> $DIR/let-else-check.rs:18:9\n+  --> $DIR/let-else-check.rs:14:13\n    |\n-LL |     let x = 1;\n-   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n+LL |         let x = 1;\n+   |             ^ help: if this is intentional, prefix it with an underscore: `_x`\n    |\n note: the lint level is defined here\n   --> $DIR/let-else-check.rs:3:9\n@@ -11,10 +11,10 @@ LL | #![deny(unused_variables)]\n    |         ^^^^^^^^^^^^^^^^\n \n error: unused variable: `x`\n-  --> $DIR/let-else-check.rs:14:13\n+  --> $DIR/let-else-check.rs:18:9\n    |\n-LL |         let x = 1;\n-   |             ^ help: if this is intentional, prefix it with an underscore: `_x`\n+LL |     let x = 1;\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "05e45f689890d00eb9371766348a90b40927ce90", "filename": "src/test/ui/let-else/let-else-non-diverging.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-diverging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-diverging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-diverging.stderr?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1,8 +1,11 @@\n error[E0308]: `else` clause of `let...else` does not diverge\n-  --> $DIR/let-else-non-diverging.rs:12:32\n+  --> $DIR/let-else-non-diverging.rs:4:32\n    |\n-LL |     let Some(x) = Some(1) else { Some(2) };\n-   |                                ^^^^^^^^^^^ expected `!`, found enum `Option`\n+LL |       let Some(x) = Some(1) else {\n+   |  ________________________________^\n+LL | |         Some(2)\n+LL | |     };\n+   | |_____^ expected `!`, found enum `Option`\n    |\n    = note: expected type `!`\n               found enum `Option<{integer}>`\n@@ -26,13 +29,10 @@ LL | |     };\n    = help: ...or use `match` instead of `let...else`\n \n error[E0308]: `else` clause of `let...else` does not diverge\n-  --> $DIR/let-else-non-diverging.rs:4:32\n+  --> $DIR/let-else-non-diverging.rs:12:32\n    |\n-LL |       let Some(x) = Some(1) else {\n-   |  ________________________________^\n-LL | |         Some(2)\n-LL | |     };\n-   | |_____^ expected `!`, found enum `Option`\n+LL |     let Some(x) = Some(1) else { Some(2) };\n+   |                                ^^^^^^^^^^^ expected `!`, found enum `Option`\n    |\n    = note: expected type `!`\n               found enum `Option<{integer}>`"}, {"sha": "56b9e073330a6237817715f5c4827f70d6f30fad", "filename": "src/test/ui/let-else/let-else-ref-bindings.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -20,7 +20,9 @@ error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:24:34\n    |\n LL |     let Some(a): Option<&[u8]> = some else { return };\n-   |                                  ^^^^ expected `&[u8]`, found struct `Vec`\n+   |                  -------------   ^^^^ expected `&[u8]`, found struct `Vec`\n+   |                  |\n+   |                  expected due to this\n    |\n    = note: expected enum `Option<&[u8]>`\n               found enum `Option<Vec<u8>>`\n@@ -29,7 +31,9 @@ error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:27:34\n    |\n LL |     let Some(a): Option<&[u8]> = &some else { return };\n-   |                                  ^^^^^ expected enum `Option`, found `&Option<Vec<u8>>`\n+   |                  -------------   ^^^^^ expected enum `Option`, found `&Option<Vec<u8>>`\n+   |                  |\n+   |                  expected due to this\n    |\n    = note:   expected enum `Option<&[u8]>`\n            found reference `&Option<Vec<u8>>`\n@@ -56,7 +60,9 @@ error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:52:38\n    |\n LL |     let Some(a): Option<&mut [u8]> = some else { return };\n-   |                                      ^^^^ expected `&mut [u8]`, found struct `Vec`\n+   |                  -----------------   ^^^^ expected `&mut [u8]`, found struct `Vec`\n+   |                  |\n+   |                  expected due to this\n    |\n    = note: expected enum `Option<&mut [u8]>`\n               found enum `Option<Vec<u8>>`\n@@ -65,7 +71,9 @@ error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:55:38\n    |\n LL |     let Some(a): Option<&mut [u8]> = &mut some else { return };\n-   |                                      ^^^^^^^^^ expected enum `Option`, found mutable reference\n+   |                  -----------------   ^^^^^^^^^ expected enum `Option`, found mutable reference\n+   |                  |\n+   |                  expected due to this\n    |\n    = note:           expected enum `Option<&mut [u8]>`\n            found mutable reference `&mut Option<Vec<u8>>`"}, {"sha": "624c2ea37a70bc758a8b08880ba5ebdbe7f70af3", "filename": "src/test/ui/let-else/let-else-temporary-lifetime.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -0,0 +1,25 @@\n+// run-pass\n+#![feature(let_else)]\n+\n+use std::sync::atomic::{AtomicU8, Ordering};\n+\n+static TRACKER: AtomicU8 = AtomicU8::new(0);\n+\n+#[derive(Default)]\n+struct Droppy {\n+    inner: u32,\n+}\n+\n+impl Drop for Droppy {\n+    fn drop(&mut self) {\n+        TRACKER.store(1, Ordering::Release);\n+        println!(\"I've been dropped\");\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(TRACKER.load(Ordering::Acquire), 0);\n+    let 0 = Droppy::default().inner else { return };\n+    assert_eq!(TRACKER.load(Ordering::Acquire), 1);\n+    println!(\"Should have dropped \ud83d\udc46\");\n+}"}, {"sha": "809e0602671febce0af951ec3c6bd0477ea67688", "filename": "src/test/ui/lint/clashing-extern-fn.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1,7 +1,6 @@\n // check-pass\n // aux-build:external_extern_fn.rs\n #![crate_type = \"lib\"]\n-#![feature(no_niche)]\n #![warn(clashing_extern_declarations)]\n \n mod redeclared_different_signature {\n@@ -400,9 +399,8 @@ mod hidden_niche {\n         #[repr(transparent)]\n         struct Transparent { x: NonZeroUsize }\n \n-        #[repr(no_niche)]\n         #[repr(transparent)]\n-        struct TransparentNoNiche { y: NonZeroUsize }\n+        struct TransparentNoNiche { y: UnsafeCell<NonZeroUsize> }\n \n         extern \"C\" {\n             fn hidden_niche_transparent() -> Option<Transparent>;"}, {"sha": "4607f68499322263dd4f85bf93bf4955eb76206b", "filename": "src/test/ui/lint/clashing-extern-fn.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1,5 +1,5 @@\n warning: `clash` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:15:13\n+  --> $DIR/clashing-extern-fn.rs:14:13\n    |\n LL |             fn clash(x: u8);\n    |             ---------------- `clash` previously declared here\n@@ -8,15 +8,15 @@ LL |             fn clash(x: u64);\n    |             ^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n    |\n note: the lint level is defined here\n-  --> $DIR/clashing-extern-fn.rs:5:9\n+  --> $DIR/clashing-extern-fn.rs:4:9\n    |\n LL | #![warn(clashing_extern_declarations)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: expected `unsafe extern \"C\" fn(u8)`\n               found `unsafe extern \"C\" fn(u64)`\n \n warning: `extern_link_name` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:53:9\n+  --> $DIR/clashing-extern-fn.rs:52:9\n    |\n LL | /     #[link_name = \"extern_link_name\"]\n LL | |     fn some_new_name(x: i16);\n@@ -29,7 +29,7 @@ LL |           fn extern_link_name(x: u32);\n               found `unsafe extern \"C\" fn(u32)`\n \n warning: `some_other_extern_link_name` redeclares `some_other_new_name` with a different signature\n-  --> $DIR/clashing-extern-fn.rs:56:9\n+  --> $DIR/clashing-extern-fn.rs:55:9\n    |\n LL |       fn some_other_new_name(x: i16);\n    |       ------------------------------- `some_other_new_name` previously declared here\n@@ -43,7 +43,7 @@ LL | |         fn some_other_extern_link_name(x: u32);\n               found `unsafe extern \"C\" fn(u32)`\n \n warning: `other_both_names_different` redeclares `link_name_same` with a different signature\n-  --> $DIR/clashing-extern-fn.rs:60:9\n+  --> $DIR/clashing-extern-fn.rs:59:9\n    |\n LL | /     #[link_name = \"link_name_same\"]\n LL | |     fn both_names_different(x: i16);\n@@ -58,7 +58,7 @@ LL | |         fn other_both_names_different(x: u32);\n               found `unsafe extern \"C\" fn(u32)`\n \n warning: `different_mod` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:73:9\n+  --> $DIR/clashing-extern-fn.rs:72:9\n    |\n LL |         fn different_mod(x: u8);\n    |         ------------------------ `different_mod` previously declared here\n@@ -70,7 +70,7 @@ LL |         fn different_mod(x: u64);\n               found `unsafe extern \"C\" fn(u64)`\n \n warning: `variadic_decl` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:83:9\n+  --> $DIR/clashing-extern-fn.rs:82:9\n    |\n LL |     fn variadic_decl(x: u8, ...);\n    |     ----------------------------- `variadic_decl` previously declared here\n@@ -82,7 +82,7 @@ LL |         fn variadic_decl(x: u8);\n               found `unsafe extern \"C\" fn(u8)`\n \n warning: `weigh_banana` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:143:13\n+  --> $DIR/clashing-extern-fn.rs:142:13\n    |\n LL |             fn weigh_banana(count: *const Banana) -> u64;\n    |             --------------------------------------------- `weigh_banana` previously declared here\n@@ -94,7 +94,7 @@ LL |             fn weigh_banana(count: *const Banana) -> u64;\n               found `unsafe extern \"C\" fn(*const three::Banana) -> u64`\n \n warning: `draw_point` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:172:13\n+  --> $DIR/clashing-extern-fn.rs:171:13\n    |\n LL |             fn draw_point(p: Point);\n    |             ------------------------ `draw_point` previously declared here\n@@ -106,7 +106,7 @@ LL |             fn draw_point(p: Point);\n               found `unsafe extern \"C\" fn(sameish_members::b::Point)`\n \n warning: `origin` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:198:13\n+  --> $DIR/clashing-extern-fn.rs:197:13\n    |\n LL |             fn origin() -> Point3;\n    |             ---------------------- `origin` previously declared here\n@@ -118,7 +118,7 @@ LL |             fn origin() -> Point3;\n               found `unsafe extern \"C\" fn() -> same_sized_members_clash::b::Point3`\n \n warning: `transparent_incorrect` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:221:13\n+  --> $DIR/clashing-extern-fn.rs:220:13\n    |\n LL |             fn transparent_incorrect() -> T;\n    |             -------------------------------- `transparent_incorrect` previously declared here\n@@ -130,7 +130,7 @@ LL |             fn transparent_incorrect() -> isize;\n               found `unsafe extern \"C\" fn() -> isize`\n \n warning: `missing_return_type` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:239:13\n+  --> $DIR/clashing-extern-fn.rs:238:13\n    |\n LL |             fn missing_return_type() -> usize;\n    |             ---------------------------------- `missing_return_type` previously declared here\n@@ -142,7 +142,7 @@ LL |             fn missing_return_type();\n               found `unsafe extern \"C\" fn()`\n \n warning: `non_zero_usize` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:257:13\n+  --> $DIR/clashing-extern-fn.rs:256:13\n    |\n LL |             fn non_zero_usize() -> core::num::NonZeroUsize;\n    |             ----------------------------------------------- `non_zero_usize` previously declared here\n@@ -154,7 +154,7 @@ LL |             fn non_zero_usize() -> usize;\n               found `unsafe extern \"C\" fn() -> usize`\n \n warning: `non_null_ptr` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:259:13\n+  --> $DIR/clashing-extern-fn.rs:258:13\n    |\n LL |             fn non_null_ptr() -> core::ptr::NonNull<usize>;\n    |             ----------------------------------------------- `non_null_ptr` previously declared here\n@@ -166,7 +166,7 @@ LL |             fn non_null_ptr() -> *const usize;\n               found `unsafe extern \"C\" fn() -> *const usize`\n \n warning: `option_non_zero_usize_incorrect` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:357:13\n+  --> $DIR/clashing-extern-fn.rs:356:13\n    |\n LL |             fn option_non_zero_usize_incorrect() -> usize;\n    |             ---------------------------------------------- `option_non_zero_usize_incorrect` previously declared here\n@@ -178,7 +178,7 @@ LL |             fn option_non_zero_usize_incorrect() -> isize;\n               found `unsafe extern \"C\" fn() -> isize`\n \n warning: `option_non_null_ptr_incorrect` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:359:13\n+  --> $DIR/clashing-extern-fn.rs:358:13\n    |\n LL |             fn option_non_null_ptr_incorrect() -> *const usize;\n    |             --------------------------------------------------- `option_non_null_ptr_incorrect` previously declared here\n@@ -190,7 +190,7 @@ LL |             fn option_non_null_ptr_incorrect() -> *const isize;\n               found `unsafe extern \"C\" fn() -> *const isize`\n \n warning: `hidden_niche_transparent_no_niche` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:410:13\n+  --> $DIR/clashing-extern-fn.rs:408:13\n    |\n LL |             fn hidden_niche_transparent_no_niche() -> usize;\n    |             ------------------------------------------------ `hidden_niche_transparent_no_niche` previously declared here\n@@ -202,7 +202,7 @@ LL |             fn hidden_niche_transparent_no_niche() -> Option<TransparentNoN\n               found `unsafe extern \"C\" fn() -> Option<TransparentNoNiche>`\n \n warning: `hidden_niche_unsafe_cell` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:414:13\n+  --> $DIR/clashing-extern-fn.rs:412:13\n    |\n LL |             fn hidden_niche_unsafe_cell() -> usize;\n    |             --------------------------------------- `hidden_niche_unsafe_cell` previously declared here\n@@ -214,7 +214,7 @@ LL |             fn hidden_niche_unsafe_cell() -> Option<UnsafeCell<NonZeroUsize\n               found `unsafe extern \"C\" fn() -> Option<UnsafeCell<NonZeroUsize>>`\n \n warning: `extern` block uses type `Option<TransparentNoNiche>`, which is not FFI-safe\n-  --> $DIR/clashing-extern-fn.rs:410:55\n+  --> $DIR/clashing-extern-fn.rs:408:55\n    |\n LL |             fn hidden_niche_transparent_no_niche() -> Option<TransparentNoNiche>;\n    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ not FFI-safe\n@@ -224,7 +224,7 @@ LL |             fn hidden_niche_transparent_no_niche() -> Option<TransparentNoN\n    = note: enum has no representation hint\n \n warning: `extern` block uses type `Option<UnsafeCell<NonZeroUsize>>`, which is not FFI-safe\n-  --> $DIR/clashing-extern-fn.rs:414:46\n+  --> $DIR/clashing-extern-fn.rs:412:46\n    |\n LL |             fn hidden_niche_unsafe_cell() -> Option<UnsafeCell<NonZeroUsize>>;\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not FFI-safe"}, {"sha": "77335c64c212093ea59cc6ea39087bfe9adcced0", "filename": "src/test/ui/parser/issues/issue-52496.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-52496.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-52496.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-52496.stderr?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -4,12 +4,13 @@ error: float literals must have an integer part\n LL |     let _ = Foo { bar: .5, baz: 42 };\n    |                        ^^ help: must have an integer part: `0.5`\n \n-error: expected one of `,` or `}`, found `.`\n+error: expected one of `,`, `:`, or `}`, found `.`\n   --> $DIR/issue-52496.rs:8:22\n    |\n LL |     let _ = Foo { bar.into(), bat: -1, . };\n-   |             ---      ^ expected one of `,` or `}`\n-   |             |\n+   |             ---   -  ^ expected one of `,`, `:`, or `}`\n+   |             |     |\n+   |             |     help: try naming a field: `bar:`\n    |             while parsing this struct\n \n error: expected identifier, found `.`"}, {"sha": "4737bc71860c24ef903af60947b32c449d636955", "filename": "src/test/ui/parser/issues/issue-62973.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62973.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62973.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62973.stderr?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -20,15 +20,23 @@ LL |\n LL |\n    |  ^\n \n-error: expected one of `,` or `}`, found `{`\n+error: expected one of `,`, `:`, or `}`, found `{`\n   --> $DIR/issue-62973.rs:6:8\n    |\n LL | fn p() { match s { v, E { [) {) }\n-   |        ^       -       -^ expected one of `,` or `}`\n-   |        |       |       |\n-   |        |       |       help: `}` may belong here\n+   |        ^       -        ^ expected one of `,`, `:`, or `}`\n+   |        |       |\n    |        |       while parsing this struct\n    |        unclosed delimiter\n+   |\n+help: `}` may belong here\n+   |\n+LL | fn p() { match s { v, E} { [) {) }\n+   |                        +\n+help: try naming a field\n+   |\n+LL | fn p() { match s { v, E: E { [) {) }\n+   |                       ++\n \n error: struct literals are not allowed here\n   --> $DIR/issue-62973.rs:6:16"}, {"sha": "451057c66a1277008483768ae886a1e97b63d7c7", "filename": "src/test/ui/parser/removed-syntax-with-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-2.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -6,6 +6,6 @@ fn main() {\n \n     let a = S { foo: (), bar: () };\n     let b = S { foo: (), with a };\n-    //~^ ERROR expected one of `,` or `}`, found `a`\n+    //~^ ERROR expected one of `,`, `:`, or `}`, found `a`\n     //~| ERROR missing field `bar` in initializer of `S`\n }"}, {"sha": "c6ae1ce674ff80467a799bc50c80bcc122a209a0", "filename": "src/test/ui/parser/removed-syntax-with-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-2.stderr?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `,` or `}`, found `a`\n+error: expected one of `,`, `:`, or `}`, found `a`\n   --> $DIR/removed-syntax-with-2.rs:8:31\n    |\n LL |     let b = S { foo: (), with a };\n-   |             -                 ^ expected one of `,` or `}`\n+   |             -                 ^ expected one of `,`, `:`, or `}`\n    |             |\n    |             while parsing this struct\n "}, {"sha": "8872ee7119e4a399bba16b4895b5d6bc6026f4a4", "filename": "src/test/ui/repr/feature-gate-no-niche.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/42bd138126b0a9d38d65bc9973e72de3c5b6c37f/src%2Ftest%2Fui%2Frepr%2Ffeature-gate-no-niche.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42bd138126b0a9d38d65bc9973e72de3c5b6c37f/src%2Ftest%2Fui%2Frepr%2Ffeature-gate-no-niche.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Ffeature-gate-no-niche.rs?ref=42bd138126b0a9d38d65bc9973e72de3c5b6c37f", "patch": "@@ -1,20 +0,0 @@\n-use std::num::NonZeroU8 as N8;\n-use std::num::NonZeroU16 as N16;\n-\n-#[repr(no_niche)]\n-pub struct Cloaked(N16);\n-//~^^ ERROR the attribute `repr(no_niche)` is currently unstable [E0658]\n-\n-#[repr(transparent, no_niche)]\n-pub struct Shadowy(N16);\n-//~^^ ERROR the attribute `repr(no_niche)` is currently unstable [E0658]\n-\n-#[repr(no_niche)]\n-pub enum Cloaked1 { _A(N16), }\n-//~^^ ERROR the attribute `repr(no_niche)` is currently unstable [E0658]\n-\n-#[repr(no_niche)]\n-pub enum Cloaked2 { _A(N16), _B(u8, N8) }\n-//~^^ ERROR the attribute `repr(no_niche)` is currently unstable [E0658]\n-\n-fn main() { }"}, {"sha": "34fd417cc99a2e0c4f7e085cf3b6fe82d4e9f49e", "filename": "src/test/ui/repr/feature-gate-no-niche.stderr", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/42bd138126b0a9d38d65bc9973e72de3c5b6c37f/src%2Ftest%2Fui%2Frepr%2Ffeature-gate-no-niche.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42bd138126b0a9d38d65bc9973e72de3c5b6c37f/src%2Ftest%2Fui%2Frepr%2Ffeature-gate-no-niche.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Ffeature-gate-no-niche.stderr?ref=42bd138126b0a9d38d65bc9973e72de3c5b6c37f", "patch": "@@ -1,35 +0,0 @@\n-error[E0658]: the attribute `repr(no_niche)` is currently unstable\n-  --> $DIR/feature-gate-no-niche.rs:4:8\n-   |\n-LL | #[repr(no_niche)]\n-   |        ^^^^^^^^\n-   |\n-   = help: add `#![feature(no_niche)]` to the crate attributes to enable\n-\n-error[E0658]: the attribute `repr(no_niche)` is currently unstable\n-  --> $DIR/feature-gate-no-niche.rs:8:21\n-   |\n-LL | #[repr(transparent, no_niche)]\n-   |                     ^^^^^^^^\n-   |\n-   = help: add `#![feature(no_niche)]` to the crate attributes to enable\n-\n-error[E0658]: the attribute `repr(no_niche)` is currently unstable\n-  --> $DIR/feature-gate-no-niche.rs:12:8\n-   |\n-LL | #[repr(no_niche)]\n-   |        ^^^^^^^^\n-   |\n-   = help: add `#![feature(no_niche)]` to the crate attributes to enable\n-\n-error[E0658]: the attribute `repr(no_niche)` is currently unstable\n-  --> $DIR/feature-gate-no-niche.rs:16:8\n-   |\n-LL | #[repr(no_niche)]\n-   |        ^^^^^^^^\n-   |\n-   = help: add `#![feature(no_niche)]` to the crate attributes to enable\n-\n-error: aborting due to 4 previous errors\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "870eda89c20d7cd0cb9b4d575287d882e7f3ca2a", "filename": "src/test/ui/repr/repr-no-niche-inapplicable-to-unions.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/42bd138126b0a9d38d65bc9973e72de3c5b6c37f/src%2Ftest%2Fui%2Frepr%2Frepr-no-niche-inapplicable-to-unions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42bd138126b0a9d38d65bc9973e72de3c5b6c37f/src%2Ftest%2Fui%2Frepr%2Frepr-no-niche-inapplicable-to-unions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Frepr-no-niche-inapplicable-to-unions.rs?ref=42bd138126b0a9d38d65bc9973e72de3c5b6c37f", "patch": "@@ -1,14 +0,0 @@\n-#![feature(no_niche)]\n-\n-use std::num::NonZeroU8 as N8;\n-use std::num::NonZeroU16 as N16;\n-\n-#[repr(no_niche)]\n-pub union Cloaked1 { _A: N16 }\n-//~^^ ERROR attribute should be applied to a struct or enum [E0517]\n-\n-#[repr(no_niche)]\n-pub union Cloaked2 { _A: N16, _B: (u8, N8) }\n-//~^^ ERROR attribute should be applied to a struct or enum [E0517]\n-\n-fn main() { }"}, {"sha": "9af929d409473991a78be237f0df950fc9543736", "filename": "src/test/ui/repr/repr-no-niche-inapplicable-to-unions.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42bd138126b0a9d38d65bc9973e72de3c5b6c37f/src%2Ftest%2Fui%2Frepr%2Frepr-no-niche-inapplicable-to-unions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42bd138126b0a9d38d65bc9973e72de3c5b6c37f/src%2Ftest%2Fui%2Frepr%2Frepr-no-niche-inapplicable-to-unions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Frepr-no-niche-inapplicable-to-unions.stderr?ref=42bd138126b0a9d38d65bc9973e72de3c5b6c37f", "patch": "@@ -1,19 +0,0 @@\n-error[E0517]: attribute should be applied to a struct or enum\n-  --> $DIR/repr-no-niche-inapplicable-to-unions.rs:6:8\n-   |\n-LL | #[repr(no_niche)]\n-   |        ^^^^^^^^\n-LL | pub union Cloaked1 { _A: N16 }\n-   | ------------------------------ not a struct or enum\n-\n-error[E0517]: attribute should be applied to a struct or enum\n-  --> $DIR/repr-no-niche-inapplicable-to-unions.rs:10:8\n-   |\n-LL | #[repr(no_niche)]\n-   |        ^^^^^^^^\n-LL | pub union Cloaked2 { _A: N16, _B: (u8, N8) }\n-   | -------------------------------------------- not a struct or enum\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0517`."}, {"sha": "2e6064aeb00744f1e1c620fe8212fed9d3f28a04", "filename": "src/test/ui/repr/repr-no-niche.rs", "status": "removed", "additions": 0, "deletions": 327, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/42bd138126b0a9d38d65bc9973e72de3c5b6c37f/src%2Ftest%2Fui%2Frepr%2Frepr-no-niche.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42bd138126b0a9d38d65bc9973e72de3c5b6c37f/src%2Ftest%2Fui%2Frepr%2Frepr-no-niche.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Frepr-no-niche.rs?ref=42bd138126b0a9d38d65bc9973e72de3c5b6c37f", "patch": "@@ -1,327 +0,0 @@\n-// run-pass\n-\n-// This file tests repr(no_niche), which causes an struct/enum to hide\n-// any niche space that may exist in its internal state from the\n-// context it appears in.\n-\n-// Here are the axes this test is seeking to cover:\n-//\n-// repr annotation:\n-// visible: (); cloaked: (no_niche); transparent: (transparent); shadowy: (transparent, no_niche)\n-//\n-// enum vs struct\n-//\n-// niche-type via type-parameter vs inline declaration\n-\n-#![feature(decl_macro)]\n-#![feature(no_niche)]\n-\n-use std::mem::size_of;\n-use std::num::{NonZeroU8, NonZeroU16};\n-\n-mod struct_inline {\n-    use std::num::NonZeroU16 as N16;\n-\n-    #[derive(Debug)] pub struct Visible(N16);\n-\n-    #[repr(no_niche)]\n-    #[derive(Debug)] pub struct Cloaked(N16);\n-\n-    #[repr(transparent)]\n-    #[derive(Debug)] pub struct Transparent(N16);\n-\n-    #[repr(transparent, no_niche)]\n-    #[derive(Debug)] pub struct Shadowy(N16);\n-}\n-\n-mod struct_param {\n-    #[derive(Debug)] pub struct Visible<T>(T);\n-\n-    #[repr(no_niche)]\n-    #[derive(Debug)] pub struct Cloaked<T>(T);\n-\n-    #[repr(transparent)]\n-    #[derive(Debug)] pub struct Transparent<T>(T);\n-\n-    #[repr(transparent, no_niche)]\n-    #[derive(Debug)] pub struct Shadowy<T>(T);\n-}\n-\n-mod enum_inline {\n-    use crate::two_fifty_six_variant_enum;\n-    use std::num::{NonZeroU8 as N8, NonZeroU16 as N16};\n-\n-    #[derive(Debug)] pub enum Visible1 { _A(N16), }\n-\n-    #[repr(no_niche)]\n-    #[derive(Debug)] pub enum Cloaked1 { _A(N16), }\n-\n-    // (N.B.: transparent enums must be univariant)\n-    #[repr(transparent)]\n-    #[derive(Debug)] pub enum Transparent { _A(N16), }\n-\n-    #[repr(transparent, no_niche)]\n-    #[derive(Debug)] pub enum Shadowy { _A(N16), }\n-\n-    // including multivariant enums for completeness. Payload and\n-    // number of variants (i.e. discriminant size) have been chosen so\n-    // that layout including discriminant is 4 bytes, with no space in\n-    // padding to hide another discrimnant from the surrounding\n-    // context.\n-    //\n-    // (Note that multivariant enums cannot usefully expose a niche in\n-    // general; this test is relying on that.)\n-    two_fifty_six_variant_enum!(Visible2, N8);\n-\n-    two_fifty_six_variant_enum!(#[repr(no_niche)] Cloaked2, N8);\n-}\n-\n-mod enum_param {\n-    use super::two_fifty_six_variant_enum;\n-\n-    #[derive(Debug)] pub enum Visible1<T> { _A(T), }\n-\n-    #[repr(no_niche)]\n-    #[derive(Debug)] pub enum Cloaked1<T> { _A(T), }\n-\n-    // (N.B.: transparent enums must be univariant)\n-    #[repr(transparent)]\n-    #[derive(Debug)] pub enum Transparent<T> { _A(T), }\n-\n-    #[repr(transparent, no_niche)]\n-    #[derive(Debug)] pub enum Shadowy<T> { _A(T), }\n-\n-    // including multivariant enums for completeness. Same notes apply\n-    // here as above (assuming `T` is instantiated with `NonZeroU8`).\n-    two_fifty_six_variant_enum!(Visible2<T>);\n-\n-    two_fifty_six_variant_enum!(#[repr(no_niche)] Cloaked2<T>);\n-}\n-\n-fn main() {\n-    // sanity-checks\n-    assert_eq!(size_of::<struct_inline::Visible>(),               2);\n-    assert_eq!(size_of::<struct_inline::Cloaked>(),               2);\n-    assert_eq!(size_of::<struct_inline::Transparent>(),           2);\n-    assert_eq!(size_of::<struct_inline::Shadowy>(),               2);\n-\n-    assert_eq!(size_of::<struct_param::Visible<NonZeroU16>>(), 2);\n-    assert_eq!(size_of::<struct_param::Cloaked<NonZeroU16>>(), 2);\n-    assert_eq!(size_of::<struct_param::Transparent<NonZeroU16>>(), 2);\n-    assert_eq!(size_of::<struct_param::Shadowy<NonZeroU16>>(), 2);\n-\n-    assert_eq!(size_of::<enum_inline::Visible1>(),    2);\n-    assert_eq!(size_of::<enum_inline::Cloaked1>(),    2);\n-    assert_eq!(size_of::<enum_inline::Transparent>(), 2); // transparent enums are univariant\n-    assert_eq!(size_of::<enum_inline::Shadowy>(),     2);\n-    assert_eq!(size_of::<enum_inline::Visible2>(),    4);\n-    assert_eq!(size_of::<enum_inline::Cloaked2>(),    4);\n-\n-    assert_eq!(size_of::<enum_param::Visible1<NonZeroU16>>(),    2);\n-    assert_eq!(size_of::<enum_param::Cloaked1<NonZeroU16>>(),    2);\n-    assert_eq!(size_of::<enum_param::Transparent<NonZeroU16>>(), 2);\n-    assert_eq!(size_of::<enum_param::Shadowy<NonZeroU16>>(),     2);\n-    assert_eq!(size_of::<enum_param::Visible2<NonZeroU8>>(),     4);\n-    assert_eq!(size_of::<enum_param::Cloaked2<NonZeroU8>>(),     4);\n-\n-    // now the actual tests of no_niche: how do inputs above compose\n-    // with `Option` type constructor. The cases with a `_+2` are the\n-    // ones where no_niche fires.\n-    assert_eq!(size_of::<Option<struct_inline::Visible>>(),       2);\n-    assert_eq!(size_of::<Option<struct_inline::Cloaked>>(),       2+2);\n-    assert_eq!(size_of::<Option<struct_inline::Transparent>>(),   2);\n-    assert_eq!(size_of::<Option<struct_inline::Shadowy>>(),       2+2);\n-\n-    assert_eq!(size_of::<Option<struct_param::Visible<NonZeroU16>>>(),     2);\n-    assert_eq!(size_of::<Option<struct_param::Cloaked<NonZeroU16>>>(),     2+2);\n-    assert_eq!(size_of::<Option<struct_param::Transparent<NonZeroU16>>>(), 2);\n-    assert_eq!(size_of::<Option<struct_param::Shadowy<NonZeroU16>>>(),     2+2);\n-\n-    assert_eq!(size_of::<Option<enum_inline::Visible1>>(),    2);\n-    assert_eq!(size_of::<Option<enum_inline::Cloaked1>>(),    2+2);\n-    assert_eq!(size_of::<Option<enum_inline::Transparent>>(), 2);\n-    assert_eq!(size_of::<Option<enum_inline::Shadowy>>(),     2+2);\n-    // cannot use niche of multivariant payload\n-    assert_eq!(size_of::<Option<enum_inline::Visible2>>(),    4+2);\n-    assert_eq!(size_of::<Option<enum_inline::Cloaked2>>(),    4+2);\n-\n-    assert_eq!(size_of::<Option<enum_param::Visible1<NonZeroU16>>>(),    2);\n-    assert_eq!(size_of::<Option<enum_param::Cloaked1<NonZeroU16>>>(),    2+2);\n-    assert_eq!(size_of::<Option<enum_param::Transparent<NonZeroU16>>>(), 2);\n-    assert_eq!(size_of::<Option<enum_param::Shadowy<NonZeroU16>>>(),     2+2);\n-    // cannot use niche of multivariant payload\n-    assert_eq!(size_of::<Option<enum_param::Visible2<NonZeroU8>>>(),    4+2);\n-    assert_eq!(size_of::<Option<enum_param::Cloaked2<NonZeroU8>>>(),    4+2);\n-}\n-\n-macro two_fifty_six_variant_enum {\n-    ($(#[$attr:meta])* $name:ident<$param:ident>) => {\n-        #[derive(Debug)] $(#[$attr])*\n-        pub enum $name<$param> {\n-            _V00($param, u16), _V01(u16, $param), _V02($param, u16), _V03(u16, $param),\n-            _V04($param, u16), _V05(u16, $param), _V06($param, u16), _V07(u16, $param),\n-            _V08($param, u16), _V09(u16, $param), _V0a($param, u16), _V0b(u16, $param),\n-            _V0c($param, u16), _V0d(u16, $param), _V0e($param, u16), _V0f(u16, $param),\n-\n-            _V10($param, u16), _V11(u16, $param), _V12($param, u16), _V13(u16, $param),\n-            _V14($param, u16), _V15(u16, $param), _V16($param, u16), _V17(u16, $param),\n-            _V18($param, u16), _V19(u16, $param), _V1a($param, u16), _V1b(u16, $param),\n-            _V1c($param, u16), _V1d(u16, $param), _V1e($param, u16), _V1f(u16, $param),\n-\n-            _V20($param, u16), _V21(u16, $param), _V22($param, u16), _V23(u16, $param),\n-            _V24($param, u16), _V25(u16, $param), _V26($param, u16), _V27(u16, $param),\n-            _V28($param, u16), _V29(u16, $param), _V2a($param, u16), _V2b(u16, $param),\n-            _V2c($param, u16), _V2d(u16, $param), _V2e($param, u16), _V2f(u16, $param),\n-\n-            _V30($param, u16), _V31(u16, $param), _V32($param, u16), _V33(u16, $param),\n-            _V34($param, u16), _V35(u16, $param), _V36($param, u16), _V37(u16, $param),\n-            _V38($param, u16), _V39(u16, $param), _V3a($param, u16), _V3b(u16, $param),\n-            _V3c($param, u16), _V3d(u16, $param), _V3e($param, u16), _V3f(u16, $param),\n-\n-            _V40($param, u16), _V41(u16, $param), _V42($param, u16), _V43(u16, $param),\n-            _V44($param, u16), _V45(u16, $param), _V46($param, u16), _V47(u16, $param),\n-            _V48($param, u16), _V49(u16, $param), _V4a($param, u16), _V4b(u16, $param),\n-            _V4c($param, u16), _V4d(u16, $param), _V4e($param, u16), _V4f(u16, $param),\n-\n-            _V50($param, u16), _V51(u16, $param), _V52($param, u16), _V53(u16, $param),\n-            _V54($param, u16), _V55(u16, $param), _V56($param, u16), _V57(u16, $param),\n-            _V58($param, u16), _V59(u16, $param), _V5a($param, u16), _V5b(u16, $param),\n-            _V5c($param, u16), _V5d(u16, $param), _V5e($param, u16), _V5f(u16, $param),\n-\n-            _V60($param, u16), _V61(u16, $param), _V62($param, u16), _V63(u16, $param),\n-            _V64($param, u16), _V65(u16, $param), _V66($param, u16), _V67(u16, $param),\n-            _V68($param, u16), _V69(u16, $param), _V6a($param, u16), _V6b(u16, $param),\n-            _V6c($param, u16), _V6d(u16, $param), _V6e($param, u16), _V6f(u16, $param),\n-\n-            _V70($param, u16), _V71(u16, $param), _V72($param, u16), _V73(u16, $param),\n-            _V74($param, u16), _V75(u16, $param), _V76($param, u16), _V77(u16, $param),\n-            _V78($param, u16), _V79(u16, $param), _V7a($param, u16), _V7b(u16, $param),\n-            _V7c($param, u16), _V7d(u16, $param), _V7e($param, u16), _V7f(u16, $param),\n-\n-            _V80($param, u16), _V81(u16, $param), _V82($param, u16), _V83(u16, $param),\n-            _V84($param, u16), _V85(u16, $param), _V86($param, u16), _V87(u16, $param),\n-            _V88($param, u16), _V89(u16, $param), _V8a($param, u16), _V8b(u16, $param),\n-            _V8c($param, u16), _V8d(u16, $param), _V8e($param, u16), _V8f(u16, $param),\n-\n-            _V90($param, u16), _V91(u16, $param), _V92($param, u16), _V93(u16, $param),\n-            _V94($param, u16), _V95(u16, $param), _V96($param, u16), _V97(u16, $param),\n-            _V98($param, u16), _V99(u16, $param), _V9a($param, u16), _V9b(u16, $param),\n-            _V9c($param, u16), _V9d(u16, $param), _V9e($param, u16), _V9f(u16, $param),\n-\n-            _Va0($param, u16), _Va1(u16, $param), _Va2($param, u16), _Va3(u16, $param),\n-            _Va4($param, u16), _Va5(u16, $param), _Va6($param, u16), _Va7(u16, $param),\n-            _Va8($param, u16), _Va9(u16, $param), _Vaa($param, u16), _Vab(u16, $param),\n-            _Vac($param, u16), _Vad(u16, $param), _Vae($param, u16), _Vaf(u16, $param),\n-\n-            _Vb0($param, u16), _Vb1(u16, $param), _Vb2($param, u16), _Vb3(u16, $param),\n-            _Vb4($param, u16), _Vb5(u16, $param), _Vb6($param, u16), _Vb7(u16, $param),\n-            _Vb8($param, u16), _Vb9(u16, $param), _Vba($param, u16), _Vbb(u16, $param),\n-            _Vbc($param, u16), _Vbd(u16, $param), _Vbe($param, u16), _Vbf(u16, $param),\n-\n-            _Vc0($param, u16), _Vc1(u16, $param), _Vc2($param, u16), _Vc3(u16, $param),\n-            _Vc4($param, u16), _Vc5(u16, $param), _Vc6($param, u16), _Vc7(u16, $param),\n-            _Vc8($param, u16), _Vc9(u16, $param), _Vca($param, u16), _Vcb(u16, $param),\n-            _Vcc($param, u16), _Vcd(u16, $param), _Vce($param, u16), _Vcf(u16, $param),\n-\n-            _Vd0($param, u16), _Vd1(u16, $param), _Vd2($param, u16), _Vd3(u16, $param),\n-            _Vd4($param, u16), _Vd5(u16, $param), _Vd6($param, u16), _Vd7(u16, $param),\n-            _Vd8($param, u16), _Vd9(u16, $param), _Vda($param, u16), _Vdb(u16, $param),\n-            _Vdc($param, u16), _Vdd(u16, $param), _Vde($param, u16), _Vdf(u16, $param),\n-\n-            _Ve0($param, u16), _Ve1(u16, $param), _Ve2($param, u16), _Ve3(u16, $param),\n-            _Ve4($param, u16), _Ve5(u16, $param), _Ve6($param, u16), _Ve7(u16, $param),\n-            _Ve8($param, u16), _Ve9(u16, $param), _Vea($param, u16), _Veb(u16, $param),\n-            _Vec($param, u16), _Ved(u16, $param), _Vee($param, u16), _Vef(u16, $param),\n-\n-            _Vf0($param, u16), _Vf1(u16, $param), _Vf2($param, u16), _Vf3(u16, $param),\n-            _Vf4($param, u16), _Vf5(u16, $param), _Vf6($param, u16), _Vf7(u16, $param),\n-            _Vf8($param, u16), _Vf9(u16, $param), _Vfa($param, u16), _Vfb(u16, $param),\n-            _Vfc($param, u16), _Vfd(u16, $param), _Vfe($param, u16), _Vff(u16, $param),\n-        }\n-    },\n-\n-    ($(#[$attr:meta])* $name:ident, $param:ty) => {\n-        #[derive(Debug)] $(#[$attr])*\n-        pub enum $name {\n-            _V00($param, u16), _V01(u16, $param), _V02($param, u16), _V03(u16, $param),\n-            _V04($param, u16), _V05(u16, $param), _V06($param, u16), _V07(u16, $param),\n-            _V08($param, u16), _V09(u16, $param), _V0a($param, u16), _V0b(u16, $param),\n-            _V0c($param, u16), _V0d(u16, $param), _V0e($param, u16), _V0f(u16, $param),\n-\n-            _V10($param, u16), _V11(u16, $param), _V12($param, u16), _V13(u16, $param),\n-            _V14($param, u16), _V15(u16, $param), _V16($param, u16), _V17(u16, $param),\n-            _V18($param, u16), _V19(u16, $param), _V1a($param, u16), _V1b(u16, $param),\n-            _V1c($param, u16), _V1d(u16, $param), _V1e($param, u16), _V1f(u16, $param),\n-\n-            _V20($param, u16), _V21(u16, $param), _V22($param, u16), _V23(u16, $param),\n-            _V24($param, u16), _V25(u16, $param), _V26($param, u16), _V27(u16, $param),\n-            _V28($param, u16), _V29(u16, $param), _V2a($param, u16), _V2b(u16, $param),\n-            _V2c($param, u16), _V2d(u16, $param), _V2e($param, u16), _V2f(u16, $param),\n-\n-            _V30($param, u16), _V31(u16, $param), _V32($param, u16), _V33(u16, $param),\n-            _V34($param, u16), _V35(u16, $param), _V36($param, u16), _V37(u16, $param),\n-            _V38($param, u16), _V39(u16, $param), _V3a($param, u16), _V3b(u16, $param),\n-            _V3c($param, u16), _V3d(u16, $param), _V3e($param, u16), _V3f(u16, $param),\n-\n-            _V40($param, u16), _V41(u16, $param), _V42($param, u16), _V43(u16, $param),\n-            _V44($param, u16), _V45(u16, $param), _V46($param, u16), _V47(u16, $param),\n-            _V48($param, u16), _V49(u16, $param), _V4a($param, u16), _V4b(u16, $param),\n-            _V4c($param, u16), _V4d(u16, $param), _V4e($param, u16), _V4f(u16, $param),\n-\n-            _V50($param, u16), _V51(u16, $param), _V52($param, u16), _V53(u16, $param),\n-            _V54($param, u16), _V55(u16, $param), _V56($param, u16), _V57(u16, $param),\n-            _V58($param, u16), _V59(u16, $param), _V5a($param, u16), _V5b(u16, $param),\n-            _V5c($param, u16), _V5d(u16, $param), _V5e($param, u16), _V5f(u16, $param),\n-\n-            _V60($param, u16), _V61(u16, $param), _V62($param, u16), _V63(u16, $param),\n-            _V64($param, u16), _V65(u16, $param), _V66($param, u16), _V67(u16, $param),\n-            _V68($param, u16), _V69(u16, $param), _V6a($param, u16), _V6b(u16, $param),\n-            _V6c($param, u16), _V6d(u16, $param), _V6e($param, u16), _V6f(u16, $param),\n-\n-            _V70($param, u16), _V71(u16, $param), _V72($param, u16), _V73(u16, $param),\n-            _V74($param, u16), _V75(u16, $param), _V76($param, u16), _V77(u16, $param),\n-            _V78($param, u16), _V79(u16, $param), _V7a($param, u16), _V7b(u16, $param),\n-            _V7c($param, u16), _V7d(u16, $param), _V7e($param, u16), _V7f(u16, $param),\n-\n-            _V80($param, u16), _V81(u16, $param), _V82($param, u16), _V83(u16, $param),\n-            _V84($param, u16), _V85(u16, $param), _V86($param, u16), _V87(u16, $param),\n-            _V88($param, u16), _V89(u16, $param), _V8a($param, u16), _V8b(u16, $param),\n-            _V8c($param, u16), _V8d(u16, $param), _V8e($param, u16), _V8f(u16, $param),\n-\n-            _V90($param, u16), _V91(u16, $param), _V92($param, u16), _V93(u16, $param),\n-            _V94($param, u16), _V95(u16, $param), _V96($param, u16), _V97(u16, $param),\n-            _V98($param, u16), _V99(u16, $param), _V9a($param, u16), _V9b(u16, $param),\n-            _V9c($param, u16), _V9d(u16, $param), _V9e($param, u16), _V9f(u16, $param),\n-\n-            _Va0($param, u16), _Va1(u16, $param), _Va2($param, u16), _Va3(u16, $param),\n-            _Va4($param, u16), _Va5(u16, $param), _Va6($param, u16), _Va7(u16, $param),\n-            _Va8($param, u16), _Va9(u16, $param), _Vaa($param, u16), _Vab(u16, $param),\n-            _Vac($param, u16), _Vad(u16, $param), _Vae($param, u16), _Vaf(u16, $param),\n-\n-            _Vb0($param, u16), _Vb1(u16, $param), _Vb2($param, u16), _Vb3(u16, $param),\n-            _Vb4($param, u16), _Vb5(u16, $param), _Vb6($param, u16), _Vb7(u16, $param),\n-            _Vb8($param, u16), _Vb9(u16, $param), _Vba($param, u16), _Vbb(u16, $param),\n-            _Vbc($param, u16), _Vbd(u16, $param), _Vbe($param, u16), _Vbf(u16, $param),\n-\n-            _Vc0($param, u16), _Vc1(u16, $param), _Vc2($param, u16), _Vc3(u16, $param),\n-            _Vc4($param, u16), _Vc5(u16, $param), _Vc6($param, u16), _Vc7(u16, $param),\n-            _Vc8($param, u16), _Vc9(u16, $param), _Vca($param, u16), _Vcb(u16, $param),\n-            _Vcc($param, u16), _Vcd(u16, $param), _Vce($param, u16), _Vcf(u16, $param),\n-\n-            _Vd0($param, u16), _Vd1(u16, $param), _Vd2($param, u16), _Vd3(u16, $param),\n-            _Vd4($param, u16), _Vd5(u16, $param), _Vd6($param, u16), _Vd7(u16, $param),\n-            _Vd8($param, u16), _Vd9(u16, $param), _Vda($param, u16), _Vdb(u16, $param),\n-            _Vdc($param, u16), _Vdd(u16, $param), _Vde($param, u16), _Vdf(u16, $param),\n-\n-            _Ve0($param, u16), _Ve1(u16, $param), _Ve2($param, u16), _Ve3(u16, $param),\n-            _Ve4($param, u16), _Ve5(u16, $param), _Ve6($param, u16), _Ve7(u16, $param),\n-            _Ve8($param, u16), _Ve9(u16, $param), _Vea($param, u16), _Veb(u16, $param),\n-            _Vec($param, u16), _Ved(u16, $param), _Vee($param, u16), _Vef(u16, $param),\n-\n-            _Vf0($param, u16), _Vf1(u16, $param), _Vf2($param, u16), _Vf3(u16, $param),\n-            _Vf4($param, u16), _Vf5(u16, $param), _Vf6($param, u16), _Vf7(u16, $param),\n-            _Vf8($param, u16), _Vf9(u16, $param), _Vfa($param, u16), _Vfb(u16, $param),\n-            _Vfc($param, u16), _Vfd(u16, $param), _Vfe($param, u16), _Vff(u16, $param),\n-        }\n-    }\n-}"}, {"sha": "ca617859db49d713ea5fe3ffa4fc0aaa52e0f771", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -11,7 +11,7 @@ use rustc_lint::LateContext;\n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n     let (init, has_trailing_exprs) = match (loop_block.stmts, loop_block.expr) {\n         ([stmt, stmts @ ..], expr) => {\n-            if let StmtKind::Local(&Local { init: Some(e), .. }) | StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind {\n+            if let StmtKind::Local(&Local { init: Some(e), els: None, .. }) | StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind {\n                 (e, !stmts.is_empty() || expr.is_some())\n             } else {\n                 return;"}, {"sha": "3077b999f4ee445f72716412911a1238eb2d4276", "filename": "src/tools/clippy/clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -1041,7 +1041,8 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n-        self.infallible_destructuring_match_linted |= infallible_destructuring_match::check(cx, local);\n+        self.infallible_destructuring_match_linted |=\n+            local.els.is_none() && infallible_destructuring_match::check(cx, local);\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {"}, {"sha": "819646bb6780e98099d405f0a1bd8993de003393", "filename": "src/tools/clippy/clippy_lints/src/no_effect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -92,6 +92,7 @@ fn check_no_effect(cx: &LateContext<'_>, stmt: &Stmt<'_>) -> bool {\n         if_chain! {\n             if !is_lint_allowed(cx, NO_EFFECT_UNDERSCORE_BINDING, local.hir_id);\n             if let Some(init) = local.init;\n+            if local.els.is_none();\n             if !local.pat.span.from_expansion();\n             if has_no_effect(cx, init);\n             if let PatKind::Binding(_, _, ident, _) = local.pat.kind;"}, {"sha": "6bce5fbd4c1fecf24cb1144fa812569186834f26", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -148,7 +148,7 @@ fn is_value_unfrozen_raw<'tcx>(\n         match val.ty().kind() {\n             // the fact that we have to dig into every structs to search enums\n             // leads us to the point checking `UnsafeCell` directly is the only option.\n-            ty::Adt(ty_def, ..) if Some(ty_def.did()) == cx.tcx.lang_items().unsafe_cell_type() => true,\n+            ty::Adt(ty_def, ..) if ty_def.is_unsafe_cell() => true,\n             ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n                 let val = cx.tcx.destructure_mir_constant(cx.param_env, val);\n                 val.fields.iter().any(|field| inner(cx, *field))"}, {"sha": "1d9a2abf7066c8819b61a42faacde644a72eb94a", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -10,7 +10,6 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::Span;\n use rustc_span::sym;\n \n@@ -203,9 +202,7 @@ fn check_final_expr<'tcx>(\n                 check_block_return(cx, ifblock);\n             }\n             if let Some(else_clause) = else_clause_opt {\n-                if expr.span.desugaring_kind() != Some(DesugaringKind::LetElse) {\n-                    check_final_expr(cx, else_clause, None, RetReplacement::Empty);\n-                }\n+                check_final_expr(cx, else_clause, None, RetReplacement::Empty);\n             }\n         },\n         // a match expr, check all arms"}, {"sha": "942f14ddd3d51337637ded33c8dde63aeb84744b", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80dde43f992f3eb419899a34551b84c6301f8e8/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=c80dde43f992f3eb419899a34551b84c6301f8e8", "patch": "@@ -102,7 +102,7 @@ pub struct HirEqInterExpr<'a, 'b, 'tcx> {\n impl HirEqInterExpr<'_, '_, '_> {\n     pub fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n-            (&StmtKind::Local(l), &StmtKind::Local(r)) => {\n+            (&StmtKind::Local(l, ), &StmtKind::Local(r, )) => {\n                 // This additional check ensures that the type of the locals are equivalent even if the init\n                 // expression or type have some inferred parts.\n                 if let Some((typeck_lhs, typeck_rhs)) = self.inner.maybe_typeck_results {\n@@ -117,6 +117,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 // these only get added if the init and type is equal.\n                 both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n                     && both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r))\n+                    && both(&l.els, &r.els, |l, r| self.eq_block(l, r))\n                     && self.eq_pat(l.pat, r.pat)\n             },\n             (&StmtKind::Expr(l), &StmtKind::Expr(r)) | (&StmtKind::Semi(l), &StmtKind::Semi(r)) => self.eq_expr(l, r),\n@@ -921,11 +922,14 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         std::mem::discriminant(&b.kind).hash(&mut self.s);\n \n         match &b.kind {\n-            StmtKind::Local(local) => {\n+            StmtKind::Local(local, ) => {\n                 self.hash_pat(local.pat);\n                 if let Some(init) = local.init {\n                     self.hash_expr(init);\n                 }\n+                if let Some(els) = local.els {\n+                    self.hash_block(els);\n+                }\n             },\n             StmtKind::Item(..) => {},\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => {"}]}