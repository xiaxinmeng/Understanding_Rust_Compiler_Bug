{"sha": "ed2157a38f6ccdfe460f2f058f60a67daac6cc5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMjE1N2EzOGY2Y2NkZmU0NjBmMmYwNThmNjBhNjdkYWFjNmNjNWE=", "commit": {"author": {"name": "Nick Fitzgerald", "email": "fitzgen@gmail.com", "date": "2019-02-07T12:02:27Z"}, "committer": {"name": "Nick Fitzgerald", "email": "fitzgen@gmail.com", "date": "2019-02-07T12:02:27Z"}, "message": "De-duplicate write_prefix lambda in pad_integral\n\nFor smaller code size.", "tree": {"sha": "dfa597e439b48b0a7b26d75ffddfe5709f2e1f24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfa597e439b48b0a7b26d75ffddfe5709f2e1f24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed2157a38f6ccdfe460f2f058f60a67daac6cc5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed2157a38f6ccdfe460f2f058f60a67daac6cc5a", "html_url": "https://github.com/rust-lang/rust/commit/ed2157a38f6ccdfe460f2f058f60a67daac6cc5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed2157a38f6ccdfe460f2f058f60a67daac6cc5a/comments", "author": {"login": "fitzgen", "id": 74571, "node_id": "MDQ6VXNlcjc0NTcx", "avatar_url": "https://avatars.githubusercontent.com/u/74571?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fitzgen", "html_url": "https://github.com/fitzgen", "followers_url": "https://api.github.com/users/fitzgen/followers", "following_url": "https://api.github.com/users/fitzgen/following{/other_user}", "gists_url": "https://api.github.com/users/fitzgen/gists{/gist_id}", "starred_url": "https://api.github.com/users/fitzgen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fitzgen/subscriptions", "organizations_url": "https://api.github.com/users/fitzgen/orgs", "repos_url": "https://api.github.com/users/fitzgen/repos", "events_url": "https://api.github.com/users/fitzgen/events{/privacy}", "received_events_url": "https://api.github.com/users/fitzgen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fitzgen", "id": 74571, "node_id": "MDQ6VXNlcjc0NTcx", "avatar_url": "https://avatars.githubusercontent.com/u/74571?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fitzgen", "html_url": "https://github.com/fitzgen", "followers_url": "https://api.github.com/users/fitzgen/followers", "following_url": "https://api.github.com/users/fitzgen/following{/other_user}", "gists_url": "https://api.github.com/users/fitzgen/gists{/gist_id}", "starred_url": "https://api.github.com/users/fitzgen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fitzgen/subscriptions", "organizations_url": "https://api.github.com/users/fitzgen/orgs", "repos_url": "https://api.github.com/users/fitzgen/repos", "events_url": "https://api.github.com/users/fitzgen/events{/privacy}", "received_events_url": "https://api.github.com/users/fitzgen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da5a0cd69c64e0772960caee32f36b11bca1b498", "url": "https://api.github.com/repos/rust-lang/rust/commits/da5a0cd69c64e0772960caee32f36b11bca1b498", "html_url": "https://github.com/rust-lang/rust/commit/da5a0cd69c64e0772960caee32f36b11bca1b498"}], "stats": {"total": 31, "additions": 20, "deletions": 11}, "files": [{"sha": "dd95e3b4a7ce43e295b096240c41a20ac3d692cd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ed2157a38f6ccdfe460f2f058f60a67daac6cc5a/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed2157a38f6ccdfe460f2f058f60a67daac6cc5a/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=ed2157a38f6ccdfe460f2f058f60a67daac6cc5a", "patch": "@@ -1153,46 +1153,55 @@ impl<'a> Formatter<'a> {\n             sign = Some('+'); width += 1;\n         }\n \n-        let prefixed = self.alternate();\n-        if prefixed {\n+        let prefix = if self.alternate() {\n             width += prefix.chars().count();\n-        }\n+            Some(prefix)\n+        } else {\n+            None\n+        };\n \n         // Writes the sign if it exists, and then the prefix if it was requested\n-        let write_prefix = |f: &mut Formatter| {\n+        #[inline(never)]\n+        fn write_prefix(f: &mut Formatter, sign: Option<char>, prefix: Option<&str>) -> Result {\n             if let Some(c) = sign {\n                 f.buf.write_char(c)?;\n             }\n-            if prefixed { f.buf.write_str(prefix) }\n-            else { Ok(()) }\n-        };\n+            if let Some(prefix) = prefix {\n+                f.buf.write_str(prefix)\n+            } else {\n+                Ok(())\n+            }\n+        }\n \n         // The `width` field is more of a `min-width` parameter at this point.\n         match self.width {\n             // If there's no minimum length requirements then we can just\n             // write the bytes.\n             None => {\n-                write_prefix(self)?; self.buf.write_str(buf)\n+                write_prefix(self, sign, prefix)?;\n+                self.buf.write_str(buf)\n             }\n             // Check if we're over the minimum width, if so then we can also\n             // just write the bytes.\n             Some(min) if width >= min => {\n-                write_prefix(self)?; self.buf.write_str(buf)\n+                write_prefix(self, sign, prefix)?;\n+                self.buf.write_str(buf)\n             }\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n             Some(min) if self.sign_aware_zero_pad() => {\n                 self.fill = '0';\n                 self.align = rt::v1::Alignment::Right;\n-                write_prefix(self)?;\n+                write_prefix(self, sign, prefix)?;\n                 self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n                     f.buf.write_str(buf)\n                 })\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n                 self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n-                    write_prefix(f)?; f.buf.write_str(buf)\n+                    write_prefix(f, sign, prefix)?;\n+                    f.buf.write_str(buf)\n                 })\n             }\n         }"}]}