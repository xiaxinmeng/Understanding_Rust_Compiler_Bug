{"sha": "35c962e9a18e1fc73939990865bfc799e485c23b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1Yzk2MmU5YTE4ZTFmYzczOTM5OTkwODY1YmZjNzk5ZTQ4NWMyM2I=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-19T10:48:45Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-22T08:16:09Z"}, "message": "Pass structural types by pointer, not by value\n\nIf we lose tail calls, this is possible. It simplifies things a lot.\n\nDirect motivation: We want ivecs with pointers pointing into\nthemselves. When copying those, the pointers have to be adjusted. It\nis impossible to this when copying them with Load/Store.", "tree": {"sha": "9e82a9e3690bc3c2110603db2cb7de485e3591f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e82a9e3690bc3c2110603db2cb7de485e3591f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35c962e9a18e1fc73939990865bfc799e485c23b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35c962e9a18e1fc73939990865bfc799e485c23b", "html_url": "https://github.com/rust-lang/rust/commit/35c962e9a18e1fc73939990865bfc799e485c23b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35c962e9a18e1fc73939990865bfc799e485c23b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ad5b71ad91ae23648945733efd162935c392a41", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad5b71ad91ae23648945733efd162935c392a41", "html_url": "https://github.com/rust-lang/rust/commit/6ad5b71ad91ae23648945733efd162935c392a41"}], "stats": {"total": 83, "additions": 38, "deletions": 45}, "files": [{"sha": "aecbe6a05f6f0c7ad5c02063ecbec1622d8521f3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/35c962e9a18e1fc73939990865bfc799e485c23b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c962e9a18e1fc73939990865bfc799e485c23b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=35c962e9a18e1fc73939990865bfc799e485c23b", "patch": "@@ -92,12 +92,14 @@ fn type_of_explicit_args(cx: &@crate_ctxt, sp: &span, inputs: &[ty::arg]) ->\n     let atys: [TypeRef] = [];\n     for arg: ty::arg in inputs {\n         let t: TypeRef = type_of_inner(cx, sp, arg.ty);\n-        t =\n-            alt arg.mode {\n-              ty::mo_alias(_) { T_ptr(t) }\n-              ty::mo_move. { T_ptr(t) }\n-              _ { t }\n-            };\n+        t = alt arg.mode {\n+          ty::mo_alias(_) { T_ptr(t) }\n+          ty::mo_move. { T_ptr(t) }\n+          _ {\n+            if ty::type_is_structural(cx.tcx, arg.ty) { T_ptr(t) }\n+            else { t }\n+          }\n+        };\n         atys += [t];\n     }\n     ret atys;\n@@ -4327,7 +4329,9 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n                     bcx = copy_ty(bcx, val, e_ty).bcx;\n                 } else {\n                     bcx = copy_ty(bcx, val, e_ty).bcx;\n-                    val = bcx.build.Load(val);\n+                    if !ty::type_is_structural(cx.ccx.tcx, e_ty) {\n+                        val = bcx.build.Load(val);\n+                    }\n                 }\n             }\n             llargs += [val];\n@@ -4494,16 +4498,8 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n \n     if !is_bot && ty::type_contains_params(ccx.tcx, arg.ty) {\n         let lldestty = lldestty0;\n-        if arg.mode == ty::mo_val && ty::type_is_structural(ccx.tcx, e_ty) {\n-            lldestty = T_ptr(lldestty);\n-        }\n         val = bcx.build.PointerCast(val, lldestty);\n     }\n-    if arg.mode == ty::mo_val && ty::type_is_structural(ccx.tcx, e_ty) {\n-        // Until here we've been treating structures by pointer;\n-        // we are now passing it as an arg, so need to load it.\n-        val = bcx.build.Load(val);\n-    }\n \n     // Collect arg for later if it happens to be one we've moving out.\n     if arg.mode == ty::mo_move {\n@@ -5821,12 +5817,13 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n     }\n }\n \n-fn copy_args_to_allocas(fcx: @fn_ctxt, args: &[ast::arg]) {\n+fn copy_args_to_allocas(fcx: @fn_ctxt, args: &[ast::arg],\n+                        arg_tys: &[ty::arg]) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n     let arg_n: uint = 0u;\n     for aarg: ast::arg in args {\n         if aarg.mode == ast::val {\n-            let argval;\n+            let argval, arg_ty = arg_tys.(arg_n).ty;\n             alt bcx.fcx.llargs.find(aarg.id) {\n               some(x) { argval = x; }\n               _ {\n@@ -5835,13 +5832,20 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, args: &[ast::arg]) {\n                     \"unbound arg ID in copy_args_to_allocas\");\n               }\n             }\n-            let a = do_spill(bcx, argval);\n+            let a;\n+            if ty::type_is_structural(fcx_tcx(fcx), arg_ty) {\n+                a = alloca(bcx, llvm::LLVMGetElementType(val_ty(argval)));\n+                bcx = memmove_ty(bcx, a, argval, arg_ty).bcx;\n+            } else {\n+                a = do_spill(bcx, argval);\n+            }\n \n             // Overwrite the llargs entry for this arg with its alloca.\n             bcx.fcx.llargs.insert(aarg.id, a);\n         }\n         arg_n += 1u;\n     }\n+    fcx.llcopyargs = bcx.llbb;\n }\n \n fn add_cleanups_for_args(bcx: &@block_ctxt, args: &[ast::arg],\n@@ -5961,7 +5965,7 @@ fn trans_closure(bcx_maybe: &option::t<@block_ctxt>,\n       _ { }\n     }\n     let arg_tys = arg_tys_of_fn(fcx.lcx.ccx, id);\n-    copy_args_to_allocas(fcx, f.decl.inputs);\n+    copy_args_to_allocas(fcx, f.decl.inputs, arg_tys);\n \n     // Figure out if we need to build a closure and act accordingly\n     let res =\n@@ -6115,7 +6119,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         i += 1u;\n     }\n     let arg_tys = arg_tys_of_fn(cx.ccx, variant.node.id);\n-    copy_args_to_allocas(fcx, fn_args);\n+    copy_args_to_allocas(fcx, fn_args, arg_tys);\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n \n@@ -6325,30 +6329,20 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n         let bcx = new_top_block_ctxt(fcx);\n         let lltop = bcx.llbb;\n \n-        if takes_ivec {\n-            let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u);\n-            let lltaskarg = llvm::LLVMGetParam(llfdecl, 1u);\n-            let llenvarg = llvm::LLVMGetParam(llfdecl, 2u);\n-            let llargvarg = llvm::LLVMGetParam(llfdecl, 3u);\n-            let args = [lloutputarg, lltaskarg, llenvarg, llargvarg];\n-            bcx.build.FastCall(main_llfn, args);\n+        let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u);\n+        let lltaskarg = llvm::LLVMGetParam(llfdecl, 1u);\n+        let llenvarg = llvm::LLVMGetParam(llfdecl, 2u);\n+        let llargvarg = llvm::LLVMGetParam(llfdecl, 3u);\n+        let args = if takes_ivec {\n+            ~[lloutputarg, lltaskarg, llenvarg, llargvarg]\n         } else {\n-            let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u);\n-            let lltaskarg = llvm::LLVMGetParam(llfdecl, 1u);\n-            let llenvarg = llvm::LLVMGetParam(llfdecl, 2u);\n-            let llargvarg = llvm::LLVMGetParam(llfdecl, 3u);\n-\n             // If the crate's main function doesn't take the args vector then\n             // we're responsible for freeing it\n-            let llivecptr = alloca(bcx, val_ty(llargvarg));\n-            bcx.build.Store(llargvarg, llivecptr);\n-            bcx =\n-                maybe_free_ivec_heap_part(bcx, llivecptr,\n-                                          ty::mk_str(ccx.tcx)).bcx;\n-\n-            let args = [lloutputarg, lltaskarg, llenvarg];\n-            bcx.build.FastCall(main_llfn, args);\n-        }\n+            bcx = maybe_free_ivec_heap_part(bcx, llargvarg,\n+                                            ty::mk_str(ccx.tcx)).bcx;\n+            ~[lloutputarg, lltaskarg, llenvarg]\n+        };\n+        bcx.build.FastCall(main_llfn, args);\n         build_return(bcx);\n \n         finish_fn(fcx, lltop);"}, {"sha": "06094808fad96a9f616c71f7bdac29da877e7ce3", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35c962e9a18e1fc73939990865bfc799e485c23b/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c962e9a18e1fc73939990865bfc799e485c23b/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=35c962e9a18e1fc73939990865bfc799e485c23b", "patch": "@@ -55,7 +55,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n                               ty::ret_ty_of_fn(ccx.tcx, ctor_id), fn_args,\n                               ty_params);\n     let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n-    copy_args_to_allocas(fcx, fn_args);\n+    copy_args_to_allocas(fcx, fn_args, arg_tys);\n \n     //  Create the first block context in the function and keep a handle on it\n     //  to pass to finish_fn later."}, {"sha": "391f4d8daaf3fab073d7bec26717005c1a00bf2e", "filename": "src/rt/main.ll.in", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35c962e9a18e1fc73939990865bfc799e485c23b/src%2Frt%2Fmain.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/35c962e9a18e1fc73939990865bfc799e485c23b/src%2Frt%2Fmain.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmain.ll.in?ref=35c962e9a18e1fc73939990865bfc799e485c23b", "patch": "@@ -16,12 +16,11 @@\n \n declare i32 @rust_start(i32, i32, i32, i32)\n \n-declare external fastcc void @_rust_main(i1* nocapture, %task*, %2* nocapture, %ivec)\n+declare external fastcc void @_rust_main(i1* nocapture, %task*, %2* nocapture, %ivec*)\n \n define void @_rust_main_wrap(i1* nocapture, %task *, %2* nocapture, %ivec *)\n {\n-  %ivec = load %ivec *%3\n-  tail call fastcc void @_rust_main(i1* %0, %task *%1, %2* nocapture %2, %ivec %ivec)\n+  tail call fastcc void @_rust_main(i1* %0, %task *%1, %2* nocapture %2, %ivec* %3)\n   ret void\n }\n "}]}