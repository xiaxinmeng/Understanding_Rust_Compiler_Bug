{"sha": "500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMGRkYzVlZmRhOWQ0YjBjOGY5MGI2NTRkMjIwZmZjOWUyNGVjYjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-22T12:24:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-22T12:24:55Z"}, "message": "Auto merge of #77871 - Julian-Wollersberger:less-query-context, r=oli-obk\n\nMake fewer types generic over QueryContext\n\nWhile trying to refactor `rustc_query_system::query::QueryContext` to make it dyn-safe, I noticed some smaller things:\n* QueryConfig doesn't need to be generic over QueryContext\n* ~~The `kind` field on QueryJobId is unused~~\n* Some unnecessary where clauses\n* Many types in `job.rs` where generic over `QueryContext` but only needed `QueryContext::Query`.\n  If handle_cycle_error() could be refactored to not take `error: CycleError<CTX::Query>`, all those bounds could be removed as well.\n\nChanging `find_cycle_in_stack()` in job.rs to not take a `tcx` argument is the only functional change here. Everything else is just updating type signatures. (aka compile-error driven development ^^)\n\n~~Currently there is a weird bug where memory usage suddenly skyrockets when running UI tests. I'll investigate that tomorrow.\nA perf run probably won't make sense before that is fixed.~~\n\nEDIT: `kind` actually is used by `Eq`, and re-adding it fixed the memory issue.", "tree": {"sha": "1854af90761b22499a97c27be2d3100aedfa97df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1854af90761b22499a97c27be2d3100aedfa97df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "html_url": "https://github.com/rust-lang/rust/commit/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b9fbf212a06944ff23325d2d63215805dc3c6c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b9fbf212a06944ff23325d2d63215805dc3c6c3", "html_url": "https://github.com/rust-lang/rust/commit/6b9fbf212a06944ff23325d2d63215805dc3c6c3"}, {"sha": "52cedcab9221bd63a67f4de4cd9c577518ed0d3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/52cedcab9221bd63a67f4de4cd9c577518ed0d3b", "html_url": "https://github.com/rust-lang/rust/commit/52cedcab9221bd63a67f4de4cd9c577518ed0d3b"}], "stats": {"total": 390, "additions": 216, "deletions": 174}, "files": [{"sha": "1a8aacc4869862b8a0543a88f2a7d4df688e867f", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "patch": "@@ -40,7 +40,8 @@ impl QueryContext for TyCtxt<'tcx> {\n \n     fn try_collect_active_jobs(\n         &self,\n-    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self>>> {\n+    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self::DepKind, Self::Query>>>\n+    {\n         self.queries.try_collect_active_jobs()\n     }\n \n@@ -353,7 +354,7 @@ macro_rules! define_queries_inner {\n             $(pub type $name<$tcx> = $V;)*\n         }\n \n-        $(impl<$tcx> QueryConfig<TyCtxt<$tcx>> for queries::$name<$tcx> {\n+        $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n             type Key = $($K)*;\n             type Value = $V;\n             type Stored = <\n@@ -372,7 +373,7 @@ macro_rules! define_queries_inner {\n             type Cache = query_storage!([$($modifiers)*][$($K)*, $V]);\n \n             #[inline(always)]\n-            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<TyCtxt<$tcx>, Self::Cache> {\n+            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<crate::dep_graph::DepKind, <TyCtxt<$tcx> as QueryContext>::Query, Self::Cache> {\n                 &tcx.queries.$name\n             }\n \n@@ -454,7 +455,7 @@ macro_rules! define_queries_inner {\n             #[inline(always)]\n             #[must_use]\n             pub fn $name(self, key: query_helper_param_ty!($($K)*))\n-                -> <queries::$name<$tcx> as QueryConfig<TyCtxt<$tcx>>>::Stored\n+                -> <queries::$name<$tcx> as QueryConfig>::Stored\n             {\n                 self.at(DUMMY_SP).$name(key.into_query_param())\n             })*\n@@ -493,7 +494,7 @@ macro_rules! define_queries_inner {\n             $($(#[$attr])*\n             #[inline(always)]\n             pub fn $name(self, key: query_helper_param_ty!($($K)*))\n-                -> <queries::$name<$tcx> as QueryConfig<TyCtxt<$tcx>>>::Stored\n+                -> <queries::$name<$tcx> as QueryConfig>::Stored\n             {\n                 get_query::<queries::$name<'_>, _>(self.tcx, self.span, key.into_query_param())\n             })*\n@@ -527,7 +528,8 @@ macro_rules! define_queries_struct {\n             fallback_extern_providers: Box<Providers>,\n \n             $($(#[$attr])*  $name: QueryState<\n-                TyCtxt<$tcx>,\n+                crate::dep_graph::DepKind,\n+                <TyCtxt<$tcx> as QueryContext>::Query,\n                 <queries::$name<$tcx> as QueryAccessors<TyCtxt<'tcx>>>::Cache,\n             >,)*\n         }\n@@ -548,7 +550,7 @@ macro_rules! define_queries_struct {\n \n             pub(crate) fn try_collect_active_jobs(\n                 &self\n-            ) -> Option<FxHashMap<QueryJobId<crate::dep_graph::DepKind>, QueryJobInfo<TyCtxt<'tcx>>>> {\n+            ) -> Option<FxHashMap<QueryJobId<crate::dep_graph::DepKind>, QueryJobInfo<crate::dep_graph::DepKind, <TyCtxt<$tcx> as QueryContext>::Query>>> {\n                 let mut jobs = FxHashMap::default();\n \n                 $("}, {"sha": "cbcecb88491888ee786862bf085cf0f7fb206fd0", "filename": "compiler/rustc_middle/src/ty/query/profiling_support.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fprofiling_support.rs?ref=500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "patch": "@@ -5,8 +5,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfiler;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n-use rustc_query_system::query::QueryCache;\n-use rustc_query_system::query::QueryState;\n+use rustc_query_system::query::{QueryCache, QueryContext, QueryState};\n use std::fmt::Debug;\n use std::io::Write;\n \n@@ -231,7 +230,7 @@ where\n pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n     tcx: TyCtxt<'tcx>,\n     query_name: &'static str,\n-    query_state: &QueryState<TyCtxt<'tcx>, C>,\n+    query_state: &QueryState<crate::dep_graph::DepKind, <TyCtxt<'tcx> as QueryContext>::Query, C>,\n     string_cache: &mut QueryKeyStringCache,\n ) where\n     C: QueryCache,"}, {"sha": "877f88d380a39848cdb17be7277a7d68fee805a3", "filename": "compiler/rustc_middle/src/ty/query/stats.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs?ref=500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "patch": "@@ -1,11 +1,10 @@\n use crate::ty::query::queries;\n use crate::ty::TyCtxt;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_query_system::query::QueryCache;\n-use rustc_query_system::query::QueryState;\n-use rustc_query_system::query::{QueryAccessors, QueryContext};\n+use rustc_query_system::query::{QueryAccessors, QueryCache, QueryContext, QueryState};\n \n use std::any::type_name;\n+use std::hash::Hash;\n use std::mem;\n #[cfg(debug_assertions)]\n use std::sync::atomic::Ordering;\n@@ -38,10 +37,12 @@ struct QueryStats {\n     local_def_id_keys: Option<usize>,\n }\n \n-fn stats<CTX: QueryContext, C: QueryCache>(\n-    name: &'static str,\n-    map: &QueryState<CTX, C>,\n-) -> QueryStats {\n+fn stats<D, Q, C>(name: &'static str, map: &QueryState<D, Q, C>) -> QueryStats\n+where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+    C: QueryCache,\n+{\n     let mut stats = QueryStats {\n         name,\n         #[cfg(debug_assertions)]\n@@ -127,7 +128,8 @@ macro_rules! print_stats {\n \n             $($(\n                 queries.push(stats::<\n-                    TyCtxt<'_>,\n+                    crate::dep_graph::DepKind,\n+                    <TyCtxt<'_> as QueryContext>::Query,\n                     <queries::$name<'_> as QueryAccessors<TyCtxt<'_>>>::Cache,\n                 >(\n                     stringify!($name),"}, {"sha": "7bc6ae1d1c6c3ecdde83f4b2f57de6879134bac2", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "patch": "@@ -1,12 +1,12 @@\n use crate::dep_graph::DepNodeIndex;\n use crate::query::plumbing::{QueryLookup, QueryState};\n-use crate::query::QueryContext;\n \n use rustc_arena::TypedArena;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::sync::WorkerLocal;\n use std::default::Default;\n+use std::fmt::Debug;\n use std::hash::Hash;\n use std::marker::PhantomData;\n \n@@ -24,24 +24,24 @@ pub trait QueryStorage: Default {\n }\n \n pub trait QueryCache: QueryStorage {\n-    type Key: Hash;\n+    type Key: Hash + Eq + Clone + Debug;\n     type Sharded: Default;\n \n     /// Checks if the query is already computed and in the cache.\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n-    fn lookup<CTX: QueryContext, R, OnHit, OnMiss>(\n+    fn lookup<D, Q, R, OnHit, OnMiss>(\n         &self,\n-        state: &QueryState<CTX, Self>,\n+        state: &QueryState<D, Q, Self>,\n         key: Self::Key,\n         // `on_hit` can be called while holding a lock to the query state shard.\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n         OnHit: FnOnce(&Self::Stored, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(Self::Key, QueryLookup<'_, CTX, Self::Key, Self::Sharded>) -> R;\n+        OnMiss: FnOnce(Self::Key, QueryLookup<'_, D, Q, Self::Key, Self::Sharded>) -> R;\n \n     fn complete(\n         &self,\n@@ -86,21 +86,25 @@ impl<K: Eq + Hash, V: Clone> QueryStorage for DefaultCache<K, V> {\n     }\n }\n \n-impl<K: Eq + Hash, V: Clone> QueryCache for DefaultCache<K, V> {\n+impl<K, V> QueryCache for DefaultCache<K, V>\n+where\n+    K: Eq + Hash + Clone + Debug,\n+    V: Clone,\n+{\n     type Key = K;\n     type Sharded = FxHashMap<K, (V, DepNodeIndex)>;\n \n     #[inline(always)]\n-    fn lookup<CTX: QueryContext, R, OnHit, OnMiss>(\n+    fn lookup<D, Q, R, OnHit, OnMiss>(\n         &self,\n-        state: &QueryState<CTX, Self>,\n+        state: &QueryState<D, Q, Self>,\n         key: K,\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n         OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'_, CTX, K, Self::Sharded>) -> R,\n+        OnMiss: FnOnce(K, QueryLookup<'_, D, Q, K, Self::Sharded>) -> R,\n     {\n         let mut lookup = state.get_lookup(&key);\n         let lock = &mut *lookup.lock;\n@@ -164,21 +168,24 @@ impl<'tcx, K: Eq + Hash, V: 'tcx> QueryStorage for ArenaCache<'tcx, K, V> {\n     }\n }\n \n-impl<'tcx, K: Eq + Hash, V: 'tcx> QueryCache for ArenaCache<'tcx, K, V> {\n+impl<'tcx, K, V: 'tcx> QueryCache for ArenaCache<'tcx, K, V>\n+where\n+    K: Eq + Hash + Clone + Debug,\n+{\n     type Key = K;\n     type Sharded = FxHashMap<K, &'tcx (V, DepNodeIndex)>;\n \n     #[inline(always)]\n-    fn lookup<CTX: QueryContext, R, OnHit, OnMiss>(\n+    fn lookup<D, Q, R, OnHit, OnMiss>(\n         &self,\n-        state: &QueryState<CTX, Self>,\n+        state: &QueryState<D, Q, Self>,\n         key: K,\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n         OnHit: FnOnce(&&'tcx V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'_, CTX, K, Self::Sharded>) -> R,\n+        OnMiss: FnOnce(K, QueryLookup<'_, D, Q, K, Self::Sharded>) -> R,\n     {\n         let mut lookup = state.get_lookup(&key);\n         let lock = &mut *lookup.lock;"}, {"sha": "6c9849e8708b74d73dc3195bd46dfb311fe209da", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "patch": "@@ -12,9 +12,7 @@ use std::borrow::Cow;\n use std::fmt::Debug;\n use std::hash::Hash;\n \n-// The parameter `CTX` is required in librustc_middle:\n-// implementations may need to access the `'tcx` lifetime in `CTX = TyCtxt<'tcx>`.\n-pub trait QueryConfig<CTX> {\n+pub trait QueryConfig {\n     const NAME: &'static str;\n     const CATEGORY: ProfileCategory;\n \n@@ -70,15 +68,15 @@ impl<CTX: QueryContext, K, V> QueryVtable<CTX, K, V> {\n     }\n }\n \n-pub trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {\n+pub trait QueryAccessors<CTX: QueryContext>: QueryConfig {\n     const ANON: bool;\n     const EVAL_ALWAYS: bool;\n     const DEP_KIND: CTX::DepKind;\n \n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX, Self::Cache>;\n+    fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX::DepKind, CTX::Query, Self::Cache>;\n \n     fn to_dep_node(tcx: CTX, key: &Self::Key) -> DepNode<CTX::DepKind>\n     where"}, {"sha": "c1d3210b61768308ca310fc8f201a9c8ea23b4f6", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 98, "deletions": 72, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "patch": "@@ -1,16 +1,16 @@\n-use crate::dep_graph::{DepContext, DepKind};\n use crate::query::plumbing::CycleError;\n-use crate::query::QueryContext;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_span::Span;\n \n use std::convert::TryFrom;\n+use std::hash::Hash;\n use std::marker::PhantomData;\n use std::num::NonZeroU32;\n \n #[cfg(parallel_compiler)]\n use {\n+    super::QueryContext,\n     parking_lot::{Condvar, Mutex},\n     rustc_data_structures::fx::FxHashSet,\n     rustc_data_structures::stable_hasher::{HashStable, StableHasher},\n@@ -31,79 +31,83 @@ pub struct QueryInfo<Q> {\n     pub query: Q,\n }\n \n-type QueryMap<CTX> = FxHashMap<QueryJobId<<CTX as DepContext>::DepKind>, QueryJobInfo<CTX>>;\n+pub(crate) type QueryMap<D, Q> = FxHashMap<QueryJobId<D>, QueryJobInfo<D, Q>>;\n \n /// A value uniquely identifiying an active query job within a shard in the query cache.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n pub struct QueryShardJobId(pub NonZeroU32);\n \n /// A value uniquely identifiying an active query job.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n-pub struct QueryJobId<K> {\n+pub struct QueryJobId<D> {\n     /// Which job within a shard is this\n     pub job: QueryShardJobId,\n \n     /// In which shard is this job\n     pub shard: u16,\n \n-    /// What kind of query this job is\n-    pub kind: K,\n+    /// What kind of query this job is.\n+    pub kind: D,\n }\n \n-impl<K: DepKind> QueryJobId<K> {\n-    pub fn new(job: QueryShardJobId, shard: usize, kind: K) -> Self {\n+impl<D> QueryJobId<D>\n+where\n+    D: Copy + Clone + Eq + Hash,\n+{\n+    pub fn new(job: QueryShardJobId, shard: usize, kind: D) -> Self {\n         QueryJobId { job, shard: u16::try_from(shard).unwrap(), kind }\n     }\n \n-    fn query<CTX: QueryContext<DepKind = K>>(self, map: &QueryMap<CTX>) -> CTX::Query {\n+    fn query<Q: Clone>(self, map: &QueryMap<D, Q>) -> Q {\n         map.get(&self).unwrap().info.query.clone()\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn span<CTX: QueryContext<DepKind = K>>(self, map: &QueryMap<CTX>) -> Span {\n+    fn span<Q: Clone>(self, map: &QueryMap<D, Q>) -> Span {\n         map.get(&self).unwrap().job.span\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn parent<CTX: QueryContext<DepKind = K>>(self, map: &QueryMap<CTX>) -> Option<QueryJobId<K>> {\n+    fn parent<Q: Clone>(self, map: &QueryMap<D, Q>) -> Option<QueryJobId<D>> {\n         map.get(&self).unwrap().job.parent\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn latch<'a, CTX: QueryContext<DepKind = K>>(\n-        self,\n-        map: &'a QueryMap<CTX>,\n-    ) -> Option<&'a QueryLatch<CTX>> {\n+    fn latch<'a, Q: Clone>(self, map: &'a QueryMap<D, Q>) -> Option<&'a QueryLatch<D, Q>> {\n         map.get(&self).unwrap().job.latch.as_ref()\n     }\n }\n \n-pub struct QueryJobInfo<CTX: QueryContext> {\n-    pub info: QueryInfo<CTX::Query>,\n-    pub job: QueryJob<CTX>,\n+pub struct QueryJobInfo<D, Q> {\n+    pub info: QueryInfo<Q>,\n+    pub job: QueryJob<D, Q>,\n }\n \n /// Represents an active query job.\n #[derive(Clone)]\n-pub struct QueryJob<CTX: QueryContext> {\n+pub struct QueryJob<D, Q> {\n     pub id: QueryShardJobId,\n \n     /// The span corresponding to the reason for which this query was required.\n     pub span: Span,\n \n     /// The parent query job which created this job and is implicitly waiting on it.\n-    pub parent: Option<QueryJobId<CTX::DepKind>>,\n+    pub parent: Option<QueryJobId<D>>,\n \n     /// The latch that is used to wait on this job.\n     #[cfg(parallel_compiler)]\n-    latch: Option<QueryLatch<CTX>>,\n+    latch: Option<QueryLatch<D, Q>>,\n \n-    dummy: PhantomData<QueryLatch<CTX>>,\n+    dummy: PhantomData<QueryLatch<D, Q>>,\n }\n \n-impl<CTX: QueryContext> QueryJob<CTX> {\n+impl<D, Q> QueryJob<D, Q>\n+where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+{\n     /// Creates a new query job.\n-    pub fn new(id: QueryShardJobId, span: Span, parent: Option<QueryJobId<CTX::DepKind>>) -> Self {\n+    pub fn new(id: QueryShardJobId, span: Span, parent: Option<QueryJobId<D>>) -> Self {\n         QueryJob {\n             id,\n             span,\n@@ -115,15 +119,15 @@ impl<CTX: QueryContext> QueryJob<CTX> {\n     }\n \n     #[cfg(parallel_compiler)]\n-    pub(super) fn latch(&mut self, _id: QueryJobId<CTX::DepKind>) -> QueryLatch<CTX> {\n+    pub(super) fn latch(&mut self, _id: QueryJobId<D>) -> QueryLatch<D, Q> {\n         if self.latch.is_none() {\n             self.latch = Some(QueryLatch::new());\n         }\n         self.latch.as_ref().unwrap().clone()\n     }\n \n     #[cfg(not(parallel_compiler))]\n-    pub(super) fn latch(&mut self, id: QueryJobId<CTX::DepKind>) -> QueryLatch<CTX> {\n+    pub(super) fn latch(&mut self, id: QueryJobId<D>) -> QueryLatch<D, Q> {\n         QueryLatch { id, dummy: PhantomData }\n     }\n \n@@ -143,19 +147,26 @@ impl<CTX: QueryContext> QueryJob<CTX> {\n \n #[cfg(not(parallel_compiler))]\n #[derive(Clone)]\n-pub(super) struct QueryLatch<CTX: QueryContext> {\n-    id: QueryJobId<CTX::DepKind>,\n-    dummy: PhantomData<CTX>,\n+pub(super) struct QueryLatch<D, Q> {\n+    id: QueryJobId<D>,\n+    dummy: PhantomData<Q>,\n }\n \n #[cfg(not(parallel_compiler))]\n-impl<CTX: QueryContext> QueryLatch<CTX> {\n-    pub(super) fn find_cycle_in_stack(&self, tcx: CTX, span: Span) -> CycleError<CTX::Query> {\n-        let query_map = tcx.try_collect_active_jobs().unwrap();\n-\n-        // Get the current executing query (waiter) and find the waitee amongst its parents\n-        let mut current_job = tcx.current_query_job();\n+impl<D, Q> QueryLatch<D, Q>\n+where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+{\n+    pub(super) fn find_cycle_in_stack(\n+        &self,\n+        query_map: QueryMap<D, Q>,\n+        current_job: &Option<QueryJobId<D>>,\n+        span: Span,\n+    ) -> CycleError<Q> {\n+        // Find the waitee amongst `current_job` parents\n         let mut cycle = Vec::new();\n+        let mut current_job = Option::clone(current_job);\n \n         while let Some(job) = current_job {\n             let info = query_map.get(&job).unwrap();\n@@ -186,35 +197,35 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryWaiter<CTX: QueryContext> {\n-    query: Option<QueryJobId<CTX::DepKind>>,\n+struct QueryWaiter<D, Q> {\n+    query: Option<QueryJobId<D>>,\n     condvar: Condvar,\n     span: Span,\n-    cycle: Lock<Option<CycleError<CTX::Query>>>,\n+    cycle: Lock<Option<CycleError<Q>>>,\n }\n \n #[cfg(parallel_compiler)]\n-impl<CTX: QueryContext> QueryWaiter<CTX> {\n+impl<D, Q> QueryWaiter<D, Q> {\n     fn notify(&self, registry: &rayon_core::Registry) {\n         rayon_core::mark_unblocked(registry);\n         self.condvar.notify_one();\n     }\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryLatchInfo<CTX: QueryContext> {\n+struct QueryLatchInfo<D, Q> {\n     complete: bool,\n-    waiters: Vec<Lrc<QueryWaiter<CTX>>>,\n+    waiters: Vec<Lrc<QueryWaiter<D, Q>>>,\n }\n \n #[cfg(parallel_compiler)]\n #[derive(Clone)]\n-pub(super) struct QueryLatch<CTX: QueryContext> {\n-    info: Lrc<Mutex<QueryLatchInfo<CTX>>>,\n+pub(super) struct QueryLatch<D, Q> {\n+    info: Lrc<Mutex<QueryLatchInfo<D, Q>>>,\n }\n \n #[cfg(parallel_compiler)]\n-impl<CTX: QueryContext> QueryLatch<CTX> {\n+impl<D: Eq + Hash, Q: Clone> QueryLatch<D, Q> {\n     fn new() -> Self {\n         QueryLatch {\n             info: Lrc::new(Mutex::new(QueryLatchInfo { complete: false, waiters: Vec::new() })),\n@@ -223,10 +234,13 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n }\n \n #[cfg(parallel_compiler)]\n-impl<CTX: QueryContext> QueryLatch<CTX> {\n+impl<D, Q> QueryLatch<D, Q> {\n     /// Awaits for the query job to complete.\n-    pub(super) fn wait_on(&self, tcx: CTX, span: Span) -> Result<(), CycleError<CTX::Query>> {\n-        let query = tcx.current_query_job();\n+    pub(super) fn wait_on(\n+        &self,\n+        query: Option<QueryJobId<D>>,\n+        span: Span,\n+    ) -> Result<(), CycleError<Q>> {\n         let waiter =\n             Lrc::new(QueryWaiter { query, span, cycle: Lock::new(None), condvar: Condvar::new() });\n         self.wait_on_inner(&waiter);\n@@ -239,12 +253,9 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n             Some(cycle) => Err(cycle),\n         }\n     }\n-}\n \n-#[cfg(parallel_compiler)]\n-impl<CTX: QueryContext> QueryLatch<CTX> {\n     /// Awaits the caller on this latch by blocking the current thread.\n-    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter<CTX>>) {\n+    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter<D, Q>>) {\n         let mut info = self.info.lock();\n         if !info.complete {\n             // We push the waiter on to the `waiters` list. It can be accessed inside\n@@ -278,7 +289,7 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n \n     /// Removes a single waiter from the list of waiters.\n     /// This is used to break query cycles.\n-    fn extract_waiter(&self, waiter: usize) -> Lrc<QueryWaiter<CTX>> {\n+    fn extract_waiter(&self, waiter: usize) -> Lrc<QueryWaiter<D, Q>> {\n         let mut info = self.info.lock();\n         debug_assert!(!info.complete);\n         // Remove the waiter from the list of waiters\n@@ -288,7 +299,7 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n \n /// A resumable waiter of a query. The usize is the index into waiters in the query's latch\n #[cfg(parallel_compiler)]\n-type Waiter<K> = (QueryJobId<K>, usize);\n+type Waiter<D> = (QueryJobId<D>, usize);\n \n /// Visits all the non-resumable and resumable waiters of a query.\n /// Only waiters in a query are visited.\n@@ -300,13 +311,15 @@ type Waiter<K> = (QueryJobId<K>, usize);\n /// required information to resume the waiter.\n /// If all `visit` calls returns None, this function also returns None.\n #[cfg(parallel_compiler)]\n-fn visit_waiters<CTX: QueryContext, F>(\n-    query_map: &QueryMap<CTX>,\n-    query: QueryJobId<CTX::DepKind>,\n+fn visit_waiters<D, Q, F>(\n+    query_map: &QueryMap<D, Q>,\n+    query: QueryJobId<D>,\n     mut visit: F,\n-) -> Option<Option<Waiter<CTX::DepKind>>>\n+) -> Option<Option<Waiter<D>>>\n where\n-    F: FnMut(Span, QueryJobId<CTX::DepKind>) -> Option<Option<Waiter<CTX::DepKind>>>,\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+    F: FnMut(Span, QueryJobId<D>) -> Option<Option<Waiter<D>>>,\n {\n     // Visit the parent query which is a non-resumable waiter since it's on the same stack\n     if let Some(parent) = query.parent(query_map) {\n@@ -335,13 +348,17 @@ where\n /// If a cycle is detected, this initial value is replaced with the span causing\n /// the cycle.\n #[cfg(parallel_compiler)]\n-fn cycle_check<CTX: QueryContext>(\n-    query_map: &QueryMap<CTX>,\n-    query: QueryJobId<CTX::DepKind>,\n+fn cycle_check<D, Q>(\n+    query_map: &QueryMap<D, Q>,\n+    query: QueryJobId<D>,\n     span: Span,\n-    stack: &mut Vec<(Span, QueryJobId<CTX::DepKind>)>,\n-    visited: &mut FxHashSet<QueryJobId<CTX::DepKind>>,\n-) -> Option<Option<Waiter<CTX::DepKind>>> {\n+    stack: &mut Vec<(Span, QueryJobId<D>)>,\n+    visited: &mut FxHashSet<QueryJobId<D>>,\n+) -> Option<Option<Waiter<D>>>\n+where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+{\n     if !visited.insert(query) {\n         return if let Some(p) = stack.iter().position(|q| q.1 == query) {\n             // We detected a query cycle, fix up the initial span and return Some\n@@ -376,11 +393,15 @@ fn cycle_check<CTX: QueryContext>(\n /// from `query` without going through any of the queries in `visited`.\n /// This is achieved with a depth first search.\n #[cfg(parallel_compiler)]\n-fn connected_to_root<CTX: QueryContext>(\n-    query_map: &QueryMap<CTX>,\n-    query: QueryJobId<CTX::DepKind>,\n-    visited: &mut FxHashSet<QueryJobId<CTX::DepKind>>,\n-) -> bool {\n+fn connected_to_root<D, Q>(\n+    query_map: &QueryMap<D, Q>,\n+    query: QueryJobId<D>,\n+    visited: &mut FxHashSet<QueryJobId<D>>,\n+) -> bool\n+where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+{\n     // We already visited this or we're deliberately ignoring it\n     if !visited.insert(query) {\n         return false;\n@@ -399,7 +420,12 @@ fn connected_to_root<CTX: QueryContext>(\n \n // Deterministically pick an query from a list\n #[cfg(parallel_compiler)]\n-fn pick_query<'a, CTX, T, F>(query_map: &QueryMap<CTX>, tcx: CTX, queries: &'a [T], f: F) -> &'a T\n+fn pick_query<'a, CTX, T, F>(\n+    query_map: &QueryMap<CTX::DepKind, CTX::Query>,\n+    tcx: CTX,\n+    queries: &'a [T],\n+    f: F,\n+) -> &'a T\n where\n     CTX: QueryContext,\n     F: Fn(&T) -> (Span, QueryJobId<CTX::DepKind>),\n@@ -429,9 +455,9 @@ where\n /// the function returns false.\n #[cfg(parallel_compiler)]\n fn remove_cycle<CTX: QueryContext>(\n-    query_map: &QueryMap<CTX>,\n+    query_map: &QueryMap<CTX::DepKind, CTX::Query>,\n     jobs: &mut Vec<QueryJobId<CTX::DepKind>>,\n-    wakelist: &mut Vec<Lrc<QueryWaiter<CTX>>>,\n+    wakelist: &mut Vec<Lrc<QueryWaiter<CTX::DepKind, CTX::Query>>>,\n     tcx: CTX,\n ) -> bool {\n     let mut visited = FxHashSet::default();"}, {"sha": "da45565dbe6bdad399081c066321490b204896b3", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "patch": "@@ -15,8 +15,8 @@ mod config;\n pub use self::config::{QueryAccessors, QueryConfig, QueryDescription};\n \n use crate::dep_graph::{DepContext, DepGraph};\n+use crate::query::job::QueryMap;\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::HashStable;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n@@ -38,9 +38,7 @@ pub trait QueryContext: DepContext {\n     /// Get the query information from the TLS context.\n     fn current_query_job(&self) -> Option<QueryJobId<Self::DepKind>>;\n \n-    fn try_collect_active_jobs(\n-        &self,\n-    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self>>>;\n+    fn try_collect_active_jobs(&self) -> Option<QueryMap<Self::DepKind, Self::Query>>;\n \n     /// Executes a job by changing the `ImplicitCtxt` to point to the\n     /// new query job while it executes. It returns the diagnostics"}, {"sha": "50f443716f44baf2c5313ea18bc5eaf55a555423", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 72, "deletions": 62, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "patch": "@@ -7,7 +7,7 @@ use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use crate::query::caches::QueryCache;\n use crate::query::config::{QueryDescription, QueryVtable, QueryVtableExt};\n use crate::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n-use crate::query::QueryContext;\n+use crate::query::{QueryContext, QueryMap};\n \n #[cfg(not(parallel_compiler))]\n use rustc_data_structures::cold_path;\n@@ -20,42 +20,40 @@ use rustc_errors::{Diagnostic, FatalError};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::Span;\n use std::collections::hash_map::Entry;\n-use std::convert::TryFrom;\n-use std::fmt::Debug;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::num::NonZeroU32;\n use std::ptr;\n #[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n-pub(super) struct QueryStateShard<CTX: QueryContext, K, C> {\n+pub(super) struct QueryStateShard<D, Q, K, C> {\n     pub(super) cache: C,\n-    active: FxHashMap<K, QueryResult<CTX>>,\n+    active: FxHashMap<K, QueryResult<D, Q>>,\n \n     /// Used to generate unique ids for active jobs.\n     jobs: u32,\n }\n \n-impl<CTX: QueryContext, K, C: Default> Default for QueryStateShard<CTX, K, C> {\n-    fn default() -> QueryStateShard<CTX, K, C> {\n+impl<D, Q, K, C: Default> Default for QueryStateShard<D, Q, K, C> {\n+    fn default() -> QueryStateShard<D, Q, K, C> {\n         QueryStateShard { cache: Default::default(), active: Default::default(), jobs: 0 }\n     }\n }\n \n-pub struct QueryState<CTX: QueryContext, C: QueryCache> {\n+pub struct QueryState<D, Q, C: QueryCache> {\n     cache: C,\n-    shards: Sharded<QueryStateShard<CTX, C::Key, C::Sharded>>,\n+    shards: Sharded<QueryStateShard<D, Q, C::Key, C::Sharded>>,\n     #[cfg(debug_assertions)]\n     pub cache_hits: AtomicUsize,\n }\n \n-impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n+impl<D, Q, C: QueryCache> QueryState<D, Q, C> {\n     #[inline]\n     pub(super) fn get_lookup<'tcx>(\n         &'tcx self,\n         key: &C::Key,\n-    ) -> QueryLookup<'tcx, CTX, C::Key, C::Sharded> {\n+    ) -> QueryLookup<'tcx, D, Q, C::Key, C::Sharded> {\n         // We compute the key's hash once and then use it for both the\n         // shard lookup and the hashmap lookup. This relies on the fact\n         // that both of them use `FxHasher`.\n@@ -70,16 +68,21 @@ impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n }\n \n /// Indicates the state of a query for a given key in a query map.\n-enum QueryResult<CTX: QueryContext> {\n+enum QueryResult<D, Q> {\n     /// An already executing query. The query job can be used to await for its completion.\n-    Started(QueryJob<CTX>),\n+    Started(QueryJob<D, Q>),\n \n     /// The query panicked. Queries trying to wait on this will raise a fatal error which will\n     /// silently panic.\n     Poisoned,\n }\n \n-impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n+impl<D, Q, C> QueryState<D, Q, C>\n+where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+    C: QueryCache,\n+{\n     #[inline(always)]\n     pub fn iter_results<R>(\n         &self,\n@@ -98,22 +101,18 @@ impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n \n     pub fn try_collect_active_jobs(\n         &self,\n-        kind: CTX::DepKind,\n-        make_query: fn(C::Key) -> CTX::Query,\n-        jobs: &mut FxHashMap<QueryJobId<CTX::DepKind>, QueryJobInfo<CTX>>,\n-    ) -> Option<()>\n-    where\n-        C::Key: Clone,\n-    {\n+        kind: D,\n+        make_query: fn(C::Key) -> Q,\n+        jobs: &mut QueryMap<D, Q>,\n+    ) -> Option<()> {\n         // We use try_lock_shards here since we are called from the\n         // deadlock handler, and this shouldn't be locked.\n         let shards = self.shards.try_lock_shards()?;\n         let shards = shards.iter().enumerate();\n         jobs.extend(shards.flat_map(|(shard_id, shard)| {\n             shard.active.iter().filter_map(move |(k, v)| {\n                 if let QueryResult::Started(ref job) = *v {\n-                    let id =\n-                        QueryJobId { job: job.id, shard: u16::try_from(shard_id).unwrap(), kind };\n+                    let id = QueryJobId::new(job.id, shard_id, kind);\n                     let info = QueryInfo { span: job.span, query: make_query(k.clone()) };\n                     Some((id, QueryJobInfo { info, job: job.clone() }))\n                 } else {\n@@ -126,8 +125,8 @@ impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n     }\n }\n \n-impl<CTX: QueryContext, C: QueryCache> Default for QueryState<CTX, C> {\n-    fn default() -> QueryState<CTX, C> {\n+impl<D, Q, C: QueryCache> Default for QueryState<D, Q, C> {\n+    fn default() -> QueryState<D, Q, C> {\n         QueryState {\n             cache: C::default(),\n             shards: Default::default(),\n@@ -138,28 +137,30 @@ impl<CTX: QueryContext, C: QueryCache> Default for QueryState<CTX, C> {\n }\n \n /// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n-pub struct QueryLookup<'tcx, CTX: QueryContext, K, C> {\n+pub struct QueryLookup<'tcx, D, Q, K, C> {\n     pub(super) key_hash: u64,\n     shard: usize,\n-    pub(super) lock: LockGuard<'tcx, QueryStateShard<CTX, K, C>>,\n+    pub(super) lock: LockGuard<'tcx, QueryStateShard<D, Q, K, C>>,\n }\n \n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-struct JobOwner<'tcx, CTX: QueryContext, C>\n+struct JobOwner<'tcx, D, Q, C>\n where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n     C: QueryCache,\n-    C::Key: Eq + Hash + Clone + Debug,\n {\n-    state: &'tcx QueryState<CTX, C>,\n+    state: &'tcx QueryState<D, Q, C>,\n     key: C::Key,\n-    id: QueryJobId<CTX::DepKind>,\n+    id: QueryJobId<D>,\n }\n \n-impl<'tcx, CTX: QueryContext, C> JobOwner<'tcx, CTX, C>\n+impl<'tcx, D, Q, C> JobOwner<'tcx, D, Q, C>\n where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n     C: QueryCache,\n-    C::Key: Eq + Hash + Clone + Debug,\n {\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n     /// start executing the query, or returns with the result of the query.\n@@ -170,14 +171,14 @@ where\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    fn try_start<'a, 'b>(\n+    fn try_start<'a, 'b, CTX>(\n         tcx: CTX,\n-        state: &'b QueryState<CTX, C>,\n+        state: &'b QueryState<CTX::DepKind, CTX::Query, C>,\n         span: Span,\n         key: &C::Key,\n-        mut lookup: QueryLookup<'a, CTX, C::Key, C::Sharded>,\n+        mut lookup: QueryLookup<'a, CTX::DepKind, CTX::Query, C::Key, C::Sharded>,\n         query: &QueryVtable<CTX, C::Key, C::Value>,\n-    ) -> TryGetJob<'b, CTX, C>\n+    ) -> TryGetJob<'b, CTX::DepKind, CTX::Query, C>\n     where\n         CTX: QueryContext,\n     {\n@@ -229,15 +230,20 @@ where\n         // so we just return the error.\n         #[cfg(not(parallel_compiler))]\n         return TryGetJob::Cycle(cold_path(|| {\n-            let value = query.handle_cycle_error(tcx, latch.find_cycle_in_stack(tcx, span));\n+            let error: CycleError<CTX::Query> = latch.find_cycle_in_stack(\n+                tcx.try_collect_active_jobs().unwrap(),\n+                &tcx.current_query_job(),\n+                span,\n+            );\n+            let value = query.handle_cycle_error(tcx, error);\n             state.cache.store_nocache(value)\n         }));\n \n         // With parallel queries we might just have to wait on some other\n         // thread.\n         #[cfg(parallel_compiler)]\n         {\n-            let result = latch.wait_on(tcx, span);\n+            let result = latch.wait_on(tcx.current_query_job(), span);\n \n             if let Err(cycle) = result {\n                 let value = query.handle_cycle_error(tcx, cycle);\n@@ -297,9 +303,11 @@ where\n     (result, diagnostics.into_inner())\n }\n \n-impl<'tcx, CTX: QueryContext, C: QueryCache> Drop for JobOwner<'tcx, CTX, C>\n+impl<'tcx, D, Q, C> Drop for JobOwner<'tcx, D, Q, C>\n where\n-    C::Key: Eq + Hash + Clone + Debug,\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+    C: QueryCache,\n {\n     #[inline(never)]\n     #[cold]\n@@ -330,12 +338,14 @@ pub struct CycleError<Q> {\n }\n \n /// The result of `try_start`.\n-enum TryGetJob<'tcx, CTX: QueryContext, C: QueryCache>\n+enum TryGetJob<'tcx, D, Q, C>\n where\n-    C::Key: Eq + Hash + Clone + Debug,\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+    C: QueryCache,\n {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n-    NotYetStarted(JobOwner<'tcx, CTX, C>),\n+    NotYetStarted(JobOwner<'tcx, D, Q, C>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep-node index\n@@ -354,7 +364,7 @@ where\n #[inline(always)]\n fn try_get_cached<CTX, C, R, OnHit, OnMiss>(\n     tcx: CTX,\n-    state: &QueryState<CTX, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n     key: C::Key,\n     // `on_hit` can be called while holding a lock to the query cache\n     on_hit: OnHit,\n@@ -364,7 +374,7 @@ where\n     C: QueryCache,\n     CTX: QueryContext,\n     OnHit: FnOnce(&C::Stored, DepNodeIndex) -> R,\n-    OnMiss: FnOnce(C::Key, QueryLookup<'_, CTX, C::Key, C::Sharded>) -> R,\n+    OnMiss: FnOnce(C::Key, QueryLookup<'_, CTX::DepKind, CTX::Query, C::Key, C::Sharded>) -> R,\n {\n     state.cache.lookup(\n         state,\n@@ -386,19 +396,20 @@ where\n #[inline(always)]\n fn try_execute_query<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n     span: Span,\n     key: C::Key,\n-    lookup: QueryLookup<'_, CTX, C::Key, C::Sharded>,\n+    lookup: QueryLookup<'_, CTX::DepKind, CTX::Query, C::Key, C::Sharded>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) -> C::Stored\n where\n     C: QueryCache,\n-    C::Key: Eq + Clone + Debug + crate::dep_graph::DepNodeParams<CTX>,\n-    C::Stored: Clone,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n     CTX: QueryContext,\n {\n-    let job = match JobOwner::try_start(tcx, state, span, &key, lookup, query) {\n+    let job = match JobOwner::<'_, CTX::DepKind, CTX::Query, C>::try_start(\n+        tcx, state, span, &key, lookup, query,\n+    ) {\n         TryGetJob::NotYetStarted(job) => job,\n         TryGetJob::Cycle(result) => return result,\n         #[cfg(parallel_compiler)]\n@@ -559,14 +570,12 @@ fn incremental_verify_ich<CTX, K, V>(\n fn force_query_with_job<C, CTX>(\n     tcx: CTX,\n     key: C::Key,\n-    job: JobOwner<'_, CTX, C>,\n+    job: JobOwner<'_, CTX::DepKind, CTX::Query, C>,\n     dep_node: DepNode<CTX::DepKind>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) -> (C::Stored, DepNodeIndex)\n where\n     C: QueryCache,\n-    C::Key: Eq + Clone + Debug,\n-    C::Stored: Clone,\n     CTX: QueryContext,\n {\n     // If the following assertion triggers, it can have two reasons:\n@@ -617,16 +626,15 @@ where\n #[inline(never)]\n fn get_query_impl<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n     span: Span,\n     key: C::Key,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) -> C::Stored\n where\n     CTX: QueryContext,\n     C: QueryCache,\n-    C::Key: Eq + Clone + crate::dep_graph::DepNodeParams<CTX>,\n-    C::Stored: Clone,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n {\n     try_get_cached(\n         tcx,\n@@ -650,12 +658,12 @@ where\n #[inline(never)]\n fn ensure_query_impl<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n     key: C::Key,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) where\n     C: QueryCache,\n-    C::Key: Eq + Clone + crate::dep_graph::DepNodeParams<CTX>,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n     CTX: QueryContext,\n {\n     if query.eval_always {\n@@ -687,14 +695,14 @@ fn ensure_query_impl<CTX, C>(\n #[inline(never)]\n fn force_query_impl<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n     key: C::Key,\n     span: Span,\n     dep_node: DepNode<CTX::DepKind>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) where\n     C: QueryCache,\n-    C::Key: Eq + Clone + crate::dep_graph::DepNodeParams<CTX>,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n     CTX: QueryContext,\n {\n     // We may be concurrently trying both execute and force a query.\n@@ -708,7 +716,9 @@ fn force_query_impl<CTX, C>(\n             // Cache hit, do nothing\n         },\n         |key, lookup| {\n-            let job = match JobOwner::try_start(tcx, state, span, &key, lookup, query) {\n+            let job = match JobOwner::<'_, CTX::DepKind, CTX::Query, C>::try_start(\n+                tcx, state, span, &key, lookup, query,\n+            ) {\n                 TryGetJob::NotYetStarted(job) => job,\n                 TryGetJob::Cycle(_) => return,\n                 #[cfg(parallel_compiler)]"}]}