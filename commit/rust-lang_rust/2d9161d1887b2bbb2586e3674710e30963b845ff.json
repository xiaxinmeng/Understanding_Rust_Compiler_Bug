{"sha": "2d9161d1887b2bbb2586e3674710e30963b845ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkOTE2MWQxODg3YjJiYmIyNTg2ZTM2NzQ3MTBlMzA5NjNiODQ1ZmY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-09-25T23:49:34Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-10-05T21:35:21Z"}, "message": "Improve resolution of associated types in macros 2.0", "tree": {"sha": "3a13f1ec041eb592f465090f0378181acb6c17f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a13f1ec041eb592f465090f0378181acb6c17f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d9161d1887b2bbb2586e3674710e30963b845ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d9161d1887b2bbb2586e3674710e30963b845ff", "html_url": "https://github.com/rust-lang/rust/commit/2d9161d1887b2bbb2586e3674710e30963b845ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d9161d1887b2bbb2586e3674710e30963b845ff/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4531131bf328e1372663310bfd45cd354db511ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/4531131bf328e1372663310bfd45cd354db511ce", "html_url": "https://github.com/rust-lang/rust/commit/4531131bf328e1372663310bfd45cd354db511ce"}], "stats": {"total": 219, "additions": 182, "deletions": 37}, "files": [{"sha": "071653c6a10cb37e83e9f1820c1583809d2d4bf1", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=2d9161d1887b2bbb2586e3674710e30963b845ff", "patch": "@@ -29,7 +29,6 @@ use infer::{InferCtxt, InferOk};\n use infer::type_variable::TypeVariableOrigin;\n use middle::const_val::ConstVal;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n-use syntax::ast;\n use syntax::symbol::Symbol;\n use ty::subst::{Subst, Substs};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n@@ -1044,10 +1043,9 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 // In either case, we handle this by not adding a\n                 // candidate for an impl if it contains a `default`\n                 // type.\n-                let item_name = selcx.tcx().associated_item(obligation.predicate.item_def_id).name;\n                 let node_item = assoc_ty_def(selcx,\n                                              impl_data.impl_def_id,\n-                                             item_name);\n+                                             obligation.predicate.item_def_id);\n \n                 let is_default = if node_item.node.is_from_trait() {\n                     // If true, the impl inherited a `type Foo = Bar`\n@@ -1441,8 +1439,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n \n     let tcx = selcx.tcx();\n     let param_env = obligation.param_env;\n-    let assoc_ty = assoc_ty_def(selcx, impl_def_id,\n-        tcx.associated_item(obligation.predicate.item_def_id).name);\n+    let assoc_ty = assoc_ty_def(selcx, impl_def_id, obligation.predicate.item_def_id);\n \n     let ty = if !assoc_ty.item.defaultness.has_value() {\n         // This means that the impl is missing a definition for the\n@@ -1471,10 +1468,11 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'gcx, 'tcx>,\n     impl_def_id: DefId,\n-    assoc_ty_name: ast::Name)\n+    assoc_ty_def_id: DefId)\n     -> specialization_graph::NodeItem<ty::AssociatedItem>\n {\n     let tcx = selcx.tcx();\n+    let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).name;\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n     let trait_def = tcx.trait_def(trait_def_id);\n \n@@ -1486,7 +1484,8 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     // cycle error if the specialization graph is currently being built.\n     let impl_node = specialization_graph::Node::Impl(impl_def_id);\n     for item in impl_node.items(tcx) {\n-        if item.kind == ty::AssociatedKind::Type && item.name == assoc_ty_name {\n+        if item.kind == ty::AssociatedKind::Type &&\n+                tcx.hygienic_eq(item.name, assoc_ty_name, trait_def_id) {\n             return specialization_graph::NodeItem {\n                 node: specialization_graph::Node::Impl(impl_def_id),\n                 item,\n@@ -1496,7 +1495,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n \n     if let Some(assoc_item) = trait_def\n         .ancestors(tcx, impl_def_id)\n-        .defs(tcx, assoc_ty_name, ty::AssociatedKind::Type)\n+        .defs(tcx, assoc_ty_name, ty::AssociatedKind::Type, trait_def_id)\n         .next() {\n         assoc_item\n     } else {"}, {"sha": "20da4c084f01e78eecb4301af68b58f787a733e7", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=2d9161d1887b2bbb2586e3674710e30963b845ff", "patch": "@@ -125,7 +125,7 @@ pub fn find_associated_item<'a, 'tcx>(\n     let trait_def = tcx.trait_def(trait_def_id);\n \n     let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n-    match ancestors.defs(tcx, item.name, item.kind).next() {\n+    match ancestors.defs(tcx, item.name, item.kind, trait_def_id).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt().enter(|infcx| {\n                 let param_env = ty::ParamEnv::empty(Reveal::All);"}, {"sha": "da9dbc0e2c9990c3416e3db9492b39e8cc69e00d", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=2d9161d1887b2bbb2586e3674710e30963b845ff", "patch": "@@ -346,11 +346,14 @@ impl<'a, 'gcx, 'tcx> Ancestors {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n     #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n-    pub fn defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name, kind: ty::AssociatedKind)\n+    pub fn defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, trait_item_name: Name,\n+                trait_item_kind: ty::AssociatedKind, trait_def_id: DefId)\n                 -> impl Iterator<Item = NodeItem<ty::AssociatedItem>> + 'a {\n         self.flat_map(move |node| {\n-            node.items(tcx).filter(move |item| item.kind == kind && item.name == name)\n-                           .map(move |item| NodeItem { node: node, item: item })\n+            node.items(tcx).filter(move |impl_item| {\n+                impl_item.kind == trait_item_kind &&\n+                tcx.hygienic_eq(impl_item.name, trait_item_name, trait_def_id)\n+            }).map(move |item| NodeItem { node: node, item: item })\n         })\n     }\n }"}, {"sha": "c4f526d80146b8868b48798ff991a5e3e004b0fc", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2d9161d1887b2bbb2586e3674710e30963b845ff", "patch": "@@ -2345,6 +2345,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    // Hygienically compare a use-site name (`use_name`) for a field or an associated item with its\n+    // supposed definition name (`def_name`). The method also needs `DefId` of the supposed\n+    // definition's parent/scope to perform comparison.\n+    pub fn hygienic_eq(self, use_name: Name, def_name: Name, def_parent_def_id: DefId) -> bool {\n+        self.adjust(use_name, def_parent_def_id, DUMMY_NODE_ID).0 == def_name.to_ident()\n+    }\n+\n     pub fn adjust(self, name: Name, scope: DefId, block: NodeId) -> (Ident, DefId) {\n         self.adjust_ident(name.to_ident(), scope, block)\n     }\n@@ -2356,6 +2363,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n         let scope = match ident.ctxt.adjust(expansion) {\n             Some(macro_def) => self.hir.definitions().macro_def_scope(macro_def),\n+            None if block == DUMMY_NODE_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId\n             None => self.hir.get_module_parent(block),\n         };\n         (ident, scope)"}, {"sha": "10e1286465dbfa3de1cef6fbb25eca4e587a6404", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=2d9161d1887b2bbb2586e3674710e30963b845ff", "patch": "@@ -596,9 +596,10 @@ impl<'a, 'tcx> ProjectionTy<'tcx> {\n     pub fn from_ref_and_name(\n         tcx: TyCtxt, trait_ref: ty::TraitRef<'tcx>, item_name: Name\n     ) -> ProjectionTy<'tcx> {\n-        let item_def_id = tcx.associated_items(trait_ref.def_id).find(\n-            |item| item.name == item_name && item.kind == ty::AssociatedKind::Type\n-        ).unwrap().def_id;\n+        let item_def_id = tcx.associated_items(trait_ref.def_id).find(|item| {\n+            item.kind == ty::AssociatedKind::Type &&\n+            tcx.hygienic_eq(item_name, item.name, trait_ref.def_id)\n+        }).unwrap().def_id;\n \n         ProjectionTy {\n             substs: trait_ref.substs,"}, {"sha": "af8cc2c806adf4bcea2849fcf1a40dbeec164fff", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2d9161d1887b2bbb2586e3674710e30963b845ff", "patch": "@@ -356,9 +356,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         poly_projections.extend(assoc_bindings.iter().filter_map(|binding| {\n             // specify type to assert that error was already reported in Err case:\n             let predicate: Result<_, ErrorReported> =\n-                self.ast_type_binding_to_poly_projection_predicate(trait_ref.ref_id,\n-                                                                   poly_trait_ref,\n-                                                                   binding);\n+                self.ast_type_binding_to_poly_projection_predicate(poly_trait_ref, binding);\n             predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n         }));\n \n@@ -423,13 +421,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                            -> bool\n     {\n         self.tcx().associated_items(trait_def_id).any(|item| {\n-            item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n+            item.kind == ty::AssociatedKind::Type &&\n+            self.tcx().hygienic_eq(assoc_name, item.name, trait_def_id)\n         })\n     }\n \n     fn ast_type_binding_to_poly_projection_predicate(\n         &self,\n-        _path_id: ast::NodeId,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         binding: &ConvertedBinding<'tcx>)\n         -> Result<ty::PolyProjectionPredicate<'tcx>, ErrorReported>\n@@ -504,7 +502,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let candidate = self.one_bound_for_assoc_type(candidates,\n                                                       &trait_ref.to_string(),\n-                                                      &binding.item_name.as_str(),\n+                                                      binding.item_name,\n                                                       binding.span)?;\n \n         Ok(candidate.map_bound(|trait_ref| {\n@@ -702,7 +700,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let param_name = tcx.hir.ty_param_name(param_node_id);\n         self.one_bound_for_assoc_type(suitable_bounds,\n                                       &param_name.as_str(),\n-                                      &assoc_name.as_str(),\n+                                      assoc_name,\n                                       span)\n     }\n \n@@ -712,7 +710,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn one_bound_for_assoc_type<I>(&self,\n                                 mut bounds: I,\n                                 ty_param_name: &str,\n-                                assoc_name: &str,\n+                                assoc_name: ast::Name,\n                                 span: Span)\n         -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n         where I: Iterator<Item=ty::PolyTraitRef<'tcx>>\n@@ -741,7 +739,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n             for bound in bounds {\n                 let bound_span = self.tcx().associated_items(bound.def_id()).find(|item| {\n-                    item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n+                    item.kind == ty::AssociatedKind::Type &&\n+                    self.tcx().hygienic_eq(assoc_name, item.name, bound.def_id())\n                 })\n                 .and_then(|item| self.tcx().hir.span_if_local(item.def_id));\n \n@@ -802,10 +801,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     .filter(|r| self.trait_defines_associated_type_named(r.def_id(),\n                                                                          assoc_name));\n \n-                match self.one_bound_for_assoc_type(candidates,\n-                                                    \"Self\",\n-                                                    &assoc_name.as_str(),\n-                                                    span) {\n+                match self.one_bound_for_assoc_type(candidates, \"Self\", assoc_name, span) {\n                     Ok(bound) => bound,\n                     Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n@@ -830,14 +826,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n \n         let trait_did = bound.0.def_id;\n-        let item = tcx.associated_items(trait_did).find(|i| i.name == assoc_name)\n+        let (assoc_ident, def_scope) = tcx.adjust(assoc_name, trait_did, ref_id);\n+        let item = tcx.associated_items(trait_did).find(|i| i.name.to_ident() == assoc_ident)\n                                                   .expect(\"missing associated type\");\n \n         let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, bound);\n         let ty = self.normalize_ty(span, ty);\n \n         let def = Def::AssociatedTy(item.def_id);\n-        let def_scope = tcx.adjust(assoc_name, item.container.id(), ref_id).1;\n         if !item.vis.is_accessible_from(def_scope, tcx) {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_name);\n             tcx.sess.span_err(span, &msg);"}, {"sha": "3ddeba9d44012b3735a30f5f5b810e3290a51ac3", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=2d9161d1887b2bbb2586e3674710e30963b845ff", "patch": "@@ -373,7 +373,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// and return it, or `None`, if no such item was defined there.\n     pub fn associated_item(&self, def_id: DefId, item_name: ast::Name)\n                            -> Option<ty::AssociatedItem> {\n-        let ident = self.tcx.adjust(item_name, def_id, self.body_id).0;\n-        self.tcx.associated_items(def_id).find(|item| item.name.to_ident() == ident)\n+        self.tcx.associated_items(def_id)\n+                .find(|item| self.tcx.hygienic_eq(item_name, item.name, def_id))\n+\n     }\n }"}, {"sha": "33ac95ffcd15c560cdc56c614c208e29f3504233", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2d9161d1887b2bbb2586e3674710e30963b845ff", "patch": "@@ -1248,6 +1248,7 @@ fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            trait_def: &ty::TraitDef,\n+                                           trait_item: &ty::AssociatedItem,\n                                            impl_id: DefId,\n                                            impl_item: &hir::ImplItem)\n {\n@@ -1258,7 +1259,8 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         hir::ImplItemKind::Method(..) => ty::AssociatedKind::Method,\n         hir::ImplItemKind::Type(_) => ty::AssociatedKind::Type\n     };\n-    let parent = ancestors.defs(tcx, impl_item.name, kind).skip(1).next()\n+\n+    let parent = ancestors.defs(tcx, trait_item.name, kind, trait_def.def_id).skip(1).next()\n         .map(|node_item| node_item.map(|parent| parent.defaultness));\n \n     if let Some(parent) = parent {\n@@ -1290,7 +1292,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for impl_item in impl_items() {\n         let ty_impl_item = tcx.associated_item(tcx.hir.local_def_id(impl_item.id));\n         let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n-            .find(|ac| ac.name == ty_impl_item.name);\n+            .find(|ac| tcx.hygienic_eq(ty_impl_item.name, ac.name, impl_trait_ref.def_id));\n \n         // Check that impl definition matches trait definition\n         if let Some(ty_trait_item) = ty_trait_item {\n@@ -1371,9 +1373,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     }\n                 }\n             }\n-        }\n \n-        check_specialization_validity(tcx, trait_def, impl_id, impl_item);\n+            check_specialization_validity(tcx, trait_def, &ty_trait_item, impl_id, impl_item);\n+        }\n     }\n \n     // Check for missing items from trait\n@@ -1382,7 +1384,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let associated_type_overridden = overridden_associated_type.is_some();\n     for trait_item in tcx.associated_items(impl_trait_ref.def_id) {\n         let is_implemented = trait_def.ancestors(tcx, impl_id)\n-            .defs(tcx, trait_item.name, trait_item.kind)\n+            .defs(tcx, trait_item.name, trait_item.kind, impl_trait_ref.def_id)\n             .next()\n             .map(|node_item| !node_item.node.is_from_trait())\n             .unwrap_or(false);"}, {"sha": "e336b0df13fea71336343756b130dfef66d88645", "filename": "src/test/compile-fail/hygiene/assoc_item_ctxt.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fassoc_item_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fassoc_item_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fassoc_item_ctxt.rs?ref=2d9161d1887b2bbb2586e3674710e30963b845ff", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#![feature(decl_macro)]\n+#![allow(unused)]\n+\n+mod ok {\n+    macro mac_trait_item($method: ident) {\n+        fn $method();\n+    }\n+\n+    trait Tr {\n+        mac_trait_item!(method);\n+    }\n+\n+    macro mac_trait_impl() {\n+        impl Tr for u8 { // OK\n+            fn method() {} // OK\n+        }\n+    }\n+\n+    mac_trait_impl!();\n+}\n+\n+mod error {\n+    macro mac_trait_item() {\n+        fn method();\n+    }\n+\n+    trait Tr {\n+        mac_trait_item!();\n+    }\n+\n+    macro mac_trait_impl() {\n+        impl Tr for u8 { //~ ERROR not all trait items implemented, missing: `method`\n+            fn method() {} //~ ERROR method `method` is not a member of trait `Tr`\n+        }\n+    }\n+\n+    mac_trait_impl!();\n+}\n+\n+fn main() {}"}, {"sha": "46a138749ff176e4e521e60cd22ad2e8ece949dd", "filename": "src/test/compile-fail/hygiene/assoc_ty_bindings.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fassoc_ty_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fassoc_ty_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fassoc_ty_bindings.rs?ref=2d9161d1887b2bbb2586e3674710e30963b845ff", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#![feature(decl_macro, associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+\n+trait Base {\n+    type AssocTy;\n+    fn f();\n+}\n+trait Derived: Base {\n+    fn g();\n+}\n+\n+macro mac() {\n+    type A = Base<AssocTy = u8>;\n+    type B = Derived<AssocTy = u8>;\n+\n+    impl Base for u8 {\n+        type AssocTy = u8;\n+        fn f() {\n+            let _: Self::AssocTy;\n+        }\n+    }\n+    impl Derived for u8 {\n+        fn g() {\n+            let _: Self::AssocTy;\n+        }\n+    }\n+\n+    fn h<T: Base, U: Derived>() {\n+        let _: T::AssocTy;\n+        let _: U::AssocTy;\n+    }\n+}\n+\n+mac!();\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "3d46d2ec99efba5d4c401e03bc53b0c00147f792", "filename": "src/test/run-pass/hygiene/specialization.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Ftest%2Frun-pass%2Fhygiene%2Fspecialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9161d1887b2bbb2586e3674710e30963b845ff/src%2Ftest%2Frun-pass%2Fhygiene%2Fspecialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Fspecialization.rs?ref=2d9161d1887b2bbb2586e3674710e30963b845ff", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#![feature(decl_macro)]\n+\n+trait Tr {\n+    fn f(&self) -> &'static str {\n+        \"This shouldn't happen\"\n+    }\n+}\n+\n+pub macro m($t:ty) {\n+    impl Tr for $t {\n+        fn f(&self) -> &'static str {\n+            \"Run me\"\n+        }\n+    }\n+}\n+\n+struct S;\n+m!(S);\n+\n+fn main() {\n+    assert_eq!(S.f(), \"Run me\");\n+}"}]}