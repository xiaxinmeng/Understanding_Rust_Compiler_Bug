{"sha": "bac213bee4b709843094a6868f4db98056407ed2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYzIxM2JlZTRiNzA5ODQzMDk0YTY4NjhmNGRiOTgwNTY0MDdlZDI=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-11-16T16:26:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-16T16:26:33Z"}, "message": "Rollup merge of #78903 - ssomers:btree_order_chaos_testing, r=Mark-Simulacrum\n\nBTreeMap: test chaotic ordering & other bits & bobs\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "177086f1aa164e5ca288df797f0774c7ef86bacc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/177086f1aa164e5ca288df797f0774c7ef86bacc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bac213bee4b709843094a6868f4db98056407ed2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfsqg5CRBK7hj4Ov3rIwAAdHIIAKjpEUncb1gc8YJEiZ6AgazK\nWbu5J6NPy+gxVxS3vfQB/WcBq9JAN7VCbGtPo4Y4cN2KVyOi9h+7XTk2O8cdBZ/P\nyoA/MNPaBteB8Ixb5fI5abZ9wlDa/y21FXySgUTBh3E4jyKecESwHLA5Xjjxc4ew\neaZ8ZCJfrnPitt0ThxEkCY56pmf7sRAeiohID4dwOwWJgiK/x3kL9va7Oog2mugW\nIDYITdXiTC9dRvMZifBfpVIi1y1wSn8HBeXqO3HxJyml0TIJvuzH5LYZAhxCzTJo\nzwSOLg7DUNYmb04svIVnxoszwzuZYVWC0AmTrFV3JtxH/7f4s7sO3z53MZx39nI=\n=5gQO\n-----END PGP SIGNATURE-----\n", "payload": "tree 177086f1aa164e5ca288df797f0774c7ef86bacc\nparent c0a9bf933677b6e35122a037ad450c55dd32ddb6\nparent 8972bcb0ddd78c5e3965c4c045736188fcae017b\nauthor Mara Bos <m-ou.se@m-ou.se> 1605543993 +0100\ncommitter GitHub <noreply@github.com> 1605543993 +0100\n\nRollup merge of #78903 - ssomers:btree_order_chaos_testing, r=Mark-Simulacrum\n\nBTreeMap: test chaotic ordering & other bits & bobs\n\nr? `@Mark-Simulacrum`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bac213bee4b709843094a6868f4db98056407ed2", "html_url": "https://github.com/rust-lang/rust/commit/bac213bee4b709843094a6868f4db98056407ed2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bac213bee4b709843094a6868f4db98056407ed2/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0a9bf933677b6e35122a037ad450c55dd32ddb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a9bf933677b6e35122a037ad450c55dd32ddb6", "html_url": "https://github.com/rust-lang/rust/commit/c0a9bf933677b6e35122a037ad450c55dd32ddb6"}, {"sha": "8972bcb0ddd78c5e3965c4c045736188fcae017b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8972bcb0ddd78c5e3965c4c045736188fcae017b", "html_url": "https://github.com/rust-lang/rust/commit/8972bcb0ddd78c5e3965c4c045736188fcae017b"}], "stats": {"total": 227, "additions": 201, "deletions": 26}, "files": [{"sha": "6e45d38dd9f912f9ee40e9407879b2a1059bc2e7", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 121, "deletions": 25, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/bac213bee4b709843094a6868f4db98056407ed2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac213bee4b709843094a6868f4db98056407ed2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=bac213bee4b709843094a6868f4db98056407ed2", "patch": "@@ -14,6 +14,9 @@ use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n+mod ord_chaos;\n+use ord_chaos::{Cyclic3, Governed, Governor};\n+\n // Capacity of a tree with a single level,\n // i.e., a tree who's root is a leaf node at height 0.\n const NODE_CAPACITY: usize = node::CAPACITY;\n@@ -28,7 +31,7 @@ const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n const MIN_INSERTS_HEIGHT_2: usize = 89;\n \n-// Gather all references from a mutable iterator and make sure Miri notices if\n+// Gathers all references from a mutable iterator and makes sure Miri notices if\n // using them is dangerous.\n fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>) {\n     // Gather all those references.\n@@ -43,28 +46,43 @@ fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>\n }\n \n impl<K, V> BTreeMap<K, V> {\n-    /// Panics if the map (or the code navigating it) is corrupted.\n-    fn check(&self)\n-    where\n-        K: Copy + Debug + Ord,\n-    {\n+    // Panics if the map (or the code navigating it) is corrupted.\n+    fn check_invariants(&self) {\n         if let Some(root) = &self.root {\n             let root_node = root.node_as_ref();\n \n+            // Check the back pointers top-down, before we attempt to rely on\n+            // more serious navigation code.\n             assert!(root_node.ascend().is_err());\n             root_node.assert_back_pointers();\n \n+            // Check consistenty of `length` and some of the navigation.\n             assert_eq!(self.length, root_node.calc_length());\n+            assert_eq!(self.length, self.keys().count());\n \n+            // Lastly, check the invariant causing the least harm.\n             root_node.assert_min_len(if root_node.height() > 0 { 1 } else { 0 });\n         } else {\n+            // Check consistenty of `length` and some of the navigation.\n             assert_eq!(self.length, 0);\n+            assert_eq!(self.length, self.keys().count());\n         }\n+    }\n \n-        self.assert_ascending();\n+    // Panics if the map is corrupted or if the keys are not in strictly\n+    // ascending order, in the current opinion of the `Ord` implementation.\n+    // If the `Ord` implementation does not honor transitivity, this method\n+    // does not guarantee that all the keys are unique, just that adjacent\n+    // keys are unique.\n+    fn check(&self)\n+    where\n+        K: Debug + Ord,\n+    {\n+        self.check_invariants();\n+        self.assert_strictly_ascending();\n     }\n \n-    /// Returns the height of the root, if any.\n+    // Returns the height of the root, if any.\n     fn height(&self) -> Option<usize> {\n         self.root.as_ref().map(node::Root::height)\n     }\n@@ -80,22 +98,18 @@ impl<K, V> BTreeMap<K, V> {\n         }\n     }\n \n-    /// Asserts that the keys are in strictly ascending order.\n-    fn assert_ascending(&self)\n+    // Panics if the keys are not in strictly ascending order.\n+    fn assert_strictly_ascending(&self)\n     where\n-        K: Copy + Debug + Ord,\n+        K: Debug + Ord,\n     {\n-        let mut num_seen = 0;\n         let mut keys = self.keys();\n         if let Some(mut previous) = keys.next() {\n-            num_seen = 1;\n             for next in keys {\n                 assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n                 previous = next;\n-                num_seen += 1;\n             }\n         }\n-        assert_eq!(num_seen, self.len());\n     }\n }\n \n@@ -111,7 +125,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n     }\n }\n \n-// Test our value of MIN_INSERTS_HEIGHT_2. It may change according to the\n+// Tests our value of MIN_INSERTS_HEIGHT_2. It may change according to the\n // implementation of insertion, but it's best to be aware of when it does.\n #[test]\n fn test_levels() {\n@@ -149,6 +163,25 @@ fn test_levels() {\n     assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2, \"{}\", map.dump_keys());\n }\n \n+// Ensures the testing infrastructure usually notices order violations.\n+#[test]\n+#[should_panic]\n+fn test_check_ord_chaos() {\n+    let gov = Governor::new();\n+    let map: BTreeMap<_, _> = (0..2).map(|i| (Governed(i, &gov), ())).collect();\n+    gov.flip();\n+    map.check();\n+}\n+\n+// Ensures the testing infrastructure doesn't always mind order violations.\n+#[test]\n+fn test_check_invariants_ord_chaos() {\n+    let gov = Governor::new();\n+    let map: BTreeMap<_, _> = (0..2).map(|i| (Governed(i, &gov), ())).collect();\n+    gov.flip();\n+    map.check_invariants();\n+}\n+\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n@@ -334,7 +367,7 @@ fn test_iter_rev() {\n     test(size, map.into_iter().rev());\n }\n \n-/// Specifically tests iter_mut's ability to mutate the value of pairs in-line\n+// Specifically tests iter_mut's ability to mutate the value of pairs in-line.\n fn do_test_iter_mut_mutation<T>(size: usize)\n where\n     T: Copy + Debug + Ord + TryFrom<usize>,\n@@ -439,6 +472,8 @@ fn test_iter_entering_root_twice() {\n     *back.1 = 42;\n     assert_eq!(front, (&0, &mut 24));\n     assert_eq!(back, (&1, &mut 42));\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next_back(), None);\n     map.check();\n }\n \n@@ -591,11 +626,12 @@ fn test_range_small() {\n \n #[test]\n fn test_range_height_1() {\n-    // Tests tree with a root and 2 leaves. Depending on details we don't want or need\n-    // to rely upon, the single key at the root will be 6 or 7.\n+    // Tests tree with a root and 2 leaves. The single key in the root node is\n+    // close to the middle among the keys.\n \n-    let map: BTreeMap<_, _> = (1..=MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)).collect();\n-    for &root in &[6, 7] {\n+    let map: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)).collect();\n+    let middle = MIN_INSERTS_HEIGHT_1 as i32 / 2;\n+    for root in middle - 2..=middle + 2 {\n         assert_eq!(range_keys(&map, (Excluded(root), Excluded(root + 1))), vec![]);\n         assert_eq!(range_keys(&map, (Excluded(root), Included(root + 1))), vec![root + 1]);\n         assert_eq!(range_keys(&map, (Included(root), Excluded(root + 1))), vec![root]);\n@@ -727,6 +763,19 @@ fn test_range_backwards_4() {\n     map.range((Excluded(3), Excluded(2)));\n }\n \n+#[test]\n+#[should_panic]\n+fn test_range_backwards_5() {\n+    let mut map = BTreeMap::new();\n+    map.insert(Cyclic3::B, ());\n+    // Lacking static_assert, call `range` conditionally, to emphasise that\n+    // we cause a different panic than `test_range_backwards_1` does.\n+    // A more refined `should_panic` would be welcome.\n+    if Cyclic3::C < Cyclic3::A {\n+        map.range(Cyclic3::C..=Cyclic3::A);\n+    }\n+}\n+\n #[test]\n fn test_range_1000() {\n     // Miri is too slow\n@@ -831,18 +880,28 @@ mod test_drain_filter {\n     }\n \n     #[test]\n-    fn consuming_nothing() {\n+    fn consumed_keeping_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: BTreeMap<_, _> = pairs.collect();\n         assert!(map.drain_filter(|_, _| false).eq(iter::empty()));\n         map.check();\n     }\n \n     #[test]\n-    fn consuming_all() {\n+    fn consumed_removing_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: BTreeMap<_, _> = pairs.clone().collect();\n         assert!(map.drain_filter(|_, _| true).eq(pairs));\n+        assert!(map.is_empty());\n+        map.check();\n+    }\n+\n+    #[test]\n+    fn dropped_removing_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n         map.check();\n     }\n \n@@ -1723,6 +1782,27 @@ fn test_append_drop_leak() {\n     assert_eq!(DROPS.load(Ordering::SeqCst), 4); // Rust issue #47949 ate one little piggy\n }\n \n+#[test]\n+fn test_append_ord_chaos() {\n+    let mut map1 = BTreeMap::new();\n+    map1.insert(Cyclic3::A, ());\n+    map1.insert(Cyclic3::B, ());\n+    let mut map2 = BTreeMap::new();\n+    map2.insert(Cyclic3::A, ());\n+    map2.insert(Cyclic3::B, ());\n+    map2.insert(Cyclic3::C, ()); // lands first, before A\n+    map2.insert(Cyclic3::B, ()); // lands first, before C\n+    map1.check();\n+    map2.check(); // keys are not unique but still strictly ascending\n+    assert_eq!(map1.len(), 2);\n+    assert_eq!(map2.len(), 4);\n+    map1.append(&mut map2);\n+    assert_eq!(map1.len(), 5);\n+    assert_eq!(map2.len(), 0);\n+    map1.check();\n+    map2.check();\n+}\n+\n fn rand_data(len: usize) -> Vec<(u32, u32)> {\n     assert!(len * 2 <= 70029); // from that point on numbers repeat\n     let mut rng = DeterministicRng::new();\n@@ -1885,11 +1965,27 @@ fn test_insert_remove_intertwined() {\n     let loops = if cfg!(miri) { 100 } else { 1_000_000 };\n     let mut map = BTreeMap::new();\n     let mut i = 1;\n+    let offset = 165; // somewhat arbitrarily chosen to cover some code paths\n     for _ in 0..loops {\n-        i = (i + 421) & 0xFF;\n+        i = (i + offset) & 0xFF;\n         map.insert(i, i);\n         map.remove(&(0xFF - i));\n     }\n-\n     map.check();\n }\n+\n+#[test]\n+fn test_insert_remove_intertwined_ord_chaos() {\n+    let loops = if cfg!(miri) { 100 } else { 1_000_000 };\n+    let gov = Governor::new();\n+    let mut map = BTreeMap::new();\n+    let mut i = 1;\n+    let offset = 165; // more arbitrarily copied from above\n+    for _ in 0..loops {\n+        i = (i + offset) & 0xFF;\n+        map.insert(Governed(i, &gov), ());\n+        map.remove(&Governed(0xFF - i, &gov));\n+        gov.flip();\n+    }\n+    map.check_invariants();\n+}"}, {"sha": "91d1d6ea9ef38f48fe9ef73171c4ebc6014a3514", "filename": "library/alloc/src/collections/btree/map/tests/ord_chaos.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/bac213bee4b709843094a6868f4db98056407ed2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests%2Ford_chaos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac213bee4b709843094a6868f4db98056407ed2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests%2Ford_chaos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests%2Ford_chaos.rs?ref=bac213bee4b709843094a6868f4db98056407ed2", "patch": "@@ -0,0 +1,76 @@\n+use std::cell::Cell;\n+use std::cmp::Ordering::{self, *};\n+use std::ptr;\n+\n+#[derive(Debug)]\n+pub enum Cyclic3 {\n+    A,\n+    B,\n+    C,\n+}\n+use Cyclic3::*;\n+\n+impl PartialOrd for Cyclic3 {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Cyclic3 {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        match (self, other) {\n+            (A, A) | (B, B) | (C, C) => Equal,\n+            (A, B) | (B, C) | (C, A) => Less,\n+            (A, C) | (B, A) | (C, B) => Greater,\n+        }\n+    }\n+}\n+\n+impl PartialEq for Cyclic3 {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.cmp(&other) == Equal\n+    }\n+}\n+\n+impl Eq for Cyclic3 {}\n+\n+#[derive(Debug)]\n+pub struct Governor {\n+    flipped: Cell<bool>,\n+}\n+\n+impl Governor {\n+    pub fn new() -> Self {\n+        Governor { flipped: Cell::new(false) }\n+    }\n+\n+    pub fn flip(&self) {\n+        self.flipped.set(!self.flipped.get());\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Governed<'a, T>(pub T, pub &'a Governor);\n+\n+impl<T: Ord> PartialOrd for Governed<'_, T> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl<T: Ord> Ord for Governed<'_, T> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        assert!(ptr::eq(self.1, other.1));\n+        let ord = self.0.cmp(&other.0);\n+        if self.1.flipped.get() { ord.reverse() } else { ord }\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for Governed<'_, T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        assert!(ptr::eq(self.1, other.1));\n+        self.0.eq(&other.0)\n+    }\n+}\n+\n+impl<T: Eq> Eq for Governed<'_, T> {}"}, {"sha": "b04b29320ac988756eb6bc337ac35da52bdca65f", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bac213bee4b709843094a6868f4db98056407ed2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac213bee4b709843094a6868f4db98056407ed2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=bac213bee4b709843094a6868f4db98056407ed2", "patch": "@@ -5,7 +5,7 @@ use crate::string::String;\n use core::cmp::Ordering::*;\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n-    /// Asserts that the back pointer in each reachable node points to its parent.\n+    // Asserts that the back pointer in each reachable node points to its parent.\n     pub fn assert_back_pointers(self) {\n         if let ForceResult::Internal(node) = self.force() {\n             for idx in 0..=node.len() {\n@@ -17,6 +17,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n         }\n     }\n \n+    // Renders a multi-line display of the keys in order and in tree hierarchy,\n+    // picturing the tree growing sideways from its root on the left to its\n+    // leaves on the right.\n     pub fn dump_keys(self) -> String\n     where\n         K: Debug,"}]}