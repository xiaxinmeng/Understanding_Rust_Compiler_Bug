{"sha": "42dde960f95222ffd8c356e0f7841cd22294a6c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyZGRlOTYwZjk1MjIyZmZkOGMzNTZlMGY3ODQxY2QyMjI5NGE2Yzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-19T22:54:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-19T22:54:14Z"}, "message": "Auto merge of #55162 - nikomatsakis:issue-54902-underscore-bound, r=tmandry\n\nhandle underscore bounds in unexpected places\n\nPer the discussion on #54902, I made it a hard error to use lifetime bounds in various places where they used to be permitted:\n\n- `where Foo: Bar<'_>` for example\n\nI also moved error reporting to HIR lowering and added `Error` variants to let us suppress downstream errors that result.\n\nI (imo) improved the error message wording to be clearer, as well.\n\nIn the process, I fixed the ICE in #52098.\n\nFixes #54902\nFixes #52098", "tree": {"sha": "315f1c52471fc775ee057c987a0c5d69f20a4b05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/315f1c52471fc775ee057c987a0c5d69f20a4b05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42dde960f95222ffd8c356e0f7841cd22294a6c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42dde960f95222ffd8c356e0f7841cd22294a6c9", "html_url": "https://github.com/rust-lang/rust/commit/42dde960f95222ffd8c356e0f7841cd22294a6c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42dde960f95222ffd8c356e0f7841cd22294a6c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78ff609d7375ee2a2c6d0222776ac612eb1b75be", "url": "https://api.github.com/repos/rust-lang/rust/commits/78ff609d7375ee2a2c6d0222776ac612eb1b75be", "html_url": "https://github.com/rust-lang/rust/commit/78ff609d7375ee2a2c6d0222776ac612eb1b75be"}, {"sha": "c294ec640be6b4cdd3b4922a622a6c12f6078b1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c294ec640be6b4cdd3b4922a622a6c12f6078b1d", "html_url": "https://github.com/rust-lang/rust/commit/c294ec640be6b4cdd3b4922a622a6c12f6078b1d"}], "stats": {"total": 1272, "additions": 910, "deletions": 362}, "files": [{"sha": "95b73d5f87b39fff6cfc2e260225ef2739333c83", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -436,7 +436,9 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n             visitor.visit_ident(ident);\n         }\n         LifetimeName::Param(ParamName::Fresh(_)) |\n+        LifetimeName::Param(ParamName::Error) |\n         LifetimeName::Static |\n+        LifetimeName::Error |\n         LifetimeName::Implicit |\n         LifetimeName::Underscore => {}\n     }\n@@ -747,7 +749,7 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n     walk_list!(visitor, visit_attribute, &param.attrs);\n     match param.name {\n         ParamName::Plain(ident) => visitor.visit_ident(ident),\n-        ParamName::Fresh(_) => {}\n+        ParamName::Error | ParamName::Fresh(_) => {}\n     }\n     match param.kind {\n         GenericParamKind::Lifetime { .. } => {}"}, {"sha": "da5979e699aa1d612ccf556094929207aa52e268", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 83, "deletions": 17, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -315,6 +315,11 @@ enum AnonymousLifetimeMode {\n     /// For **Deprecated** cases, report an error.\n     CreateParameter,\n \n+    /// Give a hard error when either `&` or `'_` is written. Used to\n+    /// rule out things like `where T: Foo<'_>`. Does not imply an\n+    /// error on default object bounds (e.g., `Box<dyn Foo>`).\n+    ReportError,\n+\n     /// Pass responsibility to `resolve_lifetime` code for all cases.\n     PassThrough,\n }\n@@ -735,6 +740,10 @@ impl<'a> LoweringContext<'a> {\n                         keywords::UnderscoreLifetime.name().as_interned_str(),\n                         hir::LifetimeParamKind::Elided,\n                     ),\n+                    ParamName::Error => (\n+                        keywords::UnderscoreLifetime.name().as_interned_str(),\n+                        hir::LifetimeParamKind::Error,\n+                    ),\n                 };\n \n                 // Add a definition for the in-band lifetime def\n@@ -791,7 +800,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     /// When we have either an elided or `'_` lifetime in an impl\n-    /// header, we convert it to\n+    /// header, we convert it to an in-band lifetime.\n     fn collect_fresh_in_band_lifetime(&mut self, span: Span) -> ParamName {\n         assert!(self.is_collecting_in_band_lifetimes);\n         let index = self.lifetimes_to_define.len();\n@@ -1474,7 +1483,7 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     }\n                     hir::LifetimeName::Param(_) => lifetime.name,\n-                    hir::LifetimeName::Static => return,\n+                    hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n                 };\n \n                 if !self.currently_bound_lifetimes.contains(&name)\n@@ -2162,7 +2171,7 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     }\n                     hir::LifetimeName::Param(_) => lifetime.name,\n-                    hir::LifetimeName::Static => return,\n+                    hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n                 };\n \n                 if !self.currently_bound_lifetimes.contains(&name) {\n@@ -2293,10 +2302,12 @@ impl<'a> LoweringContext<'a> {\n         itctx: ImplTraitContext<'_>,\n     ) -> hir::GenericBound {\n         match *tpb {\n-            GenericBound::Trait(ref ty, modifier) => hir::GenericBound::Trait(\n-                self.lower_poly_trait_ref(ty, itctx),\n-                self.lower_trait_bound_modifier(modifier),\n-            ),\n+            GenericBound::Trait(ref ty, modifier) => {\n+                hir::GenericBound::Trait(\n+                    self.lower_poly_trait_ref(ty, itctx),\n+                    self.lower_trait_bound_modifier(modifier),\n+                )\n+            }\n             GenericBound::Outlives(ref lifetime) => {\n                 hir::GenericBound::Outlives(self.lower_lifetime(lifetime))\n             }\n@@ -2318,6 +2329,8 @@ impl<'a> LoweringContext<'a> {\n                     AnonymousLifetimeMode::PassThrough => {\n                         self.new_named_lifetime(l.id, span, hir::LifetimeName::Underscore)\n                     }\n+\n+                    AnonymousLifetimeMode::ReportError => self.new_error_lifetime(Some(l.id), span),\n                 },\n             ident => {\n                 self.maybe_collect_in_band_lifetime(ident);\n@@ -2356,16 +2369,26 @@ impl<'a> LoweringContext<'a> {\n                            add_bounds: &NodeMap<Vec<GenericBound>>,\n                            mut itctx: ImplTraitContext<'_>)\n                            -> hir::GenericParam {\n-        let mut bounds = self.lower_param_bounds(&param.bounds, itctx.reborrow());\n+        let mut bounds = self.with_anonymous_lifetime_mode(\n+            AnonymousLifetimeMode::ReportError,\n+            |this| this.lower_param_bounds(&param.bounds, itctx.reborrow()),\n+        );\n+\n         match param.kind {\n             GenericParamKind::Lifetime => {\n                 let was_collecting_in_band = self.is_collecting_in_band_lifetimes;\n                 self.is_collecting_in_band_lifetimes = false;\n \n-                let lt = self.lower_lifetime(&Lifetime { id: param.id, ident: param.ident });\n+                let lt = self.with_anonymous_lifetime_mode(\n+                    AnonymousLifetimeMode::ReportError,\n+                    |this| this.lower_lifetime(&Lifetime { id: param.id, ident: param.ident }),\n+                );\n                 let param_name = match lt.name {\n                     hir::LifetimeName::Param(param_name) => param_name,\n-                    _ => hir::ParamName::Plain(lt.name.ident()),\n+                    hir::LifetimeName::Implicit\n+                        | hir::LifetimeName::Underscore\n+                        | hir::LifetimeName::Static => hir::ParamName::Plain(lt.name.ident()),\n+                    hir::LifetimeName::Error => ParamName::Error,\n                 };\n                 let param = hir::GenericParam {\n                     id: lt.id,\n@@ -2489,13 +2512,18 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause {\n-        hir::WhereClause {\n-            id: self.lower_node_id(wc.id).node_id,\n-            predicates: wc.predicates\n-                .iter()\n-                .map(|predicate| self.lower_where_predicate(predicate))\n-                .collect(),\n-        }\n+        self.with_anonymous_lifetime_mode(\n+            AnonymousLifetimeMode::ReportError,\n+            |this| {\n+                hir::WhereClause {\n+                    id: this.lower_node_id(wc.id).node_id,\n+                    predicates: wc.predicates\n+                        .iter()\n+                        .map(|predicate| this.lower_where_predicate(predicate))\n+                        .collect(),\n+                }\n+            },\n+        )\n     }\n \n     fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate {\n@@ -4837,10 +4865,38 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n \n+            AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n+\n             AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n         }\n     }\n \n+    /// Report an error on illegal use of `'_` or a `&T` with no explicit lifetime;\n+    /// return a \"error lifetime\".\n+    fn new_error_lifetime(&mut self, id: Option<NodeId>, span: Span) -> hir::Lifetime {\n+        let (id, msg, label) = match id {\n+            Some(id) => (id, \"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\"),\n+\n+            None => (\n+                self.next_id().node_id,\n+                \"`&` without an explicit lifetime name cannot be used here\",\n+                \"explicit lifetime name needed here\",\n+            ),\n+        };\n+\n+        let mut err = struct_span_err!(\n+            self.sess,\n+            span,\n+            E0637,\n+            \"{}\",\n+            msg,\n+        );\n+        err.span_label(span, label);\n+        err.emit();\n+\n+        self.new_named_lifetime(id, span, hir::LifetimeName::Error)\n+    }\n+\n     /// Invoked to create the lifetime argument(s) for a path like\n     /// `std::cell::Ref<T>`; note that implicit lifetimes in these\n     /// sorts of cases are deprecated. This may therefore report a warning or an\n@@ -4855,6 +4911,12 @@ impl<'a> LoweringContext<'a> {\n             //     impl Foo for std::cell::Ref<u32> // note lack of '_\n             AnonymousLifetimeMode::CreateParameter => {}\n \n+            AnonymousLifetimeMode::ReportError => {\n+                return (0..count)\n+                    .map(|_| self.new_error_lifetime(None, span))\n+                    .collect();\n+            }\n+\n             // This is the normal case.\n             AnonymousLifetimeMode::PassThrough => {}\n         }\n@@ -4885,6 +4947,10 @@ impl<'a> LoweringContext<'a> {\n             // `resolve_lifetime` has the code to make that happen.\n             AnonymousLifetimeMode::CreateParameter => {}\n \n+            AnonymousLifetimeMode::ReportError => {\n+                // ReportError applies to explicit use of `'_`.\n+            }\n+\n             // This is the normal case.\n             AnonymousLifetimeMode::PassThrough => {}\n         }"}, {"sha": "d5de6197a2e486d37076326a9a429c4af1c06a25", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -208,13 +208,18 @@ pub enum ParamName {\n     /// where `'f` is something like `Fresh(0)`. The indices are\n     /// unique per impl, but not necessarily continuous.\n     Fresh(usize),\n+\n+    /// Indicates an illegal name was given and an error has been\n+    /// repored (so we should squelch other derived errors). Occurs\n+    /// when e.g. `'_` is used in the wrong place.\n+    Error,\n }\n \n impl ParamName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n             ParamName::Plain(ident) => ident,\n-            ParamName::Fresh(_) => keywords::UnderscoreLifetime.ident(),\n+            ParamName::Error | ParamName::Fresh(_) => keywords::UnderscoreLifetime.ident(),\n         }\n     }\n \n@@ -234,6 +239,10 @@ pub enum LifetimeName {\n     /// User typed nothing. e.g. the lifetime in `&u32`.\n     Implicit,\n \n+    /// Indicates an error during lowering (usually `'_` in wrong place)\n+    /// that was already reported.\n+    Error,\n+\n     /// User typed `'_`.\n     Underscore,\n \n@@ -245,6 +254,7 @@ impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n             LifetimeName::Implicit => keywords::Invalid.ident(),\n+            LifetimeName::Error => keywords::Invalid.ident(),\n             LifetimeName::Underscore => keywords::UnderscoreLifetime.ident(),\n             LifetimeName::Static => keywords::StaticLifetime.ident(),\n             LifetimeName::Param(param_name) => param_name.ident(),\n@@ -260,7 +270,7 @@ impl LifetimeName {\n             // in the compiler is concerned -- `Fresh(_)` variants act\n             // equivalently to \"some fresh name\". They correspond to\n             // early-bound regions on an impl, in other words.\n-            LifetimeName::Param(_) | LifetimeName::Static => false,\n+            LifetimeName::Error | LifetimeName::Param(_) | LifetimeName::Static => false,\n         }\n     }\n \n@@ -513,6 +523,9 @@ pub enum LifetimeParamKind {\n     // Indication that the lifetime was elided like both cases here:\n     // `fn foo(x: &u8) -> &'_ u8 { x }`\n     Elided,\n+\n+    // Indication that the lifetime name was somehow in error.\n+    Error,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "a48bd4eeb09a32eb5b6726280581e087bf992898", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -144,14 +144,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n \n impl_stable_hash_for!(enum hir::ParamName {\n     Plain(name),\n-    Fresh(index)\n+    Fresh(index),\n+    Error,\n });\n \n impl_stable_hash_for!(enum hir::LifetimeName {\n     Param(param_name),\n     Implicit,\n     Underscore,\n     Static,\n+    Error,\n });\n \n impl_stable_hash_for!(struct hir::Label {\n@@ -210,7 +212,8 @@ impl_stable_hash_for!(struct hir::GenericParam {\n impl_stable_hash_for!(enum hir::LifetimeParamKind {\n     Explicit,\n     InBand,\n-    Elided\n+    Elided,\n+    Error,\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::GenericParamKind {"}, {"sha": "10e73fb636c9a69c6918b009dc5a0fa9582e0b77", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -755,8 +755,9 @@ for ::middle::resolve_lifetime::Set1<T>\n }\n \n impl_stable_hash_for!(enum ::middle::resolve_lifetime::LifetimeDefOrigin {\n-    Explicit,\n-    InBand\n+    ExplicitOrElided,\n+    InBand,\n+    Error,\n });\n \n impl_stable_hash_for!(enum ::middle::resolve_lifetime::Region {"}, {"sha": "b22ea3dceb3678bc5a3305805406980876bcb241", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 395, "deletions": 312, "changes": 707, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -18,8 +18,8 @@\n use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use hir::map::Map;\n-use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, ParamName, Node};\n-use ty::{self, TyCtxt, DefIdTree, GenericParamDefKind};\n+use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, Node, ParamName};\n+use ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n \n use errors::{Applicability, DiagnosticBuilder};\n use rustc::lint;\n@@ -43,22 +43,23 @@ use hir::{self, GenericParamKind, LifetimeParamKind};\n /// This is used to prevent the usage of in-band lifetimes in `Fn`/`fn` syntax.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum LifetimeDefOrigin {\n-    // Explicit binders like `fn foo<'a>(x: &'a u8)`\n-    Explicit,\n+    // Explicit binders like `fn foo<'a>(x: &'a u8)` or elided like `impl Foo<&u32>`\n+    ExplicitOrElided,\n     // In-band declarations like `fn foo(x: &'a u8)`\n     InBand,\n+    // Some kind of erroneous origin\n+    Error,\n }\n \n impl LifetimeDefOrigin {\n     fn from_param(param: &GenericParam) -> Self {\n         match param.kind {\n-            GenericParamKind::Lifetime { kind } => {\n-                if kind == LifetimeParamKind::InBand {\n-                    LifetimeDefOrigin::InBand\n-                } else {\n-                    LifetimeDefOrigin::Explicit\n-                }\n-            }\n+            GenericParamKind::Lifetime { kind } => match kind {\n+                LifetimeParamKind::InBand => LifetimeDefOrigin::InBand,\n+                LifetimeParamKind::Explicit => LifetimeDefOrigin::ExplicitOrElided,\n+                LifetimeParamKind::Elided => LifetimeDefOrigin::ExplicitOrElided,\n+                LifetimeParamKind::Error => LifetimeDefOrigin::Error,\n+            },\n             _ => bug!(\"expected a lifetime param\"),\n         }\n     }\n@@ -104,12 +105,12 @@ impl Region {\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n-            param,\n-            depth,\n-            def_id,\n-            origin,\n+            param, depth, def_id, origin,\n         );\n-        (param.name.modern(), Region::LateBound(depth, def_id, origin))\n+        (\n+            param.name.modern(),\n+            Region::LateBound(depth, def_id, origin),\n+        )\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -143,23 +144,24 @@ impl Region {\n \n     fn shifted_out_to_binder(self, binder: ty::DebruijnIndex) -> Region {\n         match self {\n-            Region::LateBound(debruijn, id, origin) => Region::LateBound(\n-                debruijn.shifted_out_to_binder(binder),\n-                id,\n-                origin,\n-            ),\n-            Region::LateBoundAnon(debruijn, index) => Region::LateBoundAnon(\n-                debruijn.shifted_out_to_binder(binder),\n-                index,\n-            ),\n+            Region::LateBound(debruijn, id, origin) => {\n+                Region::LateBound(debruijn.shifted_out_to_binder(binder), id, origin)\n+            }\n+            Region::LateBoundAnon(debruijn, index) => {\n+                Region::LateBoundAnon(debruijn.shifted_out_to_binder(binder), index)\n+            }\n             _ => self,\n         }\n     }\n \n     fn subst<'a, L>(self, mut params: L, map: &NamedRegionMap) -> Option<Region>\n-            where L: Iterator<Item = &'a hir::Lifetime>  {\n+    where\n+        L: Iterator<Item = &'a hir::Lifetime>,\n+    {\n         if let Region::EarlyBound(index, _, _) = self {\n-            params.nth(index as usize).and_then(|lifetime| map.defs.get(&lifetime.id).cloned())\n+            params\n+                .nth(index as usize)\n+                .and_then(|lifetime| map.defs.get(&lifetime.id).cloned())\n         } else {\n             Some(self)\n         }\n@@ -361,17 +363,17 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         is_late_bound_map: |tcx, id| {\n             let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n             tcx.resolve_lifetimes(LOCAL_CRATE)\n-               .late_bound\n-               .get(&id)\n-               .cloned()\n+                .late_bound\n+                .get(&id)\n+                .cloned()\n         },\n \n         object_lifetime_defaults_map: |tcx, id| {\n             let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n             tcx.resolve_lifetimes(LOCAL_CRATE)\n-               .object_lifetime_defaults\n-               .get(&id)\n-               .cloned()\n+                .object_lifetime_defaults\n+                .get(&id)\n+                .cloned()\n         },\n \n         ..*providers\n@@ -405,14 +407,16 @@ fn resolve_lifetimes<'tcx>(\n     }\n     for k in named_region_map.late_bound {\n         let hir_id = tcx.hir.node_to_hir_id(k);\n-        let map = rl.late_bound.entry(hir_id.owner_local_def_id()).or_default();\n+        let map = rl.late_bound\n+            .entry(hir_id.owner_local_def_id())\n+            .or_default();\n         Lrc::get_mut(map).unwrap().insert(hir_id.local_id);\n     }\n     for (k, v) in named_region_map.object_lifetime_defaults {\n         let hir_id = tcx.hir.node_to_hir_id(k);\n         let map = rl.object_lifetime_defaults\n-                    .entry(hir_id.owner_local_def_id())\n-                    .or_default();\n+            .entry(hir_id.owner_local_def_id())\n+            .or_default();\n         Lrc::get_mut(map)\n             .unwrap()\n             .insert(hir_id.local_id, Lrc::new(v));\n@@ -495,13 +499,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |_, this| intravisit::walk_item(this, item));\n             }\n-            hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n+            hir::ItemKind::Existential(hir::ExistTy {\n+                impl_trait_fn: Some(_),\n+                ..\n+            }) => {\n                 // currently existential type declarations are just generated from impl Trait\n                 // items. doing anything on this node is irrelevant, as we currently don't need\n                 // it.\n             }\n             hir::ItemKind::Ty(_, ref generics)\n-            | hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: None, ref generics, .. })\n+            | hir::ItemKind::Existential(hir::ExistTy {\n+                impl_trait_fn: None,\n+                ref generics,\n+                ..\n+            })\n             | hir::ItemKind::Enum(_, ref generics)\n             | hir::ItemKind::Struct(_, ref generics)\n             | hir::ItemKind::Union(_, ref generics)\n@@ -521,15 +532,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     0\n                 };\n                 let mut type_count = 0;\n-                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Some(Region::early(&self.tcx.hir, &mut index, param))\n-                    }\n-                    GenericParamKind::Type { .. } => {\n-                        type_count += 1;\n-                        None\n-                    }\n-                }).collect();\n+                let lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            type_count += 1;\n+                            None\n+                        }\n+                    })\n+                    .collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index: index + type_count,\n@@ -569,12 +584,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let was_in_fn_syntax = self.is_in_fn_syntax;\n                 self.is_in_fn_syntax = true;\n                 let scope = Scope::Binder {\n-                    lifetimes: c.generic_params.iter().filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::late(&self.tcx.hir, param))\n-                        }\n-                        _ => None,\n-                    }).collect(),\n+                    lifetimes: c.generic_params\n+                        .iter()\n+                        .filter_map(|param| match param.kind {\n+                            GenericParamKind::Lifetime { .. } => {\n+                                Some(Region::late(&self.tcx.hir, param))\n+                            }\n+                            _ => None,\n+                        })\n+                        .collect(),\n                     s: self.scope,\n                     next_early_index,\n                     track_lifetime_uses: true,\n@@ -612,6 +630,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // If the user wrote an explicit name, use that.\n                         self.visit_lifetime(lifetime);\n                     }\n+                    LifetimeName::Error => {}\n                 }\n             }\n             hir::TyKind::Rptr(ref lifetime_ref, ref mt) => {\n@@ -631,19 +650,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let (generics, bounds) = match self.tcx.hir.expect_item(item_id.id).node {\n                     // named existential types are reached via TyKind::Path\n                     // this arm is for `impl Trait` in the types of statics, constants and locals\n-                    hir::ItemKind::Existential(hir::ExistTy{ impl_trait_fn: None, .. }) => {\n+                    hir::ItemKind::Existential(hir::ExistTy {\n+                        impl_trait_fn: None,\n+                        ..\n+                    }) => {\n                         intravisit::walk_ty(self, ty);\n                         return;\n-                    },\n+                    }\n                     // RPIT (return position impl trait)\n-                    hir::ItemKind::Existential(hir::ExistTy{\n+                    hir::ItemKind::Existential(hir::ExistTy {\n                         ref generics,\n                         ref bounds,\n                         ..\n-                    }) => (\n-                        generics,\n-                        bounds,\n-                    ),\n+                    }) => (generics, bounds),\n                     ref i => bug!(\"impl Trait pointed to non-existential type?? {:#?}\", i),\n                 };\n \n@@ -774,15 +793,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n                 let mut type_count = 0;\n-                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Some(Region::early(&self.tcx.hir, &mut index, param))\n-                    }\n-                    GenericParamKind::Type { .. } => {\n-                        type_count += 1;\n-                        None\n-                    }\n-                }).collect();\n+                let lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            type_count += 1;\n+                            None\n+                        }\n+                    })\n+                    .collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index: index + type_count,\n@@ -825,15 +848,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 let mut next_early_index = index;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Some(Region::early(&self.tcx.hir, &mut index, param))\n-                    }\n-                    GenericParamKind::Type { .. } => {\n-                        next_early_index += 1;\n-                        None\n-                    }\n-                }).collect();\n+                let lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            next_early_index += 1;\n+                            None\n+                        }\n+                    })\n+                    .collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index,\n@@ -851,15 +878,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 let mut next_early_index = index;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Some(Region::early(&self.tcx.hir, &mut index, param))\n-                    }\n-                    GenericParamKind::Type { .. } => {\n-                        next_early_index += 1;\n-                        None\n-                    }\n-                }).collect();\n+                let lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            next_early_index += 1;\n+                            None\n+                        }\n+                    })\n+                    .collect();\n \n                 let scope = Scope::Binder {\n                     lifetimes,\n@@ -933,13 +964,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     ref bound_generic_params,\n                     ..\n                 }) => {\n-                    let lifetimes: FxHashMap<_, _> = bound_generic_params.iter()\n+                    let lifetimes: FxHashMap<_, _> = bound_generic_params\n+                        .iter()\n                         .filter_map(|param| match param.kind {\n                             GenericParamKind::Lifetime { .. } => {\n                                 Some(Region::late(&self.tcx.hir, param))\n                             }\n                             _ => None,\n-                        }).collect();\n+                        })\n+                        .collect();\n                     if !lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n                         let next_early_index = self.next_early_index();\n@@ -989,15 +1022,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n-        if !self.trait_ref_hack\n-            || trait_ref\n-                .bound_generic_params\n-                .iter()\n-                .any(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => true,\n-                    _ => false,\n-                })\n-        {\n+        if !self.trait_ref_hack || trait_ref.bound_generic_params.iter().any(|param| {\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => true,\n+                _ => false,\n+            }\n+        }) {\n             if self.trait_ref_hack {\n                 span_err!(\n                     self.tcx.sess,\n@@ -1008,13 +1038,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             let next_early_index = self.next_early_index();\n             let scope = Scope::Binder {\n-                lifetimes: trait_ref.bound_generic_params.iter()\n+                lifetimes: trait_ref\n+                    .bound_generic_params\n+                    .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n                             Some(Region::late(&self.tcx.hir, param))\n                         }\n                         _ => None,\n-                    }).collect(),\n+                    })\n+                    .collect(),\n                 s: self.scope,\n                 next_early_index,\n                 track_lifetime_uses: true,\n@@ -1079,29 +1112,30 @@ impl ShadowKind {\n     }\n }\n \n-fn check_mixed_explicit_and_in_band_defs(\n-    tcx: TyCtxt<'_, '_, '_>,\n-    params: &P<[hir::GenericParam]>,\n-) {\n-    let lifetime_params: Vec<_> = params.iter().filter_map(|param| match param.kind {\n-        GenericParamKind::Lifetime { kind, .. } => Some((kind, param.span)),\n-        _ => None,\n-    }).collect();\n-    let explicit = lifetime_params.iter().find(|(kind, _)| *kind == LifetimeParamKind::Explicit);\n-    let in_band = lifetime_params.iter().find(|(kind, _)| *kind == LifetimeParamKind::InBand);\n-\n-    if let (Some((_, explicit_span)), Some((_, in_band_span)))\n-        = (explicit, in_band) {\n+fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_, '_, '_>, params: &P<[hir::GenericParam]>) {\n+    let lifetime_params: Vec<_> = params\n+        .iter()\n+        .filter_map(|param| match param.kind {\n+            GenericParamKind::Lifetime { kind, .. } => Some((kind, param.span)),\n+            _ => None,\n+        })\n+        .collect();\n+    let explicit = lifetime_params\n+        .iter()\n+        .find(|(kind, _)| *kind == LifetimeParamKind::Explicit);\n+    let in_band = lifetime_params\n+        .iter()\n+        .find(|(kind, _)| *kind == LifetimeParamKind::InBand);\n+\n+    if let (Some((_, explicit_span)), Some((_, in_band_span))) = (explicit, in_band) {\n         struct_span_err!(\n             tcx.sess,\n             *in_band_span,\n             E0688,\n             \"cannot mix in-band and explicit lifetime definitions\"\n-        ).span_label(\n-            *in_band_span,\n-            \"in-band lifetime definition here\",\n-        ).span_label(*explicit_span, \"explicit lifetime definition here\")\n-        .emit();\n+        ).span_label(*in_band_span, \"in-band lifetime definition here\")\n+            .span_label(*explicit_span, \"explicit lifetime definition here\")\n+            .emit();\n     }\n }\n \n@@ -1187,8 +1221,9 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n \n     fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n         match ex.node {\n-            hir::ExprKind::While(.., Some(label)) |\n-            hir::ExprKind::Loop(_, Some(label), _) => Some(label.ident),\n+            hir::ExprKind::While(.., Some(label)) | hir::ExprKind::Loop(_, Some(label), _) => {\n+                Some(label.ident)\n+            }\n             _ => None,\n         }\n     }\n@@ -1241,7 +1276,11 @@ fn compute_object_lifetime_defaults(\n             hir::ItemKind::Struct(_, ref generics)\n             | hir::ItemKind::Union(_, ref generics)\n             | hir::ItemKind::Enum(_, ref generics)\n-            | hir::ItemKind::Existential(hir::ExistTy { ref generics, impl_trait_fn: None, .. })\n+            | hir::ItemKind::Existential(hir::ExistTy {\n+                ref generics,\n+                impl_trait_fn: None,\n+                ..\n+            })\n             | hir::ItemKind::Ty(_, ref generics)\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n                 let result = object_lifetime_defaults_for_item(tcx, generics);\n@@ -1253,8 +1292,10 @@ fn compute_object_lifetime_defaults(\n                         .map(|set| match *set {\n                             Set1::Empty => \"BaseDefault\".into(),\n                             Set1::One(Region::Static) => \"'static\".into(),\n-                            Set1::One(Region::EarlyBound(mut i, _, _)) => {\n-                                generics.params.iter().find_map(|param| match param.kind {\n+                            Set1::One(Region::EarlyBound(mut i, _, _)) => generics\n+                                .params\n+                                .iter()\n+                                .find_map(|param| match param.kind {\n                                     GenericParamKind::Lifetime { .. } => {\n                                         if i == 0 {\n                                             return Some(param.name.ident().to_string().into());\n@@ -1263,8 +1304,8 @@ fn compute_object_lifetime_defaults(\n                                         None\n                                     }\n                                     _ => None,\n-                                }).unwrap()\n-                            }\n+                                })\n+                                .unwrap(),\n                             Set1::One(_) => bug!(),\n                             Set1::Many => \"Ambiguous\".into(),\n                         })\n@@ -1296,66 +1337,70 @@ fn object_lifetime_defaults_for_item(\n         }\n     }\n \n-    generics.params.iter().filter_map(|param| match param.kind {\n-        GenericParamKind::Lifetime { .. } => None,\n-        GenericParamKind::Type { .. } => {\n-            let mut set = Set1::Empty;\n+    generics\n+        .params\n+        .iter()\n+        .filter_map(|param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => None,\n+            GenericParamKind::Type { .. } => {\n+                let mut set = Set1::Empty;\n \n-            add_bounds(&mut set, &param.bounds);\n+                add_bounds(&mut set, &param.bounds);\n \n-            let param_def_id = tcx.hir.local_def_id(param.id);\n-            for predicate in &generics.where_clause.predicates {\n-                // Look for `type: ...` where clauses.\n-                let data = match *predicate {\n-                    hir::WherePredicate::BoundPredicate(ref data) => data,\n-                    _ => continue,\n-                };\n+                let param_def_id = tcx.hir.local_def_id(param.id);\n+                for predicate in &generics.where_clause.predicates {\n+                    // Look for `type: ...` where clauses.\n+                    let data = match *predicate {\n+                        hir::WherePredicate::BoundPredicate(ref data) => data,\n+                        _ => continue,\n+                    };\n \n-                // Ignore `for<'a> type: ...` as they can change what\n-                // lifetimes mean (although we could \"just\" handle it).\n-                if !data.bound_generic_params.is_empty() {\n-                    continue;\n-                }\n+                    // Ignore `for<'a> type: ...` as they can change what\n+                    // lifetimes mean (although we could \"just\" handle it).\n+                    if !data.bound_generic_params.is_empty() {\n+                        continue;\n+                    }\n \n-                let def = match data.bounded_ty.node {\n-                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.def,\n-                    _ => continue,\n-                };\n+                    let def = match data.bounded_ty.node {\n+                        hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.def,\n+                        _ => continue,\n+                    };\n \n-                if def == Def::TyParam(param_def_id) {\n-                    add_bounds(&mut set, &data.bounds);\n+                    if def == Def::TyParam(param_def_id) {\n+                        add_bounds(&mut set, &data.bounds);\n+                    }\n                 }\n-            }\n \n-            Some(match set {\n-                Set1::Empty => Set1::Empty,\n-                Set1::One(name) => {\n-                    if name == hir::LifetimeName::Static {\n-                        Set1::One(Region::Static)\n-                    } else {\n-                        generics.params.iter().filter_map(|param| match param.kind {\n-                            GenericParamKind::Lifetime { .. } => {\n-                                Some((\n-                                    param.id,\n-                                    hir::LifetimeName::Param(param.name),\n-                                    LifetimeDefOrigin::from_param(param),\n-                                ))\n-                            }\n-                            _ => None,\n-                        })\n-                        .enumerate()\n-                        .find(|&(_, (_, lt_name, _))| lt_name == name)\n-                        .map_or(Set1::Many, |(i, (id, _, origin))| {\n-                            let def_id = tcx.hir.local_def_id(id);\n-                            Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n-                        })\n+                Some(match set {\n+                    Set1::Empty => Set1::Empty,\n+                    Set1::One(name) => {\n+                        if name == hir::LifetimeName::Static {\n+                            Set1::One(Region::Static)\n+                        } else {\n+                            generics\n+                                .params\n+                                .iter()\n+                                .filter_map(|param| match param.kind {\n+                                    GenericParamKind::Lifetime { .. } => Some((\n+                                        param.id,\n+                                        hir::LifetimeName::Param(param.name),\n+                                        LifetimeDefOrigin::from_param(param),\n+                                    )),\n+                                    _ => None,\n+                                })\n+                                .enumerate()\n+                                .find(|&(_, (_, lt_name, _))| lt_name == name)\n+                                .map_or(Set1::Many, |(i, (id, _, origin))| {\n+                                    let def_id = tcx.hir.local_def_id(id);\n+                                    Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n+                                })\n+                        }\n                     }\n-                }\n-                Set1::Many => Set1::Many,\n-            })\n-        }\n-    })\n-    .collect()\n+                    Set1::Many => Set1::Many,\n+                })\n+            }\n+        })\n+        .collect()\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n@@ -1405,20 +1450,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             // if sole lifetime, remove the `<>` brackets\n             Some(generics.span)\n         } else {\n-            generics.params.iter().enumerate()\n-                .find_map(|(i, param)| {\n-                    if param.name.ident() == name {\n-                        // We also want to delete a leading or trailing comma\n-                        // as appropriate\n-                        if i >= generics.params.len() - 1 {\n-                            Some(generics.params[i-1].span.shrink_to_hi().to(param.span))\n-                        } else {\n-                            Some(param.span.to(generics.params[i+1].span.shrink_to_lo()))\n-                        }\n+            generics.params.iter().enumerate().find_map(|(i, param)| {\n+                if param.name.ident() == name {\n+                    // We also want to delete a leading or trailing comma\n+                    // as appropriate\n+                    if i >= generics.params.len() - 1 {\n+                        Some(generics.params[i - 1].span.shrink_to_hi().to(param.span))\n                     } else {\n-                        None\n+                        Some(param.span.to(generics.params[i + 1].span.shrink_to_lo()))\n                     }\n-                })\n+                } else {\n+                    None\n+                }\n+            })\n         }\n     }\n \n@@ -1431,7 +1475,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        let mut def_ids: Vec<_> = defined_by.values()\n+        let mut def_ids: Vec<_> = defined_by\n+            .values()\n             .flat_map(|region| match region {\n                 Region::EarlyBound(_, def_id, _)\n                 | Region::LateBound(_, def_id, _)\n@@ -1445,21 +1490,28 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         def_ids.sort_by_key(|&def_id| self.tcx.def_path_hash(def_id));\n \n         for def_id in def_ids {\n-            debug!(\"check_uses_for_lifetimes_defined_by_scope: def_id = {:?}\", def_id);\n+            debug!(\n+                \"check_uses_for_lifetimes_defined_by_scope: def_id = {:?}\",\n+                def_id\n+            );\n \n             let lifetimeuseset = self.lifetime_uses.remove(&def_id);\n \n-            debug!(\"check_uses_for_lifetimes_defined_by_scope: lifetimeuseset = {:?}\",\n-                   lifetimeuseset);\n+            debug!(\n+                \"check_uses_for_lifetimes_defined_by_scope: lifetimeuseset = {:?}\",\n+                lifetimeuseset\n+            );\n \n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     debug!(\"node id first={:?}\", node_id);\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n-                        Node::Lifetime(hir_lifetime) => {\n-                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n-                        }\n+                        Node::Lifetime(hir_lifetime) => Some((\n+                            hir_lifetime.id,\n+                            hir_lifetime.span,\n+                            hir_lifetime.name.ident(),\n+                        )),\n                         Node::GenericParam(param) => {\n                             Some((param.id, param.span, param.name.ident()))\n                         }\n@@ -1483,9 +1535,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 None => {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n-                        Node::Lifetime(hir_lifetime) => {\n-                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n-                        }\n+                        Node::Lifetime(hir_lifetime) => Some((\n+                            hir_lifetime.id,\n+                            hir_lifetime.span,\n+                            hir_lifetime.name.ident(),\n+                        )),\n                         Node::GenericParam(param) => {\n                             Some((param.id, param.span, param.name.ident()))\n                         }\n@@ -1496,7 +1550,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             lint::builtin::UNUSED_LIFETIMES,\n                             id,\n                             span,\n-                            &format!(\"lifetime parameter `{}` never used\", name)\n+                            &format!(\"lifetime parameter `{}` never used\", name),\n                         );\n                         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n                             if let Some(generics) = self.tcx.hir.get_generics(parent_def_id) {\n@@ -1506,7 +1560,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                         span,\n                                         \"remove it\",\n                                         String::new(),\n-                                        Applicability::MachineApplicable\n+                                        Applicability::MachineApplicable,\n                                     );\n                                 }\n                             }\n@@ -1564,19 +1618,23 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n \n         let mut type_count = 0;\n-        let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => {\n-                if self.map.late_bound.contains(&param.id) {\n-                    Some(Region::late(&self.tcx.hir, param))\n-                } else {\n-                    Some(Region::early(&self.tcx.hir, &mut index, param))\n+        let lifetimes = generics\n+            .params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    if self.map.late_bound.contains(&param.id) {\n+                        Some(Region::late(&self.tcx.hir, param))\n+                    } else {\n+                        Some(Region::early(&self.tcx.hir, &mut index, param))\n+                    }\n                 }\n-            }\n-            GenericParamKind::Type { .. } => {\n-                type_count += 1;\n-                None\n-            }\n-        }).collect();\n+                GenericParamKind::Type { .. } => {\n+                    type_count += 1;\n+                    None\n+                }\n+            })\n+            .collect();\n         let next_early_index = index + type_count;\n \n         let scope = Scope::Binder {\n@@ -1631,6 +1689,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n     fn resolve_lifetime_ref(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         debug!(\"resolve_lifetime_ref(lifetime_ref={:?})\", lifetime_ref);\n+\n+        // If we've already reported an error, just ignore `lifetime_ref`.\n+        if let LifetimeName::Error = lifetime_ref.name {\n+            return;\n+        }\n+\n         // Walk up the scope chain, tracking the number of fn scopes\n         // that we pass through, until we find a lifetime with the\n         // given name or we run out of scopes.\n@@ -1649,17 +1713,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n-                Scope::Binder { ref lifetimes, s, .. } => {\n-                    let name = match lifetime_ref.name {\n-                        LifetimeName::Param(param_name) => param_name,\n+                Scope::Binder {\n+                    ref lifetimes, s, ..\n+                } => {\n+                    match lifetime_ref.name {\n+                        LifetimeName::Param(param_name) => {\n+                            if let Some(&def) = lifetimes.get(&param_name.modern()) {\n+                                break Some(def.shifted(late_depth));\n+                            }\n+                        }\n                         _ => bug!(\"expected LifetimeName::Param\"),\n-                    };\n-                    if let Some(&def) = lifetimes.get(&name.modern()) {\n-                        break Some(def.shifted(late_depth));\n-                    } else {\n-                        late_depth += 1;\n-                        scope = s;\n                     }\n+\n+                    late_depth += 1;\n+                    scope = s;\n                 }\n \n                 Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n@@ -1705,12 +1772,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             \"lifetimes used in `fn` or `Fn` syntax must be \\\n                              explicitly declared using `<...>` binders\"\n                         ).span_label(lifetime_ref.span, \"in-band lifetime definition\")\n-                         .emit();\n+                            .emit();\n                     }\n \n                     Region::Static\n-                    | Region::EarlyBound(_, _, LifetimeDefOrigin::Explicit)\n-                    | Region::LateBound(_, _, LifetimeDefOrigin::Explicit)\n+                    | Region::EarlyBound(_, _, LifetimeDefOrigin::ExplicitOrElided)\n+                    | Region::LateBound(_, _, LifetimeDefOrigin::ExplicitOrElided)\n+                    | Region::EarlyBound(_, _, LifetimeDefOrigin::Error)\n+                    | Region::LateBound(_, _, LifetimeDefOrigin::Error)\n                     | Region::LateBoundAnon(..)\n                     | Region::Free(..) => {}\n                 }\n@@ -1725,35 +1794,33 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 \"use of undeclared lifetime name `{}`\",\n                 lifetime_ref\n             ).span_label(lifetime_ref.span, \"undeclared lifetime\")\n-             .emit();\n+                .emit();\n         }\n     }\n \n-    fn visit_segment_args(\n-        &mut self,\n-        def: Def,\n-        depth: usize,\n-        generic_args: &'tcx hir::GenericArgs,\n-    ) {\n+    fn visit_segment_args(&mut self, def: Def, depth: usize, generic_args: &'tcx hir::GenericArgs) {\n         if generic_args.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n-            self.visit_fn_like_elision(generic_args.inputs(),\n-                                       Some(&generic_args.bindings[0].ty));\n+            self.visit_fn_like_elision(generic_args.inputs(), Some(&generic_args.bindings[0].ty));\n             self.is_in_fn_syntax = was_in_fn_syntax;\n             return;\n         }\n \n         let mut elide_lifetimes = true;\n-        let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n-            hir::GenericArg::Lifetime(lt) => {\n-                if !lt.is_elided() {\n-                    elide_lifetimes = false;\n+        let lifetimes = generic_args\n+            .args\n+            .iter()\n+            .filter_map(|arg| match arg {\n+                hir::GenericArg::Lifetime(lt) => {\n+                    if !lt.is_elided() {\n+                        elide_lifetimes = false;\n+                    }\n+                    Some(lt)\n                 }\n-                Some(lt)\n-            }\n-            _ => None,\n-        }).collect();\n+                _ => None,\n+            })\n+            .collect();\n         if elide_lifetimes {\n             self.resolve_elided_lifetimes(lifetimes);\n         } else {\n@@ -1809,33 +1876,37 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 self.xcrate_object_lifetime_defaults\n                     .entry(def_id)\n                     .or_insert_with(|| {\n-                        tcx.generics_of(def_id).params.iter().filter_map(|param| {\n-                            match param.kind {\n-                                GenericParamDefKind::Type { object_lifetime_default, .. } => {\n-                                    Some(object_lifetime_default)\n-                                }\n+                        tcx.generics_of(def_id)\n+                            .params\n+                            .iter()\n+                            .filter_map(|param| match param.kind {\n+                                GenericParamDefKind::Type {\n+                                    object_lifetime_default,\n+                                    ..\n+                                } => Some(object_lifetime_default),\n                                 GenericParamDefKind::Lifetime => None,\n-                            }\n-                        }).collect()\n+                            })\n+                            .collect()\n                     })\n             };\n-            unsubst.iter()\n-                   .map(|set| match *set {\n-                       Set1::Empty => if in_body {\n-                           None\n-                       } else {\n-                           Some(Region::Static)\n-                       },\n-                       Set1::One(r) => {\n-                           let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n-                               GenericArg::Lifetime(lt) => Some(lt),\n-                               _ => None,\n-                           });\n-                           r.subst(lifetimes, map)\n-                       }\n-                       Set1::Many => None,\n-                   })\n-                   .collect()\n+            unsubst\n+                .iter()\n+                .map(|set| match *set {\n+                    Set1::Empty => if in_body {\n+                        None\n+                    } else {\n+                        Some(Region::Static)\n+                    },\n+                    Set1::One(r) => {\n+                        let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Lifetime(lt) => Some(lt),\n+                            _ => None,\n+                        });\n+                        r.subst(lifetimes, map)\n+                    }\n+                    Set1::Many => None,\n+                })\n+                .collect()\n         });\n \n         let mut i = 0;\n@@ -1862,11 +1933,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_fn_like_elision(\n-        &mut self,\n-        inputs: &'tcx [hir::Ty],\n-        output: Option<&'tcx P<hir::Ty>>,\n-    ) {\n+    fn visit_fn_like_elision(&mut self, inputs: &'tcx [hir::Ty], output: Option<&'tcx P<hir::Ty>>) {\n         debug!(\"visit_fn_like_elision: enter\");\n         let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n         let arg_scope = Scope::Elision {\n@@ -2126,8 +2193,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn resolve_elided_lifetimes(&mut self,\n-                                lifetime_refs: Vec<&'tcx hir::Lifetime>) {\n+    fn resolve_elided_lifetimes(&mut self, lifetime_refs: Vec<&'tcx hir::Lifetime>) {\n         if lifetime_refs.is_empty() {\n             return;\n         }\n@@ -2285,23 +2351,32 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n-                Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l,\n+                Scope::ObjectLifetimeDefault {\n+                    lifetime: Some(l), ..\n+                } => break l,\n             }\n         };\n         self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n     }\n \n-    fn check_lifetime_params(&mut self, old_scope: ScopeRef<'_>,\n-                             params: &'tcx [hir::GenericParam]) {\n-        let lifetimes: Vec<_> = params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => Some((param, param.name)),\n-            _ => None,\n-        }).collect();\n+    fn check_lifetime_params(\n+        &mut self,\n+        old_scope: ScopeRef<'_>,\n+        params: &'tcx [hir::GenericParam],\n+    ) {\n+        let lifetimes: Vec<_> = params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => Some((param, param.name)),\n+                _ => None,\n+            })\n+            .collect();\n         for (i, (lifetime_i, lifetime_i_name)) in lifetimes.iter().enumerate() {\n             if let hir::ParamName::Plain(_) = lifetime_i_name {\n                 let name = lifetime_i_name.ident().name;\n-                if name == keywords::UnderscoreLifetime.name() ||\n-                   name == keywords::StaticLifetime.name() {\n+                if name == keywords::UnderscoreLifetime.name()\n+                    || name == keywords::StaticLifetime.name()\n+                {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n                         lifetime_i.span,\n@@ -2327,8 +2402,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         \"lifetime name `{}` declared twice in the same scope\",\n                         lifetime_j.name.ident()\n                     ).span_label(lifetime_j.span, \"declared twice\")\n-                     .span_label(lifetime_i.span, \"previous declaration here\")\n-                     .emit();\n+                        .span_label(lifetime_i.span, \"previous declaration here\")\n+                        .emit();\n                 }\n             }\n \n@@ -2338,33 +2413,34 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             for bound in &lifetime_i.bounds {\n                 match bound {\n                     hir::GenericBound::Outlives(lt) => match lt.name {\n-                        hir::LifetimeName::Underscore => {\n-                            let mut err = struct_span_err!(\n-                                self.tcx.sess,\n-                                lt.span,\n-                                E0637,\n-                                \"invalid lifetime bound name: `'_`\"\n-                            );\n-                            err.span_label(lt.span, \"`'_` is a reserved lifetime name\");\n-                            err.emit();\n-                        }\n+                        hir::LifetimeName::Underscore => self.tcx.sess.delay_span_bug(\n+                            lt.span,\n+                            \"use of `'_` in illegal place, but not caught by lowering\",\n+                        ),\n                         hir::LifetimeName::Static => {\n                             self.insert_lifetime(lt, Region::Static);\n-                            self.tcx.sess.struct_span_warn(\n-                                lifetime_i.span.to(lt.span),\n-                                &format!(\n-                                    \"unnecessary lifetime parameter `{}`\",\n+                            self.tcx\n+                                .sess\n+                                .struct_span_warn(\n+                                    lifetime_i.span.to(lt.span),\n+                                    &format!(\n+                                        \"unnecessary lifetime parameter `{}`\",\n+                                        lifetime_i.name.ident(),\n+                                    ),\n+                                )\n+                                .help(&format!(\n+                                    \"you can use the `'static` lifetime directly, in place of `{}`\",\n                                     lifetime_i.name.ident(),\n-                                ),\n-                            ).help(&format!(\n-                                \"you can use the `'static` lifetime directly, in place of `{}`\",\n-                                lifetime_i.name.ident(),\n-                            )).emit();\n+                                ))\n+                                .emit();\n                         }\n                         hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit => {\n                             self.resolve_lifetime_ref(lt);\n                         }\n-                    }\n+                        hir::LifetimeName::Error => {\n+                            // No need to do anything, error already reported.\n+                        }\n+                    },\n                     _ => bug!(),\n                 }\n             }\n@@ -2533,8 +2609,10 @@ fn insert_late_bound_lifetimes(\n     decl: &hir::FnDecl,\n     generics: &hir::Generics,\n ) {\n-    debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\",\n-           decl, generics);\n+    debug!(\n+        \"insert_late_bound_lifetimes(decl={:?}, generics={:?})\",\n+        decl, generics\n+    );\n \n     let mut constrained_by_input = ConstrainedCollector {\n         regions: FxHashSet(),\n@@ -2548,8 +2626,10 @@ fn insert_late_bound_lifetimes(\n     };\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n \n-    debug!(\"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n-           constrained_by_input.regions);\n+    debug!(\n+        \"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n+        constrained_by_input.regions\n+    );\n \n     // Walk the lifetimes that appear in where clauses.\n     //\n@@ -2565,7 +2645,8 @@ fn insert_late_bound_lifetimes(\n             if !param.bounds.is_empty() {\n                 // `'a: 'b` means both `'a` and `'b` are referenced\n                 appears_in_where_clause\n-                    .regions.insert(hir::LifetimeName::Param(param.name.modern()));\n+                    .regions\n+                    .insert(hir::LifetimeName::Param(param.name.modern()));\n             }\n         }\n     }\n@@ -2600,9 +2681,11 @@ fn insert_late_bound_lifetimes(\n             continue;\n         }\n \n-        debug!(\"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n-               param.name.ident(),\n-               param.id);\n+        debug!(\n+            \"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n+            param.name.ident(),\n+            param.id\n+        );\n \n         let inserted = map.late_bound.insert(param.id);\n         assert!(inserted, \"visited lifetime {:?} twice\", param.id);"}, {"sha": "bc5f688729c368fa653bf2910f744246fe454261", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -2074,6 +2074,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n                     hir::GenericParamKind::Type { .. } => {\n                         match param.name {\n                             hir::ParamName::Fresh(_) => { continue; },\n+                            hir::ParamName::Error => { continue; },\n                             hir::ParamName::Plain(name) => name.to_string()\n                         }\n                     }"}, {"sha": "2b671891fca6dd00736c2b1257fda7f1b467300b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -562,6 +562,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let lifetime = self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n         match lifetime.name {\n             hir::LifetimeName::Param(_)\n+            | hir::LifetimeName::Error\n             | hir::LifetimeName::Static\n             | hir::LifetimeName::Underscore => {\n                 let region_name = self.synthesize_region_name(counter);"}, {"sha": "1b493f1c12ba14e36f70f097f5fe57b52820bd1c", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -830,7 +830,10 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         let param = &hir_generics.params[index];\n-        report_bivariance(tcx, param.span, param.name.ident().name);\n+        match param.name {\n+            hir::ParamName::Error => { }\n+            _ => report_bivariance(tcx, param.span, param.name.ident().name),\n+        }\n     }\n }\n "}, {"sha": "b4f769a749f80ae3b5484fb9354d7be7c44892ec", "filename": "src/test/ui/error-codes/E0637.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Ferror-codes%2FE0637.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Ferror-codes%2FE0637.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0637.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Foo<'a: '_>(&'a u8); //~ ERROR invalid lifetime bound name: `'_`\n-fn foo<'a: '_>(_: &'a u8) {} //~ ERROR invalid lifetime bound name: `'_`\n+struct Foo<'a: '_>(&'a u8); //~ ERROR cannot be used here\n+fn foo<'a: '_>(_: &'a u8) {} //~ ERROR cannot be used here\n \n struct Bar<'a>(&'a u8);\n-impl<'a: '_> Bar<'a> { //~ ERROR invalid lifetime bound name: `'_`\n+impl<'a: '_> Bar<'a> { //~ ERROR cannot be used here\n   fn bar() {}\n }\n "}, {"sha": "2a4545fc43d08d193293e3b8ec95fd9ace0ab77b", "filename": "src/test/ui/error-codes/E0637.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Ferror-codes%2FE0637.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Ferror-codes%2FE0637.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0637.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -1,19 +1,19 @@\n-error[E0637]: invalid lifetime bound name: `'_`\n+error[E0637]: `'_` cannot be used here\n   --> $DIR/E0637.rs:11:16\n    |\n-LL | struct Foo<'a: '_>(&'a u8); //~ ERROR invalid lifetime bound name: `'_`\n+LL | struct Foo<'a: '_>(&'a u8); //~ ERROR cannot be used here\n    |                ^^ `'_` is a reserved lifetime name\n \n-error[E0637]: invalid lifetime bound name: `'_`\n+error[E0637]: `'_` cannot be used here\n   --> $DIR/E0637.rs:12:12\n    |\n-LL | fn foo<'a: '_>(_: &'a u8) {} //~ ERROR invalid lifetime bound name: `'_`\n+LL | fn foo<'a: '_>(_: &'a u8) {} //~ ERROR cannot be used here\n    |            ^^ `'_` is a reserved lifetime name\n \n-error[E0637]: invalid lifetime bound name: `'_`\n+error[E0637]: `'_` cannot be used here\n   --> $DIR/E0637.rs:15:10\n    |\n-LL | impl<'a: '_> Bar<'a> { //~ ERROR invalid lifetime bound name: `'_`\n+LL | impl<'a: '_> Bar<'a> { //~ ERROR cannot be used here\n    |          ^^ `'_` is a reserved lifetime name\n \n error: aborting due to 3 previous errors"}, {"sha": "a851e6b2071b26be0cbe770a573c92536869210d", "filename": "src/test/ui/underscore-lifetime/in-binder.Rust2015.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.Rust2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.Rust2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.Rust2015.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,46 @@\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/in-binder.rs:12:6\n+   |\n+LL | impl<'_> IceCube<'_> {}\n+   |      ^^ `'_` is a reserved lifetime name\n+\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/in-binder.rs:17:15\n+   |\n+LL | struct Struct<'_> {\n+   |               ^^ `'_` is a reserved lifetime name\n+\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/in-binder.rs:23:11\n+   |\n+LL | enum Enum<'_> {\n+   |           ^^ `'_` is a reserved lifetime name\n+\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/in-binder.rs:29:13\n+   |\n+LL | union Union<'_> {\n+   |             ^^ `'_` is a reserved lifetime name\n+\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/in-binder.rs:35:13\n+   |\n+LL | trait Trait<'_> {\n+   |             ^^ `'_` is a reserved lifetime name\n+\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/in-binder.rs:40:8\n+   |\n+LL | fn foo<'_>() {\n+   |        ^^ `'_` is a reserved lifetime name\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/in-binder.rs:12:18\n+   |\n+LL | impl<'_> IceCube<'_> {}\n+   |                  ^^ expected lifetime parameter\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors occurred: E0106, E0637.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "77da3038724b885384dcd8be0de6fac7ee47ce72", "filename": "src/test/ui/underscore-lifetime/in-binder.Rust2018.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.Rust2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.Rust2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.Rust2018.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,39 @@\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/in-binder.rs:12:6\n+   |\n+LL | impl<'_> IceCube<'_> {}\n+   |      ^^ `'_` is a reserved lifetime name\n+\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/in-binder.rs:17:15\n+   |\n+LL | struct Struct<'_> {\n+   |               ^^ `'_` is a reserved lifetime name\n+\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/in-binder.rs:23:11\n+   |\n+LL | enum Enum<'_> {\n+   |           ^^ `'_` is a reserved lifetime name\n+\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/in-binder.rs:29:13\n+   |\n+LL | union Union<'_> {\n+   |             ^^ `'_` is a reserved lifetime name\n+\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/in-binder.rs:35:13\n+   |\n+LL | trait Trait<'_> {\n+   |             ^^ `'_` is a reserved lifetime name\n+\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/in-binder.rs:40:8\n+   |\n+LL | fn foo<'_>() {\n+   |        ^^ `'_` is a reserved lifetime name\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "c94947d1eab1ccc5c08613518867a1077899aefd", "filename": "src/test/ui/underscore-lifetime/in-binder.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,45 @@\n+// Check that we error when `'_` appears as the name of a lifetime parameter.\n+//\n+// Regression test for #52098.\n+\n+// revisions: Rust2015 Rust2018\n+//[Rust2018] edition:2018\n+\n+struct IceCube<'a> {\n+    v: Vec<&'a char>\n+}\n+\n+impl<'_> IceCube<'_> {}\n+//[Rust2015]~^ ERROR `'_` cannot be used here\n+//[Rust2015]~| ERROR missing lifetime specifier\n+//[Rust2018]~^^^ ERROR `'_` cannot be used here\n+\n+struct Struct<'_> {\n+//[Rust2015]~^ ERROR `'_` cannot be used here\n+//[Rust2018]~^^ ERROR `'_` cannot be used here\n+    v: Vec<&'static char>\n+}\n+\n+enum Enum<'_> {\n+//[Rust2015]~^ ERROR `'_` cannot be used here\n+//[Rust2018]~^^ ERROR `'_` cannot be used here\n+    Variant\n+}\n+\n+union Union<'_> {\n+//[Rust2015]~^ ERROR `'_` cannot be used here\n+//[Rust2018]~^^ ERROR `'_` cannot be used here\n+    a: u32\n+}\n+\n+trait Trait<'_> {\n+//[Rust2015]~^ ERROR `'_` cannot be used here\n+//[Rust2018]~^^ ERROR `'_` cannot be used here\n+}\n+\n+fn foo<'_>() {\n+    //[Rust2015]~^ ERROR `'_` cannot be used here\n+    //[Rust2018]~^^ ERROR `'_` cannot be used here\n+}\n+\n+fn main() {}"}, {"sha": "09f3abd9135cb9c2da375562f93831663c719884", "filename": "src/test/ui/underscore-lifetime/in-fn-return-illegal.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-fn-return-illegal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-fn-return-illegal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-fn-return-illegal.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the `'_` used in structs/enums gives an error.\n+\n+use std::fmt::Debug;\n+\n+fn foo(x: &u32, y: &u32) -> &'_ u32 { loop { } } //~ ERROR missing lifetime specifier\n+\n+fn main() { }"}, {"sha": "f3ba3e529242616f6167315f0e9cfb6aa725cd5d", "filename": "src/test/ui/underscore-lifetime/in-fn-return-illegal.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-fn-return-illegal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-fn-return-illegal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-fn-return-illegal.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,11 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/in-fn-return-illegal.rs:15:30\n+   |\n+LL | fn foo(x: &u32, y: &u32) -> &'_ u32 { loop { } } //~ ERROR missing lifetime specifier\n+   |                              ^^ expected lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "1c1a9ef62d5947dee6368c350be0e0f1a4941d3e", "filename": "src/test/ui/underscore-lifetime/in-struct.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-struct.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the `'_` used in structs/enums gives an error.\n+\n+use std::fmt::Debug;\n+\n+struct Foo {\n+    x: &'_ u32, //~ ERROR missing lifetime specifier\n+}\n+\n+enum Bar {\n+    Variant(&'_ u32), //~ ERROR missing lifetime specifier\n+}\n+\n+fn main() { }"}, {"sha": "d288995d4bb820745fe1846f35d5711b2b131d87", "filename": "src/test/ui/underscore-lifetime/in-struct.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-struct.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,15 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/in-struct.rs:16:9\n+   |\n+LL |     x: &'_ u32, //~ ERROR missing lifetime specifier\n+   |         ^^ expected lifetime parameter\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/in-struct.rs:20:14\n+   |\n+LL |     Variant(&'_ u32), //~ ERROR missing lifetime specifier\n+   |              ^^ expected lifetime parameter\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "2652fc62bb6228e93f152cf8f945f45302ac8a6f", "filename": "src/test/ui/underscore-lifetime/underscore-lifetime-binders.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -15,13 +15,13 @@ impl Foo<'_> { //~ ERROR missing lifetime specifier\n     fn x() {}\n }\n \n-fn foo<'_> //~ ERROR invalid lifetime parameter name: `'_`\n+fn foo<'_> //~ ERROR cannot be used here\n (_: Foo<'_>) {}\n \n trait Meh<'a> {}\n impl<'a> Meh<'a> for u8 {}\n \n-fn meh() -> Box<for<'_> Meh<'_>> //~ ERROR invalid lifetime parameter name: `'_`\n+fn meh() -> Box<for<'_> Meh<'_>> //~ ERROR cannot be used here\n //~^ ERROR missing lifetime specifier\n {\n   Box::new(5u8)"}, {"sha": "fc9f3e642d4026993c11373f94b3042c432e717a", "filename": "src/test/ui/underscore-lifetime/underscore-lifetime-binders.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -1,3 +1,15 @@\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/underscore-lifetime-binders.rs:18:8\n+   |\n+LL | fn foo<'_> //~ ERROR cannot be used here\n+   |        ^^ `'_` is a reserved lifetime name\n+\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/underscore-lifetime-binders.rs:24:21\n+   |\n+LL | fn meh() -> Box<for<'_> Meh<'_>> //~ ERROR cannot be used here\n+   |                     ^^ `'_` is a reserved lifetime name\n+\n error[E0106]: missing lifetime specifier\n   --> $DIR/underscore-lifetime-binders.rs:12:17\n    |\n@@ -10,22 +22,10 @@ error[E0106]: missing lifetime specifier\n LL | impl Foo<'_> { //~ ERROR missing lifetime specifier\n    |          ^^ expected lifetime parameter\n \n-error[E0262]: invalid lifetime parameter name: `'_`\n-  --> $DIR/underscore-lifetime-binders.rs:18:8\n-   |\n-LL | fn foo<'_> //~ ERROR invalid lifetime parameter name: `'_`\n-   |        ^^ '_ is a reserved lifetime name\n-\n-error[E0262]: invalid lifetime parameter name: `'_`\n-  --> $DIR/underscore-lifetime-binders.rs:24:21\n-   |\n-LL | fn meh() -> Box<for<'_> Meh<'_>> //~ ERROR invalid lifetime parameter name: `'_`\n-   |                     ^^ '_ is a reserved lifetime name\n-\n error[E0106]: missing lifetime specifier\n   --> $DIR/underscore-lifetime-binders.rs:24:29\n    |\n-LL | fn meh() -> Box<for<'_> Meh<'_>> //~ ERROR invalid lifetime parameter name: `'_`\n+LL | fn meh() -> Box<for<'_> Meh<'_>> //~ ERROR cannot be used here\n    |                             ^^ expected lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n@@ -41,5 +41,5 @@ LL | fn foo2(_: &'_ u8, y: &'_ u8) -> &'_ u8 { y } //~ ERROR missing lifetime sp\n \n error: aborting due to 6 previous errors\n \n-Some errors occurred: E0106, E0262.\n+Some errors occurred: E0106, E0637.\n For more information about an error, try `rustc --explain E0106`."}, {"sha": "b514ff43860750c545b11892b5c841507cac28aa", "filename": "src/test/ui/underscore-lifetime/underscore-outlives-bounds.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-outlives-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-outlives-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-outlives-bounds.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,8 @@\n+// Regression test to check that `'b: '_` gets an error, because it's\n+// basically useless.\n+//\n+// #54902\n+\n+trait Foo<'a> {}\n+impl<'b: '_> Foo<'b> for i32 {}\n+fn main() { }"}, {"sha": "4b38a26f957f96c915b6ef4be937c16f66a00a2d", "filename": "src/test/ui/underscore-lifetime/underscore-outlives-bounds.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-outlives-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-outlives-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-outlives-bounds.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,9 @@\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/underscore-outlives-bounds.rs:7:10\n+   |\n+LL | impl<'b: '_> Foo<'b> for i32 {}\n+   |          ^^ `'_` is a reserved lifetime name\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "43de30944cacb5d3403c678a36ec8e30d83be4be", "filename": "src/test/ui/underscore-lifetime/where-clause-inherent-impl-ampersand.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,18 @@\n+// revisions: rust2015 rust2018\n+//[rust2018] edition:2018\n+\n+trait WithType<T> {}\n+trait WithRegion<'a> { }\n+\n+struct Foo<T> {\n+    t: T\n+}\n+\n+impl<T> Foo<T>\n+where\n+    T: WithType<&u32>\n+//[rust2015]~^ ERROR `&` without an explicit lifetime name cannot be used here\n+//[rust2018]~^^ ERROR `&` without an explicit lifetime name cannot be used here\n+{ }\n+\n+fn main() {}"}, {"sha": "fe726cb49c73737a3c244d520e5ceba3dbbf7c67", "filename": "src/test/ui/underscore-lifetime/where-clause-inherent-impl-ampersand.rust2015.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2015.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,9 @@\n+error[E0637]: `&` without an explicit lifetime name cannot be used here\n+  --> $DIR/where-clause-inherent-impl-ampersand.rs:13:17\n+   |\n+LL |     T: WithType<&u32>\n+   |                 ^ explicit lifetime name needed here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "fe726cb49c73737a3c244d520e5ceba3dbbf7c67", "filename": "src/test/ui/underscore-lifetime/where-clause-inherent-impl-ampersand.rust2018.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2018.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,9 @@\n+error[E0637]: `&` without an explicit lifetime name cannot be used here\n+  --> $DIR/where-clause-inherent-impl-ampersand.rs:13:17\n+   |\n+LL |     T: WithType<&u32>\n+   |                 ^ explicit lifetime name needed here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "b50cce335bd8c9808104eb9b4c5fd98540bdba86", "filename": "src/test/ui/underscore-lifetime/where-clause-inherent-impl-underscore.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,18 @@\n+// revisions: rust2015 rust2018\n+//[rust2018] edition:2018\n+\n+trait WithType<T> {}\n+trait WithRegion<'a> { }\n+\n+struct Foo<T> {\n+    t: T\n+}\n+\n+impl<T> Foo<T>\n+where\n+    T: WithRegion<'_>\n+//[rust2015]~^ ERROR `'_` cannot be used here\n+//[rust2018]~^^ ERROR `'_` cannot be used here\n+{ }\n+\n+fn main() {}"}, {"sha": "95939fd6b7e0374880dc80125675d197447865c8", "filename": "src/test/ui/underscore-lifetime/where-clause-inherent-impl-underscore.rust2015.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rust2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rust2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rust2015.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,9 @@\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/where-clause-inherent-impl-underscore.rs:13:19\n+   |\n+LL |     T: WithRegion<'_>\n+   |                   ^^ `'_` is a reserved lifetime name\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "95939fd6b7e0374880dc80125675d197447865c8", "filename": "src/test/ui/underscore-lifetime/where-clause-inherent-impl-underscore.rust2018.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rust2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rust2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-underscore.rust2018.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,9 @@\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/where-clause-inherent-impl-underscore.rs:13:19\n+   |\n+LL |     T: WithRegion<'_>\n+   |                   ^^ `'_` is a reserved lifetime name\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "f2d483e66e0138fef67cca860b28ed3bfcbb9979", "filename": "src/test/ui/underscore-lifetime/where-clause-trait-impl-region.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,16 @@\n+// revisions: rust2015 rust2018\n+//[rust2018] edition:2018\n+\n+trait WithType<T> {}\n+trait WithRegion<'a> { }\n+\n+trait Foo { }\n+\n+impl<T> Foo for Vec<T>\n+where\n+    T: WithType<&u32>\n+//[rust2015]~^ ERROR `&` without an explicit lifetime name cannot be used here\n+//[rust2018]~^^ ERROR `&` without an explicit lifetime name cannot be used here\n+{ }\n+\n+fn main() {}"}, {"sha": "fbd14de21078b1440a47035103bbf782f88edc9d", "filename": "src/test/ui/underscore-lifetime/where-clause-trait-impl-region.rust2015.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2015.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,9 @@\n+error[E0637]: `&` without an explicit lifetime name cannot be used here\n+  --> $DIR/where-clause-trait-impl-region.rs:11:17\n+   |\n+LL |     T: WithType<&u32>\n+   |                 ^ explicit lifetime name needed here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "fbd14de21078b1440a47035103bbf782f88edc9d", "filename": "src/test/ui/underscore-lifetime/where-clause-trait-impl-region.rust2018.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2018.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,9 @@\n+error[E0637]: `&` without an explicit lifetime name cannot be used here\n+  --> $DIR/where-clause-trait-impl-region.rs:11:17\n+   |\n+LL |     T: WithType<&u32>\n+   |                 ^ explicit lifetime name needed here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "94e4426e822d92a9b54e6f8af94c7a51a328adf2", "filename": "src/test/ui/underscore-lifetime/where-clause-trait-impl-underscore.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,16 @@\n+// revisions: rust2015 rust2018\n+//[rust2018] edition:2018\n+\n+trait WithType<T> {}\n+trait WithRegion<'a> { }\n+\n+trait Foo { }\n+\n+impl<T> Foo for Vec<T>\n+where\n+    T: WithRegion<'_>\n+//[rust2015]~^ ERROR `'_` cannot be used here\n+//[rust2018]~^^ ERROR `'_` cannot be used here\n+{ }\n+\n+fn main() {}"}, {"sha": "92caff0dcde9977d669106c969a4bab8540e72df", "filename": "src/test/ui/underscore-lifetime/where-clause-trait-impl-underscore.rust2015.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rust2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rust2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rust2015.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,9 @@\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/where-clause-trait-impl-underscore.rs:11:19\n+   |\n+LL |     T: WithRegion<'_>\n+   |                   ^^ `'_` is a reserved lifetime name\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "92caff0dcde9977d669106c969a4bab8540e72df", "filename": "src/test/ui/underscore-lifetime/where-clause-trait-impl-underscore.rust2018.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rust2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rust2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-underscore.rust2018.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,9 @@\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/where-clause-trait-impl-underscore.rs:11:19\n+   |\n+LL |     T: WithRegion<'_>\n+   |                   ^^ `'_` is a reserved lifetime name\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "ee6823b80478218433ceec45055b2423b41fa754", "filename": "src/test/ui/underscore-lifetime/where-clauses.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clauses.rs?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,7 @@\n+trait Foo<'a> {}\n+\n+impl<'b: '_> Foo<'b> for i32 {} //~ ERROR `'_` cannot be used here\n+\n+impl<T: '_> Foo<'static> for Vec<T> {} //~ ERROR `'_` cannot be used here\n+\n+fn main() { }"}, {"sha": "57fe2456f4cc52dbb42d6ba5d8e0be126329f12a", "filename": "src/test/ui/underscore-lifetime/where-clauses.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clauses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42dde960f95222ffd8c356e0f7841cd22294a6c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clauses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clauses.stderr?ref=42dde960f95222ffd8c356e0f7841cd22294a6c9", "patch": "@@ -0,0 +1,15 @@\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/where-clauses.rs:3:10\n+   |\n+LL | impl<'b: '_> Foo<'b> for i32 {} //~ ERROR `'_` cannot be used here\n+   |          ^^ `'_` is a reserved lifetime name\n+\n+error[E0637]: `'_` cannot be used here\n+  --> $DIR/where-clauses.rs:5:9\n+   |\n+LL | impl<T: '_> Foo<'static> for Vec<T> {} //~ ERROR `'_` cannot be used here\n+   |         ^^ `'_` is a reserved lifetime name\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0637`."}]}