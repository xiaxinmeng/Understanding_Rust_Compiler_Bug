{"sha": "e2bf960fe1c011e75cf0d6a06d3f955444d11043", "node_id": "C_kwDOAAsO6NoAKGUyYmY5NjBmZTFjMDExZTc1Y2YwZDZhMDZkM2Y5NTU0NDRkMTEwNDM", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-11-09T20:21:36Z"}, "committer": {"name": "b-naber", "email": "b_naber@gmx.de", "date": "2023-02-19T22:12:12Z"}, "message": "sccs info", "tree": {"sha": "c72c41cd950b697e5b67b70e70cc1c3ea0bcbf0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c72c41cd950b697e5b67b70e70cc1c3ea0bcbf0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2bf960fe1c011e75cf0d6a06d3f955444d11043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2bf960fe1c011e75cf0d6a06d3f955444d11043", "html_url": "https://github.com/rust-lang/rust/commit/e2bf960fe1c011e75cf0d6a06d3f955444d11043", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2bf960fe1c011e75cf0d6a06d3f955444d11043/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "960ebaf899cfceddf7edaf936f460491dcbf4733", "url": "https://api.github.com/repos/rust-lang/rust/commits/960ebaf899cfceddf7edaf936f460491dcbf4733", "html_url": "https://github.com/rust-lang/rust/commit/960ebaf899cfceddf7edaf936f460491dcbf4733"}], "stats": {"total": 82, "additions": 74, "deletions": 8}, "files": [{"sha": "f370c02161b115590e2333b39f4d1c6866e653e2", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2bf960fe1c011e75cf0d6a06d3f955444d11043/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bf960fe1c011e75cf0d6a06d3f955444d11043/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=e2bf960fe1c011e75cf0d6a06d3f955444d11043", "patch": "@@ -17,7 +17,7 @@ pub(crate) mod graph;\n /// constraints of the form `R1: R2`. Each constraint is identified by\n /// a unique `OutlivesConstraintIndex` and you can index into the set\n /// (`constraint_set[i]`) to access the constraint details.\n-#[derive(Clone, Default)]\n+#[derive(Clone, Debug, Default)]\n pub(crate) struct OutlivesConstraintSet<'tcx> {\n     outlives: IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>>,\n }"}, {"sha": "28d49c19c753f87d500f3caea8ffde7e8e9b10bf", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2bf960fe1c011e75cf0d6a06d3f955444d11043/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bf960fe1c011e75cf0d6a06d3f955444d11043/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=e2bf960fe1c011e75cf0d6a06d3f955444d11043", "patch": "@@ -263,6 +263,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n     }\n \n     let mut regioncx = RegionInferenceContext::new(\n+        infcx,\n         var_origins,\n         universal_regions,\n         placeholder_indices,"}, {"sha": "66d2850c67bfa9230ced8ecf9aee05205d1e1ec6", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e2bf960fe1c011e75cf0d6a06d3f955444d11043/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bf960fe1c011e75cf0d6a06d3f955444d11043/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=e2bf960fe1c011e75cf0d6a06d3f955444d11043", "patch": "@@ -34,6 +34,7 @@ use crate::{\n     },\n     type_check::{free_region_relations::UniversalRegionRelations, Locations},\n     universal_regions::UniversalRegions,\n+    BorrowckInferCtxt,\n };\n \n mod dump_mir;\n@@ -243,6 +244,59 @@ pub enum ExtraConstraintInfo {\n     PlaceholderFromPredicate(Span),\n }\n \n+#[cfg(debug_assertions)]\n+#[instrument(skip(infcx, sccs), level = \"debug\")]\n+fn sccs_info<'cx, 'tcx>(\n+    infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n+    sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n+) {\n+    use crate::renumber::RegionCtxt;\n+\n+    let var_to_origin = infcx.reg_var_to_origin.borrow();\n+    let num_components = sccs.scc_data.ranges.len();\n+    let mut components = vec![FxHashSet::default(); num_components];\n+\n+    for (reg_var_idx, scc_idx) in sccs.scc_indices.iter().enumerate() {\n+        let reg_var = ty::RegionVid::from_usize(reg_var_idx);\n+        let origin = var_to_origin.get(&reg_var).unwrap_or_else(|| &RegionCtxt::Unknown);\n+        components[scc_idx.as_usize()].insert(*origin);\n+    }\n+\n+    debug!(\n+        \"strongly connected components: {:#?}\",\n+        components\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, origin)| { (ConstraintSccIndex::from_usize(idx), origin) })\n+            .collect::<Vec<_>>()\n+    );\n+\n+    // Now let's calculate the best representative for each component\n+    let components_representatives = components\n+        .into_iter()\n+        .enumerate()\n+        .map(|(scc_idx, region_ctxts)| {\n+            let repr = region_ctxts\n+                .into_iter()\n+                .max_by(|x, y| x._preference_value().cmp(&y._preference_value()))\n+                .unwrap();\n+\n+            (ConstraintSccIndex::from_usize(scc_idx), repr)\n+        })\n+        .collect::<FxHashMap<_, _>>();\n+\n+    let mut scc_node_to_edges = FxHashMap::default();\n+    for (scc_idx, repr) in components_representatives.iter() {\n+        let edges_range = sccs.scc_data.ranges[*scc_idx].clone();\n+        let edges = &sccs.scc_data.all_successors[edges_range];\n+        let edge_representatives =\n+            edges.iter().map(|scc_idx| components_representatives[scc_idx]).collect::<Vec<_>>();\n+        scc_node_to_edges.insert((scc_idx, repr), edge_representatives);\n+    }\n+\n+    debug!(\"SCC edges {:#?}\", scc_node_to_edges);\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -251,7 +305,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// The `outlives_constraints` and `type_tests` are an initial set\n     /// of constraints produced by the MIR type check.\n-    pub(crate) fn new(\n+    pub(crate) fn new<'cx>(\n+        _infcx: &BorrowckInferCtxt<'cx, 'tcx>,\n         var_infos: VarInfos,\n         universal_regions: Rc<UniversalRegions<'tcx>>,\n         placeholder_indices: Rc<PlaceholderIndices>,\n@@ -263,6 +318,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         liveness_constraints: LivenessValues<RegionVid>,\n         elements: &Rc<RegionValueElements>,\n     ) -> Self {\n+        debug!(\"universal_regions: {:#?}\", universal_regions);\n+        debug!(\"outlives constraints: {:#?}\", outlives_constraints);\n+        debug!(\"placeholder_indices: {:#?}\", placeholder_indices);\n+        debug!(\"type tests: {:#?}\", type_tests);\n+\n         // Create a RegionDefinition for each inference variable.\n         let definitions: IndexVec<_, _> = var_infos\n             .iter()\n@@ -274,6 +334,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let fr_static = universal_regions.fr_static;\n         let constraint_sccs = Rc::new(constraints.compute_sccs(&constraint_graph, fr_static));\n \n+        #[cfg(debug_assertions)]\n+        {\n+            sccs_info(_infcx, constraint_sccs.clone());\n+        }\n+\n         let mut scc_values =\n             RegionValues::new(elements, universal_regions.len(), &placeholder_indices);\n "}, {"sha": "c361357ca2134462f55a0be0b281010362b409c8", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2bf960fe1c011e75cf0d6a06d3f955444d11043/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bf960fe1c011e75cf0d6a06d3f955444d11043/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=e2bf960fe1c011e75cf0d6a06d3f955444d11043", "patch": "@@ -181,7 +181,7 @@ impl<N: Idx> LivenessValues<N> {\n /// Maps from `ty::PlaceholderRegion` values that are used in the rest of\n /// rustc to the internal `PlaceholderIndex` values that are used in\n /// NLL.\n-#[derive(Default)]\n+#[derive(Debug, Default)]\n pub(crate) struct PlaceholderIndices {\n     indices: FxIndexSet<ty::PlaceholderRegion>,\n }"}, {"sha": "e2fe5285aad2cacd73e981e49c310e0025c93316", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e2bf960fe1c011e75cf0d6a06d3f955444d11043/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bf960fe1c011e75cf0d6a06d3f955444d11043/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=e2bf960fe1c011e75cf0d6a06d3f955444d11043", "patch": "@@ -21,21 +21,21 @@ mod tests;\n pub struct Sccs<N: Idx, S: Idx> {\n     /// For each node, what is the SCC index of the SCC to which it\n     /// belongs.\n-    scc_indices: IndexVec<N, S>,\n+    pub scc_indices: IndexVec<N, S>,\n \n     /// Data about each SCC.\n-    scc_data: SccData<S>,\n+    pub scc_data: SccData<S>,\n }\n \n-struct SccData<S: Idx> {\n+pub struct SccData<S: Idx> {\n     /// For each SCC, the range of `all_successors` where its\n     /// successors can be found.\n-    ranges: IndexVec<S, Range<usize>>,\n+    pub ranges: IndexVec<S, Range<usize>>,\n \n     /// Contains the successors for all the Sccs, concatenated. The\n     /// range of indices corresponding to a given SCC is found in its\n     /// SccData.\n-    all_successors: Vec<S>,\n+    pub all_successors: Vec<S>,\n }\n \n impl<N: Idx, S: Idx + Ord> Sccs<N, S> {"}]}