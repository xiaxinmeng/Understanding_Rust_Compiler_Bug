{"sha": "099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5OWI5ZmRiMWExNzBiNTdmZmQ3MTc0YjNjMzA0MmNjODZiN2ZlOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-27T10:07:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-27T10:07:48Z"}, "message": "Auto merge of #36030 - Manishearth:rollup, r=Manishearth\n\nRollup of 7 pull requests\n\n- Successful merges: #35124, #35877, #35953, #36002, #36004, #36005, #36014\n- Failed merges:", "tree": {"sha": "aa3b27019254450634a4fea8583e7cc70d7b7190", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa3b27019254450634a4fea8583e7cc70d7b7190"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "html_url": "https://github.com/rust-lang/rust/commit/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "html_url": "https://github.com/rust-lang/rust/commit/6b74503aa4f2fb4035d9adef9391e9b9658c57ad"}, {"sha": "668d63132e23999f5a74fe65c8c0590a4d9ca215", "url": "https://api.github.com/repos/rust-lang/rust/commits/668d63132e23999f5a74fe65c8c0590a4d9ca215", "html_url": "https://github.com/rust-lang/rust/commit/668d63132e23999f5a74fe65c8c0590a4d9ca215"}], "stats": {"total": 5328, "additions": 1479, "deletions": 3849}, "files": [{"sha": "6c0be654e1f5d74a8e39b6f18f26896742fda9d1", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -66,7 +66,7 @@ ERR_IDX_GEN_MD = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(ERR_IDX_GEN_EXE)\n \n D := $(S)src/doc\n \n-DOC_TARGETS := book nomicon style error-index\n+DOC_TARGETS := book nomicon error-index\n COMPILER_DOC_TARGETS :=\n DOC_L10N_TARGETS :=\n \n@@ -209,13 +209,6 @@ doc/nomicon/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/nomicon/*.md) |\n \t$(Q)rm -rf doc/nomicon\n \t$(Q)$(RUSTBOOK) build $(S)src/doc/nomicon doc/nomicon\n \n-style: doc/style/index.html\n-\n-doc/style/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/style/*.md) | doc/\n-\t@$(call E, rustbook: $@)\n-\t$(Q)rm -rf doc/style\n-\t$(Q)$(RUSTBOOK) build $(S)src/doc/style doc/style\n-\n error-index: doc/error-index.html\n \n # Metadata used to generate the index is created as a side effect of"}, {"sha": "9eacb5e3924fa25a62059081803b41830bd11343", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -308,10 +308,6 @@ impl Build {\n                     doc::rustbook(self, stage, target.target, \"nomicon\",\n                                   &doc_out);\n                 }\n-                DocStyle { stage } => {\n-                    doc::rustbook(self, stage, target.target, \"style\",\n-                                  &doc_out);\n-                }\n                 DocStandalone { stage } => {\n                     doc::standalone(self, stage, target.target, &doc_out);\n                 }"}, {"sha": "12929664886c4964f2096f0f530ec1946b3cd924", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -92,7 +92,6 @@ macro_rules! targets {\n             (doc, Doc { stage: u32 }),\n             (doc_book, DocBook { stage: u32 }),\n             (doc_nomicon, DocNomicon { stage: u32 }),\n-            (doc_style, DocStyle { stage: u32 }),\n             (doc_standalone, DocStandalone { stage: u32 }),\n             (doc_std, DocStd { stage: u32 }),\n             (doc_test, DocTest { stage: u32 }),\n@@ -366,8 +365,7 @@ impl<'a> Step<'a> {\n                 vec![self.libtest(compiler)]\n             }\n             Source::DocBook { stage } |\n-            Source::DocNomicon { stage } |\n-            Source::DocStyle { stage } => {\n+            Source::DocNomicon { stage } => {\n                 vec![self.target(&build.config.build).tool_rustbook(stage)]\n             }\n             Source::DocErrorIndex { stage } => {\n@@ -382,8 +380,7 @@ impl<'a> Step<'a> {\n             Source::Doc { stage } => {\n                 let mut deps = vec![\n                     self.doc_book(stage), self.doc_nomicon(stage),\n-                    self.doc_style(stage), self.doc_standalone(stage),\n-                    self.doc_std(stage),\n+                    self.doc_standalone(stage), self.doc_std(stage),\n                     self.doc_error_index(stage),\n                 ];\n "}, {"sha": "8d837d1a1a9165b653e8019c8333c2608d3b8584", "filename": "src/doc/style/README.md", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2FREADME.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,64 +0,0 @@\n-% Style Guidelines\n-\n-This document collects the emerging principles, conventions, abstractions, and\n-best practices for writing Rust code.\n-\n-Since Rust is evolving at a rapid pace, these guidelines are\n-preliminary. The hope is that writing them down explicitly will help\n-drive discussion, consensus and adoption.\n-\n-Whenever feasible, guidelines provide specific examples from Rust's standard\n-libraries.\n-\n-### Guideline statuses\n-\n-Every guideline has a status:\n-\n-* **[FIXME]**: Marks places where there is more work to be done. In\n-  some cases, that just means going through the RFC process.\n-\n-* **[FIXME #NNNNN]**: Like **[FIXME]**, but links to the issue tracker.\n-\n-* **[RFC #NNNN]**: Marks accepted guidelines, linking to the rust-lang\n-  RFC establishing them.\n-\n-### Guideline stabilization\n-\n-One purpose of these guidelines is to reach decisions on a number of\n-cross-cutting API and stylistic choices. Discussion and development of\n-the guidelines will happen primarily on https://internals.rust-lang.org/,\n-using the Guidelines category. Discussion can also occur on the\n-[guidelines issue tracker](https://github.com/rust-lang/rust-guidelines).\n-\n-Guidelines that are under development or discussion will be marked with the\n-status **[FIXME]**, with a link to the issue tracker when appropriate.\n-\n-Once a concrete guideline is ready to be proposed, it should be filed\n-as an [FIXME: needs RFC](https://github.com/rust-lang/rfcs). If the RFC is\n-accepted, the official guidelines will be updated to match, and will\n-include the tag **[RFC #NNNN]** linking to the RFC document.\n-\n-### What's in this document\n-\n-This document is broken into four parts:\n-\n-* **[Style](style/README.md)** provides a set of rules governing naming conventions,\n-  whitespace, and other stylistic issues.\n-\n-* **[Guidelines by Rust feature](features/README.md)** places the focus on each of\n-  Rust's features, starting from expressions and working the way out toward\n-  crates, dispensing guidelines relevant to each.\n-\n-* **Topical guidelines and patterns**. The rest of the document proceeds by\n-  cross-cutting topic, starting with\n-  [Ownership and resources](ownership/README.md).\n-\n-* **APIs for a changing Rust**\n-  discusses the forward-compatibility hazards, especially those that interact\n-  with the pre-1.0 library stabilization process.\n-\n-> **[FIXME]** Add cross-references throughout this document to the tutorial,\n-> reference manual, and other guides.\n-\n-> **[FIXME]** What are some _non_-goals, _non_-principles, or _anti_-patterns that\n-> we should document?"}, {"sha": "508ede6c4a0ac5b768022f5b746f97f7570912d4", "filename": "src/doc/style/SUMMARY.md", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2FSUMMARY.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,50 +0,0 @@\n-# Summary\n-\n-* [Style](style/README.md)\n-    * [Whitespace](style/whitespace.md)\n-    * [Comments](style/comments.md)\n-    * [Braces, semicolons, commas](style/braces.md)\n-    * [Naming](style/naming/README.md)\n-        * [Ownership variants](style/naming/ownership.md)\n-        * [Containers/wrappers](style/naming/containers.md)\n-        * [Conversions](style/naming/conversions.md)\n-        * [Iterators](style/naming/iterators.md)\n-    * [Imports](style/imports.md)\n-    * [Organization](style/organization.md)\n-* [Guidelines by Rust feature](features/README.md)\n-    * [Let binding](features/let.md)\n-    * [Pattern matching](features/match.md)\n-    * [Loops](features/loops.md)\n-    * [Functions and methods](features/functions-and-methods/README.md)\n-        * [Input](features/functions-and-methods/input.md)\n-        * [Output](features/functions-and-methods/output.md)\n-        * [For convenience](features/functions-and-methods/convenience.md)\n-    * [Types](features/types/README.md)\n-        * [Conversions](features/types/conversions.md)\n-        * [The newtype pattern](features/types/newtype.md)\n-    * [Traits](features/traits/README.md)\n-        * [For generics](features/traits/generics.md)\n-        * [For objects](features/traits/objects.md)\n-        * [For overloading](features/traits/overloading.md)\n-        * [For extensions](features/traits/extensions.md)\n-        * [For reuse](features/traits/reuse.md)\n-        * [Common traits](features/traits/common.md)\n-    * [Modules](features/modules.md)\n-    * [Crates](features/crates.md)\n-* [Ownership and resources](ownership/README.md)\n-    * [Constructors](ownership/constructors.md)\n-    * [Builders](ownership/builders.md)\n-    * [Destructors](ownership/destructors.md)\n-    * [RAII](ownership/raii.md)\n-    * [Cells and smart pointers](ownership/cell-smart.md)\n-* [Errors](errors/README.md)\n-    * [Signaling](errors/signaling.md)\n-    * [Handling](errors/handling.md)\n-    * [Propagation](errors/propagation.md)\n-    * [Ergonomics](errors/ergonomics.md)\n-* [Safety and guarantees](safety/README.md)\n-    * [Using unsafe](safety/unsafe.md)\n-    * [Library guarantees](safety/lib-guarantees.md)\n-* [Testing](testing/README.md)\n-    * [Unit testing](testing/unit.md)\n-* [FFI, platform-specific code](platform.md)"}, {"sha": "444da26ff8fed7191bc82d15eb88d5ed11156174", "filename": "src/doc/style/errors/README.md", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ferrors%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ferrors%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2FREADME.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,3 +0,0 @@\n-% Errors\n-\n-> **[FIXME]** Add some general text here."}, {"sha": "269f2a289464a1a73fc62a6287804b2bca745b77", "filename": "src/doc/style/errors/ergonomics.md", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,66 +0,0 @@\n-% Ergonomic error handling\n-\n-Error propagation with raw `Result`s can require tedious matching and\n-repackaging. This tedium is largely alleviated by the `try!` macro,\n-and can be completely removed (in some cases) by the \"`Result`-`impl`\"\n-pattern.\n-\n-### The `try!` macro\n-\n-Prefer\n-\n-```rust,ignore\n-use std::io::{File, Open, Write, IoError};\n-\n-struct Info {\n-    name: String,\n-    age: i32,\n-    rating: i32\n-}\n-\n-fn write_info(info: &Info) -> Result<(), IoError> {\n-    let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"),\n-                                   Open, Write);\n-    // Early return on error\n-    try!(file.write_line(&format!(\"name: {}\", info.name)));\n-    try!(file.write_line(&format!(\"age: {}\", info.age)));\n-    try!(file.write_line(&format!(\"rating: {}\", info.rating)));\n-    return Ok(());\n-}\n-```\n-\n-over\n-\n-```rust,ignore\n-use std::io::{File, Open, Write, IoError};\n-\n-struct Info {\n-    name: String,\n-    age: i32,\n-    rating: i32\n-}\n-\n-fn write_info(info: &Info) -> Result<(), IoError> {\n-    let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"),\n-                                   Open, Write);\n-    // Early return on error\n-    match file.write_line(&format!(\"name: {}\", info.name)) {\n-        Ok(_) => (),\n-        Err(e) => return Err(e)\n-    }\n-    match file.write_line(&format!(\"age: {}\", info.age)) {\n-        Ok(_) => (),\n-        Err(e) => return Err(e)\n-    }\n-    return file.write_line(&format!(\"rating: {}\", info.rating));\n-}\n-```\n-\n-See\n-[the `result` module documentation](https://doc.rust-lang.org/stable/std/result/index.html#the-try-macro)\n-for more details.\n-\n-### The `Result`-`impl` pattern [FIXME]\n-\n-> **[FIXME]** Document the way that the `io` module uses trait impls\n-> on `std::io::Result` to painlessly propagate errors."}, {"sha": "9b8a00d73665b6f4fd0f983a1e56763fef80fa23", "filename": "src/doc/style/errors/handling.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,7 +0,0 @@\n-% Handling errors\n-\n-### Use thread isolation to cope with failure. [FIXME]\n-\n-> **[FIXME]** Explain how to isolate threads and detect thread failure for recovery.\n-\n-### Consuming `Result` [FIXME]"}, {"sha": "0a347cd577b906136b2129909a7cde31e25f701e", "filename": "src/doc/style/errors/propagation.md", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ferrors%2Fpropagation.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ferrors%2Fpropagation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fpropagation.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,8 +0,0 @@\n-% Propagation\n-\n-> **[FIXME]** We need guidelines on how to layer error information up a stack of\n-> abstractions.\n-\n-### Error interoperation [FIXME]\n-\n-> **[FIXME]** Document the `FromError` infrastructure."}, {"sha": "4038ec10b9ab5d1f9f5a015326e8268455030dc4", "filename": "src/doc/style/errors/signaling.md", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,125 +0,0 @@\n-% Signaling errors [RFC #236]\n-\n-> The guidelines below were approved by [RFC #236](https://github.com/rust-lang/rfcs/pull/236).\n-\n-Errors fall into one of three categories:\n-\n-* Catastrophic errors, e.g. out-of-memory.\n-* Contract violations, e.g. wrong input encoding, index out of bounds.\n-* Obstructions, e.g. file not found, parse error.\n-\n-The basic principle of the convention is that:\n-\n-* Catastrophic errors and programming errors (bugs) can and should only be\n-recovered at a *coarse grain*, i.e. a thread boundary.\n-* Obstructions preventing an operation should be reported at a maximally *fine\n-grain* -- to the immediate invoker of the operation.\n-\n-## Catastrophic errors\n-\n-An error is _catastrophic_ if there is no meaningful way for the current thread to\n-continue after the error occurs.\n-\n-Catastrophic errors are _extremely_ rare, especially outside of `libstd`.\n-\n-**Canonical examples**: out of memory, stack overflow.\n-\n-### For catastrophic errors, panic\n-\n-For errors like stack overflow, Rust currently aborts the process, but\n-could in principle panic, which (in the best case) would allow\n-reporting and recovery from a supervisory thread.\n-\n-## Contract violations\n-\n-An API may define a contract that goes beyond the type checking enforced by the\n-compiler. For example, slices support an indexing operation, with the contract\n-that the supplied index must be in bounds.\n-\n-Contracts can be complex and involve more than a single function invocation. For\n-example, the `RefCell` type requires that `borrow_mut` not be called until all\n-existing borrows have been relinquished.\n-\n-### For contract violations, panic\n-\n-A contract violation is always a bug, and for bugs we follow the Erlang\n-philosophy of \"let it crash\": we assume that software *will* have bugs, and we\n-design coarse-grained thread boundaries to report, and perhaps recover, from these\n-bugs.\n-\n-### Contract design\n-\n-One subtle aspect of these guidelines is that the contract for a function is\n-chosen by an API designer -- and so the designer also determines what counts as\n-a violation.\n-\n-This RFC does not attempt to give hard-and-fast rules for designing\n-contracts. However, here are some rough guidelines:\n-\n-* Prefer expressing contracts through static types whenever possible.\n-\n-* It *must* be possible to write code that uses the API without violating the\n-  contract.\n-\n-* Contracts are most justified when violations are *inarguably* bugs -- but this\n-  is surprisingly rare.\n-\n-* Consider whether the API client could benefit from the contract-checking\n-  logic.  The checks may be expensive. Or there may be useful programming\n-  patterns where the client does not want to check inputs before hand, but would\n-  rather attempt the operation and then find out whether the inputs were invalid.\n-\n-* When a contract violation is the *only* kind of error a function may encounter\n-  -- i.e., there are no obstructions to its success other than \"bad\" inputs --\n-  using `Result` or `Option` instead is especially warranted. Clients can then use\n-  `unwrap` to assert that they have passed valid input, or re-use the error\n-  checking done by the API for their own purposes.\n-\n-* When in doubt, use loose contracts and instead return a `Result` or `Option`.\n-\n-## Obstructions\n-\n-An operation is *obstructed* if it cannot be completed for some reason, even\n-though the operation's contract has been satisfied. Obstructed operations may\n-have (documented!) side effects -- they are not required to roll back after\n-encountering an obstruction.  However, they should leave the data structures in\n-a \"coherent\" state (satisfying their invariants, continuing to guarantee safety,\n-etc.).\n-\n-Obstructions may involve external conditions (e.g., I/O), or they may involve\n-aspects of the input that are not covered by the contract.\n-\n-**Canonical examples**: file not found, parse error.\n-\n-### For obstructions, use `Result`\n-\n-The\n-[`Result<T,E>` type](https://doc.rust-lang.org/stable/std/result/index.html)\n-represents either a success (yielding `T`) or failure (yielding `E`). By\n-returning a `Result`, a function allows its clients to discover and react to\n-obstructions in a fine-grained way.\n-\n-#### What about `Option`?\n-\n-The `Option` type should not be used for \"obstructed\" operations; it\n-should only be used when a `None` return value could be considered a\n-\"successful\" execution of the operation.\n-\n-This is of course a somewhat subjective question, but a good litmus\n-test is: would a reasonable client ever ignore the result? The\n-`Result` type provides a lint that ensures the result is actually\n-inspected, while `Option` does not, and this difference of behavior\n-can help when deciding between the two types.\n-\n-Another litmus test: can the operation be understood as asking a\n-question (possibly with sideeffects)? Operations like `pop` on a\n-vector can be viewed as asking for the contents of the first element,\n-with the side effect of removing it if it exists -- with an `Option`\n-return value.\n-\n-## Do not provide both `Result` and `panic!` variants.\n-\n-An API should not provide both `Result`-producing and `panic`king versions of an\n-operation. It should provide just the `Result` version, allowing clients to use\n-`try!` or `unwrap` instead as needed. This is part of the general pattern of\n-cutting down on redundant variants by instead using method chaining."}, {"sha": "09657503d20d1cebf0c84eb194d2d315809590a4", "filename": "src/doc/style/features/README.md", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2FREADME.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,9 +0,0 @@\n-% Guidelines by language feature\n-\n-Rust provides a unique combination of language features, some new and some\n-old. This section gives guidance on when and how to use Rust's features, and\n-brings attention to some of the tradeoffs between different features.\n-\n-Notably missing from this section is an in-depth discussion of Rust's pointer\n-types (both built-in and in the library). The topic of pointers is discussed at\n-length in a [separate section on ownership](../ownership/README.md)."}, {"sha": "4748b05f17f74a189f5681bcd584657ac1cf6c83", "filename": "src/doc/style/features/crates.md", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Fcrates.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Fcrates.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Fcrates.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,6 +0,0 @@\n-% Crates\n-\n-> **[FIXME]** What general guidelines should we provide for crate design?\n-\n-> Possible topics: facades; per-crate preludes (to be imported as globs);\n-> \"lib.rs\""}, {"sha": "a3559ca3e7b6b213ea24be103ca461536dcb671b", "filename": "src/doc/style/features/functions-and-methods/README.md", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2FREADME.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,44 +0,0 @@\n-% Functions and methods\n-\n-### Prefer methods to functions if there is a clear receiver. **[FIXME: needs RFC]**\n-\n-Prefer\n-\n-```rust,ignore\n-impl Foo {\n-    pub fn frob(&self, w: widget) { ... }\n-}\n-```\n-\n-over\n-\n-```rust,ignore\n-pub fn frob(foo: &Foo, w: widget) { ... }\n-```\n-\n-for any operation that is clearly associated with a particular\n-type.\n-\n-Methods have numerous advantages over functions:\n-\n-* They do not need to be imported or qualified to be used: all you\n-  need is a value of the appropriate type.\n-* Their invocation performs autoborrowing (including mutable borrows).\n-* They make it easy to answer the question \"what can I do with a value\n-  of type `T`\" (especially when using rustdoc).\n-* They provide `self` notation, which is more concise and often more\n-  clearly conveys ownership distinctions.\n-\n-> **[FIXME]** Revisit these guidelines with\n-> [UFCS](https://github.com/nick29581/rfcs/blob/ufcs/0000-ufcs.md) and\n-> conventions developing around it.\n-\n-\n-\n-### Guidelines for inherent methods. **[FIXME]**\n-\n-> **[FIXME]** We need guidelines for when to provide inherent methods on a type,\n-> versus methods through a trait or functions.\n-\n-> **NOTE**: Rules for method resolution around inherent methods are in flux,\n-> which may impact the guidelines."}, {"sha": "69fd3772a761f8521bcf5153d2ec2b9aae2c28f5", "filename": "src/doc/style/features/functions-and-methods/convenience.md", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Fconvenience.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Fconvenience.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Fconvenience.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,43 +0,0 @@\n-% Convenience methods\n-\n-### Provide small, coherent sets of convenience methods. **[FIXME: needs RFC]**\n-\n-_Convenience methods_ wrap up existing functionality in a more convenient\n-way. The work done by a convenience method varies widely:\n-\n-* _Re-providing functions as methods_. For example, the `std::path::Path` type\n-  provides methods like `stat` on `Path`s that simply invoke the corresponding\n-  function in `std::io::fs`.\n-* _Skipping through conversions_. For example, the `str` type provides a\n-  `.len()` convenience method which is also expressible as `.as_bytes().len()`.\n-  Sometimes the conversion is more complex: the `str` module also provides\n-  `from_chars`, which encapsulates a simple use of iterators.\n-* _Encapsulating common arguments_. For example, vectors of `&str`s\n-  provide a `connect` as well as a special case, `concat`, that is expressible\n-  using `connect` with a fixed separator of `\"\"`.\n-* _Providing more efficient special cases_. The `connect` and `concat` example\n-  also applies here: singling out `concat` as a special case allows for a more\n-  efficient implementation.\n-\n-  Note, however, that the `connect` method actually detects the special case\n-  internally and invokes `concat`. Usually, it is not necessary to add a public\n-  convenience method just for efficiency gains; there should also be a\n-  _conceptual_ reason to add it, e.g. because it is such a common special case.\n-\n-It is tempting to add convenience methods in a one-off, haphazard way as\n-common use patterns emerge. Avoid this temptation, and instead _design_ small,\n-coherent sets of convenience methods that are easy to remember:\n-\n-* _Small_: Avoid combinatorial explosions of convenience methods. For example,\n-  instead of adding `_str` variants of methods that provide a `str` output,\n-  instead ensure that the normal output type of methods is easily convertible to\n-  `str`.\n-* _Coherent_: Look for small groups of convenience methods that make sense to\n-  include together. For example, the `Path` API mentioned above includes a small\n-  selection of the most common filesystem operations that take a `Path`\n-  argument.  If one convenience method strongly suggests the existence of others,\n-  consider adding the whole group.\n-* _Memorable_: It is not worth saving a few characters of typing if you have to\n-  look up the name of a convenience method every time you use it. Add\n-  convenience methods with names that are obvious and easy to remember, and add\n-  them for the most common or painful use cases."}, {"sha": "5b63a4514443c47ea17943d4b1ad0d8bee3dcd6e", "filename": "src/doc/style/features/functions-and-methods/input.md", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Finput.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Finput.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Finput.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,203 +0,0 @@\n-% Input to functions and methods\n-\n-### Let the client decide when to copy and where to place data. [FIXME: needs RFC]\n-\n-#### Copying:\n-\n-Prefer\n-\n-```rust,ignore\n-fn foo(b: Bar) {\n-   // use b as owned, directly\n-}\n-```\n-\n-over\n-\n-```rust,ignore\n-fn foo(b: &Bar) {\n-    let b = b.clone();\n-    // use b as owned after cloning\n-}\n-```\n-\n-If a function requires ownership of a value of unknown type `T`, but does not\n-otherwise need to make copies, the function should take ownership of the\n-argument (pass by value `T`) rather than using `.clone()`. That way, the caller\n-can decide whether to relinquish ownership or to `clone`.\n-\n-Similarly, the `Copy` trait bound should only be demanded it when absolutely\n-needed, not as a way of signaling that copies should be cheap to make.\n-\n-#### Placement:\n-\n-Prefer\n-\n-```rust,ignore\n-fn foo(b: Bar) -> Bar { ... }\n-```\n-\n-over\n-\n-```rust,ignore\n-fn foo(b: Box<Bar>) -> Box<Bar> { ... }\n-```\n-\n-for concrete types `Bar` (as opposed to trait objects). This way, the caller can\n-decide whether to place data on the stack or heap. No overhead is imposed by\n-letting the caller determine the placement.\n-\n-### Minimize assumptions about parameters. [FIXME: needs RFC]\n-\n-The fewer assumptions a function makes about its inputs, the more widely usable\n-it becomes.\n-\n-#### Minimizing assumptions through generics:\n-\n-Prefer\n-\n-```rust,ignore\n-fn foo<T: Iterator<i32>>(c: T) { ... }\n-```\n-\n-over any of\n-\n-```rust,ignore\n-fn foo(c: &[i32]) { ... }\n-fn foo(c: &Vec<i32>) { ... }\n-fn foo(c: &SomeOtherCollection<i32>) { ... }\n-```\n-\n-if the function only needs to iterate over the data.\n-\n-More generally, consider using generics to pinpoint the assumptions a function\n-needs to make about its arguments.\n-\n-On the other hand, generics can make it more difficult to read and understand a\n-function's signature. Aim for \"natural\" parameter types that a neither overly\n-concrete nor overly abstract. See the discussion on\n-[traits](../traits/README.md) for more guidance.\n-\n-\n-#### Minimizing ownership assumptions:\n-\n-Prefer either of\n-\n-```rust,ignore\n-fn foo(b: &Bar) { ... }\n-fn foo(b: &mut Bar) { ... }\n-```\n-\n-over\n-\n-```rust,ignore\n-fn foo(b: Bar) { ... }\n-```\n-\n-That is, prefer borrowing arguments rather than transferring ownership, unless\n-ownership is actually needed.\n-\n-### Prefer compound return types to out-parameters. [FIXME: needs RFC]\n-\n-Prefer\n-\n-```rust,ignore\n-fn foo() -> (Bar, Bar)\n-```\n-\n-over\n-\n-```rust,ignore\n-fn foo(output: &mut Bar) -> Bar\n-```\n-\n-for returning multiple `Bar` values.\n-\n-Compound return types like tuples and structs are efficiently compiled\n-and do not require heap allocation. If a function needs to return\n-multiple values, it should do so via one of these types.\n-\n-The primary exception: sometimes a function is meant to modify data\n-that the caller already owns, for example to re-use a buffer:\n-\n-```rust,ignore\n-fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize>\n-```\n-\n-(From the [Read trait](https://doc.rust-lang.org/stable/std/io/trait.Read.html#tymethod.read).)\n-\n-### Consider validating arguments, statically or dynamically. [FIXME: needs RFC]\n-\n-_Note: this material is closely related to\n-  [library-level guarantees](../../safety/lib-guarantees.md)._\n-\n-Rust APIs do _not_ generally follow the\n-[robustness principle](https://en.wikipedia.org/wiki/Robustness_principle): \"be\n-conservative in what you send; be liberal in what you accept\".\n-\n-Instead, Rust code should _enforce_ the validity of input whenever practical.\n-\n-Enforcement can be achieved through the following mechanisms (listed\n-in order of preference).\n-\n-#### Static enforcement:\n-\n-Choose an argument type that rules out bad inputs.\n-\n-For example, prefer\n-\n-```rust,ignore\n-enum FooMode {\n-    Mode1,\n-    Mode2,\n-    Mode3,\n-}\n-fn foo(mode: FooMode) { ... }\n-```\n-\n-over\n-\n-```rust,ignore\n-fn foo(mode2: bool, mode3: bool) {\n-    assert!(!mode2 || !mode3);\n-    ...\n-}\n-```\n-\n-Static enforcement usually comes at little run-time cost: it pushes the\n-costs to the boundaries. It also catches bugs early, during compilation,\n-rather than through run-time failures.\n-\n-On the other hand, some properties are difficult or impossible to\n-express using types.\n-\n-#### Dynamic enforcement:\n-\n-Validate the input as it is processed (or ahead of time, if necessary).  Dynamic\n-checking is often easier to implement than static checking, but has several\n-downsides:\n-\n-1. Runtime overhead (unless checking can be done as part of processing the input).\n-2. Delayed detection of bugs.\n-3. Introduces failure cases, either via `panic!` or `Result`/`Option` types (see\n-   the [error handling guidelines](../../errors/README.md)), which must then be\n-   dealt with by client code.\n-\n-#### Dynamic enforcement with `debug_assert!`:\n-\n-Same as dynamic enforcement, but with the possibility of easily turning off\n-expensive checks for production builds.\n-\n-#### Dynamic enforcement with opt-out:\n-\n-Same as dynamic enforcement, but adds sibling functions that opt out of the\n-checking.\n-\n-The convention is to mark these opt-out functions with a suffix like\n-`_unchecked` or by placing them in a `raw` submodule.\n-\n-The unchecked functions can be used judiciously in cases where (1) performance\n-dictates avoiding checks and (2) the client is otherwise confident that the\n-inputs are valid.\n-\n-> **[FIXME]** Should opt-out functions be marked `unsafe`?"}, {"sha": "e26eee53367cf80e4638bb2279c2e90ce200f495", "filename": "src/doc/style/features/functions-and-methods/output.md", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Foutput.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Foutput.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Foutput.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,56 +0,0 @@\n-% Output from functions and methods\n-\n-### Don't overpromise. [FIXME]\n-\n-> **[FIXME]** Add discussion of overly-specific return types,\n-> e.g. returning a compound iterator type rather than hiding it behind\n-> a use of newtype.\n-\n-### Let clients choose what to throw away. [FIXME: needs RFC]\n-\n-#### Return useful intermediate results:\n-\n-Many functions that answer a question also compute interesting related data.  If\n-this data is potentially of interest to the client, consider exposing it in the\n-API.\n-\n-Prefer\n-\n-```rust,ignore\n-struct SearchResult {\n-    found: bool,          // item in container?\n-    expected_index: usize // what would the item's index be?\n-}\n-\n-fn binary_search(&self, k: Key) -> SearchResult\n-```\n-or\n-\n-```rust,ignore\n-fn binary_search(&self, k: Key) -> (bool, usize)\n-```\n-\n-over\n-\n-```rust,ignore\n-fn binary_search(&self, k: Key) -> bool\n-```\n-\n-#### Yield back ownership:\n-\n-Prefer\n-\n-```rust,ignore\n-fn from_utf8_owned(vv: Vec<u8>) -> Result<String, Vec<u8>>\n-```\n-\n-over\n-\n-```rust,ignore\n-fn from_utf8_owned(vv: Vec<u8>) -> Option<String>\n-```\n-\n-The `from_utf8_owned` function gains ownership of a vector.  In the successful\n-case, the function consumes its input, returning an owned string without\n-allocating or copying. In the unsuccessful case, however, the function returns\n-back ownership of the original slice."}, {"sha": "ba9787b45f13c2310ab78f3b12b578219e6bc09d", "filename": "src/doc/style/features/let.md", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Flet.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Flet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Flet.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,103 +0,0 @@\n-% Let binding\n-\n-### Always separately bind RAII guards. [FIXME: needs RFC]\n-\n-Prefer\n-\n-```rust,ignore\n-fn use_mutex(m: sync::mutex::Mutex<i32>) {\n-    let guard = m.lock();\n-    do_work(guard);\n-    drop(guard); // unlock the lock\n-    // do other work\n-}\n-```\n-\n-over\n-\n-```rust,ignore\n-fn use_mutex(m: sync::mutex::Mutex<i32>) {\n-    do_work(m.lock());\n-    // do other work\n-}\n-```\n-\n-As explained in the [RAII guide](../ownership/raii.md), RAII guards are values\n-that represent ownership of some resource and whose destructor releases the\n-resource. Because the lifetime of guards are significant, they should always be\n-explicitly `let`-bound to make the lifetime clear. Consider using an explicit\n-`drop` to release the resource early.\n-\n-### Prefer conditional expressions to deferred initialization. [FIXME: needs RFC]\n-\n-Prefer\n-\n-```rust,ignore\n-let foo = match bar {\n-    Baz => 0,\n-    Quux => 1\n-};\n-```\n-\n-over\n-\n-```rust,ignore\n-let foo;\n-match bar {\n-    Baz => {\n-        foo = 0;\n-    }\n-    Quux => {\n-        foo = 1;\n-    }\n-}\n-```\n-\n-unless the conditions for initialization are too complex to fit into a simple\n-conditional expression.\n-\n-### Use type annotations for clarification; prefer explicit generics when inference fails. [FIXME: needs RFC]\n-\n-Prefer\n-\n-```rust,ignore\n-let v = s.iter().map(|x| x * 2)\n-                .collect::<Vec<_>>();\n-```\n-\n-over\n-\n-```rust,ignore\n-let v: Vec<_> = s.iter().map(|x| x * 2)\n-                        .collect();\n-```\n-\n-When the type of a value might be unclear to the _reader_ of the code, consider\n-explicitly annotating it in a `let`.\n-\n-On the other hand, when the type is unclear to the _compiler_, prefer to specify\n-the type by explicit generics instantiation, which is usually more clear.\n-\n-### Shadowing [FIXME]\n-\n-> **[FIXME]** Repeatedly shadowing a binding is somewhat common in Rust code. We\n-> need to articulate a guideline on when it is appropriate/useful and when not.\n-\n-### Prefer immutable bindings. [FIXME: needs RFC]\n-\n-Use `mut` bindings to signal the span during which a value is mutated:\n-\n-```rust,ignore\n-let mut v = Vec::new();\n-// push things onto v\n-let v = v;\n-// use v immutably henceforth\n-```\n-\n-### Prefer to bind all `struct` or tuple fields. [FIXME: needs RFC]\n-\n-When consuming a `struct` or tuple via a `let`, bind all of the fields rather\n-than using `..` to elide the ones you don't need. The benefit is that when\n-fields are added, the compiler will pinpoint all of the places where that type\n-of value was consumed, which will often need to be adjusted to take the new\n-field properly into account."}, {"sha": "b144825f98183d8a44bd6143d2b72d5a8c9e188d", "filename": "src/doc/style/features/loops.md", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Floops.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Floops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Floops.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,13 +0,0 @@\n-% Loops\n-\n-### Prefer `for` to `while`. [FIXME: needs RFC]\n-\n-A `for` loop is preferable to a `while` loop, unless the loop counts in a\n-non-uniform way (making it difficult to express using `for`).\n-\n-### Guidelines for `loop`. [FIXME]\n-\n-> **[FIXME]** When is `loop` recommended? Some possibilities:\n-> * For optimistic retry algorithms\n-> * For servers\n-> * To avoid mutating local variables sometimes needed to fit `while`"}, {"sha": "0d5a1184a0e876f7ad8d544ab97c8b50cb5ca72f", "filename": "src/doc/style/features/match.md", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Fmatch.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,26 +0,0 @@\n-% Pattern matching\n-\n-### Dereference `match` targets when possible. [FIXME: needs RFC]\n-\n-Prefer\n-\n-~~~~ignore\n-match *foo {\n-    X(...) => ...\n-    Y(...) => ...\n-}\n-~~~~\n-\n-over\n-\n-~~~~ignore\n-match foo {\n-    box X(...) => ...\n-    box Y(...) => ...\n-}\n-~~~~\n-\n-<!-- ### Clearly indicate important scopes. **[FIXME: needs RFC]** -->\n-\n-<!-- If it is important that the destructor for a value be executed at a specific -->\n-<!-- time, clearly bind that value using a standalone `let` -->"}, {"sha": "995c5fda8a0aa65f123be724c1d0078567083e86", "filename": "src/doc/style/features/modules.md", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,133 +0,0 @@\n-% Modules\n-\n-> **[FIXME]** What general guidelines should we provide for module design?\n-\n-> We should discuss visibility, nesting, `mod.rs`, and any interesting patterns\n-> around modules.\n-\n-### Headers [FIXME: needs RFC]\n-\n-Organize module headers as follows:\n-  1. [Imports](../style/imports.md).\n-  1. `mod` declarations.\n-  1. `pub mod` declarations.\n-\n-### Avoid `path` directives. [FIXME: needs RFC]\n-\n-Avoid using `#[path=\"...\"]` directives; make the file system and\n-module hierarchy match, instead.\n-\n-### Use the module hierarchy to organize APIs into coherent sections. [FIXME]\n-\n-> **[FIXME]** Flesh this out with examples; explain what a \"coherent\n-> section\" is with examples.\n->\n-> The module hierarchy defines both the public and internal API of your module.\n-> Breaking related functionality into submodules makes it understandable to both\n-> users and contributors to the module.\n-\n-### Place modules in their own file. [FIXME: needs RFC]\n-\n-> **[FIXME]**\n-> - \"<100 lines\" is arbitrary, but it's a clearer recommendation\n->   than \"~1 page\" or similar suggestions that vary by screen size, etc.\n-\n-For all except very short modules (<100 lines) and [tests](../testing/README.md),\n-place the module `foo` in a separate file, as in:\n-\n-```rust,ignore\n-pub mod foo;\n-\n-// in foo.rs or foo/mod.rs\n-pub fn bar() { println!(\"...\"); }\n-/* ... */\n-```\n-\n-rather than declaring it inline:\n-\n-```rust,ignore\n-pub mod foo {\n-    pub fn bar() { println!(\"...\"); }\n-    /* ... */\n-}\n-```\n-\n-#### Use subdirectories for modules with children. [FIXME: needs RFC]\n-\n-For modules that themselves have submodules, place the module in a separate\n-directory (e.g., `bar/mod.rs` for a module `bar`) rather than the same directory.\n-\n-Note the structure of\n-[`std::io`](https://doc.rust-lang.org/std/io/). Many of the submodules lack\n-children, like\n-[`io::fs`](https://doc.rust-lang.org/std/io/fs/)\n-and\n-[`io::stdio`](https://doc.rust-lang.org/std/io/stdio/).\n-On the other hand,\n-[`io::net`](https://doc.rust-lang.org/std/io/net/)\n-contains submodules, so it lives in a separate directory:\n-\n-```text\n-io/mod.rs\n-   io/extensions.rs\n-   io/fs.rs\n-   io/net/mod.rs\n-          io/net/addrinfo.rs\n-          io/net/ip.rs\n-          io/net/tcp.rs\n-          io/net/udp.rs\n-          io/net/unix.rs\n-   io/pipe.rs\n-   ...\n-```\n-\n-While it is possible to define all of `io` within a single directory,\n-mirroring the module hierarchy in the directory structure makes\n-submodules of `io::net` easier to find.\n-\n-### Consider top-level definitions or reexports. [FIXME: needs RFC]\n-\n-For modules with submodules,\n-define or [reexport](https://doc.rust-lang.org/std/io/#reexports) commonly used\n-definitions at the top level:\n-\n-* Functionality relevant to the module itself or to many of its\n-  children should be defined in `mod.rs`.\n-* Functionality specific to a submodule should live in that\n-  submodule. Reexport at the top level for the most important or\n-  common definitions.\n-\n-For example,\n-[`IoError`](https://doc.rust-lang.org/std/io/struct.IoError.html)\n-is defined in `io/mod.rs`, since it pertains to the entirety of `io`,\n-while\n-[`TcpStream`](https://doc.rust-lang.org/std/io/net/tcp/struct.TcpStream.html)\n-is defined in `io/net/tcp.rs` and reexported in the `io` module.\n-\n-### Use internal module hierarchies for organization. [FIXME: needs RFC]\n-\n-> **[FIXME]**\n-> - Referencing internal modules from the standard library is subject to\n->   becoming outdated.\n-\n-Internal module hierarchies (i.e., private submodules) may be used to\n-hide implementation details that are not part of the module's API.\n-\n-For example, in [`std::io`](https://doc.rust-lang.org/std/io/), `mod mem`\n-provides implementations for\n-[`BufReader`](https://doc.rust-lang.org/std/io/struct.BufReader.html)\n-and\n-[`BufWriter`](https://doc.rust-lang.org/std/io/struct.BufWriter.html),\n-but these are re-exported in `io/mod.rs` at the top level of the module:\n-\n-```rust,ignore\n-// libstd/io/mod.rs\n-\n-pub use self::mem::{MemReader, BufReader, MemWriter, BufWriter};\n-/* ... */\n-mod mem;\n-```\n-\n-This hides the detail that there even exists a `mod mem` in `io`, and\n-helps keep code organized while offering freedom to change the\n-implementation."}, {"sha": "1893db24466fa861a075035a917092a81b021094", "filename": "src/doc/style/features/traits/README.md", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2FREADME.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,22 +0,0 @@\n-% Traits\n-\n-Traits are probably Rust's most complex feature, supporting a wide range of use\n-cases and design tradeoffs. Patterns of trait usage are still emerging.\n-\n-### Know whether a trait will be used as an object. [FIXME: needs RFC]\n-\n-Trait objects have some [significant limitations](objects.md): methods\n-invoked through a trait object cannot use generics, and cannot use\n-`Self` except in receiver position.\n-\n-When designing a trait, decide early on whether the trait will be used\n-as an [object](objects.md) or as a [bound on generics](generics.md);\n-the tradeoffs are discussed in each of the linked sections.\n-\n-If a trait is meant to be used as an object, its methods should take\n-and return trait objects rather than use generics.\n-\n-\n-### Default methods [FIXME]\n-\n-> **[FIXME]** Guidelines for default methods."}, {"sha": "e8699c75229d36fc6286d54c7add8114b919aedf", "filename": "src/doc/style/features/traits/common.md", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fcommon.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fcommon.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fcommon.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,71 +0,0 @@\n-% Common traits\n-\n-### Eagerly implement common traits. [FIXME: needs RFC]\n-\n-Rust's trait system does not allow _orphans_: roughly, every `impl` must live\n-either in the crate that defines the trait or the implementing\n-type. Consequently, crates that define new types should eagerly implement all\n-applicable, common traits.\n-\n-To see why, consider the following situation:\n-\n-* Crate `std` defines trait `Debug`.\n-* Crate `url` defines type `Url`, without implementing `Debug`.\n-* Crate `webapp` imports from both `std` and `url`,\n-\n-There is no way for `webapp` to add `Debug` to `url`, since it defines neither.\n-(Note: the newtype pattern can provide an efficient, but inconvenient\n-workaround; see [newtype for views](../types/newtype.md))\n-\n-The most important common traits to implement from `std` are:\n-\n-```text\n-Clone, Debug, Hash, Eq\n-```\n-\n-#### When safe, derive or otherwise implement `Send` and `Share`. [FIXME]\n-\n-> **[FIXME]**. This guideline is in flux while the \"opt-in\" nature of\n-> built-in traits is being decided. See https://github.com/rust-lang/rfcs/pull/127\n-\n-### Prefer to derive, rather than implement. [FIXME: needs RFC]\n-\n-Deriving saves implementation effort, makes correctness trivial, and\n-automatically adapts to upstream changes.\n-\n-### Do not overload operators in surprising ways. [FIXME: needs RFC]\n-\n-Operators with built in syntax (`*`, `|`, and so on) can be provided for a type\n-by implementing the traits in `core::ops`. These operators come with strong\n-expectations: implement `Mul` only for an operation that bears some resemblance\n-to multiplication (and shares the expected properties, e.g. associativity), and\n-so on for the other traits.\n-\n-### The `Drop` trait\n-\n-The `Drop` trait is treated specially by the compiler as a way of\n-associating destructors with types. See\n-[the section on destructors](../../ownership/destructors.md) for\n-guidance.\n-\n-### The `Deref`/`DerefMut` traits\n-\n-#### Use `Deref`/`DerefMut` only for smart pointers. [FIXME: needs RFC]\n-\n-The `Deref` traits are used implicitly by the compiler in many circumstances,\n-and interact with method resolution. The relevant rules are designed\n-specifically to accommodate smart pointers, and so the traits should be used\n-only for that purpose.\n-\n-#### Do not fail within a `Deref`/`DerefMut` implementation. [FIXME: needs RFC]\n-\n-Because the `Deref` traits are invoked implicitly by the compiler in sometimes\n-subtle ways, failure during dereferencing can be extremely confusing. If a\n-dereference might not succeed, target the `Deref` trait as a `Result` or\n-`Option` type instead.\n-\n-#### Avoid inherent methods when implementing `Deref`/`DerefMut` [FIXME: needs RFC]\n-\n-The rules around method resolution and `Deref` are in flux, but inherent methods\n-on a type implementing `Deref` are likely to shadow any methods of the referent\n-with the same name."}, {"sha": "fc3a03c01f5a184e5afdb75d62ec6e32f3cd1fa0", "filename": "src/doc/style/features/traits/extensions.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fextensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fextensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fextensions.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,7 +0,0 @@\n-% Using traits to add extension methods\n-\n-> **[FIXME]** Elaborate.\n-\n-### Consider using default methods rather than extension traits **[FIXME]**\n-\n-> **[FIXME]** Elaborate."}, {"sha": "f9dac1272c33405406922fcba844e4295b7119fd", "filename": "src/doc/style/features/traits/generics.md", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,67 +0,0 @@\n-% Using traits for bounds on generics\n-\n-The most widespread use of traits is for writing generic functions or types. For\n-example, the following signature describes a function for consuming any iterator\n-yielding items of type `A` to produce a collection of `A`:\n-\n-```rust,ignore\n-fn from_iter<T: Iterator<A>>(iterator: T) -> SomeCollection<A>\n-```\n-\n-Here, the `Iterator` trait specifies an interface that a type `T` must\n-explicitly implement to be used by this generic function.\n-\n-**Pros**:\n-\n-* _Reusability_. Generic functions can be applied to an open-ended collection of\n-  types, while giving a clear contract for the functionality those types must\n-  provide.\n-* _Static dispatch and optimization_. Each use of a generic function is\n-  specialized (\"monomorphized\") to the particular types implementing the trait\n-  bounds, which means that (1) invocations of trait methods are static, direct\n-  calls to the implementation and (2) the compiler can inline and otherwise\n-  optimize these calls.\n-* _Inline layout_. If a `struct` and `enum` type is generic over some type\n-  parameter `T`, values of type `T` will be laid out _inline_ in the\n-  `struct`/`enum`, without any indirection.\n-* _Inference_. Since the type parameters to generic functions can usually be\n-  inferred, generic functions can help cut down on verbosity in code where\n-  explicit conversions or other method calls would usually be necessary. See the\n-  overloading/implicits use case below.\n-* _Precise types_. Because generics give a _name_ to the specific type\n-  implementing a trait, it is possible to be precise about places where that\n-  exact type is required or produced. For example, a function\n-\n-  ```rust,ignore\n-  fn binary<T: Trait>(x: T, y: T) -> T\n-  ```\n-\n-  is guaranteed to consume and produce elements of exactly the same type `T`; it\n-  cannot be invoked with parameters of different types that both implement\n-  `Trait`.\n-\n-**Cons**:\n-\n-* _Code size_. Specializing generic functions means that the function body is\n-  duplicated. The increase in code size must be weighed against the performance\n-  benefits of static dispatch.\n-* _Homogeneous types_. This is the other side of the \"precise types\" coin: if\n-  `T` is a type parameter, it stands for a _single_ actual type. So for example\n-  a `Vec<T>` contains elements of a single concrete type (and, indeed, the\n-  vector representation is specialized to lay these out in line). Sometimes\n-  heterogeneous collections are useful; see\n-  trait objects below.\n-* _Signature verbosity_. Heavy use of generics can bloat function signatures.\n-  **[Ed. note]** This problem may be mitigated by some language improvements; stay tuned.\n-\n-### Favor widespread traits. **[FIXME: needs RFC]**\n-\n-Generic types are a form of abstraction, which entails a mental indirection: if\n-a function takes an argument of type `T` bounded by `Trait`, clients must first\n-think about the concrete types that implement `Trait` to understand how and when\n-the function is callable.\n-\n-To keep the cost of abstraction low, favor widely-known traits. Whenever\n-possible, implement and use traits provided as part of the standard library.  Do\n-not introduce new traits for generics lightly; wait until there are a wide range\n-of types that can implement the type."}, {"sha": "34712ed1ae7f131c414aa9ae8ac67cb10947ab50", "filename": "src/doc/style/features/traits/objects.md", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fobjects.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fobjects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fobjects.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,49 +0,0 @@\n-% Using trait objects\n-\n-> **[FIXME]** What are uses of trait objects other than heterogeneous collections?\n-\n-Trait objects are useful primarily when _heterogeneous_ collections of objects\n-need to be treated uniformly; it is the closest that Rust comes to\n-object-oriented programming.\n-\n-```rust,ignore\n-struct Frame  { ... }\n-struct Button { ... }\n-struct Label  { ... }\n-\n-trait Widget  { ... }\n-\n-impl Widget for Frame  { ... }\n-impl Widget for Button { ... }\n-impl Widget for Label  { ... }\n-\n-impl Frame {\n-    fn new(contents: &[Box<Widget>]) -> Frame {\n-        ...\n-    }\n-}\n-\n-fn make_gui() -> Box<Widget> {\n-    let b: Box<Widget> = box Button::new(...);\n-    let l: Box<Widget> = box Label::new(...);\n-\n-    box Frame::new([b, l]) as Box<Widget>\n-}\n-```\n-\n-By using trait objects, we can set up a GUI framework with a `Frame` widget that\n-contains a heterogeneous collection of children widgets.\n-\n-**Pros**:\n-\n-* _Heterogeneity_. When you need it, you really need it.\n-* _Code size_. Unlike generics, trait objects do not generate specialized\n-  (monomorphized) versions of code, which can greatly reduce code size.\n-\n-**Cons**:\n-\n-* _No generic methods_. Trait objects cannot currently provide generic methods.\n-* _Dynamic dispatch and fat pointers_. Trait objects inherently involve\n-  indirection and vtable dispatch, which can carry a performance penalty.\n-* _No Self_. Except for the method receiver argument, methods on trait objects\n-  cannot use the `Self` type."}, {"sha": "d7482c96190723e943812db84cb4e1a4774a2fac", "filename": "src/doc/style/features/traits/overloading.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Foverloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Foverloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Foverloading.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,7 +0,0 @@\n-% Using traits for overloading\n-\n-> **[FIXME]** Elaborate.\n-\n-> **[FIXME]** We need to decide on guidelines for this use case. There are a few\n-> patterns emerging in current Rust code, but it's not clear how widespread they\n-> should be."}, {"sha": "feedd3937fc9dcac67e804cff5ced6af966c177e", "filename": "src/doc/style/features/traits/reuse.md", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,30 +0,0 @@\n-% Using traits to share implementations\n-\n-> **[FIXME]** Elaborate.\n-\n-> **[FIXME]** We probably want to discourage this, at least when used in a way\n-> that is publicly exposed.\n-\n-Traits that provide default implementations for function can provide code reuse\n-across types. For example, a `print` method can be defined across multiple\n-types as follows:\n-\n-``` Rust\n-trait Printable {\n-    // Default method implementation\n-    fn print(&self) { println!(\"{:?}\", *self) }\n-}\n-\n-impl Printable for i32 {}\n-\n-impl Printable for String {\n-    fn print(&self) { println!(\"{}\", *self) }\n-}\n-\n-impl Printable for bool {}\n-\n-impl Printable for f32 {}\n-```\n-\n-This allows the implementation of `print` to be shared across types, yet\n-overridden where needed, as seen in the `impl` for `String`."}, {"sha": "d3b95d8a6e719d3df1ab956c733636e0e3698d60", "filename": "src/doc/style/features/types/README.md", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2FREADME.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,68 +0,0 @@\n-% Data types\n-\n-### Use custom types to imbue meaning; do not abuse `bool`, `Option` or other core types. **[FIXME: needs RFC]**\n-\n-Prefer\n-\n-```rust,ignore\n-let w = Widget::new(Small, Round)\n-```\n-\n-over\n-\n-```rust,ignore\n-let w = Widget::new(true, false)\n-```\n-\n-Core types like `bool`, `u8` and `Option` have many possible interpretations.\n-\n-Use custom types (whether `enum`s, `struct`, or tuples) to convey\n-interpretation and invariants. In the above example,\n-it is not immediately clear what `true` and `false` are conveying without\n-looking up the argument names, but `Small` and `Round` are more suggestive.\n-\n-Using custom types makes it easier to expand the\n-options later on, for example by adding an `ExtraLarge` variant.\n-\n-See [the newtype pattern](newtype.md) for a no-cost way to wrap\n-existing types with a distinguished name.\n-\n-### Prefer private fields, except for passive data. **[FIXME: needs RFC]**\n-\n-Making a field public is a strong commitment: it pins down a representation\n-choice, _and_ prevents the type from providing any validation or maintaining any\n-invariants on the contents of the field, since clients can mutate it arbitrarily.\n-\n-Public fields are most appropriate for `struct` types in the C spirit: compound,\n-passive data structures. Otherwise, consider providing getter/setter methods\n-and hiding fields instead.\n-\n-> **[FIXME]** Cross-reference validation for function arguments.\n-\n-### Use custom `enum`s for alternatives, `bitflags` for C-style flags. **[FIXME: needs RFC]**\n-\n-Rust supports `enum` types with \"custom discriminants\":\n-\n-~~~~\n-enum Color {\n-  Red = 0xff0000,\n-  Green = 0x00ff00,\n-  Blue = 0x0000ff\n-}\n-~~~~\n-\n-Custom discriminants are useful when an `enum` type needs to be serialized to an\n-integer value compatibly with some other system/language. They support\n-\"typesafe\" APIs: by taking a `Color`, rather than an integer, a function is\n-guaranteed to get well-formed inputs, even if it later views those inputs as\n-integers.\n-\n-An `enum` allows an API to request exactly one choice from among many. Sometimes\n-an API's input is instead the presence or absence of a set of flags. In C code,\n-this is often done by having each flag correspond to a particular bit, allowing\n-a single integer to represent, say, 32 or 64 flags. Rust's `std::bitflags`\n-module provides a typesafe way for doing so.\n-\n-### Phantom types. [FIXME]\n-\n-> **[FIXME]** Add some material on phantom types (https://blog.mozilla.org/research/2014/06/23/static-checking-of-units-in-servo/)"}, {"sha": "f0f230f57e557cf2c08d8058ecd1cb5ec41a4652", "filename": "src/doc/style/features/types/conversions.md", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fconversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fconversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fconversions.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,22 +0,0 @@\n-% Conversions between types\n-\n-### Associate conversions with the most specific type involved. **[FIXME: needs RFC]**\n-\n-When in doubt, prefer `to_`/`as_`/`into_` to `from_`, because they are\n-more ergonomic to use (and can be chained with other methods).\n-\n-For many conversions between two types, one of the types is clearly more\n-\"specific\": it provides some additional invariant or interpretation that is not\n-present in the other type. For example, `str` is more specific than `&[u8]`,\n-since it is a utf-8 encoded sequence of bytes.\n-\n-Conversions should live with the more specific of the involved types. Thus,\n-`str` provides both the `as_bytes` method and the `from_utf8` constructor for\n-converting to and from `&[u8]` values. Besides being intuitive, this convention\n-avoids polluting concrete types like `&[u8]` with endless conversion methods.\n-\n-### Explicitly mark lossy conversions, or do not label them as conversions. **[FIXME: needs RFC]**\n-\n-If a function's name implies that it is a conversion (prefix `from_`, `as_`,\n-`to_` or `into_`), but the function loses information, add a suffix `_lossy` or\n-otherwise indicate the lossyness. Consider avoiding the conversion name prefix."}, {"sha": "9646e3e82aa5384e73f81c6f44d898e8b9661567", "filename": "src/doc/style/features/types/newtype.md", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fnewtype.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fnewtype.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fnewtype.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,69 +0,0 @@\n-% The newtype pattern\n-\n-A \"newtype\" is a tuple or `struct` with a single field. The terminology is borrowed from Haskell.\n-\n-Newtypes are a zero-cost abstraction: they introduce a new, distinct name for an\n-existing type, with no runtime overhead when converting between the two types.\n-\n-### Use newtypes to provide static distinctions. [FIXME: needs RFC]\n-\n-Newtypes can statically distinguish between different interpretations of an\n-underlying type.\n-\n-For example, a `f64` value might be used to represent a quantity in miles or in\n-kilometers. Using newtypes, we can keep track of the intended interpretation:\n-\n-```rust,ignore\n-struct Miles(pub f64);\n-struct Kilometers(pub f64);\n-\n-impl Miles {\n-    fn as_kilometers(&self) -> Kilometers { ... }\n-}\n-impl Kilometers {\n-    fn as_miles(&self) -> Miles { ... }\n-}\n-```\n-\n-Once we have separated these two types, we can statically ensure that we do not\n-confuse them. For example, the function\n-\n-```rust,ignore\n-fn are_we_there_yet(distance_travelled: Miles) -> bool { ... }\n-```\n-\n-cannot accidentally be called with a `Kilometers` value. The compiler will\n-remind us to perform the conversion, thus averting certain\n-[catastrophic bugs](http://en.wikipedia.org/wiki/Mars_Climate_Orbiter).\n-\n-### Use newtypes with private fields for hiding. [FIXME: needs RFC]\n-\n-A newtype can be used to hide representation details while making precise\n-promises to the client.\n-\n-For example, consider a function `my_transform` that returns a compound iterator\n-type `Enumerate<Skip<vec::MoveItems<T>>>`. We wish to hide this type from the\n-client, so that the client's view of the return type is roughly `Iterator<(usize,\n-T)>`. We can do so using the newtype pattern:\n-\n-```rust,ignore\n-struct MyTransformResult<T>(Enumerate<Skip<vec::MoveItems<T>>>);\n-impl<T> Iterator<(usize, T)> for MyTransformResult<T> { ... }\n-\n-fn my_transform<T, Iter: Iterator<T>>(iter: Iter) -> MyTransformResult<T> {\n-    ...\n-}\n-```\n-\n-Aside from simplifying the signature, this use of newtypes allows us to make a\n-expose and promise less to the client. The client does not know _how_ the result\n-iterator is constructed or represented, which means the representation can\n-change in the future without breaking client code.\n-\n-> **[FIXME]** Interaction with auto-deref.\n-\n-### Use newtypes to provide cost-free _views_ of another type. **[FIXME]**\n-\n-> **[FIXME]** Describe the pattern of using newtypes to provide a new set of\n-> inherent or trait methods, providing a different perspective on the underlying\n-> type."}, {"sha": "11bdb03a3a81851cc6e77b56a62b779ef5172b79", "filename": "src/doc/style/ownership/README.md", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fownership%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fownership%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2FREADME.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,3 +0,0 @@\n-% Ownership and resource management\n-\n-> **[FIXME]** Add general remarks about ownership/resources here."}, {"sha": "3422591233275317e416c11bdeb2295f97ecf307", "filename": "src/doc/style/ownership/builders.md", "status": "removed", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,176 +0,0 @@\n-% The builder pattern\n-\n-Some data structures are complicated to construct, due to their construction needing:\n-\n-* a large number of inputs\n-* compound data (e.g. slices)\n-* optional configuration data\n-* choice between several flavors\n-\n-which can easily lead to a large number of distinct constructors with\n-many arguments each.\n-\n-If `T` is such a data structure, consider introducing a `T` _builder_:\n-\n-1. Introduce a separate data type `TBuilder` for incrementally configuring a `T`\n-   value. When possible, choose a better name: e.g. `Command` is the builder for\n-   `Process`.\n-2. The builder constructor should take as parameters only the data _required_ to\n-   make a `T`.\n-3. The builder should offer a suite of convenient methods for configuration,\n-   including setting up compound inputs (like slices) incrementally.\n-   These methods should return `self` to allow chaining.\n-4. The builder should provide one or more \"_terminal_\" methods for actually building a `T`.\n-\n-The builder pattern is especially appropriate when building a `T` involves side\n-effects, such as spawning a thread or launching a process.\n-\n-In Rust, there are two variants of the builder pattern, differing in the\n-treatment of ownership, as described below.\n-\n-### Non-consuming builders (preferred):\n-\n-In some cases, constructing the final `T` does not require the builder itself to\n-be consumed. The follow variant on\n-[`std::process::Command`](https://doc.rust-lang.org/stable/std/process/struct.Command.html)\n-is one example:\n-\n-```rust,ignore\n-// NOTE: the actual Command API does not use owned Strings;\n-// this is a simplified version.\n-\n-pub struct Command {\n-    program: String,\n-    args: Vec<String>,\n-    cwd: Option<String>,\n-    // etc\n-}\n-\n-impl Command {\n-    pub fn new(program: String) -> Command {\n-        Command {\n-            program: program,\n-            args: Vec::new(),\n-            cwd: None,\n-        }\n-    }\n-\n-    /// Add an argument to pass to the program.\n-    pub fn arg<'a>(&'a mut self, arg: String) -> &'a mut Command {\n-        self.args.push(arg);\n-        self\n-    }\n-\n-    /// Add multiple arguments to pass to the program.\n-    pub fn args<'a>(&'a mut self, args: &[String])\n-                    -> &'a mut Command {\n-        self.args.push_all(args);\n-        self\n-    }\n-\n-    /// Set the working directory for the child process.\n-    pub fn cwd<'a>(&'a mut self, dir: String) -> &'a mut Command {\n-        self.cwd = Some(dir);\n-        self\n-    }\n-\n-    /// Executes the command as a child process, which is returned.\n-    pub fn spawn(&self) -> std::io::Result<Process> {\n-        ...\n-    }\n-}\n-```\n-\n-Note that the `spawn` method, which actually uses the builder configuration to\n-spawn a process, takes the builder by immutable reference. This is possible\n-because spawning the process does not require ownership of the configuration\n-data.\n-\n-Because the terminal `spawn` method only needs a reference, the configuration\n-methods take and return a mutable borrow of `self`.\n-\n-#### The benefit\n-\n-By using borrows throughout, `Command` can be used conveniently for both\n-one-liner and more complex constructions:\n-\n-```rust,ignore\n-// One-liners\n-Command::new(\"/bin/cat\").arg(\"file.txt\").spawn();\n-\n-// Complex configuration\n-let mut cmd = Command::new(\"/bin/ls\");\n-cmd.arg(\".\");\n-\n-if size_sorted {\n-    cmd.arg(\"-S\");\n-}\n-\n-cmd.spawn();\n-```\n-\n-### Consuming builders:\n-\n-Sometimes builders must transfer ownership when constructing the final type\n-`T`, meaning that the terminal methods must take `self` rather than `&self`:\n-\n-```rust,ignore\n-// A simplified excerpt from std::thread::Builder\n-\n-impl ThreadBuilder {\n-    /// Name the thread-to-be. Currently the name is used for identification\n-    /// only in failure messages.\n-    pub fn named(mut self, name: String) -> ThreadBuilder {\n-        self.name = Some(name);\n-        self\n-    }\n-\n-    /// Redirect thread-local stdout.\n-    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> ThreadBuilder {\n-        self.stdout = Some(stdout);\n-        //   ^~~~~~ this is owned and cannot be cloned/re-used\n-        self\n-    }\n-\n-    /// Creates and executes a new child thread.\n-    pub fn spawn(self, f: proc():Send) {\n-        // consume self\n-        ...\n-    }\n-}\n-```\n-\n-Here, the `stdout` configuration involves passing ownership of a `Writer`,\n-which must be transferred to the thread upon construction (in `spawn`).\n-\n-When the terminal methods of the builder require ownership, there is a basic tradeoff:\n-\n-* If the other builder methods take/return a mutable borrow, the complex\n-  configuration case will work well, but one-liner configuration becomes\n-  _impossible_.\n-\n-* If the other builder methods take/return an owned `self`, one-liners\n-  continue to work well but complex configuration is less convenient.\n-\n-Under the rubric of making easy things easy and hard things possible, _all_\n-builder methods for a consuming builder should take and returned an owned\n-`self`. Then client code works as follows:\n-\n-```rust,ignore\n-// One-liners\n-ThreadBuilder::new().named(\"my_thread\").spawn(proc() { ... });\n-\n-// Complex configuration\n-let mut thread = ThreadBuilder::new();\n-thread = thread.named(\"my_thread_2\"); // must re-assign to retain ownership\n-\n-if reroute {\n-    thread = thread.stdout(mywriter);\n-}\n-\n-thread.spawn(proc() { ... });\n-```\n-\n-One-liners work as before, because ownership is threaded through each of the\n-builder methods until being consumed by `spawn`. Complex configuration,\n-however, is more verbose: it requires re-assigning the builder at each step."}, {"sha": "cd027cc4aaffc96728ae64289533043b8f8471ed", "filename": "src/doc/style/ownership/cell-smart.md", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fownership%2Fcell-smart.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fownership%2Fcell-smart.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fcell-smart.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,4 +0,0 @@\n-% Cells and smart pointers\n-\n-> **[FIXME]** Add guidelines about when to use Cell, RefCell, Rc and\n-> Arc (and how to use them together)."}, {"sha": "51fc74ac1158aa47f0db1147133b8066285abbb9", "filename": "src/doc/style/ownership/constructors.md", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fownership%2Fconstructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fownership%2Fconstructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fconstructors.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,62 +0,0 @@\n-% Constructors\n-\n-### Define constructors as static, inherent methods. [FIXME: needs RFC]\n-\n-In Rust, \"constructors\" are just a convention:\n-\n-```rust,ignore\n-impl<T> Vec<T> {\n-    pub fn new() -> Vec<T> { ... }\n-}\n-```\n-\n-Constructors are static (no `self`) inherent methods for the type that they\n-construct. Combined with the practice of\n-[fully importing type names](../style/imports.md), this convention leads to\n-informative but concise construction:\n-\n-```rust,ignore\n-use vec::Vec;\n-\n-// construct a new vector\n-let mut v = Vec::new();\n-```\n-\n-This convention also applied to conversion constructors (prefix `from` rather\n-than `new`).\n-\n-### Provide constructors for passive `struct`s with defaults. [FIXME: needs RFC]\n-\n-Given the `struct`\n-\n-```rust,ignore\n-pub struct Config {\n-    pub color: Color,\n-    pub size:  Size,\n-    pub shape: Shape,\n-}\n-```\n-\n-provide a constructor if there are sensible defaults:\n-\n-```rust,ignore\n-impl Config {\n-    pub fn new() -> Config {\n-        Config {\n-            color: Brown,\n-            size: Medium,\n-            shape: Square,\n-        }\n-    }\n-}\n-```\n-\n-which then allows clients to concisely override using `struct` update syntax:\n-\n-```rust,ignore\n-Config { color: Red, .. Config::new() };\n-```\n-\n-See the [guideline for field privacy](../features/types/README.md) for\n-discussion on when to create such \"passive\" `struct`s with public\n-fields."}, {"sha": "1cfcd78d20da8346f052351ae285714e6fcf0e9f", "filename": "src/doc/style/ownership/destructors.md", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,22 +0,0 @@\n-% Destructors\n-\n-Unlike constructors, destructors in Rust have a special status: they are added\n-by implementing `Drop` for a type, and they are automatically invoked as values\n-go out of scope.\n-\n-> **[FIXME]** This section needs to be expanded.\n-\n-### Destructors should not fail. [FIXME: needs RFC]\n-\n-Destructors are executed on thread failure, and in that context a failing\n-destructor causes the program to abort.\n-\n-Instead of failing in a destructor, provide a separate method for checking for\n-clean teardown, e.g. a `close` method, that returns a `Result` to signal\n-problems.\n-\n-### Destructors should not block. [FIXME: needs RFC]\n-\n-Similarly, destructors should not invoke blocking operations, which can make\n-debugging much more difficult. Again, consider providing a separate method for\n-preparing for an infallible, nonblocking teardown."}, {"sha": "244e8096a1a2f26a230512c1f1d91ab4abfd5547", "filename": "src/doc/style/ownership/raii.md", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fownership%2Fraii.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fownership%2Fraii.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fraii.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,12 +0,0 @@\n-% RAII\n-\n-Resource Acquisition is Initialization\n-\n-> **[FIXME]** Explain the RAII pattern and give best practices.\n-\n-### Whenever possible, tie resource access to guard scopes [FIXME]\n-\n-> **[FIXME]** Example: Mutex guards guarantee that access to the\n-> protected resource only happens when the guard is in scope.\n-\n-`must_use`"}, {"sha": "d29d060b6946195deb8238a438d77f05a8c65412", "filename": "src/doc/style/platform.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fplatform.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fplatform.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fplatform.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,7 +0,0 @@\n-% FFI and platform-specific code **[FIXME]**\n-\n-> **[FIXME]** Not sure where this should live.\n-\n-When writing cross-platform code, group platform-specific code into a\n-module called `platform`. Avoid `#[cfg]` directives outside this\n-`platform` module."}, {"sha": "1ac6e704d23ebcca784d34df02987c859f8c2144", "filename": "src/doc/style/safety/README.md", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fsafety%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fsafety%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fsafety%2FREADME.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,19 +0,0 @@\n-% Safety and guarantees\n-\n-> **[FIXME]** Is there a better phrase than \"strong guarantees\" that encompasses\n-> both e.g. memory safety and e.g. data structure invariants?\n-\n-A _guarantee_ is a property that holds no matter what client code does, unless\n-the client explicitly opts out:\n-\n-* Rust guarantees memory safety and data-race freedom, with `unsafe`\n-  blocks as an opt-out mechanism.\n-\n-* APIs in Rust often provide their own guarantees. For example, `std::str`\n-guarantees that its underlying buffer is valid utf-8. The `std::path::Path` type\n-guarantees no interior nulls. Both strings and paths provide `unsafe` mechanisms\n-for opting out of these guarantees (and thereby avoiding runtime checks).\n-\n-Thinking about guarantees is an essential part of writing good Rust code.  The\n-rest of this subsection outlines some cross-cutting principles around\n-guarantees."}, {"sha": "8ee64f1806a6937ae08c554f99eced0037ddabbd", "filename": "src/doc/style/safety/lib-guarantees.md", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fsafety%2Flib-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fsafety%2Flib-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fsafety%2Flib-guarantees.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,81 +0,0 @@\n-% Library-level guarantees\n-\n-Most libraries rely on internal invariants, e.g. about their data, resource\n-ownership, or protocol states. In Rust, broken invariants cannot produce\n-segfaults, but they can still lead to wrong answers.\n-\n-### Provide library-level guarantees whenever practical. **[FIXME: needs RFC]**\n-\n-Library-level invariants should be turned into guarantees whenever\n-practical. They should hold no matter what the client does, modulo\n-explicit opt-outs. Depending on the kind of invariant, this can be\n-achieved through a combination of static and dynamic enforcement, as\n-described below.\n-\n-#### Static enforcement:\n-\n-Guaranteeing invariants almost always requires _hiding_,\n-i.e. preventing the client from directly accessing or modifying\n-internal data.\n-\n-For example, the representation of the `str` type is hidden,\n-which means that any value of type `str` must have been produced\n-through an API under the control of the `str` module, and these\n-APIs in turn ensure valid utf-8 encoding.\n-\n-Rust's type system makes it possible to provide guarantees even while\n-revealing more of the representation than usual. For example, the\n-`as_bytes()` method on `&str` gives a _read-only_ view into the\n-underlying buffer, which cannot be used to violate the utf-8 property.\n-\n-#### Dynamic enforcement:\n-\n-Malformed inputs from the client are hazards to library-level\n-guarantees, so library APIs should validate their input.\n-\n-For example, `std::str::from_utf8_owned` attempts to convert a `u8`\n-slice into an owned string, but dynamically checks that the slice is\n-valid utf-8 and returns `Err` if not.\n-\n-See\n-[the discussion on input validation](../features/functions-and-methods/input.md)\n-for more detail.\n-\n-\n-### Prefer static enforcement of guarantees. **[FIXME: needs RFC]**\n-\n-Static enforcement provides two strong benefits over dynamic enforcement:\n-\n-* Bugs are caught at compile time.\n-* There is no runtime cost.\n-\n-Sometimes purely static enforcement is impossible or impractical. In these\n-cases, a library should check as much as possible statically, but defer to\n-dynamic checks where needed.\n-\n-For example, the `std::string` module exports a `String` type with the guarantee\n-that all instances are valid utf-8:\n-\n-* Any _consumer_ of a `String` is statically guaranteed utf-8 contents. For example,\n-  the `append` method can push a `&str` onto the end of a `String` without\n-  checking anything dynamically, since the existing `String` and `&str` are\n-  statically guaranteed to be in utf-8.\n-\n-* Some _producers_ of a `String` must perform dynamic checks. For example, the\n-  `from_utf8` function attempts to convert a `Vec<u8>` into a `String`, but\n-  dynamically checks that the contents are utf-8.\n-\n-### Provide opt-outs with caution; make them explicit. **[FIXME: needs RFC]**\n-\n-Providing library-level guarantees sometimes entails inconvenience (for static\n-checks) or overhead (for dynamic checks). So it is sometimes desirable to allow\n-clients to sidestep this checking, while promising to use the API in a way that\n-still provides the guarantee. Such escape hatches should only be introduced when\n-there is a demonstrated need for them.\n-\n-It should be trivial for clients to audit their use of the library for\n-escape hatches.\n-\n-See\n-[the discussion on input validation](../features/functions-and-methods/input.md)\n-for conventions on marking opt-out functions."}, {"sha": "a8a50af044c2916e1fc6e9de79bd75bf3f05266b", "filename": "src/doc/style/safety/unsafe.md", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fsafety%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fsafety%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fsafety%2Funsafe.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,22 +0,0 @@\n-% Using `unsafe`\n-\n-### Unconditionally guarantee safety, or mark API as `unsafe`. **[FIXME: needs RFC]**\n-\n-Memory safety, type safety, and data race freedom are basic assumptions for all\n-Rust code.\n-\n-APIs that use `unsafe` blocks internally thus have two choices:\n-\n-* They can guarantee safety _unconditionally_ (i.e., regardless of client\n-  behavior or inputs) and be exported as safe code. Any safety violation is then\n-  the library's fault, not the client's fault.\n-\n-* They can export potentially unsafe functions with the `unsafe` qualifier. In\n-  this case, the documentation should make very clear the conditions under which\n-  safety is guaranteed.\n-\n-The result is that a client program can never violate safety merely by having a\n-bug; it must have explicitly opted out by using an `unsafe` block.\n-\n-Of the two options for using `unsafe`, creating such safe abstractions (the\n-first option above) is strongly preferred."}, {"sha": "87449710543c01f0ec0f7e57bf47448abef704e1", "filename": "src/doc/style/style/README.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2FREADME.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,5 +0,0 @@\n-% Style\n-\n-This section gives a set of strict rules for styling Rust code.\n-\n-> **[FIXME]** General remarks about the style guidelines"}, {"sha": "80323dba1d4c247e088cca5ed115205fe54f8231", "filename": "src/doc/style/style/braces.md", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fbraces.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fbraces.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fbraces.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,77 +0,0 @@\n-% Braces, semicolons, and commas [FIXME: needs RFC]\n-\n-### Opening braces always go on the same line.\n-\n-```rust,ignore\n-fn foo() {\n-    ...\n-}\n-\n-fn frobnicate(a: Bar, b: Bar,\n-              c: Bar, d: Bar)\n-              -> Bar {\n-    ...\n-}\n-\n-trait Bar {\n-    fn baz(&self);\n-}\n-\n-impl Bar for Baz {\n-    fn baz(&self) {\n-        ...\n-    }\n-}\n-\n-frob(|x| {\n-    x.transpose()\n-})\n-```\n-\n-### `match` arms get braces, except for single-line expressions.\n-\n-```rust,ignore\n-match foo {\n-    bar => baz,\n-    quux => {\n-        do_something();\n-        do_something_else()\n-    }\n-}\n-```\n-\n-### `return` statements get semicolons.\n-\n-```rust,ignore\n-fn foo() {\n-    do_something();\n-\n-    if condition() {\n-        return;\n-    }\n-\n-    do_something_else();\n-}\n-```\n-\n-### Trailing commas\n-\n-> **[FIXME]** We should have a guideline for when to include trailing\n-> commas in `struct`s, `match`es, function calls, etc.\n->\n-> One possible rule: a trailing comma should be included whenever the\n-> closing delimiter appears on a separate line:\n-\n-```rust,ignore\n-Foo { bar: 0, baz: 1 }\n-\n-Foo {\n-    bar: 0,\n-    baz: 1,\n-}\n-\n-match a_thing {\n-    None => 0,\n-    Some(x) => 1,\n-}\n-```"}, {"sha": "af02d87cc8da89d43dc3ef7ea557a75fa0869fc9", "filename": "src/doc/style/style/comments.md", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,122 +0,0 @@\n-% Comments [RFC #505]\n-\n-### Avoid block comments.\n-\n-Use line comments:\n-\n-```rust\n-// Wait for the main thread to return, and set the process error code\n-// appropriately.\n-```\n-\n-Instead of:\n-\n-``` rust\n-/*\n- * Wait for the main thread to return, and set the process error code\n- * appropriately.\n- */\n-```\n-\n-## Doc comments\n-\n-Doc comments are prefixed by three slashes (`///`) and indicate\n-documentation that you would like to be included in Rustdoc's output.\n-They support\n-[Markdown syntax](https://en.wikipedia.org/wiki/Markdown)\n-and are the main way of documenting your public APIs.\n-\n-The supported markdown syntax includes all of the extensions listed in the\n-[GitHub Flavored Markdown]\n-(https://help.github.com/articles/github-flavored-markdown) documentation,\n-plus superscripts.\n-\n-### Summary line\n-\n-The first line in any doc comment should be a single-line short sentence\n-providing a summary of the code. This line is used as a short summary\n-description throughout Rustdoc's output, so it's a good idea to keep it\n-short.\n-\n-### Sentence structure\n-\n-All doc comments, including the summary line, should begin with a\n-capital letter and end with a period, question mark, or exclamation\n-point. Prefer full sentences to fragments.\n-\n-The summary line should be written in\n-[third person singular present indicative form]\n-(http://en.wikipedia.org/wiki/English_verbs#Third_person_singular_present).\n-Basically, this means write \"Returns\" instead of \"Return\".\n-\n-For example:\n-\n-```rust,ignore\n-/// Sets up a default runtime configuration, given compiler-supplied arguments.\n-///\n-/// This function will block until the entire pool of M:N schedulers has\n-/// exited. This function also requires a local thread to be available.\n-///\n-/// # Arguments\n-///\n-/// * `argc` & `argv` - The argument vector. On Unix this information is used\n-///                     by `os::args`.\n-/// * `main` - The initial procedure to run inside of the M:N scheduling pool.\n-///            Once this procedure exits, the scheduling pool will begin to shut\n-///            down. The entire pool (and this function) will only return once\n-///            all child threads have finished executing.\n-///\n-/// # Return value\n-///\n-/// The return value is used as the process return code. 0 on success, 101 on\n-/// error.\n-```\n-\n-### Code snippets\n-\n-Only use inner doc comments `//!` to write crate and module-level documentation,\n-nothing else. When using `mod` blocks, prefer `///` outside of the block:\n-\n-```rust\n-/// This module contains tests\n-mod test {\n-    // ...\n-}\n-```\n-\n-over\n-\n-```rust\n-mod test {\n-    //! This module contains tests\n-\n-    // ...\n-}\n-```\n-\n-### Avoid inner doc comments.\n-\n-Use inner doc comments _only_ to document crates and file-level modules:\n-\n-```rust,ignore\n-//! The core library.\n-//!\n-//! The core library is a something something...\n-```\n-\n-### Explain context.\n-\n-Rust doesn't have special constructors, only functions that return new\n-instances.  These aren't visible in the automatically generated documentation\n-for a type, so you should specifically link to them:\n-\n-```rust,ignore\n-/// An iterator that yields `None` forever after the underlying iterator\n-/// yields `None` once.\n-///\n-/// These can be created through\n-/// [`iter.fuse()`](trait.Iterator.html#method.fuse).\n-pub struct Fuse<I> {\n-    // ...\n-}\n-```"}, {"sha": "13cc37fc236ca4a6508227e17f111ce7e118ee37", "filename": "src/doc/style/style/features.md", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Ffeatures.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,13 +0,0 @@\n-## `return` [RFC #968]\n-\n-Terminate `return` statements with semicolons:\n-\n-``` rust,ignore\n-fn foo(bar: i32) -> Option<i32> {\n-    if some_condition() {\n-        return None;\n-    }\n-\n-    ...\n-}\n-```"}, {"sha": "c958875ddb92616fb0450d6daa67691e6ebfdec6", "filename": "src/doc/style/style/imports.md", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fimports.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fimports.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fimports.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,50 +0,0 @@\n-% Imports [FIXME: needs RFC]\n-\n-The imports of a crate/module should consist of the following\n-sections, in order, with a blank space between each:\n-\n-* `extern crate` directives\n-* external `use` imports\n-* local `use` imports\n-* `pub use` imports\n-\n-For example:\n-\n-```rust,ignore\n-// Crates.\n-extern crate getopts;\n-extern crate mylib;\n-\n-// Standard library imports.\n-use getopts::{optopt, getopts};\n-use std::os;\n-\n-// Import from a library that we wrote.\n-use mylib::webserver;\n-\n-// Will be reexported when we import this module.\n-pub use self::types::Webdata;\n-```\n-\n-### Avoid `use *`, except in tests.\n-\n-Glob imports have several downsides:\n-* They make it harder to tell where names are bound.\n-* They are forwards-incompatible, since new upstream exports can clash\n-  with existing names.\n-\n-When writing a [`test` submodule](../testing/README.md), importing `super::*` is appropriate\n-as a convenience.\n-\n-### Prefer fully importing types/traits while module-qualifying functions.\n-\n-For example:\n-\n-```rust,ignore\n-use option::Option;\n-use mem;\n-\n-let i: isize = mem::transmute(Option(0));\n-```\n-\n-> **[FIXME]** Add rationale."}, {"sha": "6d88a838f5f5322d0b21e18c23e5952e6c695c05", "filename": "src/doc/style/style/naming/README.md", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2FREADME.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,115 +0,0 @@\n-% Naming conventions\n-\n-### General conventions [RFC #430]\n-\n-> The guidelines below were approved by [RFC #430](https://github.com/rust-lang/rfcs/pull/430).\n-\n-In general, Rust tends to use `CamelCase` for \"type-level\" constructs\n-(types and traits) and `snake_case` for \"value-level\" constructs. More\n-precisely:\n-\n-| Item | Convention |\n-| ---- | ---------- |\n-| Crates | `snake_case` (but prefer single word) |\n-| Modules | `snake_case` |\n-| Types | `CamelCase` |\n-| Traits | `CamelCase` |\n-| Enum variants | `CamelCase` |\n-| Functions | `snake_case` |\n-| Methods | `snake_case` |\n-| General constructors | `new` or `with_more_details` |\n-| Conversion constructors | `from_some_other_type` |\n-| Local variables | `snake_case` |\n-| Static variables | `SCREAMING_SNAKE_CASE` |\n-| Constant variables | `SCREAMING_SNAKE_CASE` |\n-| Type parameters | concise `CamelCase`, usually single uppercase letter: `T` |\n-| Lifetimes | short, lowercase: `'a` |\n-\n-<p>\n-In `CamelCase`, acronyms count as one word: use `Uuid` rather than\n-`UUID`.  In `snake_case`, acronyms are lower-cased: `is_xid_start`.\n-\n-In `snake_case` or `SCREAMING_SNAKE_CASE`, a \"word\" should never\n-consist of a single letter unless it is the last \"word\". So, we have\n-`btree_map` rather than `b_tree_map`, but `PI_2` rather than `PI2`.\n-\n-### Referring to types in function/method names [RFC 344]\n-\n-> The guidelines below were approved by [RFC #344](https://github.com/rust-lang/rfcs/pull/344).\n-\n-Function names often involve type names, the most common example being conversions\n-like `as_slice`. If the type has a purely textual name (ignoring parameters), it\n-is straightforward to convert between type conventions and function conventions:\n-\n-Type name | Text in methods\n---------- | ---------------\n-`String`  | `string`\n-`Vec<T>`  | `vec`\n-`YourType`| `your_type`\n-\n-Types that involve notation follow the convention below. There is some\n-overlap on these rules; apply the most specific applicable rule:\n-\n-Type name | Text in methods\n---------- | ---------------\n-`&str`    | `str`\n-`&[T]`    | `slice`\n-`&mut [T]`| `mut_slice`\n-`&[u8]`   | `bytes`\n-`&T`      | `ref`\n-`&mut T`  | `mut`\n-`*const T`| `ptr`\n-`*mut T`  | `mut_ptr`\n-\n-### Avoid redundant prefixes [RFC 356]\n-\n-> The guidelines below were approved by [RFC #356](https://github.com/rust-lang/rfcs/pull/356).\n-\n-Names of items within a module should not be prefixed with that module's name:\n-\n-Prefer\n-\n-```rust,ignore\n-mod foo {\n-    pub struct Error { ... }\n-}\n-```\n-\n-over\n-\n-```rust,ignore\n-mod foo {\n-    pub struct FooError { ... }\n-}\n-```\n-\n-This convention avoids stuttering (like `io::IoError`). Library clients can\n-rename on import to avoid clashes.\n-\n-### Getter/setter methods [RFC 344]\n-\n-> The guidelines below were approved by [RFC #344](https://github.com/rust-lang/rfcs/pull/344).\n-\n-Some data structures do not wish to provide direct access to their fields, but\n-instead offer \"getter\" and \"setter\" methods for manipulating the field state\n-(often providing checking or other functionality).\n-\n-The convention for a field `foo: T` is:\n-\n-* A method `foo(&self) -> &T` for getting the current value of the field.\n-* A method `set_foo(&self, val: T)` for setting the field. (The `val` argument\n-  here may take `&T` or some other type, depending on the context.)\n-\n-Note that this convention is about getters/setters on ordinary data types, *not*\n-on [builder objects](../../ownership/builders.html).\n-\n-### Escape hatches [FIXME]\n-\n-> **[FIXME]** Should we standardize a convention for functions that may break API\n-> guarantees? e.g. `ToCStr::to_c_str_unchecked`\n-\n-### Predicates\n-\n-* Simple boolean predicates should be prefixed with `is_` or another\n-  short question word, e.g., `is_empty`.\n-* Common exceptions: `lt`, `gt`, and other established predicate names."}, {"sha": "c352a5b1bf1912df19f8db867f828886183586ba", "filename": "src/doc/style/style/naming/containers.md", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,69 +0,0 @@\n-% Common container/wrapper methods [FIXME: needs RFC]\n-\n-Containers, wrappers, and cells all provide ways to access the data\n-they enclose.  Accessor methods often have variants to access the data\n-by value, by reference, and by mutable reference.\n-\n-In general, the `get` family of methods is used to access contained\n-data without any risk of thread failure; they return `Option` as\n-appropriate. This name is chosen rather than names like `find` or\n-`lookup` because it is appropriate for a wider range of container types.\n-\n-#### Containers\n-\n-For a container with keys/indexes of type `K` and elements of type `V`:\n-\n-```rust,ignore\n-// Look up element without failing\n-fn get(&self, key: K) -> Option<&V>\n-fn get_mut(&mut self, key: K) -> Option<&mut V>\n-\n-// Convenience for .get(key).map(|elt| elt.clone())\n-fn get_clone(&self, key: K) -> Option<V>\n-\n-// Lookup element, failing if it is not found:\n-impl Index<K, V> for Container { ... }\n-impl IndexMut<K, V> for Container { ... }\n-```\n-\n-#### Wrappers/Cells\n-\n-Prefer specific conversion functions like `as_bytes` or `into_vec` whenever\n-possible. Otherwise, use:\n-\n-```rust,ignore\n-// Extract contents without failing\n-fn get(&self) -> &V\n-fn get_mut(&mut self) -> &mut V\n-fn unwrap(self) -> V\n-```\n-\n-#### Wrappers/Cells around `Copy` data\n-\n-```rust,ignore\n-// Extract contents without failing\n-fn get(&self) -> V\n-```\n-\n-#### `Option`-like types\n-\n-Finally, we have the cases of types like `Option` and `Result`, which\n-play a special role for failure.\n-\n-For `Option<V>`:\n-\n-```rust,ignore\n-// Extract contents or fail if not available\n-fn assert(self) -> V\n-fn expect(self, &str) -> V\n-```\n-\n-For `Result<V, E>`:\n-\n-```rust,ignore\n-// Extract the contents of Ok variant; fail if Err\n-fn assert(self) -> V\n-\n-// Extract the contents of Err variant; fail if Ok\n-fn assert_err(self) -> E\n-```"}, {"sha": "0287919c78aae22b7dfc069b04d895d892b8807a", "filename": "src/doc/style/style/naming/conversions.md", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fconversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fconversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fconversions.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,32 +0,0 @@\n-% Conversions [Rust issue #7087]\n-\n-> The guidelines below were approved by [rust issue #7087](https://github.com/rust-lang/rust/issues/7087).\n-\n-> **[FIXME]** Should we provide standard traits for conversions? Doing\n-> so nicely will require\n-> [trait reform](https://github.com/rust-lang/rfcs/pull/48) to land.\n-\n-Conversions should be provided as methods, with names prefixed as follows:\n-\n-| Prefix | Cost | Consumes convertee |\n-| ------ | ---- | ------------------ |\n-| `as_` | Free | No |\n-| `to_` | Expensive | No |\n-| `into_` | Variable | Yes |\n-\n-<p>\n-For example:\n-\n-* `as_bytes()` gives a `&[u8]` view into a `&str`, which is a no-op.\n-* `to_owned()` copies a `&str` to a new `String`.\n-* `into_bytes()` consumes a `String` and yields the underlying\n-  `Vec<u8>`, which is a no-op.\n-\n-Conversions prefixed `as_` and `into_` typically _decrease abstraction_, either\n-exposing a view into the underlying representation (`as`) or deconstructing data\n-into its underlying representation (`into`). Conversions prefixed `to_`, on the\n-other hand, typically stay at the same level of abstraction but do some work to\n-change one representation into another.\n-\n-> **[FIXME]** The distinctions between conversion methods does not work\n-> so well for `from_` conversion constructors. Is that a problem?"}, {"sha": "945cbe4800cb089a2b420536ce6b05a95d29a1ec", "filename": "src/doc/style/style/naming/iterators.md", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fiterators.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,32 +0,0 @@\n-% Iterators\n-\n-#### Method names [RFC #199]\n-\n-> The guidelines below were approved by [RFC #199](https://github.com/rust-lang/rfcs/pull/199).\n-\n-For a container with elements of type `U`, iterator methods should be named:\n-\n-```rust,ignore\n-fn iter(&self) -> T           // where T implements Iterator<&U>\n-fn iter_mut(&mut self) -> T   // where T implements Iterator<&mut U>\n-fn into_iter(self) -> T       // where T implements Iterator<U>\n-```\n-\n-The default iterator variant yields shared references `&U`.\n-\n-#### Type names [RFC #344]\n-\n-> The guidelines below were approved by [RFC #344](https://github.com/rust-lang/rfcs/pull/344).\n-\n-The name of an iterator type should be the same as the method that\n-produces the iterator.\n-\n-For example:\n-\n-* `iter` should yield an `Iter`\n-* `iter_mut` should yield an `IterMut`\n-* `into_iter` should yield an `IntoIter`\n-* `keys` should yield `Keys`\n-\n-These type names make the most sense when prefixed with their owning module,\n-e.g. `vec::IntoIter`."}, {"sha": "32cd8a1595afb0a245ae6062c7218fe65fe29940", "filename": "src/doc/style/style/naming/ownership.md", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fownership.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,34 +0,0 @@\n-% Ownership variants [RFC #199]\n-\n-> The guidelines below were approved by [RFC #199](https://github.com/rust-lang/rfcs/pull/199).\n-\n-Functions often come in multiple variants: immutably borrowed, mutably\n-borrowed, and owned.\n-\n-The right default depends on the function in question. Variants should\n-be marked through suffixes.\n-\n-#### Immutably borrowed by default\n-\n-If `foo` uses/produces an immutable borrow by default, use:\n-\n-* The `_mut` suffix (e.g. `foo_mut`) for the mutably borrowed variant.\n-* The `_move` suffix (e.g. `foo_move`) for the owned variant.\n-\n-#### Owned by default\n-\n-If `foo` uses/produces owned data by default, use:\n-\n-* The `_ref` suffix (e.g. `foo_ref`) for the immutably borrowed variant.\n-* The `_mut` suffix (e.g. `foo_mut`) for the mutably borrowed variant.\n-\n-#### Exceptions\n-\n-In the case of iterators, the moving variant can also be understood as\n-an `into` conversion, `into_iter`, and `for x in v.into_iter()` reads\n-arguably better than `for x in v.iter_move()`, so the convention is\n-`into_iter`.\n-\n-For mutably borrowed variants, if the `mut` qualifier is part of a\n-type name (e.g. `as_mut_slice`), it should appear as it would appear\n-in the type."}, {"sha": "d3c2178cc993fc6f66a41f25a18bae6883f67883", "filename": "src/doc/style/style/optional.md", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Foptional.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Foptional.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Foptional.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,3 +0,0 @@\n-*\n-\n-*"}, {"sha": "85065406d761c7ec76deffe71400f2c2c2d2a448", "filename": "src/doc/style/style/organization.md", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Forganization.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Forganization.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Forganization.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,14 +0,0 @@\n-% Organization [FIXME: needs RFC]\n-\n-> **[FIXME]** What else?\n-\n-### Reexport the most important types at the crate level.\n-\n-Crates `pub use` the most common types for convenience, so that clients do not\n-have to remember or write the crate's module hierarchy to use these types.\n-\n-### Define types and operations together.\n-\n-Type definitions and the functions/methods that operate on them should be\n-defined together in a single module, with the type appearing above the\n-functions/methods."}, {"sha": "c33c17c8e42a28be24ae1fa24e65336aefb14d56", "filename": "src/doc/style/style/whitespace.md", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fwhitespace.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Fstyle%2Fwhitespace.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fwhitespace.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,133 +0,0 @@\n-% Whitespace [FIXME: needs RFC]\n-\n-* Lines must not exceed 99 characters.\n-* Use 4 spaces for indentation, _not_ tabs.\n-* No trailing whitespace at the end of lines or files.\n-\n-### Spaces\n-\n-* Use spaces around binary operators, including the equals sign in attributes:\n-\n-```rust,ignore\n-#[deprecated = \"Use `bar` instead.\"]\n-fn foo(a: usize, b: usize) -> usize {\n-    a + b\n-}\n-```\n-\n-* Use a space after colons and commas:\n-\n-```rust,ignore\n-fn foo(a: Bar);\n-\n-MyStruct { foo: 3, bar: 4 }\n-\n-foo(bar, baz);\n-```\n-\n-* Use a space after the opening and before the closing brace for\n-  single line blocks or `struct` expressions:\n-\n-```rust,ignore\n-spawn(proc() { do_something(); })\n-\n-Point { x: 0.1, y: 0.3 }\n-```\n-\n-### Line wrapping\n-\n-* For multiline function signatures, each new line should align with the\n-  first parameter. Multiple parameters per line are permitted:\n-\n-```rust,ignore\n-fn frobnicate(a: Bar, b: Bar,\n-              c: Bar, d: Bar)\n-              -> Bar {\n-    ...\n-}\n-\n-fn foo<T: This,\n-       U: That>(\n-       a: Bar,\n-       b: Bar)\n-       -> Baz {\n-    ...\n-}\n-```\n-\n-* Multiline function invocations generally follow the same rule as for\n-  signatures. However, if the final argument begins a new block, the\n-  contents of the block may begin on a new line, indented one level:\n-\n-```rust,ignore\n-fn foo_bar(a: Bar, b: Bar,\n-           c: |Bar|) -> Bar {\n-    ...\n-}\n-\n-// Same line is fine:\n-foo_bar(x, y, |z| { z.transpose(y) });\n-\n-// Indented body on new line is also fine:\n-foo_bar(x, y, |z| {\n-    z.quux();\n-    z.rotate(x)\n-})\n-```\n-\n-> **[FIXME]** Do we also want to allow the following?\n->\n-> ```rust,ignore\n-> frobnicate(\n->     arg1,\n->     arg2,\n->     arg3)\n-> ```\n->\n-> This style could ease the conflict between line length and functions\n-> with many parameters (or long method chains).\n-\n-### Matches\n-\n-> * **[Deprecated]** If you have multiple patterns in a single `match`\n->   arm, write each pattern on a separate line:\n->\n->     ```rust,ignore\n->     match foo {\n->         bar(_)\n->         | baz => quux,\n->         x\n->         | y\n->         | z => {\n->             quuux\n->         }\n->     }\n->     ```\n-\n-### Alignment\n-\n-Idiomatic code should not use extra whitespace in the middle of a line\n-to provide alignment.\n-\n-\n-```rust,ignore\n-// Good\n-struct Foo {\n-    short: f64,\n-    really_long: f64,\n-}\n-\n-// Bad\n-struct Bar {\n-    short:       f64,\n-    really_long: f64,\n-}\n-\n-// Good\n-let a = 0;\n-let radius = 7;\n-\n-// Bad\n-let b        = 0;\n-let diameter = 7;\n-```"}, {"sha": "a21f69414d326b15cb1a617ebba77a1b23807dc4", "filename": "src/doc/style/testing/README.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ftesting%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ftesting%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ftesting%2FREADME.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,5 +0,0 @@\n-% Testing\n-\n-> **[FIXME]** Add some general remarks about when and how to unit\n-> test, versus other kinds of testing. What are our expectations for\n-> Rust's core libraries?"}, {"sha": "dbbe9fc3ac6da92602304f64de31b07afa01e80a", "filename": "src/doc/style/testing/unit.md", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ftesting%2Funit.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ftesting%2Funit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ftesting%2Funit.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,30 +0,0 @@\n-% Unit testing\n-\n-Unit tests should live in a `tests` submodule at the bottom of the module they\n-test. Mark the `tests` submodule with `#[cfg(test)]` so it is only compiled when\n-testing.\n-\n-The `tests` module should contain:\n-\n-* Imports needed only for testing.\n-* Functions marked with `#[test]` striving for full coverage of the parent module's\n-  definitions.\n-* Auxiliary functions needed for writing the tests.\n-\n-For example:\n-\n-``` rust\n-// Excerpt from std::str\n-\n-#[cfg(test)]\n-mod tests {\n-    #[test]\n-    fn test_eq() {\n-        assert!((eq(&\"\".to_owned(), &\"\".to_owned())));\n-        assert!((eq(&\"foo\".to_owned(), &\"foo\".to_owned())));\n-        assert!((!eq(&\"foo\".to_owned(), &\"bar\".to_owned())));\n-    }\n-}\n-```\n-\n-> **[FIXME]** add details about useful macros for testing, e.g. `assert!`"}, {"sha": "28ef2a1832d8bf175682a7709ba6409ae1ec0ea7", "filename": "src/doc/style/todo.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ftodo.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b74503aa4f2fb4035d9adef9391e9b9658c57ad/src%2Fdoc%2Fstyle%2Ftodo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ftodo.md?ref=6b74503aa4f2fb4035d9adef9391e9b9658c57ad", "patch": "@@ -1,5 +0,0 @@\n-* [Containers and iteration]()\n-* [The visitor pattern]()\n-* [Concurrency]()\n-* [Documentation]()\n-* [Macros]()"}, {"sha": "c8a78f84f185768fde245c014c5d9bf29559833a", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -67,7 +67,6 @@ use core::mem;\n use core::ops::{CoerceUnsized, Deref, DerefMut};\n use core::ops::{BoxPlace, Boxed, InPlace, Place, Placer};\n use core::ptr::{self, Unique};\n-use core::raw::TraitObject;\n use core::convert::From;\n \n /// A value that represents the heap. This is the default place that the `box`\n@@ -428,12 +427,8 @@ impl Box<Any> {\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n         if self.is::<T>() {\n             unsafe {\n-                // Get the raw representation of the trait object\n-                let raw = Box::into_raw(self);\n-                let to: TraitObject = mem::transmute::<*mut Any, TraitObject>(raw);\n-\n-                // Extract the data pointer\n-                Ok(Box::from_raw(to.data as *mut T))\n+                let raw: *mut Any = Box::into_raw(self);\n+                Ok(Box::from_raw(raw as *mut T))\n             }\n         } else {\n             Err(self)"}, {"sha": "c6453da3f4697d5f660634cf59a088a4197059ea", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -91,7 +91,7 @@\n #![cfg_attr(stage0, feature(unsafe_no_drop_flag))]\n #![feature(unsize)]\n \n-#![cfg_attr(not(test), feature(fused, raw, fn_traits, placement_new_protocol))]\n+#![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol))]\n #![cfg_attr(test, feature(test, box_heap))]\n \n // Allow testing this library"}, {"sha": "a3018a46eea22063545331e6937609597a98654d", "filename": "src/libcore/any.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -72,8 +72,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use fmt;\n-use mem::transmute;\n-use raw::TraitObject;\n use intrinsics;\n use marker::Reflect;\n \n@@ -199,11 +197,7 @@ impl Any {\n     pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n         if self.is::<T>() {\n             unsafe {\n-                // Get the raw representation of the trait object\n-                let to: TraitObject = transmute(self);\n-\n-                // Extract the data pointer\n-                Some(&*(to.data as *const T))\n+                Some(&*(self as *const Any as *const T))\n             }\n         } else {\n             None\n@@ -240,11 +234,7 @@ impl Any {\n     pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n         if self.is::<T>() {\n             unsafe {\n-                // Get the raw representation of the trait object\n-                let to: TraitObject = transmute(self);\n-\n-                // Extract the data pointer\n-                Some(&mut *(to.data as *const T as *mut T))\n+                Some(&mut *(self as *mut Any as *mut T))\n             }\n         } else {\n             None"}, {"sha": "4acb8b807d594efcc0f6b8be67ec1165a93c9a9f", "filename": "src/librustc/infer/bivariate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fbivariate.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -106,7 +106,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         }\n     }\n \n-    fn regions(&mut self, a: ty::Region, _: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: &'tcx ty::Region, _: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region> {\n         Ok(a)\n     }\n "}, {"sha": "5ce30484ede0027aab5c595d58a5ef906067ea86", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -329,8 +329,8 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match r {\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n             // Never make variables for regions bound within the type itself,\n             // nor for erased regions.\n             ty::ReLateBound(..) |"}, {"sha": "bf247acec5a2d31112c5a787ac2b7772ab029318", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -79,7 +79,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         }\n     }\n \n-    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "9169d299e040b815876b8f75511b3a5981f06868", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n                                    err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n-                                   region: ty::Region,\n+                                   region: &'tcx ty::Region,\n                                    suffix: &str) {\n         fn item_scope_tag(item: &hir::Item) -> &'static str {\n             match item.node {\n@@ -120,7 +120,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n              Some(span))\n         }\n \n-        let (description, span) = match region {\n+        let (description, span) = match *region {\n             ty::ReScope(scope) => {\n                 let new_string;\n                 let unknown_scope = || {\n@@ -405,12 +405,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         fn free_regions_from_same_fn<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                     sub: Region,\n-                                                     sup: Region)\n+                                                     sub: &'tcx Region,\n+                                                     sup: &'tcx Region)\n                                                      -> Option<FreeRegionsFromSameFn> {\n             debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n             let (scope_id, fr1, fr2) = match (sub, sup) {\n-                (ReFree(fr1), ReFree(fr2)) => {\n+                (&ReFree(fr1), &ReFree(fr2)) => {\n                     if fr1.scope != fr2.scope {\n                         return None\n                     }\n@@ -602,7 +602,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn report_generic_bound_failure(&self,\n                                     origin: SubregionOrigin<'tcx>,\n                                     bound_kind: GenericKind<'tcx>,\n-                                    sub: Region)\n+                                    sub: &'tcx Region)\n     {\n         // FIXME: it would be better to report the first error message\n         // with the span of the parameter itself, rather than the span\n@@ -616,7 +616,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"the associated type `{}`\", p),\n         };\n \n-        let mut err = match sub {\n+        let mut err = match *sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n                 let mut err = struct_span_err!(self.tcx.sess,\n@@ -667,8 +667,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn report_concrete_failure(&self,\n                                origin: SubregionOrigin<'tcx>,\n-                               sub: Region,\n-                               sup: Region)\n+                               sub: &'tcx Region,\n+                               sup: &'tcx Region)\n                                 -> DiagnosticBuilder<'tcx> {\n         match origin {\n             infer::Subtype(trace) => {\n@@ -939,9 +939,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin<'tcx>,\n-                               sub_region: Region,\n+                               sub_region: &'tcx Region,\n                                sup_origin: SubregionOrigin<'tcx>,\n-                               sup_region: Region) {\n+                               sup_region: &'tcx Region) {\n         let mut err = self.report_inference_failure(var_origin);\n \n         self.tcx.note_and_explain_region(&mut err,"}, {"sha": "beda734ee0d567b3baf332d1f5a3af7919c052c3", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -83,8 +83,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match r {\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n             ty::ReEarlyBound(..) |\n             ty::ReLateBound(..) => {\n                 // leave bound regions alone\n@@ -99,7 +99,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::ReEmpty |\n             ty::ReErased => {\n                 // replace all free regions with 'erased\n-                ty::ReErased\n+                self.tcx().mk_region(ty::ReErased)\n             }\n         }\n     }"}, {"sha": "a5709e1880801d8942d87f909a1de2d46e301308", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -57,7 +57,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "90be5e935baf16a2733ec7e28f4a447d00135599", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -164,7 +164,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 .map(|(&skol, &(br, ref regions))| {\n                     let representative =\n                         regions.iter()\n-                               .filter(|r| !skol_resolution_map.contains_key(r))\n+                               .filter(|&&r| !skol_resolution_map.contains_key(r))\n                                .cloned()\n                                .next()\n                                .unwrap_or_else(|| { // [1]\n@@ -268,9 +268,9 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                                             r0: ty::Region)\n-                                             -> ty::Region {\n+                                             a_map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>,\n+                                             r0: &'tcx ty::Region)\n+                                             -> &'tcx ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n@@ -301,7 +301,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                     debug!(\"generalize_region(r0={:?}): \\\n                             replacing with {:?}, tainted={:?}\",\n                            r0, *a_br, tainted);\n-                    return ty::ReLateBound(debruijn, *a_br);\n+                    return infcx.tcx.mk_region(ty::ReLateBound(debruijn, *a_br));\n                 }\n             }\n \n@@ -364,10 +364,12 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                                             a_map: &FnvHashMap<ty::BoundRegion,\n+                                                                &'tcx ty::Region>,\n                                              a_vars: &[ty::RegionVid],\n                                              b_vars: &[ty::RegionVid],\n-                                             r0: ty::Region) -> ty::Region {\n+                                             r0: &'tcx ty::Region)\n+                                             -> &'tcx ty::Region {\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n                 return r0;\n@@ -419,7 +421,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             if a_r.is_some() && b_r.is_some() && only_new_vars {\n                 // Related to exactly one bound variable from each fn:\n-                return rev_lookup(span, a_map, a_r.unwrap());\n+                return rev_lookup(infcx, span, a_map, a_r.unwrap());\n             } else if a_r.is_none() && b_r.is_none() {\n                 // Not related to bound variables from either fn:\n                 assert!(!r0.is_bound());\n@@ -430,13 +432,14 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        fn rev_lookup(span: Span,\n-                      a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                      r: ty::Region) -> ty::Region\n+        fn rev_lookup<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                      span: Span,\n+                                      a_map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>,\n+                                      r: &'tcx ty::Region) -> &'tcx ty::Region\n         {\n             for (a_br, a_r) in a_map {\n                 if *a_r == r {\n-                    return ty::ReLateBound(ty::DebruijnIndex::new(1), *a_br);\n+                    return infcx.tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), *a_br));\n                 }\n             }\n             span_bug!(\n@@ -445,19 +448,21 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 r);\n         }\n \n-        fn fresh_bound_variable(infcx: &InferCtxt, debruijn: ty::DebruijnIndex) -> ty::Region {\n+        fn fresh_bound_variable<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                                debruijn: ty::DebruijnIndex)\n+                                                -> &'tcx ty::Region {\n             infcx.region_vars.new_bound(debruijn)\n         }\n     }\n }\n \n fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n-                           map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n+                           map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n                            -> Vec<ty::RegionVid> {\n     map.iter()\n-       .map(|(_, r)| match *r {\n+       .map(|(_, &r)| match *r {\n            ty::ReVar(r) => { r }\n-           r => {\n+           _ => {\n                span_bug!(\n                    fields.trace.origin.span(),\n                    \"found non-region-vid: {:?}\",\n@@ -467,8 +472,8 @@ fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n        .collect()\n }\n \n-fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n-    match r {\n+fn is_var_in_set(new_vars: &[ty::RegionVid], r: &ty::Region) -> bool {\n+    match *r {\n         ty::ReVar(ref v) => new_vars.iter().any(|x| x == v),\n         _ => false\n     }\n@@ -479,13 +484,13 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                          mut fldr: F)\n                                          -> T\n     where T: TypeFoldable<'tcx>,\n-          F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n+          F: FnMut(&'tcx ty::Region, ty::DebruijnIndex) -> &'tcx ty::Region,\n {\n     tcx.fold_regions(unbound_value, &mut false, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,\n         // because the ones at the current level should have been replaced\n         // with fresh variables\n-        assert!(match region {\n+        assert!(match *region {\n             ty::ReLateBound(..) => false,\n             _ => true\n         });\n@@ -497,9 +502,9 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn tainted_regions(&self,\n                        snapshot: &CombinedSnapshot,\n-                       r: ty::Region,\n+                       r: &'tcx ty::Region,\n                        directions: TaintDirections)\n-                       -> FnvHashSet<ty::Region> {\n+                       -> FnvHashSet<&'tcx ty::Region> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r, directions)\n     }\n \n@@ -596,7 +601,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            binder: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot)\n-                                           -> (T, SkolemizationMap)\n+                                           -> (T, SkolemizationMap<'tcx>)\n         where T : TypeFoldable<'tcx>\n     {\n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n@@ -619,7 +624,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn leak_check(&self,\n                       overly_polymorphic: bool,\n                       span: Span,\n-                      skol_map: &SkolemizationMap,\n+                      skol_map: &SkolemizationMap<'tcx>,\n                       snapshot: &CombinedSnapshot)\n                       -> RelateResult<'tcx, ()>\n     {\n@@ -673,7 +678,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             for &tainted_region in &incoming_taints {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n-                match tainted_region {\n+                match *tainted_region {\n                     ty::ReVar(vid) => {\n                         if new_vars.contains(&vid) {\n                             warnings.extend(\n@@ -742,7 +747,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// to the depth of the predicate, in this case 1, so that the final\n     /// predicate is `for<'a> &'a int : Clone`.\n     pub fn plug_leaks<T>(&self,\n-                         skol_map: SkolemizationMap,\n+                         skol_map: SkolemizationMap<'tcx>,\n                          snapshot: &CombinedSnapshot,\n                          value: &T) -> T\n         where T : TypeFoldable<'tcx>\n@@ -755,7 +760,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // region back to the `ty::BoundRegion` that it originally\n         // represented. Because `leak_check` passed, we know that\n         // these taint sets are mutually disjoint.\n-        let inv_skol_map: FnvHashMap<ty::Region, ty::BoundRegion> =\n+        let inv_skol_map: FnvHashMap<&'tcx ty::Region, ty::BoundRegion> =\n             skol_map\n             .iter()\n             .flat_map(|(&skol_br, &skol)| {\n@@ -794,15 +799,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // (which ought not to escape the snapshot, but we\n                     // don't check that) or itself\n                     assert!(\n-                        match r {\n+                        match *r {\n                             ty::ReVar(_) => true,\n                             ty::ReSkolemized(_, ref br1) => br == br1,\n                             _ => false,\n                         },\n                         \"leak-check would have us replace {:?} with {:?}\",\n                         r, br);\n \n-                    ty::ReLateBound(ty::DebruijnIndex::new(current_depth - 1), br.clone())\n+                    self.tcx.mk_region(ty::ReLateBound(\n+                        ty::DebruijnIndex::new(current_depth - 1), br.clone()))\n                 }\n             }\n         });\n@@ -826,7 +832,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Note: popping also occurs implicitly as part of `leak_check`.\n     pub fn pop_skolemized(&self,\n-                          skol_map: SkolemizationMap,\n+                          skol_map: SkolemizationMap<'tcx>,\n                           snapshot: &CombinedSnapshot)\n     {\n         debug!(\"pop_skolemized({:?})\", skol_map);"}, {"sha": "7d352be67d32b9c2a1dd716df90b74cbbaaec689", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -57,7 +57,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "9854cd95397b79179bb300abb77078d016a34502", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -177,7 +177,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n /// region that each late-bound region was replaced with.\n-pub type SkolemizationMap = FnvHashMap<ty::BoundRegion, ty::Region>;\n+pub type SkolemizationMap<'tcx> = FnvHashMap<ty::BoundRegion, &'tcx ty::Region>;\n \n /// Why did we require that the two types be related?\n ///\n@@ -1123,8 +1123,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn sub_regions(&self,\n                        origin: SubregionOrigin<'tcx>,\n-                       a: ty::Region,\n-                       b: ty::Region) {\n+                       a: &'tcx ty::Region,\n+                       b: &'tcx ty::Region) {\n         debug!(\"sub_regions({:?} <: {:?})\", a, b);\n         self.region_vars.make_subregion(origin, a, b);\n     }\n@@ -1147,7 +1147,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn region_outlives_predicate(&self,\n                                      span: Span,\n-                                     predicate: &ty::PolyRegionOutlivesPredicate)\n+                                     predicate: &ty::PolyRegionOutlivesPredicate<'tcx>)\n         -> UnitResult<'tcx>\n     {\n         self.commit_if_ok(|snapshot| {\n@@ -1190,16 +1190,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .new_key(None)\n     }\n \n-    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region {\n-        ty::ReVar(self.region_vars.new_region_var(origin))\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin)\n+                           -> &'tcx ty::Region {\n+        self.tcx.mk_region(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n     /// Create a region inference variable for the given\n     /// region parameter definition.\n     pub fn region_var_for_def(&self,\n                               span: Span,\n                               def: &ty::RegionParameterDef)\n-                              -> ty::Region {\n+                              -> &'tcx ty::Region {\n         self.next_region_var(EarlyBoundRegion(span, def.name))\n     }\n \n@@ -1245,7 +1246,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region {\n+    pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> &'tcx ty::Region {\n         self.region_vars.new_bound(debruijn)\n     }\n \n@@ -1530,7 +1531,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n-        -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n+        -> (T, FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n         where T : TypeFoldable<'tcx>\n     {\n         self.tcx.replace_late_bound_regions(\n@@ -1576,8 +1577,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn verify_generic_bound(&self,\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n-                                a: ty::Region,\n-                                bound: VerifyBound) {\n+                                a: &'tcx ty::Region,\n+                                bound: VerifyBound<'tcx>) {\n         debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\",\n                kind,\n                a,\n@@ -1666,7 +1667,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.region_maps.temporary_scope(rvalue_id)\n     }\n \n-    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n         self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n     }\n "}, {"sha": "1c64ebc0537ae7455f774eb2a0245042199f208d", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -123,7 +123,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     graph_name: String,\n-    map: &'a FnvHashMap<Constraint, SubregionOrigin<'tcx>>,\n+    map: &'a FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n     node_ids: FnvHashMap<Node, usize>,\n }\n \n@@ -135,8 +135,8 @@ enum Node {\n \n // type Edge = Constraint;\n #[derive(Clone, PartialEq, Eq, Debug, Copy)]\n-enum Edge {\n-    Constraint(Constraint),\n+enum Edge<'tcx> {\n+    Constraint(Constraint<'tcx>),\n     EnclScope(CodeExtent, CodeExtent),\n }\n \n@@ -177,7 +177,7 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     type Node = Node;\n-    type Edge = Edge;\n+    type Edge = Edge<'tcx>;\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(&*self.graph_name).unwrap()\n     }\n@@ -214,11 +214,11 @@ fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n         Constraint::ConstrainVarSubVar(rv_1, rv_2) =>\n             (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n         Constraint::ConstrainRegSubVar(r_1, rv_2) =>\n-            (Node::Region(r_1), Node::RegionVid(rv_2)),\n+            (Node::Region(*r_1), Node::RegionVid(rv_2)),\n         Constraint::ConstrainVarSubReg(rv_1, r_2) =>\n-            (Node::RegionVid(rv_1), Node::Region(r_2)),\n+            (Node::RegionVid(rv_1), Node::Region(*r_2)),\n         Constraint::ConstrainRegSubReg(r_1, r_2) =>\n-            (Node::Region(r_1), Node::Region(r_2)),\n+            (Node::Region(*r_1), Node::Region(*r_2)),\n     }\n }\n \n@@ -234,7 +234,7 @@ fn edge_to_nodes(e: &Edge) -> (Node, Node) {\n \n impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     type Node = Node;\n-    type Edge = Edge;\n+    type Edge = Edge<'tcx>;\n     fn nodes(&self) -> dot::Nodes<Node> {\n         let mut set = FnvHashSet();\n         for node in self.node_ids.keys() {\n@@ -243,26 +243,26 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n         debug!(\"constraint graph has {} nodes\", set.len());\n         set.into_iter().collect()\n     }\n-    fn edges(&self) -> dot::Edges<Edge> {\n+    fn edges(&self) -> dot::Edges<Edge<'tcx>> {\n         debug!(\"constraint graph has {} edges\", self.map.len());\n         let mut v: Vec<_> = self.map.keys().map(|e| Edge::Constraint(*e)).collect();\n         self.tcx.region_maps.each_encl_scope(|sub, sup| v.push(Edge::EnclScope(*sub, *sup)));\n         debug!(\"region graph has {} edges\", v.len());\n         Cow::Owned(v)\n     }\n-    fn source(&self, edge: &Edge) -> Node {\n+    fn source(&self, edge: &Edge<'tcx>) -> Node {\n         let (n1, _) = edge_to_nodes(edge);\n         debug!(\"edge {:?} has source {:?}\", edge, n1);\n         n1\n     }\n-    fn target(&self, edge: &Edge) -> Node {\n+    fn target(&self, edge: &Edge<'tcx>) -> Node {\n         let (_, n2) = edge_to_nodes(edge);\n         debug!(\"edge {:?} has target {:?}\", edge, n2);\n         n2\n     }\n }\n \n-pub type ConstraintMap<'tcx> = FnvHashMap<Constraint, SubregionOrigin<'tcx>>;\n+pub type ConstraintMap<'tcx> = FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n \n fn dump_region_constraints_to<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                               map: &ConstraintMap<'tcx>,"}, {"sha": "b3693ae1e21ad86378859fa9fc92ce428de236f6", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 191, "deletions": 155, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -39,22 +39,22 @@ mod graphviz;\n \n // A constraint that influences the inference process.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub enum Constraint {\n+pub enum Constraint<'tcx> {\n     // One region variable is subregion of another\n     ConstrainVarSubVar(RegionVid, RegionVid),\n \n     // Concrete region is subregion of region variable\n-    ConstrainRegSubVar(Region, RegionVid),\n+    ConstrainRegSubVar(&'tcx Region, RegionVid),\n \n     // Region variable is subregion of concrete region. This does not\n     // directly affect inference, but instead is checked after\n     // inference is complete.\n-    ConstrainVarSubReg(RegionVid, Region),\n+    ConstrainVarSubReg(RegionVid, &'tcx Region),\n \n     // A constraint where neither side is a variable. This does not\n     // directly affect inference, but instead is checked after\n     // inference is complete.\n-    ConstrainRegSubReg(Region, Region),\n+    ConstrainRegSubReg(&'tcx Region, &'tcx Region),\n }\n \n // VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n@@ -66,8 +66,8 @@ pub enum Constraint {\n pub struct Verify<'tcx> {\n     kind: GenericKind<'tcx>,\n     origin: SubregionOrigin<'tcx>,\n-    region: Region,\n-    bound: VerifyBound,\n+    region: &'tcx Region,\n+    bound: VerifyBound<'tcx>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -80,36 +80,36 @@ pub enum GenericKind<'tcx> {\n // particular region (let's call it `'min`) meets some bound.\n // The bound is described the by the following grammar:\n #[derive(Debug)]\n-pub enum VerifyBound {\n+pub enum VerifyBound<'tcx> {\n     // B = exists {R} --> some 'r in {R} must outlive 'min\n     //\n     // Put another way, the subject value is known to outlive all\n     // regions in {R}, so if any of those outlives 'min, then the\n     // bound is met.\n-    AnyRegion(Vec<Region>),\n+    AnyRegion(Vec<&'tcx Region>),\n \n     // B = forall {R} --> all 'r in {R} must outlive 'min\n     //\n     // Put another way, the subject value is known to outlive some\n     // region in {R}, so if all of those outlives 'min, then the bound\n     // is met.\n-    AllRegions(Vec<Region>),\n+    AllRegions(Vec<&'tcx Region>),\n \n     // B = exists {B} --> 'min must meet some bound b in {B}\n-    AnyBound(Vec<VerifyBound>),\n+    AnyBound(Vec<VerifyBound<'tcx>>),\n \n     // B = forall {B} --> 'min must meet all bounds b in {B}\n-    AllBounds(Vec<VerifyBound>),\n+    AllBounds(Vec<VerifyBound<'tcx>>),\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct TwoRegions {\n-    a: Region,\n-    b: Region,\n+pub struct TwoRegions<'tcx> {\n+    a: &'tcx Region,\n+    b: &'tcx Region,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-pub enum UndoLogEntry {\n+pub enum UndoLogEntry<'tcx> {\n     /// Pushed when we start a snapshot.\n     OpenSnapshot,\n \n@@ -122,7 +122,7 @@ pub enum UndoLogEntry {\n     AddVar(RegionVid),\n \n     /// We added the given `constraint`\n-    AddConstraint(Constraint),\n+    AddConstraint(Constraint<'tcx>),\n \n     /// We added the given `verify`\n     AddVerify(usize),\n@@ -131,7 +131,7 @@ pub enum UndoLogEntry {\n     AddGiven(ty::FreeRegion, ty::RegionVid),\n \n     /// We added a GLB/LUB \"combinaton variable\"\n-    AddCombination(CombineMapType, TwoRegions),\n+    AddCombination(CombineMapType, TwoRegions<'tcx>),\n \n     /// During skolemization, we sometimes purge entries from the undo\n     /// log in a kind of minisnapshot (unlike other snapshots, this\n@@ -153,13 +153,13 @@ pub enum RegionResolutionError<'tcx> {\n     /// `ConcreteFailure(o, a, b)`:\n     ///\n     /// `o` requires that `a <= b`, but this does not hold\n-    ConcreteFailure(SubregionOrigin<'tcx>, Region, Region),\n+    ConcreteFailure(SubregionOrigin<'tcx>, &'tcx Region, &'tcx Region),\n \n     /// `GenericBoundFailure(p, s, a)\n     ///\n     /// The parameter/associated-type `p` must be known to outlive the lifetime\n     /// `a` (but none of the known bounds are sufficient).\n-    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region),\n+    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, &'tcx Region),\n \n     /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n@@ -168,9 +168,9 @@ pub enum RegionResolutionError<'tcx> {\n     /// `sub_r <= sup_r` does not hold.\n     SubSupConflict(RegionVariableOrigin,\n                    SubregionOrigin<'tcx>,\n-                   Region,\n+                   &'tcx Region,\n                    SubregionOrigin<'tcx>,\n-                   Region),\n+                   &'tcx Region),\n \n     /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n     /// more specific errors message by suggesting to the user where they\n@@ -182,7 +182,7 @@ pub enum RegionResolutionError<'tcx> {\n \n #[derive(Clone, Debug)]\n pub enum ProcessedErrorOrigin<'tcx> {\n-    ConcreteFailure(SubregionOrigin<'tcx>, Region, Region),\n+    ConcreteFailure(SubregionOrigin<'tcx>, &'tcx Region, &'tcx Region),\n     VariableFailure(RegionVariableOrigin),\n }\n \n@@ -213,7 +213,7 @@ impl SameRegions {\n     }\n }\n \n-pub type CombineMap = FnvHashMap<TwoRegions, RegionVid>;\n+pub type CombineMap<'tcx> = FnvHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -222,7 +222,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // Constraints of the form `A <= B` introduced by the region\n     // checker.  Here at least one of `A` and `B` must be a region\n     // variable.\n-    constraints: RefCell<FnvHashMap<Constraint, SubregionOrigin<'tcx>>>,\n+    constraints: RefCell<FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n \n     // A \"verify\" is something that we need to verify after inference is\n     // done, but which does not directly affect inference in any way.\n@@ -250,8 +250,8 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // a bit of a hack but seems to work.\n     givens: RefCell<FnvHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n \n-    lubs: RefCell<CombineMap>,\n-    glbs: RefCell<CombineMap>,\n+    lubs: RefCell<CombineMap<'tcx>>,\n+    glbs: RefCell<CombineMap<'tcx>>,\n     skolemization_count: Cell<u32>,\n     bound_count: Cell<u32>,\n \n@@ -264,12 +264,12 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // otherwise we end up adding entries for things like the lower\n     // bound on a variable and so forth, which can never be rolled\n     // back.\n-    undo_log: RefCell<Vec<UndoLogEntry>>,\n+    undo_log: RefCell<Vec<UndoLogEntry<'tcx>>>,\n     unification_table: RefCell<UnificationTable<ty::RegionVid>>,\n \n     // This contains the results of inference.  It begins as an empty\n     // option and only acquires a value after inference is complete.\n-    values: RefCell<Option<Vec<VarValue>>>,\n+    values: RefCell<Option<Vec<VarValue<'tcx>>>>,\n }\n \n pub struct RegionSnapshot {\n@@ -303,23 +303,24 @@ impl TaintDirections {\n     }\n }\n \n-struct TaintSet {\n+struct TaintSet<'tcx> {\n     directions: TaintDirections,\n-    regions: FnvHashSet<ty::Region>\n+    regions: FnvHashSet<&'tcx ty::Region>\n }\n \n-impl TaintSet {\n+impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n     fn new(directions: TaintDirections,\n-           initial_region: ty::Region)\n+           initial_region: &'tcx ty::Region)\n            -> Self {\n         let mut regions = FnvHashSet();\n         regions.insert(initial_region);\n         TaintSet { directions: directions, regions: regions }\n     }\n \n     fn fixed_point(&mut self,\n-                   undo_log: &[UndoLogEntry],\n-                   verifys: &[Verify]) {\n+                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                   undo_log: &[UndoLogEntry<'tcx>],\n+                   verifys: &[Verify<'tcx>]) {\n         let mut prev_len = 0;\n         while prev_len < self.len() {\n             debug!(\"tainted: prev_len = {:?} new_len = {:?}\",\n@@ -330,19 +331,21 @@ impl TaintSet {\n             for undo_entry in undo_log {\n                 match undo_entry {\n                     &AddConstraint(ConstrainVarSubVar(a, b)) => {\n-                        self.add_edge(ReVar(a), ReVar(b));\n+                        self.add_edge(tcx.mk_region(ReVar(a)),\n+                                      tcx.mk_region(ReVar(b)));\n                     }\n                     &AddConstraint(ConstrainRegSubVar(a, b)) => {\n-                        self.add_edge(a, ReVar(b));\n+                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n                     }\n                     &AddConstraint(ConstrainVarSubReg(a, b)) => {\n-                        self.add_edge(ReVar(a), b);\n+                        self.add_edge(tcx.mk_region(ReVar(a)), b);\n                     }\n                     &AddConstraint(ConstrainRegSubReg(a, b)) => {\n                         self.add_edge(a, b);\n                     }\n                     &AddGiven(a, b) => {\n-                        self.add_edge(ReFree(a), ReVar(b));\n+                        self.add_edge(tcx.mk_region(ReFree(a)),\n+                                      tcx.mk_region(ReVar(b)));\n                     }\n                     &AddVerify(i) => {\n                         verifys[i].bound.for_each_region(&mut |b| {\n@@ -359,7 +362,7 @@ impl TaintSet {\n         }\n     }\n \n-    fn into_set(self) -> FnvHashSet<ty::Region> {\n+    fn into_set(self) -> FnvHashSet<&'tcx ty::Region> {\n         self.regions\n     }\n \n@@ -368,8 +371,8 @@ impl TaintSet {\n     }\n \n     fn add_edge(&mut self,\n-                source: ty::Region,\n-                target: ty::Region) {\n+                source: &'tcx ty::Region,\n+                target: &'tcx ty::Region) {\n         if self.directions.incoming {\n             if self.regions.contains(&target) {\n                 self.regions.insert(source);\n@@ -450,7 +453,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             .rollback_to(snapshot.region_snapshot);\n     }\n \n-    pub fn rollback_undo_entry(&self, undo_entry: UndoLogEntry) {\n+    pub fn rollback_undo_entry(&self, undo_entry: UndoLogEntry<'tcx>) {\n         match undo_entry {\n             OpenSnapshot => {\n                 panic!(\"Failure to observe stack discipline\");\n@@ -529,21 +532,22 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// The `snapshot` argument to this function is not really used;\n     /// it's just there to make it explicit which snapshot bounds the\n     /// skolemized region that results. It should always be the top-most snapshot.\n-    pub fn push_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot) -> Region {\n+    pub fn push_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot)\n+                           -> &'tcx Region {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n \n         let sc = self.skolemization_count.get();\n         self.skolemization_count.set(sc + 1);\n-        ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br)\n+        self.tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n     }\n \n     /// Removes all the edges to/from the skolemized regions that are\n     /// in `skols`. This is used after a higher-ranked operation\n     /// completes to remove all trace of the skolemized regions\n     /// created in that time.\n     pub fn pop_skolemized(&self,\n-                          skols: &FnvHashSet<ty::Region>,\n+                          skols: &FnvHashSet<&'tcx ty::Region>,\n                           snapshot: &RegionSnapshot) {\n         debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n \n@@ -566,7 +570,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 skols.len());\n         debug_assert! {\n             skols.iter()\n-                 .all(|k| match *k {\n+                 .all(|&k| match *k {\n                      ty::ReSkolemized(index, _) =>\n                          index.index >= first_to_pop &&\n                          index.index < last_to_pop,\n@@ -597,9 +601,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         self.skolemization_count.set(snapshot.skolemization_count);\n         return;\n \n-        fn kill_constraint(skols: &FnvHashSet<ty::Region>,\n-                           undo_entry: &UndoLogEntry)\n-                           -> bool {\n+        fn kill_constraint<'tcx>(skols: &FnvHashSet<&'tcx ty::Region>,\n+                                 undo_entry: &UndoLogEntry<'tcx>)\n+                                 -> bool {\n             match undo_entry {\n                 &AddConstraint(ConstrainVarSubVar(_, _)) =>\n                     false,\n@@ -626,7 +630,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     }\n \n-    pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region {\n+    pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> &'tcx Region {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n         // the top of this file for more details.\n@@ -652,14 +656,14 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             bug!(\"rollover in RegionInference new_bound()\");\n         }\n \n-        ReLateBound(debruijn, BrFresh(sc))\n+        self.tcx.mk_region(ReLateBound(debruijn, BrFresh(sc)))\n     }\n \n     fn values_are_none(&self) -> bool {\n         self.values.borrow().is_none()\n     }\n \n-    fn add_constraint(&self, constraint: Constraint, origin: SubregionOrigin<'tcx>) {\n+    fn add_constraint(&self, constraint: Constraint<'tcx>, origin: SubregionOrigin<'tcx>) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -704,20 +708,26 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn make_eqregion(&self, origin: SubregionOrigin<'tcx>, sub: Region, sup: Region) {\n+    pub fn make_eqregion(&self,\n+                         origin: SubregionOrigin<'tcx>,\n+                         sub: &'tcx Region,\n+                         sup: &'tcx Region) {\n         if sub != sup {\n             // Eventually, it would be nice to add direct support for\n             // equating regions.\n             self.make_subregion(origin.clone(), sub, sup);\n             self.make_subregion(origin, sup, sub);\n \n-            if let (ty::ReVar(sub), ty::ReVar(sup)) = (sub, sup) {\n+            if let (ty::ReVar(sub), ty::ReVar(sup)) = (*sub, *sup) {\n                 self.unification_table.borrow_mut().union(sub, sup);\n             }\n         }\n     }\n \n-    pub fn make_subregion(&self, origin: SubregionOrigin<'tcx>, sub: Region, sup: Region) {\n+    pub fn make_subregion(&self,\n+                          origin: SubregionOrigin<'tcx>,\n+                          sub: &'tcx Region,\n+                          sup: &'tcx Region) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -727,26 +737,26 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                origin);\n \n         match (sub, sup) {\n-            (ReEarlyBound(..), _) |\n-            (ReLateBound(..), _) |\n-            (_, ReEarlyBound(..)) |\n-            (_, ReLateBound(..)) => {\n+            (&ReEarlyBound(..), _) |\n+            (&ReLateBound(..), _) |\n+            (_, &ReEarlyBound(..)) |\n+            (_, &ReLateBound(..)) => {\n                 span_bug!(origin.span(),\n                           \"cannot relate bound region: {:?} <= {:?}\",\n                           sub,\n                           sup);\n             }\n-            (_, ReStatic) => {\n+            (_, &ReStatic) => {\n                 // all regions are subregions of static, so we can ignore this\n             }\n-            (ReVar(sub_id), ReVar(sup_id)) => {\n+            (&ReVar(sub_id), &ReVar(sup_id)) => {\n                 self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n             }\n-            (r, ReVar(sup_id)) => {\n-                self.add_constraint(ConstrainRegSubVar(r, sup_id), origin);\n+            (_, &ReVar(sup_id)) => {\n+                self.add_constraint(ConstrainRegSubVar(sub, sup_id), origin);\n             }\n-            (ReVar(sub_id), r) => {\n-                self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n+            (&ReVar(sub_id), _) => {\n+                self.add_constraint(ConstrainVarSubReg(sub_id, sup), origin);\n             }\n             _ => {\n                 self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n@@ -758,8 +768,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     pub fn verify_generic_bound(&self,\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n-                                sub: Region,\n-                                bound: VerifyBound) {\n+                                sub: &'tcx Region,\n+                                bound: VerifyBound<'tcx>) {\n         self.add_verify(Verify {\n             kind: kind,\n             origin: origin,\n@@ -768,29 +778,43 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    pub fn lub_regions(&self, origin: SubregionOrigin<'tcx>, a: Region, b: Region) -> Region {\n+    pub fn lub_regions(&self,\n+                       origin: SubregionOrigin<'tcx>,\n+                       a: &'tcx Region,\n+                       b: &'tcx Region)\n+                       -> &'tcx Region {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n-        if a == ty::ReStatic || b == ty::ReStatic {\n-            ReStatic // nothing lives longer than static\n-        } else if a == b {\n-            a // LUB(a,a) = a\n-        } else {\n-            self.combine_vars(Lub, a, b, origin.clone(), |this, old_r, new_r| {\n-                this.make_subregion(origin.clone(), old_r, new_r)\n-            })\n+        match (a, b) {\n+            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n+                r // nothing lives longer than static\n+            }\n+\n+            _ if a == b => {\n+                a // LUB(a,a) = a\n+            }\n+\n+            _ => {\n+                self.combine_vars(Lub, a, b, origin.clone(), |this, old_r, new_r| {\n+                    this.make_subregion(origin.clone(), old_r, new_r)\n+                })\n+            }\n         }\n     }\n \n-    pub fn glb_regions(&self, origin: SubregionOrigin<'tcx>, a: Region, b: Region) -> Region {\n+    pub fn glb_regions(&self,\n+                       origin: SubregionOrigin<'tcx>,\n+                       a: &'tcx Region,\n+                       b: &'tcx Region)\n+                       -> &'tcx Region {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n-            (ReStatic, r) | (r, ReStatic) => {\n+            (&ReStatic, r) | (r, &ReStatic) => {\n                 r // static lives longer than everything else\n             }\n \n@@ -806,26 +830,27 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region {\n+    pub fn resolve_var(&self, rid: RegionVid) -> &'tcx ty::Region {\n         match *self.values.borrow() {\n             None => {\n                 span_bug!((*self.var_origins.borrow())[rid.index as usize].span(),\n                           \"attempt to resolve region variable before values have \\\n                            been computed!\")\n             }\n             Some(ref values) => {\n-                let r = lookup(values, rid);\n+                let r = lookup(self.tcx, values, rid);\n                 debug!(\"resolve_var({:?}) = {:?}\", rid, r);\n                 r\n             }\n         }\n     }\n \n-    pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> ty::Region {\n-        ty::ReVar(self.unification_table.borrow_mut().find_value(rid).min_vid)\n+    pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> &'tcx ty::Region {\n+        let vid = self.unification_table.borrow_mut().find_value(rid).min_vid;\n+        self.tcx.mk_region(ty::ReVar(vid))\n     }\n \n-    fn combine_map(&self, t: CombineMapType) -> &RefCell<CombineMap> {\n+    fn combine_map(&self, t: CombineMapType) -> &RefCell<CombineMap<'tcx>> {\n         match t {\n             Glb => &self.glbs,\n             Lub => &self.lubs,\n@@ -834,26 +859,26 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn combine_vars<F>(&self,\n                            t: CombineMapType,\n-                           a: Region,\n-                           b: Region,\n+                           a: &'tcx Region,\n+                           b: &'tcx Region,\n                            origin: SubregionOrigin<'tcx>,\n                            mut relate: F)\n-                           -> Region\n-        where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, Region, Region)\n+                           -> &'tcx Region\n+        where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, &'tcx Region, &'tcx Region)\n     {\n         let vars = TwoRegions { a: a, b: b };\n         if let Some(&c) = self.combine_map(t).borrow().get(&vars) {\n-            return ReVar(c);\n+            return self.tcx.mk_region(ReVar(c));\n         }\n         let c = self.new_region_var(MiscVariable(origin.span()));\n         self.combine_map(t).borrow_mut().insert(vars, c);\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddCombination(t, vars));\n         }\n-        relate(self, a, ReVar(c));\n-        relate(self, b, ReVar(c));\n+        relate(self, a, self.tcx.mk_region(ReVar(c)));\n+        relate(self, b, self.tcx.mk_region(ReVar(c)));\n         debug!(\"combine_vars() c={:?}\", c);\n-        ReVar(c)\n+        self.tcx.mk_region(ReVar(c))\n     }\n \n     pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot) -> Vec<RegionVid> {\n@@ -878,17 +903,18 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// related to other regions.\n     pub fn tainted(&self,\n                    mark: &RegionSnapshot,\n-                   r0: Region,\n+                   r0: &'tcx Region,\n                    directions: TaintDirections)\n-                   -> FnvHashSet<ty::Region> {\n+                   -> FnvHashSet<&'tcx ty::Region> {\n         debug!(\"tainted(mark={:?}, r0={:?}, directions={:?})\",\n                mark, r0, directions);\n \n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n         // is not a terribly efficient implementation.\n         let mut taint_set = TaintSet::new(directions, r0);\n-        taint_set.fixed_point(&self.undo_log.borrow()[mark.length..],\n+        taint_set.fixed_point(self.tcx,\n+                              &self.undo_log.borrow()[mark.length..],\n                               &self.verifys.borrow());\n         debug!(\"tainted: result={:?}\", taint_set.regions);\n         return taint_set.into_set();\n@@ -910,36 +936,39 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         errors\n     }\n \n-    fn lub_concrete_regions(&self, free_regions: &FreeRegionMap, a: Region, b: Region) -> Region {\n+    fn lub_concrete_regions(&self,\n+                            free_regions: &FreeRegionMap,\n+                            a: &'tcx Region,\n+                            b: &'tcx Region)\n+                            -> &'tcx Region {\n         match (a, b) {\n-            (ReLateBound(..), _) |\n-            (_, ReLateBound(..)) |\n-            (ReEarlyBound(..), _) |\n-            (_, ReEarlyBound(..)) |\n-            (ReErased, _) |\n-            (_, ReErased) => {\n+            (&ReLateBound(..), _) |\n+            (_, &ReLateBound(..)) |\n+            (&ReEarlyBound(..), _) |\n+            (_, &ReEarlyBound(..)) |\n+            (&ReErased, _) |\n+            (_, &ReErased) => {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n             }\n \n-            (ReStatic, _) | (_, ReStatic) => {\n-                ReStatic // nothing lives longer than static\n+            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n+                r // nothing lives longer than static\n             }\n \n-            (ReEmpty, r) | (r, ReEmpty) => {\n+            (&ReEmpty, r) | (r, &ReEmpty) => {\n                 r // everything lives longer than empty\n             }\n \n-            (ReVar(v_id), _) | (_, ReVar(v_id)) => {\n+            (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n                 span_bug!((*self.var_origins.borrow())[v_id.index as usize].span(),\n                           \"lub_concrete_regions invoked with non-concrete \\\n                            regions: {:?}, {:?}\",\n                           a,\n                           b);\n             }\n \n-            (ReFree(ref fr), ReScope(s_id)) |\n-            (ReScope(s_id), ReFree(ref fr)) => {\n-                let f = ReFree(*fr);\n+            (&ReFree(fr), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReFree(fr)) => {\n                 // A \"free\" region can be interpreted as \"some region\n                 // at least as big as the block fr.scope_id\".  So, we can\n                 // reasonably compare free regions and scopes:\n@@ -949,33 +978,34 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                     // if the free region's scope `fr.scope_id` is bigger than\n                     // the scope region `s_id`, then the LUB is the free\n                     // region itself:\n-                    f\n+                    self.tcx.mk_region(ReFree(fr))\n                 } else {\n                     // otherwise, we don't know what the free region is,\n                     // so we must conservatively say the LUB is static:\n-                    ReStatic\n+                    self.tcx.mk_region(ReStatic)\n                 }\n             }\n \n-            (ReScope(a_id), ReScope(b_id)) => {\n+            (&ReScope(a_id), &ReScope(b_id)) => {\n                 // The region corresponding to an outer block is a\n                 // subtype of the region corresponding to an inner\n                 // block.\n-                ReScope(self.tcx.region_maps.nearest_common_ancestor(a_id, b_id))\n+                self.tcx.mk_region(ReScope(\n+                    self.tcx.region_maps.nearest_common_ancestor(a_id, b_id)))\n             }\n \n-            (ReFree(a_fr), ReFree(b_fr)) => {\n-                free_regions.lub_free_regions(a_fr, b_fr)\n+            (&ReFree(a_fr), &ReFree(b_fr)) => {\n+                self.tcx.mk_region(free_regions.lub_free_regions(a_fr, b_fr))\n             }\n \n             // For these types, we cannot define any additional\n             // relationship:\n-            (ReSkolemized(..), _) |\n-            (_, ReSkolemized(..)) => {\n+            (&ReSkolemized(..), _) |\n+            (_, &ReSkolemized(..)) => {\n                 if a == b {\n                     a\n                 } else {\n-                    ReStatic\n+                    self.tcx.mk_region(ReStatic)\n                 }\n             }\n         }\n@@ -985,24 +1015,24 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n // ______________________________________________________________________\n \n #[derive(Copy, Clone, Debug)]\n-pub enum VarValue {\n-    Value(Region),\n+pub enum VarValue<'tcx> {\n+    Value(&'tcx Region),\n     ErrorValue,\n }\n \n struct RegionAndOrigin<'tcx> {\n-    region: Region,\n+    region: &'tcx Region,\n     origin: SubregionOrigin<'tcx>,\n }\n \n-type RegionGraph = graph::Graph<(), Constraint>;\n+type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     fn infer_variable_values(&self,\n                              free_regions: &FreeRegionMap,\n                              errors: &mut Vec<RegionResolutionError<'tcx>>,\n                              subject: ast::NodeId)\n-                             -> Vec<VarValue> {\n+                             -> Vec<VarValue<'tcx>> {\n         let mut var_data = self.construct_var_data();\n \n         // Dorky hack to cause `dump_constraints` to only get called\n@@ -1020,9 +1050,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         var_data\n     }\n \n-    fn construct_var_data(&self) -> Vec<VarValue> {\n+    fn construct_var_data(&self) -> Vec<VarValue<'tcx>> {\n         (0..self.num_vars() as usize)\n-            .map(|_| Value(ty::ReEmpty))\n+            .map(|_| Value(self.tcx.mk_region(ty::ReEmpty)))\n             .collect()\n     }\n \n@@ -1059,7 +1089,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn expansion(&self, free_regions: &FreeRegionMap, var_values: &mut [VarValue]) {\n+    fn expansion(&self, free_regions: &FreeRegionMap, var_values: &mut [VarValue<'tcx>]) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n             debug!(\"expansion: constraint={:?} origin={:?}\",\n                    constraint, origin);\n@@ -1089,17 +1119,17 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     fn expand_node(&self,\n                    free_regions: &FreeRegionMap,\n-                   a_region: Region,\n+                   a_region: &'tcx Region,\n                    b_vid: RegionVid,\n-                   b_data: &mut VarValue)\n+                   b_data: &mut VarValue<'tcx>)\n                    -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\",\n                a_region,\n                b_vid,\n                b_data);\n \n         // Check if this relationship is implied by a given.\n-        match a_region {\n+        match *a_region {\n             ty::ReFree(fr) => {\n                 if self.givens.borrow().contains(&(fr, b_vid)) {\n                     debug!(\"given\");\n@@ -1136,7 +1166,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// and check that they are satisfied.\n     fn collect_errors(&self,\n                       free_regions: &FreeRegionMap,\n-                      var_data: &mut Vec<VarValue>,\n+                      var_data: &mut Vec<VarValue<'tcx>>,\n                       errors: &mut Vec<RegionResolutionError<'tcx>>) {\n         let constraints = self.constraints.borrow();\n         for (constraint, origin) in constraints.iter() {\n@@ -1192,7 +1222,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         for verify in self.verifys.borrow().iter() {\n             debug!(\"collect_errors: verify={:?}\", verify);\n-            let sub = normalize(var_data, verify.region);\n+            let sub = normalize(self.tcx, var_data, verify.region);\n             if verify.bound.is_met(self.tcx, free_regions, var_data, sub) {\n                 continue;\n             }\n@@ -1213,8 +1243,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// and create a `RegionResolutionError` for each of them.\n     fn collect_var_errors(&self,\n                           free_regions: &FreeRegionMap,\n-                          var_data: &[VarValue],\n-                          graph: &RegionGraph,\n+                          var_data: &[VarValue<'tcx>],\n+                          graph: &RegionGraph<'tcx>,\n                           errors: &mut Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"collect_var_errors\");\n \n@@ -1271,7 +1301,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn construct_graph(&self) -> RegionGraph {\n+    fn construct_graph(&self) -> RegionGraph<'tcx> {\n         let num_vars = self.num_vars();\n \n         let constraints = self.constraints.borrow();\n@@ -1315,7 +1345,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     fn collect_error_for_expanding_node(&self,\n                                         free_regions: &FreeRegionMap,\n-                                        graph: &RegionGraph,\n+                                        graph: &RegionGraph<'tcx>,\n                                         dup_vec: &mut [u32],\n                                         node_idx: RegionVid,\n                                         errors: &mut Vec<RegionResolutionError<'tcx>>) {\n@@ -1339,9 +1369,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         // the user will more likely get a specific suggestion.\n         fn free_regions_first(a: &RegionAndOrigin, b: &RegionAndOrigin) -> Ordering {\n             match (a.region, b.region) {\n-                (ReFree(..), ReFree(..)) => Equal,\n-                (ReFree(..), _) => Less,\n-                (_, ReFree(..)) => Greater,\n+                (&ReFree(..), &ReFree(..)) => Equal,\n+                (&ReFree(..), _) => Less,\n+                (_, &ReFree(..)) => Greater,\n                 (_, _) => Equal,\n             }\n         }\n@@ -1378,7 +1408,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     fn collect_concrete_regions(&self,\n-                                graph: &RegionGraph,\n+                                graph: &RegionGraph<'tcx>,\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction,\n                                 dup_vec: &mut [u32])\n@@ -1423,7 +1453,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         fn process_edges<'a, 'gcx, 'tcx>(this: &RegionVarBindings<'a, 'gcx, 'tcx>,\n                                          state: &mut WalkState<'tcx>,\n-                                         graph: &RegionGraph,\n+                                         graph: &RegionGraph<'tcx>,\n                                          source_vid: RegionVid,\n                                          dir: Direction) {\n             debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n@@ -1460,7 +1490,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n-        where F: FnMut(&Constraint, &SubregionOrigin<'tcx>) -> bool\n+        where F: FnMut(&Constraint<'tcx>, &SubregionOrigin<'tcx>) -> bool\n     {\n         let mut iteration = 0;\n         let mut changed = true;\n@@ -1481,17 +1511,23 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n }\n \n-fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n-    match r {\n-        ty::ReVar(rid) => lookup(values, rid),\n+fn normalize<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                             values: &Vec<VarValue<'tcx>>,\n+                             r: &'tcx ty::Region)\n+                             -> &'tcx ty::Region {\n+    match *r {\n+        ty::ReVar(rid) => lookup(tcx, values, rid),\n         _ => r,\n     }\n }\n \n-fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n+fn lookup<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                          values: &Vec<VarValue<'tcx>>,\n+                          rid: ty::RegionVid)\n+                          -> &'tcx ty::Region {\n     match values[rid.index as usize] {\n         Value(r) => r,\n-        ErrorValue => ReStatic, // Previously reported error.\n+        ErrorValue => tcx.mk_region(ReStatic), // Previously reported error.\n     }\n }\n \n@@ -1535,8 +1571,8 @@ impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> VerifyBound {\n-    fn for_each_region(&self, f: &mut FnMut(ty::Region)) {\n+impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n+    fn for_each_region(&self, f: &mut FnMut(&'tcx ty::Region)) {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) |\n             &VerifyBound::AllRegions(ref rs) => for &r in rs {\n@@ -1552,7 +1588,7 @@ impl<'a, 'gcx, 'tcx> VerifyBound {\n \n     pub fn must_hold(&self) -> bool {\n         match self {\n-            &VerifyBound::AnyRegion(ref bs) => bs.contains(&ty::ReStatic),\n+            &VerifyBound::AnyRegion(ref bs) => bs.contains(&&ty::ReStatic),\n             &VerifyBound::AllRegions(ref bs) => bs.is_empty(),\n             &VerifyBound::AnyBound(ref bs) => bs.iter().any(|b| b.must_hold()),\n             &VerifyBound::AllBounds(ref bs) => bs.iter().all(|b| b.must_hold()),\n@@ -1562,13 +1598,13 @@ impl<'a, 'gcx, 'tcx> VerifyBound {\n     pub fn cannot_hold(&self) -> bool {\n         match self {\n             &VerifyBound::AnyRegion(ref bs) => bs.is_empty(),\n-            &VerifyBound::AllRegions(ref bs) => bs.contains(&ty::ReEmpty),\n+            &VerifyBound::AllRegions(ref bs) => bs.contains(&&ty::ReEmpty),\n             &VerifyBound::AnyBound(ref bs) => bs.iter().all(|b| b.cannot_hold()),\n             &VerifyBound::AllBounds(ref bs) => bs.iter().any(|b| b.cannot_hold()),\n         }\n     }\n \n-    pub fn or(self, vb: VerifyBound) -> VerifyBound {\n+    pub fn or(self, vb: VerifyBound<'tcx>) -> VerifyBound<'tcx> {\n         if self.must_hold() || vb.cannot_hold() {\n             self\n         } else if self.cannot_hold() || vb.must_hold() {\n@@ -1578,7 +1614,7 @@ impl<'a, 'gcx, 'tcx> VerifyBound {\n         }\n     }\n \n-    pub fn and(self, vb: VerifyBound) -> VerifyBound {\n+    pub fn and(self, vb: VerifyBound<'tcx>) -> VerifyBound<'tcx> {\n         if self.must_hold() && vb.must_hold() {\n             self\n         } else if self.cannot_hold() && vb.cannot_hold() {\n@@ -1590,18 +1626,18 @@ impl<'a, 'gcx, 'tcx> VerifyBound {\n \n     fn is_met(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n               free_regions: &FreeRegionMap,\n-              var_values: &Vec<VarValue>,\n-              min: ty::Region)\n+              var_values: &Vec<VarValue<'tcx>>,\n+              min: &'tcx ty::Region)\n               -> bool {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) =>\n                 rs.iter()\n-                  .map(|&r| normalize(var_values, r))\n+                  .map(|&r| normalize(tcx, var_values, r))\n                   .any(|r| free_regions.is_subregion_of(tcx, min, r)),\n \n             &VerifyBound::AllRegions(ref rs) =>\n                 rs.iter()\n-                  .map(|&r| normalize(var_values, r))\n+                  .map(|&r| normalize(tcx, var_values, r))\n                   .all(|r| free_regions.is_subregion_of(tcx, min, r)),\n \n             &VerifyBound::AnyBound(ref bs) =>"}, {"sha": "357a03a2ffd7c214d4919169e76a363620fd2f46", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -72,10 +72,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match r {\n-          ty::ReVar(rid) => self.infcx.region_vars.opportunistic_resolve_var(rid),\n-          _ => r,\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n+            ty::ReVar(rid) => self.infcx.region_vars.opportunistic_resolve_var(rid),\n+            _ => r,\n         }\n     }\n }\n@@ -138,10 +138,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match r {\n-          ty::ReVar(rid) => self.infcx.region_vars.resolve_var(rid),\n-          _ => r,\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n+            ty::ReVar(rid) => self.infcx.region_vars.resolve_var(rid),\n+            _ => r,\n         }\n     }\n }"}, {"sha": "159de2faced574e5fb9817f6e03223768fc1233d", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -107,7 +107,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         }\n     }\n \n-    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region> {\n         debug!(\"{}.regions({:?}, {:?}) self.cause={:?}\",\n                self.tag(), a, b, self.fields.cause);\n         // FIXME -- we have more fine-grained information available"}, {"sha": "1e4b2e9116fd27f67e5b344e947e683e9700c568", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -27,6 +27,7 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]\n+#![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(enumset)]"}, {"sha": "b33bc520fe21622407561beccea2dab9e662dc30", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -149,7 +149,7 @@ pub trait CrateStore<'tcx> {\n     fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind;\n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>;\n-    fn item_variances(&self, def: DefId) -> ty::ItemVariances;\n+    fn item_variances(&self, def: DefId) -> Vec<ty::Variance>;\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx>;\n@@ -198,7 +198,6 @@ pub trait CrateStore<'tcx> {\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool;\n     fn is_foreign_item(&self, did: DefId) -> bool;\n-    fn is_static_method(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n     fn is_typedef(&self, did: DefId) -> bool;\n \n@@ -329,7 +328,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind  { bug!(\"closure_kind\") }\n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n-    fn item_variances(&self, def: DefId) -> ty::ItemVariances { bug!(\"item_variances\") }\n+    fn item_variances(&self, def: DefId) -> Vec<ty::Variance> { bug!(\"item_variances\") }\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx> { bug!(\"item_type\") }\n@@ -391,7 +390,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool\n         { bug!(\"is_extern_item\") }\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n-    fn is_static_method(&self, did: DefId) -> bool { bug!(\"is_static_method\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n     fn is_typedef(&self, did: DefId) -> bool { bug!(\"is_typedef\") }\n "}, {"sha": "37366f38974a4bbc8c77a2e7bf93bacadd09468b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n             if self.tcx.trait_of_item(def.def_id()).is_some() => {\n                 if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n-                    match substs.substs.types[0].sty {\n+                    match substs.substs.type_at(0).sty {\n                         TyEnum(tyid, _) | TyStruct(tyid, _) => {\n                             self.check_def_id(tyid.did)\n                         }"}, {"sha": "798702e6fd6571b5f70269576e641c335dbc4e1c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -76,7 +76,7 @@ pub trait Delegate<'tcx> {\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              loan_region: ty::Region,\n+              loan_region: &'tcx ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: LoanCause);\n \n@@ -301,11 +301,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         for arg in &decl.inputs {\n             let arg_ty = return_if_err!(self.mc.infcx.node_ty(arg.pat.id));\n \n-            let fn_body_scope = self.tcx().region_maps.node_extent(body.id);\n+            let fn_body_scope_r = self.tcx().node_scope_region(body.id);\n             let arg_cmt = self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n-                ty::ReScope(fn_body_scope), // Args live only as long as the fn body.\n+                fn_body_scope_r, // Args live only as long as the fn body.\n                 arg_ty);\n \n             self.walk_irrefutable_pat(arg_cmt, &arg.pat);\n@@ -352,7 +352,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     fn borrow_expr(&mut self,\n                    expr: &hir::Expr,\n-                   r: ty::Region,\n+                   r: &'tcx ty::Region,\n                    bk: ty::BorrowKind,\n                    cause: LoanCause) {\n         debug!(\"borrow_expr(expr={:?}, r={:?}, bk={:?})\",\n@@ -431,7 +431,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n             hir::ExprMatch(ref discr, ref arms, _) => {\n                 let discr_cmt = return_if_err!(self.mc.cat_expr(&discr));\n-                self.borrow_expr(&discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n+                let r = self.tcx().mk_region(ty::ReEmpty);\n+                self.borrow_expr(&discr, r, ty::ImmBorrow, MatchDiscriminant);\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n@@ -449,7 +450,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.mc.infcx.node_ty(expr.id));\n-                if let ty::TyRef(&r, _) = expr_ty.sty {\n+                if let ty::TyRef(r, _) = expr_ty.sty {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.borrow_expr(&base, r, bk, AddrOf);\n                 }\n@@ -557,7 +558,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         let callee_ty = return_if_err!(self.mc.infcx.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n                callee, callee_ty);\n-        let call_scope = self.tcx().region_maps.node_extent(call.id);\n         match callee_ty.sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n                 self.consume_expr(callee);\n@@ -578,14 +578,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     };\n                 match overloaded_call_type {\n                     FnMutOverloadedCall => {\n+                        let call_scope_r = self.tcx().node_scope_region(call.id);\n                         self.borrow_expr(callee,\n-                                         ty::ReScope(call_scope),\n+                                         call_scope_r,\n                                          ty::MutBorrow,\n                                          ClosureInvocation);\n                     }\n                     FnOverloadedCall => {\n+                        let call_scope_r = self.tcx().node_scope_region(call.id);\n                         self.borrow_expr(callee,\n-                                         ty::ReScope(call_scope),\n+                                         call_scope_r,\n                                          ty::ImmBorrow,\n                                          ClosureInvocation);\n                     }\n@@ -761,7 +763,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 };\n                 let bk = ty::BorrowKind::from_mutbl(m);\n                 self.delegate.borrow(expr.id, expr.span, cmt,\n-                                     *r, bk, AutoRef);\n+                                     r, bk, AutoRef);\n             }\n         }\n     }\n@@ -822,7 +824,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n                                      cmt_base,\n-                                     *r,\n+                                     r,\n                                      ty::BorrowKind::from_mutbl(m),\n                                      AutoRef);\n             }\n@@ -835,7 +837,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // Converting from a &T to *T (or &mut T to *mut T) is\n                 // treated as borrowing it for the enclosing temporary\n                 // scope.\n-                let r = ty::ReScope(self.tcx().region_maps.node_extent(expr.id));\n+                let r = self.tcx().node_scope_region(expr.id);\n \n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n@@ -890,7 +892,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // methods are implicitly autoref'd which sadly does not use\n         // adjustments, so we must hardcode the borrow here.\n \n-        let r = ty::ReScope(self.tcx().region_maps.node_extent(expr.id));\n+        let r = self.tcx().node_scope_region(expr.id);\n         let bk = ty::ImmBorrow;\n \n         for &arg in &rhs {\n@@ -979,7 +981,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // It is also a borrow or copy/move of the value being matched.\n                 match bmode {\n                     hir::BindByRef(m) => {\n-                        if let ty::TyRef(&r, _) = pat_ty.sty {\n+                        if let ty::TyRef(r, _) = pat_ty.sty {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n                             delegate.borrow(pat.id, pat.span, cmt_pat, r, bk, RefBinding);\n                         }"}, {"sha": "8193d062631c1f4be6309ffae1ad1813ef91f8df", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -37,7 +37,7 @@ impl FreeRegionMap {\n         for implied_bound in implied_bounds {\n             debug!(\"implied bound: {:?}\", implied_bound);\n             match *implied_bound {\n-                ImpliedBound::RegionSubRegion(ty::ReFree(free_a), ty::ReFree(free_b)) => {\n+                ImpliedBound::RegionSubRegion(&ty::ReFree(free_a), &ty::ReFree(free_b)) => {\n                     self.relate_free_regions(free_a, free_b);\n                 }\n                 ImpliedBound::RegionSubRegion(..) |\n@@ -65,9 +65,9 @@ impl FreeRegionMap {\n                 }\n                 ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n                     match (r_a, r_b) {\n-                        (ty::ReStatic, ty::ReFree(_)) => {},\n-                        (ty::ReFree(fr_a), ty::ReStatic) => self.relate_to_static(fr_a),\n-                        (ty::ReFree(fr_a), ty::ReFree(fr_b)) => {\n+                        (&ty::ReStatic, &ty::ReFree(_)) => {},\n+                        (&ty::ReFree(fr_a), &ty::ReStatic) => self.relate_to_static(fr_a),\n+                        (&ty::ReFree(fr_a), &ty::ReFree(fr_b)) => {\n                             // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n                             self.relate_free_regions(fr_b, fr_a);\n                         }\n@@ -122,26 +122,26 @@ impl FreeRegionMap {\n     /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n     pub fn is_subregion_of(&self,\n                            tcx: TyCtxt,\n-                           sub_region: ty::Region,\n-                           super_region: ty::Region)\n+                           sub_region: &ty::Region,\n+                           super_region: &ty::Region)\n                            -> bool {\n         let result = sub_region == super_region || {\n             match (sub_region, super_region) {\n-                (ty::ReEmpty, _) |\n-                (_, ty::ReStatic) =>\n+                (&ty::ReEmpty, _) |\n+                (_, &ty::ReStatic) =>\n                     true,\n \n-                (ty::ReScope(sub_scope), ty::ReScope(super_scope)) =>\n+                (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n                     tcx.region_maps.is_subscope_of(sub_scope, super_scope),\n \n-                (ty::ReScope(sub_scope), ty::ReFree(fr)) =>\n+                (&ty::ReScope(sub_scope), &ty::ReFree(fr)) =>\n                     tcx.region_maps.is_subscope_of(sub_scope, fr.scope) ||\n                     self.is_static(fr),\n \n-                (ty::ReFree(sub_fr), ty::ReFree(super_fr)) =>\n+                (&ty::ReFree(sub_fr), &ty::ReFree(super_fr)) =>\n                     self.sub_free_region(sub_fr, super_fr),\n \n-                (ty::ReStatic, ty::ReFree(sup_fr)) =>\n+                (&ty::ReStatic, &ty::ReFree(sup_fr)) =>\n                     self.is_static(sup_fr),\n \n                 _ =>"}, {"sha": "a74bdb02044dee92127b18420480469de2b241d6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -90,11 +90,11 @@ use std::rc::Rc;\n \n #[derive(Clone, PartialEq)]\n pub enum Categorization<'tcx> {\n-    Rvalue(ty::Region),                    // temporary val, argument is its scope\n+    Rvalue(&'tcx ty::Region),                    // temporary val, argument is its scope\n     StaticItem,\n     Upvar(Upvar),                          // upvar referenced by closure env\n     Local(ast::NodeId),                    // local variable\n-    Deref(cmt<'tcx>, usize, PointerKind),  // deref of a ptr\n+    Deref(cmt<'tcx>, usize, PointerKind<'tcx>),  // deref of a ptr\n     Interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n     Downcast(cmt<'tcx>, DefId),            // selects a particular enum variant (*1)\n \n@@ -110,18 +110,18 @@ pub struct Upvar {\n \n // different kinds of pointers:\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum PointerKind {\n+pub enum PointerKind<'tcx> {\n     /// `Box<T>`\n     Unique,\n \n     /// `&T`\n-    BorrowedPtr(ty::BorrowKind, ty::Region),\n+    BorrowedPtr(ty::BorrowKind, &'tcx ty::Region),\n \n     /// `*T`\n     UnsafePtr(hir::Mutability),\n \n     /// Implicit deref of the `&T` that results from an overloaded index `[]`.\n-    Implicit(ty::BorrowKind, ty::Region),\n+    Implicit(ty::BorrowKind, &'tcx ty::Region),\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n@@ -198,8 +198,8 @@ pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n #[derive(Copy, Clone)]\n-pub enum deref_kind {\n-    deref_ptr(PointerKind),\n+pub enum deref_kind<'tcx> {\n+    deref_ptr(PointerKind<'tcx>),\n     deref_interior(InteriorKind),\n }\n \n@@ -216,7 +216,7 @@ fn deref_kind(t: Ty, context: DerefKindContext) -> McResult<deref_kind> {\n \n         ty::TyRef(r, mt) => {\n             let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n-            Ok(deref_ptr(BorrowedPtr(kind, *r)))\n+            Ok(deref_ptr(BorrowedPtr(kind, r)))\n         }\n \n         ty::TyRawPtr(ref mt) => {\n@@ -767,13 +767,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         };\n \n         // Region of environment pointer\n-        let env_region = ty::ReFree(ty::FreeRegion {\n+        let env_region = self.tcx().mk_region(ty::ReFree(ty::FreeRegion {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n             scope: self.tcx().region_maps.item_extent(fn_body_id),\n             bound_region: ty::BrEnv\n-        });\n+        }));\n \n         let env_ptr = BorrowedPtr(env_borrow_kind, env_region);\n \n@@ -817,11 +817,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n     /// Returns the lifetime of a temporary created by expr with id `id`.\n     /// This could be `'static` if `id` is part of a constant expression.\n-    pub fn temporary_scope(&self, id: ast::NodeId) -> ty::Region {\n-        match self.infcx.temporary_scope(id) {\n+    pub fn temporary_scope(&self, id: ast::NodeId) -> &'tcx ty::Region {\n+        self.tcx().mk_region(match self.infcx.temporary_scope(id) {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic\n-        }\n+        })\n     }\n \n     pub fn cat_rvalue_node(&self,\n@@ -845,7 +845,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let re = if qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n             self.temporary_scope(id)\n         } else {\n-            ty::ReStatic\n+            self.tcx().mk_region(ty::ReStatic)\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);\n@@ -855,7 +855,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn cat_rvalue(&self,\n                       cmt_id: ast::NodeId,\n                       span: Span,\n-                      temp_scope: ty::Region,\n+                      temp_scope: &'tcx ty::Region,\n                       expr_ty: Ty<'tcx>) -> cmt<'tcx> {\n         let ret = Rc::new(cmt_ {\n             id:cmt_id,\n@@ -1480,7 +1480,7 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     }\n }\n \n-impl fmt::Debug for PointerKind {\n+impl<'tcx> fmt::Debug for PointerKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             Unique => write!(f, \"Box\"),"}, {"sha": "ebe4050022153bee2cb2db306778f25eee1bd967", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -89,9 +89,12 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n \n #[derive(PartialEq, Debug)]\n enum ScopeChain<'a> {\n-    /// EarlyScope(['a, 'b, ...], s) extends s with early-bound\n-    /// lifetimes.\n-    EarlyScope(&'a [hir::LifetimeDef], Scope<'a>),\n+    /// EarlyScope(['a, 'b, ...], start, s) extends s with early-bound\n+    /// lifetimes, with consecutive parameter indices from `start`.\n+    /// That is, 'a has index `start`, 'b has index `start + 1`, etc.\n+    /// Indices before `start` correspond to other generic parameters\n+    /// of a parent item (trait/impl of a method), or `Self` in traits.\n+    EarlyScope(&'a [hir::LifetimeDef], u32, Scope<'a>),\n     /// LateScope(['a, 'b, ...], s) extends s with late-bound\n     /// lifetimes introduced by the declaration binder_id.\n     LateScope(&'a [hir::LifetimeDef], Scope<'a>),\n@@ -157,7 +160,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n                 hir::ItemImpl(_, _, ref generics, _, _, _) => {\n                     // These kinds of items have only early bound lifetime parameters.\n                     let lifetimes = &generics.lifetimes;\n-                    this.with(EarlyScope(lifetimes, &ROOT_SCOPE), |old_scope, this| {\n+                    let start = if let hir::ItemTrait(..) = item.node {\n+                        1 // Self comes before lifetimes\n+                    } else {\n+                        0\n+                    };\n+                    this.with(EarlyScope(lifetimes, start, &ROOT_SCOPE), |old_scope, this| {\n                         this.check_lifetime_defs(old_scope, lifetimes);\n                         intravisit::walk_item(this, item);\n                     });\n@@ -461,7 +469,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n                 FnScope { s, .. } => { scope = s; }\n                 RootScope => { return; }\n \n-                EarlyScope(lifetimes, s) |\n+                EarlyScope(lifetimes, _, s) |\n                 LateScope(lifetimes, s) => {\n                     for lifetime_def in lifetimes {\n                         // FIXME (#24278): non-hygienic comparison\n@@ -566,8 +574,24 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     .cloned()\n                     .partition(|l| self.map.late_bound.contains_key(&l.lifetime.id));\n \n+        // Find the start of nested early scopes, e.g. in methods.\n+        let mut start = 0;\n+        if let EarlyScope(..) = *self.scope {\n+            let parent = self.hir_map.expect_item(self.hir_map.get_parent(fn_id));\n+            if let hir::ItemTrait(..) = parent.node {\n+                start += 1; // Self comes first.\n+            }\n+            match parent.node {\n+                hir::ItemTrait(_, ref generics, _, _) |\n+                hir::ItemImpl(_, _, ref generics, _, _, _) => {\n+                    start += generics.lifetimes.len() + generics.ty_params.len();\n+                }\n+                _ => {}\n+            }\n+        }\n+\n         let this = self;\n-        this.with(EarlyScope(&early, this.scope), move |old_scope, this| {\n+        this.with(EarlyScope(&early, start as u32, this.scope), move |old_scope, this| {\n             this.with(LateScope(&late, this.scope), move |_, this| {\n                 this.check_lifetime_defs(old_scope, &generics.lifetimes);\n                 walk(this);\n@@ -597,19 +621,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break;\n                 }\n \n-                EarlyScope(lifetimes, s) => {\n+                EarlyScope(lifetimes, start, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((mut index, lifetime_def)) => {\n-                            // Adjust for nested early scopes, e.g. in methods.\n-                            let mut parent = s;\n-                            while let EarlyScope(lifetimes, s) = *parent {\n-                                index += lifetimes.len() as u32;\n-                                parent = s;\n-                            }\n-                            assert_eq!(*parent, RootScope);\n-\n+                        Some((index, lifetime_def)) => {\n                             let decl_id = lifetime_def.id;\n-                            let def = DefEarlyBoundRegion(index, decl_id);\n+                            let def = DefEarlyBoundRegion(start + index, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n@@ -671,7 +687,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break;\n                 }\n \n-                EarlyScope(lifetimes, s) |\n+                EarlyScope(lifetimes, _, s) |\n                 LateScope(lifetimes, s) => {\n                     search_result = search_lifetimes(lifetimes, lifetime_ref);\n                     if search_result.is_some() {\n@@ -767,7 +783,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     return;\n                 }\n \n-                EarlyScope(lifetimes, s) |\n+                EarlyScope(lifetimes, _, s) |\n                 LateScope(lifetimes, s) => {\n                     if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n                         signal_shadowing_problem("}, {"sha": "8145c0aae3f74cb344303a5084468f455897943c", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -911,7 +911,7 @@ pub enum Rvalue<'tcx> {\n     Repeat(Operand<'tcx>, TypedConstVal<'tcx>),\n \n     /// &x or &mut x\n-    Ref(Region, BorrowKind, Lvalue<'tcx>),\n+    Ref(&'tcx Region, BorrowKind, Lvalue<'tcx>),\n \n     /// length of a [X] or [X;n] value\n     Len(Lvalue<'tcx>),"}, {"sha": "76e5f8598c1c549c6da3843e7275d293aa9a1eae", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -145,8 +145,7 @@ impl<'tcx> Rvalue<'tcx> {\n             }\n             &Rvalue::Ref(reg, bk, ref lv) => {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n-                Some(tcx.mk_ref(\n-                    tcx.mk_region(reg),\n+                Some(tcx.mk_ref(reg,\n                     ty::TypeAndMut {\n                         ty: lv_ty,\n                         mutbl: bk.to_mutbl_lossy()"}, {"sha": "2771880735c27a71866ba304563c910d99fef0c0", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -757,7 +757,7 @@ make_mir_visitor!(Visitor,);\n make_mir_visitor!(MutVisitor,mut);\n \n #[derive(Copy, Clone, Debug)]\n-pub enum LvalueContext {\n+pub enum LvalueContext<'tcx> {\n     // Appears as LHS of an assignment\n     Store,\n \n@@ -771,7 +771,7 @@ pub enum LvalueContext {\n     Inspect,\n \n     // Being borrowed\n-    Borrow { region: Region, kind: BorrowKind },\n+    Borrow { region: &'tcx Region, kind: BorrowKind },\n \n     // Being sliced -- this should be same as being borrowed, probably\n     Slice { from_start: usize, from_end: usize },"}, {"sha": "10112e5084557c38f9098d15fa7cef8d0bce5f70", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -232,8 +232,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 if let Ok(..) = self.can_equate(&trait_self_ty, &impl_self_ty) {\n                     self_match_impls.push(def_id);\n \n-                    if trait_ref.substs.types[1..].iter()\n-                        .zip(&impl_trait_ref.substs.types[1..])\n+                    if trait_ref.substs.types().skip(1)\n+                        .zip(impl_trait_ref.substs.types().skip(1))\n                         .all(|(u,v)| self.fuzzy_match_tys(u, v))\n                     {\n                         fuzzy_match_impls.push(def_id);\n@@ -738,8 +738,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ty::Predicate::Trait(ref data) => {\n                 let trait_ref = data.to_poly_trait_ref();\n                 let self_ty = trait_ref.self_ty();\n-                let all_types = &trait_ref.substs().types;\n-                if all_types.references_error() {\n+                if predicate.references_error() {\n                 } else {\n                     // Typically, this ambiguity should only happen if\n                     // there are unresolved type inference variables"}, {"sha": "6598aacc1d3d2d2ee5adffc807bdf4eb772d4c28", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -93,7 +93,7 @@ pub struct FulfillmentContext<'tcx> {\n \n #[derive(Clone)]\n pub struct RegionObligation<'tcx> {\n-    pub sub_region: ty::Region,\n+    pub sub_region: &'tcx ty::Region,\n     pub sup_type: Ty<'tcx>,\n     pub cause: ObligationCause<'tcx>,\n }\n@@ -142,7 +142,7 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n         // Auto trait obligations on `impl Trait`.\n         if tcx.trait_has_default_impl(predicate.def_id()) {\n             let substs = predicate.skip_binder().trait_ref.substs;\n-            if substs.types.len() == 1 && substs.regions.is_empty() {\n+            if substs.types().count() == 1 && substs.regions().next().is_none() {\n                 if let ty::TyAnon(..) = predicate.skip_binder().self_ty().sty {\n                     return true;\n                 }\n@@ -162,7 +162,7 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n                 let concrete_ty = ty_scheme.ty.subst(tcx, substs);\n                 let predicate = ty::TraitRef {\n                     def_id: self.predicate.def_id(),\n-                    substs: Substs::new_trait(tcx, vec![], vec![], concrete_ty)\n+                    substs: Substs::new_trait(tcx, concrete_ty, &[])\n                 }.to_predicate();\n \n                 let original_obligation = Obligation::new(self.cause.clone(),\n@@ -246,7 +246,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n     pub fn register_region_obligation(&mut self,\n                                       t_a: Ty<'tcx>,\n-                                      r_b: ty::Region,\n+                                      r_b: &'tcx ty::Region,\n                                       cause: ObligationCause<'tcx>)\n     {\n         register_region_obligation(t_a, r_b, cause, &mut self.region_obligations);\n@@ -440,8 +440,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n {\n     t.skip_binder() // ok b/c this check doesn't care about regions\n      .input_types()\n-     .iter()\n-     .map(|t| selcx.infcx().resolve_type_vars_if_possible(t))\n+     .map(|t| selcx.infcx().resolve_type_vars_if_possible(&t))\n      .filter(|t| t.has_infer_types())\n      .flat_map(|t| t.walk())\n      .filter(|t| match t.sty { ty::TyInfer(_) => true, _ => false })\n@@ -581,7 +580,8 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                         // Otherwise, we have something of the form\n                         // `for<'a> T: 'a where 'a not in T`, which we can treat as `T: 'static`.\n                         Some(t_a) => {\n-                            register_region_obligation(t_a, ty::ReStatic,\n+                            let r_static = selcx.tcx().mk_region(ty::ReStatic);\n+                            register_region_obligation(t_a, r_static,\n                                                        obligation.cause.clone(),\n                                                        region_obligations);\n                             Ok(Some(vec![]))\n@@ -691,7 +691,7 @@ fn coinductive_obligation<'a,'gcx,'tcx>(selcx: &SelectionContext<'a,'gcx,'tcx>,\n }\n \n fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n-                                    r_b: ty::Region,\n+                                    r_b: &'tcx ty::Region,\n                                     cause: ObligationCause<'tcx>,\n                                     region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n {"}, {"sha": "219d5200467622f8df1f708531206ce12b33a815", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 match predicate {\n                     ty::Predicate::Trait(ref data) => {\n                         // In the case of a trait predicate, we can skip the \"self\" type.\n-                        data.0.trait_ref.input_types()[1..].iter().any(|t| t.has_self_ty())\n+                        data.skip_binder().input_types().skip(1).any(|t| t.has_self_ty())\n                     }\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::WellFormed(..) |"}, {"sha": "b015de79be5c690e632d723359960134b3212d6e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -36,7 +36,7 @@ use super::util;\n use hir::def_id::DefId;\n use infer;\n use infer::{InferCtxt, InferOk, TypeFreshener, TypeOrigin};\n-use ty::subst::{Subst, Substs};\n+use ty::subst::{Kind, Subst, Substs};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use traits;\n use ty::fast_reject;\n@@ -644,8 +644,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // This suffices to allow chains like `FnMut` implemented in\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n-        let input_types = stack.fresh_trait_ref.0.input_types();\n-        let unbound_input_types = input_types.iter().any(|ty| ty.is_fresh());\n+        let unbound_input_types = stack.fresh_trait_ref.input_types().any(|ty| ty.is_fresh());\n         if unbound_input_types && self.intercrate {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n                    stack.fresh_trait_ref);\n@@ -1064,9 +1063,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         match *candidate {\n             Ok(Some(_)) | Err(_) => true,\n-            Ok(None) => {\n-                cache_fresh_trait_pred.0.trait_ref.substs.types.has_infer_types()\n-            }\n+            Ok(None) => cache_fresh_trait_pred.has_infer_types()\n         }\n     }\n \n@@ -1250,7 +1247,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         obligation: &TraitObligation<'tcx>,\n                         trait_bound: ty::PolyTraitRef<'tcx>,\n                         skol_trait_ref: ty::TraitRef<'tcx>,\n-                        skol_map: &infer::SkolemizationMap,\n+                        skol_map: &infer::SkolemizationMap<'tcx>,\n                         snapshot: &infer::CombinedSnapshot)\n                         -> bool\n     {\n@@ -1603,7 +1600,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 return;\n             }\n         };\n-        let target = obligation.predicate.skip_binder().input_types()[1];\n+        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n \n         debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\",\n                source, target);\n@@ -1936,7 +1933,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             // for `PhantomData<T>`, we pass `T`\n             ty::TyStruct(def, substs) if def.is_phantom_data() => {\n-                substs.types.to_vec()\n+                substs.types().collect()\n             }\n \n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n@@ -1985,7 +1982,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                   trait_def_id,\n                                                   recursion_depth,\n                                                   normalized_ty,\n-                                                  vec![]);\n+                                                  &[]);\n                 obligations.push(skol_obligation);\n                 this.infcx().plug_leaks(skol_map, snapshot, &obligations)\n             })\n@@ -2180,12 +2177,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         match self_ty.sty {\n             ty::TyTrait(ref data) => {\n                 // OK to skip the binder, it is reintroduced below\n-                let input_types = data.principal.skip_binder().input_types();\n+                let input_types = data.principal.input_types();\n                 let assoc_types = data.projection_bounds.iter()\n                                       .map(|pb| pb.skip_binder().ty);\n-                let all_types: Vec<_> = input_types.iter().cloned()\n-                                                          .chain(assoc_types)\n-                                                          .collect();\n+                let all_types: Vec<_> = input_types.chain(assoc_types)\n+                                                   .collect();\n \n                 // reintroduce the two binding levels we skipped, then flatten into one\n                 let all_types = ty::Binder(ty::Binder(all_types));\n@@ -2267,7 +2263,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                    mut substs: Normalized<'tcx, &'tcx Substs<'tcx>>,\n                    cause: ObligationCause<'tcx>,\n                    recursion_depth: usize,\n-                   skol_map: infer::SkolemizationMap,\n+                   skol_map: infer::SkolemizationMap<'tcx>,\n                    snapshot: &infer::CombinedSnapshot)\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n@@ -2476,7 +2472,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // regions here. See the comment there for more details.\n         let source = self.infcx.shallow_resolve(\n             tcx.no_late_bound_regions(&obligation.self_ty()).unwrap());\n-        let target = obligation.predicate.skip_binder().input_types()[1];\n+        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n         let target = self.infcx.shallow_resolve(target);\n \n         debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\",\n@@ -2585,7 +2581,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 } else {\n                     return Err(Unimplemented);\n                 };\n-                let mut ty_params = BitVector::new(substs_a.types.len());\n+                let mut ty_params = BitVector::new(substs_a.types().count());\n                 let mut found = false;\n                 for ty in field.walk() {\n                     if let ty::TyParam(p) = ty.sty {\n@@ -2601,14 +2597,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // TyError and ensure they do not affect any other fields.\n                 // This could be checked after type collection for any struct\n                 // with a potentially unsized trailing field.\n-                let types = substs_a.types.iter().enumerate().map(|(i, ty)| {\n+                let params = substs_a.params().iter().enumerate().map(|(i, &k)| {\n                     if ty_params.contains(i) {\n-                        tcx.types.err\n+                        Kind::from(tcx.types.err)\n                     } else {\n-                        ty\n+                        k\n                     }\n-                }).collect();\n-                let substs = Substs::new(tcx, types, substs_a.regions.clone());\n+                });\n+                let substs = Substs::new(tcx, params);\n                 for &ty in fields.split_last().unwrap().1 {\n                     if ty.subst(tcx, substs).references_error() {\n                         return Err(Unimplemented);\n@@ -2621,15 +2617,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n                 // Check that the source structure with the target's\n                 // type parameters is a subtype of the target.\n-                let types = substs_a.types.iter().enumerate().map(|(i, ty)| {\n+                let params = substs_a.params().iter().enumerate().map(|(i, &k)| {\n                     if ty_params.contains(i) {\n-                        substs_b.types[i]\n+                        Kind::from(substs_b.type_at(i))\n                     } else {\n-                        ty\n+                        k\n                     }\n-                }).collect();\n-                let substs = Substs::new(tcx, types, substs_a.regions.clone());\n-                let new_struct = tcx.mk_struct(def, substs);\n+                });\n+                let new_struct = tcx.mk_struct(def, Substs::new(tcx, params));\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_struct, target)\n@@ -2642,7 +2637,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     obligation.predicate.def_id(),\n                     obligation.recursion_depth + 1,\n                     inner_source,\n-                    vec![inner_target]));\n+                    &[inner_target]));\n             }\n \n             _ => bug!()\n@@ -2665,7 +2660,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     impl_def_id: DefId,\n                     obligation: &TraitObligation<'tcx>,\n                     snapshot: &infer::CombinedSnapshot)\n-                    -> (Normalized<'tcx, &'tcx Substs<'tcx>>, infer::SkolemizationMap)\n+                    -> (Normalized<'tcx, &'tcx Substs<'tcx>>,\n+                        infer::SkolemizationMap<'tcx>)\n     {\n         match self.match_impl(impl_def_id, obligation, snapshot) {\n             Ok((substs, skol_map)) => (substs, skol_map),\n@@ -2682,7 +2678,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                   obligation: &TraitObligation<'tcx>,\n                   snapshot: &infer::CombinedSnapshot)\n                   -> Result<(Normalized<'tcx, &'tcx Substs<'tcx>>,\n-                             infer::SkolemizationMap), ()>\n+                             infer::SkolemizationMap<'tcx>), ()>\n     {\n         let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n \n@@ -2753,9 +2749,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // substitution if we find that any of the input types, when\n         // simplified, do not match.\n \n-        obligation.predicate.0.input_types().iter()\n+        obligation.predicate.skip_binder().input_types()\n             .zip(impl_trait_ref.input_types())\n-            .any(|(&obligation_ty, &impl_ty)| {\n+            .any(|(obligation_ty, impl_ty)| {\n                 let simplified_obligation_ty =\n                     fast_reject::simplify_type(self.tcx(), obligation_ty, true);\n                 let simplified_impl_ty =\n@@ -2875,7 +2871,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                  recursion_depth: usize,\n                                  def_id: DefId, // of impl or trait\n                                  substs: &Substs<'tcx>, // for impl or trait\n-                                 skol_map: infer::SkolemizationMap,\n+                                 skol_map: infer::SkolemizationMap<'tcx>,\n                                  snapshot: &infer::CombinedSnapshot)\n                                  -> Vec<PredicateObligation<'tcx>>\n     {"}, {"sha": "038de25312d35b631fb1f6fe41c4abb703d21246", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             Ok(def_id) => {\n                 Ok(ty::TraitRef {\n                     def_id: def_id,\n-                    substs: Substs::new_trait(self, vec![], vec![], param_ty)\n+                    substs: Substs::new_trait(self, param_ty, &[])\n                 })\n             }\n             Err(e) => {\n@@ -401,12 +401,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         trait_def_id: DefId,\n         recursion_depth: usize,\n         param_ty: Ty<'tcx>,\n-        ty_params: Vec<Ty<'tcx>>)\n+        ty_params: &[Ty<'tcx>])\n         -> PredicateObligation<'tcx>\n     {\n         let trait_ref = ty::TraitRef {\n             def_id: trait_def_id,\n-            substs: Substs::new_trait(self, ty_params, vec![], param_ty)\n+            substs: Substs::new_trait(self, param_ty, ty_params)\n         };\n         predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n     }\n@@ -496,7 +496,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n         let trait_ref = ty::TraitRef {\n             def_id: fn_trait_def_id,\n-            substs: Substs::new_trait(self, vec![arguments_tuple], vec![], self_ty),\n+            substs: Substs::new_trait(self, self_ty, &[arguments_tuple]),\n         };\n         ty::Binder((trait_ref, sig.0.output))\n     }"}, {"sha": "b1846e03941489cafc665f586ccb687d39a458d9", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -52,7 +52,8 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n         self.relate(a, b)\n     }\n \n-    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "e048e618e84d66951cd38467f3b9b0c0d2037f2c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -213,7 +213,7 @@ pub struct Tables<'tcx> {\n     pub method_map: ty::MethodMap<'tcx>,\n \n     /// Borrows\n-    pub upvar_capture_map: ty::UpvarCaptureMap,\n+    pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n@@ -1152,12 +1152,17 @@ fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n impl_interners!('tcx,\n     type_list: mk_type_list(Vec<Ty<'tcx>>, keep_local) -> [Ty<'tcx>],\n     substs: mk_substs(Substs<'tcx>, |substs: &Substs| {\n-        keep_local(&substs.types) || keep_local(&substs.regions)\n+        substs.params().iter().any(keep_local)\n     }) -> Substs<'tcx>,\n     bare_fn: mk_bare_fn(BareFnTy<'tcx>, |fty: &BareFnTy| {\n         keep_local(&fty.sig)\n     }) -> BareFnTy<'tcx>,\n-    region: mk_region(Region, keep_local) -> Region\n+    region: mk_region(Region, |r| {\n+        match r {\n+            &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n+            _ => false\n+        }\n+    }) -> Region\n );\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "3d60d326b2b0f640f477f4436a60a6b50cf18ea0", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -41,11 +41,11 @@ pub enum TypeError<'tcx> {\n     FixedArraySize(ExpectedFound<usize>),\n     TyParamSize(ExpectedFound<usize>),\n     ArgCount,\n-    RegionsDoesNotOutlive(Region, Region),\n-    RegionsNotSame(Region, Region),\n-    RegionsNoOverlap(Region, Region),\n-    RegionsInsufficientlyPolymorphic(BoundRegion, Region),\n-    RegionsOverlyPolymorphic(BoundRegion, Region),\n+    RegionsDoesNotOutlive(&'tcx Region, &'tcx Region),\n+    RegionsNotSame(&'tcx Region, &'tcx Region),\n+    RegionsNoOverlap(&'tcx Region, &'tcx Region),\n+    RegionsInsufficientlyPolymorphic(BoundRegion, &'tcx Region),\n+    RegionsOverlyPolymorphic(BoundRegion, &'tcx Region),\n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntegerAsChar,\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n@@ -296,7 +296,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 self.note_and_explain_region(db, \"concrete lifetime that was found is \",\n                                            conc_region, \"\");\n             }\n-            RegionsOverlyPolymorphic(_, ty::ReVar(_)) => {\n+            RegionsOverlyPolymorphic(_, &ty::ReVar(_)) => {\n                 // don't bother to print out the message below for\n                 // inference variables, it's not very illuminating.\n             }"}, {"sha": "1afd49ab47fbfeb686252bb807173bac5fc2a248", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -137,7 +137,7 @@ impl FlagComputation {\n             }\n \n             &ty::TyRef(r, ref m) => {\n-                self.add_region(*r);\n+                self.add_region(r);\n                 self.add_ty(m.ty);\n             }\n \n@@ -176,8 +176,8 @@ impl FlagComputation {\n         self.add_bound_computation(&computation);\n     }\n \n-    fn add_region(&mut self, r: ty::Region) {\n-        match r {\n+    fn add_region(&mut self, r: &ty::Region) {\n+        match *r {\n             ty::ReVar(..) => {\n                 self.add_flags(TypeFlags::HAS_RE_INFER);\n                 self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX);\n@@ -208,8 +208,11 @@ impl FlagComputation {\n     }\n \n     fn add_substs(&mut self, substs: &Substs) {\n-        self.add_tys(&substs.types);\n-        for &r in &substs.regions {\n+        for ty in substs.types() {\n+            self.add_ty(ty);\n+        }\n+\n+        for r in substs.regions() {\n             self.add_region(r);\n         }\n     }"}, {"sha": "2c18d1d52547f2acd0e0fb10ce6330c51c7f320f", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -169,7 +169,7 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         fty.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n         r.super_fold_with(self)\n     }\n \n@@ -188,7 +188,7 @@ pub trait TypeVisitor<'tcx> : Sized {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region) -> bool {\n+    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n         r.super_visit_with(self)\n     }\n }\n@@ -222,13 +222,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// whether any late-bound regions were skipped\n     pub fn collect_regions<T>(self,\n         value: &T,\n-        region_set: &mut FnvHashSet<ty::Region>)\n+        region_set: &mut FnvHashSet<&'tcx ty::Region>)\n         -> bool\n         where T : TypeFoldable<'tcx>\n     {\n         let mut have_bound_regions = false;\n-        self.fold_regions(value, &mut have_bound_regions,\n-                          |r, d| { region_set.insert(r.from_depth(d)); r });\n+        self.fold_regions(value, &mut have_bound_regions, |r, d| {\n+            region_set.insert(self.mk_region(r.from_depth(d)));\n+            r\n+        });\n         have_bound_regions\n     }\n \n@@ -240,7 +242,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         skipped_regions: &mut bool,\n         mut f: F)\n         -> T\n-        where F : FnMut(ty::Region, u32) -> ty::Region,\n+        where F : FnMut(&'tcx ty::Region, u32) -> &'tcx ty::Region,\n               T : TypeFoldable<'tcx>,\n     {\n         value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f))\n@@ -260,14 +262,14 @@ pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     skipped_regions: &'a mut bool,\n     current_depth: u32,\n-    fld_r: &'a mut (FnMut(ty::Region, u32) -> ty::Region + 'a),\n+    fld_r: &'a mut (FnMut(&'tcx ty::Region, u32) -> &'tcx ty::Region + 'a),\n }\n \n impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n     pub fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   skipped_regions: &'a mut bool,\n                   fld_r: &'a mut F) -> RegionFolder<'a, 'gcx, 'tcx>\n-        where F : FnMut(ty::Region, u32) -> ty::Region\n+        where F : FnMut(&'tcx ty::Region, u32) -> &'tcx ty::Region\n     {\n         RegionFolder {\n             tcx: tcx,\n@@ -288,8 +290,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match r {\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n             ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n                 debug!(\"RegionFolder.fold_region({:?}) skipped bound region (current depth={})\",\n                        r, self.current_depth);\n@@ -313,16 +315,16 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n-    fld_r: &'a mut (FnMut(ty::BoundRegion) -> ty::Region + 'a),\n-    map: FnvHashMap<ty::BoundRegion, ty::Region>\n+    fld_r: &'a mut (FnMut(ty::BoundRegion) -> &'tcx ty::Region + 'a),\n+    map: FnvHashMap<ty::BoundRegion, &'tcx ty::Region>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n-        -> (T, FnvHashMap<ty::BoundRegion, ty::Region>)\n-        where F : FnMut(ty::BoundRegion) -> ty::Region,\n+        -> (T, FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+        where F : FnMut(ty::BoundRegion) -> &'tcx ty::Region,\n               T : TypeFoldable<'tcx>,\n     {\n         let mut replacer = RegionReplacer::new(self, &mut f);\n@@ -340,7 +342,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         where T : TypeFoldable<'tcx>\n     {\n         self.replace_late_bound_regions(value, |br| {\n-            ty::ReFree(ty::FreeRegion{scope: all_outlive_scope, bound_region: br})\n+            self.mk_region(ty::ReFree(ty::FreeRegion {\n+                scope: all_outlive_scope,\n+                bound_region: br\n+            }))\n         }).0\n     }\n \n@@ -353,11 +358,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let bound0_value = bound2_value.skip_binder().skip_binder();\n         let value = self.fold_regions(bound0_value, &mut false,\n                                       |region, current_depth| {\n-            match region {\n+            match *region {\n                 ty::ReLateBound(debruijn, br) if debruijn.depth >= current_depth => {\n                     // should be true if no escaping regions from bound2_value\n                     assert!(debruijn.depth - current_depth <= 1);\n-                    ty::ReLateBound(ty::DebruijnIndex::new(current_depth), br)\n+                    self.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(current_depth), br))\n                 }\n                 _ => {\n                     region\n@@ -411,7 +416,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn erase_late_bound_regions<T>(self, value: &Binder<T>) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        self.replace_late_bound_regions(value, |_| ty::ReErased).0\n+        self.replace_late_bound_regions(value, |_| self.mk_region(ty::ReErased)).0\n     }\n \n     /// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n@@ -428,15 +433,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let mut counter = 0;\n         Binder(self.replace_late_bound_regions(sig, |_| {\n             counter += 1;\n-            ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(counter))\n+            self.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(counter)))\n         }).0)\n     }\n }\n \n impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n     fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>, fld_r: &'a mut F)\n               -> RegionReplacer<'a, 'gcx, 'tcx>\n-        where F : FnMut(ty::BoundRegion) -> ty::Region\n+        where F : FnMut(ty::BoundRegion) -> &'tcx ty::Region\n     {\n         RegionReplacer {\n             tcx: tcx,\n@@ -465,22 +470,22 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n         t.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match r {\n+    fn fold_region(&mut self, r:&'tcx  ty::Region) -> &'tcx ty::Region {\n+        match *r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n                 let fld_r = &mut self.fld_r;\n                 let region = *self.map.entry(br).or_insert_with(|| fld_r(br));\n-                if let ty::ReLateBound(debruijn1, br) = region {\n+                if let ty::ReLateBound(debruijn1, br) = *region {\n                     // If the callback returns a late-bound region,\n                     // that region should always use depth 1. Then we\n                     // adjust it to the correct depth.\n                     assert_eq!(debruijn1.depth, 1);\n-                    ty::ReLateBound(debruijn, br)\n+                    self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n                 } else {\n                     region\n                 }\n             }\n-            r => r\n+            _ => r\n         }\n     }\n }\n@@ -528,7 +533,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 u.super_fold_with(self)\n             }\n \n-            fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+            fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n                 // because late-bound regions affect subtyping, we can't\n                 // erase the bound/free distinction, but we can replace\n                 // all free regions with 'erased.\n@@ -537,9 +542,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // type system never \"sees\" those, they get substituted\n                 // away. In trans, they will always be erased to 'erased\n                 // whenever a substitution occurs.\n-                match r {\n+                match *r {\n                     ty::ReLateBound(..) => r,\n-                    _ => ty::ReErased\n+                    _ => self.tcx().mk_region(ty::ReErased)\n                 }\n             }\n         }\n@@ -574,7 +579,7 @@ pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            value, amount);\n \n     value.fold_with(&mut RegionFolder::new(tcx, &mut false, &mut |region, _current_depth| {\n-        shift_region(region, amount)\n+        tcx.mk_region(shift_region(*region, amount))\n     }))\n }\n \n@@ -616,7 +621,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingRegionsVisitor {\n         t.region_depth > self.depth\n     }\n \n-    fn visit_region(&mut self, r: ty::Region) -> bool {\n+    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n         r.escapes_depth(self.depth)\n     }\n }\n@@ -630,17 +635,18 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         t.flags.get().intersects(self.flags)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region) -> bool {\n+    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n         if self.flags.intersects(ty::TypeFlags::HAS_LOCAL_NAMES) {\n             // does this represent a region that cannot be named\n             // in a global way? used in fulfillment caching.\n-            match r {\n+            match *r {\n                 ty::ReStatic | ty::ReEmpty | ty::ReErased => {}\n                 _ => return true,\n             }\n         }\n-        if self.flags.intersects(ty::TypeFlags::HAS_RE_INFER) {\n-            match r {\n+        if self.flags.intersects(ty::TypeFlags::HAS_RE_INFER |\n+                                 ty::TypeFlags::KEEP_IN_LOCAL_TCX) {\n+            match *r {\n                 ty::ReVar(_) | ty::ReSkolemized(..) => { return true }\n                 _ => {}\n             }\n@@ -688,8 +694,8 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region) -> bool {\n-        match r {\n+    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+        match *r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n                 self.regions.insert(br);\n             }"}, {"sha": "62bd30e2555921b029f69df921ac07254320ff24", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self_ty.sty {\n             ty::TyStruct(adt_def, substs) |\n             ty::TyEnum(adt_def, substs) => {\n-                if substs.types.is_empty() { // ignore regions\n+                if substs.types().next().is_none() { // ignore regions\n                     self.push_item_path(buffer, adt_def.did);\n                 } else {\n                     buffer.push(&format!(\"<{}>\", self_ty));"}, {"sha": "0e8bea86178f3097bc4021d656c592d6659a3e57", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -38,7 +38,7 @@ dep_map_ty! { TraitItemDefIds: TraitItemDefIds(DefId) -> Rc<Vec<ty::ImplOrTraitI\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n-dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<ty::ItemVariances> }\n+dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplItems: ImplItems(DefId) -> Vec<ty::ImplOrTraitItemId> }\n dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }"}, {"sha": "759dc30037210166b0729595a1123786a68e2b21", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -343,7 +343,7 @@ pub struct Method<'tcx> {\n     pub generics: &'tcx Generics<'tcx>,\n     pub predicates: GenericPredicates<'tcx>,\n     pub fty: &'tcx BareFnTy<'tcx>,\n-    pub explicit_self: ExplicitSelfCategory,\n+    pub explicit_self: ExplicitSelfCategory<'tcx>,\n     pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n@@ -355,7 +355,7 @@ impl<'tcx> Method<'tcx> {\n                generics: &'tcx ty::Generics<'tcx>,\n                predicates: GenericPredicates<'tcx>,\n                fty: &'tcx BareFnTy<'tcx>,\n-               explicit_self: ExplicitSelfCategory,\n+               explicit_self: ExplicitSelfCategory<'tcx>,\n                vis: Visibility,\n                defaultness: hir::Defaultness,\n                def_id: DefId,\n@@ -417,21 +417,6 @@ pub struct AssociatedType<'tcx> {\n     pub container: ImplOrTraitItemContainer,\n }\n \n-#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n-pub struct ItemVariances {\n-    pub types: Vec<Variance>,\n-    pub regions: Vec<Variance>,\n-}\n-\n-impl ItemVariances {\n-    pub fn empty() -> ItemVariances {\n-        ItemVariances {\n-            types: vec![],\n-            regions: vec![],\n-        }\n-    }\n-}\n-\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Copy)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n@@ -658,28 +643,28 @@ pub enum BorrowKind {\n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n #[derive(PartialEq, Clone, Debug, Copy)]\n-pub enum UpvarCapture {\n+pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n     /// depending on inference.\n     ByValue,\n \n     /// Upvar is captured by reference.\n-    ByRef(UpvarBorrow),\n+    ByRef(UpvarBorrow<'tcx>),\n }\n \n #[derive(PartialEq, Clone, Copy)]\n-pub struct UpvarBorrow {\n+pub struct UpvarBorrow<'tcx> {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n     /// syntax.\n     pub kind: BorrowKind,\n \n     /// Region of the resulting reference.\n-    pub region: ty::Region,\n+    pub region: &'tcx ty::Region,\n }\n \n-pub type UpvarCaptureMap = FnvHashMap<UpvarId, UpvarCapture>;\n+pub type UpvarCaptureMap<'tcx> = FnvHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n #[derive(Copy, Clone)]\n pub struct ClosureUpvar<'tcx> {\n@@ -700,7 +685,7 @@ pub enum IntVarValue {\n /// this is `None`, then the default is inherited from the\n /// surrounding context. See RFC #599 for details.\n #[derive(Copy, Clone)]\n-pub enum ObjectLifetimeDefault {\n+pub enum ObjectLifetimeDefault<'tcx> {\n     /// Require an explicit annotation. Occurs when multiple\n     /// `T:'a` constraints are found.\n     Ambiguous,\n@@ -709,7 +694,7 @@ pub enum ObjectLifetimeDefault {\n     BaseDefault,\n \n     /// Use the given region as the default.\n-    Specific(Region),\n+    Specific(&'tcx Region),\n }\n \n #[derive(Clone)]\n@@ -719,18 +704,18 @@ pub struct TypeParameterDef<'tcx> {\n     pub index: u32,\n     pub default_def_id: DefId, // for use in error reporing about defaults\n     pub default: Option<Ty<'tcx>>,\n-    pub object_lifetime_default: ObjectLifetimeDefault,\n+    pub object_lifetime_default: ObjectLifetimeDefault<'tcx>,\n }\n \n #[derive(Clone)]\n-pub struct RegionParameterDef {\n+pub struct RegionParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n     pub index: u32,\n-    pub bounds: Vec<ty::Region>,\n+    pub bounds: Vec<&'tcx ty::Region>,\n }\n \n-impl RegionParameterDef {\n+impl<'tcx> RegionParameterDef<'tcx> {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: self.index,\n@@ -750,11 +735,25 @@ pub struct Generics<'tcx> {\n     pub parent: Option<DefId>,\n     pub parent_regions: u32,\n     pub parent_types: u32,\n-    pub regions: Vec<RegionParameterDef>,\n+    pub regions: Vec<RegionParameterDef<'tcx>>,\n     pub types: Vec<TypeParameterDef<'tcx>>,\n     pub has_self: bool,\n }\n \n+impl<'tcx> Generics<'tcx> {\n+    pub fn parent_count(&self) -> usize {\n+        self.parent_regions as usize + self.parent_types as usize\n+    }\n+\n+    pub fn own_count(&self) -> usize {\n+        self.regions.len() + self.types.len()\n+    }\n+\n+    pub fn count(&self) -> usize {\n+        self.parent_count() + self.own_count()\n+    }\n+}\n+\n /// Bounds on generics.\n #[derive(Clone)]\n pub struct GenericPredicates<'tcx> {\n@@ -812,7 +811,7 @@ pub enum Predicate<'tcx> {\n     Equate(PolyEquatePredicate<'tcx>),\n \n     /// where 'a : 'b\n-    RegionOutlives(PolyRegionOutlivesPredicate),\n+    RegionOutlives(PolyRegionOutlivesPredicate<'tcx>),\n \n     /// where T : 'a\n     TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n@@ -951,7 +950,6 @@ impl<'tcx> TraitPredicate<'tcx> {\n         // leads to more recompilation.\n         let def_ids: Vec<_> =\n             self.input_types()\n-                .iter()\n                 .flat_map(|t| t.walk())\n                 .filter_map(|t| match t.sty {\n                     ty::TyStruct(adt_def, _) |\n@@ -964,8 +962,8 @@ impl<'tcx> TraitPredicate<'tcx> {\n         DepNode::TraitSelect(self.def_id(), def_ids)\n     }\n \n-    pub fn input_types(&self) -> &[Ty<'tcx>] {\n-        &self.trait_ref.substs.types\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+        self.trait_ref.input_types()\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n@@ -992,8 +990,9 @@ pub type PolyEquatePredicate<'tcx> = ty::Binder<EquatePredicate<'tcx>>;\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n-pub type PolyRegionOutlivesPredicate = PolyOutlivesPredicate<ty::Region, ty::Region>;\n-pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::Region>;\n+pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<&'tcx ty::Region,\n+                                                                   &'tcx ty::Region>;\n+pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, &'tcx ty::Region>;\n \n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n@@ -1082,7 +1081,7 @@ impl<'tcx> ToPredicate<'tcx> for PolyEquatePredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate {\n+impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n         Predicate::RegionOutlives(self.clone())\n     }\n@@ -1107,7 +1106,7 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn walk_tys(&self) -> IntoIter<Ty<'tcx>> {\n         let vec: Vec<_> = match *self {\n             ty::Predicate::Trait(ref data) => {\n-                data.0.trait_ref.input_types().to_vec()\n+                data.skip_binder().input_types().collect()\n             }\n             ty::Predicate::Rfc1592(ref data) => {\n                 return data.walk_tys()\n@@ -1123,10 +1122,7 @@ impl<'tcx> Predicate<'tcx> {\n             }\n             ty::Predicate::Projection(ref data) => {\n                 let trait_inputs = data.0.projection_ty.trait_ref.input_types();\n-                trait_inputs.iter()\n-                            .cloned()\n-                            .chain(Some(data.0.ty))\n-                            .collect()\n+                trait_inputs.chain(Some(data.0.ty)).collect()\n             }\n             ty::Predicate::WellFormed(data) => {\n                 vec![data]\n@@ -1206,15 +1202,15 @@ impl<'tcx> TraitRef<'tcx> {\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n-        self.substs.types[0]\n+        self.substs.type_at(0)\n     }\n \n-    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n         // associated types.\n-        &self.substs.types\n+        self.substs.types()\n     }\n }\n \n@@ -1239,7 +1235,7 @@ pub struct ParameterEnvironment<'tcx> {\n     /// indicates it must outlive at least the function body (the user\n     /// may specify stronger requirements). This field indicates the\n     /// region of the callee.\n-    pub implicit_region_bound: ty::Region,\n+    pub implicit_region_bound: &'tcx ty::Region,\n \n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n@@ -1866,7 +1862,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                 };\n                 let sized_predicate = Binder(TraitRef {\n                     def_id: sized_trait,\n-                    substs: Substs::new_trait(tcx, vec![], vec![], ty)\n+                    substs: Substs::new_trait(tcx, ty, &[])\n                 }).to_predicate();\n                 let predicates = tcx.lookup_predicates(self.did).predicates;\n                 if predicates.into_iter().any(|p| p == sized_predicate) {\n@@ -2593,7 +2589,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             || self.lookup_repr_hints(did).contains(&attr::ReprSimd)\n     }\n \n-    pub fn item_variances(self, item_id: DefId) -> Rc<ItemVariances> {\n+    pub fn item_variances(self, item_id: DefId) -> Rc<Vec<ty::Variance>> {\n         lookup_locally_or_in_crate_store(\n             \"item_variance_map\", item_id, &self.item_variance_map,\n             || Rc::new(self.sess.cstore.item_variances(item_id)))\n@@ -2827,7 +2823,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         ty::ParameterEnvironment {\n             free_substs: Substs::empty(self),\n             caller_bounds: Vec::new(),\n-            implicit_region_bound: ty::ReEmpty,\n+            implicit_region_bound: self.mk_region(ty::ReEmpty),\n             free_id_outlive: free_id_outlive\n         }\n     }\n@@ -2843,8 +2839,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let substs = Substs::for_item(self.global_tcx(), def_id, |def, _| {\n             // map bound 'a => free 'a\n-            ReFree(FreeRegion { scope: free_id_outlive,\n-                                bound_region: def.to_bound_region() })\n+            self.global_tcx().mk_region(ReFree(FreeRegion {\n+                scope: free_id_outlive,\n+                bound_region: def.to_bound_region()\n+            }))\n         }, |def, _| {\n             // map T => T\n             self.global_tcx().mk_param_from_def(def)\n@@ -2894,7 +2892,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let unnormalized_env = ty::ParameterEnvironment {\n             free_substs: free_substs,\n-            implicit_region_bound: ty::ReScope(free_id_outlive),\n+            implicit_region_bound: tcx.mk_region(ty::ReScope(free_id_outlive)),\n             caller_bounds: predicates,\n             free_id_outlive: free_id_outlive,\n         };\n@@ -2903,6 +2901,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         traits::normalize_param_env_or_error(tcx, unnormalized_env, cause)\n     }\n \n+    pub fn node_scope_region(self, id: NodeId) -> &'tcx Region {\n+        self.mk_region(ty::ReScope(self.region_maps.node_extent(id)))\n+    }\n+\n     pub fn is_method_call(self, expr_id: NodeId) -> bool {\n         self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n     }\n@@ -2912,7 +2914,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                                                             autoderefs))\n     }\n \n-    pub fn upvar_capture(self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+    pub fn upvar_capture(self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n         Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n \n@@ -2938,10 +2940,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n /// The category of explicit self.\n #[derive(Clone, Copy, Eq, PartialEq, Debug)]\n-pub enum ExplicitSelfCategory {\n+pub enum ExplicitSelfCategory<'tcx> {\n     Static,\n     ByValue,\n-    ByReference(Region, hir::Mutability),\n+    ByReference(&'tcx Region, hir::Mutability),\n     ByBox,\n }\n "}, {"sha": "4d5b38212f600ee43c18bb29500b01c52dfa5853", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -17,7 +17,7 @@ use ty::{self, Ty, TypeFoldable};\n \n #[derive(Debug)]\n pub enum Component<'tcx> {\n-    Region(ty::Region),\n+    Region(&'tcx ty::Region),\n     Param(ty::ParamTy),\n     UnresolvedInferenceVariable(ty::InferTy),\n \n@@ -210,7 +210,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region>) {\n+fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<&'tcx ty::Region>) {\n     for r in regions {\n         if !r.is_bound() {\n             out.push(Component::Region(r));"}, {"sha": "5c157ff32e7bbb846bd256f6b98c9c3315a07b61", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -14,7 +14,7 @@\n //! type equality, etc.\n \n use hir::def_id::DefId;\n-use ty::subst::Substs;\n+use ty::subst::{Kind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::error::{ExpectedFound, TypeError};\n use std::rc::Rc;\n@@ -71,8 +71,8 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>)\n            -> RelateResult<'tcx, Ty<'tcx>>;\n \n-    fn regions(&mut self, a: ty::Region, b: ty::Region)\n-               -> RelateResult<'tcx, ty::Region>;\n+    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region>;\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n@@ -139,27 +139,26 @@ fn relate_item_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n }\n \n pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                        variances: Option<&ty::ItemVariances>,\n+                                        variances: Option<&Vec<ty::Variance>>,\n                                         a_subst: &'tcx Substs<'tcx>,\n                                         b_subst: &'tcx Substs<'tcx>)\n                                         -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n     where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let tcx = relation.tcx();\n \n-    let types = a_subst.types.iter().enumerate().map(|(i, a_ty)| {\n-        let b_ty = &b_subst.types[i];\n-        let variance = variances.map_or(ty::Invariant, |v| v.types[i]);\n-        relation.relate_with_variance(variance, a_ty, b_ty)\n-    }).collect::<Result<_, _>>()?;\n-\n-    let regions = a_subst.regions.iter().enumerate().map(|(i, a_r)| {\n-        let b_r = &b_subst.regions[i];\n-        let variance = variances.map_or(ty::Invariant, |v| v.regions[i]);\n-        relation.relate_with_variance(variance, a_r, b_r)\n-    }).collect::<Result<_, _>>()?;\n+    let params = a_subst.params().iter().zip(b_subst.params()).enumerate().map(|(i, (a, b))| {\n+        let variance = variances.map_or(ty::Invariant, |v| v[i]);\n+        if let (Some(a_ty), Some(b_ty)) = (a.as_type(), b.as_type()) {\n+            Ok(Kind::from(relation.relate_with_variance(variance, &a_ty, &b_ty)?))\n+        } else if let (Some(a_r), Some(b_r)) = (a.as_region(), b.as_region()) {\n+            Ok(Kind::from(relation.relate_with_variance(variance, &a_r, &b_r)?))\n+        } else {\n+            bug!()\n+        }\n+    });\n \n-    Ok(Substs::new(tcx, types, regions))\n+    Substs::maybe_new(tcx, params)\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::BareFnTy<'tcx> {\n@@ -473,9 +472,9 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n \n         (&ty::TyRef(a_r, ref a_mt), &ty::TyRef(b_r, ref b_mt)) =>\n         {\n-            let r = relation.relate_with_variance(ty::Contravariant, a_r, b_r)?;\n+            let r = relation.relate_with_variance(ty::Contravariant, &a_r, &b_r)?;\n             let mt = relation.relate(a_mt, b_mt)?;\n-            Ok(tcx.mk_ref(tcx.mk_region(r), mt))\n+            Ok(tcx.mk_ref(r, mt))\n         }\n \n         (&ty::TyArray(a_t, sz_a), &ty::TyArray(b_t, sz_b)) =>\n@@ -571,11 +570,11 @@ impl<'tcx> Relate<'tcx> for &'tcx Substs<'tcx> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for ty::Region {\n+impl<'tcx> Relate<'tcx> for &'tcx ty::Region {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::Region,\n-                           b: &ty::Region)\n-                           -> RelateResult<'tcx, ty::Region>\n+                           a: &&'tcx ty::Region,\n+                           b: &&'tcx ty::Region)\n+                           -> RelateResult<'tcx, &'tcx ty::Region>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.regions(*a, *b)"}, {"sha": "705cca056f24c0d9bf5d7095e2546325b477f7d1", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 16, "deletions": 51, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use infer::type_variable;\n-use ty::subst::Substs;\n use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n@@ -73,13 +72,6 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n     }\n }\n \n-impl<'tcx> Lift<'tcx> for ty::Region {\n-    type Lifted = Self;\n-    fn lift_to_tcx(&self, _: TyCtxt) -> Option<ty::Region> {\n-        Some(*self)\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n     type Lifted = ty::TraitRef<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -316,13 +308,21 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             FixedArraySize(x) => FixedArraySize(x),\n             TyParamSize(x) => TyParamSize(x),\n             ArgCount => ArgCount,\n-            RegionsDoesNotOutlive(a, b) => RegionsDoesNotOutlive(a, b),\n-            RegionsNotSame(a, b) => RegionsNotSame(a, b),\n-            RegionsNoOverlap(a, b) => RegionsNoOverlap(a, b),\n+            RegionsDoesNotOutlive(a, b) => {\n+                return tcx.lift(&(a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b))\n+            }\n+            RegionsNotSame(a, b) => {\n+                return tcx.lift(&(a, b)).map(|(a, b)| RegionsNotSame(a, b))\n+            }\n+            RegionsNoOverlap(a, b) => {\n+                return tcx.lift(&(a, b)).map(|(a, b)| RegionsNoOverlap(a, b))\n+            }\n             RegionsInsufficientlyPolymorphic(a, b) => {\n-                RegionsInsufficientlyPolymorphic(a, b)\n+                return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b))\n+            }\n+            RegionsOverlyPolymorphic(a, b) => {\n+                return tcx.lift(&b).map(|b| RegionsOverlyPolymorphic(a, b))\n             }\n-            RegionsOverlyPolymorphic(a, b) => RegionsOverlyPolymorphic(a, b),\n             IntegerAsChar => IntegerAsChar,\n             IntMismatch(x) => IntMismatch(x),\n             FloatMismatch(x) => FloatMismatch(x),\n@@ -655,7 +655,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n         *self\n     }\n@@ -673,41 +673,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n-        *self\n-    }\n-\n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let region = folder.fold_region(**self);\n-        folder.tcx().mk_region(region)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        false\n-    }\n-\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        visitor.visit_region(**self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let types = self.types.fold_with(folder);\n-        let regions = self.regions.fold_with(folder);\n-        Substs::new(folder.tcx(), types, regions)\n-    }\n-\n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_substs(self)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.types.visit_with(visitor) || self.regions.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ClosureSubsts {\n@@ -783,7 +748,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             ty::ObjectLifetimeDefault::Ambiguous =>\n@@ -805,7 +770,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n+impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::RegionParameterDef {\n             name: self.name,"}, {"sha": "0e3f18c4474eaed1b91788ee56b3c298eb38f7aa", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -19,8 +19,8 @@ use util::common::ErrorReported;\n \n use collections::enum_set::{self, EnumSet, CLike};\n use std::fmt;\n-use std::ops;\n use std::mem;\n+use std::ops;\n use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::parse::token::keywords;\n@@ -293,7 +293,7 @@ impl<'tcx> Decodable for ClosureSubsts<'tcx> {\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct TraitObject<'tcx> {\n     pub principal: PolyExistentialTraitRef<'tcx>,\n-    pub region_bound: ty::Region,\n+    pub region_bound: &'tcx ty::Region,\n     pub builtin_bounds: BuiltinBounds,\n     pub projection_bounds: Vec<PolyExistentialProjection<'tcx>>,\n }\n@@ -335,7 +335,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n         self.0.substs\n     }\n \n-    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n         self.0.input_types()\n     }\n@@ -360,12 +360,12 @@ pub struct ExistentialTraitRef<'tcx> {\n }\n \n impl<'tcx> ExistentialTraitRef<'tcx> {\n-    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n         // associated types.\n-        &self.substs.types\n+        self.substs.types()\n     }\n }\n \n@@ -376,7 +376,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n         self.0.def_id\n     }\n \n-    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n         self.0.input_types()\n     }\n@@ -675,6 +675,15 @@ pub enum Region {\n     ReErased,\n }\n \n+impl<'tcx> Decodable for &'tcx Region {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<&'tcx Region, D::Error> {\n+        let r = Decodable::decode(d)?;\n+        cstore::tls::with_decoding_context(d, |dcx, _| {\n+            Ok(dcx.tcx().mk_region(r))\n+        })\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n     pub index: u32,\n@@ -1206,26 +1215,26 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Returns the regions directly referenced from this type (but\n     /// not types reachable from this type via `walk_tys`). This\n     /// ignores late-bound regions binders.\n-    pub fn regions(&self) -> Vec<ty::Region> {\n+    pub fn regions(&self) -> Vec<&'tcx ty::Region> {\n         match self.sty {\n             TyRef(region, _) => {\n-                vec![*region]\n+                vec![region]\n             }\n             TyTrait(ref obj) => {\n                 let mut v = vec![obj.region_bound];\n-                v.extend_from_slice(&obj.principal.skip_binder().substs.regions);\n+                v.extend(obj.principal.skip_binder().substs.regions());\n                 v\n             }\n             TyEnum(_, substs) |\n             TyStruct(_, substs) |\n             TyAnon(_, substs) => {\n-                substs.regions.to_vec()\n+                substs.regions().collect()\n             }\n             TyClosure(_, ref substs) => {\n-                substs.func_substs.regions.to_vec()\n+                substs.func_substs.regions().collect()\n             }\n             TyProjection(ref data) => {\n-                data.trait_ref.substs.regions.to_vec()\n+                data.trait_ref.substs.regions().collect()\n             }\n             TyFnDef(..) |\n             TyFnPtr(_) |"}, {"sha": "0ccfea23309999d96d3fdbfa03151764824aa90a", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 227, "deletions": 59, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -13,41 +13,156 @@\n use middle::cstore;\n use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n-use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n \n-///////////////////////////////////////////////////////////////////////////\n+use core::nonzero::NonZero;\n+use std::fmt;\n+use std::iter;\n+use std::marker::PhantomData;\n+use std::mem;\n+\n+/// An entity in the Rust typesystem, which can be one of\n+/// several kinds (only types and lifetimes for now).\n+/// To reduce memory usage, a `Kind` is a interned pointer,\n+/// with the lowest 2 bits being reserved for a tag to\n+/// indicate the type (`Ty` or `Region`) it points to.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Kind<'tcx> {\n+    ptr: NonZero<usize>,\n+    marker: PhantomData<(Ty<'tcx>, &'tcx ty::Region)>\n+}\n+\n+const TAG_MASK: usize = 0b11;\n+const TYPE_TAG: usize = 0b00;\n+const REGION_TAG: usize = 0b01;\n+\n+impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n+    fn from(ty: Ty<'tcx>) -> Kind<'tcx> {\n+        // Ensure we can use the tag bits.\n+        assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);\n+\n+        let ptr = ty as *const _ as usize;\n+        Kind {\n+            ptr: unsafe {\n+                NonZero::new(ptr | TYPE_TAG)\n+            },\n+            marker: PhantomData\n+        }\n+    }\n+}\n+\n+impl<'tcx> From<&'tcx ty::Region> for Kind<'tcx> {\n+    fn from(r: &'tcx ty::Region) -> Kind<'tcx> {\n+        // Ensure we can use the tag bits.\n+        assert_eq!(mem::align_of_val(r) & TAG_MASK, 0);\n+\n+        let ptr = r as *const _ as usize;\n+        Kind {\n+            ptr: unsafe {\n+                NonZero::new(ptr | REGION_TAG)\n+            },\n+            marker: PhantomData\n+        }\n+    }\n+}\n+\n+impl<'tcx> Kind<'tcx> {\n+    #[inline]\n+    unsafe fn downcast<T>(self, tag: usize) -> Option<&'tcx T> {\n+        let ptr = *self.ptr;\n+        if ptr & TAG_MASK == tag {\n+            Some(&*((ptr & !TAG_MASK) as *const _))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_type(self) -> Option<Ty<'tcx>> {\n+        unsafe {\n+            self.downcast(TYPE_TAG)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_region(self) -> Option<&'tcx ty::Region> {\n+        unsafe {\n+            self.downcast(REGION_TAG)\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for Kind<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if let Some(ty) = self.as_type() {\n+            write!(f, \"{:?}\", ty)\n+        } else if let Some(r) = self.as_region() {\n+            write!(f, \"{:?}\", r)\n+        } else {\n+            write!(f, \"<unknwon @ {:p}>\", *self.ptr as *const ())\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        if let Some(ty) = self.as_type() {\n+            Kind::from(ty.fold_with(folder))\n+        } else if let Some(r) = self.as_region() {\n+            Kind::from(r.fold_with(folder))\n+        } else {\n+            bug!()\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        if let Some(ty) = self.as_type() {\n+            ty.visit_with(visitor)\n+        } else if let Some(r) = self.as_region() {\n+            r.visit_with(visitor)\n+        } else {\n+            bug!()\n+        }\n+    }\n+}\n \n /// A substitution mapping type/region parameters to new values.\n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Substs<'tcx> {\n-    pub types: Vec<Ty<'tcx>>,\n-    pub regions: Vec<ty::Region>,\n+    params: Vec<Kind<'tcx>>\n }\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               t: Vec<Ty<'tcx>>,\n-               r: Vec<ty::Region>)\n-               -> &'tcx Substs<'tcx>\n-    {\n-        tcx.mk_substs(Substs { types: t, regions: r })\n+    pub fn new<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>, params: I)\n+                  -> &'tcx Substs<'tcx>\n+    where I: IntoIterator<Item=Kind<'tcx>> {\n+        tcx.mk_substs(Substs {\n+            params: params.into_iter().collect()\n+        })\n+    }\n+\n+    pub fn maybe_new<I, E>(tcx: TyCtxt<'a, 'gcx, 'tcx>, params: I)\n+                           -> Result<&'tcx Substs<'tcx>, E>\n+    where I: IntoIterator<Item=Result<Kind<'tcx>, E>> {\n+        Ok(tcx.mk_substs(Substs {\n+            params: params.into_iter().collect::<Result<_, _>>()?\n+        }))\n     }\n \n     pub fn new_trait(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     mut t: Vec<Ty<'tcx>>,\n-                     r: Vec<ty::Region>,\n-                     s: Ty<'tcx>)\n+                     s: Ty<'tcx>,\n+                     t: &[Ty<'tcx>])\n                     -> &'tcx Substs<'tcx>\n     {\n-        t.insert(0, s);\n-        Substs::new(tcx, t, r)\n+        let t = iter::once(s).chain(t.iter().cloned());\n+        Substs::new(tcx, t.map(Kind::from))\n     }\n \n     pub fn empty(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx Substs<'tcx> {\n-        Substs::new(tcx, vec![], vec![])\n+        Substs::new(tcx, vec![])\n     }\n \n     /// Creates a Substs for generic parameter definitions,\n@@ -60,56 +175,93 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                             mut mk_region: FR,\n                             mut mk_type: FT)\n                             -> &'tcx Substs<'tcx>\n-    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> ty::Region,\n+    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> &'tcx ty::Region,\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n         let defs = tcx.lookup_generics(def_id);\n-        let num_regions = defs.parent_regions as usize + defs.regions.len();\n-        let num_types = defs.parent_types as usize + defs.types.len();\n         let mut substs = Substs {\n-            regions: Vec::with_capacity(num_regions),\n-            types: Vec::with_capacity(num_types)\n+            params: Vec::with_capacity(defs.count())\n         };\n \n         substs.fill_item(tcx, defs, &mut mk_region, &mut mk_type);\n \n-        Substs::new(tcx, substs.types, substs.regions)\n+        tcx.mk_substs(substs)\n     }\n \n     fn fill_item<FR, FT>(&mut self,\n                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          defs: &ty::Generics<'tcx>,\n                          mk_region: &mut FR,\n                          mk_type: &mut FT)\n-    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> ty::Region,\n+    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> &'tcx ty::Region,\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n         if let Some(def_id) = defs.parent {\n             let parent_defs = tcx.lookup_generics(def_id);\n             self.fill_item(tcx, parent_defs, mk_region, mk_type);\n         }\n \n+        // Handle Self first, before all regions.\n+        let mut types = defs.types.iter();\n+        if defs.parent.is_none() && defs.has_self {\n+            let def = types.next().unwrap();\n+            let ty = mk_type(def, self);\n+            assert_eq!(def.index as usize, self.params.len());\n+            self.params.push(Kind::from(ty));\n+        }\n+\n         for def in &defs.regions {\n             let region = mk_region(def, self);\n-            assert_eq!(def.index as usize, self.regions.len());\n-            self.regions.push(region);\n+            assert_eq!(def.index as usize, self.params.len());\n+            self.params.push(Kind::from(region));\n         }\n \n-        for def in &defs.types {\n+        for def in types {\n             let ty = mk_type(def, self);\n-            assert_eq!(def.index as usize, self.types.len());\n-            self.types.push(ty);\n+            assert_eq!(def.index as usize, self.params.len());\n+            self.params.push(Kind::from(ty));\n         }\n     }\n \n     pub fn is_noop(&self) -> bool {\n-        self.regions.is_empty() && self.types.is_empty()\n+        self.params.is_empty()\n+    }\n+\n+    #[inline]\n+    pub fn params(&self) -> &[Kind<'tcx>] {\n+        &self.params\n+    }\n+\n+    #[inline]\n+    pub fn types(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+        self.params.iter().filter_map(|k| k.as_type())\n+    }\n+\n+    #[inline]\n+    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=&'tcx ty::Region> + 'a {\n+        self.params.iter().filter_map(|k| k.as_region())\n+    }\n+\n+    #[inline]\n+    pub fn type_at(&self, i: usize) -> Ty<'tcx> {\n+        self.params[i].as_type().unwrap_or_else(|| {\n+            bug!(\"expected type for param #{} in {:?}\", i, self.params);\n+        })\n     }\n \n+    #[inline]\n+    pub fn region_at(&self, i: usize) -> &'tcx ty::Region {\n+        self.params[i].as_region().unwrap_or_else(|| {\n+            bug!(\"expected region for param #{} in {:?}\", i, self.params);\n+        })\n+    }\n+\n+    #[inline]\n     pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n-        self.types[ty_param_def.index as usize]\n+        self.type_at(ty_param_def.index as usize)\n     }\n \n-    pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> ty::Region {\n-        self.regions[def.index as usize]\n+    #[inline]\n+    pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> &'tcx ty::Region {\n+        self.region_at(def.index as usize)\n     }\n \n     /// Transform from substitutions for a child of `source_ancestor`\n@@ -122,11 +274,27 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                        target_substs: &Substs<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n         let defs = tcx.lookup_generics(source_ancestor);\n-        let regions = target_substs.regions.iter()\n-            .chain(&self.regions[defs.regions.len()..]).cloned().collect();\n-        let types = target_substs.types.iter()\n-            .chain(&self.types[defs.types.len()..]).cloned().collect();\n-        Substs::new(tcx, types, regions)\n+        tcx.mk_substs(Substs {\n+            params: target_substs.params.iter()\n+                .chain(&self.params[defs.own_count()..]).cloned().collect()\n+        })\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let params = self.params.iter().map(|k| k.fold_with(folder)).collect();\n+        folder.tcx().mk_substs(Substs {\n+            params: params\n+        })\n+    }\n+\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_substs(self)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.params.visit_with(visitor)\n     }\n }\n \n@@ -215,16 +383,18 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n         // Note: This routine only handles regions that are bound on\n         // type declarations and other outer declarations, not those\n         // bound in *fn types*. Region substitution of the bound\n         // regions that appear in a function signature is done using\n         // the specialized routine `ty::replace_late_regions()`.\n-        match r {\n+        match *r {\n             ty::ReEarlyBound(data) => {\n-                match self.substs.regions.get(data.index as usize) {\n-                    Some(&r) => {\n+                let r = self.substs.params.get(data.index as usize)\n+                            .and_then(|k| k.as_region());\n+                match r {\n+                    Some(r) => {\n                         self.shift_region_through_binders(r)\n                     }\n                     None => {\n@@ -278,9 +448,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.types.get(p.idx as usize);\n+        let opt_ty = self.substs.params.get(p.idx as usize)\n+                         .and_then(|k| k.as_type());\n         let ty = match opt_ty {\n-            Some(t) => *t,\n+            Some(t) => t,\n             None => {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 span_bug!(\n@@ -291,7 +462,7 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n                     source_ty,\n                     p.idx,\n                     self.root_ty,\n-                    self.substs);\n+                    self.substs.params);\n             }\n         };\n \n@@ -354,8 +525,8 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    fn shift_region_through_binders(&self, region: ty::Region) -> ty::Region {\n-        ty::fold::shift_region(region, self.region_binders_passed)\n+    fn shift_region_through_binders(&self, region: &'tcx ty::Region) -> &'tcx ty::Region {\n+        self.tcx().mk_region(ty::fold::shift_region(*region, self.region_binders_passed))\n     }\n }\n \n@@ -367,12 +538,11 @@ impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n                        substs: &Substs<'tcx>)\n                        -> ty::TraitRef<'tcx> {\n         let defs = tcx.lookup_generics(trait_id);\n-        let regions = substs.regions[..defs.regions.len()].to_vec();\n-        let types = substs.types[..defs.types.len()].to_vec();\n \n+        let params = substs.params[..defs.own_count()].iter().cloned();\n         ty::TraitRef {\n             def_id: trait_id,\n-            substs: Substs::new(tcx, types, regions)\n+            substs: Substs::new(tcx, params)\n         }\n     }\n }\n@@ -381,13 +551,13 @@ impl<'a, 'gcx, 'tcx> ty::ExistentialTraitRef<'tcx> {\n     pub fn erase_self_ty(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          trait_ref: ty::TraitRef<'tcx>)\n                          -> ty::ExistentialTraitRef<'tcx> {\n-        let Substs { mut types, regions } = trait_ref.substs.clone();\n-\n-        types.remove(0);\n+        // Assert there is a Self.\n+        trait_ref.substs.type_at(0);\n \n+        let params = trait_ref.substs.params[1..].iter().cloned();\n         ty::ExistentialTraitRef {\n             def_id: trait_ref.def_id,\n-            substs: Substs::new(tcx, types, regions)\n+            substs: Substs::new(tcx, params)\n         }\n     }\n }\n@@ -404,13 +574,11 @@ impl<'a, 'gcx, 'tcx> ty::PolyExistentialTraitRef<'tcx> {\n         assert!(!self_ty.has_escaping_regions());\n \n         self.map_bound(|trait_ref| {\n-            let Substs { mut types, regions } = trait_ref.substs.clone();\n-\n-            types.insert(0, self_ty);\n-\n+            let params = trait_ref.substs.params.iter().cloned();\n+            let params = iter::once(Kind::from(self_ty)).chain(params);\n             ty::TraitRef {\n                 def_id: trait_ref.def_id,\n-                substs: Substs::new(tcx, types, regions)\n+                substs: Substs::new(tcx, params)\n             }\n         })\n     }"}, {"sha": "dd5c6a9758abf263d49b0960d8b684932b141d56", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn required_region_bounds(self,\n                                   erased_self_ty: Ty<'tcx>,\n                                   predicates: Vec<ty::Predicate<'tcx>>)\n-                                  -> Vec<ty::Region>    {\n+                                  -> Vec<&'tcx ty::Region>    {\n         debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n                erased_self_ty,\n                predicates);\n@@ -496,8 +496,8 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n         ty.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region) -> bool {\n-        match r {\n+    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+        match *r {\n             ty::ReStatic | ty::ReErased => {\n                 self.hash::<u32>(0);\n             }\n@@ -693,10 +693,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         return false;\n                     }\n \n-                    let types_a = &substs_a.types;\n-                    let types_b = &substs_b.types;\n-\n-                    types_a.iter().zip(types_b).all(|(&a, &b)| same_type(a, b))\n+                    substs_a.types().zip(substs_b.types()).all(|(a, b)| same_type(a, b))\n                 }\n                 _ => {\n                     a == b"}, {"sha": "409f5a85997bda10eb0fff2eb5b76b28862d6a61", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -67,6 +67,12 @@ pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> IntoIter<Ty<'tcx>> {\n     stack.into_iter()\n }\n \n+// We push types on the stack in reverse order so as to\n+// maintain a pre-order traversal. As of the time of this\n+// writing, the fact that the traversal is pre-order is not\n+// known to be significant to any code, but it seems like the\n+// natural order one would expect (basically, the order of the\n+// types as they are written).\n fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n     match parent_ty.sty {\n         ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n@@ -79,28 +85,28 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n             stack.push(mt.ty);\n         }\n         ty::TyProjection(ref data) => {\n-            push_reversed(stack, &data.trait_ref.substs.types);\n+            stack.extend(data.trait_ref.substs.types().rev());\n         }\n         ty::TyTrait(ref obj) => {\n-            push_reversed(stack, obj.principal.input_types());\n-            push_reversed(stack, &obj.projection_bounds.iter().map(|pred| {\n+            stack.extend(obj.principal.input_types().rev());\n+            stack.extend(obj.projection_bounds.iter().map(|pred| {\n                 pred.0.ty\n-            }).collect::<Vec<_>>());\n+            }).rev());\n         }\n         ty::TyEnum(_, ref substs) |\n         ty::TyStruct(_, ref substs) |\n         ty::TyAnon(_, ref substs) => {\n-            push_reversed(stack, &substs.types);\n+            stack.extend(substs.types().rev());\n         }\n         ty::TyClosure(_, ref substs) => {\n-            push_reversed(stack, &substs.func_substs.types);\n-            push_reversed(stack, &substs.upvar_tys);\n+            stack.extend(substs.func_substs.types().rev());\n+            stack.extend(substs.upvar_tys.iter().cloned().rev());\n         }\n-        ty::TyTuple(ref ts) => {\n-            push_reversed(stack, ts);\n+        ty::TyTuple(ts) => {\n+            stack.extend(ts.iter().cloned().rev());\n         }\n         ty::TyFnDef(_, substs, ref ft) => {\n-            push_reversed(stack, &substs.types);\n+            stack.extend(substs.types().rev());\n             push_sig_subtypes(stack, &ft.sig);\n         }\n         ty::TyFnPtr(ref ft) => {\n@@ -111,17 +117,5 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n \n fn push_sig_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, sig: &ty::PolyFnSig<'tcx>) {\n     stack.push(sig.0.output);\n-    push_reversed(stack, &sig.0.inputs);\n-}\n-\n-fn push_reversed<'tcx>(stack: &mut Vec<Ty<'tcx>>, tys: &[Ty<'tcx>]) {\n-    // We push slices on the stack in reverse order so as to\n-    // maintain a pre-order traversal. As of the time of this\n-    // writing, the fact that the traversal is pre-order is not\n-    // known to be significant to any code, but it seems like the\n-    // natural order one would expect (basically, the order of the\n-    // types as they are written).\n-    for &ty in tys.iter().rev() {\n-        stack.push(ty);\n-    }\n+    stack.extend(sig.0.inputs.iter().cloned().rev());\n }"}, {"sha": "1f166cb192fa33c0c686066909f8dea6026315d8", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -115,9 +115,9 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n #[derive(Debug)]\n pub enum ImpliedBound<'tcx> {\n-    RegionSubRegion(ty::Region, ty::Region),\n-    RegionSubParam(ty::Region, ty::ParamTy),\n-    RegionSubProjection(ty::Region, ty::ProjectionTy<'tcx>),\n+    RegionSubRegion(&'tcx ty::Region, &'tcx ty::Region),\n+    RegionSubParam(&'tcx ty::Region, ty::ParamTy),\n+    RegionSubProjection(&'tcx ty::Region, ty::ProjectionTy<'tcx>),\n }\n \n /// Compute the implied bounds that a callee/impl can assume based on\n@@ -196,7 +196,7 @@ pub fn implied_bounds<'a, 'gcx, 'tcx>(\n /// this down to determine what relationships would have to hold for\n /// `T: 'a` to hold. We get to assume that the caller has validated\n /// those relationships.\n-fn implied_bounds_from_components<'tcx>(sub_region: ty::Region,\n+fn implied_bounds_from_components<'tcx>(sub_region: &'tcx ty::Region,\n                                         sup_components: Vec<Component<'tcx>>)\n                                         -> Vec<ImpliedBound<'tcx>>\n {\n@@ -260,8 +260,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n         let cause = self.cause(traits::MiscObligation);\n         self.out.extend(\n-            trait_ref.substs.types\n-                            .iter()\n+            trait_ref.substs.types()\n                             .filter(|ty| !ty.has_escaping_regions())\n                             .map(|ty| traits::Obligation::new(cause.clone(),\n                                                               ty::Predicate::WellFormed(ty))));\n@@ -364,7 +363,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                                 cause,\n                                 ty::Predicate::TypeOutlives(\n                                     ty::Binder(\n-                                        ty::OutlivesPredicate(mt.ty, *r)))));\n+                                        ty::OutlivesPredicate(mt.ty, r)))));\n                     }\n                 }\n \n@@ -535,7 +534,7 @@ pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     principal: ty::PolyExistentialTraitRef<'tcx>,\n     others: ty::BuiltinBounds)\n-    -> Vec<ty::Region>\n+    -> Vec<&'tcx ty::Region>\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically"}, {"sha": "24b68c66e46673d3934f33227212987a1a66bf22", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -22,6 +22,8 @@ use ty::fold::{TypeFolder, TypeVisitor};\n \n use std::cell::Cell;\n use std::fmt;\n+use std::usize;\n+\n use syntax::abi::Abi;\n use syntax::parse::token;\n use syntax::ast::CRATE_NODE_ID;\n@@ -80,15 +82,17 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         verbose = tcx.sess.verbose();\n         has_self = generics.has_self;\n \n+        let mut child_types = 0;\n         if let Some(def_id) = generics.parent {\n             // Methods.\n             assert_eq!(ns, Ns::Value);\n+            child_types = generics.types.len();\n             generics = tcx.lookup_generics(def_id);\n             num_regions = generics.regions.len();\n             num_types = generics.types.len();\n \n             if has_self {\n-                write!(f, \"<{} as \", substs.types[0])?;\n+                write!(f, \"<{} as \", substs.type_at(0))?;\n             }\n \n             item_name = Some(tcx.item_name(did));\n@@ -107,8 +111,8 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         if !verbose {\n             if generics.types.last().map_or(false, |def| def.default.is_some()) {\n                 if let Some(substs) = tcx.lift(&substs) {\n-                    let tps = &substs.types[..num_types];\n-                    for (def, actual) in generics.types.iter().zip(tps).rev() {\n+                    let tps = substs.types().rev().skip(child_types);\n+                    for (def, actual) in generics.types.iter().rev().zip(tps) {\n                         if def.default.subst(tcx, substs) != Some(actual) {\n                             break;\n                         }\n@@ -124,7 +128,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n \n     if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n         let projection_ty = projections[0].ty;\n-        if let TyTuple(ref args) = substs.types[1].sty {\n+        if let TyTuple(ref args) = substs.type_at(1).sty {\n             return fn_sig(f, args, false, projection_ty);\n         }\n     }\n@@ -139,13 +143,15 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         }\n     };\n \n-    let print_regions = |f: &mut fmt::Formatter, start: &str, regions: &[ty::Region]| {\n+    let print_regions = |f: &mut fmt::Formatter, start: &str, skip, count| {\n         // Don't print any regions if they're all erased.\n-        if regions.iter().all(|r| *r == ty::ReErased) {\n+        let regions = || substs.regions().skip(skip).take(count);\n+        if regions().all(|r: &ty::Region| *r == ty::ReErased) {\n             return Ok(());\n         }\n \n-        for region in regions {\n+        for region in regions() {\n+            let region: &ty::Region = region;\n             start_or_continue(f, start, \", \")?;\n             if verbose {\n                 write!(f, \"{:?}\", region)?;\n@@ -167,11 +173,12 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         Ok(())\n     };\n \n-    print_regions(f, \"<\", &substs.regions[..num_regions])?;\n+    print_regions(f, \"<\", 0, num_regions)?;\n \n-    let tps = &substs.types[..num_types];\n+    let tps = substs.types().take(num_types - num_supplied_defaults)\n+                            .skip(has_self as usize);\n \n-    for &ty in &tps[has_self as usize..tps.len() - num_supplied_defaults] {\n+    for ty in tps {\n         start_or_continue(f, \"<\", \", \")?;\n         write!(f, \"{}\", ty)?;\n     }\n@@ -197,10 +204,10 @@ pub fn parameterized(f: &mut fmt::Formatter,\n             write!(f, \"::{}\", item_name)?;\n         }\n \n-        print_regions(f, \"::<\", &substs.regions[num_regions..])?;\n+        print_regions(f, \"::<\", num_regions, usize::MAX)?;\n \n         // FIXME: consider being smart with defaults here too\n-        for ty in &substs.types[num_types..] {\n+        for ty in substs.types().skip(num_types) {\n             start_or_continue(f, \"::<\", \", \")?;\n             write!(f, \"{}\", ty)?;\n         }\n@@ -240,7 +247,7 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n \n     let new_value = tcx.replace_late_bound_regions(&value, |br| {\n         let _ = start_or_continue(f, \"for<\", \", \");\n-        ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n+        let br = match br {\n             ty::BrNamed(_, name, _) => {\n                 let _ = write!(f, \"{}\", name);\n                 br\n@@ -254,7 +261,8 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n                             name,\n                             ty::Issue32330::WontChange)\n             }\n-        })\n+        };\n+        tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), br))\n     }).0;\n \n     start_or_continue(f, \"\", \"> \")?;\n@@ -344,7 +352,7 @@ impl<'tcx> fmt::Debug for ty::TypeParameterDef<'tcx> {\n     }\n }\n \n-impl fmt::Debug for ty::RegionParameterDef {\n+impl<'tcx> fmt::Debug for ty::RegionParameterDef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"RegionParameterDef({}, {:?}, {}, {:?})\",\n                self.name,\n@@ -368,13 +376,6 @@ impl<'tcx> fmt::Display for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for Substs<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Substs[types={:?}, regions={:?}]\",\n-               self.types, self.regions)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::ItemSubsts<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ItemSubsts({:?})\", self.substs)\n@@ -598,7 +599,7 @@ impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ObjectLifetimeDefault {\n+impl<'tcx> fmt::Debug for ty::ObjectLifetimeDefault<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ObjectLifetimeDefault::Ambiguous => write!(f, \"Ambiguous\"),\n@@ -654,13 +655,6 @@ impl fmt::Debug for ty::Variance {\n     }\n }\n \n-impl fmt::Debug for ty::ItemVariances {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ItemVariances(types={:?}, regions={:?})\",\n-               self.types, self.regions)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::GenericPredicates<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"GenericPredicates({:?})\", self.predicates)\n@@ -793,13 +787,14 @@ impl<'tcx> fmt::Display for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region>> {\n+impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, &'tcx ty::Region>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>> {\n+impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<&'tcx ty::Region,\n+                                                             &'tcx ty::Region>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n@@ -973,7 +968,7 @@ impl fmt::Debug for ty::UpvarId {\n     }\n }\n \n-impl fmt::Debug for ty::UpvarBorrow {\n+impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"UpvarBorrow({:?}, {:?})\",\n                self.kind, self.region)\n@@ -997,7 +992,7 @@ impl fmt::Display for ty::InferTy {\n     }\n }\n \n-impl fmt::Display for ty::ExplicitSelfCategory {\n+impl<'tcx> fmt::Display for ty::ExplicitSelfCategory<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(match *self {\n             ty::ExplicitSelfCategory::Static => \"static\","}, {"sha": "e86fa9a05f372c4eb1e2503a5a996a6855ac74c8", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              loan_region: ty::Region,\n+              loan_region: &'tcx ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {"}, {"sha": "9f95175d59d439217bdc5b9e3642b38e2640943b", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -28,7 +28,7 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     span: Span,\n                                     cause: euv::LoanCause,\n                                     cmt: mc::cmt<'tcx>,\n-                                    loan_region: ty::Region,\n+                                    loan_region: &'tcx ty::Region,\n                                     _: ty::BorrowKind)\n                                     -> Result<(),()> {\n     //! Reports error if `loan_region` is larger than S\n@@ -56,7 +56,7 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n \n     span: Span,\n     cause: euv::LoanCause,\n-    loan_region: ty::Region,\n+    loan_region: &'tcx ty::Region,\n     cmt_original: mc::cmt<'tcx>\n }\n \n@@ -92,7 +92,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn check_scope(&self, max_scope: ty::Region) -> R {\n+    fn check_scope(&self, max_scope: &'tcx ty::Region) -> R {\n         //! Reports an error if `loan_region` is larger than `max_scope`\n \n         if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn scope(&self, cmt: &mc::cmt) -> ty::Region {\n+    fn scope(&self, cmt: &mc::cmt<'tcx>) -> &'tcx ty::Region {\n         //! Returns the maximal region scope for the which the\n         //! lvalue `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n@@ -112,16 +112,15 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                 temp_scope\n             }\n             Categorization::Upvar(..) => {\n-                ty::ReScope(self.item_scope)\n-            }\n-            Categorization::StaticItem => {\n-                ty::ReStatic\n+                self.bccx.tcx.mk_region(ty::ReScope(self.item_scope))\n             }\n             Categorization::Local(local_id) => {\n-                ty::ReScope(self.bccx.tcx.region_maps.var_scope(local_id))\n+                self.bccx.tcx.mk_region(ty::ReScope(\n+                    self.bccx.tcx.region_maps.var_scope(local_id)))\n             }\n+            Categorization::StaticItem |\n             Categorization::Deref(_, _, mc::UnsafePtr(..)) => {\n-                ty::ReStatic\n+                self.bccx.tcx.mk_region(ty::ReStatic)\n             }\n             Categorization::Deref(_, _, mc::BorrowedPtr(_, r)) |\n             Categorization::Deref(_, _, mc::Implicit(_, r)) => {\n@@ -135,7 +134,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn report_error(&self, code: bckerr_code) {\n+    fn report_error(&self, code: bckerr_code<'tcx>) {\n         self.bccx.report(BckError { cmt: self.cmt_original.clone(),\n                                     span: self.span,\n                                     cause: BorrowViolation(self.cause),"}, {"sha": "a255564f01e255397f0c8a538e28df1c3d906096", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              loan_region: ty::Region,\n+              loan_region: &'tcx ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n@@ -307,7 +307,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                        borrow_span: Span,\n                        cmt: mc::cmt<'tcx>,\n                        req_kind: ty::BorrowKind,\n-                       loan_region: ty::Region,\n+                       loan_region: &'tcx ty::Region,\n                        cause: euv::LoanCause) {\n         debug!(\"guarantee_valid(borrow_id={}, cmt={:?}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n@@ -318,7 +318,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n         // a loan for the empty region can never be dereferenced, so\n         // it is always safe\n-        if loan_region == ty::ReEmpty {\n+        if *loan_region == ty::ReEmpty {\n             return;\n         }\n \n@@ -358,7 +358,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             }\n \n             RestrictionResult::SafeIf(loan_path, restricted_paths) => {\n-                let loan_scope = match loan_region {\n+                let loan_scope = match *loan_region {\n                     ty::ReScope(scope) => scope,\n \n                     ty::ReFree(ref fr) => fr.scope,"}, {"sha": "d08f792b30c144251e1d3938db237025bc101d9c", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -31,7 +31,7 @@ pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       cause: euv::LoanCause,\n                                       cmt: mc::cmt<'tcx>,\n-                                      loan_region: ty::Region)\n+                                      loan_region: &'tcx ty::Region)\n                                       -> RestrictionResult<'tcx> {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n@@ -49,7 +49,7 @@ pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n struct RestrictionsContext<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     span: Span,\n-    loan_region: ty::Region,\n+    loan_region: &'tcx ty::Region,\n     cause: euv::LoanCause,\n }\n \n@@ -157,7 +157,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn extend(&self,\n               result: RestrictionResult<'tcx>,\n               cmt: &mc::cmt<'tcx>,\n-              elem: LoanPathElem) -> RestrictionResult<'tcx> {\n+              elem: LoanPathElem<'tcx>) -> RestrictionResult<'tcx> {\n         match result {\n             RestrictionResult::Safe => RestrictionResult::Safe,\n             RestrictionResult::SafeIf(base_lp, mut base_vec) => {"}, {"sha": "885bbe856c8fb441c9bfe14b864314afa08e3f16", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -16,7 +16,7 @@ use super::{drop_flag_effects_for_location, on_all_children_bits};\n use super::{DropFlagState, MoveDataParamEnv};\n use super::patch::MirPatch;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::mir::repr::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n@@ -26,6 +26,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n \n use std::fmt;\n+use std::iter;\n use std::u32;\n \n pub struct ElaborateDrops;\n@@ -859,7 +860,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let unit_temp = Lvalue::Temp(self.patch.new_temp(tcx.mk_nil()));\n         let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n             .unwrap_or_else(|e| tcx.sess.fatal(&e));\n-        let substs = Substs::new(tcx, vec![ty], vec![]);\n+        let substs = Substs::new(tcx, iter::once(Kind::from(ty)));\n         let fty = tcx.lookup_item_type(free_func).ty.subst(tcx, substs);\n \n         self.patch.new_block(BasicBlockData {"}, {"sha": "6137afbb59f4d40b2129a0d889b0e80e40a1c645", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -41,6 +41,7 @@ use rustc::ty::{self, TyCtxt};\n use std::fmt;\n use std::mem;\n use std::rc::Rc;\n+use std::hash::{Hash, Hasher};\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n use syntax_pos::{MultiSpan, Span};\n@@ -345,18 +346,21 @@ impl<'tcx> Loan<'tcx> {\n     }\n }\n \n-#[derive(Eq, Hash)]\n+#[derive(Eq)]\n pub struct LoanPath<'tcx> {\n     kind: LoanPathKind<'tcx>,\n     ty: ty::Ty<'tcx>,\n }\n \n impl<'tcx> PartialEq for LoanPath<'tcx> {\n     fn eq(&self, that: &LoanPath<'tcx>) -> bool {\n-        let r = self.kind == that.kind;\n-        debug_assert!(self.ty == that.ty || !r,\n-                      \"Somehow loan paths are equal though their tys are not.\");\n-        r\n+        self.kind == that.kind\n+    }\n+}\n+\n+impl<'tcx> Hash for LoanPath<'tcx> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.kind.hash(state);\n     }\n }\n \n@@ -365,7 +369,7 @@ pub enum LoanPathKind<'tcx> {\n     LpVar(ast::NodeId),                         // `x` in README.md\n     LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n     LpDowncast(Rc<LoanPath<'tcx>>, DefId), // `x` downcast to particular enum variant\n-    LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem)\n+    LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem<'tcx>)\n }\n \n impl<'tcx> LoanPath<'tcx> {\n@@ -410,8 +414,8 @@ impl ToInteriorKind for mc::InteriorKind {\n // `enum E { X { foo: u32 }, Y { foo: u32 }}`\n // each `foo` is qualified by the definitition id of the variant (`X` or `Y`).\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum LoanPathElem {\n-    LpDeref(mc::PointerKind),\n+pub enum LoanPathElem<'tcx> {\n+    LpDeref(mc::PointerKind<'tcx>),\n     LpInterior(Option<DefId>, InteriorKind),\n }\n \n@@ -564,10 +568,11 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n \n // Errors that can occur\n #[derive(PartialEq)]\n-pub enum bckerr_code {\n+pub enum bckerr_code<'tcx> {\n     err_mutbl,\n-    err_out_of_scope(ty::Region, ty::Region, euv::LoanCause), // superscope, subscope, loan cause\n-    err_borrowed_pointer_too_short(ty::Region, ty::Region), // loan, ptr\n+    /// superscope, subscope, loan cause\n+    err_out_of_scope(&'tcx ty::Region, &'tcx ty::Region, euv::LoanCause),\n+    err_borrowed_pointer_too_short(&'tcx ty::Region, &'tcx ty::Region), // loan, ptr\n }\n \n // Combination of an error code and the categorization of the expression\n@@ -577,7 +582,7 @@ pub struct BckError<'tcx> {\n     span: Span,\n     cause: AliasableViolationKind,\n     cmt: mc::cmt<'tcx>,\n-    code: bckerr_code\n+    code: bckerr_code<'tcx>\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -605,7 +610,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.free_region_map = old_free_region_map;\n     }\n \n-    pub fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region)\n+    pub fn is_subregion_of(&self, r_sub: &'tcx ty::Region, r_sup: &'tcx ty::Region)\n                            -> bool\n     {\n         self.free_region_map.is_subregion_of(self.tcx, r_sub, r_sup)\n@@ -614,9 +619,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         // Catch and handle some particular cases.\n         match (&err.code, &err.cause) {\n-            (&err_out_of_scope(ty::ReScope(_), ty::ReStatic, _),\n+            (&err_out_of_scope(&ty::ReScope(_), &ty::ReStatic, _),\n              &BorrowViolation(euv::ClosureCapture(span))) |\n-            (&err_out_of_scope(ty::ReScope(_), ty::ReFree(..), _),\n+            (&err_out_of_scope(&ty::ReScope(_), &ty::ReFree(..), _),\n              &BorrowViolation(euv::ClosureCapture(span))) => {\n                 return self.report_out_of_scope_escaping_closure_capture(&err, span);\n             }\n@@ -965,8 +970,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             .emit();\n     }\n \n-    fn region_end_span(&self, region: ty::Region) -> Option<Span> {\n-        match region {\n+    fn region_end_span(&self, region: &'tcx ty::Region) -> Option<Span> {\n+        match *region {\n             ty::ReScope(scope) => {\n                 match scope.span(&self.tcx.region_maps, &self.tcx.map) {\n                     Some(s) => {\n@@ -1194,8 +1199,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn statement_scope_span(tcx: TyCtxt, region: ty::Region) -> Option<Span> {\n-    match region {\n+fn statement_scope_span(tcx: TyCtxt, region: &ty::Region) -> Option<Span> {\n+    match *region {\n         ty::ReScope(scope) => {\n             match tcx.map.find(scope.node_id(&tcx.region_maps)) {\n                 Some(hir_map::NodeStmt(stmt)) => Some(stmt.span),"}, {"sha": "82c142c919e3471c0a58eda9a53d7e1a049f66e3", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -1172,7 +1172,7 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n               _: NodeId,\n               span: Span,\n               _: cmt,\n-              _: Region,\n+              _: &'tcx Region,\n               kind: BorrowKind,\n               _: LoanCause) {\n         match kind {"}, {"sha": "460a6e68a5c5a20f4c4af373c67fdc40c80f8279", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -20,13 +20,14 @@ use rustc::middle::region::{self, CodeExtent};\n use rustc::middle::region::CodeExtentData;\n use rustc::middle::resolve_lifetime;\n use rustc::middle::stability;\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n+use std::iter;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n@@ -283,50 +284,51 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     pub fn re_early_bound(&self,\n                           index: u32,\n                           name: &'static str)\n-                          -> ty::Region {\n+                          -> &'tcx ty::Region {\n         let name = token::intern(name);\n-        ty::ReEarlyBound(ty::EarlyBoundRegion {\n+        self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: index,\n             name: name,\n-        })\n+        }))\n     }\n \n-    pub fn re_late_bound_with_debruijn(&self, id: u32, debruijn: ty::DebruijnIndex) -> ty::Region {\n-        ty::ReLateBound(debruijn, ty::BrAnon(id))\n+    pub fn re_late_bound_with_debruijn(&self, id: u32, debruijn: ty::DebruijnIndex)\n+                                       -> &'tcx ty::Region {\n+        self.infcx.tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n     }\n \n-    pub fn t_rptr(&self, r: ty::Region) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n+    pub fn t_rptr(&self, r: &'tcx ty::Region) -> Ty<'tcx> {\n+        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound(&self, id: u32) -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1));\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound_with_debruijn(&self,\n                                            id: u32,\n                                            debruijn: ty::DebruijnIndex)\n                                            -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, debruijn);\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n         let r = ty::ReScope(self.tcx().region_maps.node_extent(id));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n-    pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region {\n-        ty::ReFree(ty::FreeRegion {\n+    pub fn re_free(&self, nid: ast::NodeId, id: u32) -> &'tcx ty::Region {\n+        self.infcx.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n             scope: self.tcx().region_maps.item_extent(nid),\n             bound_region: ty::BrAnon(id),\n-        })\n+        }))\n     }\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: u32) -> Ty<'tcx> {\n         let r = self.re_free(nid, id);\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_static(&self) -> Ty<'tcx> {\n@@ -675,7 +677,7 @@ fn subst_ty_renumber_bound() {\n             env.t_fn(&[t_param], env.t_nil())\n         };\n \n-        let substs = Substs::new(env.infcx.tcx, vec![t_rptr_bound1], vec![]);\n+        let substs = Substs::new(env.infcx.tcx, iter::once(Kind::from(t_rptr_bound1)));\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)\n@@ -710,7 +712,7 @@ fn subst_ty_renumber_some_bounds() {\n             env.t_pair(t_param, env.t_fn(&[t_param], env.t_nil()))\n         };\n \n-        let substs = Substs::new(env.infcx.tcx, vec![t_rptr_bound1], vec![]);\n+        let substs = Substs::new(env.infcx.tcx, iter::once(Kind::from(t_rptr_bound1)));\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = (&'a isize, fn(&'a isize))\n@@ -772,7 +774,7 @@ fn subst_region_renumber_region() {\n             env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n         };\n \n-        let substs = Substs::new(env.infcx.tcx, vec![], vec![re_bound1]);\n+        let substs = Substs::new(env.infcx.tcx, iter::once(Kind::from(re_bound1)));\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)"}, {"sha": "0236f9c413ddc26e47662090196bda23a3ef9c57", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -517,7 +517,7 @@ pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n // Encoding and decoding the side tables\n \n trait rbml_writer_helpers<'tcx> {\n-    fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region);\n+    fn emit_region(&mut self, ecx: &e::EncodeContext, r: &'tcx ty::Region);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n     fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                        substs: &Substs<'tcx>);\n@@ -531,7 +531,7 @@ trait rbml_writer_helpers<'tcx> {\n }\n \n impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n-    fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region) {\n+    fn emit_region(&mut self, ecx: &e::EncodeContext, r: &'tcx ty::Region) {\n         self.emit_opaque(|this| Ok(tyencode::enc_region(&mut this.cursor,\n                                                         &ecx.ty_str_ctxt(),\n                                                         r)));\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                 &adjustment::AutoPtr(r, m) => {\n                     this.emit_enum_variant(\"AutoPtr\", 0, 2, |this| {\n                         this.emit_enum_variant_arg(0,\n-                            |this| Ok(this.emit_region(ecx, *r)));\n+                            |this| Ok(this.emit_region(ecx, r)));\n                         this.emit_enum_variant_arg(1, |this| m.encode(this))\n                     })\n                 }\n@@ -824,7 +824,7 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                      f: F) -> R\n         where F: for<'x> FnOnce(&mut tydecode::TyDecoder<'x, 'tcx>) -> R;\n \n-    fn read_region(&mut self, dcx: &DecodeContext) -> ty::Region;\n+    fn read_region<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> &'tcx ty::Region;\n     fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n     fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -835,8 +835,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                               -> ty::Predicate<'tcx>;\n     fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                            -> &'tcx Substs<'tcx>;\n-    fn read_upvar_capture(&mut self, dcx: &DecodeContext)\n-                          -> ty::UpvarCapture;\n+    fn read_upvar_capture<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                  -> ty::UpvarCapture<'tcx>;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                     -> adjustment::AutoAdjustment<'tcx>;\n     fn read_cast_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -908,7 +908,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             str\n         }\n     }\n-    fn read_region(&mut self, dcx: &DecodeContext) -> ty::Region {\n+    fn read_region<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> &'tcx ty::Region {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n@@ -948,7 +948,8 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                .parse_substs())\n         }).unwrap()\n     }\n-    fn read_upvar_capture(&mut self, dcx: &DecodeContext) -> ty::UpvarCapture {\n+    fn read_upvar_capture<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                                  -> ty::UpvarCapture<'tcx> {\n         self.read_enum(\"UpvarCapture\", |this| {\n             let variants = [\"ByValue\", \"ByRef\"];\n             this.read_enum_variant(&variants, |this, i| {\n@@ -1032,7 +1033,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n-                        let r: ty::Region =\n+                        let r: &'tcx ty::Region =\n                             this.read_enum_variant_arg(0, |this| {\n                                 Ok(this.read_region(dcx))\n                             }).unwrap();\n@@ -1041,7 +1042,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                 Decodable::decode(this)\n                             }).unwrap();\n \n-                        adjustment::AutoPtr(dcx.tcx.mk_region(r), m)\n+                        adjustment::AutoPtr(r, m)\n                     }\n                     1 => {\n                         let m: hir::Mutability ="}, {"sha": "0fd7b683067b7441798446c8b5ad19c25c2c4307", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::closure_ty(&cdata, def_id.index, tcx)\n     }\n \n-    fn item_variances(&self, def: DefId) -> ty::ItemVariances {\n+    fn item_variances(&self, def: DefId) -> Vec<ty::Variance> {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_item_variances(&cdata, def.index)\n@@ -291,13 +291,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_foreign_item(&cdata, did.index)\n     }\n \n-    fn is_static_method(&self, def: DefId) -> bool\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::is_static_method(&cdata, def.index)\n-    }\n-\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool\n     {\n         self.do_is_statically_included_foreign_item(id)"}, {"sha": "afcd25a79c5a135169f6d002049864ef71e0fb40", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -860,7 +860,8 @@ pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n     }\n }\n \n-fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n+fn get_explicit_self<'a, 'tcx>(item: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                               -> ty::ExplicitSelfCategory<'tcx> {\n     fn get_mutability(ch: u8) -> hir::Mutability {\n         match ch as char {\n             'i' => hir::MutImmutable,\n@@ -880,7 +881,7 @@ fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n         // FIXME(#4846) expl. region\n         '&' => {\n             ty::ExplicitSelfCategory::ByReference(\n-                ty::ReEmpty,\n+                tcx.mk_region(ty::ReEmpty),\n                 get_mutability(string.as_bytes()[1]))\n         }\n         _ => bug!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n@@ -906,16 +907,6 @@ pub fn get_trait_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n     item_name(doc)\n }\n \n-pub fn is_static_method(cdata: Cmd, id: DefIndex) -> bool {\n-    let doc = cdata.lookup_item(id);\n-    match item_sort(doc) {\n-        Some('r') | Some('p') => {\n-            get_explicit_self(doc) == ty::ExplicitSelfCategory::Static\n-        }\n-        _ => false\n-    }\n-}\n-\n pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                         -> Option<ty::ImplOrTraitItem<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n@@ -960,7 +951,7 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n                     \"the type {:?} of the method {:?} is not a function?\",\n                     ity, name)\n             };\n-            let explicit_self = get_explicit_self(item_doc);\n+            let explicit_self = get_explicit_self(item_doc, tcx);\n \n             ty::MethodTraitItem(Rc::new(ty::Method::new(name,\n                                                         generics,\n@@ -1001,7 +992,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: DefIndex)\n     }).collect()\n }\n \n-pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> ty::ItemVariances {\n+pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> Vec<ty::Variance> {\n     let item_doc = cdata.lookup_item(id);\n     let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n     let mut decoder = reader::Decoder::new(variance_doc);"}, {"sha": "f51299226fe7da904ff2f689e194d4eb8ad36cd6", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -20,7 +20,7 @@ use rustc::hir;\n \n use rustc::hir::def_id::{DefId, DefIndex};\n use middle::region;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n use rbml;\n@@ -129,19 +129,19 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n     pub fn parse_substs(&mut self) -> &'tcx Substs<'tcx> {\n-        let mut regions = vec![];\n-        let mut types = vec![];\n+        let mut params = vec![];\n         assert_eq!(self.next(), '[');\n-        while self.peek() != '|' {\n-            regions.push(self.parse_region());\n-        }\n-        assert_eq!(self.next(), '|');\n         while self.peek() != ']' {\n-            types.push(self.parse_ty());\n+            let k = match self.next() {\n+                'r' => Kind::from(self.parse_region()),\n+                't' => Kind::from(self.parse_ty()),\n+                _ => bug!()\n+            };\n+            params.push(k);\n         }\n         assert_eq!(self.next(), ']');\n \n-        Substs::new(self.tcx, types, regions)\n+        Substs::new(self.tcx, params)\n     }\n \n     pub fn parse_generics(&mut self) -> &'tcx ty::Generics<'tcx> {\n@@ -207,8 +207,8 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    pub fn parse_region(&mut self) -> ty::Region {\n-        match self.next() {\n+    pub fn parse_region(&mut self) -> &'tcx ty::Region {\n+        self.tcx.mk_region(match self.next() {\n             'b' => {\n                 assert_eq!(self.next(), '[');\n                 let id = ty::DebruijnIndex::new(self.parse_u32());\n@@ -245,7 +245,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             'e' => ty::ReEmpty,\n             'E' => ty::ReErased,\n             _ => bug!(\"parse_region: bad input\")\n-        }\n+        })\n     }\n \n     fn parse_scope(&mut self) -> region::CodeExtent {\n@@ -403,9 +403,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             '~' => return tcx.mk_box(self.parse_ty()),\n             '*' => return tcx.mk_ptr(self.parse_mt()),\n             '&' => {\n-                let r = self.parse_region();\n-                let mt = self.parse_mt();\n-                return tcx.mk_ref(tcx.mk_region(r), mt);\n+                return tcx.mk_ref(self.parse_region(), self.parse_mt());\n             }\n             'V' => {\n                 let t = self.parse_ty();\n@@ -657,7 +655,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    fn parse_region_param_def(&mut self) -> ty::RegionParameterDef {\n+    fn parse_region_param_def(&mut self) -> ty::RegionParameterDef<'tcx> {\n         let name = self.parse_name(':');\n         let def_id = self.parse_def();\n         let index = self.parse_u32();\n@@ -681,7 +679,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n \n-    fn parse_object_lifetime_default(&mut self) -> ty::ObjectLifetimeDefault {\n+    fn parse_object_lifetime_default(&mut self) -> ty::ObjectLifetimeDefault<'tcx> {\n         match self.next() {\n             'a' => ty::ObjectLifetimeDefault::Ambiguous,\n             'b' => ty::ObjectLifetimeDefault::BaseDefault,"}, {"sha": "7255eae61d4533cd75b205caae28b6f7f256e121", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -133,7 +133,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n         ty::TyRawPtr(mt) => { write!(w, \"*\"); enc_mt(w, cx, mt); }\n         ty::TyRef(r, mt) => {\n             write!(w, \"&\");\n-            enc_region(w, cx, *r);\n+            enc_region(w, cx, r);\n             enc_mt(w, cx, mt);\n         }\n         ty::TyArray(t, sz) => {\n@@ -251,12 +251,16 @@ fn enc_opt<T, F>(w: &mut Cursor<Vec<u8>>, t: Option<T>, enc_f: F) where\n pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                             substs: &Substs<'tcx>) {\n     write!(w, \"[\");\n-    for &r in &substs.regions {\n-        enc_region(w, cx, r);\n-    }\n-    write!(w, \"|\");\n-    for &ty in &substs.types {\n-        enc_ty(w, cx, ty);\n+    for &k in substs.params() {\n+        if let Some(ty) = k.as_type() {\n+            write!(w, \"t\");\n+            enc_ty(w, cx, ty);\n+        } else if let Some(r) = k.as_region() {\n+            write!(w, \"r\");\n+            enc_region(w, cx, r);\n+        } else {\n+            bug!()\n+        }\n     }\n     write!(w, \"]\");\n }\n@@ -286,8 +290,8 @@ pub fn enc_generics<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n     }\n }\n \n-pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: ty::Region) {\n-    match r {\n+pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: &ty::Region) {\n+    match *r {\n         ty::ReLateBound(id, br) => {\n             write!(w, \"b[{}|\", id.depth);\n             enc_bound_region(w, cx, br);"}, {"sha": "1b64b4d0b5317861712ebae924b4fec20e60fa32", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -278,7 +278,7 @@ struct Binding<'tcx> {\n     var_id: NodeId,\n     var_ty: Ty<'tcx>,\n     mutability: Mutability,\n-    binding_mode: BindingMode,\n+    binding_mode: BindingMode<'tcx>,\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "bf43bfb326a581a3bc7980776e9977264e639acc", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     assert!(ty.is_slice());\n                     let eq_def_id = self.hir.tcx().lang_items.eq_trait().unwrap();\n                     let ty = mt.ty;\n-                    let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, vec![ty]);\n+                    let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty]);\n \n                     let bool_ty = self.hir.bool_ty();\n                     let eq_result = self.temp(bool_ty);"}, {"sha": "0b33e5a145083fabc58475ea20d0f153480413cb", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -89,13 +89,15 @@ should go to.\n use build::{BlockAnd, BlockAndExtension, Builder, CFG, ScopeAuxiliary, ScopeId};\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::middle::lang_items;\n-use rustc::ty::subst::{Substs, Subst};\n+use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::repr::*;\n use syntax_pos::Span;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::fnv::FnvHashMap;\n \n+use std::iter;\n+\n pub struct Scope<'tcx> {\n     /// the scope-id within the scope_auxiliary\n     id: ScopeId,\n@@ -789,7 +791,7 @@ fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                               -> TerminatorKind<'tcx> {\n     let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n                        .unwrap_or_else(|e| tcx.sess.fatal(&e));\n-    let substs = Substs::new(tcx, vec![data.item_ty], vec![]);\n+    let substs = Substs::new(tcx, iter::once(Kind::from(data.item_ty)));\n     TerminatorKind::Call {\n         func: Operand::Constant(Constant {\n             span: data.span,"}, {"sha": "6e8a5771eea949a1ad4ea2af600e8548120d0b07", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -108,7 +108,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 region, ty::TypeAndMut { ty: expr.ty, mutbl: mutbl }),\n                             span: expr.span,\n                             kind: ExprKind::Borrow {\n-                                region: *region,\n+                                region: region,\n                                 borrow_kind: to_borrow_kind(mutbl),\n                                 arg: expr.to_ref()\n                             }\n@@ -137,7 +137,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 ty: adjusted_ty,\n                                 span: self.span,\n                                 kind: ExprKind::Borrow {\n-                                    region: *r,\n+                                    region: r,\n                                     borrow_kind: to_borrow_kind(m),\n                                     arg: expr.to_ref(),\n                                 },\n@@ -154,7 +154,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 ty: cx.tcx.mk_ref(region, ty::TypeAndMut { ty: expr.ty, mutbl: m }),\n                                 span: self.span,\n                                 kind: ExprKind::Borrow {\n-                                    region: *region,\n+                                    region: region,\n                                     borrow_kind: to_borrow_kind(m),\n                                     arg: expr.to_ref(),\n                                 },\n@@ -310,7 +310,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 _ => span_bug!(expr.span, \"type of & not region\"),\n             };\n             ExprKind::Borrow {\n-                region: *region,\n+                region: region,\n                 borrow_kind: to_borrow_kind(mutbl),\n                 arg: expr.to_ref(),\n             }\n@@ -842,8 +842,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     ExprKind::Deref {\n                         arg: Expr {\n                             temp_lifetime: temp_lifetime,\n-                            ty: cx.tcx.mk_ref(\n-                                cx.tcx.mk_region(borrow.region),\n+                            ty: cx.tcx.mk_ref(borrow.region,\n                                 ty::TypeAndMut {\n                                     ty: var_ty,\n                                     mutbl: borrow.kind.to_mutbl_lossy()\n@@ -907,8 +906,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         PassArgs::ByRef => {\n-            let scope = cx.tcx.region_maps.node_extent(expr.id);\n-            let region = cx.tcx.mk_region(ty::ReScope(scope));\n+            let region = cx.tcx.node_scope_region(expr.id);\n             let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n             argrefs.extend(\n                 args.iter()\n@@ -922,7 +920,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             temp_lifetime: temp_lifetime,\n                             ty: adjusted_ty,\n                             span: expr.span,\n-                            kind: ExprKind::Borrow { region: *region,\n+                            kind: ExprKind::Borrow { region: region,\n                                                      borrow_kind: BorrowKind::Shared,\n                                                      arg: arg.to_ref() }\n                         }.to_ref()"}, {"sha": "a38b429333b70f643aec7a315fb16f3d4d294b5b", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -144,10 +144,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         trait_def_id: DefId,\n                         method_name: &str,\n                         self_ty: Ty<'tcx>,\n-                        params: Vec<Ty<'tcx>>)\n+                        params: &[Ty<'tcx>])\n                         -> (Ty<'tcx>, Literal<'tcx>) {\n         let method_name = token::intern(method_name);\n-        let substs = Substs::new_trait(self.tcx, params, vec![], self_ty);\n+        let substs = Substs::new_trait(self.tcx, self_ty, params);\n         for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n             match *trait_item {\n                 ty::ImplOrTraitItem::MethodTraitItem(ref method) => {"}, {"sha": "0bd22cd2d9308c4a35b9cee16b9d88b2b10d9ee0", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -161,7 +161,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 let id = self.cx.tcx.expect_def(pat.id).var_id();\n                 let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n-                    ty::TyRef(&r, _) => Some(r),\n+                    ty::TyRef(r, _) => Some(r),\n                     _ => None,\n                 };\n                 let (mutability, mode) = match bm {"}, {"sha": "353f2433353028198f42c9a137600218f0368dac", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -193,7 +193,7 @@ pub enum ExprKind<'tcx> {\n         id: DefId,\n     },\n     Borrow {\n-        region: Region,\n+        region: &'tcx Region,\n         borrow_kind: BorrowKind,\n         arg: ExprRef<'tcx>,\n     },\n@@ -284,7 +284,7 @@ pub enum PatternKind<'tcx> {\n     Binding {\n         mutability: Mutability,\n         name: ast::Name,\n-        mode: BindingMode,\n+        mode: BindingMode<'tcx>,\n         var: ast::NodeId,\n         ty: Ty<'tcx>,\n         subpattern: Option<Pattern<'tcx>>,\n@@ -332,9 +332,9 @@ pub enum PatternKind<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub enum BindingMode {\n+pub enum BindingMode<'tcx> {\n     ByValue,\n-    ByRef(Region, BorrowKind),\n+    ByRef(&'tcx Region, BorrowKind),\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "9e076851bc37d9b6c900482283ecaf3cb6f6bcc2", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -540,7 +540,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n                 if let Literal::Item { def_id, substs } = constant.literal {\n                     // Don't peek inside generic (associated) constants.\n-                    if !substs.types.is_empty() {\n+                    if substs.types().next().is_some() {\n                         self.add_type(constant.ty);\n                     } else {\n                         let qualif = qualify_const_item_cached(self.tcx,"}, {"sha": "4aae6d690c4df3ccf1bebce7d206b8eff82983cb", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -683,7 +683,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n               borrow_id: ast::NodeId,\n               _borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              _loan_region: ty::Region,\n+              _loan_region: &'tcx ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause) {\n         // Kind of hacky, but we allow Unsafe coercions in constants."}, {"sha": "c3ef5a72a2944e8b2c2a092e69d8535599679c88", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'gcx, 'tc\n               _borrow_id: ast::NodeId,\n               _borrow_span: Span,\n               _cmt: mc::cmt,\n-              _loan_region: ty::Region,\n+              _loan_region: &'tcx ty::Region,\n               _bk: ty::BorrowKind,\n               _loan_cause: euv::LoanCause) {\n     }"}, {"sha": "9b02cbe6721f34e6dd3118250373c1345240fa02", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -104,8 +104,9 @@ use util::sha2::{Digest, Sha256};\n use rustc::middle::{cstore, weak_lang_items};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n-use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n+use rustc::ty::subst::Substs;\n use rustc::hir::map::definitions::{DefPath, DefPathData};\n \n use syntax::attr;\n@@ -126,14 +127,14 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                              // parameters substituted; this is\n                              // included in the hash as a kind of\n                              // safeguard.\n-                             item_type: ty::Ty<'tcx>,\n+                             item_type: Ty<'tcx>,\n \n                              // values for generic type parameters,\n                              // if any.\n-                             parameters: &[ty::Ty<'tcx>])\n+                             substs: Option<&Substs<'tcx>>)\n                              -> String {\n     debug!(\"get_symbol_hash(def_path={:?}, parameters={:?})\",\n-           def_path, parameters);\n+           def_path, substs);\n \n     let tcx = scx.tcx();\n \n@@ -154,11 +155,13 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     hash_state.input(&encoded_item_type[..]);\n \n     // also include any type parameters (for generic items)\n-    for t in parameters {\n-       assert!(!t.has_erasable_regions());\n-       assert!(!t.needs_subst());\n-       let encoded_type = tcx.sess.cstore.encode_type(tcx, t, def_id_to_string);\n-       hash_state.input(&encoded_type[..]);\n+    if let Some(substs) = substs {\n+        for t in substs.types() {\n+            assert!(!t.has_erasable_regions());\n+            assert!(!t.needs_subst());\n+            let encoded_type = tcx.sess.cstore.encode_type(tcx, t, def_id_to_string);\n+            hash_state.input(&encoded_type[..]);\n+        }\n     }\n \n     return format!(\"h{}\", truncated_hash_result(&mut *hash_state));\n@@ -252,7 +255,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n         // and should not matter anyhow.\n         let instance_ty = scx.tcx().erase_regions(&instance_ty.ty);\n \n-        let hash = get_symbol_hash(scx, &def_path, instance_ty, &substs.types);\n+        let hash = get_symbol_hash(scx, &def_path, instance_ty, Some(substs));\n \n         let mut buffer = SymbolPathBuffer {\n             names: Vec::with_capacity(def_path.data.len())\n@@ -282,22 +285,22 @@ impl ItemPathBuffer for SymbolPathBuffer {\n }\n \n pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                                    t: ty::Ty<'tcx>,\n+                                                    t: Ty<'tcx>,\n                                                     prefix: &str)\n                                                     -> String {\n     let empty_def_path = DefPath {\n         data: vec![],\n         krate: cstore::LOCAL_CRATE,\n     };\n-    let hash = get_symbol_hash(scx, &empty_def_path, t, &[]);\n+    let hash = get_symbol_hash(scx, &empty_def_path, t, None);\n     let path = [token::intern_and_get_ident(prefix)];\n     mangle(path.iter().cloned(), Some(&hash[..]))\n }\n \n /// Only symbols that are invisible outside their compilation unit should use a\n /// name generated by this function.\n pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                    t: ty::Ty<'tcx>,\n+                                                    t: Ty<'tcx>,\n                                                     suffix: &str)\n                                                     -> String {\n     let path = [token::intern(&t.to_string()).as_str(),\n@@ -306,7 +309,7 @@ pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>\n         data: vec![],\n         krate: cstore::LOCAL_CRATE,\n     };\n-    let hash = get_symbol_hash(ccx.shared(), &def_path, t, &[]);\n+    let hash = get_symbol_hash(ccx.shared(), &def_path, t, None);\n     mangle(path.iter().cloned(), Some(&hash[..]))\n }\n "}, {"sha": "5e431193a2c4cac96366bd61e1376b283a01b573", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -514,7 +514,7 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n                                              -> CustomCoerceUnsized {\n     let trait_ref = ty::Binder(ty::TraitRef {\n         def_id: scx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n-        substs: Substs::new_trait(scx.tcx(), vec![target_ty], vec![], source_ty)\n+        substs: Substs::new_trait(scx.tcx(), source_ty, &[target_ty])\n     });\n \n     match fulfill_obligation(scx, DUMMY_SP, trait_ref) {"}, {"sha": "a30f8f291a6775c676dc1527984b2b922c4e1314", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -400,9 +400,9 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     debug!(\"get_fn(def_id={:?}, substs={:?})\", def_id, substs);\n \n-    assert!(!substs.types.needs_infer());\n-    assert!(!substs.types.has_escaping_regions());\n-    assert!(!substs.types.has_param_types());\n+    assert!(!substs.needs_infer());\n+    assert!(!substs.has_escaping_regions());\n+    assert!(!substs.has_param_types());\n \n     let substs = tcx.normalize_associated_type(&substs);\n     let instance = Instance::new(def_id, substs);"}, {"sha": "ba979813aa1f071fe50df7f3d5f134f899a5ee31", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -756,7 +756,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                    .drop_trait()\n                                    .unwrap();\n \n-        let self_type_substs = Substs::new_trait(scx.tcx(), vec![], vec![], ty);\n+        let self_type_substs = Substs::new_trait(scx.tcx(), ty, &[]);\n \n         let trait_ref = ty::TraitRef {\n             def_id: drop_trait_def_id,\n@@ -1238,7 +1238,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     // The substitutions we have are on the impl, so we grab\n                     // the method type from the impl to substitute into.\n                     let impl_substs = Substs::for_item(tcx, impl_def_id,\n-                                                       |_, _| ty::ReErased,\n+                                                       |_, _| tcx.mk_region(ty::ReErased),\n                                                        |_, _| tcx.types.err);\n                     let mth = meth::get_impl_method(tcx,\n                                                     callee_substs,"}, {"sha": "5055ed86a038662de131f7215739becf79ab406e", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -265,7 +265,7 @@ pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n }\n \n pub fn validate_substs(substs: &Substs) {\n-    assert!(!substs.types.needs_infer());\n+    assert!(!substs.needs_infer());\n }\n \n // Function context.  Every LLVM function we create will have one of"}, {"sha": "71184dd3f814d11fcf300122c6ea9610ea17541a", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -563,7 +563,9 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self.tcx(), item_def_id, |_, _| ty::ReErased, |_, _| {\n+        Substs::for_item(self.tcx(), item_def_id,\n+                         |_, _| self.tcx().mk_region(ty::ReErased),\n+                         |_, _| {\n             bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n         })\n     }"}, {"sha": "67d4a0e044c9c8ac7d7b6594255269615a3ba6c5", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -342,11 +342,10 @@ impl<'tcx> TypeMap<'tcx> {\n             // Add the def-index as the second part\n             output.push_str(&format!(\"{:x}\", def_id.index.as_usize()));\n \n-            let tps = &substs.types;\n-            if !tps.is_empty() {\n+            if substs.types().next().is_some() {\n                 output.push('<');\n \n-                for &type_parameter in tps {\n+                for type_parameter in substs.types() {\n                     let param_type_id =\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id ="}, {"sha": "5e248261e11852a54ecd69d69d0ce0d6172a3ad1", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -344,37 +344,35 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                          generics: &ty::Generics<'tcx>,\n-                                         param_substs: &Substs<'tcx>,\n+                                         substs: &Substs<'tcx>,\n                                          file_metadata: DIFile,\n                                          name_to_append_suffix_to: &mut String)\n                                          -> DIArray\n     {\n-        let actual_types = &param_substs.types;\n-\n-        if actual_types.is_empty() {\n+        if substs.types().next().is_none() {\n             return create_DIArray(DIB(cx), &[]);\n         }\n \n         name_to_append_suffix_to.push('<');\n-        for (i, &actual_type) in actual_types.iter().enumerate() {\n+        for (i, actual_type) in substs.types().enumerate() {\n+            if i != 0 {\n+                name_to_append_suffix_to.push_str(\",\");\n+            }\n+\n             let actual_type = cx.tcx().normalize_associated_type(&actual_type);\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n                                                                true);\n             name_to_append_suffix_to.push_str(&actual_type_name[..]);\n-\n-            if i != actual_types.len() - 1 {\n-                name_to_append_suffix_to.push_str(\",\");\n-            }\n         }\n         name_to_append_suffix_to.push('>');\n \n         // Again, only create type information if full debuginfo is enabled\n         let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n             let names = get_type_parameter_names(cx, generics);\n-            actual_types.iter().zip(names).map(|(ty, name)| {\n-                let actual_type = cx.tcx().normalize_associated_type(ty);\n+            substs.types().zip(names).map(|(ty, name)| {\n+                let actual_type = cx.tcx().normalize_associated_type(&ty);\n                 let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n                 let name = CString::new(name.as_str().as_bytes()).unwrap();\n                 unsafe {"}, {"sha": "f757578e6954def808863c0a174668972d89c17b", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -175,13 +175,13 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                   substs: &Substs<'tcx>,\n                                   output: &mut String) {\n-        if substs.types.is_empty() {\n+        if substs.types().next().is_none() {\n             return;\n         }\n \n         output.push('<');\n \n-        for &type_parameter in &substs.types {\n+        for type_parameter in substs.types() {\n             push_debuginfo_type_name(cx, type_parameter, true, output);\n             output.push_str(\", \");\n         }"}, {"sha": "f29d85f3b52f06aff255178a7c35db4e72902d86", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -302,7 +302,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let trait_ref = ty::Binder(ty::TraitRef {\n         def_id: tcx.lang_items.drop_trait().unwrap(),\n-        substs: Substs::new_trait(tcx, vec![], vec![], t)\n+        substs: Substs::new_trait(tcx, t, &[])\n     });\n     let vtbl = match fulfill_obligation(bcx.ccx().shared(), DUMMY_SP, trait_ref) {\n         traits::VtableImpl(data) => data,"}, {"sha": "8bef7584db9e22639be49f5fd6ae451e1f96f468", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -146,12 +146,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             Call(bcx, llfn, &[], call_debug_location)\n         }\n         (_, \"size_of\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n         }\n         (_, \"size_of_val\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             if !type_is_sized(tcx, tp_ty) {\n                 let (llsize, _) =\n                     glue::size_and_align_of_dst(&bcx.build(), tp_ty, llargs[1]);\n@@ -162,11 +162,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n         }\n         (_, \"min_align_of\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             C_uint(ccx, type_of::align_of(ccx, tp_ty))\n         }\n         (_, \"min_align_of_val\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             if !type_is_sized(tcx, tp_ty) {\n                 let (_, llalign) =\n                     glue::size_and_align_of_dst(&bcx.build(), tp_ty, llargs[1]);\n@@ -176,12 +176,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n         }\n         (_, \"pref_align_of\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty))\n         }\n         (_, \"drop_in_place\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             let is_sized = type_is_sized(tcx, tp_ty);\n             let ptr = if is_sized {\n                 llargs[0]\n@@ -199,15 +199,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_nil(ccx)\n         }\n         (_, \"type_name\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             let ty_name = token::intern_and_get_ident(&tp_ty.to_string());\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {\n-            C_u64(ccx, ccx.tcx().type_id_hash(substs.types[0]))\n+            C_u64(ccx, ccx.tcx().type_id_hash(substs.type_at(0)))\n         }\n         (_, \"init\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             if !type_is_zero_size(ccx, tp_ty) {\n                 // Just zero out the stack slot. (See comment on base::memzero for explanation)\n                 init_zero_mem(bcx, llresult, tp_ty);\n@@ -219,7 +219,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_nil(ccx)\n         }\n         (_, \"needs_drop\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n \n             C_bool(ccx, bcx.fcx.type_needs_drop(tp_ty))\n         }\n@@ -238,7 +238,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            false,\n                            false,\n-                           substs.types[0],\n+                           substs.type_at(0),\n                            llargs[1],\n                            llargs[0],\n                            llargs[2],\n@@ -248,7 +248,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            true,\n                            false,\n-                           substs.types[0],\n+                           substs.type_at(0),\n                            llargs[1],\n                            llargs[0],\n                            llargs[2],\n@@ -257,7 +257,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"write_bytes\") => {\n             memset_intrinsic(bcx,\n                              false,\n-                             substs.types[0],\n+                             substs.type_at(0),\n                              llargs[0],\n                              llargs[1],\n                              llargs[2],\n@@ -268,7 +268,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            false,\n                            true,\n-                           substs.types[0],\n+                           substs.type_at(0),\n                            llargs[0],\n                            llargs[1],\n                            llargs[2],\n@@ -278,7 +278,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            true,\n                            true,\n-                           substs.types[0],\n+                           substs.type_at(0),\n                            llargs[0],\n                            llargs[1],\n                            llargs[2],\n@@ -287,14 +287,14 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"volatile_set_memory\") => {\n             memset_intrinsic(bcx,\n                              true,\n-                             substs.types[0],\n+                             substs.type_at(0),\n                              llargs[0],\n                              llargs[1],\n                              llargs[2],\n                              call_debug_location)\n         }\n         (_, \"volatile_load\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             let mut ptr = llargs[0];\n             if let Some(ty) = fn_ty.ret.cast {\n                 ptr = PointerCast(bcx, ptr, ty.ptr_to());\n@@ -306,7 +306,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             to_immediate(bcx, load, tp_ty)\n         },\n         (_, \"volatile_store\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             if type_is_fat_ptr(bcx.tcx(), tp_ty) {\n                 VolatileStore(bcx, llargs[1], get_dataptr(bcx, llargs[0]));\n                 VolatileStore(bcx, llargs[2], get_meta(bcx, llargs[0]));\n@@ -406,7 +406,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         },\n \n         (_, \"discriminant_value\") => {\n-            let val_ty = substs.types[0];\n+            let val_ty = substs.type_at(0);\n             match val_ty.sty {\n                 ty::TyEnum(..) => {\n                     let repr = adt::represent_type(ccx, val_ty);\n@@ -458,7 +458,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n             match split[1] {\n                 \"cxchg\" | \"cxchgweak\" => {\n-                    let sty = &substs.types[0].sty;\n+                    let sty = &substs.type_at(0).sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n                         let val = AtomicCmpXchg(bcx, llargs[0], llargs[1], llargs[2],\n@@ -477,7 +477,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"load\" => {\n-                    let sty = &substs.types[0].sty;\n+                    let sty = &substs.type_at(0).sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         AtomicLoad(bcx, llargs[0], order)\n                     } else {\n@@ -490,7 +490,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"store\" => {\n-                    let sty = &substs.types[0].sty;\n+                    let sty = &substs.type_at(0).sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         AtomicStore(bcx, llargs[1], llargs[0], order);\n                     } else {\n@@ -529,7 +529,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    let sty = &substs.types[0].sty;\n+                    let sty = &substs.type_at(0).sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         AtomicRMW(bcx, atom_op, llargs[0], llargs[1], order)\n                     } else {"}, {"sha": "483bc99c310fccb86f8983395e2298f3d3cc20ce", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -265,7 +265,7 @@ pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // the method may have some early-bound lifetimes, add\n             // regions for those\n             let method_substs = Substs::for_item(tcx, trait_method_def_id,\n-                                                 |_, _| ty::ReErased,\n+                                                 |_, _| tcx.mk_region(ty::ReErased),\n                                                  |_, _| tcx.types.err);\n \n             // The substitutions we have are on the impl, so we grab\n@@ -307,7 +307,7 @@ pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  name: Name)\n                                  -> ImplMethod<'tcx>\n {\n-    assert!(!substs.types.needs_infer());\n+    assert!(!substs.needs_infer());\n \n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n     let trait_def = tcx.lookup_trait_def(trait_def_id);"}, {"sha": "0ffb83067f91c57389070d4097a190ac12307f10", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -32,7 +32,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n impl<'tcx> Instance<'tcx> {\n     pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n                -> Instance<'tcx> {\n-        assert!(substs.regions.iter().all(|&r| r == ty::ReErased));\n+        assert!(substs.regions().all(|&r| r == ty::ReErased));\n         Instance { def: def_id, substs: substs }\n     }\n     pub fn mono<'a>(scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {"}, {"sha": "7341e8db41de5bf4e83b3c1ea29924a94836cd8a", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -342,7 +342,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         TransItem::DropGlue(..) => unreachable!(),\n                         // Is there any benefit to using ExternalLinkage?:\n                         TransItem::Fn(ref instance) => {\n-                            if instance.substs.types.is_empty() {\n+                            if instance.substs.types().next().is_none() {\n                                 // This is a non-generic functions, we always\n                                 // make it visible externally on the chance that\n                                 // it might be used in another codegen unit.\n@@ -487,7 +487,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // DefId, we use the location of the impl after all.\n \n             if tcx.trait_of_item(instance.def).is_some() {\n-                let self_ty = instance.substs.types[0];\n+                let self_ty = instance.substs.type_at(0);\n                 // This is an implementation of a trait method.\n                 return characteristic_def_id_of_type(self_ty).or(Some(instance.def));\n             }"}, {"sha": "2c91c408487b8513319d06b163be261fcfda2887", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -171,8 +171,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                     instance: Instance<'tcx>,\n                     linkage: llvm::Linkage,\n                     symbol_name: &str) {\n-        assert!(!instance.substs.types.needs_infer() &&\n-                !instance.substs.types.has_param_types());\n+        assert!(!instance.substs.needs_infer() &&\n+                !instance.substs.has_param_types());\n \n         let item_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n         let item_ty = ccx.tcx().erase_regions(&item_ty);\n@@ -244,7 +244,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n         match *self {\n             TransItem::Fn(ref instance) => {\n-                !instance.substs.types.is_empty() || {\n+                instance.substs.types().next().is_some() || {\n                     let attributes = tcx.get_attrs(instance.def);\n                     attr::requests_inline(&attributes[..])\n                 }\n@@ -264,16 +264,19 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn is_instantiated_only_on_demand(&self) -> bool {\n         match *self {\n-            TransItem::Fn(ref instance) => !instance.def.is_local() ||\n-                                           !instance.substs.types.is_empty(),\n+            TransItem::Fn(ref instance) => {\n+                !instance.def.is_local() || instance.substs.types().next().is_some()\n+            }\n             TransItem::DropGlue(..) => true,\n             TransItem::Static(..)   => false,\n         }\n     }\n \n     pub fn is_generic_fn(&self) -> bool {\n         match *self {\n-            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n+            TransItem::Fn(ref instance) => {\n+                instance.substs.types().next().is_some()\n+            }\n             TransItem::DropGlue(..) |\n             TransItem::Static(..)   => false,\n         }\n@@ -374,7 +377,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       t: ty::Ty<'tcx>,\n+                                       t: Ty<'tcx>,\n                                        output: &mut String) {\n     match t.sty {\n         ty::TyBool              => output.push_str(\"bool\"),\n@@ -396,7 +399,7 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyStruct(adt_def, substs) |\n         ty::TyEnum(adt_def, substs) => {\n             push_item_name(tcx, adt_def.did, output);\n-            push_type_params(tcx, &substs.types, &[], output);\n+            push_type_params(tcx, substs, &[], output);\n         },\n         ty::TyTuple(component_types) => {\n             output.push('(');\n@@ -446,7 +449,7 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyTrait(ref trait_data) => {\n             push_item_name(tcx, trait_data.principal.def_id(), output);\n             push_type_params(tcx,\n-                             &trait_data.principal.skip_binder().substs.types,\n+                             trait_data.principal.skip_binder().substs,\n                              &trait_data.projection_bounds,\n                              output);\n         },\n@@ -494,7 +497,7 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             output.push_str(\"{\");\n             output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n             output.push_str(\"}\");\n-            push_type_params(tcx, &closure_substs.func_substs.types, &[], output);\n+            push_type_params(tcx, closure_substs.func_substs, &[], output);\n         }\n         ty::TyError |\n         ty::TyInfer(_) |\n@@ -529,16 +532,16 @@ fn push_item_name(tcx: TyCtxt,\n }\n \n fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              types: &[Ty<'tcx>],\n+                              substs: &Substs<'tcx>,\n                               projections: &[ty::PolyExistentialProjection<'tcx>],\n                               output: &mut String) {\n-    if types.is_empty() && projections.is_empty() {\n+    if substs.types().next().is_none() && projections.is_empty() {\n         return;\n     }\n \n     output.push('<');\n \n-    for &type_parameter in types {\n+    for type_parameter in substs.types() {\n         push_unique_type_name(tcx, type_parameter, output);\n         output.push_str(\", \");\n     }\n@@ -562,7 +565,7 @@ fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      instance: Instance<'tcx>,\n                                      output: &mut String) {\n     push_item_name(tcx, instance.def, output);\n-    push_type_params(tcx, &instance.substs.types, &[], output);\n+    push_type_params(tcx, instance.substs, &[], output);\n }\n \n pub fn def_id_to_string(tcx: TyCtxt, def_id: DefId) -> String {\n@@ -572,7 +575,7 @@ pub fn def_id_to_string(tcx: TyCtxt, def_id: DefId) -> String {\n }\n \n pub fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                ty: ty::Ty<'tcx>)\n+                                ty: Ty<'tcx>)\n                                 -> String {\n     let mut output = String::new();\n     push_unique_type_name(tcx, ty, &mut output);"}, {"sha": "b47d2cd0f204b8d37ad9327f6bd18916b5b8d140", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -17,6 +17,7 @@ use common::*;\n use machine;\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::subst::Substs;\n \n use type_::Type;\n \n@@ -256,7 +257,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           // avoids creating more than one copy of the enum when one\n           // of the enum's variants refers to the enum itself.\n           let repr = adt::represent_type(cx, t);\n-          let name = llvm_type_name(cx, def.did, &substs.types);\n+          let name = llvm_type_name(cx, def.did, substs);\n           adt::incomplete_type_of(cx, &repr, &name[..])\n       }\n       ty::TyClosure(..) => {\n@@ -330,7 +331,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n               // in *after* placing it into the type cache. This prevents\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n-              let name = llvm_type_name(cx, def.did, &substs.types);\n+              let name = llvm_type_name(cx, def.did, substs);\n               adt::incomplete_type_of(cx, &repr, &name[..])\n           }\n       }\n@@ -367,10 +368,10 @@ pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n \n fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             did: DefId,\n-                            tps: &[Ty<'tcx>])\n+                            substs: &Substs<'tcx>)\n                             -> String {\n     let base = cx.tcx().item_path_str(did);\n-    let strings: Vec<String> = tps.iter().map(|t| t.to_string()).collect();\n+    let strings: Vec<String> = substs.types().map(|t| t.to_string()).collect();\n     let tstr = if strings.is_empty() {\n         base\n     } else {"}, {"sha": "f24a7cf2121ebe7ab67c22e508b9ec3885d8a014", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -178,8 +178,9 @@ type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjection\n /// This type must not appear anywhere in other converted types.\n const TRAIT_OBJECT_DUMMY_SELF: ty::TypeVariants<'static> = ty::TyInfer(ty::FreshTy(0));\n \n-pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n-                            -> ty::Region {\n+pub fn ast_region_to_region<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                            lifetime: &hir::Lifetime)\n+                                            -> &'tcx ty::Region {\n     let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n         None => {\n             // should have been recorded by the `resolve_lifetime` pass\n@@ -238,7 +239,7 @@ pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n            lifetime.id,\n            r);\n \n-    r\n+    tcx.mk_region(r)\n }\n \n fn report_elision_failure(\n@@ -313,14 +314,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn opt_ast_region_to_region(&self,\n         rscope: &RegionScope,\n         default_span: Span,\n-        opt_lifetime: &Option<hir::Lifetime>) -> ty::Region\n+        opt_lifetime: &Option<hir::Lifetime>) -> &'tcx ty::Region\n     {\n         let r = match *opt_lifetime {\n             Some(ref lifetime) => {\n                 ast_region_to_region(self.tcx(), lifetime)\n             }\n \n-            None => match rscope.anon_regions(default_span, 1) {\n+            None => self.tcx().mk_region(match rscope.anon_regions(default_span, 1) {\n                 Ok(rs) => rs[0],\n                 Err(params) => {\n                     let ampersand_span = Span { hi: default_span.lo, ..default_span};\n@@ -335,7 +336,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     err.emit();\n                     ty::ReStatic\n                 }\n-            }\n+            })\n         };\n \n         debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {:?}\",\n@@ -366,7 +367,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     .emit();\n \n                 return Substs::for_item(tcx, def_id, |_, _| {\n-                    ty::ReStatic\n+                    tcx.mk_region(ty::ReStatic)\n                 }, |_, _| {\n                     tcx.types.err\n                 });\n@@ -431,7 +432,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let expected_num_region_params = decl_generics.regions.len();\n         let supplied_num_region_params = lifetimes.len();\n         let regions = if expected_num_region_params == supplied_num_region_params {\n-            lifetimes.iter().map(|l| ast_region_to_region(tcx, l)).collect()\n+            lifetimes.iter().map(|l| *ast_region_to_region(tcx, l)).collect()\n         } else {\n             let anon_regions =\n                 rscope.anon_regions(span, expected_num_region_params);\n@@ -472,7 +473,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let mut output_assoc_binding = None;\n         let substs = Substs::for_item(tcx, def_id, |def, _| {\n-            regions[def.index as usize]\n+            let i = def.index as usize - self_ty.is_some() as usize;\n+            tcx.mk_region(regions[i])\n         }, |def, substs| {\n             let i = def.index as usize;\n \n@@ -481,7 +483,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 return ty;\n             }\n \n-            let i = i - self_ty.is_some() as usize;\n+            let i = i - self_ty.is_some() as usize - decl_generics.regions.len();\n             if num_types_provided.map_or(false, |n| i < n) {\n                 // A provided type parameter.\n                 match *parameters {\n@@ -588,7 +590,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n \n         if lifetimes_for_params.iter().map(|e| e.lifetime_count).sum::<usize>() == 1 {\n-            Ok(possible_implied_output_region.unwrap())\n+            Ok(*possible_implied_output_region.unwrap())\n         } else {\n             Err(Some(lifetimes_for_params))\n         }\n@@ -937,8 +939,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // FIXME(#12938): This is a hack until we have full support for DST.\n         if Some(did) == self.tcx().lang_items.owned_box() {\n-            assert_eq!(substs.types.len(), 1);\n-            return self.tcx().mk_box(substs.types[0]);\n+            assert_eq!(substs.types().count(), 1);\n+            return self.tcx().mk_box(substs.type_at(0));\n         }\n \n         decl_ty.subst(self.tcx(), substs)\n@@ -1100,15 +1102,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let region_bound = match region_bound {\n             Some(r) => r,\n             None => {\n-                match rscope.object_lifetime_default(span) {\n+                tcx.mk_region(match rscope.object_lifetime_default(span) {\n                     Some(r) => r,\n                     None => {\n                         span_err!(self.tcx().sess, span, E0228,\n                                   \"the lifetime bound for this object type cannot be deduced \\\n                                    from context; please supply an explicit bound\");\n                         ty::ReStatic\n                     }\n-                }\n+                })\n             }\n         };\n \n@@ -1643,7 +1645,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         rscope,\n                         ty::ObjectLifetimeDefault::Specific(r));\n                 let t = self.ast_ty_to_ty(rscope1, &mt.ty);\n-                tcx.mk_ref(tcx.mk_region(r), ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n+                tcx.mk_ref(r, ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n             }\n             hir::TyNever => {\n                 tcx.types.never\n@@ -1801,7 +1803,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         sig: &hir::MethodSig,\n                         untransformed_self_ty: Ty<'tcx>,\n                         anon_scope: Option<AnonTypeScope>)\n-                        -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n+                        -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory<'tcx>) {\n         self.ty_of_method_or_bare_fn(sig.unsafety,\n                                      sig.abi,\n                                      Some(untransformed_self_ty),\n@@ -1826,7 +1828,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                decl: &hir::FnDecl,\n                                arg_anon_scope: Option<AnonTypeScope>,\n                                ret_anon_scope: Option<AnonTypeScope>)\n-                               -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory)\n+                               -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory<'tcx>)\n     {\n         debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -1863,7 +1865,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // reference) in the arguments, then any anonymous regions in the output\n         // have that lifetime.\n         let implied_output_region = match explicit_self_category {\n-            ty::ExplicitSelfCategory::ByReference(region, _) => Ok(region),\n+            ty::ExplicitSelfCategory::ByReference(region, _) => Ok(*region),\n             _ => self.find_implied_output_region(&arg_tys, arg_pats)\n         };\n \n@@ -1890,7 +1892,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                rscope: &RegionScope,\n                                untransformed_self_ty: Ty<'tcx>,\n                                explicit_self: &hir::ExplicitSelf)\n-                               -> (Ty<'tcx>, ty::ExplicitSelfCategory)\n+                               -> (Ty<'tcx>, ty::ExplicitSelfCategory<'tcx>)\n     {\n         return match explicit_self.node {\n             SelfKind::Value(..) => {\n@@ -1902,8 +1904,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                              rscope,\n                                              explicit_self.span,\n                                              lifetime);\n-                (self.tcx().mk_ref(\n-                    self.tcx().mk_region(region),\n+                (self.tcx().mk_ref(region,\n                     ty::TypeAndMut {\n                         ty: untransformed_self_ty,\n                         mutbl: mutability\n@@ -1957,7 +1958,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     ty::ExplicitSelfCategory::ByValue\n                 } else {\n                     match explicit_type.sty {\n-                        ty::TyRef(r, mt) => ty::ExplicitSelfCategory::ByReference(*r, mt.mutbl),\n+                        ty::TyRef(r, mt) => ty::ExplicitSelfCategory::ByReference(r, mt.mutbl),\n                         ty::TyBox(_) => ty::ExplicitSelfCategory::ByBox,\n                         _ => ty::ExplicitSelfCategory::ByValue,\n                     }\n@@ -2070,7 +2071,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         explicit_region_bounds: &[&hir::Lifetime],\n         principal_trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n         builtin_bounds: ty::BuiltinBounds)\n-        -> Option<ty::Region> // if None, use the default\n+        -> Option<&'tcx ty::Region> // if None, use the default\n     {\n         let tcx = self.tcx();\n \n@@ -2093,7 +2094,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         if let Err(ErrorReported) =\n                 self.ensure_super_predicates(span, principal_trait_ref.def_id()) {\n-            return Some(ty::ReStatic);\n+            return Some(tcx.mk_region(ty::ReStatic));\n         }\n \n         // No explicit region bound specified. Therefore, examine trait\n@@ -2109,8 +2110,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // If any of the derived region bounds are 'static, that is always\n         // the best choice.\n-        if derived_region_bounds.iter().any(|r| ty::ReStatic == *r) {\n-            return Some(ty::ReStatic);\n+        if derived_region_bounds.iter().any(|&r| ty::ReStatic == *r) {\n+            return Some(tcx.mk_region(ty::ReStatic));\n         }\n \n         // Determine whether there is exactly one unique region in the set\n@@ -2242,7 +2243,7 @@ fn report_lifetime_number_error(tcx: TyCtxt, span: Span, number: usize, expected\n // and return from functions in multiple places.\n #[derive(PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n-    pub region_bounds: Vec<ty::Region>,\n+    pub region_bounds: Vec<&'tcx ty::Region>,\n     pub builtin_bounds: ty::BuiltinBounds,\n     pub trait_bounds: Vec<ty::PolyTraitRef<'tcx>>,\n     pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n@@ -2264,7 +2265,7 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n         for &region_bound in &self.region_bounds {\n             // account for the binder being introduced below; no need to shift `param_ty`\n             // because, at present at least, it can only refer to early-bound regions\n-            let region_bound = ty::fold::shift_region(region_bound, 1);\n+            let region_bound = tcx.mk_region(ty::fold::shift_region(*region_bound, 1));\n             vec.push(ty::Binder(ty::OutlivesPredicate(param_ty, region_bound)).to_predicate());\n         }\n "}, {"sha": "78175c85b19bf3c6533c40039b5ca43b5b46f8e2", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -122,7 +122,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // and T is the expected type.\n                         let region_var = self.next_region_var(infer::PatternRegion(pat.span));\n                         let mt = ty::TypeAndMut { ty: expected, mutbl: mutbl };\n-                        let region_ty = tcx.mk_ref(tcx.mk_region(region_var), mt);\n+                        let region_ty = tcx.mk_ref(region_var, mt);\n \n                         // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n                         // required. However, we use equality, which is stronger. See (*) for\n@@ -220,7 +220,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             let inner_ty = self.next_ty_var();\n                             let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n                             let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                            let rptr_ty = tcx.mk_ref(tcx.mk_region(region), mt);\n+                            let rptr_ty = tcx.mk_ref(region, mt);\n                             self.demand_eqtype(pat.span, expected, rptr_ty);\n                             (rptr_ty, inner_ty)\n                         }"}, {"sha": "19261a2447f9100ed8b7dee42319073e7ad4fdc0", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                 Some(f) => f,\n                 None => return None\n             },\n-            substs: Substs::new_trait(tcx, vec![], vec![], self.cur_ty)\n+            substs: Substs::new_trait(tcx, self.cur_ty, &[])\n         };\n \n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);"}, {"sha": "46e8c27f6d33bbb38e77cc13d249af197c11c99e", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -203,7 +203,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        let arg_param_ty = trait_ref.substs().types[1];\n+        let arg_param_ty = trait_ref.substs().type_at(1);\n         let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n         debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n "}, {"sha": "26a47055289761b72500e2f96258e74d5f1445c8", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -336,7 +336,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 if r_borrow_var.is_none() { // create var lazilly, at most once\n                     let coercion = Coercion(span);\n                     let r = self.next_region_var(coercion);\n-                    r_borrow_var = Some(self.tcx.mk_region(r)); // [4] above\n+                    r_borrow_var = Some(r); // [4] above\n                 }\n                 r_borrow_var.unwrap()\n             };\n@@ -436,8 +436,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n                 let coercion = Coercion(self.origin.span());\n                 let r_borrow = self.next_region_var(coercion);\n-                let region = self.tcx.mk_region(r_borrow);\n-                (mt_a.ty, Some(AutoPtr(region, mt_b.mutbl)))\n+                (mt_a.ty, Some(AutoPtr(r_borrow, mt_b.mutbl)))\n             }\n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n@@ -459,7 +458,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                                          coerce_unsized_did,\n                                                          0,\n                                                          source,\n-                                                         vec![target]));\n+                                                         &[target]));\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where"}, {"sha": "cede9d871ff4d6a77b3f9fccc40457c6e57504c8", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -412,7 +412,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n                ty);\n \n         cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n-                                 ty, ty::ReScope(cx.parent_scope));\n+                                 ty, tcx.mk_region(ty::ReScope(cx.parent_scope)));\n \n         return Ok(());\n     }\n@@ -438,7 +438,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n \n         ty::TyStruct(def, substs) if def.is_phantom_data() => {\n             // PhantomData<T> - behaves identically to T\n-            let ity = substs.types[0];\n+            let ity = substs.type_at(0);\n             iterate_over_potentially_unsafe_regions_in_type(\n                 cx, context, ity, depth+1)\n         }"}, {"sha": "ad48827a1d0397a2547cac9a0a846fb3e4a4a021", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -37,7 +37,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let i_ty = tcx.lookup_item_type(def_id);\n \n     let substs = Substs::for_item(tcx, def_id,\n-                                  |_, _| ty::ReErased,\n+                                  |_, _| tcx.mk_region(ty::ReErased),\n                                   |def, _| tcx.mk_param_from_def(def));\n \n     let fty = tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {"}, {"sha": "be77ca435a18c8f27e580abf1c6c94709c52d599", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     {\n         let (autoref, unsize) = if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n-            let autoref = AutoPtr(self.tcx.mk_region(region), mutbl);\n+            let autoref = AutoPtr(region, mutbl);\n             (Some(autoref), pick.unsize.map(|target| {\n                 target.adjust_for_autoref(self.tcx, Some(autoref))\n             }))\n@@ -327,19 +327,22 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // parameters from the type and those from the method.\n         //\n         // FIXME -- permit users to manually specify lifetimes\n+        let supplied_start = substs.params().len() + method.generics.regions.len();\n         Substs::for_item(self.tcx, method.def_id, |def, _| {\n-            if let Some(&r) = substs.regions.get(def.index as usize) {\n-                r\n+            let i = def.index as usize;\n+            if i < substs.params().len() {\n+                substs.region_at(i)\n             } else {\n                 self.region_var_for_def(self.span, def)\n             }\n         }, |def, cur_substs| {\n-            if let Some(&ty) = substs.types.get(def.index as usize) {\n-                ty\n+            let i = def.index as usize;\n+            if i < substs.params().len() {\n+                substs.type_at(i)\n             } else if supplied_method_types.is_empty() {\n                 self.type_var_for_def(self.span, def, cur_substs)\n             } else {\n-                supplied_method_types[def.index as usize - substs.types.len()]\n+                supplied_method_types[i - supplied_start]\n             }\n         })\n     }"}, {"sha": "a64982cd1bf819efb9ad8960abb7bd9cfe531e3b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -519,17 +519,17 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                        trait_ref.substs,\n                        m);\n                 assert_eq!(m.generics.parent_types as usize,\n-                           trait_ref.substs.types.len());\n+                           trait_ref.substs.types().count());\n                 assert_eq!(m.generics.parent_regions as usize,\n-                           trait_ref.substs.regions.len());\n+                           trait_ref.substs.regions().count());\n             }\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n             // artifacts. This means it is safe to put into the\n             // `WhereClauseCandidate` and (eventually) into the\n             // `WhereClausePick`.\n-            assert!(!trait_ref.substs.types.needs_infer());\n+            assert!(!trait_ref.substs.needs_infer());\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -1220,8 +1220,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // are given do not include type/lifetime parameters for the\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n-        assert_eq!(substs.types.len(), method.generics.parent_types as usize);\n-        assert_eq!(substs.regions.len(), method.generics.parent_regions as usize);\n+        assert_eq!(substs.types().count(), method.generics.parent_types as usize);\n+        assert_eq!(substs.regions().count(), method.generics.parent_regions as usize);\n \n         if self.mode == Mode::Path {\n             return impl_ty;\n@@ -1236,16 +1236,18 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             xform_self_ty.subst(self.tcx, substs)\n         } else {\n             let substs = Substs::for_item(self.tcx, method.def_id, |def, _| {\n-                if let Some(&r) = substs.regions.get(def.index as usize) {\n-                    r\n+                let i = def.index as usize;\n+                if i < substs.params().len() {\n+                    substs.region_at(i)\n                 } else {\n                     // In general, during probe we erase regions. See\n                     // `impl_self_ty()` for an explanation.\n-                    ty::ReErased\n+                    self.tcx.mk_region(ty::ReErased)\n                 }\n             }, |def, cur_substs| {\n-                if let Some(&ty) = substs.types.get(def.index as usize) {\n-                    ty\n+                let i = def.index as usize;\n+                if i < substs.params().len() {\n+                    substs.type_at(i)\n                 } else {\n                     self.type_var_for_def(self.span, def, cur_substs)\n                 }\n@@ -1262,7 +1264,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let impl_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n \n         let substs = Substs::for_item(self.tcx, impl_def_id,\n-                                      |_, _| ty::ReErased,\n+                                      |_, _| self.tcx.mk_region(ty::ReErased),\n                                       |_, _| self.next_ty_var());\n \n         (impl_ty, substs)\n@@ -1324,7 +1326,7 @@ impl<'tcx> Candidate<'tcx> {\n                     // inference variables or other artifacts. This\n                     // means they are safe to put into the\n                     // `WhereClausePick`.\n-                    assert!(!trait_ref.substs().types.needs_infer());\n+                    assert!(!trait_ref.substs().needs_infer());\n \n                     WhereClausePick(trait_ref.clone())\n                 }"}, {"sha": "f9699a55f50687e601c783e7ebd6972ca908efb2", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 self.autoderef(span, ty).any(|(ty, _)| self.probe(|_| {\n                     let fn_once_substs =\n-                        Substs::new_trait(tcx, vec![self.next_ty_var()], vec![], ty);\n+                        Substs::new_trait(tcx, ty, &[self.next_ty_var()]);\n                     let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                     let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                     let obligation = Obligation::misc(span,"}, {"sha": "e972a5ca7fb3894848b2816b77f880e624d6a935", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -770,7 +770,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       }\n       hir::ItemTy(_, ref generics) => {\n         let pty_ty = ccx.tcx.node_id_to_type(it.id);\n-        check_bounds_are_used(ccx, &generics.ty_params, pty_ty);\n+        check_bounds_are_used(ccx, generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n         if m.abi == Abi::RustIntrinsic {\n@@ -1422,13 +1422,13 @@ impl<'a, 'gcx, 'tcx> RegionScope for FnCtxt<'a, 'gcx, 'tcx> {\n         // (and anyway, within a fn body the right region may not even\n         // be something the user can write explicitly, since it might\n         // be some expression).\n-        self.next_region_var(infer::MiscVariable(span))\n+        *self.next_region_var(infer::MiscVariable(span))\n     }\n \n     fn anon_regions(&self, span: Span, count: usize)\n                     -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n         Ok((0..count).map(|_| {\n-            self.next_region_var(infer::MiscVariable(span))\n+            *self.next_region_var(infer::MiscVariable(span))\n         }).collect())\n     }\n }\n@@ -1862,7 +1862,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// outlive the region `r`.\n     pub fn register_region_obligation(&self,\n                                       ty: Ty<'tcx>,\n-                                      region: ty::Region,\n+                                      region: &'tcx ty::Region,\n                                       cause: traits::ObligationCause<'tcx>)\n     {\n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n@@ -1893,13 +1893,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // FIXME(#27579) all uses of this should be migrated to register_wf_obligation eventually\n         let cause = traits::ObligationCause::new(span, self.body_id, code);\n-        self.register_region_obligation(ty, ty::ReEmpty, cause);\n+        self.register_region_obligation(ty, self.tcx.mk_region(ty::ReEmpty), cause);\n     }\n \n     /// Registers obligations that all types appearing in `substs` are well-formed.\n     pub fn add_wf_bounds(&self, substs: &Substs<'tcx>, expr: &hir::Expr)\n     {\n-        for &ty in &substs.types {\n+        for ty in substs.types() {\n             self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n         }\n     }\n@@ -3454,7 +3454,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // value whose address was taken can actually be made to live\n                 // as long as it needs to live.\n                 let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n-                tcx.mk_ref(tcx.mk_region(region), tm)\n+                tcx.mk_ref(region, tm)\n             };\n             self.write_ty(id, oprnd_t);\n           }\n@@ -4242,18 +4242,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.check_path_parameter_count(span, !require_type_space, &mut type_segment);\n         self.check_path_parameter_count(span, true, &mut fn_segment);\n \n+        let (fn_start, has_self) = match (type_segment, fn_segment) {\n+            (_, Some((_, generics))) => {\n+                (generics.parent_count(), generics.has_self)\n+            }\n+            (Some((_, generics)), None) => {\n+                (generics.own_count(), generics.has_self)\n+            }\n+            (None, None) => (0, false)\n+        };\n         let substs = Substs::for_item(self.tcx, def.def_id(), |def, _| {\n             let mut i = def.index as usize;\n-            let type_regions = match (type_segment, fn_segment) {\n-                (_, Some((_, generics))) => generics.parent_regions as usize,\n-                (Some((_, generics)), None) => generics.regions.len(),\n-                (None, None) => 0\n-            };\n \n-            let segment = if i < type_regions {\n+            let segment = if i < fn_start {\n+                i -= has_self as usize;\n                 type_segment\n             } else {\n-                i -= type_regions;\n+                i -= fn_start;\n                 fn_segment\n             };\n             let lifetimes = match segment.map(|(s, _)| &s.parameters) {\n@@ -4269,18 +4274,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }, |def, substs| {\n             let mut i = def.index as usize;\n-            let (type_types, has_self) = match (type_segment, fn_segment) {\n-                (_, Some((_, generics))) => {\n-                    (generics.parent_types as usize, generics.has_self)\n-                }\n-                (Some((_, generics)), None) => {\n-                    (generics.types.len(), generics.has_self)\n-                }\n-                (None, None) => (0, false)\n-            };\n \n-            let can_omit = i >= type_types || !require_type_space;\n-            let segment = if i < type_types {\n+            let can_omit = i >= fn_start || !require_type_space;\n+            let segment = if i < fn_start {\n                 // Handle Self first, so we can adjust the index to match the AST.\n                 if has_self && i == 0 {\n                     return opt_self_ty.unwrap_or_else(|| {\n@@ -4290,7 +4286,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 i -= has_self as usize;\n                 type_segment\n             } else {\n-                i -= type_types;\n+                i -= fn_start;\n                 fn_segment\n             };\n             let types = match segment.map(|(s, _)| &s.parameters) {\n@@ -4299,6 +4295,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 None => &[]\n             };\n \n+            // Skip over the lifetimes in the same segment.\n+            if let Some((_, generics)) = segment {\n+                i -= generics.regions.len();\n+            }\n+\n             let omitted = can_omit && types.is_empty();\n             if let Some(ast_ty) = types.get(i) {\n                 // A provided type parameter.\n@@ -4502,28 +4503,28 @@ pub fn may_break(tcx: TyCtxt, id: ast::NodeId, b: &hir::Block) -> bool {\n }\n \n pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                       tps: &[hir::TyParam],\n+                                       generics: &hir::Generics,\n                                        ty: Ty<'tcx>) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\",\n-           tps.len(),  ty);\n+           generics.ty_params.len(),  ty);\n \n     // make a vector of booleans initially false, set to true when used\n-    if tps.is_empty() { return; }\n-    let mut tps_used = vec![false; tps.len()];\n+    if generics.ty_params.is_empty() { return; }\n+    let mut tps_used = vec![false; generics.ty_params.len()];\n \n     for leaf_ty in ty.walk() {\n         if let ty::TyParam(ParamTy {idx, ..}) = leaf_ty.sty {\n             debug!(\"Found use of ty param num {}\", idx);\n-            tps_used[idx as usize] = true;\n+            tps_used[idx as usize - generics.lifetimes.len()] = true;\n         }\n     }\n \n-    for (i, b) in tps_used.iter().enumerate() {\n-        if !*b {\n-            struct_span_err!(ccx.tcx.sess, tps[i].span, E0091,\n+    for (&used, param) in tps_used.iter().zip(&generics.ty_params) {\n+        if !used {\n+            struct_span_err!(ccx.tcx.sess, param.span, E0091,\n                 \"type parameter `{}` is unused\",\n-                tps[i].name)\n-                .span_label(tps[i].span, &format!(\"unused type parameter\"))\n+                param.name)\n+                .span_label(param.span, &format!(\"unused type parameter\"))\n                 .emit();\n         }\n     }"}, {"sha": "cef2bb07e35ca065991bf0dd4f2f8ee08b0d9358", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 53, "deletions": 54, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -169,7 +169,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n \n-    region_bound_pairs: Vec<(ty::Region, GenericKind<'tcx>)>,\n+    region_bound_pairs: Vec<(&'tcx ty::Region, GenericKind<'tcx>)>,\n \n     free_region_map: FreeRegionMap,\n \n@@ -324,9 +324,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let call_site_scope = self.call_site_scope.unwrap();\n         debug!(\"visit_fn_body body.id {} call_site_scope: {:?}\",\n                body.id, call_site_scope);\n+        let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n         self.type_of_node_must_outlive(infer::CallReturn(span),\n                                        body.id,\n-                                       ty::ReScope(call_site_scope));\n+                                       call_site_region);\n \n         self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n \n@@ -407,8 +408,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             for implication in implied_bounds {\n                 debug!(\"implication: {:?}\", implication);\n                 match implication {\n-                    ImpliedBound::RegionSubRegion(ty::ReFree(free_a),\n-                                                  ty::ReVar(vid_b)) => {\n+                    ImpliedBound::RegionSubRegion(&ty::ReFree(free_a),\n+                                                  &ty::ReVar(vid_b)) => {\n                         self.add_given(free_a, vid_b);\n                     }\n                     ImpliedBound::RegionSubParam(r_a, param_b) => {\n@@ -476,9 +477,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // variable's type enclose at least the variable's scope.\n \n             let var_scope = tcx.region_maps.var_scope(id);\n+            let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n \n             let origin = infer::BindingTypeIsNotValidAtDecl(span);\n-            self.type_of_node_must_outlive(origin, id, ty::ReScope(var_scope));\n+            self.type_of_node_must_outlive(origin, id, var_region);\n \n             let typ = self.resolve_node_type(id);\n             dropck::check_safety_of_destructor_if_necessary(self, typ, span, var_scope);\n@@ -525,7 +527,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // scope of that expression. This also guarantees basic WF.\n         let expr_ty = self.resolve_node_type(expr.id);\n         // the region corresponding to this expression\n-        let expr_region = ty::ReScope(self.tcx.region_maps.node_extent(expr.id));\n+        let expr_region = self.tcx.node_scope_region(expr.id);\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                                expr_ty, expr_region);\n \n@@ -713,7 +715,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n                     None => self.resolve_node_type(base.id)\n                 };\n                 if let ty::TyRef(r_ptr, _) = base_ty.sty {\n-                    self.mk_subregion_due_to_dereference(expr.span, expr_region, *r_ptr);\n+                    self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n                 }\n \n                 intravisit::walk_expr(self, expr);\n@@ -780,9 +782,10 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 let call_site_scope = self.call_site_scope;\n                 debug!(\"visit_expr ExprRet ret_expr.id {} call_site_scope: {:?}\",\n                        ret_expr.id, call_site_scope);\n+                let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n                 self.type_of_node_must_outlive(infer::CallReturn(ret_expr.span),\n                                                ret_expr.id,\n-                                               ty::ReScope(call_site_scope.unwrap()));\n+                                               call_site_region);\n                 intravisit::walk_expr(self, expr);\n             }\n \n@@ -819,7 +822,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             /*From:*/ (&ty::TyRef(from_r, ref from_mt),\n             /*To:  */  &ty::TyRef(to_r, ref to_mt)) => {\n                 // Target cannot outlive source, naturally.\n-                self.sub_regions(infer::Reborrow(cast_expr.span), *to_r, *from_r);\n+                self.sub_regions(infer::Reborrow(cast_expr.span), to_r, from_r);\n                 self.walk_cast(cast_expr, from_mt.ty, to_mt.ty);\n             }\n \n@@ -889,7 +892,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n         let callee_scope = self.tcx.region_maps.node_extent(call_expr.id);\n-        let callee_region = ty::ReScope(callee_scope);\n+        let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n         debug!(\"callee_region={:?}\", callee_region);\n \n@@ -933,8 +936,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                derefs,\n                derefd_ty);\n \n-        let s_deref_expr = self.tcx.region_maps.node_extent(deref_expr.id);\n-        let r_deref_expr = ty::ReScope(s_deref_expr);\n+        let r_deref_expr = self.tcx.node_scope_region(deref_expr.id);\n         for i in 0..derefs {\n             let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n             debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n@@ -989,7 +991,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n             if let ty::TyRef(r_ptr, _) =  derefd_ty.sty {\n                 self.mk_subregion_due_to_dereference(deref_expr.span,\n-                                                     r_deref_expr, *r_ptr);\n+                                                     r_deref_expr, r_ptr);\n             }\n \n             match derefd_ty.builtin_deref(true, ty::NoPreference) {\n@@ -1003,8 +1005,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_subregion_due_to_dereference(&mut self,\n                                            deref_span: Span,\n-                                           minimum_lifetime: ty::Region,\n-                                           maximum_lifetime: ty::Region) {\n+                                           minimum_lifetime: &'tcx ty::Region,\n+                                           maximum_lifetime: &'tcx ty::Region) {\n         self.sub_regions(infer::DerefPointer(deref_span),\n                          minimum_lifetime, maximum_lifetime)\n     }\n@@ -1014,7 +1016,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                                      span: Span) {\n         match cmt.cat {\n             Categorization::Rvalue(region) => {\n-                match region {\n+                match *region {\n                     ty::ReScope(rvalue_scope) => {\n                         let typ = self.resolve_type(cmt.ty);\n                         dropck::check_safety_of_destructor_if_necessary(self,\n@@ -1023,7 +1025,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                                                         rvalue_scope);\n                     }\n                     ty::ReStatic => {}\n-                    region => {\n+                    _ => {\n                         span_bug!(span,\n                                   \"unexpected rvalue region in rvalue \\\n                                    destructor safety checking: `{:?}`\",\n@@ -1049,7 +1051,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             match mt.ty.sty {\n                 ty::TySlice(_) | ty::TyStr => {\n                     self.sub_regions(infer::IndexSlice(index_expr.span),\n-                                     r_index_expr, *r_ptr);\n+                                     self.tcx.mk_region(r_index_expr), r_ptr);\n                 }\n                 _ => {}\n             }\n@@ -1061,7 +1063,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn type_of_node_must_outlive(&mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         id: ast::NodeId,\n-        minimum_lifetime: ty::Region)\n+        minimum_lifetime: &'tcx ty::Region)\n     {\n         let tcx = self.tcx;\n \n@@ -1132,7 +1134,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let mc = mc::MemCategorizationContext::new(self);\n         for arg in args {\n             let arg_ty = self.node_ty(arg.id);\n-            let re_scope = ty::ReScope(body_scope);\n+            let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n             let arg_cmt = mc.cat_rvalue(arg.id, arg.ty.span, re_scope, arg_ty);\n             debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n                    arg_ty,\n@@ -1168,7 +1170,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn link_autoref(&self,\n                     expr: &hir::Expr,\n                     autoderefs: usize,\n-                    autoref: &adjustment::AutoRef)\n+                    autoref: &adjustment::AutoRef<'tcx>)\n     {\n         debug!(\"link_autoref(autoref={:?})\", autoref);\n         let mc = mc::MemCategorizationContext::new(self);\n@@ -1182,8 +1184,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             adjustment::AutoUnsafe(m) => {\n-                let r = ty::ReScope(self.tcx.region_maps.node_extent(expr.id));\n-                self.link_region(expr.span, &r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n+                let r = self.tcx.node_scope_region(expr.id);\n+                self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n         }\n     }\n@@ -1197,8 +1199,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                expr, callee_scope);\n         let mc = mc::MemCategorizationContext::new(self);\n         let expr_cmt = ignore_err!(mc.cat_expr(expr));\n-        let borrow_region = ty::ReScope(callee_scope);\n-        self.link_region(expr.span, &borrow_region, ty::ImmBorrow, expr_cmt);\n+        let borrow_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n+        self.link_region(expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n     }\n \n     /// Like `link_region()`, except that the region is extracted from the type of `id`,\n@@ -1212,9 +1214,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                id, mutbl, cmt_borrowed);\n \n         let rptr_ty = self.resolve_node_type(id);\n-        if let ty::TyRef(&r, _) = rptr_ty.sty {\n+        if let ty::TyRef(r, _) = rptr_ty.sty {\n             debug!(\"rptr_ty={}\",  rptr_ty);\n-            self.link_region(span, &r, ty::BorrowKind::from_mutbl(mutbl),\n+            self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl),\n                              cmt_borrowed);\n         }\n     }\n@@ -1225,14 +1227,14 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// between regions, as explained in `link_reborrowed_region()`.\n     fn link_region(&self,\n                    span: Span,\n-                   borrow_region: &ty::Region,\n+                   borrow_region: &'tcx ty::Region,\n                    borrow_kind: ty::BorrowKind,\n                    borrow_cmt: mc::cmt<'tcx>) {\n         let mut borrow_cmt = borrow_cmt;\n         let mut borrow_kind = borrow_kind;\n \n         let origin = infer::DataBorrowed(borrow_cmt.ty, span);\n-        self.type_must_outlive(origin, borrow_cmt.ty, *borrow_region);\n+        self.type_must_outlive(origin, borrow_cmt.ty, borrow_region);\n \n         loop {\n             debug!(\"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n@@ -1322,10 +1324,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// recurse and process `ref_cmt` (see case 2 above).\n     fn link_reborrowed_region(&self,\n                               span: Span,\n-                              borrow_region: &ty::Region,\n+                              borrow_region: &'tcx ty::Region,\n                               borrow_kind: ty::BorrowKind,\n                               ref_cmt: mc::cmt<'tcx>,\n-                              ref_region: ty::Region,\n+                              ref_region: &'tcx ty::Region,\n                               mut ref_kind: ty::BorrowKind,\n                               note: mc::Note)\n                               -> Option<(mc::cmt<'tcx>, ty::BorrowKind)>\n@@ -1364,7 +1366,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"link_reborrowed_region: {:?} <= {:?}\",\n                borrow_region,\n                ref_region);\n-        self.sub_regions(cause, *borrow_region, ref_region);\n+        self.sub_regions(cause, borrow_region, ref_region);\n \n         // If we end up needing to recurse and establish a region link\n         // with `ref_cmt`, calculate what borrow kind we will end up\n@@ -1436,7 +1438,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                           origin: infer::ParameterOrigin,\n                           substs: &Substs<'tcx>,\n                           expr_span: Span,\n-                          expr_region: ty::Region) {\n+                          expr_region: &'tcx ty::Region) {\n         debug!(\"substs_wf_in_scope(substs={:?}, \\\n                 expr_region={:?}, \\\n                 origin={:?}, \\\n@@ -1445,11 +1447,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let origin = infer::ParameterInScope(origin, expr_span);\n \n-        for &region in &substs.regions {\n+        for region in substs.regions() {\n             self.sub_regions(origin.clone(), expr_region, region);\n         }\n \n-        for &ty in &substs.types {\n+        for ty in substs.types() {\n             let ty = self.resolve_type(ty);\n             self.type_must_outlive(origin.clone(), ty, expr_region);\n         }\n@@ -1461,7 +1463,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     pub fn type_must_outlive(&self,\n                              origin: infer::SubregionOrigin<'tcx>,\n                              ty: Ty<'tcx>,\n-                             region: ty::Region)\n+                             region: &'tcx ty::Region)\n     {\n         let ty = self.resolve_type(ty);\n \n@@ -1479,7 +1481,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn components_must_outlive(&self,\n                                origin: infer::SubregionOrigin<'tcx>,\n                                components: Vec<ty::outlives::Component<'tcx>>,\n-                               region: ty::Region)\n+                               region: &'tcx ty::Region)\n     {\n         for component in components {\n             let origin = origin.clone();\n@@ -1510,7 +1512,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn param_ty_must_outlive(&self,\n                              origin: infer::SubregionOrigin<'tcx>,\n-                             region: ty::Region,\n+                             region: &'tcx ty::Region,\n                              param_ty: ty::ParamTy) {\n         debug!(\"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n                region, param_ty, origin);\n@@ -1522,7 +1524,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn projection_must_outlive(&self,\n                                origin: infer::SubregionOrigin<'tcx>,\n-                               region: ty::Region,\n+                               region: &'tcx ty::Region,\n                                projection_ty: ty::ProjectionTy<'tcx>)\n     {\n         debug!(\"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n@@ -1552,7 +1554,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         // If we know that the projection outlives 'static, then we're\n         // done here.\n-        if env_bounds.contains(&ty::ReStatic) {\n+        if env_bounds.contains(&&ty::ReStatic) {\n             debug!(\"projection_must_outlive: 'static as declared bound\");\n             return;\n         }\n@@ -1575,11 +1577,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         if env_bounds.is_empty() && needs_infer {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n-            for &component_ty in &projection_ty.trait_ref.substs.types {\n+            for component_ty in projection_ty.trait_ref.substs.types() {\n                 self.type_must_outlive(origin.clone(), component_ty, region);\n             }\n \n-            for &r in &projection_ty.trait_ref.substs.regions {\n+            for r in projection_ty.trait_ref.substs.regions() {\n                 self.sub_regions(origin.clone(), region, r);\n             }\n \n@@ -1597,10 +1599,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n             let unique_bound = env_bounds[0];\n             debug!(\"projection_must_outlive: unique declared bound = {:?}\", unique_bound);\n-            if projection_ty.trait_ref.substs.regions\n-                                             .iter()\n-                                             .any(|r| env_bounds.contains(r))\n-            {\n+            if projection_ty.trait_ref.substs.regions().any(|r| env_bounds.contains(&r)) {\n                 debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n                 self.sub_regions(origin.clone(), region, unique_bound);\n                 return;\n@@ -1617,7 +1616,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.verify_generic_bound(origin, generic.clone(), region, verify_bound);\n     }\n \n-    fn type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound {\n+    fn type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n         match ty.sty {\n             ty::TyParam(p) => {\n                 self.param_bound(p)\n@@ -1632,7 +1631,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound {\n+    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n         let param_env = &self.parameter_environment;\n \n         debug!(\"param_bound(param_ty={:?})\",\n@@ -1650,7 +1649,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn projection_declared_bounds(&self,\n                                   span: Span,\n                                   projection_ty: ty::ProjectionTy<'tcx>)\n-                                  -> Vec<ty::Region>\n+                                  -> Vec<&'tcx ty::Region>\n     {\n         // First assemble bounds from where clauses and traits.\n \n@@ -1665,9 +1664,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn projection_bound(&self,\n                         span: Span,\n-                        declared_bounds: Vec<ty::Region>,\n+                        declared_bounds: Vec<&'tcx ty::Region>,\n                         projection_ty: ty::ProjectionTy<'tcx>)\n-                        -> VerifyBound {\n+                        -> VerifyBound<'tcx> {\n         debug!(\"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n                declared_bounds, projection_ty);\n \n@@ -1679,7 +1678,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n     }\n \n-    fn recursive_type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound {\n+    fn recursive_type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n         let mut bounds = vec![];\n \n         for subty in ty.walk_shallow() {\n@@ -1701,7 +1700,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn declared_generic_bounds_from_env(&self, generic: GenericKind<'tcx>)\n-                                        -> Vec<ty::Region>\n+                                        -> Vec<&'tcx ty::Region>\n     {\n         let param_env = &self.parameter_environment;\n \n@@ -1735,7 +1734,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn declared_projection_bounds_from_trait(&self,\n                                              span: Span,\n                                              projection_ty: ty::ProjectionTy<'tcx>)\n-                                             -> Vec<ty::Region>\n+                                             -> Vec<&'tcx ty::Region>\n     {\n         debug!(\"projection_bounds(projection_ty={:?})\",\n                projection_ty);"}, {"sha": "a85e295784e977e5eeab71761fd11ca348ffb7fb", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                         match capture {\n                             ty::UpvarCapture::ByValue => freevar_ty,\n                             ty::UpvarCapture::ByRef(borrow) =>\n-                                tcx.mk_ref(tcx.mk_region(borrow.region),\n+                                tcx.mk_ref(borrow.region,\n                                            ty::TypeAndMut {\n                                                ty: freevar_ty,\n                                                mutbl: borrow.kind.to_mutbl_lossy(),\n@@ -536,7 +536,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n               borrow_id: ast::NodeId,\n               _borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              _loan_region: ty::Region,\n+              _loan_region: &'tcx ty::Region,\n               bk: ty::BorrowKind,\n               _loan_cause: euv::LoanCause)\n     {"}, {"sha": "38ec7ba686f6f5e1b60372fd4af297510e2f8daa", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -416,7 +416,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             ty::ExplicitSelfCategory::Static => return,\n             ty::ExplicitSelfCategory::ByValue => self_ty,\n             ty::ExplicitSelfCategory::ByReference(region, mutability) => {\n-                fcx.tcx.mk_ref(fcx.tcx.mk_region(region), ty::TypeAndMut {\n+                fcx.tcx.mk_ref(region, ty::TypeAndMut {\n                     ty: self_ty,\n                     mutbl: mutability\n                 })\n@@ -457,7 +457,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         let variances = self.tcx().item_variances(item_def_id);\n \n         let mut constrained_parameters: HashSet<_> =\n-            variances.types\n+            variances[ast_generics.lifetimes.len()..]\n                      .iter().enumerate()\n                      .filter(|&(_, &variance)| variance != ty::Bivariant)\n                      .map(|(index, _)| self.param_ty(ast_generics, index))\n@@ -468,22 +468,22 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                          None,\n                                          &mut constrained_parameters);\n \n-        for (index, _) in variances.types.iter().enumerate() {\n-            let param_ty = self.param_ty(ast_generics, index);\n-            if constrained_parameters.contains(&Parameter::Type(param_ty)) {\n-                continue;\n-            }\n-            let span = ast_generics.ty_params[index].span;\n-            self.report_bivariance(span, param_ty.name);\n-        }\n-\n-        for (index, &variance) in variances.regions.iter().enumerate() {\n-            if variance != ty::Bivariant {\n-                continue;\n-            }\n+        for (index, &variance) in variances.iter().enumerate() {\n+            let (span, name) = if index < ast_generics.lifetimes.len() {\n+                if variance != ty::Bivariant {\n+                    continue;\n+                }\n \n-            let span = ast_generics.lifetimes[index].lifetime.span;\n-            let name = ast_generics.lifetimes[index].lifetime.name;\n+                (ast_generics.lifetimes[index].lifetime.span,\n+                 ast_generics.lifetimes[index].lifetime.name)\n+            } else {\n+                let index = index - ast_generics.lifetimes.len();\n+                let param_ty = self.param_ty(ast_generics, index);\n+                if constrained_parameters.contains(&Parameter::Type(param_ty)) {\n+                    continue;\n+                }\n+                (ast_generics.ty_params[index].span, param_ty.name)\n+            };\n             self.report_bivariance(span, name);\n         }\n     }\n@@ -597,7 +597,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Trait impl: take implied bounds from all types that\n                 // appear in the trait reference.\n                 let trait_ref = self.instantiate_type_scheme(span, free_substs, trait_ref);\n-                trait_ref.substs.types.to_vec()\n+                trait_ref.substs.types().collect()\n             }\n \n             None => {"}, {"sha": "3bd0e890bb8119fd4e8bf5196145d9185f1c47a6", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -87,7 +87,7 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     // early-bound versions of them, visible from the\n     // outside of the function. This is needed by, and\n     // only populated if there are any `impl Trait`.\n-    free_to_bound_regions: DefIdMap<ty::Region>\n+    free_to_bound_regions: DefIdMap<&'gcx ty::Region>\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n@@ -102,16 +102,22 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             return wbcx;\n         }\n \n+        let gcx = fcx.tcx.global_tcx();\n         let free_substs = fcx.parameter_environment.free_substs;\n-        for (i, r) in free_substs.regions.iter().enumerate() {\n+        for (i, k) in free_substs.params().iter().enumerate() {\n+            let r = if let Some(r) = k.as_region() {\n+                r\n+            } else {\n+                continue;\n+            };\n             match *r {\n                 ty::ReFree(ty::FreeRegion {\n                     bound_region: ty::BoundRegion::BrNamed(def_id, name, _), ..\n                 }) => {\n-                    let bound_region = ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                    let bound_region = gcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n                         index: i as u32,\n                         name: name,\n-                    });\n+                    }));\n                     wbcx.free_to_bound_regions.insert(def_id, bound_region);\n                 }\n                 _ => {\n@@ -311,9 +317,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             // Convert the type from the function into a type valid outside\n             // the function, by replacing free regions with early-bound ones.\n             let outside_ty = gcx.fold_regions(&inside_ty, &mut false, |r, _| {\n-                match r {\n+                match *r {\n                     // 'static is valid everywhere.\n-                    ty::ReStatic => ty::ReStatic,\n+                    ty::ReStatic => gcx.mk_region(ty::ReStatic),\n \n                     // Free regions that come from early-bound regions are valid.\n                     ty::ReFree(ty::FreeRegion {\n@@ -331,7 +337,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                         span_err!(self.tcx().sess, span, E0564,\n                                   \"only named lifetimes are allowed in `impl Trait`, \\\n                                    but `{}` was found in the type `{}`\", r, inside_ty);\n-                        ty::ReStatic\n+                        gcx.mk_region(ty::ReStatic)\n                     }\n \n                     ty::ReVar(_) |\n@@ -626,12 +632,12 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n         match self.infcx.fully_resolve(&r) {\n             Ok(r) => r,\n             Err(e) => {\n                 self.report_error(e);\n-                ty::ReStatic\n+                self.tcx.mk_region(ty::ReStatic)\n             }\n         }\n     }"}, {"sha": "7d6cee7b3bac16767e64d653f5a727b166f22061", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n             let source = tcx.lookup_item_type(impl_did).ty;\n             let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n-            let target = trait_ref.substs.types[1];\n+            let target = trait_ref.substs.type_at(1);\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n                    source, target);\n \n@@ -413,7 +413,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                     (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n \n                     (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n-                        infcx.sub_regions(infer::RelateObjectBound(span), *r_b, *r_a);\n+                        infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n                         check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n                     }\n \n@@ -498,7 +498,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 // Register an obligation for `A: Trait<B>`.\n                 let cause = traits::ObligationCause::misc(span, impl_node_id);\n                 let predicate = tcx.predicate_for_trait_def(cause, trait_def_id, 0,\n-                                                            source, vec![target]);\n+                                                            source, &[target]);\n                 fulfill_cx.register_predicate_obligation(&infcx, predicate);\n \n                 // Check that all transitive obligations are satisfied."}, {"sha": "0074d3930e29f66402855d86f1df085f2ffa56c0", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -1486,31 +1486,34 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         let has_self = opt_self.is_some();\n         let mut parent_has_self = false;\n+        let mut own_start = has_self as u32;\n         let (parent_regions, parent_types) = parent_def_id.map_or((0, 0), |def_id| {\n             let generics = generics_of_def_id(ccx, def_id);\n             assert_eq!(generics.parent, None);\n             assert_eq!(generics.parent_regions, 0);\n             assert_eq!(generics.parent_types, 0);\n             assert_eq!(has_self, false);\n             parent_has_self = generics.has_self;\n+            own_start = generics.count() as u32;\n             (generics.regions.len() as u32, generics.types.len() as u32)\n         });\n \n         let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n         let regions = early_lifetimes.iter().enumerate().map(|(i, l)| {\n             ty::RegionParameterDef {\n                 name: l.lifetime.name,\n-                index: parent_regions + i as u32,\n+                index: own_start + i as u32,\n                 def_id: tcx.map.local_def_id(l.lifetime.id),\n                 bounds: l.bounds.iter().map(|l| {\n                     ast_region_to_region(tcx, l)\n                 }).collect()\n             }\n-        }).collect();\n+        }).collect::<Vec<_>>();\n \n         // Now create the real type parameters.\n+        let type_start = own_start + regions.len() as u32;\n         let types = ast_generics.ty_params.iter().enumerate().map(|(i, p)| {\n-            let i = parent_types + has_self as u32 + i as u32;\n+            let i = type_start + i as u32;\n             get_or_create_type_parameter_def(ccx, ast_generics, i, p, allow_defaults)\n         });\n         let types: Vec<_> = opt_self.into_iter().chain(types).collect();\n@@ -1529,8 +1532,8 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         tcx.alloc_generics(ty::Generics {\n             parent: parent_def_id,\n-            parent_regions: parent_regions as u32,\n-            parent_types: parent_types as u32,\n+            parent_regions: parent_regions,\n+            parent_types: parent_types,\n             regions: regions,\n             types: types,\n             has_self: has_self || parent_has_self\n@@ -1741,12 +1744,12 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                   -> ty::GenericPredicates<'tcx>\n {\n     let tcx = ccx.tcx;\n-    let (parent_regions, parent_types) = parent.map_or((0, 0), |def_id| {\n+    let parent_count = parent.map_or(0, |def_id| {\n         let generics = generics_of_def_id(ccx, def_id);\n         assert_eq!(generics.parent, None);\n         assert_eq!(generics.parent_regions, 0);\n         assert_eq!(generics.parent_types, 0);\n-        (generics.regions.len() as u32, generics.types.len() as u32)\n+        generics.count() as u32\n     });\n     let ref base_predicates = match parent {\n         Some(def_id) => {\n@@ -1762,10 +1765,29 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     };\n     let mut predicates = super_predicates;\n \n+    // Collect the region predicates that were declared inline as\n+    // well. In the case of parameters declared on a fn or method, we\n+    // have to be careful to only iterate over early-bound regions.\n+    let own_start = parent_count + has_self as u32;\n+    let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n+    for (index, param) in early_lifetimes.iter().enumerate() {\n+        let index = own_start + index as u32;\n+        let region = ccx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+            index: index,\n+            name: param.lifetime.name\n+        }));\n+        for bound in &param.bounds {\n+            let bound_region = ast_region_to_region(ccx.tcx, bound);\n+            let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n+            predicates.push(outlives.to_predicate());\n+        }\n+    }\n+\n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n+    let type_start = own_start + early_lifetimes.len() as u32;\n     for (index, param) in ast_generics.ty_params.iter().enumerate() {\n-        let index = parent_types + has_self as u32 + index as u32;\n+        let index = type_start + index as u32;\n         let param_ty = ty::ParamTy::new(index, param.name).to_ty(ccx.tcx);\n         let bounds = compute_bounds(&ccx.icx(&(base_predicates, ast_generics)),\n                                     param_ty,\n@@ -1776,24 +1798,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         predicates.extend(bounds.predicates(ccx.tcx, param_ty));\n     }\n \n-    // Collect the region predicates that were declared inline as\n-    // well. In the case of parameters declared on a fn or method, we\n-    // have to be careful to only iterate over early-bound regions.\n-    let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n-    for (index, param) in early_lifetimes.iter().enumerate() {\n-        let index = parent_regions + index as u32;\n-        let region =\n-            ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                index: index,\n-                name: param.lifetime.name\n-            });\n-        for bound in &param.bounds {\n-            let bound_region = ast_region_to_region(ccx.tcx, bound);\n-            let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n-            predicates.push(outlives.to_predicate());\n-        }\n-    }\n-\n     // Add in the bounds that appear in the where-clause\n     let where_clause = &ast_generics.where_clause;\n     for predicate in &where_clause.predicates {\n@@ -1919,7 +1923,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                             param_id: ast::NodeId,\n                                             param_bounds: &[hir::TyParamBound],\n                                             where_clause: &hir::WhereClause)\n-                                            -> ty::ObjectLifetimeDefault\n+                                            -> ty::ObjectLifetimeDefault<'tcx>\n {\n     let inline_bounds = from_bounds(ccx, param_bounds);\n     let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n@@ -1937,7 +1941,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n     fn from_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                             bounds: &[hir::TyParamBound])\n-                            -> Vec<ty::Region>\n+                            -> Vec<&'tcx ty::Region>\n     {\n         bounds.iter()\n               .filter_map(|bound| {\n@@ -1954,7 +1958,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     fn from_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                 param_id: ast::NodeId,\n                                 predicates: &[hir::WherePredicate])\n-                                -> Vec<ty::Region>\n+                                -> Vec<&'tcx ty::Region>\n     {\n         predicates.iter()\n                   .flat_map(|predicate| {\n@@ -2126,7 +2130,7 @@ pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n     }\n \n     Substs::for_item(tcx, def_id,\n-                     |def, _| def.to_early_bound_region(),\n+                     |def, _| tcx.mk_region(def.to_early_bound_region()),\n                      |def, _| tcx.mk_param_from_def(def))\n }\n "}, {"sha": "637df52e3cb03e2fb40c6746c7503c4b293796be", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -58,8 +58,8 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region) -> bool {\n-        match r {\n+    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+        match *r {\n             ty::ReEarlyBound(data) => {\n                 self.parameters.push(Parameter::Region(data));\n             }"}, {"sha": "2a989105c9cb49b258c80d1f76e5fd0dd8c8dd21", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -172,7 +172,7 @@ fn write_substs_to_tcx<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                node_id,\n                item_substs);\n \n-        assert!(!item_substs.substs.types.needs_infer());\n+        assert!(!item_substs.substs.needs_infer());\n \n         ccx.tcx.tables.borrow_mut().item_substs.insert(node_id, item_substs);\n     }"}, {"sha": "f5b13c4207d905aaec9066559b8dc0b100140ae8", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -257,12 +257,12 @@ impl RegionScope for BindingRscope {\n /// A scope which overrides the default object lifetime but has no other effect.\n pub struct ObjectLifetimeDefaultRscope<'r> {\n     base_scope: &'r (RegionScope+'r),\n-    default: ty::ObjectLifetimeDefault,\n+    default: ty::ObjectLifetimeDefault<'r>,\n }\n \n impl<'r> ObjectLifetimeDefaultRscope<'r> {\n     pub fn new(base_scope: &'r (RegionScope+'r),\n-               default: ty::ObjectLifetimeDefault)\n+               default: ty::ObjectLifetimeDefault<'r>)\n                -> ObjectLifetimeDefaultRscope<'r>\n     {\n         ObjectLifetimeDefaultRscope {\n@@ -283,7 +283,7 @@ impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n                 Some(self.base_object_lifetime_default(span)),\n \n             ty::ObjectLifetimeDefault::Specific(r) =>\n-                Some(r),\n+                Some(*r),\n         }\n     }\n "}, {"sha": "2cf84b5745af4a0ec0c2e25fd4a84794a473407e", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -26,7 +26,6 @@ use rustc::hir::intravisit::Visitor;\n \n use super::terms::*;\n use super::terms::VarianceTerm::*;\n-use super::terms::ParamKind::*;\n use super::xform::*;\n \n pub struct ConstraintContext<'a, 'tcx: 'a> {\n@@ -209,7 +208,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn declared_variance(&self,\n                          param_def_id: DefId,\n                          item_def_id: DefId,\n-                         kind: ParamKind,\n                          index: usize)\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n@@ -224,11 +222,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n             let variances = self.tcx().item_variances(item_def_id);\n-            let variance = match kind {\n-                TypeParam => variances.types[index],\n-                RegionParam => variances.regions[index],\n-            };\n-            self.constant_term(variance)\n+            self.constant_term(variances[index])\n         }\n     }\n \n@@ -330,7 +324,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyRef(region, ref mt) => {\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, *region, contra);\n+                self.add_constraints_from_region(generics, region, contra);\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n \n@@ -401,8 +395,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyParam(ref data) => {\n                 assert_eq!(generics.parent, None);\n-                assert!((data.idx as usize) < generics.types.len());\n-                let def_id = generics.types[data.idx as usize].def_id;\n+                let mut i = data.idx as usize;\n+                if !generics.has_self || i > 0 {\n+                    i -= generics.regions.len();\n+                }\n+                let def_id = generics.types[i].def_id;\n                 let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 match self.terms_cx.inferred_map.get(&node_id) {\n                     Some(&index) => {\n@@ -449,7 +446,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         for p in type_param_defs {\n             let variance_decl =\n-                self.declared_variance(p.def_id, def_id, TypeParam, p.index as usize);\n+                self.declared_variance(p.def_id, def_id, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_ty = substs.type_for_def(p);\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n@@ -459,7 +456,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         for p in region_param_defs {\n             let variance_decl =\n-                self.declared_variance(p.def_id, def_id, RegionParam, p.index as usize);\n+                self.declared_variance(p.def_id, def_id, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_r = substs.region_for_def(p);\n             self.add_constraints_from_region(generics, substs_r, variance_i);\n@@ -483,13 +480,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n                                    generics: &ty::Generics<'tcx>,\n-                                   region: ty::Region,\n+                                   region: &'tcx ty::Region,\n                                    variance: VarianceTermPtr<'a>) {\n-        match region {\n+        match *region {\n             ty::ReEarlyBound(ref data) => {\n                 assert_eq!(generics.parent, None);\n-                assert!((data.index as usize) < generics.regions.len());\n-                let def_id = generics.regions[data.index as usize].def_id;\n+                let i = data.index as usize - generics.has_self as usize;\n+                let def_id = generics.regions[i].def_id;\n                 let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {\n                     let index = self.inferred_index(node_id);"}, {"sha": "82b63d0cc09377fd015c9bbeb9d6a755ed4689b6", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -21,7 +21,6 @@ use std::rc::Rc;\n use super::constraints::*;\n use super::terms::*;\n use super::terms::VarianceTerm::*;\n-use super::terms::ParamKind::*;\n use super::xform::*;\n \n struct SolveContext<'a, 'tcx: 'a> {\n@@ -109,24 +108,16 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         while index < num_inferred {\n             let item_id = inferred_infos[index].item_id;\n \n-            let mut item_variances = ty::ItemVariances::empty();\n+            let mut item_variances = vec![];\n \n             while index < num_inferred && inferred_infos[index].item_id == item_id {\n                 let info = &inferred_infos[index];\n                 let variance = solutions[index];\n-                debug!(\"Index {} Info {} / {:?} Variance {:?}\",\n-                       index, info.index, info.kind, variance);\n-                match info.kind {\n-                    TypeParam => {\n-                        assert_eq!(item_variances.types.len(), info.index);\n-                        item_variances.types.push(variance);\n-                    }\n-                    RegionParam => {\n-                        assert_eq!(item_variances.regions.len(), info.index);\n-                        item_variances.regions.push(variance);\n-                    }\n-                }\n+                debug!(\"Index {} Info {} Variance {:?}\",\n+                       index, info.index, variance);\n \n+                assert_eq!(item_variances.len(), info.index);\n+                item_variances.push(variance);\n                 index += 1;\n             }\n "}, {"sha": "c0b53787177d5ff9e0e175506de66d525aa3f93d", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -31,7 +31,6 @@ use rustc::hir::intravisit::Visitor;\n use util::nodemap::NodeMap;\n \n use self::VarianceTerm::*;\n-use self::ParamKind::*;\n \n pub type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n@@ -61,7 +60,7 @@ pub struct TermsContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub arena: &'a TypedArena<VarianceTerm<'a>>,\n \n-    pub empty_variances: Rc<ty::ItemVariances>,\n+    pub empty_variances: Rc<Vec<ty::Variance>>,\n \n     // For marker types, UnsafeCell, and other lang items where\n     // variance is hardcoded, records the item-id and the hardcoded\n@@ -76,15 +75,8 @@ pub struct TermsContext<'a, 'tcx: 'a> {\n     pub inferred_infos: Vec<InferredInfo<'a>> ,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub enum ParamKind {\n-    TypeParam,\n-    RegionParam,\n-}\n-\n pub struct InferredInfo<'a> {\n     pub item_id: ast::NodeId,\n-    pub kind: ParamKind,\n     pub index: usize,\n     pub param_id: ast::NodeId,\n     pub term: VarianceTermPtr<'a>,\n@@ -110,7 +102,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n \n         // cache and share the variance struct used for items with\n         // no type/region parameters\n-        empty_variances: Rc::new(ty::ItemVariances::empty())\n+        empty_variances: Rc::new(vec![])\n     };\n \n     // See README.md for a discussion on dep-graph management.\n@@ -162,17 +154,19 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n         let inferreds_on_entry = self.num_inferred();\n \n+        if has_self {\n+            self.add_inferred(item_id, 0, item_id);\n+        }\n+\n         for (i, p) in generics.lifetimes.iter().enumerate() {\n             let id = p.lifetime.id;\n-            self.add_inferred(item_id, RegionParam, i, id);\n+            let i = has_self as usize + i;\n+            self.add_inferred(item_id, i, id);\n         }\n \n-        if has_self {\n-            self.add_inferred(item_id, TypeParam, 0, item_id);\n-        }\n         for (i, p) in generics.ty_params.iter().enumerate() {\n-            let i = has_self as usize + i;\n-            self.add_inferred(item_id, TypeParam, i, p.id);\n+            let i = has_self as usize + generics.lifetimes.len() + i;\n+            self.add_inferred(item_id, i, p.id);\n         }\n \n         // If this item has no type or lifetime parameters,\n@@ -194,14 +188,12 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n     fn add_inferred(&mut self,\n                     item_id: ast::NodeId,\n-                    kind: ParamKind,\n                     index: usize,\n                     param_id: ast::NodeId) {\n         let inf_index = InferredIndex(self.inferred_infos.len());\n         let term = self.arena.alloc(InferredTerm(inf_index));\n         let initial_variance = self.pick_initial_variance(item_id, index);\n         self.inferred_infos.push(InferredInfo { item_id: item_id,\n-                                                kind: kind,\n                                                 index: index,\n                                                 param_id: param_id,\n                                                 term: term,\n@@ -211,13 +203,12 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n         debug!(\"add_inferred(item_path={}, \\\n                 item_id={}, \\\n-                kind={:?}, \\\n                 index={}, \\\n                 param_id={}, \\\n                 inf_index={:?}, \\\n                 initial_variance={:?})\",\n                self.tcx.item_path_str(self.tcx.map.local_def_id(item_id)),\n-               item_id, kind, index, param_id, inf_index,\n+               item_id, index, param_id, inf_index,\n                initial_variance);\n     }\n "}, {"sha": "c8620254b6f42c6696c0adb0568957bf53dccf27", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -642,8 +642,8 @@ impl Clean<TyParamBound> for hir::TyParamBound {\n \n fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: bool,\n                         bindings: Vec<TypeBinding>, substs: &Substs) -> PathParameters {\n-    let lifetimes = substs.regions.iter().filter_map(|v| v.clean(cx)).collect();\n-    let types = substs.types[has_self as usize..].to_vec();\n+    let lifetimes = substs.regions().filter_map(|v| v.clean(cx)).collect();\n+    let types = substs.types().skip(has_self as usize).collect::<Vec<_>>();\n \n     match (trait_did, cx.tcx_opt()) {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n@@ -737,12 +737,11 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         let path = external_path(cx, &tcx.item_name(self.def_id).as_str(),\n                                  Some(self.def_id), true, vec![], self.substs);\n \n-        debug!(\"ty::TraitRef\\n  substs.types: {:?}\\n\",\n-               &self.input_types()[1..]);\n+        debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", self.substs);\n \n         // collect any late bound regions\n         let mut late_bounds = vec![];\n-        for &ty_s in &self.input_types()[1..] {\n+        for ty_s in self.input_types().skip(1) {\n             if let ty::TyTuple(ts) = ty_s.sty {\n                 for &ty_s in ts {\n                     if let ty::TyRef(ref reg, _) = ty_s.sty {\n@@ -775,9 +774,9 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n impl<'tcx> Clean<Option<Vec<TyParamBound>>> for Substs<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Option<Vec<TyParamBound>> {\n         let mut v = Vec::new();\n-        v.extend(self.regions.iter().filter_map(|r| r.clean(cx))\n+        v.extend(self.regions().filter_map(|r| r.clean(cx))\n                      .map(RegionBound));\n-        v.extend(self.types.iter().map(|t| TraitBound(PolyTrait {\n+        v.extend(self.types().map(|t| TraitBound(PolyTrait {\n             trait_: t.clean(cx),\n             lifetimes: vec![]\n         }, hir::TraitBoundModifier::None)));\n@@ -822,7 +821,7 @@ impl Clean<Lifetime> for hir::LifetimeDef {\n     }\n }\n \n-impl Clean<Lifetime> for ty::RegionParameterDef {\n+impl<'tcx> Clean<Lifetime> for ty::RegionParameterDef<'tcx> {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n         Lifetime(self.name.to_string())\n     }\n@@ -914,7 +913,7 @@ impl<'tcx> Clean<WherePredicate> for ty::EquatePredicate<'tcx> {\n     }\n }\n \n-impl Clean<WherePredicate> for ty::OutlivesPredicate<ty::Region, ty::Region> {\n+impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<&'tcx ty::Region, &'tcx ty::Region> {\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         WherePredicate::RegionPredicate {\n@@ -924,7 +923,7 @@ impl Clean<WherePredicate> for ty::OutlivesPredicate<ty::Region, ty::Region> {\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Ty<'tcx>, ty::Region> {\n+impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Ty<'tcx>, &'tcx ty::Region> {\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n "}, {"sha": "ab537f39bf96a268a2c8161ca30e70cce9b0a9ec", "filename": "src/libstd/error.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -54,7 +54,6 @@ use fmt::{self, Debug, Display};\n use marker::Reflect;\n use mem::transmute;\n use num;\n-use raw::TraitObject;\n use str;\n use string;\n \n@@ -326,11 +325,7 @@ impl Error + 'static {\n     pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n         if self.is::<T>() {\n             unsafe {\n-                // Get the raw representation of the trait object\n-                let to: TraitObject = transmute(self);\n-\n-                // Extract the data pointer\n-                Some(&*(to.data as *const T))\n+                Some(&*(self as *const Error as *const T))\n             }\n         } else {\n             None\n@@ -344,11 +339,7 @@ impl Error + 'static {\n     pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n         if self.is::<T>() {\n             unsafe {\n-                // Get the raw representation of the trait object\n-                let to: TraitObject = transmute(self);\n-\n-                // Extract the data pointer\n-                Some(&mut *(to.data as *const T as *mut T))\n+                Some(&mut *(self as *mut Error as *mut T))\n             }\n         } else {\n             None\n@@ -409,13 +400,8 @@ impl Error {\n     pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<Error>> {\n         if self.is::<T>() {\n             unsafe {\n-                // Get the raw representation of the trait object\n-                let raw = Box::into_raw(self);\n-                let to: TraitObject =\n-                    transmute::<*mut Error, TraitObject>(raw);\n-\n-                // Extract the data pointer\n-                Ok(Box::from_raw(to.data as *mut T))\n+                let raw: *mut Error = Box::into_raw(self);\n+                Ok(Box::from_raw(raw as *mut T))\n             }\n         } else {\n             Err(self)"}, {"sha": "26599208ec0091270f6f18767541ae38d92e4c71", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -491,18 +491,7 @@ fn expand_trait_item(ti: ast::TraitItem, fld: &mut MacroExpander)\n pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n     let t = match t.node.clone() {\n         ast::TyKind::Mac(mac) => {\n-            if fld.cx.ecfg.features.unwrap().type_macros {\n-                expand_mac_invoc(mac, None, Vec::new(), t.span, fld)\n-            } else {\n-                feature_gate::emit_feature_err(\n-                    &fld.cx.parse_sess.span_diagnostic,\n-                    \"type_macros\",\n-                    t.span,\n-                    feature_gate::GateIssue::Language,\n-                    \"type macros are experimental\");\n-\n-                DummyResult::raw_ty(t.span)\n-            }\n+            expand_mac_invoc(mac, None, Vec::new(), t.span, fld)\n         }\n         _ => t\n     };"}, {"sha": "dc68e0646346473cca52a5ed9dceadbc296770ea", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -213,9 +213,6 @@ declare_features! (\n     // Allows associated type defaults\n     (active, associated_type_defaults, \"1.2.0\", Some(29661)),\n \n-    // Allows macros to appear in the type position.\n-    (active, type_macros, \"1.3.0\", Some(27245)),\n-\n     // allow `repr(simd)`, and importing the various simd intrinsics\n     (active, repr_simd, \"1.4.0\", Some(27731)),\n \n@@ -321,6 +318,8 @@ declare_features! (\n     // mean anything\n     (accepted, test_accepted_feature, \"1.0.0\", None),\n     (accepted, tuple_indexing, \"1.0.0\", None),\n+    // Allows macros to appear in the type position.\n+    (accepted, type_macros, \"1.13.0\", Some(27245)),\n     (accepted, while_let, \"1.0.0\", None),\n     // Allows `#[deprecated]` attribute\n     (accepted, deprecated, \"1.9.0\", Some(29935))"}, {"sha": "1646246069eadf196251a113fcfb36b772e0f02d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -4087,9 +4087,30 @@ impl<'a> Parser<'a> {\n         if !self.eat(&token::OpenDelim(token::Brace)) {\n             let sp = self.span;\n             let tok = self.this_token_to_string();\n-            return Err(self.span_fatal_help(sp,\n-                                 &format!(\"expected `{{`, found `{}`\", tok),\n-                                 \"place this code inside a block\"));\n+            let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found `{}`\", tok));\n+\n+            // Check to see if the user has written something like\n+            //\n+            //    if (cond)\n+            //      bar;\n+            //\n+            // Which is valid in other languages, but not Rust.\n+            match self.parse_stmt_without_recovery(false) {\n+                Ok(Some(stmt)) => {\n+                    let mut stmt_span = stmt.span;\n+                    // expand the span to include the semicolon, if it exists\n+                    if self.eat(&token::Semi) {\n+                        stmt_span.hi = self.last_span.hi;\n+                    }\n+                    e.span_help(stmt_span, \"try placing this code inside a block\");\n+                }\n+                Err(mut e) => {\n+                    self.recover_stmt_(SemiColonMode::Break);\n+                    e.cancel();\n+                }\n+                _ => ()\n+            }\n+            return Err(e);\n         }\n \n         self.parse_block_tail(lo, BlockCheckMode::Default)"}, {"sha": "fa0b75da999c29127d17e8f42b975f8dda479376", "filename": "src/test/compile-fail/issue-30007.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fissue-30007.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fissue-30007.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30007.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(type_macros)]\n-\n macro_rules! t {\n     () => ( String ; );     //~ ERROR macro expansion ignores token `;`\n }"}, {"sha": "20e5b1d72d3d71a9f8ce4c9e716b1f1362db9f8c", "filename": "src/test/compile-fail/issue-32950.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fissue-32950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fissue-32950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32950.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(type_macros, concat_idents)]\n+#![feature(concat_idents)]\n \n #[derive(Debug)] //~ NOTE in this expansion\n struct Baz<T>("}, {"sha": "4aa0a3023bb109ed5398458c65e258329a1e6928", "filename": "src/test/compile-fail/macro-context.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fmacro-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fmacro-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-context.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(type_macros)]\n-\n // (typeof used because it's surprisingly hard to find an unparsed token after a stmt)\n macro_rules! m {\n     () => ( i ; typeof );   //~ ERROR expected expression, found reserved keyword `typeof`"}, {"sha": "4a6dbf014a1cace35ae973c1daa5cf77ca3bade8", "filename": "src/test/compile-fail/macro-error.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(type_macros)]\n-\n macro_rules! foo {\n     ($a:expr) => $a; //~ ERROR macro rhs must be delimited\n }"}, {"sha": "1f29ff4e05c09811ed29ff33b914baee6b070f8f", "filename": "src/test/compile-fail/missing-block-hint.rs", "status": "renamed", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fmissing-block-hint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fmissing-block-hint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-block-hint.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! Id {\n-    ($T:tt) => ($T);\n-}\n-\n-struct Foo<T> {\n-    x: Id!(T)\n-    //~^ ERROR: type macros are experimental (see issue #27245)\n-}\n-\n fn main() {\n-    let foo = Foo { x: i32 };\n+    {\n+        if (foo) => {} //~ ERROR expected `{`, found `=>`\n+    }\n+    {\n+        if (foo)\n+            bar; //~ ERROR expected `{`, found `bar`\n+                 //^ HELP try placing this code inside a block\n+    }\n }", "previous_filename": "src/test/compile-fail/type-macros-fail.rs"}, {"sha": "f3dcf405a68a6276abc0e99abc36df62e5baef40", "filename": "src/test/compile-fail/privacy/restricted/tuple-struct-fields/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(pub_restricted, type_macros)]\n+#![feature(pub_restricted)]\n \n mod foo {\n     type T = ();"}, {"sha": "3bf8ca30a6c3fe42df1b46936704d56cdce21c24", "filename": "src/test/compile-fail/privacy/restricted/tuple-struct-fields/test2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest2.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(pub_restricted, type_macros)]\n+#![feature(pub_restricted)]\n \n macro_rules! define_struct {\n     ($t:ty) => {"}, {"sha": "febe224fb84dcf14ce2294d6b1940109b13e9843", "filename": "src/test/compile-fail/privacy/restricted/tuple-struct-fields/test3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest3.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(pub_restricted, type_macros)]\n+#![feature(pub_restricted)]\n \n macro_rules! define_struct {\n     ($t:ty) => {"}, {"sha": "f06e3544e575dec1874a39eb9dc1eeb2b735aae0", "filename": "src/test/compile-fail/syntax-extension-minor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(concat_idents, type_macros)]\n+#![feature(concat_idents)]\n \n pub fn main() {\n     struct Foo;"}, {"sha": "7dbfc6ac1257d082732d314232599c32c460cef8", "filename": "src/test/compile-fail/variance-associated-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -20,12 +20,12 @@ trait Trait<'a> {\n }\n \n #[rustc_variance]\n-struct Foo<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[+], regions=[-])\n+struct Foo<'a, T : Trait<'a>> { //~ ERROR [-, +]\n     field: (T, &'a ())\n }\n \n #[rustc_variance]\n-struct Bar<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[o], regions=[o])\n+struct Bar<'a, T : Trait<'a>> { //~ ERROR [o, o]\n     field: <T as Trait<'a>>::Type\n }\n "}, {"sha": "1f54771e3676abd00677dc05b75672c2d619a1ec", "filename": "src/test/compile-fail/variance-object-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -18,7 +18,7 @@ use std::cell::Cell;\n // For better or worse, associated types are invariant, and hence we\n // get an invariant result for `'a`.\n #[rustc_variance]\n-struct Foo<'a> { //~ ERROR regions=[o]\n+struct Foo<'a> { //~ ERROR [o]\n     x: Box<Fn(i32) -> &'a i32 + 'static>\n }\n "}, {"sha": "41d204a541b5ad9b4481dd1fe51abff1d3afb359", "filename": "src/test/compile-fail/variance-region-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -13,11 +13,11 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-trait Foo: 'static { //~ ERROR types=[o]\n+trait Foo: 'static { //~ ERROR [o]\n }\n \n #[rustc_variance]\n-trait Bar<T> { //~ ERROR types=[o, o]\n+trait Bar<T> { //~ ERROR [o, o]\n     fn do_it(&self)\n         where T: 'static;\n }"}, {"sha": "bf46edcfab8b172ffc4affd0eff34f98625e62af", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -16,7 +16,7 @@\n // Regions that just appear in normal spots are contravariant:\n \n #[rustc_variance]\n-struct Test2<'a, 'b, 'c> { //~ ERROR regions=[-, -, -]\n+struct Test2<'a, 'b, 'c> { //~ ERROR [-, -, -]\n     x: &'a isize,\n     y: &'b [isize],\n     c: &'c str\n@@ -25,7 +25,7 @@ struct Test2<'a, 'b, 'c> { //~ ERROR regions=[-, -, -]\n // Those same annotations in function arguments become covariant:\n \n #[rustc_variance]\n-struct Test3<'a, 'b, 'c> { //~ ERROR regions=[+, +, +]\n+struct Test3<'a, 'b, 'c> { //~ ERROR [+, +, +]\n     x: extern \"Rust\" fn(&'a isize),\n     y: extern \"Rust\" fn(&'b [isize]),\n     c: extern \"Rust\" fn(&'c str),\n@@ -34,15 +34,15 @@ struct Test3<'a, 'b, 'c> { //~ ERROR regions=[+, +, +]\n // Mutability induces invariance:\n \n #[rustc_variance]\n-struct Test4<'a, 'b:'a> { //~ ERROR regions=[-, o]\n+struct Test4<'a, 'b:'a> { //~ ERROR [-, o]\n     x: &'a mut &'b isize,\n }\n \n // Mutability induces invariance, even when in a\n // contravariant context:\n \n #[rustc_variance]\n-struct Test5<'a, 'b:'a> { //~ ERROR regions=[+, o]\n+struct Test5<'a, 'b:'a> { //~ ERROR [+, o]\n     x: extern \"Rust\" fn(&'a mut &'b isize),\n }\n \n@@ -52,22 +52,22 @@ struct Test5<'a, 'b:'a> { //~ ERROR regions=[+, o]\n // argument list occurs in an invariant context.\n \n #[rustc_variance]\n-struct Test6<'a, 'b:'a> { //~ ERROR regions=[-, o]\n+struct Test6<'a, 'b:'a> { //~ ERROR [-, o]\n     x: &'a mut extern \"Rust\" fn(&'b isize),\n }\n \n // No uses at all is bivariant:\n \n #[rustc_variance]\n-struct Test7<'a> { //~ ERROR regions=[*]\n+struct Test7<'a> { //~ ERROR [*]\n     //~^ ERROR parameter `'a` is never used\n     x: isize\n }\n \n // Try enums too.\n \n #[rustc_variance]\n-enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[+, -, o]\n+enum Test8<'a, 'b, 'c:'b> { //~ ERROR [+, -, o]\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),"}, {"sha": "e28828f62e52d655f4b65e7888ac9b7d17131b2d", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -15,33 +15,33 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[+, -, o, *]\n+enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR [+, -, o, *]\n     //~^ ERROR parameter `'d` is never used\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n-struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[*, o, -, +]\n+struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR [*, o, -, +]\n     //~^ ERROR parameter `'w` is never used\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n-struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[o, o, *]\n+struct Derived2<'a, 'b:'a, 'c> { //~ ERROR [o, o, *]\n     //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n-struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[o, -, *]\n+struct Derived3<'a:'b, 'b, 'c> { //~ ERROR [o, -, *]\n     //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'b, 'a, 'c>\n }\n \n #[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n-struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[+, -, o]\n+struct Derived4<'a, 'b, 'c:'b> { //~ ERROR [+, -, o]\n     f: Base<'a, 'b, 'c, 'a>\n }\n "}, {"sha": "4c737a7594d260125b4486e257d6820ff89aaed7", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -15,48 +15,48 @@\n // influence variance.\n \n #[rustc_variance]\n-trait Getter<T> { //~ ERROR types=[o, o]\n+trait Getter<T> { //~ ERROR [o, o]\n     fn get(&self) -> T;\n }\n \n #[rustc_variance]\n-trait Setter<T> { //~ ERROR types=[o, o]\n+trait Setter<T> { //~ ERROR [o, o]\n     fn get(&self, T);\n }\n \n #[rustc_variance]\n-struct TestStruct<U,T:Setter<U>> { //~ ERROR types=[+, +]\n+struct TestStruct<U,T:Setter<U>> { //~ ERROR [+, +]\n     t: T, u: U\n }\n \n #[rustc_variance]\n-enum TestEnum<U,T:Setter<U>> {//~ ERROR types=[*, +]\n+enum TestEnum<U,T:Setter<U>> {//~ ERROR [*, +]\n     //~^ ERROR parameter `U` is never used\n     Foo(T)\n }\n \n #[rustc_variance]\n-trait TestTrait<U,T:Setter<U>> { //~ ERROR types=[o, o, o]\n+trait TestTrait<U,T:Setter<U>> { //~ ERROR [o, o, o]\n     fn getter(&self, u: U) -> T;\n }\n \n #[rustc_variance]\n-trait TestTrait2<U> : Getter<U> { //~ ERROR types=[o, o]\n+trait TestTrait2<U> : Getter<U> { //~ ERROR [o, o]\n }\n \n #[rustc_variance]\n-trait TestTrait3<U> { //~ ERROR types=[o, o]\n+trait TestTrait3<U> { //~ ERROR [o, o]\n     fn getter<T:Getter<U>>(&self);\n }\n \n #[rustc_variance]\n-struct TestContraStruct<U,T:Setter<U>> { //~ ERROR types=[*, +]\n+struct TestContraStruct<U,T:Setter<U>> { //~ ERROR [*, +]\n     //~^ ERROR parameter `U` is never used\n     t: T\n }\n \n #[rustc_variance]\n-struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR types=[*, +]\n+struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR [*, +]\n     //~^ ERROR parameter `U` is never used\n     t: T\n }"}, {"sha": "b120588ecab52318f4d014f6ed4230d38dc72246", "filename": "src/test/compile-fail/variance-trait-object-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -21,7 +21,7 @@ use std::mem;\n trait T { fn foo(&self); }\n \n #[rustc_variance]\n-struct TOption<'a> { //~ ERROR regions=[-]\n+struct TOption<'a> { //~ ERROR [-]\n     v: Option<Box<T + 'a>>,\n }\n "}, {"sha": "2df94cc907a9cf88517497712bb4218e90caca3b", "filename": "src/test/compile-fail/variance-types-bounds.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -14,46 +14,46 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-struct TestImm<A, B> { //~ ERROR types=[+, +]\n+struct TestImm<A, B> { //~ ERROR [+, +]\n     x: A,\n     y: B,\n }\n \n #[rustc_variance]\n-struct TestMut<A, B:'static> { //~ ERROR types=[+, o]\n+struct TestMut<A, B:'static> { //~ ERROR [+, o]\n     x: A,\n     y: &'static mut B,\n }\n \n #[rustc_variance]\n-struct TestIndirect<A:'static, B:'static> { //~ ERROR types=[+, o]\n+struct TestIndirect<A:'static, B:'static> { //~ ERROR [+, o]\n     m: TestMut<A, B>\n }\n \n #[rustc_variance]\n-struct TestIndirect2<A:'static, B:'static> { //~ ERROR types=[o, o]\n+struct TestIndirect2<A:'static, B:'static> { //~ ERROR [o, o]\n     n: TestMut<A, B>,\n     m: TestMut<B, A>\n }\n \n #[rustc_variance]\n-trait Getter<A> { //~ ERROR types=[o, o]\n+trait Getter<A> { //~ ERROR [o, o]\n     fn get(&self) -> A;\n }\n \n #[rustc_variance]\n-trait Setter<A> { //~ ERROR types=[o, o]\n+trait Setter<A> { //~ ERROR [o, o]\n     fn set(&mut self, a: A);\n }\n \n #[rustc_variance]\n-trait GetterSetter<A> { //~ ERROR types=[o, o]\n+trait GetterSetter<A> { //~ ERROR [o, o]\n     fn get(&self) -> A;\n     fn set(&mut self, a: A);\n }\n \n #[rustc_variance]\n-trait GetterInTypeBound<A> { //~ ERROR types=[o, o]\n+trait GetterInTypeBound<A> { //~ ERROR [o, o]\n     // Here, the use of `A` in the method bound *does* affect\n     // variance.  Think of it as if the method requested a dictionary\n     // for `T:Getter<A>`.  Since this dictionary is an input, it is\n@@ -63,12 +63,12 @@ trait GetterInTypeBound<A> { //~ ERROR types=[o, o]\n }\n \n #[rustc_variance]\n-trait SetterInTypeBound<A> { //~ ERROR types=[o, o]\n+trait SetterInTypeBound<A> { //~ ERROR [o, o]\n     fn do_it<T:Setter<A>>(&self);\n }\n \n #[rustc_variance]\n-struct TestObject<A, R> { //~ ERROR types=[o, o]\n+struct TestObject<A, R> { //~ ERROR [o, o]\n     n: Box<Setter<A>+Send>,\n     m: Box<Getter<R>+Send>,\n }"}, {"sha": "7667972c9d251edcd9d8e85115fb05b848c1e4fc", "filename": "src/test/compile-fail/variance-types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -17,32 +17,32 @@ use std::cell::Cell;\n // not considered bivariant.\n \n #[rustc_variance]\n-struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR types=[o, o], regions=[-]\n+struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR [-, o, o]\n     t: &'a mut (A,B)\n }\n \n #[rustc_variance]\n-struct InvariantCell<A> { //~ ERROR types=[o]\n+struct InvariantCell<A> { //~ ERROR [o]\n     t: Cell<A>\n }\n \n #[rustc_variance]\n-struct InvariantIndirect<A> { //~ ERROR types=[o]\n+struct InvariantIndirect<A> { //~ ERROR [o]\n     t: InvariantCell<A>\n }\n \n #[rustc_variance]\n-struct Covariant<A> { //~ ERROR types=[+]\n+struct Covariant<A> { //~ ERROR [+]\n     t: A, u: fn() -> A\n }\n \n #[rustc_variance]\n-struct Contravariant<A> { //~ ERROR types=[-]\n+struct Contravariant<A> { //~ ERROR [-]\n     t: fn(A)\n }\n \n #[rustc_variance]\n-enum Enum<A,B,C> { //~ ERROR types=[+, -, o]\n+enum Enum<A,B,C> { //~ ERROR [+, -, o]\n     Foo(Covariant<A>),\n     Bar(Contravariant<B>),\n     Zed(Covariant<C>,Contravariant<C>)"}, {"sha": "2efd9333999b24ca0f83834b7be300b849cb7f19", "filename": "src/test/run-pass/simd-intrinsic-generic-cast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-cast.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, platform_intrinsics, concat_idents,\n-           type_macros, test)]\n+#![feature(repr_simd, platform_intrinsics, concat_idents, test)]\n #![allow(non_camel_case_types)]\n \n extern crate test;"}, {"sha": "84c0983de80c83abfb580d9dedcd2b4f9122ff16", "filename": "src/test/run-pass/type-macros-hlist.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Frun-pass%2Ftype-macros-hlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Frun-pass%2Ftype-macros-hlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-macros-hlist.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(type_macros)]\n-\n use std::ops::*;\n \n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]"}, {"sha": "7d1045cf3f1a82e0950e2298044b30c4dfada22e", "filename": "src/test/run-pass/type-macros-simple.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Frun-pass%2Ftype-macros-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91/src%2Ftest%2Frun-pass%2Ftype-macros-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-macros-simple.rs?ref=099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(type_macros)]\n-\n macro_rules! Tuple {\n     { $A:ty,$B:ty } => { ($A, $B) }\n }"}]}