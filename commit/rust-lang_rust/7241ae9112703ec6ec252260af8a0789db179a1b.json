{"sha": "7241ae9112703ec6ec252260af8a0789db179a1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNDFhZTkxMTI3MDNlYzZlYzI1MjI2MGFmOGEwNzg5ZGIxNzlhMWI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-09-04T00:00:11Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-09-04T16:14:13Z"}, "message": "Support return aggregates in platform intrinsics.\n\nThis also involved adding `[TYPE;N]` syntax and aggregate indexing\nsupport to the generator script: it's the only way to be able to have a\nparameterised intrinsic that returns an aggregate, since one can't refer\nto previous elements of the current aggregate (and that was harder to\nimplement).", "tree": {"sha": "225ed4a7f4c69b6574ed7712d096f6327f375253", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/225ed4a7f4c69b6574ed7712d096f6327f375253"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7241ae9112703ec6ec252260af8a0789db179a1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7241ae9112703ec6ec252260af8a0789db179a1b", "html_url": "https://github.com/rust-lang/rust/commit/7241ae9112703ec6ec252260af8a0789db179a1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7241ae9112703ec6ec252260af8a0789db179a1b/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c19e7b629b42fc2e153893762397a336423e6ec3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c19e7b629b42fc2e153893762397a336423e6ec3", "html_url": "https://github.com/rust-lang/rust/commit/c19e7b629b42fc2e153893762397a336423e6ec3"}], "stats": {"total": 106, "additions": 88, "deletions": 18}, "files": [{"sha": "d1217c1fb2b4a916b8882c5f8ac0ff1ae2172a2b", "filename": "src/etc/platform-intrinsics/generator.py", "status": "modified", "additions": 67, "deletions": 16, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7241ae9112703ec6ec252260af8a0789db179a1b/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "raw_url": "https://github.com/rust-lang/rust/raw/7241ae9112703ec6ec252260af8a0789db179a1b/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py?ref=7241ae9112703ec6ec252260af8a0789db179a1b", "patch": "@@ -19,7 +19,7 @@\n SPEC = re.compile(\n     r'^(?:(?P<void>V)|(?P<id>[iusfIUSF])(?:\\((?P<start>\\d+)-(?P<end>\\d+)\\)|'\n     r'(?P<width>\\d+)(:?/(?P<llvm_width>\\d+))?)'\n-    r'|(?P<reference>\\d+))(?P<modifiers>[vShdnwusDMC]*)(?P<force_width>x\\d+)?'\n+    r'|(?P<reference>\\d+))(?P<index>\\.\\d+)?(?P<modifiers>[vShdnwusfDMC]*)(?P<force_width>x\\d+)?'\n     r'(?:(?P<pointer>Pm|Pc)(?P<llvm_pointer>/.*)?|(?P<bitcast>->.*))?$'\n )\n \n@@ -70,23 +70,32 @@ def lookup(raw):\n                                 {k: lookup(v) for k, v in data.items()})\n \n class PlatformTypeInfo(object):\n-    def __init__(self, llvm_name, properties):\n-        self.properties = properties\n-        self.llvm_name = llvm_name\n+    def __init__(self, llvm_name, properties, elems = None):\n+        if elems is None:\n+            self.properties = properties\n+            self.llvm_name = llvm_name\n+        else:\n+            assert properties is None and llvm_name is None\n+            self.properties = {}\n+            self.elems = elems\n \n     def __repr__(self):\n         return '<PlatformTypeInfo {}, {}>'.format(self.llvm_name, self.properties)\n \n     def __getattr__(self, name):\n         return self.properties[name]\n \n+    def __getitem__(self, idx):\n+        return self.elems[idx]\n+\n     def vectorize(self, length, width_info):\n         props = self.properties.copy()\n         props.update(width_info)\n         return PlatformTypeInfo('v{}{}'.format(length, self.llvm_name), props)\n \n-    def pointer(self):\n-        return PlatformTypeInfo('p0{}'.format(self.llvm_name), self.properties)\n+    def pointer(self, llvm_elem):\n+        name = self.llvm_name if llvm_elem is None else llvm_elem.llvm_name\n+        return PlatformTypeInfo('p0{}'.format(name), self.properties)\n \n BITWIDTH_POINTER = '<pointer>'\n \n@@ -128,6 +137,8 @@ def modify(self, spec, width, previous):\n             return Unsigned(self.bitwidth())\n         elif spec == 's':\n             return Signed(self.bitwidth())\n+        elif spec == 'f':\n+            return Float(self.bitwidth())\n         elif spec == 'w':\n             return self.__class__(self.bitwidth() * 2)\n         elif spec == 'n':\n@@ -283,7 +294,11 @@ def rust_name(self):\n                                self._elem.rust_name())\n \n     def type_info(self, platform_info):\n-        return self._elem.type_info(platform_info).pointer()\n+        if self._llvm_elem is None:\n+            llvm_elem = None\n+        else:\n+            llvm_elem = self._llvm_elem.type_info(platform_info)\n+        return self._elem.type_info(platform_info).pointer(llvm_elem)\n \n     def __eq__(self, other):\n         return isinstance(other, Pointer) and self._const == other._const \\\n@@ -298,6 +313,14 @@ def __init__(self, flatten, elems):\n     def __repr__(self):\n         return '<Aggregate {}>'.format(self._elems)\n \n+    def modify(self, spec, width, previous):\n+        if spec.startswith('.'):\n+            num = int(spec[1:])\n+            return self._elems[num]\n+        else:\n+            print(spec)\n+            raise NotImplementedError()\n+\n     def compiler_ctor(self):\n         return 'agg({}, vec![{}])'.format('true' if self._flatten else 'false',\n                                           ', '.join(elem.compiler_ctor() for elem in self._elems))\n@@ -306,8 +329,7 @@ def rust_name(self):\n         return '({})'.format(', '.join(elem.rust_name() for elem in self._elems))\n \n     def type_info(self, platform_info):\n-        #return PlatformTypeInfo(None, None, self._llvm_name)\n-        return None\n+        return PlatformTypeInfo(None, None, [elem.type_info(platform_info) for elem in self._elems])\n \n     def __eq__(self, other):\n         return isinstance(other, Aggregate) and self._flatten == other._flatten and \\\n@@ -349,7 +371,11 @@ def enumerate(self, width, previous):\n                 id = match.group('id')\n                 reference = match.group('reference')\n \n-                modifiers = list(match.group('modifiers') or '')\n+                modifiers = []\n+                index = match.group('index')\n+                if index is not None:\n+                    modifiers.append(index)\n+                modifiers += list(match.group('modifiers') or '')\n                 force = match.group('force_width')\n                 if force is not None:\n                     modifiers.append(force)\n@@ -407,16 +433,32 @@ def enumerate(self, width, previous):\n                 else:\n                     assert False, 'matched `{}`, but didn\\'t understand it?'.format(spec)\n             elif spec.startswith('('):\n-                assert bitcast is None\n                 if spec.endswith(')'):\n-                    raise NotImplementedError()\n+                    true_spec = spec[1:-1]\n+                    flatten = False\n                 elif spec.endswith(')f'):\n                     true_spec = spec[1:-2]\n                     flatten = True\n+                else:\n+                    assert False, 'found unclosed aggregate `{}`'.format(spec)\n \n                 for elems in itertools.product(*(TypeSpec(subspec).enumerate(width, previous)\n                                                  for subspec in true_spec.split(','))):\n                     yield Aggregate(flatten, elems)\n+            elif spec.startswith('['):\n+                if spec.endswith(']'):\n+                    true_spec = spec[1:-1]\n+                    flatten = False\n+                elif spec.endswith(']f'):\n+                    true_spec = spec[1:-2]\n+                    flatten = True\n+                else:\n+                    assert False, 'found unclosed aggregate `{}`'.format(spec)\n+                elem_spec, count = true_spec.split(';')\n+\n+                count = int(count)\n+                for elem in TypeSpec(elem_spec).enumerate(width, previous):\n+                    yield Aggregate(flatten, [elem] * count)\n             else:\n                 assert False, 'Failed to parse `{}`'.format(spec)\n \n@@ -514,7 +556,7 @@ def parse_args():\n         core_type := void | vector | scalar | aggregate | reference\n \n         modifier := 'v' | 'h' | 'd' | 'n' | 'w' | 'u' | 's' |\n-                     'x' number\n+                     'x' number | '.' number\n         suffix := pointer | bitcast\n         pointer := 'Pm' llvm_pointer? | 'Pc' llvm_pointer?\n         llvm_pointer := '/' type\n@@ -529,7 +571,7 @@ def parse_args():\n         scalar_type := 'U' | 'S' | 'F'\n         llvm_width := '/' number\n \n-        aggregate := '(' (type),* ')' 'f'?\n+        aggregate := '(' (type),* ')' 'f'? | '[' type ';' number ']' 'f'?\n \n         reference := number\n \n@@ -586,6 +628,12 @@ def parse_args():\n         - no `f` corresponds to `declare ... @llvm.foo({float, i32})`.\n         - having an `f` corresponds to `declare ... @llvm.foo(float, i32)`.\n \n+        The `[type;number]` form is a just shorter way to write\n+        `(...)`, except avoids doing a cartesian product of generic\n+        types, e.g. `[S32;2]` is the same as `(S32, S32)`, while\n+        `[I32;2]` is describing just the two types `(S32,S32)` and\n+        `(U32,U32)` (i.e. doesn't include `(S32,U32)`, `(U32,S32)` as\n+        `(I32,I32)` would).\n \n         (Currently aggregates can not contain other aggregates.)\n \n@@ -604,13 +652,16 @@ def parse_args():\n         ### Modifiers\n \n         - 'v': put a scalar into a vector of the current width (u32 -> u32x4, when width == 128)\n+        - 'S': get the scalar element of a vector (u32x4 -> u32)\n         - 'h': half the length of the vector (u32x4 -> u32x2)\n         - 'd': double the length of the vector (u32x2 -> u32x4)\n         - 'n': narrow the element of the vector (u32x4 -> u16x4)\n         - 'w': widen the element of the vector (u16x4 -> u32x4)\n-        - 'u': force an integer (vector or scalar) to be unsigned (i32x4 -> u32x4)\n-        - 's': force an integer (vector or scalar) to be signed (u32x4 -> i32x4)\n+        - 'u': force a number (vector or scalar) to be unsigned int (f32x4 -> u32x4)\n+        - 's': force a number (vector or scalar) to be signed int (u32x4 -> i32x4)\n+        - 'f': force a number (vector or scalar) to be float (u32x4 -> f32x4)\n         - 'x' number: force the type to be a vector of bitwidth `number`.\n+        - '.' number: get the `number`th element of an aggregate\n         - 'D': dereference a pointer (*mut u32 -> u32)\n         - 'C': make a pointer const (*mut u32 -> *const u32)\n         - 'M': make a pointer mut (*const u32 -> *mut u32)"}, {"sha": "bcfd44d8835d7605d257db184fcc2295367b7e9a", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7241ae9112703ec6ec252260af8a0789db179a1b/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7241ae9112703ec6ec252260af8a0789db179a1b/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=7241ae9112703ec6ec252260af8a0789db179a1b", "patch": "@@ -965,7 +965,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         vec![Type::vector(&elem,\n                                           length as u64)]\n                     }\n-                    Aggregate(false, _) => unimplemented!(),\n+                    Aggregate(false, ref contents) => {\n+                        let elems = contents.iter()\n+                                            .map(|t| one(ty_to_type(ccx, t, any_changes_needed)))\n+                                            .collect::<Vec<_>>();\n+                        vec![Type::struct_(ccx, &elems, false)]\n+                    }\n                     Aggregate(true, ref contents) => {\n                         *any_changes_needed = true;\n                         contents.iter()\n@@ -1049,14 +1054,28 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             };\n             assert_eq!(inputs.len(), llargs.len());\n \n-            match intr.definition {\n+            let val = match intr.definition {\n                 intrinsics::IntrinsicDef::Named(name) => {\n                     let f = declare::declare_cfn(ccx,\n                                                  name,\n                                                  Type::func(&inputs, &outputs),\n                                                  tcx.mk_nil());\n                     Call(bcx, f, &llargs, None, call_debug_location)\n                 }\n+            };\n+\n+            match intr.output {\n+                intrinsics::Type::Aggregate(flatten, ref elems) => {\n+                    // the output is a tuple so we need to munge it properly\n+                    assert!(!flatten);\n+\n+                    for i in 0..elems.len() {\n+                        let val = ExtractValue(bcx, val, i);\n+                        Store(bcx, val, StructGEP(bcx, llresult, i));\n+                    }\n+                    C_nil(ccx)\n+                }\n+                _ => val,\n             }\n         }\n     };"}]}