{"sha": "a079ae2599305d6a218e52a384f1cb1077f5ffb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNzlhZTI1OTkzMDVkNmEyMThlNTJhMzg0ZjFjYjEwNzdmNWZmYjE=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-09-02T12:59:14Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-09-02T13:05:27Z"}, "message": "Correct doc comments inside `use_expr_visitor.rs`", "tree": {"sha": "bc1ceb2efba43b4351a8dd8637f087fef7055ad8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc1ceb2efba43b4351a8dd8637f087fef7055ad8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a079ae2599305d6a218e52a384f1cb1077f5ffb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a079ae2599305d6a218e52a384f1cb1077f5ffb1", "html_url": "https://github.com/rust-lang/rust/commit/a079ae2599305d6a218e52a384f1cb1077f5ffb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a079ae2599305d6a218e52a384f1cb1077f5ffb1/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b27ccbc7e1e6a04d749e244a3c13f72ca38e80e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b27ccbc7e1e6a04d749e244a3c13f72ca38e80e7", "html_url": "https://github.com/rust-lang/rust/commit/b27ccbc7e1e6a04d749e244a3c13f72ca38e80e7"}], "stats": {"total": 78, "additions": 39, "deletions": 39}, "files": [{"sha": "ba70006fe96b3bb7a918bbcde28f049addbd7ec0", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a079ae2599305d6a218e52a384f1cb1077f5ffb1/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a079ae2599305d6a218e52a384f1cb1077f5ffb1/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=a079ae2599305d6a218e52a384f1cb1077f5ffb1", "patch": "@@ -21,74 +21,74 @@ use std::iter;\n \n use crate::mem_categorization as mc;\n \n-///////////////////////////////////////////////////////////////////////////\n-// The Delegate trait\n-\n /// This trait defines the callbacks you can expect to receive when\n /// employing the ExprUseVisitor.\n pub trait Delegate<'tcx> {\n-    // The value found at `place` is moved, depending\n-    // on `mode`. Where `diag_expr_id` is the id used for diagnostics for `place`.\n-    //\n-    // Use of a `Copy` type in a ByValue context is considered a use\n-    // by `ImmBorrow` and `borrow` is called instead. This is because\n-    // a shared borrow is the \"minimum access\" that would be needed\n-    // to perform a copy.\n-    //\n-    //\n-    // The parameter `diag_expr_id` indicates the HIR id that ought to be used for\n-    // diagnostics. Around pattern matching such as `let pat = expr`, the diagnostic\n-    // id will be the id of the expression `expr` but the place itself will have\n-    // the id of the binding in the pattern `pat`.\n+    /// The value found at `place` is moved, depending\n+    /// on `mode`. Where `diag_expr_id` is the id used for diagnostics for `place`.\n+    ///\n+    /// Use of a `Copy` type in a ByValue context is considered a use\n+    /// by `ImmBorrow` and `borrow` is called instead. This is because\n+    /// a shared borrow is the \"minimum access\" that would be needed\n+    /// to perform a copy.\n+    ///\n+    ///\n+    /// The parameter `diag_expr_id` indicates the HIR id that ought to be used for\n+    /// diagnostics. Around pattern matching such as `let pat = expr`, the diagnostic\n+    /// id will be the id of the expression `expr` but the place itself will have\n+    /// the id of the binding in the pattern `pat`.\n     fn consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId);\n \n-    // The value found at `place` is being borrowed with kind `bk`.\n-    // `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n+    /// The value found at `place` is being borrowed with kind `bk`.\n+    /// `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n     fn borrow(\n         &mut self,\n         place_with_id: &PlaceWithHirId<'tcx>,\n         diag_expr_id: hir::HirId,\n         bk: ty::BorrowKind,\n     );\n \n-    // The path at `assignee_place` is being assigned to.\n-    // `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n+    /// The path at `assignee_place` is being assigned to.\n+    /// `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId);\n \n-    // The `place` should be a fake read because of specified `cause`.\n+    /// The `place` should be a fake read because of specified `cause`.\n     fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause, diag_expr_id: hir::HirId);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n enum ConsumeMode {\n-    Copy, // reference to x where x has a type that copies\n-    Move, // reference to x where x has a type that moves\n+    /// reference to x where x has a type that copies\n+    Copy,\n+    /// reference to x where x has a type that moves\n+    Move,\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum MutateMode {\n     Init,\n-    JustWrite,    // x = y\n-    WriteAndRead, // x += y\n+    /// Example: `x = y`\n+    JustWrite,\n+    /// Example: `x += y`\n+    WriteAndRead,\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// The ExprUseVisitor type\n-//\n-// This is the code that actually walks the tree.\n+/// The ExprUseVisitor type\n+///\n+/// This is the code that actually walks the tree.\n pub struct ExprUseVisitor<'a, 'tcx> {\n     mc: mc::MemCategorizationContext<'a, 'tcx>,\n     body_owner: LocalDefId,\n     delegate: &'a mut dyn Delegate<'tcx>,\n }\n \n-// If the MC results in an error, it's because the type check\n-// failed (or will fail, when the error is uncovered and reported\n-// during writeback). In this case, we just ignore this part of the\n-// code.\n-//\n-// Note that this macro appears similar to try!(), but, unlike try!(),\n-// it does not propagate the error.\n+/// If the MC results in an error, it's because the type check\n+/// failed (or will fail, when the error is uncovered and reported\n+/// during writeback). In this case, we just ignore this part of the\n+/// code.\n+///\n+/// Note that this macro appears similar to try!(), but, unlike try!(),\n+/// it does not propagate the error.\n macro_rules! return_if_err {\n     ($inp: expr) => {\n         match $inp {\n@@ -537,9 +537,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         self.walk_expr(with_expr);\n     }\n \n-    // Invoke the appropriate delegate calls for anything that gets\n-    // consumed or borrowed as part of the automatic adjustment\n-    // process.\n+    /// Invoke the appropriate delegate calls for anything that gets\n+    /// consumed or borrowed as part of the automatic adjustment\n+    /// process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr<'_>) {\n         let adjustments = self.mc.typeck_results.expr_adjustments(expr);\n         let mut place_with_id = return_if_err!(self.mc.cat_expr_unadjusted(expr));"}]}