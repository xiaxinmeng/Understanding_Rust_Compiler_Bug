{"sha": "ce47d131010f7e91d76f4de2fd9e69a920bbcf23", "node_id": "C_kwDOAAsO6NoAKGNlNDdkMTMxMDEwZjdlOTFkNzZmNGRlMmZkOWU2OWE5MjBiYmNmMjM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-17T10:44:41Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-17T10:44:44Z"}, "message": "Make attribute completions more ast based", "tree": {"sha": "31b5a189703ba8ac8a193d0a3b2e5a7ce84f4b3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31b5a189703ba8ac8a193d0a3b2e5a7ce84f4b3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce47d131010f7e91d76f4de2fd9e69a920bbcf23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce47d131010f7e91d76f4de2fd9e69a920bbcf23", "html_url": "https://github.com/rust-lang/rust/commit/ce47d131010f7e91d76f4de2fd9e69a920bbcf23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce47d131010f7e91d76f4de2fd9e69a920bbcf23/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e329b7742b343413ad248973c3764061d363b76e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e329b7742b343413ad248973c3764061d363b76e", "html_url": "https://github.com/rust-lang/rust/commit/e329b7742b343413ad248973c3764061d363b76e"}], "stats": {"total": 173, "additions": 110, "deletions": 63}, "files": [{"sha": "6abc2a94c415ac371ec5108063feaa2e10c9b350", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ce47d131010f7e91d76f4de2fd9e69a920bbcf23/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce47d131010f7e91d76f4de2fd9e69a920bbcf23/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=ce47d131010f7e91d76f4de2fd9e69a920bbcf23", "patch": "@@ -5,9 +5,10 @@\n \n use hir::HasAttrs;\n use ide_db::helpers::generated_lints::{CLIPPY_LINTS, DEFAULT_LINTS, FEATURES};\n+use itertools::Itertools;\n use once_cell::sync::Lazy;\n-use rustc_hash::{FxHashMap, FxHashSet};\n-use syntax::{algo::non_trivia_sibling, ast, AstNode, Direction, NodeOrToken, SyntaxKind, T};\n+use rustc_hash::FxHashMap;\n+use syntax::{algo::non_trivia_sibling, ast, AstNode, Direction, SyntaxKind, T};\n \n use crate::{\n     context::CompletionContext,\n@@ -303,31 +304,38 @@ const ATTRIBUTES: &[AttrCompletion] = &[\n     .prefer_inner(),\n ];\n \n-fn parse_comma_sep_input(derive_input: ast::TokenTree) -> Option<FxHashSet<String>> {\n-    let (l_paren, r_paren) = derive_input.l_paren_token().zip(derive_input.r_paren_token())?;\n-    let mut input_derives = FxHashSet::default();\n-    let mut tokens = derive_input\n+fn parse_comma_sep_paths(input: ast::TokenTree) -> Option<Vec<ast::Path>> {\n+    let r_paren = input.r_paren_token()?;\n+    let tokens = input\n         .syntax()\n         .children_with_tokens()\n-        .filter_map(NodeOrToken::into_token)\n-        .skip_while(|token| token != &l_paren)\n         .skip(1)\n-        .take_while(|token| token != &r_paren)\n-        .peekable();\n-    let mut input = String::new();\n-    while tokens.peek().is_some() {\n-        for token in tokens.by_ref().take_while(|t| t.kind() != T![,]) {\n-            input.push_str(token.text());\n-        }\n-\n-        if !input.is_empty() {\n-            input_derives.insert(input.trim().to_owned());\n-        }\n-\n-        input.clear();\n-    }\n+        .take_while(|it| it.as_token() != Some(&r_paren));\n+    let input_expressions = tokens.into_iter().group_by(|tok| tok.kind() == T![,]);\n+    Some(\n+        input_expressions\n+            .into_iter()\n+            .filter_map(|(is_sep, group)| (!is_sep).then(|| group))\n+            .filter_map(|mut tokens| ast::Path::parse(&tokens.join(\"\")).ok())\n+            .collect::<Vec<ast::Path>>(),\n+    )\n+}\n \n-    Some(input_derives)\n+fn parse_comma_sep_expr(input: ast::TokenTree) -> Option<Vec<ast::Expr>> {\n+    let r_paren = input.r_paren_token()?;\n+    let tokens = input\n+        .syntax()\n+        .children_with_tokens()\n+        .skip(1)\n+        .take_while(|it| it.as_token() != Some(&r_paren));\n+    let input_expressions = tokens.into_iter().group_by(|tok| tok.kind() == T![,]);\n+    Some(\n+        input_expressions\n+            .into_iter()\n+            .filter_map(|(is_sep, group)| (!is_sep).then(|| group))\n+            .filter_map(|mut tokens| ast::Expr::parse(&tokens.join(\"\")).ok())\n+            .collect::<Vec<ast::Expr>>(),\n+    )\n }\n \n #[test]"}, {"sha": "36758baafc027354d1cfe35fb9a2a0f0fdd88000", "filename": "crates/ide_completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ce47d131010f7e91d76f4de2fd9e69a920bbcf23/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce47d131010f7e91d76f4de2fd9e69a920bbcf23/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=ce47d131010f7e91d76f4de2fd9e69a920bbcf23", "patch": "@@ -2,7 +2,7 @@\n use hir::HasAttrs;\n use itertools::Itertools;\n use rustc_hash::FxHashMap;\n-use syntax::ast;\n+use syntax::{ast, SmolStr};\n \n use crate::{\n     context::CompletionContext,\n@@ -15,26 +15,31 @@ pub(super) fn complete_derive(\n     ctx: &CompletionContext,\n     derive_input: ast::TokenTree,\n ) {\n-    if let Some(existing_derives) = super::parse_comma_sep_input(derive_input) {\n+    if let Some(existing_derives) = super::parse_comma_sep_paths(derive_input) {\n         for (derive, docs) in get_derive_names_in_scope(ctx) {\n+            let label;\n             let (label, lookup) = if let Some(derive_completion) = DEFAULT_DERIVE_COMPLETIONS\n                 .iter()\n                 .find(|derive_completion| derive_completion.label == derive)\n             {\n                 let mut components = vec![derive_completion.label];\n-                components.extend(\n-                    derive_completion\n-                        .dependencies\n+                components.extend(derive_completion.dependencies.iter().filter(|&&dependency| {\n+                    !existing_derives\n                         .iter()\n-                        .filter(|&&dependency| !existing_derives.contains(dependency)),\n-                );\n+                        .filter_map(|it| it.as_single_name_ref())\n+                        .any(|it| it.text() == dependency)\n+                }));\n                 let lookup = components.join(\", \");\n-                let label = components.iter().rev().join(\", \");\n-                (label, Some(lookup))\n-            } else if existing_derives.contains(&derive) {\n+                label = components.iter().rev().join(\", \");\n+                (&*label, Some(lookup))\n+            } else if existing_derives\n+                .iter()\n+                .filter_map(|it| it.as_single_name_ref())\n+                .any(|it| it.text().as_str() == derive)\n+            {\n                 continue;\n             } else {\n-                (derive, None)\n+                (&*derive, None)\n             };\n             let mut item =\n                 CompletionItem::new(CompletionKind::Attribute, ctx.source_range(), label);\n@@ -52,12 +57,12 @@ pub(super) fn complete_derive(\n \n fn get_derive_names_in_scope(\n     ctx: &CompletionContext,\n-) -> FxHashMap<String, Option<hir::Documentation>> {\n+) -> FxHashMap<SmolStr, Option<hir::Documentation>> {\n     let mut result = FxHashMap::default();\n     ctx.process_all_names(&mut |name, scope_def| {\n         if let hir::ScopeDef::MacroDef(mac) = scope_def {\n             if mac.kind() == hir::MacroKind::Derive {\n-                result.insert(name.to_string(), mac.docs(ctx.db));\n+                result.insert(name.to_smol_str(), mac.docs(ctx.db));\n             }\n         }\n     });"}, {"sha": "dffb2d92d3803fdba41d26c2fba5025fd7968efd", "filename": "crates/ide_completion/src/completions/attribute/lint.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ce47d131010f7e91d76f4de2fd9e69a920bbcf23/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce47d131010f7e91d76f4de2fd9e69a920bbcf23/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs?ref=ce47d131010f7e91d76f4de2fd9e69a920bbcf23", "patch": "@@ -14,17 +14,46 @@ pub(super) fn complete_lint(\n     derive_input: ast::TokenTree,\n     lints_completions: &[Lint],\n ) {\n-    if let Some(existing_lints) = super::parse_comma_sep_input(derive_input) {\n-        for lint_completion in\n-            lints_completions.iter().filter(|completion| !existing_lints.contains(completion.label))\n-        {\n-            let mut item = CompletionItem::new(\n-                CompletionKind::Attribute,\n-                ctx.source_range(),\n-                lint_completion.label,\n-            );\n+    if let Some(existing_lints) = super::parse_comma_sep_paths(derive_input) {\n+        for &Lint { label, description } in lints_completions {\n+            let (ex_q, ex_name) = {\n+                // FIXME: change `Lint`'s label to not store a path in it but split the prefix off instead?\n+                let mut parts = label.split(\"::\");\n+                let ns_or_label = match parts.next() {\n+                    Some(it) => it,\n+                    None => continue,\n+                };\n+                let label = parts.next();\n+                match label {\n+                    Some(label) => (Some(ns_or_label), label),\n+                    None => (None, ns_or_label),\n+                }\n+            };\n+            let repr_already_annotated = existing_lints\n+                .iter()\n+                .filter_map(|path| {\n+                    let q = path.qualifier();\n+                    if q.as_ref().and_then(|it| it.qualifier()).is_some() {\n+                        return None;\n+                    }\n+                    Some((q.and_then(|it| it.as_single_name_ref()), path.segment()?.name_ref()?))\n+                })\n+                .any(|(q, name)| {\n+                    let qualifier_matches = match (q, ex_q) {\n+                        (None, None) => true,\n+                        (None, Some(_)) => false,\n+                        (Some(_), None) => false,\n+                        (Some(q), Some(ns)) => q.text() == ns,\n+                    };\n+                    qualifier_matches && name.text() == ex_name\n+                });\n+            if repr_already_annotated {\n+                continue;\n+            }\n+            let mut item =\n+                CompletionItem::new(CompletionKind::Attribute, ctx.source_range(), ex_name);\n             item.kind(CompletionItemKind::Attribute)\n-                .documentation(hir::Documentation::new(lint_completion.description.to_owned()));\n+                .documentation(hir::Documentation::new(description.to_owned()));\n             item.add_to(acc)\n         }\n     }"}, {"sha": "95efe77c06d3c75169927f047d529f3ddfb6dec8", "filename": "crates/ide_completion/src/completions/attribute/repr.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ce47d131010f7e91d76f4de2fd9e69a920bbcf23/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce47d131010f7e91d76f4de2fd9e69a920bbcf23/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs?ref=ce47d131010f7e91d76f4de2fd9e69a920bbcf23", "patch": "@@ -8,29 +8,34 @@ use crate::{\n     Completions,\n };\n \n-pub(super) fn complete_repr(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext,\n-    derive_input: ast::TokenTree,\n-) {\n-    if let Some(existing_reprs) = super::parse_comma_sep_input(derive_input) {\n-        for repr_completion in REPR_COMPLETIONS {\n-            if existing_reprs\n+pub(super) fn complete_repr(acc: &mut Completions, ctx: &CompletionContext, input: ast::TokenTree) {\n+    if let Some(existing_reprs) = super::parse_comma_sep_expr(input) {\n+        for &ReprCompletion { label, snippet, lookup, collides } in REPR_COMPLETIONS {\n+            let repr_already_annotated = existing_reprs\n                 .iter()\n-                .any(|it| repr_completion.label == it || repr_completion.collides.contains(&&**it))\n-            {\n+                .filter_map(|expr| match expr {\n+                    ast::Expr::PathExpr(path) => path.path()?.as_single_name_ref(),\n+                    ast::Expr::CallExpr(call) => match call.expr()? {\n+                        ast::Expr::PathExpr(path) => path.path()?.as_single_name_ref(),\n+                        _ => return None,\n+                    },\n+                    _ => None,\n+                })\n+                .any(|it| {\n+                    let text = it.text();\n+                    label == text || collides.contains(&text.as_str())\n+                });\n+            if repr_already_annotated {\n                 continue;\n             }\n-            let mut item = CompletionItem::new(\n-                CompletionKind::Attribute,\n-                ctx.source_range(),\n-                repr_completion.label,\n-            );\n+\n+            let mut item =\n+                CompletionItem::new(CompletionKind::Attribute, ctx.source_range(), label);\n             item.kind(CompletionItemKind::Attribute);\n-            if let Some(lookup) = repr_completion.lookup {\n+            if let Some(lookup) = lookup {\n                 item.lookup_by(lookup);\n             }\n-            if let Some((snippet, cap)) = repr_completion.snippet.zip(ctx.config.snippet_cap) {\n+            if let Some((snippet, cap)) = snippet.zip(ctx.config.snippet_cap) {\n                 item.insert_snippet(cap, snippet);\n             }\n             item.add_to(acc);"}]}